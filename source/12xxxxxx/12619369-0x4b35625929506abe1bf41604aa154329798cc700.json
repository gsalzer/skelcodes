{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.5.16 <0.5.17;\r\n\r\n// based on MyAdvancedToken8,2017-2021, inspired by parity sampleContract, Consensys-ERC20 and openzepelin\r\n\r\ncontract TokenMaster {\r\n    address internal masterCopy;\r\n\r\n    bytes32 internal name32;\r\n    uint256 private ownerPrices;                                                // buyPrice, sellPrice, owner address\r\n\r\n    mapping(address => uint256)                     private balances;\r\n    mapping(address => mapping(address => uint256)) private allowed;\r\n\r\n    // -------------------------------------------------------------\r\n    \r\n    uint256 constant k_buyPr       = 1 ether / 1000000;                         // price per share\r\n    uint256 constant k_sellPr      = k_buyPr - (k_buyPr/10);\r\n    uint256 constant k_sellBuy     = uint256( (uint256(uint256(k_buyPr)<<160) + uint256(uint256(k_sellPr)<<208)) & k_pMask );\r\n    \r\n    uint256 private _guardCounter  = 1;\r\n    \r\n    uint256 constant contractShare = uint256(1000000*10*2);                     // 10% contract reserve\r\n    uint256 constant contractShare2= uint256(1000000*10*1);\r\n    \r\n    uint256 constant provision     = uint256(1111100*2);                        // 1.11% provision\r\n    uint256 constant provision2    = uint256(1111100*1);\r\n    \r\n    uint256 constant k_aMask       = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant k_sMask       = 0xffffffffffff0000000000000000000000000000000000000000000000000000;\r\n    uint256 constant k_bMask       = 0x000000000000ffffffffffff0000000000000000000000000000000000000000;\r\n    uint256 constant k_mask        = 0x0000000000000000000000000000000000000000000000000000ffffffffffff;\r\n    uint256 constant k_pMask       = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\r\n    uint256 constant k_frozenFlag  = 0x0000000000000000000000000000000000000000000000000000000000000001;\r\n    uint256 constant k_shareMask   = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\r\n\r\n    address constant k_add00       = address(0x0);\r\n    address constant k_provisonRec = address(0x00ec140832E635eF2f5786C60a55cc83eAf8D59d);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event FrozenFunds(address target, bool frozen);\r\n    event Deposit(address from, uint256 value);\r\n    event Deployment(address owner, address theContract);\r\n    event Approval(address indexed owner,address indexed spender,uint256 value);\r\n\r\n    modifier nonReentrant() {\r\n      _guardCounter += 1;\r\n      uint256 localCounter = _guardCounter;\r\n      _;\r\n      require(localCounter == _guardCounter,\"re-entrance attack prohibited. Yeah!\");\r\n    }\r\n    \r\n    function owner() external view returns (address ow) {\r\n      return address(uint160(ownerPrices & k_aMask));\r\n    }\r\n    \r\n    function name() external view returns (string memory) {\r\n      return bytes32ToStr(name32);\r\n    }\r\n    \r\n    function standard() external pure returns (string memory std) {\r\n      return 'ERC-20';\r\n    }\r\n    \r\n    function symbol() external pure returns (string memory sym) {\r\n      return 'shares';\r\n    }\r\n    \r\n    function decimals() external pure returns (uint8 dec) {\r\n      return  2;\r\n    }\r\n    \r\n    function totalSupply() external pure returns (uint256 spl) {\r\n      return 1000000;\r\n    }\r\n    \r\n    function sellPrice() external view returns (uint256 sp) {\r\n      return uint256( (uint256( ownerPrices & k_sMask )>>208) & k_mask );\r\n    }\r\n    \r\n    function buyPrice() external view returns (uint256 bp) {\r\n      return uint256( (uint256( ownerPrices & k_bMask )>>160) & k_mask );\r\n    }\r\n    \r\n    function balanceOf(address tokenOwner) external view returns (uint thebalance) {\r\n      return balances[tokenOwner]>>1;\r\n    }\r\n    \r\n    function frozen(address tokenOwner) external view returns (bool isFrozen) {\r\n      return (uint256(balances[tokenOwner] & k_frozenFlag) > 0);\r\n    }\r\n    \r\n    function tokenAllow(address tokenOwner,address spender) external view returns (uint256 tokens) {\r\n      return allowed[tokenOwner][spender];\r\n    }\r\n    \r\n    function saveOwner(uint256 buyP,uint256 sellP,address own) private pure returns (bytes32 o) {\r\n      return bytes32( uint256(uint256(buyP)<<160) + uint256(uint256(sellP)<<208) + uint256(uint160(own)) );\r\n    }\r\n    \r\n    function char(byte b) private pure returns (byte c) {\r\n        if (uint8(b) < uint8(10)) return byte(uint8(b) + 0x30);\r\n        else return byte(uint8(b) + 0x57);\r\n    }\r\n\r\n    function b_String(bytes32 _bytes32, uint len, bool isString) private pure returns (string memory) {\r\n        uint8 off = 0;\r\n        if (isString) off = 2;\r\n        bytes memory s = new bytes((len*2)+off);\r\n\r\n        if (isString) {\r\n          s[0] = 0x30;\r\n          s[1] = 0x78;\r\n        }\r\n      \r\n        uint8 count = 0;\r\n        \r\n        for (uint i = 0; i < len; i++) {\r\n            byte b = byte(uint8(uint(_bytes32) / (2 ** (8 * ((len-1) - i)))));\r\n            byte hi = byte(uint8(b) / 16);\r\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\r\n            s[off+(2 * i)] = char(hi);\r\n            s[off+(2 * i) + 1] = char(lo);\r\n            count++;\r\n        }\r\n        \r\n        return string(s);\r\n    }\r\n    \r\n    function mb32(bytes memory _data) private pure returns(bytes32 a) {\r\n      assembly {\r\n          a := mload(add(_data, 32))\r\n      }\r\n    }\r\n    \r\n    function bytes32ToStr(bytes32 _b) internal pure returns (string memory)\r\n    { \r\n      bytes memory bArr = new bytes(32); \r\n      for (uint256 i;i<32;i++) { bArr[i] = _b[i]; } \r\n      return string(bArr); \r\n    }  \r\n    \r\n    function approve_v2d(address spender, uint tokens) external {\r\n        require(uint256(balances[msg.sender] & k_frozenFlag)==0,\"account frozen!\");\r\n        require(allowed[msg.sender][spender] == 0, \"approve = 0 required!\");\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n    }\r\n    \r\n    function transfer_G8l(address toReceiver, uint amount) external {\r\n        uint balSender = balances[msg.sender];\r\n        require(uint256(balSender & k_frozenFlag)==0,\"account frozen!\");\r\n        \r\n        require(balSender>>1 >= amount,\"not enough token!\");\r\n        uint bal = balances[toReceiver]>>1;\r\n        require(bal + amount >= bal,\"overflow error!\");\r\n        balances[msg.sender] -= amount<<1;\r\n        balances[toReceiver] += amount<<1;\r\n        \r\n        emit Transfer(msg.sender, toReceiver, amount);\r\n    }\r\n    \r\n    function transferFrom_78S(address from, address toReceiver, uint amount) external {\r\n        require(uint256(balances[msg.sender] & k_frozenFlag)==0,\"account frozen!\");\r\n\r\n        require(allowed[from][msg.sender] >= amount,\"allowance too small\");\r\n        allowed[from][msg.sender] -= amount;\r\n        \r\n        require(balances[from]>>1 >= amount,\"not enough token!\");\r\n        uint bal = balances[toReceiver]>>1;\r\n        require(bal + amount >= bal,\"overflow error!\");\r\n        balances[from] -= amount<<1;\r\n        balances[toReceiver] += amount<<1;\r\n\r\n        emit Transfer(from, toReceiver, amount);\r\n    }\r\n    \r\n    function transferOwnership_m0(address newOwner) external {\r\n        uint256 oPrices = ownerPrices;\r\n        require(msg.sender == address(uint160(oPrices & k_aMask)),\"only owner\");\r\n        ownerPrices =  uint256(oPrices & k_pMask) + uint256(uint160(newOwner));\r\n    }\r\n    \r\n    function freezeAccount_16R(address target, bool freeze) external {\r\n        require(msg.sender == address(uint160(ownerPrices & k_aMask)),\"only owner\");\r\n        uint b = balances[target];\r\n        b = b-uint256(b%2);\r\n        if (!freeze||target==k_provisonRec) balances[target] = uint256(b); else balances[target] = uint256(b+1);\r\n        emit FrozenFunds(target, freeze);\r\n    }\r\n\r\n    function setPrices_7d4(uint256 newSellPrice, uint256 newBuyPrice) external {\r\n        address o = address(uint160(ownerPrices & k_aMask));\r\n        require(msg.sender == o,\"only owner\");\r\n        ownerPrices = uint256(newBuyPrice<<160) + uint256(newSellPrice<<208) + uint256(o);\r\n    }\r\n      \r\n    function buy_uae() payable external nonReentrant {\r\n        require(msg.value>0,\"value 0!\");\r\n        \r\n        uint bal = balances[msg.sender];\r\n        require(uint256(bal & k_frozenFlag)==0,\"account frozen!\");\r\n        \r\n        uint256 ownPrices = ownerPrices;\r\n        uint256 bPrice    = uint256( (uint256( ownPrices & k_bMask )>>160) & k_mask );\r\n        \r\n        require(msg.value>0&&bPrice>0,\"value/price 0\");\r\n        uint amount = uint256(msg.value / bPrice);\r\n        \r\n        require(balances[address(this)]>>1 >= amount,\"not enough token!\");\r\n        require((bal>>1) + (amount<<1) >= (bal>>1),\"overflow error!\");\r\n        balances[address(this)] -= amount<<1;\r\n        balances[msg.sender]    += amount<<1;\r\n\r\n        emit Transfer(address(this), msg.sender, amount);\r\n    }\r\n\r\n    function sell_LA2(uint256 amount) external nonReentrant {\r\n        uint bal = balances[msg.sender];\r\n        require(uint256(bal & k_frozenFlag)==0,\"account frozen!\");\r\n        \r\n        uint256 ownPrices = ownerPrices;\r\n        uint256 sPrice    = uint256( (uint256( ownPrices & k_sMask )>>208) & k_mask );\r\n\r\n        require(amount>0&&sPrice>0,\"value/price 0\");\r\n        require(bal>>1 >= amount,\"not enough token!\");\r\n        \r\n        bal = balances[address(this)]>>1;\r\n        require(bal+amount >= bal,\"overflow error!\");\r\n        balances[msg.sender] -= amount<<1;\r\n        balances[address(this)] += amount<<1;\r\n\r\n        msg.sender.transfer(amount * sPrice);\r\n        emit Transfer(msg.sender, address(this), amount);\r\n    }\r\n    \r\n    function newToken(uint256[] calldata _data) external payable nonReentrant\r\n    {\r\n        uint l = _data.length-1;\r\n        require(l<=31 && l>=2,\"2-31 owners only\");\r\n\r\n        ownerPrices = k_sellBuy + uint256(uint160(msg.sender) & k_aMask);        \r\n        name32      = bytes32(_data[l]);\r\n\r\n        address    iOwner;\r\n        uint256    iShare;\r\n        \r\n        uint i=0;\r\n        do {\r\n          iOwner = address(uint160(_data[i] & k_aMask));\r\n          iShare = uint256(uint256(_data[i] & k_pMask)>>159) & k_shareMask;          \r\n          require((iShare != 0) && (iOwner != k_add00),\"Illegal owner/share in list.\");\r\n          \r\n          balances[iOwner] = iShare;\r\n          emit Transfer(address(this), iOwner, iShare>>1);\r\n          \r\n          i++;\r\n        } while(i<l);\r\n\r\n        balances[address(this)] = contractShare;                                // +10.00% token for proxyToken contract\r\n        emit Transfer(k_add00, address(this), contractShare2);\r\n        \r\n        balances[k_provisonRec] = provision;                                    // + 1.11% token provision\r\n        emit Transfer(k_add00, k_provisonRec, provision2);\r\n    }\r\n\r\n    function() external payable {\r\n      if (msg.value > 0) emit Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    constructor (bytes32 tokenName) public payable\r\n    { \r\n        name32      = tokenName;\r\n        ownerPrices = k_sellBuy + uint256(uint160(msg.sender) & k_aMask);\r\n        emit Deployment(msg.sender, address(this));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenName\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"theContract\",\"type\":\"address\"}],\"name\":\"Deployment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve_v2d\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"thebalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy_uae\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"dec\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount_16R\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"frozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isFrozen\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_data\",\"type\":\"uint256[]\"}],\"name\":\"newToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ow\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell_LA2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSellPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBuyPrice\",\"type\":\"uint256\"}],\"name\":\"setPrices_7d4\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"std\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sym\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"tokenAllow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spl\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom_78S\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership_m0\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer_G8l\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenMaster","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"800000","ConstructorArguments":"546f6b656e4d6173746572436f6e747261637400000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9ac2841350e507a8906b4b76b57e21406fe10e62c38467cf9b345c5227de62bf"}]}