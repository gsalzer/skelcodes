{"status":"1","message":"OK","result":[{"SourceCode":"{\"BojaPublicSale.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.5;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./TransferHelper.sol\\\";\\n\\ninterface oracleInterface {\\n    function latestAnswer() external view returns (int256);\\n}\\n\\ninterface Token {\\n    function decimals() external view returns (uint256);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ncontract BojaPublicSale is Ownable {\\n    using SafeMath for uint256;\\n\\n    uint256 decimalFactor;\\n\\n    address public tokenContractAddress =\\n        0x9D0BbFF00a3961455CcB87E43596c7E846e57e7a;\\n\\n    address public adminAddress = 0xa8Ca8862E2Ef8713dFedff3b5Da69CD5ACd6e638;\\n    address public USDTContractAddress =\\n        0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address public USDCContractAddress =\\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address public ETHOracleAddress =\\n        0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\\n    address public USDTOracleAddress =\\n        0x3E7d1eAB13ad0104d2750B8863b489D65364e32D;\\n    address public USDCOracleAddress =\\n        0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;\\n    address public transferLeftOverAddress =\\n        0xE0Df9d5367CAA8Eb9E250d7587d806aA01a9eD6D;\\n    uint256 public PreSaleStartDate = 1626652800;\\n    uint256 public PreSaleEndDate = 1630022399;\\n\\n    uint256 public ICOStartDate = 1630022400;\\n    uint256 public ICOEndDate = 1634601599;\\n\\n\\n    uint256 PreSaleTokens = 157800181;\\n\\n    uint256 public preSalePrice = 38; // in 10**2..\\n    uint256 public icoPrice = 360; // in 10**2..\\n    uint256 public tokenSold;\\n\\n    event BuyTokenEvent(\\n        address indexed userAdress,\\n        uint256 tokenAmount,\\n        uint256 inputAmount,\\n        uint8 indexed currencyType,\\n        uint256 timestamp\\n    );\\n\\n    constructor() {\\n        PreSaleStartDate = block.timestamp;\\n        decimalFactor = 10**Token(tokenContractAddress).decimals();\\n    }\\n\\n    function buyTokens(uint8 currencyType, uint256 amount) external payable {\\n        //currencyType--\\u003e 1=ETH, currencyType--\\u003e2=USDT, currencyType--\\u003e3=USDC\\n        require(\\n            block.timestamp \\u003e= PreSaleStartDate,\\n            \\\"Presale has not started yet.\\\"\\n        );\\n        require(block.timestamp \\u003c ICOEndDate, \\\"ICO Ended.\\\");\\n        require(\\n            (Token(tokenContractAddress).balanceOf(address(this))) \\u003e 0,\\n            \\\"ICO Ended.\\\"\\n        );\\n        uint256 noOfTOkens;\\n        uint256 inputAmount;\\n        if (currencyType == 1) {\\n            inputAmount = msg.value;\\n        } else if (currencyType == 2) {\\n            Token tokenObj = Token(USDTContractAddress);\\n            require(\\n                tokenObj.balanceOf(msg.sender) \\u003e= amount,\\n                \\\"You do not have enough USDT balance\\\"\\n            );\\n            require(\\n                tokenObj.allowance(msg.sender, address(this)) \\u003e= amount,\\n                \\\"Please allow smart contract to spend on your behalf\\\"\\n            );\\n            inputAmount = amount;\\n        } else {\\n            Token tokenObj = Token(USDCContractAddress);\\n            require(\\n                tokenObj.balanceOf(msg.sender) \\u003e= amount,\\n                \\\"You do not have enough USDT balance\\\"\\n            );\\n            require(\\n                tokenObj.allowance(msg.sender, address(this)) \\u003e= amount,\\n                \\\"Please allow smart contract to spend on your behalf\\\"\\n            );\\n            inputAmount = amount;\\n        }\\n        (noOfTOkens) = calculateToken(currencyType, inputAmount);\\n        require(\\n            (noOfTOkens \\u003c=\\n                Token(tokenContractAddress).balanceOf(address(this))),\\n            \\\"Not enough tokens available to buy.\\\"\\n        );\\n        if (currencyType == 1) {\\n            TransferHelper.safeTransferETH(adminAddress, msg.value);\\n        } else if (currencyType == 2) {\\n            TransferHelper.safeTransferFrom(\\n                USDTContractAddress,\\n                msg.sender,\\n                adminAddress,\\n                amount\\n            );\\n        } else {\\n            TransferHelper.safeTransferFrom(\\n                USDCContractAddress,\\n                msg.sender,\\n                adminAddress,\\n                amount\\n            );\\n        }\\n        TransferHelper.safeTransfer(\\n            tokenContractAddress,\\n            msg.sender,\\n            noOfTOkens\\n        );\\n        tokenSold = tokenSold.add(noOfTOkens);\\n        emit BuyTokenEvent(\\n            msg.sender,\\n            noOfTOkens,\\n            inputAmount,\\n            currencyType,\\n            block.timestamp\\n        );\\n    }\\n\\n    function calculateToken(uint8 currencyType, uint256 amount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        //currencyType--\\u003e 1=ETH, currencyType--\\u003e2=USDT, currencyType--\\u003e3=USDC\\n        require(amount \\u003e 0, \\\"Please enter amount greater than 0.\\\");\\n        uint256 amountInUSD;\\n        uint256 decimalValue;\\n        if (currencyType == 1) {\\n            amountInUSD = (uint256)(\\n                oracleInterface(ETHOracleAddress).latestAnswer()\\n            );\\n            decimalValue = 10**18;\\n        } else if (currencyType == 2) {\\n            amountInUSD = (uint256)(\\n                oracleInterface(USDTOracleAddress).latestAnswer()\\n            );\\n            decimalValue = 10**Token(USDTContractAddress).decimals();\\n        } else if (currencyType == 3) {\\n            amountInUSD = (uint256)(\\n                oracleInterface(USDCOracleAddress).latestAnswer()\\n            );\\n            decimalValue = 10**Token(USDCContractAddress).decimals();\\n        }\\n        uint256 tokenPrice;\\n        if (\\n            block.timestamp \\u003c PreSaleEndDate \\u0026\\u0026\\n            tokenSold \\u003c PreSaleTokens.mul(decimalFactor)\\n        ) {\\n            tokenPrice = preSalePrice;\\n        } else if (\\n            block.timestamp \\u003c PreSaleEndDate \\u0026\\u0026\\n            tokenSold \\u003e PreSaleTokens.mul(decimalFactor)\\n        ) {\\n            tokenPrice = icoPrice;\\n        } else {\\n            tokenPrice = icoPrice;\\n        }\\n        uint256 tokenAmount = (\\n            (amountInUSD.mul(10**2).mul(decimalFactor).mul(amount)).div(\\n                tokenPrice.mul(decimalValue).mul(10**8)\\n            )\\n        );\\n        if (tokenPrice != icoPrice) {\\n            if (tokenSold.add(tokenAmount) \\u003e PreSaleTokens.mul(decimalFactor)) {\\n                uint256 tokenLeftInPresale = (PreSaleTokens.mul(decimalFactor))\\n                .sub(tokenSold);\\n                uint256 amountLeft = amount.sub(\\n                    (\\n                        tokenLeftInPresale.mul(preSalePrice).mul(10**8).mul(\\n                            decimalValue\\n                        )\\n                    )\\n                    .div(decimalFactor.mul(10**2).mul(amountInUSD))\\n                );\\n                uint256 tokenFromICO = (\\n                    (amountInUSD.mul(10**2).mul(decimalFactor).mul(amountLeft))\\n                    .div(icoPrice.mul(decimalValue).mul(10**8))\\n                );\\n                tokenAmount = tokenLeftInPresale.add(tokenFromICO);\\n            }\\n        }\\n        return tokenAmount;\\n    }\\n\\n    function transferAfterICOEnd() external {\\n        require((block.timestamp \\u003e ICOEndDate), \\\"ICO is currently running.\\\");\\n        if (block.timestamp \\u003e ICOEndDate) {\\n            TransferHelper.safeTransfer(\\n                tokenContractAddress,\\n                transferLeftOverAddress,\\n                Token(tokenContractAddress).balanceOf(address(this))\\n            );\\n        }\\n    }\\n\\n    function updateTokenAddress(address _tokenContractAddress)\\n        external\\n        onlyOwner\\n    {\\n        tokenContractAddress = _tokenContractAddress;\\n        decimalFactor = 10**Token(tokenContractAddress).decimals();\\n    }\\n\\n    function updateAdminAddress(address _adminAddress) external onlyOwner {\\n        adminAddress = _adminAddress;\\n    }\\n\\n    function updateTransferLeftOverAddress(address _transferLeftOverAddress)\\n        external\\n        onlyOwner\\n    {\\n        transferLeftOverAddress = _transferLeftOverAddress;\\n    }\\n\\n    function updateUSDTContractAddress(address _USDTContractAddress)\\n        external\\n        onlyOwner\\n    {\\n        USDTContractAddress = _USDTContractAddress;\\n    }\\n\\n    function updateUSDCContractAddress(address _USDCContractAddress)\\n        external\\n        onlyOwner\\n    {\\n        USDCContractAddress = _USDCContractAddress;\\n    }\\n\\n    function updateETHOracleAddress(address _ETHOracleAddress)\\n        external\\n        onlyOwner\\n    {\\n        ETHOracleAddress = _ETHOracleAddress;\\n    }\\n\\n    function updateUSDTOracleAddress(address _USDTOracleAddress)\\n        external\\n        onlyOwner\\n    {\\n        USDTOracleAddress = _USDTOracleAddress;\\n    }\\n\\n    function updateUSDCOracleAddress(address _USDCOracleAddress)\\n        external\\n        onlyOwner\\n    {\\n        USDCOracleAddress = _USDCOracleAddress;\\n    }\\n}\\n\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.5;\\n\\ncontract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.5;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.5;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\n        );\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\n        );\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\n        );\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(\\n            success,\\n            \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\"\\n        );\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAdress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"currencyType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BuyTokenEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETHOracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ICOEndDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ICOStartDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PreSaleEndDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PreSaleStartDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDCContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDCOracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTOracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"currencyType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"currencyType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icoPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferAfterICOEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferLeftOverAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"}],\"name\":\"updateAdminAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ETHOracleAddress\",\"type\":\"address\"}],\"name\":\"updateETHOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"updateTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transferLeftOverAddress\",\"type\":\"address\"}],\"name\":\"updateTransferLeftOverAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_USDCContractAddress\",\"type\":\"address\"}],\"name\":\"updateUSDCContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_USDCOracleAddress\",\"type\":\"address\"}],\"name\":\"updateUSDCOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_USDTContractAddress\",\"type\":\"address\"}],\"name\":\"updateUSDTContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_USDTOracleAddress\",\"type\":\"address\"}],\"name\":\"updateUSDTOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BojaPublicSale","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3091d3dc92d9fbfa2d0d7a7b08d15d4f6a5d727f06f9b916552914e717adc86a"}]}