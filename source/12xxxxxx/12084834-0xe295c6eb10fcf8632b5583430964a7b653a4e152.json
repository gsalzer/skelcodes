{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenGeyser.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport \\\"./roles/Ownable.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\nimport \\\"./TokenPool.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev A smart-contract based mechanism to distribute tokens over time, inspired loosely by Compound and Uniswap.\\r\\n *\\r\\n *  Distribution tokens are added to a locked pool in the contract and become unlocked over time according to a once-configurable unlock schedule. Once unlocked, they are available to be claimed by users.\\r\\n *\\r\\n *  A user may deposit tokens to accrue ownership share over the unlocked pool. This owner share is a function of the number of tokens deposited as well as the length of time deposited.\\r\\n *\\r\\n *  Specifically, a user's share of the currently-unlocked pool equals their \\\"deposit-seconds\\\" divided by the global \\\"deposit-seconds\\\". This aligns the new token distribution with long term supporters of the project, addressing one of the major drawbacks of simple airdrops.\\r\\n *\\r\\n *  More background and motivation available at:\\r\\n *  https://github.com/ampleforth/RFCs/blob/master/RFCs/rfc-1.md\\r\\n */\\r\\ncontract TokenGeyser is IStaking, Ownable\\r\\n{\\r\\n  using SafeMath for uint;\\r\\n\\r\\n\\r\\n  // single stake for user; user may have multiple.\\r\\n  struct Stake\\r\\n  {\\r\\n    uint stakingShares;\\r\\n    uint timestampSec;\\r\\n  }\\r\\n\\r\\n  // caches aggregated values from the User->Stake[] map to save computation.\\r\\n  // if lastAccountingTimestampSec is 0, there's no entry for that user.\\r\\n  struct UserTotals\\r\\n  {\\r\\n    uint stakingShares;\\r\\n    uint stakingShareSeconds;\\r\\n    uint lastAccountingTimestampSec;\\r\\n  }\\r\\n\\r\\n  // locked/unlocked state\\r\\n  struct UnlockSchedule\\r\\n  {\\r\\n    uint initialLockedShares;\\r\\n    uint unlockedShares;\\r\\n    uint lastUnlockTimestampSec;\\r\\n    uint endAtSec;\\r\\n    uint durationSec;\\r\\n  }\\r\\n\\r\\n\\r\\n  TokenPool private _lockedPool;\\r\\n  TokenPool private _unlockedPool;\\r\\n  TokenPool private _stakingPool;\\r\\n\\r\\n  UnlockSchedule[] public unlockSchedules;\\r\\n\\r\\n\\r\\n  // time-bonus params\\r\\n  uint public startBonus = 0;\\r\\n  uint public bonusPeriodSec = 0;\\r\\n  uint public constant BONUS_DECIMALS = 2;\\r\\n\\r\\n\\r\\n  // global accounting state\\r\\n  uint public totalLockedShares = 0;\\r\\n  uint public totalStakingShares = 0;\\r\\n  uint private _maxUnlockSchedules = 0;\\r\\n  uint private _initialSharesPerToken = 0;\\r\\n  uint private _totalStakingShareSeconds = 0;\\r\\n  uint private _lastAccountingTimestampSec = now;\\r\\n\\r\\n\\r\\n  // timestamp ordered stakes for each user, earliest to latest.\\r\\n  mapping(address => Stake[]) private _userStakes;\\r\\n\\r\\n  // staking values per user\\r\\n  mapping(address => UserTotals) private _userTotals;\\r\\n\\r\\n  mapping(address => uint) public initStakeTimestamps;\\r\\n\\r\\n\\r\\n  event Staked(address indexed user, uint amount, uint total, bytes data);\\r\\n  event Unstaked(address indexed user, uint amount, uint total, bytes data);\\r\\n\\r\\n  event TokensClaimed(address indexed user, uint amount);\\r\\n  event TokensLocked(uint amount, uint durationSec, uint total);\\r\\n  event TokensUnlocked(uint amount, uint remainingLocked);\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @param stakingToken The token users deposit as stake.\\r\\n   * @param distributionToken The token users receive as they unstake.\\r\\n   * @param maxUnlockSchedules Max number of unlock stages, to guard against hitting gas limit.\\r\\n   * @param startBonus_ Starting time bonus, BONUS_DECIMALS fixed point. e.g. 25% means user gets 25% of max distribution tokens.\\r\\n   * @param bonusPeriodSec_ Length of time for bonus to increase linearly to max.\\r\\n   * @param initialSharesPerToken Number of shares to mint per staking token on first stake.\\r\\n   */\\r\\n  constructor(IERC20 stakingToken, IERC20 distributionToken, uint maxUnlockSchedules, uint startBonus_, uint bonusPeriodSec_, uint initialSharesPerToken) public\\r\\n  {\\r\\n    // start bonus must be <= 100%\\r\\n    require(startBonus_ <= 10 ** BONUS_DECIMALS, \\\"TokenGeyser: start bonus too high\\\");\\r\\n    // if no period is desired, set startBonus = 100% & bonusPeriod to small val like 1sec.\\r\\n    require(bonusPeriodSec_ != 0, \\\"TokenGeyser: bonus period is 0\\\");\\r\\n    require(initialSharesPerToken > 0, \\\"TokenGeyser: initialSharesPerToken is 0\\\");\\r\\n\\r\\n    _stakingPool = new TokenPool(stakingToken);\\r\\n    _lockedPool = new TokenPool(distributionToken);\\r\\n    _unlockedPool = new TokenPool(distributionToken);\\r\\n\\r\\n    startBonus = startBonus_;\\r\\n    bonusPeriodSec = bonusPeriodSec_;\\r\\n    _maxUnlockSchedules = maxUnlockSchedules;\\r\\n    _initialSharesPerToken = initialSharesPerToken;\\r\\n  }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of unlockable shares from a given schedule. The returned value depends on the time since the last unlock. This function updates schedule accounting, but does not actually transfer any tokens.\\r\\n   *\\r\\n   * @param s Index of the unlock schedule.\\r\\n   *\\r\\n   * @return The number of unlocked shares.\\r\\n   */\\r\\n  function unlockScheduleShares(uint s) private returns (uint)\\r\\n  {\\r\\n    UnlockSchedule storage schedule = unlockSchedules[s];\\r\\n\\r\\n    if (schedule.unlockedShares >= schedule.initialLockedShares)\\r\\n    {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint sharesToUnlock = 0;\\r\\n\\r\\n    // Special case to handle any leftover dust from integer division\\r\\n    if (now >= schedule.endAtSec)\\r\\n    {\\r\\n      sharesToUnlock = (schedule.initialLockedShares.sub(schedule.unlockedShares));\\r\\n      schedule.lastUnlockTimestampSec = schedule.endAtSec;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n      sharesToUnlock = now.sub(schedule.lastUnlockTimestampSec).mul(schedule.initialLockedShares).div(schedule.durationSec);\\r\\n\\r\\n      schedule.lastUnlockTimestampSec = now;\\r\\n    }\\r\\n\\r\\n    schedule.unlockedShares = schedule.unlockedShares.add(sharesToUnlock);\\r\\n\\r\\n    return sharesToUnlock;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Moves distribution tokens from the locked pool to the unlocked pool, according to the previously defined unlock schedules. Publicly callable.\\r\\n   *\\r\\n   * @return Number of newly unlocked distribution tokens.\\r\\n   */\\r\\n  function unlockTokens() public returns (uint)\\r\\n  {\\r\\n    uint unlockedTokens = 0;\\r\\n    uint lockedTokens = totalLocked();\\r\\n\\r\\n    if (totalLockedShares == 0)\\r\\n    {\\r\\n      unlockedTokens = lockedTokens;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n      uint unlockedShares = 0;\\r\\n\\r\\n      for (uint s = 0; s < unlockSchedules.length; s++)\\r\\n      {\\r\\n        unlockedShares = unlockedShares.add(unlockScheduleShares(s));\\r\\n      }\\r\\n\\r\\n      unlockedTokens = unlockedShares.mul(lockedTokens).div(totalLockedShares);\\r\\n      totalLockedShares = totalLockedShares.sub(unlockedShares);\\r\\n    }\\r\\n\\r\\n    if (unlockedTokens > 0)\\r\\n    {\\r\\n      require(_lockedPool.transfer(address(_unlockedPool), unlockedTokens), \\\"TokenGeyser: tx out of locked pool failed\\\");\\r\\n\\r\\n      emit TokensUnlocked(unlockedTokens, totalLocked());\\r\\n    }\\r\\n\\r\\n    return unlockedTokens;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev A globally callable function to update the accounting state of the system.\\r\\n   *      Global state and state for the caller are updated.\\r\\n   *\\r\\n   * @return [0] balance of the locked pool\\r\\n   * @return [1] balance of the unlocked pool\\r\\n   * @return [2] caller's staking share seconds\\r\\n   * @return [3] global staking share seconds\\r\\n   * @return [4] Rewards caller has accumulated, optimistically assumes max time-bonus.\\r\\n   *\\r\\n   * @return [5] block timestamp\\r\\n   */\\r\\n  function updateAccounting() public returns (uint, uint, uint, uint, uint, uint)\\r\\n  {\\r\\n    unlockTokens();\\r\\n\\r\\n\\r\\n    uint newStakingShareSeconds = now.sub(_lastAccountingTimestampSec).mul(totalStakingShares);\\r\\n\\r\\n    _totalStakingShareSeconds = _totalStakingShareSeconds.add(newStakingShareSeconds);\\r\\n    _lastAccountingTimestampSec = now;\\r\\n\\r\\n\\r\\n    UserTotals storage totals = _userTotals[msg.sender];\\r\\n\\r\\n    uint newUserStakingShareSeconds = now.sub(totals.lastAccountingTimestampSec).mul(totals.stakingShares);\\r\\n\\r\\n    totals.stakingShareSeconds = totals.stakingShareSeconds.add(newUserStakingShareSeconds);\\r\\n    totals.lastAccountingTimestampSec = now;\\r\\n\\r\\n    uint totalUserRewards = (_totalStakingShareSeconds > 0) ? totalUnlocked().mul(totals.stakingShareSeconds).div(_totalStakingShareSeconds) : 0;\\r\\n\\r\\n    return (totalLocked(), totalUnlocked(), totals.stakingShareSeconds, _totalStakingShareSeconds, totalUserRewards, now);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev allows the contract owner to add more locked distribution tokens, along with the associated \\\"unlock schedule\\\". These locked tokens immediately begin unlocking linearly over the duration of durationSec timeframe.\\r\\n   *\\r\\n   * @param amount Number of distribution tokens to lock. These are transferred from the caller.\\r\\n   *\\r\\n   * @param durationSec Length of time to linear unlock the tokens.\\r\\n   */\\r\\n  function lockTokens(uint amount, uint durationSec) external onlyOwner\\r\\n  {\\r\\n    require(unlockSchedules.length < _maxUnlockSchedules, \\\"TokenGeyser: reached max unlock schedules\\\");\\r\\n\\r\\n    // update lockedTokens amount before using it in computations after.\\r\\n    updateAccounting();\\r\\n\\r\\n    UnlockSchedule memory schedule;\\r\\n\\r\\n    uint lockedTokens = totalLocked();\\r\\n    uint mintedLockedShares = (lockedTokens > 0) ? totalLockedShares.mul(amount).div(lockedTokens) : amount.mul(_initialSharesPerToken);\\r\\n\\r\\n\\r\\n    schedule.initialLockedShares = mintedLockedShares;\\r\\n    schedule.lastUnlockTimestampSec = now;\\r\\n    schedule.endAtSec = now.add(durationSec);\\r\\n    schedule.durationSec = durationSec;\\r\\n    unlockSchedules.push(schedule);\\r\\n\\r\\n    totalLockedShares = totalLockedShares.add(mintedLockedShares);\\r\\n\\r\\n    require(_lockedPool.token().transferFrom(msg.sender, address(_lockedPool), amount), \\\"TokenGeyser: transfer into locked pool failed\\\");\\r\\n\\r\\n    emit TokensLocked(amount, durationSec, totalLocked());\\r\\n  }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers amount of deposit tokens from the user.\\r\\n   * @param amount Number of deposit tokens to stake.\\r\\n   * @param data Not used.\\r\\n   */\\r\\n  function stake(uint amount, bytes calldata data) external\\r\\n  {\\r\\n    _stakeFor(msg.sender, msg.sender, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers amount of deposit tokens from the caller on behalf of user.\\r\\n   * @param user User address who gains credit for this stake operation.\\r\\n   * @param amount Number of deposit tokens to stake.\\r\\n   * @param data Not used.\\r\\n   */\\r\\n  function stakeFor(address user, uint amount, bytes calldata data) external onlyOwner\\r\\n  {\\r\\n    _stakeFor(msg.sender, user, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Private implementation of staking methods.\\r\\n   * @param staker User address who deposits tokens to stake.\\r\\n   * @param beneficiary User address who gains credit for this stake operation.\\r\\n   * @param amount Number of deposit tokens to stake.\\r\\n   */\\r\\n  function _stakeFor(address staker, address beneficiary, uint amount) private\\r\\n  {\\r\\n    require(amount > 0, \\\"TokenGeyser: stake amt is 0\\\");\\r\\n    require(beneficiary != address(0), \\\"TokenGeyser: beneficiary is 0 addr\\\");\\r\\n    require(totalStakingShares == 0 || totalStaked() > 0, \\\"TokenGeyser: Invalid state. Staking shares exist, but no staking tokens do\\\");\\r\\n\\r\\n\\r\\n    if (initStakeTimestamps[beneficiary] == 0)\\r\\n    {\\r\\n      initStakeTimestamps[beneficiary] = now;\\r\\n    }\\r\\n\\r\\n\\r\\n    uint mintedStakingShares = (totalStakingShares > 0) ? totalStakingShares.mul(amount).div(totalStaked()) : amount.mul(_initialSharesPerToken);\\r\\n\\r\\n\\r\\n    require(mintedStakingShares > 0, \\\"TokenGeyser: Stake too small\\\");\\r\\n\\r\\n    updateAccounting();\\r\\n\\r\\n\\r\\n    UserTotals storage totals = _userTotals[beneficiary];\\r\\n\\r\\n    totals.stakingShares = totals.stakingShares.add(mintedStakingShares);\\r\\n    totals.lastAccountingTimestampSec = now;\\r\\n\\r\\n\\r\\n    Stake memory newStake = Stake(mintedStakingShares, now);\\r\\n\\r\\n    _userStakes[beneficiary].push(newStake);\\r\\n    totalStakingShares = totalStakingShares.add(mintedStakingShares);\\r\\n\\r\\n    require(_stakingPool.token().transferFrom(staker, address(_stakingPool), amount), \\\"TokenGeyser: tx into staking pool failed\\\");\\r\\n\\r\\n    emit Staked(beneficiary, amount, totalStakedFor(beneficiary), \\\"\\\");\\r\\n  }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Applies an additional time-bonus to a distribution amount. This is necessary to encourage long-term deposits instead of constant unstake/restakes.\\r\\n   * The bonus-multiplier is the result of a linear function that starts at startBonus and ends at 100% over bonusPeriodSec, then stays at 100% thereafter.\\r\\n\\r\\n   * @param currentRewardTokens The current number of distribution tokens already allotted for this unstake op. Any bonuses are already applied.\\r\\n\\r\\n   * @param stakingShareSeconds The stakingShare-seconds that are being burned for new distribution tokens.\\r\\n\\r\\n   * @param stakeTimeSec Length of time for which the tokens were staked. Needed to calculate the time-bonus.\\r\\n\\r\\n   * @return Updated amount of distribution tokens to award, with any bonus included on the newly added tokens.\\r\\n   */\\r\\n  function computeNewReward(uint currentRewardTokens, uint stakingShareSeconds, uint stakeTimeSec) private view returns (uint)\\r\\n  {\\r\\n    uint newRewardTokens = totalUnlocked().mul(stakingShareSeconds).div(_totalStakingShareSeconds);\\r\\n\\r\\n    if (stakeTimeSec >= bonusPeriodSec)\\r\\n    {\\r\\n      return currentRewardTokens.add(newRewardTokens);\\r\\n    }\\r\\n\\r\\n    uint oneHundredPct = 10 ** BONUS_DECIMALS;\\r\\n    uint bonusedReward = startBonus.add(oneHundredPct.sub(startBonus).mul(stakeTimeSec).div(bonusPeriodSec)).mul(newRewardTokens).div(oneHundredPct);\\r\\n\\r\\n    return currentRewardTokens.add(bonusedReward);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Unstakes a certain amount of previously deposited tokens. User also receives their allotted number of distribution tokens.\\r\\n   * @param amount Number of deposit tokens to unstake / withdraw.\\r\\n   * @param data Not used.\\r\\n   */\\r\\n  function unstake(uint amount, bytes calldata data) external\\r\\n  {\\r\\n    _unstake(amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @param amount Number of deposit tokens to unstake / withdraw.\\r\\n   * @return The total number of distribution tokens that would be rewarded.\\r\\n   */\\r\\n  function unstakeQuery(uint amount) public returns (uint)\\r\\n  {\\r\\n    return _unstake(amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Unstakes a certain amount of previously deposited tokens. User also receives their allotted number of distribution tokens.\\r\\n   * @param amount Number of deposit tokens to unstake / withdraw.\\r\\n\\r\\n   * @return The total number of distribution tokens rewarded.\\r\\n   */\\r\\n  function _unstake(uint amount) private returns (uint)\\r\\n  {\\r\\n    uint initStakeTimestamp = initStakeTimestamps[msg.sender];\\r\\n\\r\\n    require(now > initStakeTimestamp.add(10 days), \\\"TokenGeyser: in cooldown\\\");\\r\\n\\r\\n    updateAccounting();\\r\\n\\r\\n    require(amount > 0, \\\"TokenGeyser: unstake amt is 0\\\");\\r\\n    require(totalStakedFor(msg.sender) >= amount, \\\"TokenGeyser: unstake amt > total user stakes\\\");\\r\\n\\r\\n    uint stakingSharesToBurn = totalStakingShares.mul(amount).div(totalStaked());\\r\\n\\r\\n    require(stakingSharesToBurn > 0, \\\"TokenGeyser: unstake too small\\\");\\r\\n\\r\\n\\r\\n    UserTotals storage totals = _userTotals[msg.sender];\\r\\n    Stake[] storage accountStakes = _userStakes[msg.sender];\\r\\n\\r\\n    // redeem from most recent stake and go backwards in time.\\r\\n    uint rewardAmount = 0;\\r\\n    uint stakingShareSecondsToBurn = 0;\\r\\n    uint sharesLeftToBurn = stakingSharesToBurn;\\r\\n\\r\\n    while (sharesLeftToBurn > 0)\\r\\n    {\\r\\n      Stake storage lastStake = accountStakes[accountStakes.length - 1];\\r\\n      uint stakeTimeSec = now.sub(lastStake.timestampSec);\\r\\n      uint newStakingShareSecondsToBurn = 0;\\r\\n\\r\\n      if (lastStake.stakingShares <= sharesLeftToBurn)\\r\\n      {\\r\\n        // fully redeem a past stake\\r\\n        newStakingShareSecondsToBurn = lastStake.stakingShares.mul(stakeTimeSec);\\r\\n        rewardAmount = computeNewReward(rewardAmount, newStakingShareSecondsToBurn, stakeTimeSec);\\r\\n        stakingShareSecondsToBurn = stakingShareSecondsToBurn.add(newStakingShareSecondsToBurn);\\r\\n        sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.stakingShares);\\r\\n        accountStakes.length--;\\r\\n      }\\r\\n      else\\r\\n      {\\r\\n        // partially redeem a past stake\\r\\n        newStakingShareSecondsToBurn = sharesLeftToBurn.mul(stakeTimeSec);\\r\\n        rewardAmount = computeNewReward(rewardAmount, newStakingShareSecondsToBurn, stakeTimeSec);\\r\\n        stakingShareSecondsToBurn = stakingShareSecondsToBurn.add(newStakingShareSecondsToBurn);\\r\\n        lastStake.stakingShares = lastStake.stakingShares.sub(sharesLeftToBurn);\\r\\n        sharesLeftToBurn = 0;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    totals.stakingShareSeconds = totals.stakingShareSeconds.sub(stakingShareSecondsToBurn);\\r\\n    totals.stakingShares = totals.stakingShares.sub(stakingSharesToBurn);\\r\\n\\r\\n\\r\\n    _totalStakingShareSeconds = _totalStakingShareSeconds.sub(stakingShareSecondsToBurn);\\r\\n    totalStakingShares = totalStakingShares.sub(stakingSharesToBurn);\\r\\n\\r\\n\\r\\n    uint unstakeFee = amount.mul(100).div(10000);\\r\\n\\r\\n    if (now >= initStakeTimestamp.add(45 days))\\r\\n    {\\r\\n      unstakeFee = amount.mul(75).div(10000);\\r\\n    }\\r\\n\\r\\n    require(_stakingPool.transfer(owner(), unstakeFee), \\\"TokenGeyser: err tx'ing fee\\\");\\r\\n\\r\\n    require(_stakingPool.transfer(msg.sender, amount.sub(unstakeFee)), \\\"TokenGeyser: tx out of staking pool failed\\\");\\r\\n    require(_unlockedPool.transfer(msg.sender, rewardAmount), \\\"TokenGeyser: tx out of unlocked pool failed\\\");\\r\\n\\r\\n    emit Unstaked(msg.sender, amount, totalStakedFor(msg.sender), \\\"\\\");\\r\\n    emit TokensClaimed(msg.sender, rewardAmount);\\r\\n\\r\\n    require(totalStakingShares == 0 || totalStaked() > 0, \\\"TokenGeyser: Err unstaking. Staking shares exist, but no staking tokens do\\\");\\r\\n\\r\\n    return rewardAmount;\\r\\n  }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @param addr  user to look up staking information for.\\r\\n   * @return The number of staking tokens deposited for addr.\\r\\n   */\\r\\n  function totalStakedFor(address addr) public view returns (uint)\\r\\n  {\\r\\n    return totalStakingShares > 0 ? totalStaked().mul(_userTotals[addr].stakingShares).div(totalStakingShares) : 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The total number of deposit tokens staked globally, by all users.\\r\\n   */\\r\\n  function totalStaked() public view returns (uint)\\r\\n  {\\r\\n    return _stakingPool.balance();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Total number of locked distribution tokens.\\r\\n   */\\r\\n  function totalLocked() public view returns (uint)\\r\\n  {\\r\\n    return _lockedPool.balance();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Total number of unlocked distribution tokens.\\r\\n   */\\r\\n  function totalUnlocked() public view returns (uint)\\r\\n  {\\r\\n    return _unlockedPool.balance();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Number of unlock schedules.\\r\\n   */\\r\\n  function unlockScheduleCount() public view returns (uint)\\r\\n  {\\r\\n    return unlockSchedules.length;\\r\\n  }\\r\\n\\r\\n\\r\\n  // getUserTotals, getTotalStakingShareSeconds, getLastAccountingTimestamp functions added for Yield\\r\\n\\r\\n  /**\\r\\n   * @param addr  user to look up staking information for\\r\\n\\r\\n   * @return The UserStakes for this address\\r\\n   */\\r\\n  function getUserStakes(address addr) public view returns (Stake[] memory)\\r\\n  {\\r\\n    Stake[] memory userStakes = _userStakes[addr];\\r\\n\\r\\n    return userStakes;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @param addr user to look up staking information for\\r\\n\\r\\n   * @return The UserTotals for this address.\\r\\n   */\\r\\n  function getUserTotals(address addr) public view returns (UserTotals memory)\\r\\n  {\\r\\n    UserTotals memory userTotals = _userTotals[addr];\\r\\n\\r\\n    return userTotals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The total staking share seconds\\r\\n   */\\r\\n  function getTotalStakingShareSeconds() public view returns (uint256)\\r\\n  {\\r\\n    return _totalStakingShareSeconds;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The last global accounting timestamp.\\r\\n   */\\r\\n  function getLastAccountingTimestamp() public view returns (uint256)\\r\\n  {\\r\\n    return _lastAccountingTimestampSec;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The token users receive as they unstake.\\r\\n   */\\r\\n  function getDistributionToken() public view returns (IERC20)\\r\\n  {\\r\\n    assert(_unlockedPool.token() == _lockedPool.token());\\r\\n\\r\\n    return _unlockedPool.token();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The token users deposit as stake.\\r\\n   */\\r\\n  function getStakingToken() public view returns (IERC20)\\r\\n  {\\r\\n    return _stakingPool.token();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Note that this application has a staking token as well as a distribution token, which may be different. This function is required by EIP-900.\\r\\n\\r\\n   * @return The deposit token used for staking.\\r\\n   */\\r\\n  function token() external view returns (address)\\r\\n  {\\r\\n    return address(getStakingToken());\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/roles/Ownable.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\r\\n\\r\\n\\r\\ncontract Ownable\\r\\n{\\r\\n  address private _owner;\\r\\n\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\r\\n  modifier onlyOwner()\\r\\n  {\\r\\n    require(isOwner(), \\\"!owner\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  constructor () internal\\r\\n  {\\r\\n    _owner = msg.sender;\\r\\n    emit OwnershipTransferred(address(0), msg.sender);\\r\\n  }\\r\\n\\r\\n  function owner() public view returns (address)\\r\\n  {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  function isOwner() public view returns (bool)\\r\\n  {\\r\\n    return msg.sender == _owner;\\r\\n  }\\r\\n\\r\\n  function renounceOwnership() public onlyOwner\\r\\n  {\\r\\n    emit OwnershipTransferred(_owner, address(0));\\r\\n\\r\\n    _owner = address(0);\\r\\n  }\\r\\n\\r\\n  function transferOwnership(address _newOwner) public onlyOwner\\r\\n  {\\r\\n    require(_newOwner != address(0), \\\"0 addy\\\");\\r\\n\\r\\n    emit OwnershipTransferred(_owner, _newOwner);\\r\\n\\r\\n    _owner = _newOwner;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Staking interface, as defined by EIP-900.\\r\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-900.md\\r\\n */\\r\\ncontract IStaking\\r\\n{\\r\\n  event Staked(address indexed user, uint amount, uint total, bytes data);\\r\\n  event Unstaked(address indexed user, uint amount, uint total, bytes data);\\r\\n\\r\\n  function stake(uint amount, bytes calldata data) external;\\r\\n\\r\\n  function stakeFor(address user, uint amount, bytes calldata data) external;\\r\\n\\r\\n  function unstake(uint amount, bytes calldata data) external;\\r\\n\\r\\n  function totalStakedFor(address addr) public view returns (uint);\\r\\n\\r\\n  function totalStaked() public view returns (uint);\\r\\n\\r\\n  function token() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @return false. This application does not support staking history.\\r\\n   */\\r\\n  function supportsHistory() external pure returns (bool)\\r\\n  {\\r\\n    return false;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TokenPool.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport \\\"./roles/Ownable.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title A simple holder of tokens.\\r\\n * This is a simple contract to hold tokens. It's useful in the case where a separate contract needs to hold multiple distinct pools of the same token.\\r\\n */\\r\\ncontract TokenPool is Ownable\\r\\n{\\r\\n  IERC20 public token;\\r\\n\\r\\n\\r\\n  constructor(IERC20 _token) public\\r\\n  {\\r\\n    token = _token;\\r\\n  }\\r\\n\\r\\n  function balance() public view returns (uint)\\r\\n  {\\r\\n    return token.balanceOf(address(this));\\r\\n  }\\r\\n\\r\\n  function transfer(address _to, uint _value) external onlyOwner returns (bool)\\r\\n  {\\r\\n    return token.transfer(_to, _value);\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"distributionToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxUnlockSchedules\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBonus_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusPeriodSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialSharesPerToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"durationSec\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"TokensLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingLocked\",\"type\":\"uint256\"}],\"name\":\"TokensUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusPeriodSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDistributionToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastAccountingTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalStakingShareSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakingShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestampSec\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenGeyser.Stake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserTotals\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakingShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingShareSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastAccountingTimestampSec\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenGeyser.UserTotals\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"initStakeTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"durationSec\",\"type\":\"uint256\"}],\"name\":\"lockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"stakeFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supportsHistory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLockedShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"totalStakedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStakingShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUnlocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockScheduleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unlockSchedules\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialLockedShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockedShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUnlockTimestampSec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAtSec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"durationSec\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstakeQuery\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenGeyser","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000bbfd9b37ec6ea1ca612ab4adef6d8c6ece1a4134000000000000000000000000dcb01cc464238396e213a6fdd933e36796eaff9f0000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000000000000000000000002100000000000000000000000000000000000000000000000000000000003b538000000000000000000000000000000000000000000000000000000000000f4240","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}