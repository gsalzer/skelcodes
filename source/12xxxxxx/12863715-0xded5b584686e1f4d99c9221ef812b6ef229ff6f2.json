{"status":"1","message":"OK","result":[{"SourceCode":"{\"IUniswapV2Router02.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    //function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    //function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"UniswapIntermediateAgentETH.sol\":{\"content\":\"// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\n//import \\\"./IBSCswapRouter02.sol\\\";\\r\\n\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: APPROVE_FAILED\\u0027);\\r\\n    }\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FAILED\\u0027);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027);\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint value) internal {\\r\\n        (bool success,) = to.call{value:value}(new bytes(0));\\r\\n        require(success, \\u0027TransferHelper: ETH_TRANSFER_FAILED\\u0027);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IReimbursement {\\r\\n    function getLicenseeFee(address licenseeVault, address projectContract) external view returns(uint256); // return fee percentage with 2 decimals\\r\\n    function getVaultOwner(address vault) external view returns(address);\\r\\n    // returns address of fee receiver or address(0) if licensee can\\u0027t receive the fee (fee should be returns to user)\\r\\n    function requestReimbursement(address user, uint256 feeAmount, address licenseeVault) external returns(address);\\r\\n}\\r\\n\\r\\ncontract UniswapIntermediateAgent is Ownable{\\r\\n    using TransferHelper for address;\\r\\n    \\r\\n    IReimbursement public reimbursementContract;\\r\\n    address public companyVault;    // the vault address of our company registered in reimbursement contract\\r\\n    mapping(address =\\u003e uint256) public routerInterface; // type on router interface: 0 = uniswap, 1 = BSCswap\\r\\n\\r\\n    constructor(address _reimbursementContract) {      \\r\\n        reimbursementContract = IReimbursement(_reimbursementContract);\\r\\n    }\\r\\n    \\r\\n    function setReimbursement(address _reimbursement)external onlyOwner{\\r\\n        require(_reimbursement != address(0), \\\"Invalid address\\\");\\r\\n        reimbursementContract = IReimbursement(_reimbursement);\\r\\n    }\\r\\n\\r\\n    // set address of company vault (ID) in reimbursement contract\\r\\n    function setCompanyVault(address _vault) external onlyOwner{\\r\\n        companyVault = _vault;\\r\\n    }\\r\\n\\r\\n    // set type of interface of selected router.\\r\\n    // _type: 0 = uniswap, 1 = BSCswap\\r\\n    function setRouterInterface(address _router, uint256 _type) external onlyOwner {\\r\\n        routerInterface[_router] = _type;\\r\\n    }\\r\\n\\r\\n    event Swap(\\r\\n        address indexed user,\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountA,\\r\\n        uint256 amountB\\r\\n    );\\r\\n        \\r\\n    function getFee(\\r\\n        address fromToken,  // address(0) means native coin (ETH, BNB)\\r\\n        uint256 amountIn, \\r\\n        address licensee,\\r\\n        address uniV2Router   // Uniswap-compatible router address\\r\\n    ) \\r\\n    external\\r\\n    view\\r\\n    returns(uint256) \\r\\n    {\\r\\n        uint256 feeLicensee;\\r\\n        uint256 feeBswap;\\r\\n        address[] memory tempPath = new address[](2);\\r\\n        uint256 licenseeFeeRate = reimbursementContract.getLicenseeFee(licensee, address(this));\\r\\n        uint256 feeRate = reimbursementContract.getLicenseeFee(companyVault, address(this));\\r\\n        if (routerInterface[uniV2Router] == 1) {\\r\\n            // add function for different interface here\\r\\n        } else {\\r\\n            tempPath[1] = IUniswapV2Router02(uniV2Router).WETH();\\r\\n        }\\r\\n        if(fromToken == address(0) || fromToken == tempPath[1]) {\\r\\n            feeLicensee = amountIn * licenseeFeeRate / 10000;\\r\\n            feeBswap = amountIn * feeRate / 10000;\\r\\n        }\\r\\n        else {\\r\\n                tempPath[0] = fromToken;\\r\\n                uint256[] memory totalFeeAmt = IUniswapV2Router02(uniV2Router).getAmountsOut(amountIn, tempPath); \\r\\n                feeBswap = totalFeeAmt[1] * feeRate / 10000;\\r\\n                \\r\\n                if(licenseeFeeRate\\u003e0){\\r\\n                    feeLicensee = totalFeeAmt[1] * licenseeFeeRate / 10000;\\r\\n                }\\r\\n        }\\r\\n        return feeBswap + feeLicensee;\\r\\n    }\\r\\n\\r\\n    function swap(\\r\\n        address payable licensee,\\r\\n        uint256 amountIn,                                                       // amount of token to swap\\r\\n        uint256 amountOut,                                                      // minimum amount of token to receive\\r\\n        address[] memory path,                                                  // address(0) means native coin (ETH, BNB)\\r\\n        uint256 deadline,\\r\\n        uint256 swapType,                                                        // allow to choose the correct swap function: \\r\\n                                                                                // 0 - swap Exact Tokens For Token; \\r\\n                                                                                // 1 - swap Tokens For Exact Token SupportingFeeOnTransferTokens;\\r\\n                                                                                // 2 - swap Tokens For Exact Token; \\r\\n        address uniV2Router   // Uniswap-compatible router address\\r\\n    ) \\r\\n        external\\r\\n        payable\\r\\n        returns (uint256[] memory amounts) \\r\\n    {\\r\\n        if (routerInterface[uniV2Router] == 1) {\\r\\n            // add function for different interface here\\r\\n        } else {\\r\\n            return swapUni(licensee, amountIn, amountOut, path, deadline, swapType, IUniswapV2Router02(uniV2Router));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function swapUni(\\r\\n        address payable licensee,\\r\\n        uint256 amountIn,                                                       // amount of token to swap\\r\\n        uint256 amountOut,                                                      // minimum amount of token to receive\\r\\n        address[] memory path,                                                  // address(0) means native coin (ETH, BNB)\\r\\n        uint256 deadline,\\r\\n        uint256 swapType,                                                        // allow to choose the correct swap function: \\r\\n                                                                                // 0 - swap Exact Tokens For Token; \\r\\n                                                                                // 1 - swap Tokens For Exact Token SupportingFeeOnTransferTokens;\\r\\n                                                                                // 2 - swap Tokens For Exact Token; \\r\\n        IUniswapV2Router02 uniV2Router   // Uniswap-compatible router address\\r\\n    ) \\r\\n        internal\\r\\n        returns (uint256[] memory amounts) \\r\\n    {\\r\\n        bool toETH;\\r\\n        bool fromETH;\\r\\n        uint256 totalGas = gasleft();\\r\\n        uint256 totalFee;\\r\\n        totalFee = msg.value;                                                   // assume that all coins that user send is a fee\\r\\n    \\r\\n        if (path[0] == address(0)) {                                             // swap from native coin (ETH, BNB)\\r\\n            totalFee = totalFee - amountIn;                                   // separate fee from swapping value\\r\\n            path[0] = uniV2Router.WETH();\\r\\n            fromETH = true;\\r\\n        } else {                                                                 // transfer token from user and approve to Router\\r\\n            path[0].safeTransferFrom(msg.sender, address(this), amountIn);\\r\\n            path[0].safeApprove(address(uniV2Router), amountIn);        \\r\\n        }\\r\\n    \\r\\n        if (path[path.length-1] == address(0)) {                                 // swap to native coin (ETH, BNB)\\r\\n            path[path.length-1] = uniV2Router.WETH();\\r\\n            toETH = true;\\r\\n        }\\r\\n        \\r\\n        require (!fromETH || !toETH, \\\"Swapping from ETH to ETH is forbidden\\\");\\r\\n\\r\\n        totalFee =  CalculateTokenAmounts(                        // function to find bswap and mint licensee token\\r\\n             uniV2Router.WETH(),\\r\\n             amountIn, \\r\\n             path, \\r\\n             licensee,\\r\\n             totalFee,\\r\\n             uniV2Router\\r\\n        );\\r\\n        \\r\\n        if (swapType == 0) {                    \\r\\n            if (fromETH) {\\r\\n                amounts = uniV2Router.swapExactETHForTokens{value: amountIn}(\\r\\n                    0,\\r\\n                    path,\\r\\n                    msg.sender,\\r\\n                    deadline\\r\\n                );\\r\\n            } else if (toETH) {\\r\\n                amounts = uniV2Router.swapExactTokensForETH(\\r\\n                    amountIn,\\r\\n                    amountOut,\\r\\n                    path,\\r\\n                    payable(msg.sender),\\r\\n                    deadline\\r\\n                );            \\r\\n            } else {\\r\\n                amounts = uniV2Router.swapExactTokensForTokens(\\r\\n                    amountIn,\\r\\n                    amountOut,\\r\\n                    path,\\r\\n                    msg.sender,\\r\\n                    deadline\\r\\n                );\\r\\n            }\\r\\n        } else if (swapType == 1) {\\r\\n            if (fromETH) {\\r\\n                uniV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountIn}(\\r\\n                    0,\\r\\n                    path,\\r\\n                    msg.sender,\\r\\n                    deadline\\r\\n                );\\r\\n            } else if (toETH) {\\r\\n                uniV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n                    amountIn,\\r\\n                    amountOut,\\r\\n                    path,\\r\\n                    payable(msg.sender),\\r\\n                    deadline\\r\\n                );            \\r\\n            } else {\\r\\n                uniV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n                    amountIn,\\r\\n                    amountOut,\\r\\n                    path,\\r\\n                    msg.sender,\\r\\n                    deadline\\r\\n                );\\r\\n            }\\r\\n        } else if (swapType == 2) {\\r\\n            if (fromETH) {\\r\\n                amounts = uniV2Router.swapETHForExactTokens{value: amountIn}(\\r\\n                    amountOut,\\r\\n                    path,\\r\\n                    msg.sender,\\r\\n                    deadline\\r\\n                );\\r\\n                \\r\\n                if(amountIn - amounts[0] \\u003e 0){\\r\\n                    payable(msg.sender).transfer(amountIn - amounts[0]);\\r\\n                }\\r\\n\\r\\n            } else if (toETH) {\\r\\n                amounts = uniV2Router.swapTokensForExactETH(\\r\\n                    amountOut,\\r\\n                    amountIn,\\r\\n                    path,\\r\\n                    payable(msg.sender),\\r\\n                    deadline\\r\\n                );\\r\\n                \\r\\n                if(amountIn - amounts[0] \\u003e 0){\\r\\n                    path[0].safeTransfer(msg.sender, (amountIn - amounts[0]));\\r\\n                }\\r\\n            } else {\\r\\n                amounts = uniV2Router.swapTokensForExactTokens(\\r\\n                    amountOut,\\r\\n                    amountIn,\\r\\n                    path,\\r\\n                    msg.sender,\\r\\n                    deadline\\r\\n                );\\r\\n                \\r\\n                if(amountIn - amounts[0] \\u003e 0){\\r\\n                    path[0].safeTransfer(msg.sender, (amountIn - amounts[0]));\\r\\n                }\\r\\n            }\\r\\n        }else { \\r\\n            revert(\\\"Wrong type\\\");\\r\\n        }\\r\\n    \\r\\n        totalGas = (totalGas - gasleft()) * tx.gasprice;\\r\\n        // request reimbursement for user\\r\\n        reimbursementContract.requestReimbursement(msg.sender, totalFee + totalGas, companyVault);\\r\\n        emit Swap(msg.sender, path[0], path[1], amountIn, amounts[1]);      // emit swap event\\r\\n    }\\r\\n    \\r\\n    function CalculateTokenAmounts(\\r\\n        address WETH,\\r\\n        uint256 amountIn, \\r\\n        address[] memory path, \\r\\n        address payable licensee,\\r\\n        uint256 totalFee,\\r\\n        IUniswapV2Router02 uniV2Router\\r\\n    ) \\r\\n        internal \\r\\n        returns(uint256)\\r\\n        {\\r\\n                \\r\\n        uint256 feeLicensee;\\r\\n        uint256 feeBswap;\\r\\n        address[] memory tempPath = new address[](2);\\r\\n        uint256 licenseeFeeRate = reimbursementContract.getLicenseeFee(licensee, address(this));\\r\\n        uint256 feeRate = reimbursementContract.getLicenseeFee(companyVault, address(this));\\r\\n        \\r\\n        if(WETH == path[0]) { // swapping from native coin\\r\\n            feeLicensee = amountIn * licenseeFeeRate / 10000;\\r\\n            feeBswap = amountIn * feeRate / 10000;\\r\\n        }\\r\\n        else {\\r\\n                tempPath[0] = path[0];\\r\\n                tempPath[1] = WETH;\\r\\n                uint256[] memory totalFeeAmt = uniV2Router.getAmountsOut(amountIn, tempPath); \\r\\n                feeBswap = totalFeeAmt[1] * feeRate / 10000;\\r\\n                \\r\\n                if(licenseeFeeRate \\u003e 0){\\r\\n                    feeLicensee = totalFeeAmt[1] * licenseeFeeRate / 10000;\\r\\n                }\\r\\n        }\\r\\n    \\r\\n        uint256 refundFee;\\r\\n        if(feeLicensee != 0){\\r\\n            address licenseeFeeTo = reimbursementContract.requestReimbursement(msg.sender, feeLicensee, licensee);\\r\\n            if (licenseeFeeTo == address(0)) {\\r\\n                refundFee = feeLicensee;    // refund to user\\r\\n            } else {\\r\\n                payable(licenseeFeeTo).transfer(feeLicensee);  // transfer to fee receiver\\r\\n            }                                            \\r\\n        }\\r\\n\\r\\n        require (refundFee + totalFee \\u003e= feeLicensee + feeBswap, \\\"Insufficient fee\\\");\\r\\n        refundFee = (refundFee + totalFee) - (feeLicensee + feeBswap);\\r\\n        if (refundFee \\u003e (20000 * tx.gasprice))                                              // avoid spending more gas on transfer than the amount to refund\\r\\n            payable(msg.sender).transfer(refundFee);                                                 \\r\\n        else\\r\\n            feeBswap += refundFee;                                                          // add small amount to company fee\\r\\n            \\r\\n        payable(owner()).transfer(feeBswap);\\r\\n        \\r\\n        return feeBswap;\\r\\n    }\\r\\n    \\r\\n    receive() external payable {}\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reimbursementContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"companyVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"licensee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniV2Router\",\"type\":\"address\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reimbursementContract\",\"outputs\":[{\"internalType\":\"contract IReimbursement\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"routerInterface\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setCompanyVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reimbursement\",\"type\":\"address\"}],\"name\":\"setReimbursement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"setRouterInterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"licensee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniV2Router\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"UniswapIntermediateAgent","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000096d1e9d25bd949b6811e2844aca63cb3cfce68af","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://696fcac51c06701448d5c9c8f61574448f08862bcee443fb183d4d57cddffeea"}]}