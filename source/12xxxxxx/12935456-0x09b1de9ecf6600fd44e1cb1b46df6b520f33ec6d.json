{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.3.0 https://hardhat.org\r\n\r\n// File @chainlink/contracts/src/v0.7/interfaces/LinkTokenInterface.sol@v0.1.6\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external view returns (string memory tokenName);\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\n\r\n// File contracts/vendor/Owned.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @title The Owned contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract Owned {\r\n\r\n  address public owner;\r\n  address private pendingOwner;\r\n\r\n  event OwnershipTransferRequested(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n  event OwnershipTransferred(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(address _to)\r\n    external\r\n    onlyOwner()\r\n  {\r\n    pendingOwner = _to;\r\n\r\n    emit OwnershipTransferRequested(owner, _to);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership()\r\n    external\r\n  {\r\n    require(msg.sender == pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = owner;\r\n    owner = msg.sender;\r\n    pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Only callable by owner\");\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n\r\n// File contracts/KeeperRegistryInterface.sol\r\n\r\n\r\npragma solidity 0.7.6;\r\n\r\ninterface KeeperRegistryBaseInterface {\r\n  function registerUpkeep(\r\n    address target,\r\n    uint32 gasLimit,\r\n    address admin,\r\n    bytes calldata checkData\r\n  ) external returns (\r\n      uint256 id\r\n    );\r\n  function performUpkeep(\r\n    uint256 id,\r\n    bytes calldata performData\r\n  ) external returns (\r\n      bool success\r\n    );\r\n  function cancelUpkeep(\r\n    uint256 id\r\n  ) external;\r\n  function addFunds(\r\n    uint256 id,\r\n    uint96 amount\r\n  ) external;\r\n\r\n  function getUpkeep(uint256 id)\r\n    external view returns (\r\n      address target,\r\n      uint32 executeGas,\r\n      bytes memory checkData,\r\n      uint96 balance,\r\n      address lastKeeper,\r\n      address admin,\r\n      uint64 maxValidBlocknumber\r\n    );\r\n  function getUpkeepCount()\r\n    external view returns (uint256);\r\n  function getCanceledUpkeepList()\r\n    external view returns (uint256[] memory);\r\n  function getKeeperList()\r\n    external view returns (address[] memory);\r\n  function getKeeperInfo(address query)\r\n    external view returns (\r\n      address payee,\r\n      bool active,\r\n      uint96 balance\r\n    );\r\n  function getConfig()\r\n    external view returns (\r\n      uint32 paymentPremiumPPB,\r\n      uint24 checkFrequencyBlocks,\r\n      uint32 checkGasLimit,\r\n      uint24 stalenessSeconds,\r\n      uint16 gasCeilingMultiplier,\r\n      uint256 fallbackGasPrice,\r\n      uint256 fallbackLinkPrice\r\n    );\r\n}\r\n\r\n/**\r\n  * @dev The view methods are not actually marked as view in the implementation\r\n  * but we want them to be easily queried off-chain. Solidity will not compile\r\n  * if we actually inherrit from this interface, so we document it here.\r\n  */\r\ninterface KeeperRegistryInterface is KeeperRegistryBaseInterface {\r\n  function checkUpkeep(\r\n    uint256 upkeepId,\r\n    address from\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      bytes memory performData,\r\n      uint256 maxLinkPayment,\r\n      uint256 gasLimit,\r\n      int256 gasWei,\r\n      int256 linkEth\r\n    );\r\n}\r\n\r\ninterface KeeperRegistryExecutableInterface is KeeperRegistryBaseInterface {\r\n  function checkUpkeep(\r\n    uint256 upkeepId,\r\n    address from\r\n  )\r\n    external\r\n    returns (\r\n      bytes memory performData,\r\n      uint256 maxLinkPayment,\r\n      uint256 gasLimit,\r\n      uint256 adjustedGasWei,\r\n      uint256 linkEth\r\n    );\r\n}\r\n\r\n\r\n// File contracts/SafeMath96.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * This library is a version of Open Zeppelin's SafeMath, modified to support\r\n * unsigned 96 bit integers.\r\n */\r\nlibrary SafeMath96 {\r\n  /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n  function add(uint96 a, uint96 b) internal pure returns (uint96) {\r\n    uint96 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint96 a, uint96 b) internal pure returns (uint96) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint96 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n  function mul(uint96 a, uint96 b) internal pure returns (uint96) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint96 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint96 a, uint96 b) internal pure returns (uint96) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint96 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint96 a, uint96 b) internal pure returns (uint96) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n// File contracts/UpkeepRegistrationRequests.sol\r\n\r\n\r\npragma solidity 0.7.6;\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice Contract to accept requests for upkeep registrations\r\n * @dev There are 2 registration workflows in this contract\r\n * Flow 1. auto approve OFF / manual registration - UI calls `register` function on this contract, this contract owner at a later time then manually\r\n *  calls `approve` to register upkeep and emit events to inform UI and others interested.\r\n * Flow 2. auto approve ON / real time registration - UI calls `register` function as before, which calls the `registerUpkeep` function directly on\r\n *  keeper registry and then emits approved event to finish the flow automatically without manual intervention.\r\n * The idea is to have same interface(functions,events) for UI or anyone using this contract irrespective of auto approve being enabled or not.\r\n * they can just listen to `RegistrationRequested` & `RegistrationApproved` events and know the status on registrations.\r\n */\r\ncontract UpkeepRegistrationRequests is Owned {\r\n    using SafeMath96 for uint96;\r\n\r\n    bytes4 private constant REGISTER_REQUEST_SELECTOR = this.register.selector;\r\n\r\n    uint256 private s_minLINKJuels;\r\n    mapping(bytes32 => PendingRequest) private s_pendingRequests;\r\n\r\n    LinkTokenInterface public immutable LINK;\r\n\r\n    struct AutoApprovedConfig {\r\n        bool enabled;\r\n        uint16 allowedPerWindow;\r\n        uint32 windowSizeInBlocks;\r\n        uint64 windowStart;\r\n        uint16 approvedInCurrentWindow;\r\n    }\r\n\r\n    struct PendingRequest {\r\n        address admin;\r\n        uint96 balance;\r\n    }\r\n\r\n    AutoApprovedConfig private s_config;\r\n    KeeperRegistryBaseInterface private s_keeperRegistry;\r\n\r\n    event RegistrationRequested(\r\n        bytes32 indexed hash,\r\n        string name,\r\n        bytes encryptedEmail,\r\n        address indexed upkeepContract,\r\n        uint32 gasLimit,\r\n        address adminAddress,\r\n        bytes checkData,\r\n        uint96 amount,\r\n        uint8 indexed source\r\n    );\r\n\r\n    event RegistrationApproved(\r\n        bytes32 indexed hash,\r\n        string displayName,\r\n        uint256 indexed upkeepId\r\n    );\r\n\r\n    event ConfigChanged(\r\n        bool enabled,\r\n        uint32 windowSizeInBlocks,\r\n        uint16 allowedPerWindow,\r\n        address keeperRegistry,\r\n        uint256 minLINKJuels\r\n    );\r\n\r\n    constructor(\r\n        address LINKAddress,\r\n        uint256 minimumLINKJuels\r\n    ) {\r\n        LINK = LinkTokenInterface(LINKAddress);\r\n        s_minLINKJuels = minimumLINKJuels;\r\n    }\r\n\r\n    //EXTERNAL\r\n\r\n    /**\r\n     * @notice register can only be called through transferAndCall on LINK contract\r\n     * @param name string of the upkeep to be registered\r\n     * @param encryptedEmail email address of upkeep contact\r\n     * @param upkeepContract address to peform upkeep on\r\n     * @param gasLimit amount of gas to provide the target contract when performing upkeep\r\n     * @param adminAddress address to cancel upkeep and withdraw remaining funds\r\n     * @param checkData data passed to the contract when checking for upkeep\r\n     * @param amount quantity of LINK upkeep is funded with (specified in Juels)\r\n     * @param source application sending this request\r\n     */\r\n    function register(\r\n        string memory name,\r\n        bytes calldata encryptedEmail,\r\n        address upkeepContract,\r\n        uint32 gasLimit,\r\n        address adminAddress,\r\n        bytes calldata checkData,\r\n        uint96 amount,\r\n        uint8 source\r\n    )\r\n      external\r\n      onlyLINK()\r\n    {\r\n        require(adminAddress != address(0), \"invalid admin address\");\r\n        bytes32 hash = keccak256(abi.encode(upkeepContract, gasLimit, adminAddress, checkData));\r\n\r\n        emit RegistrationRequested(\r\n            hash,\r\n            name,\r\n            encryptedEmail,\r\n            upkeepContract,\r\n            gasLimit,\r\n            adminAddress,\r\n            checkData,\r\n            amount,\r\n            source\r\n        );\r\n\r\n        AutoApprovedConfig memory config = s_config;\r\n        if (config.enabled && _underApprovalLimit(config)) {\r\n            _incrementApprovedCount(config);\r\n\r\n            _approve(\r\n                name,\r\n                upkeepContract,\r\n                gasLimit,\r\n                adminAddress,\r\n                checkData,\r\n                amount,\r\n                hash\r\n            );\r\n        } else {\r\n            uint96 newBalance = s_pendingRequests[hash].balance.add(amount);\r\n            s_pendingRequests[hash] = PendingRequest({\r\n                admin: adminAddress,\r\n                balance: newBalance\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev register upkeep on KeeperRegistry contract and emit RegistrationApproved event\r\n     */\r\n    function approve(\r\n        string memory name,\r\n        address upkeepContract,\r\n        uint32 gasLimit,\r\n        address adminAddress,\r\n        bytes calldata checkData,\r\n        bytes32 hash\r\n    )\r\n      external\r\n      onlyOwner()\r\n    {\r\n        PendingRequest memory request = s_pendingRequests[hash];\r\n        require(request.admin != address(0), \"request not found\");\r\n        bytes32 expectedHash = keccak256(abi.encode(upkeepContract, gasLimit, adminAddress, checkData));\r\n        require(hash == expectedHash, \"hash and payload do not match\");\r\n        delete s_pendingRequests[hash];\r\n        _approve(\r\n            name,\r\n            upkeepContract,\r\n            gasLimit,\r\n            adminAddress,\r\n            checkData,\r\n            request.balance,\r\n            hash\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice cancel will remove a registration request and return the refunds to the msg.sender\r\n     * @param hash the request hash\r\n     */\r\n    function cancel(\r\n        bytes32 hash\r\n    )\r\n      external\r\n    {\r\n        PendingRequest memory request = s_pendingRequests[hash];\r\n        require(msg.sender == request.admin || msg.sender == owner, \"only admin / owner can cancel\");\r\n        require(request.admin != address(0), \"request not found\");\r\n        delete s_pendingRequests[hash];\r\n        require(LINK.transfer(msg.sender, request.balance), \"LINK token transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice owner calls this function to set if registration requests should be sent directly to the Keeper Registry\r\n     * @param enabled setting for autoapprove registrations\r\n     * @param windowSizeInBlocks window size defined in number of blocks\r\n     * @param allowedPerWindow number of registrations that can be auto approved in above window\r\n     * @param keeperRegistry new keeper registry address\r\n     */\r\n    function setRegistrationConfig(\r\n        bool enabled,\r\n        uint32 windowSizeInBlocks,\r\n        uint16 allowedPerWindow,\r\n        address keeperRegistry,\r\n        uint256 minLINKJuels\r\n    )\r\n      external\r\n      onlyOwner()\r\n    {\r\n        s_config = AutoApprovedConfig({\r\n            enabled: enabled,\r\n            allowedPerWindow: allowedPerWindow,\r\n            windowSizeInBlocks: windowSizeInBlocks,\r\n            windowStart: 0,\r\n            approvedInCurrentWindow: 0\r\n        });\r\n        s_minLINKJuels = minLINKJuels;\r\n        s_keeperRegistry = KeeperRegistryBaseInterface(keeperRegistry);\r\n\r\n        emit ConfigChanged(\r\n          enabled,\r\n          windowSizeInBlocks,\r\n          allowedPerWindow,\r\n          keeperRegistry,\r\n          minLINKJuels\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice read the current registration configuration\r\n     */\r\n    function getRegistrationConfig()\r\n        external\r\n        view\r\n        returns (\r\n            bool enabled,\r\n            uint32 windowSizeInBlocks,\r\n            uint16 allowedPerWindow,\r\n            address keeperRegistry,\r\n            uint256 minLINKJuels,\r\n            uint64 windowStart,\r\n            uint16 approvedInCurrentWindow\r\n        )\r\n    {\r\n        AutoApprovedConfig memory config = s_config;\r\n        return (\r\n            config.enabled,\r\n            config.windowSizeInBlocks,\r\n            config.allowedPerWindow,\r\n            address(s_keeperRegistry),\r\n            s_minLINKJuels,\r\n            config.windowStart,\r\n            config.approvedInCurrentWindow\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice gets the admin address and the current balance of a registration request\r\n     */\r\n    function getPendingRequest(bytes32 hash) external view returns(address, uint96) {\r\n        PendingRequest memory request = s_pendingRequests[hash];\r\n        return (request.admin, request.balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Called when LINK is sent to the contract via `transferAndCall`\r\n     * @param amount Amount of LINK sent (specified in Juels)\r\n     * @param data Payload of the transaction\r\n     */\r\n    function onTokenTransfer(\r\n        address, /* sender */\r\n        uint256 amount,\r\n        bytes calldata data\r\n    )\r\n      external\r\n      onlyLINK()\r\n      permittedFunctionsForLINK(data)\r\n      isActualAmount(amount, data)\r\n    {\r\n        require(amount >= s_minLINKJuels, \"Insufficient payment\");\r\n        (bool success, ) = address(this).delegatecall(data); // calls register\r\n        require(success, \"Unable to create request\");\r\n    }\r\n\r\n    //PRIVATE\r\n\r\n    /**\r\n     * @dev reset auto approve window if passed end of current window\r\n     */\r\n    function _resetWindowIfRequired(\r\n        AutoApprovedConfig memory config\r\n    )\r\n      private\r\n    {\r\n        uint64 blocksPassed = uint64(block.number - config.windowStart);\r\n        if (blocksPassed >= config.windowSizeInBlocks) {\r\n            config.windowStart = uint64(block.number);\r\n            config.approvedInCurrentWindow = 0;\r\n            s_config = config;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev register upkeep on KeeperRegistry contract and emit RegistrationApproved event\r\n     */\r\n    function _approve(\r\n        string memory name,\r\n        address upkeepContract,\r\n        uint32 gasLimit,\r\n        address adminAddress,\r\n        bytes calldata checkData,\r\n        uint96 amount,\r\n        bytes32 hash\r\n    )\r\n      private\r\n    {\r\n        KeeperRegistryBaseInterface keeperRegistry = s_keeperRegistry;\r\n\r\n        // register upkeep\r\n        uint256 upkeepId = keeperRegistry.registerUpkeep(\r\n            upkeepContract,\r\n            gasLimit,\r\n            adminAddress,\r\n            checkData\r\n        );\r\n        // fund upkeep\r\n        bool success = LINK.transferAndCall(\r\n          address(keeperRegistry),\r\n          amount,\r\n          abi.encode(upkeepId)\r\n        );\r\n        require(success, \"failed to fund upkeep\");\r\n\r\n        emit RegistrationApproved(hash, name, upkeepId);\r\n    }\r\n\r\n    /**\r\n     * @dev determine approval limits and check if in range\r\n     */\r\n    function _underApprovalLimit(\r\n      AutoApprovedConfig memory config\r\n    )\r\n      private\r\n      returns (bool)\r\n    {\r\n        _resetWindowIfRequired(config);\r\n        if (config.approvedInCurrentWindow < config.allowedPerWindow) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev record new latest approved count\r\n     */\r\n    function _incrementApprovedCount(\r\n      AutoApprovedConfig memory config\r\n    )\r\n      private\r\n    {\r\n        config.approvedInCurrentWindow++;\r\n        s_config = config;\r\n    }\r\n\r\n    //MODIFIERS\r\n\r\n    /**\r\n     * @dev Reverts if not sent from the LINK token\r\n     */\r\n    modifier onlyLINK() {\r\n        require(msg.sender == address(LINK), \"Must use LINK token\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the given data does not begin with the `register` function selector\r\n     * @param _data The data payload of the request\r\n     */\r\n    modifier permittedFunctionsForLINK(\r\n        bytes memory _data\r\n    ) {\r\n        bytes4 funcSelector;\r\n        assembly {\r\n            // solhint-disable-next-line avoid-low-level-calls\r\n            funcSelector := mload(add(_data, 32))\r\n        }\r\n        require(\r\n            funcSelector == REGISTER_REQUEST_SELECTOR,\r\n            \"Must use whitelisted functions\"\r\n        );\r\n        _;\r\n    }\r\n\r\n   /**\r\n   * @dev Reverts if the actual amount passed does not match the expected amount\r\n   * @param expected amount that should match the actual amount\r\n   * @param data bytes\r\n   */\r\n  modifier isActualAmount(\r\n    uint256 expected,\r\n    bytes memory data\r\n  ) {\r\n      uint256 actual;\r\n      assembly{\r\n          actual := mload(add(data, 228))\r\n      }\r\n      require(expected == actual, \"Amount mismatch\");\r\n      _;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"LINKAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumLINKJuels\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"windowSizeInBlocks\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"allowedPerWindow\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keeperRegistry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLINKJuels\",\"type\":\"uint256\"}],\"name\":\"ConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"displayName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"upkeepId\",\"type\":\"uint256\"}],\"name\":\"RegistrationApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encryptedEmail\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upkeepContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adminAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"RegistrationRequested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LINK\",\"outputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"upkeepContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"adminAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"getPendingRequest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistrationConfig\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"windowSizeInBlocks\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"allowedPerWindow\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"keeperRegistry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minLINKJuels\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"windowStart\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"approvedInCurrentWindow\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"encryptedEmail\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"upkeepContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"adminAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"uint8\",\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"windowSizeInBlocks\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"allowedPerWindow\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"keeperRegistry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minLINKJuels\",\"type\":\"uint256\"}],\"name\":\"setRegistrationConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UpkeepRegistrationRequests","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca0000000000000000000000000000000000000000000000004563918244f40000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a94b2167e255c971e5b63a032a96ee6583991c6861847298cfdd0d54469378b5"}]}