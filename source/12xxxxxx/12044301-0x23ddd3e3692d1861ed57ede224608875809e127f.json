{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: rainbow-bridge/contracts/eth/nearbridge/contracts/AdminControlled.sol\r\n\r\npragma solidity ^0.6;\r\n\r\ncontract AdminControlled {\r\n    address public admin;\r\n    uint public paused;\r\n\r\n    constructor(address _admin, uint flags) public {\r\n        admin = _admin;\r\n\r\n        // Add the possibility to set pause flags on the initialization\r\n        paused = flags;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier pausable(uint flag) {\r\n        require((paused & flag) == 0 || msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    function adminPause(uint flags) public onlyAdmin {\r\n        paused = flags;\r\n    }\r\n\r\n    function adminSstore(uint key, uint value) public onlyAdmin {\r\n        assembly {\r\n            sstore(key, value)\r\n        }\r\n    }\r\n\r\n    function adminSendEth(address payable destination, uint amount) public onlyAdmin {\r\n        destination.transfer(amount);\r\n    }\r\n\r\n    function adminReceiveEth() public payable onlyAdmin {}\r\n\r\n    function adminDelegatecall(address target, bytes memory data) public payable onlyAdmin returns (bytes memory) {\r\n        (bool success, bytes memory rdata) = target.delegatecall(data);\r\n        require(success);\r\n        return rdata;\r\n    }\r\n}\r\n\r\n// File: rainbow-bridge/contracts/eth/nearbridge/contracts/Borsh.sol\r\n\r\npragma solidity ^0.6;\r\n\r\n\r\nlibrary Borsh {\r\n    using SafeMath for uint256;\r\n\r\n    struct Data {\r\n        uint256 offset;\r\n        bytes raw;\r\n    }\r\n\r\n    function from(bytes memory data) internal pure returns (Data memory) {\r\n        return Data({offset: 0, raw: data});\r\n    }\r\n\r\n    modifier shift(Data memory data, uint256 size) {\r\n        require(data.raw.length >= data.offset + size, \"Borsh: Out of range\");\r\n        _;\r\n        data.offset += size;\r\n    }\r\n\r\n    function finished(Data memory data) internal pure returns (bool) {\r\n        return data.offset == data.raw.length;\r\n    }\r\n\r\n    function peekKeccak256(Data memory data, uint256 length) internal pure returns (bytes32 res) {\r\n        return bytesKeccak256(data.raw, data.offset, length);\r\n    }\r\n\r\n    function bytesKeccak256(\r\n        bytes memory ptr,\r\n        uint256 offset,\r\n        uint256 length\r\n    ) internal pure returns (bytes32 res) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            res := keccak256(add(add(ptr, 32), offset), length)\r\n        }\r\n    }\r\n\r\n    function peekSha256(Data memory data, uint256 length) internal view returns (bytes32) {\r\n        return bytesSha256(data.raw, data.offset, length);\r\n    }\r\n\r\n    function bytesSha256(\r\n        bytes memory ptr,\r\n        uint256 offset,\r\n        uint256 length\r\n    ) internal view returns (bytes32) {\r\n        bytes32[1] memory result;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            pop(staticcall(gas(), 0x02, add(add(ptr, 32), offset), length, result, 32))\r\n        }\r\n        return result[0];\r\n    }\r\n\r\n    function decodeU8(Data memory data) internal pure shift(data, 1) returns (uint8 value) {\r\n        value = uint8(data.raw[data.offset]);\r\n    }\r\n\r\n    function decodeI8(Data memory data) internal pure shift(data, 1) returns (int8 value) {\r\n        value = int8(data.raw[data.offset]);\r\n    }\r\n\r\n    function decodeU16(Data memory data) internal pure returns (uint16 value) {\r\n        value = uint16(decodeU8(data));\r\n        value |= (uint16(decodeU8(data)) << 8);\r\n    }\r\n\r\n    function decodeI16(Data memory data) internal pure returns (int16 value) {\r\n        value = int16(decodeI8(data));\r\n        value |= (int16(decodeI8(data)) << 8);\r\n    }\r\n\r\n    function decodeU32(Data memory data) internal pure returns (uint32 value) {\r\n        value = uint32(decodeU16(data));\r\n        value |= (uint32(decodeU16(data)) << 16);\r\n    }\r\n\r\n    function decodeI32(Data memory data) internal pure returns (int32 value) {\r\n        value = int32(decodeI16(data));\r\n        value |= (int32(decodeI16(data)) << 16);\r\n    }\r\n\r\n    function decodeU64(Data memory data) internal pure returns (uint64 value) {\r\n        value = uint64(decodeU32(data));\r\n        value |= (uint64(decodeU32(data)) << 32);\r\n    }\r\n\r\n    function decodeI64(Data memory data) internal pure returns (int64 value) {\r\n        value = int64(decodeI32(data));\r\n        value |= (int64(decodeI32(data)) << 32);\r\n    }\r\n\r\n    function decodeU128(Data memory data) internal pure returns (uint128 value) {\r\n        value = uint128(decodeU64(data));\r\n        value |= (uint128(decodeU64(data)) << 64);\r\n    }\r\n\r\n    function decodeI128(Data memory data) internal pure returns (int128 value) {\r\n        value = int128(decodeI64(data));\r\n        value |= (int128(decodeI64(data)) << 64);\r\n    }\r\n\r\n    function decodeU256(Data memory data) internal pure returns (uint256 value) {\r\n        value = uint256(decodeU128(data));\r\n        value |= (uint256(decodeU128(data)) << 128);\r\n    }\r\n\r\n    function decodeI256(Data memory data) internal pure returns (int256 value) {\r\n        value = int256(decodeI128(data));\r\n        value |= (int256(decodeI128(data)) << 128);\r\n    }\r\n\r\n    function decodeBool(Data memory data) internal pure returns (bool value) {\r\n        value = (decodeU8(data) != 0);\r\n    }\r\n\r\n    function decodeBytes(Data memory data) internal pure returns (bytes memory value) {\r\n        value = new bytes(decodeU32(data));\r\n        for (uint i = 0; i < value.length; i++) {\r\n            value[i] = byte(decodeU8(data));\r\n        }\r\n    }\r\n\r\n    function decodeBytes32(Data memory data) internal pure shift(data, 32) returns (bytes32 value) {\r\n        bytes memory raw = data.raw;\r\n        uint256 offset = data.offset;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            value := mload(add(add(raw, 32), offset))\r\n        }\r\n    }\r\n\r\n    function decodeBytes20(Data memory data) internal pure returns (bytes20 value) {\r\n        for (uint i = 0; i < 20; i++) {\r\n            value |= bytes20(byte(decodeU8(data)) & 0xFF) >> (i * 8);\r\n        }\r\n    }\r\n\r\n    // Public key\r\n\r\n    struct SECP256K1PublicKey {\r\n        uint256 x;\r\n        uint256 y;\r\n    }\r\n\r\n    function decodeSECP256K1PublicKey(Borsh.Data memory data) internal pure returns (SECP256K1PublicKey memory key) {\r\n        key.x = decodeU256(data);\r\n        key.y = decodeU256(data);\r\n    }\r\n\r\n    struct ED25519PublicKey {\r\n        bytes32 xy;\r\n    }\r\n\r\n    function decodeED25519PublicKey(Borsh.Data memory data) internal pure returns (ED25519PublicKey memory key) {\r\n        key.xy = decodeBytes32(data);\r\n    }\r\n\r\n    // Signature\r\n\r\n    struct SECP256K1Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n    }\r\n\r\n    function decodeSECP256K1Signature(Borsh.Data memory data) internal pure returns (SECP256K1Signature memory sig) {\r\n        sig.r = decodeBytes32(data);\r\n        sig.s = decodeBytes32(data);\r\n        sig.v = decodeU8(data);\r\n    }\r\n\r\n    struct ED25519Signature {\r\n        bytes32[2] rs;\r\n    }\r\n\r\n    function decodeED25519Signature(Borsh.Data memory data) internal pure returns (ED25519Signature memory sig) {\r\n        sig.rs[0] = decodeBytes32(data);\r\n        sig.rs[1] = decodeBytes32(data);\r\n    }\r\n}\r\n\r\n// File: rainbow-bridge/contracts/eth/nearbridge/contracts/NearDecoder.sol\r\n\r\npragma solidity ^0.6;\r\n\r\n\r\n\r\nlibrary NearDecoder {\r\n    using Borsh for Borsh.Data;\r\n    using NearDecoder for Borsh.Data;\r\n\r\n    struct PublicKey {\r\n        uint8 enumIndex;\r\n        Borsh.ED25519PublicKey ed25519;\r\n        Borsh.SECP256K1PublicKey secp256k1;\r\n    }\r\n\r\n    function decodePublicKey(Borsh.Data memory data) internal pure returns (PublicKey memory key) {\r\n        key.enumIndex = data.decodeU8();\r\n\r\n        if (key.enumIndex == 0) {\r\n            key.ed25519 = data.decodeED25519PublicKey();\r\n        } else if (key.enumIndex == 1) {\r\n            key.secp256k1 = data.decodeSECP256K1PublicKey();\r\n        } else {\r\n            revert(\"NearBridge: Only ED25519 and SECP256K1 public keys are supported\");\r\n        }\r\n    }\r\n\r\n    struct ValidatorStake {\r\n        string account_id;\r\n        PublicKey public_key;\r\n        uint128 stake;\r\n    }\r\n\r\n    function decodeValidatorStake(Borsh.Data memory data) internal pure returns (ValidatorStake memory validatorStake) {\r\n        validatorStake.account_id = string(data.decodeBytes());\r\n        validatorStake.public_key = data.decodePublicKey();\r\n        validatorStake.stake = data.decodeU128();\r\n    }\r\n\r\n    struct OptionalValidatorStakes {\r\n        bool none;\r\n        ValidatorStake[] validatorStakes;\r\n        bytes32 hash; // Additional computable element\r\n    }\r\n\r\n    function decodeOptionalValidatorStakes(Borsh.Data memory data)\r\n        internal\r\n        view\r\n        returns (OptionalValidatorStakes memory stakes)\r\n    {\r\n        stakes.none = (data.decodeU8() == 0);\r\n        if (!stakes.none) {\r\n            uint256 start = data.offset;\r\n\r\n            stakes.validatorStakes = new ValidatorStake[](data.decodeU32());\r\n            for (uint i = 0; i < stakes.validatorStakes.length; i++) {\r\n                stakes.validatorStakes[i] = data.decodeValidatorStake();\r\n            }\r\n\r\n            uint256 stop = data.offset;\r\n            data.offset = start;\r\n            stakes.hash = data.peekSha256(stop - start);\r\n            data.offset = stop;\r\n        }\r\n    }\r\n\r\n    struct Signature {\r\n        uint8 enumIndex;\r\n        Borsh.ED25519Signature ed25519;\r\n        Borsh.SECP256K1Signature secp256k1;\r\n    }\r\n\r\n    function decodeSignature(Borsh.Data memory data) internal pure returns (Signature memory sig) {\r\n        sig.enumIndex = data.decodeU8();\r\n\r\n        if (sig.enumIndex == 0) {\r\n            sig.ed25519 = data.decodeED25519Signature();\r\n        } else if (sig.enumIndex == 1) {\r\n            sig.secp256k1 = data.decodeSECP256K1Signature();\r\n        } else {\r\n            revert(\"NearBridge: Only ED25519 and SECP256K1 signatures are supported\");\r\n        }\r\n    }\r\n\r\n    struct OptionalSignature {\r\n        bool none;\r\n        Signature signature;\r\n    }\r\n\r\n    function decodeOptionalSignature(Borsh.Data memory data) internal pure returns (OptionalSignature memory sig) {\r\n        sig.none = (data.decodeU8() == 0);\r\n        if (!sig.none) {\r\n            sig.signature = data.decodeSignature();\r\n        }\r\n    }\r\n\r\n    struct LightClientBlock {\r\n        bytes32 prev_block_hash;\r\n        bytes32 next_block_inner_hash;\r\n        BlockHeaderInnerLite inner_lite;\r\n        bytes32 inner_rest_hash;\r\n        OptionalValidatorStakes next_bps;\r\n        OptionalSignature[] approvals_after_next;\r\n        bytes32 hash;\r\n        bytes32 next_hash;\r\n    }\r\n\r\n    struct InitialValidators {\r\n        ValidatorStake[] validator_stakes;\r\n    }\r\n\r\n    function decodeInitialValidators(Borsh.Data memory data)\r\n        internal\r\n        view\r\n        returns (InitialValidators memory validators)\r\n    {\r\n        validators.validator_stakes = new ValidatorStake[](data.decodeU32());\r\n        for (uint i = 0; i < validators.validator_stakes.length; i++) {\r\n            validators.validator_stakes[i] = data.decodeValidatorStake();\r\n        }\r\n    }\r\n\r\n    function decodeLightClientBlock(Borsh.Data memory data) internal view returns (LightClientBlock memory header) {\r\n        header.prev_block_hash = data.decodeBytes32();\r\n        header.next_block_inner_hash = data.decodeBytes32();\r\n        header.inner_lite = data.decodeBlockHeaderInnerLite();\r\n        header.inner_rest_hash = data.decodeBytes32();\r\n        header.next_bps = data.decodeOptionalValidatorStakes();\r\n\r\n        header.approvals_after_next = new OptionalSignature[](data.decodeU32());\r\n        for (uint i = 0; i < header.approvals_after_next.length; i++) {\r\n            header.approvals_after_next[i] = data.decodeOptionalSignature();\r\n        }\r\n\r\n        header.hash = sha256(\r\n            abi.encodePacked(\r\n                sha256(abi.encodePacked(header.inner_lite.hash, header.inner_rest_hash)),\r\n                header.prev_block_hash\r\n            )\r\n        );\r\n\r\n        header.next_hash = sha256(abi.encodePacked(header.next_block_inner_hash, header.hash));\r\n    }\r\n\r\n    struct BlockHeaderInnerLite {\r\n        uint64 height; /// Height of this block since the genesis block (height 0).\r\n        bytes32 epoch_id; /// Epoch start hash of this block's epoch. Used for retrieving validator information\r\n        bytes32 next_epoch_id;\r\n        bytes32 prev_state_root; /// Root hash of the state at the previous block.\r\n        bytes32 outcome_root; /// Root of the outcomes of transactions and receipts.\r\n        uint64 timestamp; /// Timestamp at which the block was built.\r\n        bytes32 next_bp_hash; /// Hash of the next epoch block producers set\r\n        bytes32 block_merkle_root;\r\n        bytes32 hash; // Additional computable element\r\n    }\r\n\r\n    function decodeBlockHeaderInnerLite(Borsh.Data memory data)\r\n        internal\r\n        view\r\n        returns (BlockHeaderInnerLite memory header)\r\n    {\r\n        header.hash = data.peekSha256(208);\r\n        header.height = data.decodeU64();\r\n        header.epoch_id = data.decodeBytes32();\r\n        header.next_epoch_id = data.decodeBytes32();\r\n        header.prev_state_root = data.decodeBytes32();\r\n        header.outcome_root = data.decodeBytes32();\r\n        header.timestamp = data.decodeU64();\r\n        header.next_bp_hash = data.decodeBytes32();\r\n        header.block_merkle_root = data.decodeBytes32();\r\n    }\r\n}\r\n\r\n// File: rainbow-bridge/contracts/eth/nearprover/contracts/ProofDecoder.sol\r\n\r\npragma solidity ^0.6;\r\n\r\n\r\n\r\nlibrary ProofDecoder {\r\n    using Borsh for Borsh.Data;\r\n    using ProofDecoder for Borsh.Data;\r\n    using NearDecoder for Borsh.Data;\r\n\r\n    struct FullOutcomeProof {\r\n        ExecutionOutcomeWithIdAndProof outcome_proof;\r\n        MerklePath outcome_root_proof; // TODO: now empty array\r\n        BlockHeaderLight block_header_lite;\r\n        MerklePath block_proof;\r\n    }\r\n\r\n    function decodeFullOutcomeProof(Borsh.Data memory data) internal view returns (FullOutcomeProof memory proof) {\r\n        proof.outcome_proof = data.decodeExecutionOutcomeWithIdAndProof();\r\n        proof.outcome_root_proof = data.decodeMerklePath();\r\n        proof.block_header_lite = data.decodeBlockHeaderLight();\r\n        proof.block_proof = data.decodeMerklePath();\r\n    }\r\n\r\n    struct BlockHeaderLight {\r\n        bytes32 prev_block_hash;\r\n        bytes32 inner_rest_hash;\r\n        NearDecoder.BlockHeaderInnerLite inner_lite;\r\n        bytes32 hash; // Computable\r\n    }\r\n\r\n    function decodeBlockHeaderLight(Borsh.Data memory data) internal view returns (BlockHeaderLight memory header) {\r\n        header.prev_block_hash = data.decodeBytes32();\r\n        header.inner_rest_hash = data.decodeBytes32();\r\n        header.inner_lite = data.decodeBlockHeaderInnerLite();\r\n\r\n        header.hash = sha256(\r\n            abi.encodePacked(\r\n                sha256(abi.encodePacked(header.inner_lite.hash, header.inner_rest_hash)),\r\n                header.prev_block_hash\r\n            )\r\n        );\r\n    }\r\n\r\n    struct ExecutionStatus {\r\n        uint8 enumIndex;\r\n        bool unknown;\r\n        bool failed;\r\n        bytes successValue; /// The final action succeeded and returned some value or an empty vec.\r\n        bytes32 successReceiptId; /// The final action of the receipt returned a promise or the signed\r\n        /// transaction was converted to a receipt. Contains the receipt_id of the generated receipt.\r\n    }\r\n\r\n    function decodeExecutionStatus(Borsh.Data memory data)\r\n        internal\r\n        pure\r\n        returns (ExecutionStatus memory executionStatus)\r\n    {\r\n        executionStatus.enumIndex = data.decodeU8();\r\n        if (executionStatus.enumIndex == 0) {\r\n            executionStatus.unknown = true;\r\n        } else if (executionStatus.enumIndex == 1) {\r\n            //revert(\"NearDecoder: decodeExecutionStatus failure case not implemented yet\");\r\n            // Can avoid revert since ExecutionStatus is latest field in all parent structures\r\n            executionStatus.failed = true;\r\n        } else if (executionStatus.enumIndex == 2) {\r\n            executionStatus.successValue = data.decodeBytes();\r\n        } else if (executionStatus.enumIndex == 3) {\r\n            executionStatus.successReceiptId = data.decodeBytes32();\r\n        } else {\r\n            revert(\"NearDecoder: decodeExecutionStatus index out of range\");\r\n        }\r\n    }\r\n\r\n    struct ExecutionOutcome {\r\n        bytes[] logs; /// Logs from this transaction or receipt.\r\n        bytes32[] receipt_ids; /// Receipt IDs generated by this transaction or receipt.\r\n        uint64 gas_burnt; /// The amount of the gas burnt by the given transaction or receipt.\r\n        uint128 tokens_burnt; /// The total number of the tokens burnt by the given transaction or receipt.\r\n        bytes executor_id; /// Hash of the transaction or receipt id that produced this outcome.\r\n        ExecutionStatus status; /// Execution status. Contains the result in case of successful execution.\r\n        bytes32[] merkelization_hashes;\r\n    }\r\n\r\n    function decodeExecutionOutcome(Borsh.Data memory data) internal view returns (ExecutionOutcome memory outcome) {\r\n        outcome.logs = new bytes[](data.decodeU32());\r\n        for (uint i = 0; i < outcome.logs.length; i++) {\r\n            outcome.logs[i] = data.decodeBytes();\r\n        }\r\n\r\n        uint256 start = data.offset;\r\n        outcome.receipt_ids = new bytes32[](data.decodeU32());\r\n        for (uint i = 0; i < outcome.receipt_ids.length; i++) {\r\n            outcome.receipt_ids[i] = data.decodeBytes32();\r\n        }\r\n        outcome.gas_burnt = data.decodeU64();\r\n        outcome.tokens_burnt = data.decodeU128();\r\n        outcome.executor_id = data.decodeBytes();\r\n        outcome.status = data.decodeExecutionStatus();\r\n        uint256 stop = data.offset;\r\n\r\n        outcome.merkelization_hashes = new bytes32[](1 + outcome.logs.length);\r\n        data.offset = start;\r\n        outcome.merkelization_hashes[0] = data.peekSha256(stop - start);\r\n        data.offset = stop;\r\n        for (uint i = 0; i < outcome.logs.length; i++) {\r\n            outcome.merkelization_hashes[i + 1] = sha256(outcome.logs[i]);\r\n        }\r\n    }\r\n\r\n    struct ExecutionOutcomeWithId {\r\n        bytes32 id; /// The transaction hash or the receipt ID.\r\n        ExecutionOutcome outcome;\r\n        bytes32 hash;\r\n    }\r\n\r\n    function decodeExecutionOutcomeWithId(Borsh.Data memory data)\r\n        internal\r\n        view\r\n        returns (ExecutionOutcomeWithId memory outcome)\r\n    {\r\n        outcome.id = data.decodeBytes32();\r\n        outcome.outcome = data.decodeExecutionOutcome();\r\n\r\n        uint256 len = 1 + outcome.outcome.merkelization_hashes.length;\r\n        outcome.hash = sha256(\r\n            abi.encodePacked(\r\n                uint8((len >> 0) & 0xFF),\r\n                uint8((len >> 8) & 0xFF),\r\n                uint8((len >> 16) & 0xFF),\r\n                uint8((len >> 24) & 0xFF),\r\n                outcome.id,\r\n                outcome.outcome.merkelization_hashes\r\n            )\r\n        );\r\n    }\r\n\r\n    struct MerklePathItem {\r\n        bytes32 hash;\r\n        uint8 direction; // 0 = left, 1 = right\r\n    }\r\n\r\n    function decodeMerklePathItem(Borsh.Data memory data) internal pure returns (MerklePathItem memory item) {\r\n        item.hash = data.decodeBytes32();\r\n        item.direction = data.decodeU8();\r\n        require(item.direction < 2, \"ProofDecoder: MerklePathItem direction should be 0 or 1\");\r\n    }\r\n\r\n    struct MerklePath {\r\n        MerklePathItem[] items;\r\n    }\r\n\r\n    function decodeMerklePath(Borsh.Data memory data) internal pure returns (MerklePath memory path) {\r\n        path.items = new MerklePathItem[](data.decodeU32());\r\n        for (uint i = 0; i < path.items.length; i++) {\r\n            path.items[i] = data.decodeMerklePathItem();\r\n        }\r\n    }\r\n\r\n    struct ExecutionOutcomeWithIdAndProof {\r\n        MerklePath proof;\r\n        bytes32 block_hash;\r\n        ExecutionOutcomeWithId outcome_with_id;\r\n    }\r\n\r\n    function decodeExecutionOutcomeWithIdAndProof(Borsh.Data memory data)\r\n        internal\r\n        view\r\n        returns (ExecutionOutcomeWithIdAndProof memory outcome)\r\n    {\r\n        outcome.proof = data.decodeMerklePath();\r\n        outcome.block_hash = data.decodeBytes32();\r\n        outcome.outcome_with_id = data.decodeExecutionOutcomeWithId();\r\n    }\r\n}\r\n\r\n// File: rainbow-bridge/contracts/eth/nearprover/contracts/INearProver.sol\r\n\r\npragma solidity ^0.6;\r\n\r\ninterface INearProver {\r\n    function proveOutcome(bytes calldata proofData, uint64 blockHeight) external view returns (bool);\r\n}\r\n\r\n// File: contracts/Locker.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\n\r\n\r\ncontract Locker {\r\n    using Borsh for Borsh.Data;\r\n    using ProofDecoder for Borsh.Data;\r\n\r\n    INearProver public prover_;\r\n    bytes public nearTokenFactory_;\r\n\r\n    /// Proofs from blocks that are below the acceptance height will be rejected.\r\n    // If `minBlockAcceptanceHeight_` value is zero - proofs from block with any height are accepted.\r\n    uint64 public minBlockAcceptanceHeight_;\r\n\r\n    // OutcomeReciptId -> Used\r\n    mapping(bytes32 => bool) public usedProofs_;\r\n\r\n    constructor(bytes memory nearTokenFactory, INearProver prover, uint64 minBlockAcceptanceHeight) public {\r\n        require(nearTokenFactory.length > 0, \"Invalid Near Token Factory address\");\r\n        require(address(prover) != address(0), \"Invalid Near prover address\");\r\n\r\n        nearTokenFactory_ = nearTokenFactory;\r\n        prover_ = prover;\r\n        minBlockAcceptanceHeight_ = minBlockAcceptanceHeight;\r\n    }\r\n\r\n    /// Parses the provided proof and consumes it if it's not already used.\r\n    /// The consumed event cannot be reused for future calls.\r\n    function _parseAndConsumeProof(bytes memory proofData, uint64 proofBlockHeight)\r\n        internal\r\n        returns (ProofDecoder.ExecutionStatus memory result)\r\n    {\r\n        require(proofBlockHeight >= minBlockAcceptanceHeight_, \"Proof is from the ancient block\");\r\n        require(prover_.proveOutcome(proofData, proofBlockHeight), \"Proof should be valid\");\r\n\r\n        // Unpack the proof and extract the execution outcome.\r\n        Borsh.Data memory borshData = Borsh.from(proofData);\r\n        ProofDecoder.FullOutcomeProof memory fullOutcomeProof = borshData.decodeFullOutcomeProof();\r\n        require(borshData.finished(), \"Argument should be exact borsh serialization\");\r\n\r\n        bytes32 receiptId = fullOutcomeProof.outcome_proof.outcome_with_id.outcome.receipt_ids[0];\r\n        require(!usedProofs_[receiptId], \"The burn event proof cannot be reused\");\r\n        usedProofs_[receiptId] = true;\r\n\r\n        require(keccak256(fullOutcomeProof.outcome_proof.outcome_with_id.outcome.executor_id)\r\n                == keccak256(nearTokenFactory_),\r\n                \"Can only unlock tokens from the linked proof producer on Near blockchain\");\r\n\r\n        result = fullOutcomeProof.outcome_proof.outcome_with_id.outcome.status;\r\n        require(!result.failed, \"Cannot use failed execution outcome for unlocking the tokens\");\r\n        require(!result.unknown, \"Cannot use unknown execution outcome for unlocking the tokens\");\r\n    }\r\n}\r\n\r\n// File: contracts/ERC20Locker.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC20Locker is Locker, AdminControlled {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event Locked (\r\n        address indexed token,\r\n        address indexed sender,\r\n        uint256 amount,\r\n        string accountId\r\n    );\r\n\r\n    event Unlocked (\r\n        uint128 amount,\r\n        address recipient\r\n    );\r\n\r\n    // Function output from burning fungible token on Near side.\r\n    struct BurnResult {\r\n        uint128 amount;\r\n        address token;\r\n        address recipient;\r\n    }\r\n\r\n    uint constant UNPAUSED_ALL = 0;\r\n    uint constant PAUSED_LOCK = 1 << 0;\r\n    uint constant PAUSED_UNLOCK = 1 << 1;\r\n\r\n    // ERC20Locker is linked to the bridge token factory on NEAR side.\r\n    // It also links to the prover that it uses to unlock the tokens.\r\n    constructor(bytes memory nearTokenFactory,\r\n                INearProver prover,\r\n                uint64 minBlockAcceptanceHeight,\r\n                address _admin,\r\n                uint pausedFlags)\r\n        AdminControlled(_admin, pausedFlags)\r\n        Locker(nearTokenFactory, prover, minBlockAcceptanceHeight)\r\n        public\r\n    {\r\n    }\r\n\r\n    function lockToken(address ethToken, uint256 amount, string memory accountId)\r\n        public\r\n        pausable (PAUSED_LOCK)\r\n    {\r\n        require(IERC20(ethToken).balanceOf(address(this)).add(amount) <= ((uint256(1) << 128) - 1), \"Maximum tokens locked exceeded (< 2^128 - 1)\");\r\n        IERC20(ethToken).safeTransferFrom(msg.sender, address(this), amount);\r\n        emit Locked(address(ethToken), msg.sender, amount, accountId);\r\n    }\r\n\r\n    function unlockToken(bytes memory proofData, uint64 proofBlockHeight)\r\n        public\r\n        pausable (PAUSED_UNLOCK)\r\n    {\r\n        ProofDecoder.ExecutionStatus memory status = _parseAndConsumeProof(proofData, proofBlockHeight);\r\n        BurnResult memory result = _decodeBurnResult(status.successValue);\r\n        IERC20(result.token).safeTransfer(result.recipient, result.amount);\r\n        emit Unlocked(result.amount, result.recipient);\r\n    }\r\n\r\n    function _decodeBurnResult(bytes memory data) internal pure returns(BurnResult memory result) {\r\n        Borsh.Data memory borshData = Borsh.from(data);\r\n        uint8 flag = borshData.decodeU8();\r\n        require(flag == 0, \"ERR_NOT_WITHDRAW_RESULT\");\r\n        result.amount = borshData.decodeU128();\r\n        bytes20 token = borshData.decodeBytes20();\r\n        result.token = address(uint160(token));\r\n        bytes20 recipient = borshData.decodeBytes20();\r\n        result.recipient = address(uint160(recipient));\r\n    }\r\n\r\n    // tokenFallback implements the ContractReceiver interface from ERC223-token-standard.\r\n    // This allows to support ERC223 tokens with no extra cost.\r\n    // The function always passes: we don't need to make any decision and the contract always\r\n    // accept token transfers transfer.\r\n    function tokenFallback(address _from, uint _value, bytes memory _data) public pure {}\r\n\r\n    function adminTransfer(IERC20 token, address destination, uint amount)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        token.safeTransfer(destination, amount);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"nearTokenFactory\",\"type\":\"bytes\"},{\"internalType\":\"contract INearProver\",\"name\":\"prover\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"minBlockAcceptanceHeight\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pausedFlags\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"accountId\",\"type\":\"string\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"adminDelegatecall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"name\":\"adminPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminReceiveEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminSendEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"adminSstore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"accountId\",\"type\":\"string\"}],\"name\":\"lockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBlockAcceptanceHeight_\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nearTokenFactory_\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prover_\",\"outputs\":[{\"internalType\":\"contract INearProver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"proofBlockHeight\",\"type\":\"uint64\"}],\"name\":\"unlockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"usedProofs_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ERC20Locker","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000051ad3f020274910065dcb421629cd2e6e5b46c40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b8e11a1ad588863379a3e523b37d8c78070c16d900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000013666163746f72792e6272696467652e6e65617200000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6d64ebe7e8dc8585f64892cbd13c339ad76ab238b814ae2fd251f805a7149dd0"}]}