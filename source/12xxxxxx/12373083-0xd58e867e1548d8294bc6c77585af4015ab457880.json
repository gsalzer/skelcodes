{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/SaviourCRatioSetter.sol\npragma solidity =0.6.7 >=0.6.0 <0.8.0 >=0.6.7 <0.7.0;\n\n////// src/interfaces/GebSafeManagerLike.sol\n/* pragma solidity ^0.6.7; */\n\nabstract contract GebSafeManagerLike {\n    function safes(uint256) virtual public view returns (address);\n    function ownsSAFE(uint256) virtual public view returns (address);\n    function safeCan(address,uint256,address) virtual public view returns (uint256);\n}\n\n////// src/interfaces/OracleRelayerLike.sol\n/* pragma solidity ^0.6.7; */\n\nabstract contract OracleRelayerLike_2 {\n    function collateralTypes(bytes32) virtual public view returns (address, uint256, uint256);\n    function liquidationCRatio(bytes32) virtual public view returns (uint256);\n    function redemptionPrice() virtual public returns (uint256);\n}\n\n////// src/utils/ReentrancyGuard.sol\n// SPDX-License-Identifier: MIT\n\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n////// src/interfaces/SaviourCRatioSetterLike.sol\n/* pragma solidity 0.6.7; */\n\n/* import \"./OracleRelayerLike.sol\"; */\n/* import \"./GebSafeManagerLike.sol\"; */\n\n/* import \"../utils/ReentrancyGuard.sol\"; */\n\nabstract contract SaviourCRatioSetterLike is ReentrancyGuard {\n    // --- Auth ---\n    mapping (address => uint256) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"SaviourCRatioSetter/account-not-authorized\");\n        _;\n    }\n\n    // Checks whether someone controls a safe handler inside the GebSafeManager\n    modifier controlsSAFE(address owner, uint256 safeID) {\n        require(owner != address(0), \"SaviourCRatioSetter/null-owner\");\n        require(either(owner == safeManager.ownsSAFE(safeID), safeManager.safeCan(safeManager.ownsSAFE(safeID), safeID, owner) == 1), \"SaviourCRatioSetter/not-owning-safe\");\n\n        _;\n    }\n\n    // --- Variables ---\n    OracleRelayerLike_2  public oracleRelayer;\n    GebSafeManagerLike public safeManager;\n\n    // Default desired cratio for each individual collateral type\n    mapping(bytes32 => uint256)                     public defaultDesiredCollateralizationRatios;\n    // Minimum bound for the desired cratio for each collateral type\n    mapping(bytes32 => uint256)                     public minDesiredCollateralizationRatios;\n    // Desired CRatios for each SAFE after they're saved\n    mapping(bytes32 => mapping(address => uint256)) public desiredCollateralizationRatios;\n\n    // --- Constants ---\n    uint256 public constant MAX_CRATIO        = 1000;\n    uint256 public constant CRATIO_SCALE_DOWN = 10**25;\n\n    // --- Boolean Logic ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y) }\n    }\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 indexed parameter, address data);\n    event SetDefaultCRatio(bytes32 indexed collateralType, uint256 cRatio);\n    event SetMinDesiredCollateralizationRatio(\n      bytes32 indexed collateralType,\n      uint256 cRatio\n    );\n    event SetDesiredCollateralizationRatio(\n      address indexed caller,\n      bytes32 indexed collateralType,\n      uint256 safeID,\n      address indexed safeHandler,\n      uint256 cRatio\n    );\n\n    // --- Functions ---\n    function setDefaultCRatio(bytes32, uint256) virtual external;\n    function setMinDesiredCollateralizationRatio(bytes32 collateralType, uint256 cRatio) virtual external;\n    function setDesiredCollateralizationRatio(bytes32 collateralType, uint256 safeID, uint256 cRatio) virtual external;\n}\n\n////// src/math/SafeMath.sol\n// SPDX-License-Identifier: MIT\n\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\ncontract SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n////// src/SaviourCRatioSetter.sol\n/* pragma solidity 0.6.7; */\n\n/* import \"./interfaces/SaviourCRatioSetterLike.sol\"; */\n/* import \"./math/SafeMath.sol\"; */\n\ncontract SaviourCRatioSetter is SafeMath, SaviourCRatioSetterLike {\n    constructor(\n      address oracleRelayer_,\n      address safeManager_\n    ) public {\n        require(oracleRelayer_ != address(0), \"SaviourCRatioSetter/null-oracle-relayer\");\n        require(safeManager_ != address(0), \"SaviourCRatioSetter/null-safe-manager\");\n\n        authorizedAccounts[msg.sender] = 1;\n\n        oracleRelayer = OracleRelayerLike_2(oracleRelayer_);\n        safeManager   = GebSafeManagerLike(safeManager_);\n\n        oracleRelayer.redemptionPrice();\n\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"oracleRelayer\", oracleRelayer_);\n    }\n\n    // --- Administration ---\n    /**\n     * @notice Modify an address param\n     * @param parameter The name of the parameter\n     * @param data New address for the parameter\n     */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(data != address(0), \"SaviourCRatioSetter/null-data\");\n\n        if (parameter == \"oracleRelayer\") {\n            oracleRelayer = OracleRelayerLike_2(data);\n            oracleRelayer.redemptionPrice();\n        }\n        else revert(\"SaviourCRatioSetter/modify-unrecognized-param\");\n    }\n    /**\n     * @notice Set the default desired CRatio for a specific collateral type\n     * @param collateralType The name of the collateral type to set the default CRatio for\n     * @param cRatio New default collateralization ratio\n     */\n    function setDefaultCRatio(bytes32 collateralType, uint256 cRatio) external override isAuthorized {\n        uint256 scaledLiquidationRatio = oracleRelayer.liquidationCRatio(collateralType) / CRATIO_SCALE_DOWN;\n\n        require(scaledLiquidationRatio > 0, \"SaviourCRatioSetter/invalid-scaled-liq-ratio\");\n        require(both(cRatio > scaledLiquidationRatio, cRatio <= MAX_CRATIO), \"SaviourCRatioSetter/invalid-default-desired-cratio\");\n\n        defaultDesiredCollateralizationRatios[collateralType] = cRatio;\n\n        emit SetDefaultCRatio(collateralType, cRatio);\n    }\n    /*\n    * @notify Set the minimum CRatio that every Safe must take into account when setting a desired CRatio\n    * @param collateralType The collateral type for which to set the min desired CRatio\n    * @param cRatio The min desired CRatio to set for collateralType\n    */\n    function setMinDesiredCollateralizationRatio(bytes32 collateralType, uint256 cRatio) external override isAuthorized {\n        require(cRatio < MAX_CRATIO, \"SaviourCRatioSetter/invalid-min-cratio\");\n        minDesiredCollateralizationRatios[collateralType] = cRatio;\n        emit SetMinDesiredCollateralizationRatio(collateralType, cRatio);\n    }\n\n    // --- Adjust Cover Preferences ---\n    /*\n    * @notice Sets the collateralization ratio that a SAFE should have after it's saved\n    * @dev Only an address that controls the SAFE inside GebSafeManager can call this\n    * @param collateralType The collateral type used in the safe\n    * @param safeID The ID of the SAFE to set the desired CRatio for. This ID should be registered inside GebSafeManager\n    * @param cRatio The collateralization ratio to set\n    */\n    function setDesiredCollateralizationRatio(bytes32 collateralType, uint256 safeID, uint256 cRatio)\n      external override controlsSAFE(msg.sender, safeID) {\n        uint256 scaledLiquidationRatio = oracleRelayer.liquidationCRatio(collateralType) / CRATIO_SCALE_DOWN;\n        address safeHandler = safeManager.safes(safeID);\n\n        require(scaledLiquidationRatio > 0, \"SaviourCRatioSetter/invalid-scaled-liq-ratio\");\n        require(either(cRatio >= minDesiredCollateralizationRatios[collateralType], cRatio == 0), \"SaviourCRatioSetter/invalid-min-ratio\");\n        require(cRatio <= MAX_CRATIO, \"SaviourCRatioSetter/exceeds-max-cratio\");\n\n        if (cRatio > 0) {\n            require(scaledLiquidationRatio < cRatio, \"SaviourCRatioSetter/invalid-desired-cratio\");\n        }\n\n        desiredCollateralizationRatios[collateralType][safeHandler] = cRatio;\n\n        emit SetDesiredCollateralizationRatio(msg.sender, collateralType, safeID, safeHandler, cRatio);\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleRelayer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"safeManager_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cRatio\",\"type\":\"uint256\"}],\"name\":\"SetDefaultCRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safeHandler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cRatio\",\"type\":\"uint256\"}],\"name\":\"SetDesiredCollateralizationRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cRatio\",\"type\":\"uint256\"}],\"name\":\"SetMinDesiredCollateralizationRatio\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CRATIO_SCALE_DOWN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CRATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"defaultDesiredCollateralizationRatios\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"desiredCollateralizationRatios\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"minDesiredCollateralizationRatios\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleRelayer\",\"outputs\":[{\"internalType\":\"contract OracleRelayerLike_2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeManager\",\"outputs\":[{\"internalType\":\"contract GebSafeManagerLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"cRatio\",\"type\":\"uint256\"}],\"name\":\"setDefaultCRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"safeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cRatio\",\"type\":\"uint256\"}],\"name\":\"setDesiredCollateralizationRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"cRatio\",\"type\":\"uint256\"}],\"name\":\"setMinDesiredCollateralizationRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SaviourCRatioSetter","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004ed9c0dca0479bc64d8f4eb3007126d5791f7851000000000000000000000000efe0b4ca532769a3ae758fd82e1426a03a94f185","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}