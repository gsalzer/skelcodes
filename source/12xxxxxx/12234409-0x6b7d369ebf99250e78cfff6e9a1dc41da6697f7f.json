{"status":"1","message":"OK","result":[{"SourceCode":"{\"ApymonPack.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\u0027./IERC1155Receiver.sol\\u0027;\\nimport \\\"./ERC165.sol\\\";\\nimport \\u0027./Events.sol\\u0027;\\nimport \\u0027./Ownable.sol\\u0027;\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\\ninterface IERC721 {\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function totalSupply() external view returns (uint256);\\n    function exists(uint256 tokenId) external view returns (bool);\\n    function approve(address to, uint256 tokenId) external;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    function mintCreature() external returns (uint256 creatureId);\\n}\\n\\ninterface IERC1155 {\\n    function setApprovalForAll(address operator, bool approved) external;\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface ISwap {\\n    function swapErc20(\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inAmount,\\n        address outToken,\\n        uint8 router,\\n        address to\\n    ) external;\\n    function swapErc721(\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inId,\\n        address outToken,\\n        uint8 router,\\n        address to\\n    ) external;\\n    function swapErc1155(\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inId,\\n        uint256 inAmount,\\n        address outToken,\\n        uint256 outId,\\n        uint8 router,\\n        address to\\n    ) external;\\n}\\n\\ncontract ApymonPack is ERC165, IERC1155Receiver, IERC721Receiver, Context, Events, Ownable {\\n\\n    struct Token {\\n        uint8 tokenType; // 1: ERC20, 2: ERC721, 3: ERC1155\\n        address tokenAddress;\\n    }\\n\\n    // Token types\\n    uint8 private constant TOKEN_TYPE_ERC20 = 1;\\n    uint8 private constant TOKEN_TYPE_ERC721 = 2;\\n    uint8 private constant TOKEN_TYPE_ERC1155 = 3;\\n\\n    uint256 private constant MAX_EGG_SUPPLY = 6400;\\n\\n    // Mapping from egg ID -\\u003e token(erc20) -\\u003e balance\\n    mapping(uint256 =\\u003e mapping(address =\\u003e uint256)) private _insideERC20TokenBalances;\\n\\n    // Mapping from egg ID -\\u003e token(erc1155) -\\u003e tokenId -\\u003e balance\\n    mapping(uint256 =\\u003e mapping(address =\\u003e mapping(uint256 =\\u003e uint256))) private _insideERC1155TokenBalances;\\n\\n    // Mapping from egg ID -\\u003e tokens\\n    mapping(uint256 =\\u003e Token[]) private _insideTokens;\\n\\n    // Mapping from egg ID -\\u003e token(erc721 or erc1155) -\\u003e ids\\n    mapping(uint256 =\\u003e mapping(address =\\u003e uint256[])) private _insideTokenIds;\\n\\n    // Mapping from egg ID -\\u003e locked time\\n    mapping(uint256 =\\u003e uint256) private _lockedTimestamp;\\n\\n    // Mapping from egg ID -\\u003e opened\\n    mapping(uint256 =\\u003e bool) private _opened;\\n\\n    IERC721 public _apymon;\\n\\n    bool public _enableClose;\\n    ISwap public _swap;\\n\\n    modifier onlyEggOwner(uint256 eggId) {\\n        require(_apymon.exists(eggId));\\n        require(_apymon.ownerOf(eggId) == msg.sender);\\n        _;\\n    }\\n\\n    modifier unlocked(uint256 eggId) {\\n        require(\\n            _lockedTimestamp[eggId] == 0 ||\\n            _lockedTimestamp[eggId] \\u003c block.timestamp\\n        );\\n        _;\\n    }\\n\\n    modifier opened(uint256 eggId) {\\n        require(isOpened(eggId));\\n        _;\\n    }\\n\\n    constructor(\\n        address apymon\\n    ) {\\n        _apymon = IERC721(apymon);\\n        _enableClose = false;\\n    }\\n\\n    // View functions\\n\\n    /**\\n     * @dev check if egg has been locked.\\n     */\\n    function existsId(\\n        uint256 eggId,\\n        address token,\\n        uint256 id\\n    ) public view returns (bool) {\\n        uint256[] memory ids = _insideTokenIds[eggId][token];\\n\\n        for (uint256 i; i \\u003c ids.length; i++) {\\n            if (ids[i] == id) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @dev check if egg has been locked.\\n     */\\n    function isLocked(\\n        uint256 eggId\\n    ) external view returns (bool locked, uint256 endTime) {\\n        if (\\n            _lockedTimestamp[eggId] == 0 ||\\n            _lockedTimestamp[eggId] \\u003c block.timestamp\\n        ) {\\n            locked = false;\\n        } else {\\n            locked = true;\\n            endTime = _lockedTimestamp[eggId];\\n        }\\n    }\\n\\n    /**\\n     * @dev check if egg opened or not.\\n     */\\n    function isOpened(\\n        uint256 eggId\\n    ) public view returns (bool) {\\n        return _opened[eggId];\\n    }\\n\\n    /**\\n     * @dev check if claimed creature for certain egg.\\n     */\\n    function isClaimedCreature(\\n        uint256 eggId\\n    ) public view returns (bool) {\\n        return _apymon.exists(eggId + MAX_EGG_SUPPLY);\\n    }\\n\\n    /**\\n     * @dev check if tokenId exists in egg\\n     */\\n    function getInsideTokensCount(\\n        uint256 eggId\\n    ) public view opened(eggId) returns (\\n        uint256 erc20Len,\\n        uint256 erc721Len,\\n        uint256 erc1155Len\\n    ) {\\n        Token[] memory tokens = _insideTokens[eggId];\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            Token memory token = tokens[i];\\n            if (token.tokenType == TOKEN_TYPE_ERC20) {\\n                erc20Len += 1;\\n            }\\n            if (token.tokenType == TOKEN_TYPE_ERC721) {\\n                erc721Len += 1;\\n            }\\n            if (token.tokenType == TOKEN_TYPE_ERC1155) {\\n                erc1155Len += 1;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev get tokens by eggId\\n     */\\n    function getTokens(\\n        uint256 eggId\\n    ) external view opened(eggId) returns (\\n        uint8[] memory tokenTypes,\\n        address[] memory tokenAddresses\\n    ) {\\n        Token[] memory tokens = _insideTokens[eggId];\\n        \\n        tokenTypes = new uint8[](tokens.length);\\n        tokenAddresses = new address[](tokens.length);\\n\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            tokenTypes[i] = tokens[i].tokenType;\\n            tokenAddresses[i] = tokens[i].tokenAddress;\\n        }        \\n    }\\n\\n    /**\\n     * @dev get ERC20 token info\\n     */\\n    function getERC20Tokens(\\n        uint256 eggId\\n    ) public view opened(eggId) returns (\\n        address[] memory addresses,\\n        uint256[] memory tokenBalances\\n    ) {\\n        Token[] memory tokens = _insideTokens[eggId];\\n        (\\n            uint256 erc20Len,\\n            ,\\n        ) = getInsideTokensCount(eggId);\\n        \\n        tokenBalances = new uint256[](erc20Len);\\n        addresses = new address[](erc20Len);\\n        uint256 j;\\n\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            Token memory token = tokens[i];\\n            if (token.tokenType == TOKEN_TYPE_ERC20) {\\n                addresses[j] = token.tokenAddress;\\n                tokenBalances[j] = _insideERC20TokenBalances[eggId][token.tokenAddress];\\n                j++;\\n            }\\n        }        \\n    }\\n\\n    /**\\n     * @dev get ERC721 token info\\n     */\\n    function getERC721Tokens(\\n        uint256 eggId\\n    ) public view opened(eggId) returns (\\n        address[] memory addresses,\\n        uint256[] memory tokenBalances\\n    ) {\\n        Token[] memory tokens = _insideTokens[eggId];\\n        (\\n            ,\\n            uint256 erc721Len\\n            ,\\n        ) = getInsideTokensCount(eggId);\\n        \\n        tokenBalances = new uint256[](erc721Len);\\n        addresses = new address[](erc721Len);\\n        uint256 j;\\n\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            Token memory token = tokens[i];\\n            if (token.tokenType == TOKEN_TYPE_ERC721) {\\n                addresses[j] = token.tokenAddress;\\n                tokenBalances[j] = _insideTokenIds[eggId][token.tokenAddress].length;\\n                j++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev get ERC721 or ERC1155 ids\\n     */\\n    function getERC721OrERC1155Ids(\\n        uint256 eggId,\\n        address insideToken\\n    ) public view opened(eggId) returns (uint256[] memory) {\\n        return _insideTokenIds[eggId][insideToken];\\n    }\\n\\n    /**\\n     * @dev get ERC1155 token addresses info\\n     */\\n    function getERC1155Tokens(\\n        uint256 eggId\\n    ) public view opened(eggId) returns (address[] memory addresses) {\\n        Token[] memory tokens = _insideTokens[eggId];\\n        (\\n            ,\\n            ,\\n            uint256 erc1155Len\\n        ) = getInsideTokensCount(eggId);\\n        \\n        addresses = new address[](erc1155Len);\\n        uint256 j;\\n\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            Token memory token = tokens[i];\\n            if (token.tokenType == TOKEN_TYPE_ERC1155) {\\n                addresses[j] = token.tokenAddress;\\n                j++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev get ERC1155 token balances by ids\\n     */\\n    function getERC1155TokenBalances(\\n        uint256 eggId,\\n        address insideToken,\\n        uint256[] memory tokenIds\\n    ) public view opened(eggId) returns (uint256[] memory tokenBalances) {\\n        tokenBalances = new uint256[](tokenIds.length);\\n        for (uint256 i; i \\u003c tokenIds.length; i++) {\\n            tokenBalances[i] = _insideERC1155TokenBalances[eggId][insideToken][tokenIds[i]];\\n        }\\n    }\\n\\n    // Write functions\\n\\n    /**\\n     * @dev lock egg.\\n     */\\n    function lockEgg(\\n        uint256 eggId,\\n        uint256 timeInSeconds\\n    ) external onlyEggOwner(eggId) opened(eggId) unlocked(eggId) {\\n        _lockedTimestamp[eggId] = block.timestamp + timeInSeconds;\\n        emit LockedEgg(\\n            eggId,\\n            msg.sender,\\n            block.timestamp,\\n            block.timestamp + timeInSeconds\\n        );\\n    }\\n\\n    function setEnableClose(bool enabled) external onlyOwner {\\n        _enableClose = enabled;\\n    }\\n\\n    function setSwap(address swap) external onlyOwner {\\n        _swap = ISwap(swap);\\n    }\\n\\n    /**\\n     * @dev open egg.\\n     */\\n    function openEgg(\\n        uint256 eggId,\\n        bool isClaimCreature\\n    ) external onlyEggOwner(eggId) {\\n        _opened[eggId] = true;\\n        emit OpenedEgg(\\n            eggId,\\n            msg.sender\\n        );\\n\\n        if (isClaimCreature \\u0026\\u0026 !isClaimedCreature(eggId)) {\\n            claimCreature(eggId);\\n        }\\n    }\\n\\n    /**\\n     * @dev open egg.\\n     */\\n    function closeEgg(\\n        uint256 eggId\\n    ) external onlyEggOwner(eggId) {\\n        require(_enableClose == true);\\n        _opened[eggId] = false;\\n        emit ClosedEgg(\\n            eggId,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @dev deposit erc20 tokens into egg.\\n     */\\n    function depositErc20IntoEgg(\\n        uint256 eggId,\\n        address[] memory tokens,\\n        uint256[] memory amounts\\n    ) external {\\n        require(\\n            tokens.length \\u003e 0 \\u0026\\u0026\\n            tokens.length == amounts.length\\n        );\\n\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            require(tokens[i] != address(0));\\n            IERC20 iToken = IERC20(tokens[i]);\\n\\n            uint256 prevBalance = iToken.balanceOf(address(this));\\n            iToken.transferFrom(\\n                msg.sender,\\n                address(this),\\n                amounts[i]\\n            );\\n            uint256 receivedAmount = iToken.balanceOf(address(this)) - prevBalance;\\n\\n            _increaseInsideTokenBalance(\\n                eggId,\\n                TOKEN_TYPE_ERC20,\\n                tokens[i],\\n                receivedAmount\\n            );\\n\\n            emit DepositedErc20IntoEgg(\\n                eggId,\\n                msg.sender,\\n                tokens[i],\\n                receivedAmount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev withdraw erc20 tokens from egg.\\n     */\\n    function withdrawErc20FromEgg(\\n        uint256 eggId,\\n        address[] memory tokens,\\n        uint256[] memory amounts,\\n        address to\\n    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\\n        require(\\n            tokens.length \\u003e 0 \\u0026\\u0026\\n            tokens.length == amounts.length\\n        );\\n\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            require(tokens[i] != address(0));\\n            IERC20 iToken = IERC20(tokens[i]);\\n\\n            iToken.transfer(to, amounts[i]);\\n\\n            _decreaseInsideTokenBalance(\\n                eggId,\\n                TOKEN_TYPE_ERC20,\\n                tokens[i],\\n                amounts[i]\\n            );\\n            emit WithdrewErc20FromEgg(\\n                eggId,\\n                msg.sender,\\n                tokens[i],\\n                amounts[i],\\n                to\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev send erc20 tokens from my egg to another egg.\\n     */\\n    function sendErc20(\\n        uint256 fromEggId,\\n        address[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256 toEggId\\n    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\\n        require(fromEggId != toEggId);\\n        require(\\n            tokens.length \\u003e 0 \\u0026\\u0026\\n            tokens.length == amounts.length\\n        );\\n\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            require(tokens[i] != address(0));\\n            require(_apymon.exists(toEggId));\\n\\n            _decreaseInsideTokenBalance(\\n                fromEggId,\\n                TOKEN_TYPE_ERC20,\\n                tokens[i],\\n                amounts[i]\\n            );\\n\\n            _increaseInsideTokenBalance(\\n                toEggId,\\n                TOKEN_TYPE_ERC20,\\n                tokens[i],\\n                amounts[i]\\n            );\\n\\n            emit SentErc20(\\n                fromEggId,\\n                msg.sender,\\n                tokens[i],\\n                amounts[i],\\n                toEggId\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev deposit erc721 tokens into egg.\\n     */\\n    function depositErc721IntoEgg(\\n        uint256 eggId,\\n        address token,\\n        uint256[] memory tokenIds\\n    ) external {\\n        require(token != address(0));\\n\\n        for (uint256 i; i \\u003c tokenIds.length; i++) {\\n            require(\\n                token != address(this) ||\\n                (token == address(this) \\u0026\\u0026 eggId != tokenIds[i])\\n            );\\n            IERC721 iToken = IERC721(token);\\n            \\n            iToken.safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                tokenIds[i]\\n            );\\n\\n            _putInsideTokenId(\\n                eggId,\\n                token,\\n                tokenIds[i]\\n            );\\n\\n            emit DepositedErc721IntoEgg(\\n                eggId,\\n                msg.sender,\\n                token,\\n                tokenIds[i]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev withdraw erc721 token from egg.\\n     */\\n    function withdrawErc721FromEgg(\\n        uint256 eggId,\\n        address token,\\n        uint256[] memory tokenIds,\\n        address to\\n    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\\n        require(token != address(0));\\n        IERC721 iToken = IERC721(token);\\n\\n        for (uint256 i; i \\u003c tokenIds.length; i++) {\\n            address tokenOwner = iToken.ownerOf(tokenIds[i]);\\n\\n            require(tokenOwner == address(this));\\n\\n            iToken.safeTransferFrom(\\n                tokenOwner,\\n                to,\\n                tokenIds[i]\\n            );\\n\\n            _popInsideTokenId(\\n                eggId,\\n                token,\\n                tokenIds[i]\\n            );\\n\\n            emit WithdrewErc721FromEgg(\\n                eggId,\\n                msg.sender,\\n                token,\\n                tokenIds[i],\\n                to\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev send erc721 tokens from my egg to another egg.\\n     */\\n    function sendErc721(\\n        uint256 fromEggId,\\n        address token,\\n        uint256[] memory tokenIds,\\n        uint256 toEggId\\n    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\\n        require(fromEggId != toEggId);\\n        require(token != address(0));\\n        require(_apymon.exists(toEggId));\\n\\n        for (uint256 i; i \\u003c tokenIds.length; i++) {\\n            _popInsideTokenId(\\n                fromEggId,\\n                token,\\n                tokenIds[i]\\n            );\\n\\n            _putInsideTokenId(\\n                toEggId,\\n                token,\\n                tokenIds[i]\\n            );\\n\\n            emit SentErc721(\\n                fromEggId,\\n                msg.sender,\\n                token,\\n                tokenIds[i],\\n                toEggId\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev deposit erc1155 token into egg.\\n     */\\n    function depositErc1155IntoEgg(\\n        uint256 eggId,\\n        address token,\\n        uint256[] memory tokenIds,\\n        uint256[] memory amounts\\n    ) external {\\n        require(token != address(0));\\n        IERC1155 iToken = IERC1155(token);\\n\\n        for (uint256 i; i \\u003c tokenIds.length; i++) {\\n            iToken.safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                tokenIds[i],\\n                amounts[i],\\n                bytes(\\\"\\\")\\n            );\\n\\n            _putInsideTokenIdForERC1155(\\n                eggId,\\n                token,\\n                tokenIds[i]\\n            );\\n\\n            _increaseInsideERC1155TokenBalance(\\n                eggId,\\n                TOKEN_TYPE_ERC1155,\\n                token,\\n                tokenIds[i],\\n                amounts[i]\\n            );\\n            emit DepositedErc1155IntoEgg(\\n                eggId,\\n                msg.sender,\\n                token,\\n                tokenIds[i],\\n                amounts[i]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev withdraw erc1155 token from egg.\\n     */\\n    function withdrawErc1155FromEgg(\\n        uint256 eggId,\\n        address token,\\n        uint256[] memory tokenIds,\\n        uint256[] memory amounts,\\n        address to\\n    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\\n        require(token != address(0));\\n        IERC1155 iToken = IERC1155(token);\\n\\n        for (uint256 i; i \\u003c tokenIds.length; i++) {\\n            uint256 tokenId = tokenIds[i];\\n            uint256 amount = amounts[i];\\n\\n            iToken.safeTransferFrom(\\n                address(this),\\n                to,\\n                tokenId,\\n                amount,\\n                bytes(\\\"\\\")\\n            );\\n\\n            _decreaseInsideERC1155TokenBalance(\\n                eggId,\\n                token,\\n                tokenId,\\n                amount\\n            );\\n\\n            _popInsideTokenIdForERC1155(\\n                eggId,\\n                token,\\n                tokenId\\n            );\\n\\n            _popERC1155FromEgg(\\n                eggId,\\n                token,\\n                tokenId\\n            );\\n            emit WithdrewErc1155FromEgg(\\n                eggId,\\n                msg.sender,\\n                token,\\n                tokenId,\\n                amount,\\n                to\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev send erc1155 token from my egg to another egg.\\n     */\\n    function sendErc1155(\\n        uint256 fromEggId,\\n        address token,\\n        uint256[] memory tokenIds,\\n        uint256[] memory amounts,\\n        uint256 toEggId\\n    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\\n        require(fromEggId != toEggId);\\n        require(token != address(0));\\n        require(_apymon.exists(toEggId));\\n\\n        for (uint256 i; i \\u003c tokenIds.length; i++) {\\n            uint256 tokenId = tokenIds[i];\\n            uint256 amount = amounts[i];\\n\\n            _decreaseInsideERC1155TokenBalance(\\n                fromEggId,\\n                token,\\n                tokenId,\\n                amount\\n            );\\n\\n            _increaseInsideERC1155TokenBalance(\\n                toEggId,\\n                TOKEN_TYPE_ERC1155,\\n                token,\\n                tokenId,\\n                amount\\n            );\\n\\n            _popInsideTokenIdForERC1155(\\n                fromEggId,\\n                token,\\n                tokenId\\n            );\\n\\n            _putInsideTokenIdForERC1155(\\n                toEggId,\\n                token,\\n                tokenId\\n            );\\n\\n            _popERC1155FromEgg(\\n                fromEggId,\\n                token,\\n                tokenId\\n            );\\n            emit SentErc1155(\\n                fromEggId,\\n                msg.sender,\\n                token,\\n                tokenId,\\n                amount,\\n                toEggId\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev withdraw all of inside tokens into specific address.\\n     */\\n    function withdrawAll(\\n        uint256 eggId,\\n        address to\\n    ) external {\\n        require(to != address(0));\\n        (address[] memory erc20Addresses, uint256[] memory erc20Balances) = getERC20Tokens(eggId);\\n        withdrawErc20FromEgg(\\n            eggId,\\n            erc20Addresses,\\n            erc20Balances,\\n            to\\n        );\\n\\n        (address[] memory erc721Addresses, ) = getERC721Tokens(eggId);\\n        for (uint256 a; a \\u003c erc721Addresses.length; a++) {\\n            uint256[] memory ids = getERC721OrERC1155Ids(\\n                eggId,\\n                erc721Addresses[a]\\n            );\\n            withdrawErc721FromEgg(\\n                eggId,\\n                erc721Addresses[a],\\n                ids,\\n                to\\n            );\\n        }\\n\\n        address[] memory erc1155Addresses = getERC1155Tokens(eggId);\\n        for (uint256 a; a \\u003c erc1155Addresses.length; a++) {\\n            uint256[] memory ids = getERC721OrERC1155Ids(\\n                eggId,\\n                erc1155Addresses[a]\\n            );\\n            uint256[] memory tokenBalances = getERC1155TokenBalances(\\n                eggId,\\n                erc1155Addresses[a],\\n                ids\\n            );\\n            withdrawErc1155FromEgg(\\n                eggId,\\n                erc1155Addresses[a],\\n                ids,\\n                tokenBalances,\\n                to\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev send all of inside tokens to specific egg.\\n     */\\n    function sendAll(\\n        uint256 fromEggId,\\n        uint256 toEggId\\n    ) external {\\n        (\\n            address[] memory erc20Addresses,\\n            uint256[] memory erc20Balances\\n        ) = getERC20Tokens(fromEggId);\\n        sendErc20(\\n            fromEggId,\\n            erc20Addresses,\\n            erc20Balances,\\n            toEggId\\n        );\\n\\n        (\\n            address[] memory erc721Addresses\\n            ,\\n        ) = getERC721Tokens(fromEggId);\\n        for (uint256 a; a \\u003c erc721Addresses.length; a++) {\\n            uint256[] memory ids = getERC721OrERC1155Ids(\\n                fromEggId,\\n                erc721Addresses[a]\\n            );\\n            sendErc721(\\n                fromEggId,\\n                erc721Addresses[a],\\n                ids,\\n                toEggId\\n            );\\n        }\\n\\n        address[] memory erc1155Addresses = getERC1155Tokens(fromEggId);\\n        for (uint256 a; a \\u003c erc1155Addresses.length; a++) {\\n            uint256[] memory ids = getERC721OrERC1155Ids(\\n                fromEggId,\\n                erc1155Addresses[a]\\n            );\\n            uint256[] memory tokenBalances = getERC1155TokenBalances(\\n                fromEggId,\\n                erc1155Addresses[a],\\n                ids\\n            );\\n            sendErc1155(\\n                fromEggId,\\n                erc1155Addresses[a],\\n                ids,\\n                tokenBalances,\\n                toEggId\\n            );\\n        }\\n    }\\n    \\n    /**\\n     * @dev external function to increase token balance of egg\\n     */\\n    function increaseInsideTokenBalance(\\n        uint256 eggId,\\n        uint8 tokenType,\\n        address token,\\n        uint256 amount\\n    ) external {\\n        require(msg.sender != address(0));\\n        require(msg.sender == address(_apymon));\\n\\n        _increaseInsideTokenBalance(\\n            eggId,\\n            tokenType,\\n            token,\\n            amount\\n        );\\n    }\\n\\n    /**\\n     * @dev external function to put creature into egg\\n     * Must be called by egg owner\\n     */\\n    function claimCreature(\\n        uint256 eggId\\n    ) public onlyEggOwner(eggId) {\\n        uint256 creatureId = _apymon.mintCreature();\\n\\n        _putInsideTokenId(\\n            eggId,\\n            address(_apymon),\\n            creatureId\\n        );\\n\\n        emit DepositedErc721IntoEgg(\\n            eggId,\\n            address(this),\\n            address(_apymon),\\n            creatureId\\n        );\\n    }\\n\\n    function swapErc20(\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inAmount,\\n        address outToken,\\n        uint8 router,\\n        address to\\n    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\\n        require(address(_swap) != address(0));\\n        require(_insideERC20TokenBalances[eggId][inToken] \\u003e= inAmount);\\n\\n        IERC20(inToken).approve(address(_swap), inAmount);\\n\\n        _swap.swapErc20(\\n            eggId,\\n            inToken,\\n            inAmount,\\n            outToken,\\n            router,\\n            to\\n        );\\n        emit SwapedErc20(\\n            msg.sender,\\n            eggId,\\n            inToken,\\n            inAmount,\\n            outToken,\\n            to\\n        );\\n\\n        _decreaseInsideTokenBalance(\\n            eggId,\\n            TOKEN_TYPE_ERC20,\\n            inToken,\\n            inAmount\\n        );\\n    }\\n\\n    function swapErc721(\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inId,\\n        address outToken,\\n        uint8 router,\\n        address to\\n    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\\n        require(address(_swap) != address(0));\\n        require(existsId(eggId, inToken, inId));\\n        \\n        IERC721(inToken).approve(address(_swap), inId);\\n\\n        _swap.swapErc721(\\n            eggId,\\n            inToken,\\n            inId,\\n            outToken,\\n            router,\\n            to\\n        );\\n        emit SwapedErc721(\\n            msg.sender,\\n            eggId,\\n            inToken,\\n            inId,\\n            outToken,\\n            to\\n        );\\n\\n        _popInsideTokenId(\\n            eggId,\\n            inToken,\\n            inId\\n        );\\n    }\\n\\n    function swapErc1155(\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inId,\\n        uint256 inAmount,\\n        address outToken,\\n        uint256 outId,\\n        uint8 router,\\n        address to\\n    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\\n        require(address(_swap) != address(0));\\n        require(existsId(eggId, inToken, inId));\\n        require(\\n            _insideERC1155TokenBalances[eggId][inToken][inId] \\u003e= inAmount\\n        );\\n\\n        IERC1155(inToken).setApprovalForAll(address(_swap), true);\\n\\n        _swap.swapErc1155(\\n            eggId,\\n            inToken,\\n            inId,\\n            inAmount,\\n            outToken,\\n            outId,\\n            router,\\n            to\\n        );\\n        emit SwapedErc1155(\\n            msg.sender,\\n            eggId,\\n            inToken,\\n            inId,\\n            inAmount,\\n            outToken,\\n            outId,\\n            to\\n        );\\n\\n        _decreaseInsideERC1155TokenBalance(\\n            eggId,\\n            inToken,\\n            inId,\\n            inAmount\\n        );\\n\\n        _popInsideTokenIdForERC1155(\\n            eggId,\\n            inToken,\\n            inId\\n        );\\n\\n        _popERC1155FromEgg(\\n            eggId,\\n            inToken,\\n            inId\\n        );\\n    }\\n\\n    function _popERC1155FromEgg(\\n        uint256 eggId,\\n        address token,\\n        uint256 tokenId\\n    ) private {\\n        uint256[] memory ids = _insideTokenIds[eggId][token];\\n        if (\\n            _insideERC1155TokenBalances[eggId][token][tokenId] == 0 \\u0026\\u0026 \\n            ids.length == 0\\n        ) {\\n            delete _insideERC1155TokenBalances[eggId][token][tokenId];\\n            delete _insideTokenIds[eggId][token];\\n            _popTokenFromEgg(\\n                eggId,\\n                TOKEN_TYPE_ERC1155,\\n                token\\n            );\\n        }\\n    }\\n    \\n    /**\\n     * @dev private function to increase token balance of egg\\n     */\\n    function _increaseInsideTokenBalance(\\n        uint256 eggId,\\n        uint8 tokenType,\\n        address token,\\n        uint256 amount\\n    ) private {\\n        _insideERC20TokenBalances[eggId][token] += amount;\\n        _putTokenIntoEgg(\\n            eggId,\\n            tokenType,\\n            token\\n        );\\n    }\\n\\n    /**\\n     * @dev private function to increase erc1155 token balance of egg\\n     */\\n    function _increaseInsideERC1155TokenBalance(\\n        uint256 eggId,\\n        uint8 tokenType,\\n        address token,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) private {\\n        _insideERC1155TokenBalances[eggId][token][tokenId] += amount;\\n        _putTokenIntoEgg(\\n            eggId,\\n            tokenType,\\n            token\\n        );\\n    }\\n\\n    /**\\n     * @dev private function to decrease token balance of egg\\n     */\\n    function _decreaseInsideTokenBalance(\\n        uint256 eggId,\\n        uint8 tokenType,\\n        address token,\\n        uint256 amount\\n    ) private {\\n        require(_insideERC20TokenBalances[eggId][token] \\u003e= amount);\\n        _insideERC20TokenBalances[eggId][token] -= amount;\\n        if (_insideERC20TokenBalances[eggId][token] == 0) {\\n            delete _insideERC20TokenBalances[eggId][token];\\n            _popTokenFromEgg(\\n                eggId,\\n                tokenType,\\n                token\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev private function to decrease erc1155 token balance of egg\\n     */\\n    function _decreaseInsideERC1155TokenBalance(\\n        uint256 eggId,\\n        address token,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) private {\\n        require(_insideERC1155TokenBalances[eggId][token][tokenId] \\u003e= amount);\\n        _insideERC1155TokenBalances[eggId][token][tokenId] -= amount;\\n    }\\n\\n    /**\\n     * @dev private function to put a token id to egg\\n     */\\n    function _putInsideTokenId(\\n        uint256 eggId,\\n        address token,\\n        uint256 tokenId\\n    ) private {\\n        uint256[] storage ids = _insideTokenIds[eggId][token];\\n        ids.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev private function to put a token id to egg in ERC1155\\n     */\\n    function _putInsideTokenIdForERC1155(\\n        uint256 eggId,\\n        address token,\\n        uint256 tokenId\\n    ) private {\\n        uint256[] storage ids = _insideTokenIds[eggId][token];\\n        bool isExist;\\n        for (uint256 i; i \\u003c ids.length; i++) {\\n            if (ids[i] == tokenId) {\\n                isExist = true;\\n            }\\n        }\\n        if (!isExist) {\\n            ids.push(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev private function to pop a token id from egg\\n     */\\n    function _popInsideTokenId(\\n        uint256 eggId,\\n        address token,\\n        uint256 tokenId\\n    ) private {\\n        uint256[] storage ids = _insideTokenIds[eggId][token];\\n        for (uint256 i; i \\u003c ids.length; i++) {\\n            if (ids[i] == tokenId) {\\n                ids[i] = ids[ids.length - 1];\\n                ids.pop();\\n            }\\n        }\\n\\n        if (ids.length == 0) {\\n            delete _insideTokenIds[eggId][token];\\n        }\\n    }\\n\\n    /**\\n     * @dev private function to pop a token id from egg in ERC1155\\n     */\\n    function _popInsideTokenIdForERC1155(\\n        uint256 eggId,\\n        address token,\\n        uint256 tokenId\\n    ) private {\\n        uint256 tokenBalance = _insideERC1155TokenBalances[eggId][token][tokenId];\\n        if (tokenBalance \\u003c= 0) {\\n            delete _insideERC1155TokenBalances[eggId][token][tokenId];\\n            _popInsideTokenId(\\n                eggId,\\n                token,\\n                tokenId\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev put token(type, address) to egg\\n     */\\n    function _putTokenIntoEgg(\\n        uint256 eggId,\\n        uint8 tokenType,\\n        address tokenAddress\\n    ) private {\\n        Token[] storage tokens = _insideTokens[eggId];\\n        bool exists = false;\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            if (\\n                tokens[i].tokenType == tokenType \\u0026\\u0026\\n                tokens[i].tokenAddress == tokenAddress\\n            ) {\\n                exists = true;\\n                break;\\n            }\\n        }\\n\\n        if (!exists) {\\n            tokens.push(Token({\\n                tokenType: tokenType,\\n                tokenAddress: tokenAddress\\n            }));\\n        }\\n    }\\n\\n    /**\\n     * @dev pop token(type, address) from egg\\n     */\\n    function _popTokenFromEgg(\\n        uint256 eggId,\\n        uint8 tokenType,\\n        address tokenAddress\\n    ) private {\\n        Token[] storage tokens = _insideTokens[eggId];\\n        for (uint256 i; i \\u003c tokens.length; i++) {\\n            if (\\n                tokens[i].tokenType == tokenType \\u0026\\u0026\\n                tokens[i].tokenAddress == tokenAddress\\n            ) {\\n                tokens[i] = tokens[tokens.length - 1];\\n                tokens.pop();\\n                break;\\n            }\\n        }\\n\\n        if (tokens.length == 0) {\\n            delete _insideTokens[eggId];\\n        }\\n    }\\n   \\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns(bytes4) {\\n        return 0xf23a6e61;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external pure override returns(bytes4) {\\n        return 0xbc197c81;\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it\\u0027s supported.\\n     */\\n    mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n    constructor () {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"},\"Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ncontract Events {\\n    event LockedEgg(\\n        uint256 eggId,\\n        address indexed owner,\\n        uint256 startTimestamp,\\n        uint256 endTimestamp\\n    );\\n\\n    event OpenedEgg(\\n        uint256 eggId,\\n        address indexed owner\\n    );\\n\\n    event ClosedEgg(\\n        uint256 eggId,\\n        address indexed owner\\n    );\\n\\n    event DepositedErc20IntoEgg(\\n        uint256 eggId,\\n        address indexed owner,\\n        address indexed erc20Token,\\n        uint256 amount\\n    );\\n\\n    event WithdrewErc20FromEgg(\\n        uint256 eggId,\\n        address indexed owner,\\n        address indexed erc20Token,\\n        uint256 amount,\\n        address indexed to\\n    );\\n\\n    event SentErc20(\\n        uint256 fromEggId,\\n        address indexed owner,\\n        address indexed erc20Token,\\n        uint256 amount,\\n        uint256 toEggId\\n    );\\n\\n    event DepositedErc721IntoEgg(\\n        uint256 eggId,\\n        address indexed owner,\\n        address indexed erc721Token,\\n        uint256 tokenId\\n    );\\n\\n    event WithdrewErc721FromEgg(\\n        uint256 eggId,\\n        address indexed owner,\\n        address indexed erc721Token,\\n        uint256 tokenId,\\n        address indexed to\\n    );\\n\\n    event SentErc721(\\n        uint256 fromEggId,\\n        address indexed owner,\\n        address indexed erc721Token,\\n        uint256 tokenId,\\n        uint256 toEggId\\n    );\\n\\n    event DepositedErc1155IntoEgg(\\n        uint256 eggId,\\n        address indexed owner,\\n        address indexed erc1155Token,\\n        uint256 tokenId,\\n        uint256 amount\\n    );\\n\\n    event WithdrewErc1155FromEgg(\\n        uint256 eggId,\\n        address indexed owner,\\n        address indexed erc1155Token,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address indexed to\\n    );\\n\\n    event SentErc1155(\\n        uint256 fromEggId,\\n        address indexed owner,\\n        address indexed erc1155Token,\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint256 toEggId\\n    );\\n\\n    event SwapedErc20(\\n        address indexed owner,\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inAmount,\\n        address outToken,\\n        address indexed to\\n    );\\n\\n    event SwapedErc721(\\n        address indexed owner,\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inId,\\n        address outToken,\\n        address indexed to\\n    );\\n\\n    event SwapedErc1155(\\n        address indexed owner,\\n        uint256 eggId,\\n        address inToken,\\n        uint256 inId,\\n        uint256 inAmount,\\n        address outToken,\\n        uint256 outId,\\n        address indexed to\\n    );\\n}\"},\"IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller\\u0027s tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``\\u0027s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``\\u0027s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"},\"IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"apymon\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ClosedEgg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc1155Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositedErc1155IntoEgg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositedErc20IntoEgg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc721Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"DepositedErc721IntoEgg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"LockedEgg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OpenedEgg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromEggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc1155Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toEggId\",\"type\":\"uint256\"}],\"name\":\"SentErc1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromEggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toEggId\",\"type\":\"uint256\"}],\"name\":\"SentErc20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromEggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc721Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toEggId\",\"type\":\"uint256\"}],\"name\":\"SentErc721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SwapedErc1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SwapedErc20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SwapedErc721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc1155Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"WithdrewErc1155FromEgg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"WithdrewErc20FromEgg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc721Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"WithdrewErc721FromEgg\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_apymon\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_enableClose\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swap\",\"outputs\":[{\"internalType\":\"contract ISwap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"claimCreature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"closeEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"depositErc1155IntoEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"depositErc20IntoEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"depositErc721IntoEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"existsId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"insideToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getERC1155TokenBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenBalances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"getERC1155Tokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"getERC20Tokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenBalances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"insideToken\",\"type\":\"address\"}],\"name\":\"getERC721OrERC1155Ids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"getERC721Tokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenBalances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"getInsideTokensCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"erc20Len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc721Len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"erc1155Len\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"tokenTypes\",\"type\":\"uint8[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseInsideTokenBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"isClaimedCreature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"}],\"name\":\"isOpened\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeInSeconds\",\"type\":\"uint256\"}],\"name\":\"lockEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isClaimCreature\",\"type\":\"bool\"}],\"name\":\"openEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromEggId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toEggId\",\"type\":\"uint256\"}],\"name\":\"sendAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromEggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"toEggId\",\"type\":\"uint256\"}],\"name\":\"sendErc1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromEggId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"toEggId\",\"type\":\"uint256\"}],\"name\":\"sendErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromEggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"toEggId\",\"type\":\"uint256\"}],\"name\":\"sendErc721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setEnableClose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swap\",\"type\":\"address\"}],\"name\":\"setSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"router\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapErc1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"router\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"outToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"router\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"swapErc721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawErc1155FromEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawErc20FromEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawErc721FromEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ApymonPack","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009c008a22d71b6182029b694b0311486e4c0e53db","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://570696b3d3b32688d9d93a449eb5801f4b36d7ce391349d93a63614ba983adc7"}]}