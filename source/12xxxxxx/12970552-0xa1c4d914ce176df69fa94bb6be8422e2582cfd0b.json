{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.4;\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract StakingManager {\r\n    using SafeERC20 for IERC20;\r\n    \r\n    address public custodian_;\r\n    address public signOwner_;\r\n    mapping(uint32 => uint256) private bitmask_;\r\n    \r\n    event Deposit(address indexed caller, IERC20 indexed asset, uint256 amount);\r\n    event Withdraw(address indexed caller, uint32 block, uint8 bit, IERC20 indexed asset, uint256 amount);\r\n    \r\n    constructor(address _custodian, address _signOwner) {\r\n        custodian_ = _custodian;\r\n        signOwner_ = _signOwner;\r\n    }\r\n    \r\n    function deposit(IERC20 _asset, uint256 _amount) external {\r\n        _asset.safeTransferFrom(msg.sender, custodian_, _amount);\r\n\r\n        emit Deposit(msg.sender, _asset, _amount);\r\n    }\r\n\r\n    function withdraw(\r\n        uint32 _block,\r\n        uint8 _bit,\r\n        IERC20 _asset,\r\n        uint256 _amount,\r\n        bytes calldata _signature) external {\r\n\r\n        require(!isWithdrawn(_block, _bit), \"ERR_ALREADY_WITHDRAWN\");\r\n        \r\n        string memory message = string(abi.encodePacked(\r\n            _toAsciiString(msg.sender), \";\",\r\n            _toAsciiString(address(_asset)), \";\",\r\n            _uintToString(_block), \";\",\r\n            _uintToString(_bit), \";\",\r\n            _uintToString(_amount)));\r\n\r\n        _verify(message, _signature);\r\n        \r\n        _setWithdrawn(_block, _bit);\r\n        \r\n        _asset.safeTransfer(msg.sender, _amount);\r\n        \r\n        emit Withdraw(msg.sender, _block, _bit, _asset, _amount);\r\n    }\r\n\r\n    function isWithdrawn(uint32 _block, uint8 _bit) public view returns (bool) {\r\n        uint256 bitBlock = bitmask_[_block];\r\n        uint256 mask = uint256(1) << _bit;\r\n\r\n        return (bitBlock & mask) > 0;\r\n    }\r\n    \r\n    function _setWithdrawn(uint32 _block, uint8 _bit) private {\r\n        uint256 bitBlock = bitmask_[_block];\r\n        uint256 mask = uint256(1) << _bit;\r\n        \r\n        bitmask_[_block] = (bitBlock | mask);\r\n    }\r\n    \r\n   function _verify(string memory _message, bytes calldata _sig) private view {\r\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(abi.encodePacked(_message))));\r\n        address messageSigner = _recover(messageHash, _sig);\r\n\r\n        require(messageSigner == signOwner_, \"ERR_VERIFICATION_FAILED\");\r\n    }\r\n\r\n    function _recover(bytes32 _hash, bytes memory _sig) private pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        require(_sig.length == 65, \"ERR_RECOVER_SIG_SIZE\");\r\n\r\n        assembly {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            v := byte(0, mload(add(_sig, 96)))\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        require(v == 27 || v == 28, \"ERR_RECOVER_INVALID_SIG\");\r\n\r\n        return ecrecover(_hash, v, r, s);\r\n    }\r\n\r\n    function _uintToString(uint _i) private pure returns (string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k - 1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function _toAsciiString(address _addr) private pure returns (string memory) {\r\n        bytes memory s = new bytes(40);\r\n        for (uint i = 0; i < 20; i++) {\r\n            bytes1 b = bytes1(uint8(uint(uint160(_addr)) / (2 ** (8 * (19 - i)))));\r\n            bytes1 hi = bytes1(uint8(b) / 16);\r\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n            s[2 * i] = _char(hi);\r\n            s[2 * i + 1] = _char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    function _char(bytes1 value) private pure returns (bytes1) {\r\n        return (uint8(value) < 10) ? bytes1(uint8(value) + 0x30) : bytes1(uint8(value) + 0x57);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_custodian\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"block\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"bit\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"custodian_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_block\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_bit\",\"type\":\"uint8\"}],\"name\":\"isWithdrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signOwner_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_block\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_bit\",\"type\":\"uint8\"},{\"internalType\":\"contract IERC20\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakingManager","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bbfd44b1c7e76c2941a484f5c5dbbfa193d88ada000000000000000000000000b76ccb35c7bf6526966c65ec248930d8efed0db2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://18b8f369c117d01d2b9a95ca25fd0ce3cbad708c7338618df325b185ea99d764"}]}