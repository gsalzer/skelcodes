{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.3;\r\n\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\nlibrary Clones {\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create2(0, ptr, 0x37, salt)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create2 failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\r\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\r\n            mstore(add(ptr, 0x4c), salt)\r\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\r\n            predicted := keccak256(add(ptr, 0x37), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\r\n        return predictDeterministicAddress(implementation, salt, address(this));\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\ncontract Governance is ReentrancyGuard {\r\n\r\n\tuint constant public governance_challenging_period = 10 days;\r\n\tuint constant public governance_freeze_period = 30 days;\r\n\r\n\taddress public votingTokenAddress;\r\n\taddress public governedContractAddress;\r\n\r\n\tmapping(address => uint) public balances;\r\n\r\n\tVotedValue[] public votedValues;\r\n\tmapping(string => VotedValue) public votedValuesMap;\r\n\r\n\r\n\tconstructor(address _governedContractAddress, address _votingTokenAddress){\r\n\t\tinit(_governedContractAddress, _votingTokenAddress);\r\n\t}\r\n\r\n\tfunction init(address _governedContractAddress, address _votingTokenAddress) public {\r\n\t\trequire(governedContractAddress == address(0), \"governance already initialized\");\r\n\t\tgovernedContractAddress = _governedContractAddress;\r\n\t\tvotingTokenAddress = _votingTokenAddress;\r\n\t}\r\n\r\n\tfunction addressBelongsToGovernance(address addr) public view returns (bool) {\r\n\t\tfor (uint i = 0; i < votedValues.length; i++)\r\n\t\t\tif (address(votedValues[i]) == addr)\r\n\t\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction isUntiedFromAllVotes(address addr) public view returns (bool) {\r\n\t\tfor (uint i = 0; i < votedValues.length; i++)\r\n\t\t\tif (votedValues[i].hasVote(addr))\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction addVotedValue(string memory name, VotedValue votedValue) external {\r\n\t\trequire(msg.sender == governedContractAddress, \"not authorized\");\r\n\t\tvotedValues.push(votedValue);\r\n\t\tvotedValuesMap[name] = votedValue;\r\n\t}\r\n\r\n\r\n\t// deposit\r\n\r\n\tfunction deposit(uint amount) payable external {\r\n\t\tdeposit(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction deposit(address from, uint amount) nonReentrant payable public {\r\n\t\trequire(from == msg.sender || addressBelongsToGovernance(msg.sender), \"not allowed\");\r\n\t\tif (votingTokenAddress == address(0))\r\n\t\t\trequire(msg.value == amount, \"wrong amount received\");\r\n\t\telse {\r\n\t\t\trequire(msg.value == 0, \"don't send ETH\");\r\n\t\t\trequire(IERC20(votingTokenAddress).transferFrom(from, address(this), amount), \"failed to pull gov deposit\");\r\n\t\t}\r\n\t\tbalances[from] += amount;\r\n\t}\r\n\r\n\r\n\t// withdrawal functions\r\n\r\n\tfunction withdraw() external {\r\n\t\twithdraw(balances[msg.sender]);\r\n\t}\r\n\r\n\tfunction withdraw(uint amount) nonReentrant public {\r\n\t\trequire(amount > 0, \"zero withdrawal requested\");\r\n\t\trequire(amount <= balances[msg.sender], \"not enough balance\");\r\n\t\trequire(isUntiedFromAllVotes(msg.sender), \"some votes not removed yet\");\r\n\t\tbalances[msg.sender] -= amount;\r\n\t\tif (votingTokenAddress == address(0))\r\n\t\t\tpayable(msg.sender).transfer(amount);\r\n\t\telse\r\n\t\t\trequire(IERC20(votingTokenAddress).transfer(msg.sender, amount), \"failed to withdraw gov deposit\");\r\n\t}\r\n}\r\n\r\n\r\nabstract contract VotedValue is ReentrancyGuard {\r\n\tGovernance public governance;\r\n\tuint public challenging_period_start_ts;\r\n\tmapping(address => bool) public hasVote;\r\n\r\n\tconstructor(Governance _governance){\r\n\t\tgovernance = _governance;\r\n\t}\r\n\r\n\tfunction checkVoteChangeLock() view public {\r\n\t\trequire(challenging_period_start_ts + governance.governance_challenging_period() + governance.governance_freeze_period() < block.timestamp, \"you cannot change your vote yet\");\r\n\t}\r\n\r\n\tfunction checkChallengingPeriodExpiry() view public {\r\n\t\trequire(block.timestamp > challenging_period_start_ts + governance.governance_challenging_period(), \"challenging period not expired yet\");\r\n\t}\r\n}\r\n\r\n\r\ncontract VotedValueUint is VotedValue {\r\n\r\n\tfunction(uint) external validationCallback;\r\n\tfunction(uint) external commitCallback;\r\n\r\n\tuint public leader;\r\n\tuint public current_value;\r\n\r\n\tmapping(address => uint) public choices;\r\n\tmapping(uint => uint) public votesByValue;\r\n\tmapping(uint => mapping(address => uint)) public votesByValueAddress;\r\n\r\n\tconstructor() VotedValue(Governance(address(0))) {}\r\n\r\n\t// constructor(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) VotedValue(_governance) {\r\n\t// \tleader = initial_value;\r\n\t// \tcurrent_value = initial_value;\r\n\t// \tvalidationCallback = _validationCallback;\r\n\t// \tcommitCallback = _commitCallback;\r\n\t// }\r\n\r\n\tfunction init(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = _governance;\r\n\t\tleader = initial_value;\r\n\t\tcurrent_value = initial_value;\r\n\t\tvalidationCallback = _validationCallback;\r\n\t\tcommitCallback = _commitCallback;\r\n\t}\r\n\r\n\tfunction vote(uint value) nonReentrant external {\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction voteAndDeposit(uint value, uint amount) nonReentrant payable external {\r\n\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction _vote(uint value) private {\r\n\t\tvalidationCallback(value);\r\n\t\tuint prev_choice = choices[msg.sender];\r\n\t\tbool hadVote = hasVote[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\r\n\t\t// first, remove votes from the previous choice\r\n\t\tif (hadVote)\r\n\t\t\tremoveVote(prev_choice);\r\n\r\n\t\t// then, add them to the new choice\r\n\t\tuint balance = governance.balances(msg.sender);\r\n\t\trequire(balance > 0, \"no balance\");\r\n\t\tvotesByValue[value] += balance;\r\n\t\tvotesByValueAddress[value][msg.sender] = balance;\r\n\t\tchoices[msg.sender] = value;\r\n\t\thasVote[msg.sender] = true;\r\n\r\n\t\t// check if the leader has just changed\r\n\t\tif (votesByValue[value] > votesByValue[leader]){\r\n\t\t\tleader = value;\r\n\t\t\tchallenging_period_start_ts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unvote() external {\r\n\t\tif (!hasVote[msg.sender])\r\n\t\t\treturn;\r\n\t\tuint prev_choice = choices[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\t\t\r\n\t\tremoveVote(prev_choice);\r\n\t\tdelete choices[msg.sender];\r\n\t\tdelete hasVote[msg.sender];\r\n\t}\r\n\r\n\tfunction removeVote(uint value) internal {\r\n\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\r\n\t\tvotesByValueAddress[value][msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction commit() nonReentrant external {\r\n\t\trequire(leader != current_value, \"already equal to leader\");\r\n\t\tcheckChallengingPeriodExpiry();\r\n\t\tcurrent_value = leader;\r\n\t\tcommitCallback(leader);\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract VotedValueUintArray is VotedValue {\r\n\r\n\tfunction(uint[] memory) external validationCallback;\r\n\tfunction(uint[] memory) external commitCallback;\r\n\r\n\tuint[] public leader;\r\n\tuint[] public current_value;\r\n\r\n\tmapping(address => uint[]) public choices;\r\n\tmapping(bytes32 => uint) public votesByValue;\r\n\tmapping(bytes32 => mapping(address => uint)) public votesByValueAddress;\r\n\r\n\tconstructor() VotedValue(Governance(address(0))) {}\r\n\r\n\t// constructor(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) VotedValue(_governance) {\r\n\t// \tleader = initial_value;\r\n\t// \tcurrent_value = initial_value;\r\n\t// \tvalidationCallback = _validationCallback;\r\n\t// \tcommitCallback = _commitCallback;\r\n\t// }\r\n\r\n\tfunction init(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = _governance;\r\n\t\tleader = initial_value;\r\n\t\tcurrent_value = initial_value;\r\n\t\tvalidationCallback = _validationCallback;\r\n\t\tcommitCallback = _commitCallback;\r\n\t}\r\n\r\n\tfunction equal(uint[] memory a1, uint[] memory a2) public pure returns (bool) {\r\n\t\tif (a1.length != a2.length)\r\n\t\t\treturn false;\r\n\t\tfor (uint i = 0; i < a1.length; i++)\r\n\t\t\tif (a1[i] != a2[i])\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getKey(uint[] memory a) public pure returns (bytes32){\r\n\t\treturn keccak256(abi.encodePacked(a));\r\n\t}\r\n\r\n\tfunction vote(uint[] memory value) nonReentrant external {\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction voteAndDeposit(uint[] memory value, uint amount) nonReentrant payable external {\r\n\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction _vote(uint[] memory value) private {\r\n\t\tvalidationCallback(value);\r\n\t\tuint[] storage prev_choice = choices[msg.sender];\r\n\t\tbool hadVote = hasVote[msg.sender];\r\n\t\tif (equal(prev_choice, leader))\r\n\t\t\tcheckVoteChangeLock();\r\n\r\n\t\t// remove one's vote from the previous choice first\r\n\t\tif (hadVote)\r\n\t\t\tremoveVote(prev_choice);\r\n\r\n\t\t// then, add it to the new choice, if any\r\n\t\tbytes32 key = getKey(value);\r\n\t\tuint balance = governance.balances(msg.sender);\r\n\t\trequire(balance > 0, \"no balance\");\r\n\t\tvotesByValue[key] += balance;\r\n\t\tvotesByValueAddress[key][msg.sender] = balance;\r\n\t\tchoices[msg.sender] = value;\r\n\t\thasVote[msg.sender] = true;\r\n\r\n\t\t// check if the leader has just changed\r\n\t\tif (votesByValue[key] > votesByValue[getKey(leader)]){\r\n\t\t\tleader = value;\r\n\t\t\tchallenging_period_start_ts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unvote() external {\r\n\t\tif (!hasVote[msg.sender])\r\n\t\t\treturn;\r\n\t\tuint[] storage prev_choice = choices[msg.sender];\r\n\t\tif (equal(prev_choice, leader))\r\n\t\t\tcheckVoteChangeLock();\r\n\t\t\r\n\t\tremoveVote(prev_choice);\r\n\t\tdelete choices[msg.sender];\r\n\t\tdelete hasVote[msg.sender];\r\n\t}\r\n\r\n\tfunction removeVote(uint[] memory value) internal {\r\n\t\tbytes32 key = getKey(value);\r\n\t\tvotesByValue[key] -= votesByValueAddress[key][msg.sender];\r\n\t\tvotesByValueAddress[key][msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction commit() nonReentrant external {\r\n\t\trequire(!equal(leader, current_value), \"already equal to leader\");\r\n\t\tcheckChallengingPeriodExpiry();\r\n\t\tcurrent_value = leader;\r\n\t\tcommitCallback(leader);\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract VotedValueAddress is VotedValue {\r\n\r\n\tfunction(address) external validationCallback;\r\n\tfunction(address) external commitCallback;\r\n\r\n\taddress public leader;\r\n\taddress public current_value;\r\n\r\n\t// mapping(who => value)\r\n\tmapping(address => address) public choices;\r\n\r\n\t// mapping(value => votes)\r\n\tmapping(address => uint) public votesByValue;\r\n\r\n\t// mapping(value => mapping(who => votes))\r\n\tmapping(address => mapping(address => uint)) public votesByValueAddress;\r\n\r\n\tconstructor() VotedValue(Governance(address(0))) {}\r\n\r\n\t// constructor(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) VotedValue(_governance) {\r\n\t// \tleader = initial_value;\r\n\t// \tcurrent_value = initial_value;\r\n\t// \tvalidationCallback = _validationCallback;\r\n\t// \tcommitCallback = _commitCallback;\r\n\t// }\r\n\r\n\tfunction init(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = _governance;\r\n\t\tleader = initial_value;\r\n\t\tcurrent_value = initial_value;\r\n\t\tvalidationCallback = _validationCallback;\r\n\t\tcommitCallback = _commitCallback;\r\n\t}\r\n\r\n\tfunction vote(address value) nonReentrant external {\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction voteAndDeposit(address value, uint amount) nonReentrant payable external {\r\n\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction _vote(address value) private {\r\n\t\tvalidationCallback(value);\r\n\t\taddress prev_choice = choices[msg.sender];\r\n\t\tbool hadVote = hasVote[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\r\n\t\t// first, remove votes from the previous choice\r\n\t\tif (hadVote)\r\n\t\t\tremoveVote(prev_choice);\r\n\r\n\t\t// then, add them to the new choice\r\n\t\tuint balance = governance.balances(msg.sender);\r\n\t\trequire(balance > 0, \"no balance\");\r\n\t\tvotesByValue[value] += balance;\r\n\t\tvotesByValueAddress[value][msg.sender] = balance;\r\n\t\tchoices[msg.sender] = value;\r\n\t\thasVote[msg.sender] = true;\r\n\r\n\t\t// check if the leader has just changed\r\n\t\tif (votesByValue[value] > votesByValue[leader]){\r\n\t\t\tleader = value;\r\n\t\t\tchallenging_period_start_ts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unvote() external {\r\n\t\tif (!hasVote[msg.sender])\r\n\t\t\treturn;\r\n\t\taddress prev_choice = choices[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\t\t\r\n\t\tremoveVote(prev_choice);\r\n\t\tdelete choices[msg.sender];\r\n\t\tdelete hasVote[msg.sender];\r\n\t}\r\n\r\n\tfunction removeVote(address value) internal {\r\n\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\r\n\t\tvotesByValueAddress[value][msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction commit() nonReentrant external {\r\n\t\trequire(leader != current_value, \"already equal to leader\");\r\n\t\tcheckChallengingPeriodExpiry();\r\n\t\tcurrent_value = leader;\r\n\t\tcommitCallback(leader);\r\n\t}\r\n}\r\n\r\n\r\ncontract VotedValueFactory {\r\n\r\n\taddress public votedValueUintMaster;\r\n\taddress public votedValueUintArrayMaster;\r\n\taddress public votedValueAddressMaster;\r\n\r\n\tconstructor(address _votedValueUintMaster, address _votedValueUintArrayMaster, address _votedValueAddressMaster) {\r\n\t\tvotedValueUintMaster = _votedValueUintMaster;\r\n\t\tvotedValueUintArrayMaster = _votedValueUintArrayMaster;\r\n\t\tvotedValueAddressMaster = _votedValueAddressMaster;\r\n\t}\r\n\r\n\r\n\tfunction createVotedValueUint(Governance governance, uint initial_value, function(uint) external validationCallback, function(uint) external commitCallback) external returns (VotedValueUint) {\r\n\t\tVotedValueUint vv = VotedValueUint(Clones.clone(votedValueUintMaster));\r\n\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\r\n\t\treturn vv;\r\n\t}\r\n\r\n\tfunction createVotedValueUintArray(Governance governance, uint[] memory initial_value, function(uint[] memory) external validationCallback, function(uint[] memory) external commitCallback) external returns (VotedValueUintArray) {\r\n\t\tVotedValueUintArray vv = VotedValueUintArray(Clones.clone(votedValueUintArrayMaster));\r\n\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\r\n\t\treturn vv;\r\n\t}\r\n\r\n\tfunction createVotedValueAddress(Governance governance, address initial_value, function(address) external validationCallback, function(address) external commitCallback) external returns (VotedValueAddress) {\r\n\t\tVotedValueAddress vv = VotedValueAddress(Clones.clone(votedValueAddressMaster));\r\n\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\r\n\t\treturn vv;\r\n\t}\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_votedValueUintMaster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_votedValueUintArrayMaster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_votedValueAddressMaster\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract Governance\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initial_value\",\"type\":\"address\"},{\"internalType\":\"function (address) external\",\"name\":\"validationCallback\",\"type\":\"function\"},{\"internalType\":\"function (address) external\",\"name\":\"commitCallback\",\"type\":\"function\"}],\"name\":\"createVotedValueAddress\",\"outputs\":[{\"internalType\":\"contract VotedValueAddress\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Governance\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initial_value\",\"type\":\"uint256\"},{\"internalType\":\"function (uint256) external\",\"name\":\"validationCallback\",\"type\":\"function\"},{\"internalType\":\"function (uint256) external\",\"name\":\"commitCallback\",\"type\":\"function\"}],\"name\":\"createVotedValueUint\",\"outputs\":[{\"internalType\":\"contract VotedValueUint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Governance\",\"name\":\"governance\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"initial_value\",\"type\":\"uint256[]\"},{\"internalType\":\"function (uint256[]) external\",\"name\":\"validationCallback\",\"type\":\"function\"},{\"internalType\":\"function (uint256[]) external\",\"name\":\"commitCallback\",\"type\":\"function\"}],\"name\":\"createVotedValueUintArray\",\"outputs\":[{\"internalType\":\"contract VotedValueUintArray\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votedValueAddressMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votedValueUintArrayMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votedValueUintMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VotedValueFactory","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000016f5e8ad38cf676a0a78436ed8f5c8c19da3be3d000000000000000000000000ac6f466dfc250f612aa35e942dcf4a42e2156ce2000000000000000000000000ff4a6b38749c931b8f376d60515b81135ad5e464","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f0482399fd70cbd553cf209735245229b874816e82be2b23db72f3e26f3c5f0a"}]}