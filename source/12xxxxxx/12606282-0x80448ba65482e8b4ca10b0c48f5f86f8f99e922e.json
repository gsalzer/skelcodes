{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/IBGV1_flat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\ninterface IIBGEvents {\\n\\n    event Registration(address indexed _user, address indexed referrer, uint registrationTime);\\n    event PackPurchased(address indexed _user, uint indexed _pack, uint _plan, uint currentPackAmount, uint time);\\n    event StakedToken(address indexed stakedBy, uint amountStaked, uint plan, uint time, uint stakingPeriod);\\n    event DirectReferralIncome(address indexed _from, address indexed receiver, uint incomeRecieved, uint indexed level, uint time);\\n    event LostIncome(address indexed _from, address indexed reciever, uint incomeLost, uint indexed level, uint time);\\n    event YieldIncome(address indexed user, uint yieldRecieved, uint time);\\n    event YieldMatchingIncome(address indexed _from, address indexed receiver, uint incomeRecieved, uint indexed level, uint time);\\n    event YieldMatchingLostIncome(address indexed _from, address indexed reciever, uint matchingLostIncome, uint indexed level, uint time);\\n}\\n\\n\\nlibrary InvestmentLibrary {\\n\\n    struct Investment {\\n        uint plan;\\n        uint investment;\\n        uint investmentTime;\\n        uint stakingPeriod;\\n        uint yieldRateValue;\\n        bool isUnstaked;\\n        bool withdrawInvestment;\\n    }\\n}\\n\\n\\nlibrary IBGLibrary {\\n\\n    struct IBGPlan {\\n        uint IBGTokens;\\n        uint stakedIBGTokens;\\n        uint IBGYieldIncome;\\n        uint IBGYieldMatchingIncome;\\n        uint IBGYieldMatchingLostIncome;\\n        uint withdrawnInvestment;\\n        uint withdrawnYield;\\n    }\\n}\\n\\n\\nlibrary UserLibrary {\\n\\n    struct User {\\n        uint referralCount;\\n        uint directReferrerIncome;\\n        uint lostIncome;\\n        uint currentPlan;\\n        uint investmentCount;\\n        address referrer;\\n    }\\n\\n    function exists(User storage self) internal view returns (bool) {\\n        return self.investmentCount > 0;\\n    }\\n}\\n\\n\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{ value: value }(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\\n\\n\\n/**\\n * @title CustomOwnable\\n * @dev This contract has the owner address providing basic authorization control\\n */\\ncontract CustomOwnable {\\n    /**\\n     * @dev Event to show ownership has been transferred\\n     * @param previousOwner representing the address of the previous owner\\n     * @param newOwner representing the address of the new owner\\n     */\\n    event OwnershipTransferred(address previousOwner, address newOwner);\\n\\n    // Owner of the contract\\n    address private _owner;\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner(), \\\"CustomOwnable: FORBIDDEN\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev The constructor sets the original owner of the contract to the sender account.\\n     */\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Tells the address of the owner\\n     * @return the address of the owner\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Sets a new owner address\\n     */\\n    function _setOwner(address newOwner) internal {\\n        _owner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"CustomOwnable: FORBIDDEN\\\");\\n        emit OwnershipTransferred(owner(), newOwner);\\n        _setOwner(newOwner);\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n\\n\\n\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\\n\\n\\n\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\ncontract IBGV0 is IIBGEvents, CustomOwnable, ReentrancyGuard {\\n    using SafeMath for uint;\\n    using UserLibrary for UserLibrary.User;\\n    using IBGLibrary for IBGLibrary.IBGPlan;\\n    using InvestmentLibrary for InvestmentLibrary.Investment;\\n\\n    IERC20 public usdt;\\n    IERC20 ibg;\\n    IERC20 bgbf;\\n    address rootNode;\\n\\n    mapping(address => UserLibrary.User) public users;\\n    mapping(address => IBGLibrary.IBGPlan) public IBGPlanDetails;\\n    mapping(address => mapping(uint => InvestmentLibrary.Investment)) public cycleDetails;\\n\\n    bool internal _initialized;\\n\\n    uint public constant SERVICE_START_TIME = 1619521871;\\n\\n    uint private constant DECIMAL_FACTOR = 10**6;\\n    uint private constant DECIMAL_FACTOR_IBG = 10**18;\\n    uint private constant SECONDS_IN_DAY = 86400;\\n    uint private constant IBG_TO_USDT = 1 * DECIMAL_FACTOR_IBG;\\n\\n    uint private constant MAX_PACKS = 6;\\n    uint private constant MAX_PLANS = 3;\\n\\n    uint private constant IBG_PERCENTAGE = 20;\\n    uint private constant BGBF_PERCENTAGE = 10;\\n    uint private constant MAX_CURRENT_PLAN = DECIMAL_FACTOR_IBG ** 2;\\n\\n    uint private constant MAX_ELIGIBLE_REFERRER_WALKS = 25;\\n\\n\\n    uint ibgPercentage;\\n    uint bgbfPercentage;\\n    uint maxPacks;\\n    uint maxPlans;\\n    uint public maxWalks;\\n    uint public IBGToUsdt;\\n    uint public increaseIBGAfterLimit;\\n    uint public increaseRateIBG;\\n    uint public totalIBGDistributed;\\n    address treasuryWallet;\\n    address directCommissionWallet;\\n    address yieldMatchingWallet;\\n    address yieldWallet;\\n\\n    uint lastRate;\\n\\n    mapping(uint => string) public plans;\\n    mapping(uint => bool) public planActiveStatus;\\n    mapping(uint => uint) public packPrice;\\n    mapping(uint => uint) public stakingTime;\\n    mapping(uint => uint) public yieldRate;\\n    mapping(uint => uint) public directReferralRate;\\n    mapping(uint => uint) public yieldMatchingRate;\\n\\n    modifier onlyBeforeLaunch() {\\n        require(block.timestamp < SERVICE_START_TIME, \\\"IBGV0: Service Expired\\\");\\n        _;\\n    }\\n\\n    function initialize(address _governance, address _ibg, address _usdt, address _treasuryWallet) external {\\n        require(!_initialized, 'IBGV0: INVALID');\\n        _initialized = true;\\n        _setOwner(_governance);\\n        usdt = IERC20(_usdt);\\n        ibg = IERC20(_ibg);\\n        rootNode = _treasuryWallet;\\n        treasuryWallet = _treasuryWallet;\\n        directCommissionWallet = _treasuryWallet;\\n        yieldMatchingWallet = _treasuryWallet;\\n        yieldWallet = _treasuryWallet;\\n\\n\\n        users[rootNode].investmentCount = 1;\\n\\n        ibgPercentage = IBG_PERCENTAGE;\\n        bgbfPercentage = BGBF_PERCENTAGE;\\n\\n        IBGToUsdt = IBG_TO_USDT;\\n        increaseRateIBG = 10 * 10**16;\\n        increaseIBGAfterLimit = 100000 * DECIMAL_FACTOR_IBG;\\n        maxPacks = MAX_PACKS;\\n        maxPlans = MAX_PLANS;\\n        maxWalks = MAX_ELIGIBLE_REFERRER_WALKS;\\n\\n        directReferralRate[1] = 40;\\n        directReferralRate[2] = 30;\\n        directReferralRate[3] = 20;\\n\\n        plans[1] = \\\"IBG\\\";\\n        plans[2] = \\\"BGBF\\\";\\n        plans[3] = \\\"BLENDED\\\";\\n\\n        planActiveStatus[1] = true;\\n\\n        packPrice[1] = 100 * DECIMAL_FACTOR;\\n        packPrice[2] = 1000 * DECIMAL_FACTOR;\\n        packPrice[3] = 5000 * DECIMAL_FACTOR;\\n        packPrice[4] = 10000 * DECIMAL_FACTOR;\\n        packPrice[5] = 50000 * DECIMAL_FACTOR;\\n        packPrice[6] = 100000 * DECIMAL_FACTOR;\\n\\n        stakingTime[1] = 30;\\n        stakingTime[2] = 60;\\n        stakingTime[3] = 90;\\n\\n        yieldRate[stakingTime[1]] = 5;\\n        yieldRate[stakingTime[2]] = 6;\\n        yieldRate[stakingTime[3]] = 7;\\n\\n        yieldMatchingRate[1] = 30;\\n        yieldMatchingRate[2] = 20;\\n        yieldMatchingRate[3] = 10;\\n        yieldMatchingRate[4] = 10;\\n        yieldMatchingRate[5] = 10;\\n\\n        users[rootNode].currentPlan = MAX_CURRENT_PLAN;\\n        emit Registration(rootNode, address(0), block.timestamp);\\n    }\\n\\n    function setPackagePercentage(uint _value, uint plan) public onlyOwner {\\n        require(_value > 0 && _value <= 100, \\\"IBGV0: Invalid percentage\\\");\\n        if (plan == 1) {\\n            ibgPercentage = _value;\\n        } else if (plan == 2) {\\n            bgbfPercentage = _value;\\n        }\\n    }\\n\\n    function setIBGIncreaseBase(uint newBase) external virtual onlyOwner {\\n        require(newBase > 0, \\\"IBGV1: Non_Zero\\\");\\n        increaseIBGAfterLimit = newBase;\\n    }\\n\\n    function setIBGIncreaseRate(uint newRate) external virtual onlyOwner {\\n        require(newRate > 0, \\\"IBGV1: Non_Zero\\\");\\n        increaseRateIBG = newRate;\\n    }\\n\\n    function setlastRate(uint newRate) external virtual onlyOwner {\\n        lastRate = newRate;\\n    }\\n\\n    function registerAdmin(address _user, address _referrer, uint _pack, uint _plan, uint stakingPeriod) external virtual onlyOwner onlyBeforeLaunch nonReentrant {\\n        _register(_user, _referrer, _pack, _plan, stakingPeriod, true);\\n    }\\n\\n    function register(address _referrer, uint _pack, uint _plan, uint stakingPeriod) external virtual nonReentrant {\\n        _register(msg.sender, _referrer, _pack, _plan, stakingPeriod, false);\\n    }\\n\\n    function _register(address user, address _referrer, uint _pack, uint _plan, uint stakingPeriod, bool isAdmin) private {\\n        require(_pack >= 1 && _pack <= maxPacks, 'IBGV0: Invalid Pack');\\n        require(_plan >= 1 && _plan <= maxPlans, 'IBGV0: Invalid Plan');\\n        require(planActiveStatus[_plan], 'IBGV0: Plan is not active yet');\\n        require(stakingPeriod >= 1 && stakingPeriod <= 3, 'IBGV0: Invalid staking period');\\n        require(!users[user].exists(), 'IBGV0: User_Exists');\\n        require(users[_referrer].exists(), 'IBGV0: Referrer does not exists');\\n        uint value = packPrice[_pack];\\n\\n        if (!isAdmin) {\\n            TransferHelper.safeTransferFrom(address(usdt), user, address(this), value);\\n        }\\n\\n        users[user].referrer = _referrer;\\n        users[_referrer].referralCount++;\\n\\n        emit Registration(user, _referrer, block.timestamp);\\n\\n        _investment(user, _pack, _plan, value, stakingPeriod, isAdmin);\\n    }\\n\\n    function investmentAdmin(address _user, uint _pack, uint _plan, uint stakingPeriod) external virtual onlyOwner onlyBeforeLaunch nonReentrant {\\n        require(_pack >= 1 && _pack <= maxPacks, 'IBGV0: Invalid Pack');\\n        require(_plan >= 1 && _plan <= maxPlans, 'IBGV0: Invalid Plan');\\n        require(planActiveStatus[_plan], 'IBGV0: Plan is not active yet');\\n        require(stakingPeriod >= 1 && stakingPeriod <= 3, 'IBGV0: Invalid staking period');\\n        require(users[_user].exists(), \\\"IBGV0: User not registered yet\\\");\\n\\n        _investment(_user, _pack, _plan, packPrice[_pack], stakingPeriod, true);\\n    }\\n\\n    function investment(uint _pack, uint _plan, uint stakingPeriod) external virtual nonReentrant {\\n        require(_pack >= 1 && _pack <= maxPacks, 'IBGV0: Invalid Pack');\\n        require(_plan >= 1 && _plan <= maxPlans, 'IBGV0: Invalid Plan');\\n        require(planActiveStatus[_plan], 'IBGV0: Plan is not active yet');\\n        require(stakingPeriod >= 1 && stakingPeriod <= 3, 'IBGV0: Invalid staking period');\\n        require(users[msg.sender].exists(), \\\"IBGV0: User not registered yet\\\");\\n\\n        uint value = packPrice[_pack];\\n        TransferHelper.safeTransferFrom(address(usdt), msg.sender, address(this), value);\\n        _investment(msg.sender, _pack, _plan, value, stakingPeriod, false);\\n    }\\n\\n    function _investment(address _user, uint _pack, uint _plan, uint currentPackAmount, uint stakingPeriod, bool isAdmin) private {\\n        users[_user].investmentCount++;\\n        users[_user].currentPlan = users[_user].currentPlan.add(currentPackAmount);\\n\\n        InvestmentLibrary.Investment storage cycle = cycleDetails[_user][users[_user].investmentCount];\\n        cycle.investmentTime = block.timestamp;\\n        cycle.plan = _plan;\\n        cycle.stakingPeriod = stakingTime[stakingPeriod];\\n        cycle.yieldRateValue = yieldRate[stakingTime[stakingPeriod]];\\n        if(_plan == 1) {\\n            uint iBGAmount = (currentPackAmount.mul(DECIMAL_FACTOR_IBG)).div(DECIMAL_FACTOR);\\n            if (!isAdmin) {\\n                iBGAmount = ((iBGAmount).mul(DECIMAL_FACTOR_IBG)).div(IBGToUsdt);\\n                TransferHelper.safeTransfer(address(usdt), treasuryWallet, currentPackAmount.mul((uint(100)).sub(ibgPercentage)).div(100));\\n            }\\n\\n            cycle.investment = iBGAmount;\\n            totalIBGDistributed = totalIBGDistributed.add(iBGAmount);\\n            IBGPlanDetails[_user].IBGTokens = IBGPlanDetails[_user].IBGTokens.add(iBGAmount);\\n            IBGPlanDetails[_user].stakedIBGTokens = IBGPlanDetails[_user].stakedIBGTokens.add(iBGAmount);\\n            emit StakedToken(_user, iBGAmount, _plan, block.timestamp, stakingPeriod);\\n\\n            calculateIBGTokenPrice();\\n\\n            if (!isAdmin) {\\n                commisionTransfer(_user, users[_user].referrer, currentPackAmount, (currentPackAmount.mul(ibgPercentage).div(100)), ibgPercentage);\\n            }\\n        }\\n\\n        emit PackPurchased(_user, _pack, _plan, currentPackAmount, block.timestamp);\\n    }\\n\\n    function iBGYieldCommission(address user, address reciever, uint currentPlan, uint yieldDistributionAmount) private {\\n        uint level = 1;\\n        TransferHelper.safeTransfer(address(ibg), yieldMatchingWallet, (yieldDistributionAmount.mul(20)).div(100));\\n\\n        while(level <= 5) {\\n            uint amount = (yieldDistributionAmount.mul(yieldMatchingRate[level]).div(100));\\n            if(reciever == address(0)) {\\n                TransferHelper.safeTransfer(address(ibg), rootNode, amount);\\n                IBGPlanDetails[rootNode].IBGYieldMatchingIncome = IBGPlanDetails[rootNode].IBGYieldMatchingIncome.add(amount);\\n\\n                emit YieldMatchingIncome(user, rootNode, amount, level, block.timestamp);\\n            } else {\\n                if(users[reciever].currentPlan >= currentPlan) {\\n                    TransferHelper.safeTransfer(address(ibg), reciever, amount);\\n                    IBGPlanDetails[reciever].IBGYieldMatchingIncome = IBGPlanDetails[reciever].IBGYieldMatchingIncome.add(amount);\\n\\n                    emit YieldMatchingIncome(user, reciever, amount, level, block.timestamp);\\n                }\\n                else {\\n                    uint newAmount = ((amount).mul(users[reciever].currentPlan).div(currentPlan));\\n                    TransferHelper.safeTransfer(address(ibg), reciever, newAmount);\\n                    IBGPlanDetails[reciever].IBGYieldMatchingIncome = IBGPlanDetails[reciever].IBGYieldMatchingIncome.add(newAmount);\\n\\n                    emit YieldMatchingIncome(user, reciever, newAmount, level, block.timestamp);\\n\\n                    uint lostIncome = amount.sub(newAmount);\\n                    IBGPlanDetails[reciever].IBGYieldMatchingLostIncome = IBGPlanDetails[reciever].IBGYieldMatchingLostIncome.add(lostIncome);\\n\\n                    address eligibleUser = getEligibleReceiver(users[reciever].referrer, users[user].currentPlan);\\n                    TransferHelper.safeTransfer(address(ibg), eligibleUser, lostIncome);\\n                    IBGPlanDetails[eligibleUser].IBGYieldMatchingIncome = IBGPlanDetails[eligibleUser].IBGYieldMatchingIncome.add(lostIncome);\\n\\n                    emit YieldMatchingLostIncome(user, reciever, lostIncome, level, block.timestamp);\\n                    emit YieldMatchingIncome(user, eligibleUser, lostIncome, level, block.timestamp);\\n                }\\n            }\\n\\n            reciever = users[reciever].referrer;\\n            level++;\\n        }\\n    }\\n\\n    function commisionTransfer(address _from, address _receiver, uint currentPlan, uint distributeAmount, uint _basePercentage) private {\\n        TransferHelper.safeTransfer(address(usdt), directCommissionWallet, (distributeAmount.mul(10)).div(100));\\n        uint level = 1;\\n        while(level <= 3) {\\n            uint amount;\\n            amount = ((distributeAmount).mul(directReferralRate[level])).div(100);\\n            if(_receiver == address(0)) {\\n                TransferHelper.safeTransfer(address(usdt), rootNode, amount);\\n                users[rootNode].directReferrerIncome = users[rootNode].directReferrerIncome.add(amount);\\n                emit DirectReferralIncome(_from, rootNode, amount, level, block.timestamp);\\n            } else {\\n                if(users[_receiver].currentPlan >= users[_from].currentPlan) {\\n                    TransferHelper.safeTransfer(address(usdt), _receiver, amount);\\n                    users[_receiver].directReferrerIncome = users[_receiver].directReferrerIncome.add(amount);\\n                    emit DirectReferralIncome(_from, _receiver, amount, level, block.timestamp);\\n                } else {\\n                    uint prevPlan = users[_from].currentPlan.sub(currentPlan);\\n                    uint newAmount;\\n                    if (prevPlan < users[_receiver].currentPlan) {\\n                        newAmount = users[_receiver].currentPlan.sub(prevPlan);\\n                    }\\n\\n\\n                    if (newAmount > 0) {\\n                        newAmount = (((newAmount).mul(_basePercentage)).div(100));\\n                        newAmount = ((newAmount).mul(directReferralRate[level])).div(100);\\n                        TransferHelper.safeTransfer(address(usdt), _receiver, newAmount);\\n                        users[_receiver].directReferrerIncome = users[_receiver].directReferrerIncome.add(newAmount);\\n\\n                        emit DirectReferralIncome(_from, _receiver, newAmount, level, block.timestamp);\\n                    }\\n\\n\\n                    uint lostIncome = amount - newAmount;\\n\\n                    users[_receiver].lostIncome = users[_receiver].lostIncome.add(lostIncome);\\n                    address eligibleUser = getEligibleReceiver(users[_receiver].referrer, users[_from].currentPlan);\\n                    TransferHelper.safeTransfer(address(usdt), eligibleUser, lostIncome);\\n                    users[eligibleUser].directReferrerIncome = users[eligibleUser].directReferrerIncome.add(lostIncome);\\n                    emit LostIncome(_from, _receiver, lostIncome, level, block.timestamp);\\n                    emit DirectReferralIncome(_from, eligibleUser, lostIncome, level, block.timestamp);\\n                }\\n            }\\n\\n            _receiver = users[_receiver].referrer;\\n            level++;\\n        }\\n    }\\n\\n    function getEligibleReceiver(address _receiver, uint currentPlan) private view returns(address) {\\n        uint walks;\\n        while (_receiver != address(0) && walks++ < maxWalks) {\\n            if (users[_receiver].currentPlan >= currentPlan) {\\n                return _receiver;\\n            }\\n            _receiver = users[_receiver].referrer;\\n        }\\n\\n        return rootNode;\\n    }\\n\\n    function setMaxWalks(uint walks) external onlyOwner {\\n        require(walks > 0, 'IBGV0: Invalid walks');\\n        maxWalks = walks;\\n    }\\n\\n    function withdrawYield(bool onlyYield) external virtual nonReentrant {\\n        require(onlyYield || !onlyYield, \\\"IBGV0: Forbidden\\\");\\n    }\\n\\n    function _withdrawYield(address user) private {\\n        require(users[user].investmentCount > 0, 'IBGV0: Please invest to withdraw');\\n        _withdrawIBGYield(user, users[user].investmentCount, true);\\n    }\\n\\n    function _withdrawIBGYield(address user, uint cycles, bool onlyYield) private {\\n        require(users[user].investmentCount > 0, 'IBGV0: Please invest to withdraw');\\n        require(onlyYield, \\\"IBGV0: Only Yield\\\");\\n        uint totalYield;\\n        for(uint i = 1; i <= cycles; i++) {\\n            InvestmentLibrary.Investment storage cycle = cycleDetails[user][i];\\n            if(!cycle.isUnstaked && cycle.plan == 1) {\\n                uint daysDiff = (block.timestamp.sub(cycle.investmentTime)).div(SECONDS_IN_DAY);\\n                uint count;\\n                if(daysDiff >= (cycle.stakingPeriod)) {\\n                    count = (cycle.stakingPeriod).div(30);\\n                    cycleDetails[user][i].isUnstaked = true;\\n                    totalYield = totalYield.add(((cycle.investment).mul(count.mul(cycle.yieldRateValue))).div(100));\\n                    IBGPlanDetails[user].withdrawnYield = IBGPlanDetails[user].withdrawnYield.add(totalYield);\\n                }\\n            }\\n        }\\n\\n        if (totalYield == 0) {\\n            return;\\n        }\\n\\n        totalIBGDistributed = totalIBGDistributed.add(totalYield);\\n        calculateIBGTokenPrice();\\n\\n        uint yieldAmount = (totalYield.mul(95)).div(100);\\n        TransferHelper.safeTransfer(address(ibg), yieldWallet, ((totalYield).mul(5)).div(100));\\n        IBGPlanDetails[user].IBGYieldIncome = IBGPlanDetails[user].IBGYieldIncome.add(((yieldAmount).mul(90)).div(100));\\n        TransferHelper.safeTransfer(address(ibg), user, ((yieldAmount).mul(90)).div(100));\\n\\n        emit YieldIncome(msg.sender, ((yieldAmount).mul(90)).div(100), block.timestamp);\\n\\n        iBGYieldCommission(user, users[user].referrer, users[user].currentPlan, (yieldAmount.mul(10)).div(100));\\n    }\\n\\n    function withdrawInvestment(address user, bool withdraw, uint8 stakingPeriod) private {\\n        require(users[user].investmentCount > 0, 'IBGV0: Please invest to withdraw');\\n        if(!withdraw) {\\n            require(stakingPeriod >= 1 && stakingPeriod <= 3, 'IBGV0: Invalid staking period');\\n        }\\n        _withdrawInvestment(user, users[user].investmentCount, withdraw, stakingPeriod);\\n    }\\n\\n    function _withdrawInvestment(address user, uint cycles, bool withdraw, uint stakingPeriod) private {\\n        uint totalInvestment;\\n        uint reStakedInvestment;\\n        uint totalIBGAmount;\\n        if(withdraw) {\\n            totalIBGAmount = calculateTotalIBGInvest(user);\\n        }\\n        for(uint i = 1; i <= cycles; i++) {\\n            InvestmentLibrary.Investment storage cycle = cycleDetails[user][i];\\n            if(cycle.plan == 1 && !cycle.withdrawInvestment) {\\n                uint daysDiff = (block.timestamp.sub(cycle.investmentTime)).div(SECONDS_IN_DAY);\\n                if(daysDiff >= (cycle.stakingPeriod)) {\\n                    if(withdraw) {\\n                        IBGPlanDetails[user].stakedIBGTokens = IBGPlanDetails[user].stakedIBGTokens.sub(cycle.investment);\\n                        totalInvestment = totalInvestment.add(cycle.investment);\\n                    } else {\\n                       reStakedInvestment = reStakedInvestment.add(cycle.investment);\\n                    }\\n                    cycle.withdrawInvestment = true;\\n                }\\n            }\\n        }\\n\\n        if(totalInvestment > 0 && withdraw) {\\n            TransferHelper.safeTransfer(address(ibg), user, totalInvestment);\\n            IBGPlanDetails[user].withdrawnInvestment = IBGPlanDetails[user].withdrawnInvestment.add(totalInvestment);\\n            demotePack(user, totalIBGAmount, totalInvestment);\\n        }\\n\\n        if(!withdraw && reStakedInvestment > 0) {\\n            reStakeInvestment(user, reStakedInvestment, stakingPeriod);\\n        }\\n    }\\n\\n    function reStakeInvestment(address user, uint investmentAmount, uint stakingPeriod) private {\\n        users[user].investmentCount++;\\n        InvestmentLibrary.Investment storage cycle = cycleDetails[user][users[user].investmentCount];\\n        cycle.investmentTime = block.timestamp;\\n        cycle.plan = 1;\\n        cycle.stakingPeriod = stakingTime[stakingPeriod];\\n        cycle.yieldRateValue = yieldRate[stakingTime[stakingPeriod]];\\n        cycle.investment = investmentAmount;\\n    }\\n\\n    function _restakeYieldAndInvestment(address user, uint8 stakingPeriod) private {\\n        require(users[user].investmentCount > 0, 'IBGV0: Please invest to withdraw');\\n        require(stakingPeriod >= 1 && stakingPeriod <= 3, 'IBGV0: Invalid staking period');\\n\\n        uint totalStakeAmount;\\n        for(uint i = 1; i <= users[user].investmentCount; i++) {\\n            uint totalYield;\\n            InvestmentLibrary.Investment storage cycle = cycleDetails[user][i];\\n            if(!cycle.isUnstaked && cycle.plan == 1) {\\n                uint daysDiff = (block.timestamp.sub(cycle.investmentTime)).div(SECONDS_IN_DAY);\\n                uint count;\\n                if(daysDiff >= (cycle.stakingPeriod)) {\\n                    count = (cycle.stakingPeriod).div(30);\\n                    totalYield = totalYield.add(((cycle.investment).mul(count.mul(cycle.yieldRateValue))).div(100));\\n                    cycle.isUnstaked = true;\\n                }\\n            }\\n            if(totalYield > 0) {\\n                uint yieldAmount = (totalYield.mul(95)).div(100);\\n                TransferHelper.safeTransfer(address(ibg), yieldWallet, ((totalYield).mul(5)).div(100));\\n                totalStakeAmount = totalStakeAmount.add(yieldAmount);\\n            }\\n            if(cycle.plan == 1 && !cycle.withdrawInvestment) {\\n                uint daysDiff = (block.timestamp.sub(cycle.investmentTime)).div(SECONDS_IN_DAY);\\n                if(daysDiff >= (cycle.stakingPeriod)) {\\n                    totalStakeAmount = totalStakeAmount.add(cycle.investment);\\n                    cycle.withdrawInvestment = true;\\n                }\\n            }\\n        }\\n        if(totalStakeAmount > 0) {\\n            reStakeInvestment(user, totalStakeAmount, stakingPeriod);\\n        }\\n    }\\n\\n    function yieldAndInvestment(uint8 operation, uint8 stakingPeriod) public {\\n        require(users[msg.sender].investmentCount > 0, 'IBGV0: Please invest to withdraw');\\n        require(operation >= 0 && operation <= 3, 'IBGV0: Invalid operation');\\n        if(operation == 1 && operation == 3) {\\n            require(stakingPeriod >= 1 && stakingPeriod <= 3, 'IBGV0: Invalid staking period');\\n        }\\n        if(operation == 0) {\\n            _withdrawYield(msg.sender);\\n        } else if(operation == 1) {\\n            _withdrawYield(msg.sender);\\n            withdrawInvestment(msg.sender, true, stakingPeriod);\\n        } else if(operation == 2) {\\n            withdrawInvestment(msg.sender, false, stakingPeriod);\\n        } else if(operation == 3) {\\n            _restakeYieldAndInvestment(msg.sender, stakingPeriod);\\n        }\\n    }\\n\\n    function calculateTotalIBGInvest(address user) private view returns(uint) {\\n        uint total;\\n        for(uint i = 1; i <= users[user].investmentCount; i++) {\\n            InvestmentLibrary.Investment storage cycle = cycleDetails[user][i];\\n            if(!cycle.withdrawInvestment) {\\n                total = total.add(cycle.investment);\\n            }\\n        }\\n        return total;\\n    }\\n\\n    function calculateStakedInvestment(address user) public view returns(uint) {\\n        uint stakedInvestment;\\n        for(uint i = 1; i <= users[user].investmentCount; i++) {\\n            InvestmentLibrary.Investment storage cycle = cycleDetails[user][i];\\n            uint daysDiff = (block.timestamp.sub(cycle.investmentTime)).div(SECONDS_IN_DAY);\\n            if(daysDiff < (cycle.stakingPeriod)) {\\n                stakedInvestment = stakedInvestment.add(cycle.investment);\\n            }\\n        }\\n        return stakedInvestment;\\n    }\\n\\n    function calculateAccumulatedYield(address user) public view returns(uint) {\\n        uint accumulatedYield;\\n        for(uint i = 1; i <= users[user].investmentCount; i++) {\\n            InvestmentLibrary.Investment storage cycle = cycleDetails[user][i];\\n            uint count;\\n            uint daysDiff = (block.timestamp.sub(cycle.investmentTime)).div(SECONDS_IN_DAY);\\n            if(daysDiff >= (cycle.stakingPeriod)) {\\n                count = (cycle.stakingPeriod).div(30);\\n                accumulatedYield = accumulatedYield.add(((cycle.investment).mul(count.mul(cycle.yieldRateValue))).div(100));\\n            }\\n        }\\n        return accumulatedYield;\\n    }\\n\\n    function demotePack(address user, uint totalIBGAmount, uint IBGAmount) private {\\n        uint afterSellIbg = totalIBGAmount.sub(IBGAmount);\\n        uint newPlanUsdt = ((((afterSellIbg).mul(IBGToUsdt)).div(DECIMAL_FACTOR_IBG)).div(DECIMAL_FACTOR_IBG)).mul(DECIMAL_FACTOR);\\n        if(newPlanUsdt <= users[user].currentPlan) {\\n            users[user].currentPlan = newPlanUsdt;\\n        }\\n    }\\n\\n    function calculateYieldAndInvestment(address user) public view returns(uint withdrawableYield, uint withdrawableInvestment) {\\n        uint totalYield;\\n        uint totalInvestment;\\n        for(uint i = 1; i <= users[user].investmentCount; i++) {\\n            InvestmentLibrary.Investment storage cycle = cycleDetails[user][i];\\n            if(!cycle.isUnstaked && cycle.plan == 1) {\\n                uint daysDiff = (block.timestamp.sub(cycle.investmentTime)).div(SECONDS_IN_DAY);\\n                uint count;\\n                if(daysDiff >= (cycle.stakingPeriod)) {\\n                    count = (cycle.stakingPeriod).div(30);\\n                    totalYield = totalYield.add(((cycle.investment).mul(count.mul(cycle.yieldRateValue))).div(100));\\n                }\\n            }\\n            if(cycle.plan == 1 && !cycle.withdrawInvestment) {\\n                uint daysDiff = (block.timestamp.sub(cycle.investmentTime)).div(SECONDS_IN_DAY);\\n                if(daysDiff >= (cycle.stakingPeriod)) {\\n                    totalInvestment = totalInvestment.add(cycle.investment);\\n                }\\n            }\\n        }\\n        return (totalYield, totalInvestment);\\n    }\\n\\n    function calculateIBGTokenPrice() private {\\n        uint newValue = totalIBGDistributed.div(increaseIBGAfterLimit);\\n        if(newValue > lastRate) {\\n            lastRate = newValue;\\n            newValue = newValue.mul(increaseRateIBG);\\n            IBGToUsdt = (1 * DECIMAL_FACTOR_IBG).add(newValue);\\n        }\\n    }\\n\\n    function getInvestmentDetails(address _user, uint _id) external view returns (uint plan, uint investmentAmount, uint investmentTime, uint stakingPeriod, bool isUnstaked) {\\n        return(\\n            cycleDetails[_user][_id].plan,\\n            cycleDetails[_user][_id].investment,\\n            cycleDetails[_user][_id].investmentTime,\\n            cycleDetails[_user][_id].stakingPeriod,\\n            cycleDetails[_user][_id].isUnstaked\\n        );\\n    }\\n\\n    function updateDirectReferralRate(uint index, uint value) external virtual onlyOwner {\\n        require(index > 0 && index < 4, 'IBGV0: Index length must be between 1 to 3');\\n        require(value > 0 && value <= 100,'IBGV0: Invalid Value');\\n        directReferralRate[index] = value;\\n    }\\n\\n    function updateYieldMatchingRate(uint index, uint value) external virtual onlyOwner {\\n        require(index > 0 && index < 6, 'IBGV0: Index length must be between 1 to 5');\\n        require(value > 0 && value <= 100,'IBGV0: Invalid Value');\\n        yieldMatchingRate[index] = value;\\n    }\\n\\n\\n    function updatePack(uint packNumber, uint price) external virtual onlyOwner returns(uint, uint) {\\n        require((packNumber > 0 && packNumber <= maxPacks.add(1)), \\\"IBGV0: Invalid PackNumber\\\");\\n        require(price > 0, \\\"IBGV0: Invalid Packprice\\\");\\n        packPrice[packNumber] = price;\\n\\n        if(packNumber > maxPacks) {\\n            maxPacks = packNumber;\\n        }\\n\\n        return(packNumber, packPrice[packNumber]);\\n    }\\n\\n    function updatePlan(uint planNumber, string calldata planName) external virtual onlyOwner returns(uint, string memory) {\\n        require((planNumber > 0 && planNumber <= maxPlans.add(1)), \\\"IBGV0: Invalid PlanNumber\\\");\\n        require(keccak256(abi.encodePacked(planName)) != keccak256(abi.encodePacked('')), \\\"IBGV0: Invalid Plan name\\\");\\n        plans[planNumber] = planName;\\n\\n        if(planNumber > maxPlans) {\\n            maxPlans = planNumber;\\n        }\\n\\n        return(planNumber, plans[planNumber]);\\n    }\\n\\n    function updateStakingTime(uint timeIndex, uint timeValue) external virtual onlyOwner returns(uint, uint) {\\n        require(timeIndex > 0, 'IBGV0: Invalid TimeIndex');\\n        require(timeValue > 0, 'IBGV0: Invalid TimeValue');\\n        stakingTime[timeIndex] = timeValue;\\n        return(timeIndex, stakingTime[timeIndex]);\\n\\n    }\\n\\n    function updateYieldRate(uint timeInDays, uint yieldValue) external virtual onlyOwner returns(uint, uint) {\\n        require(timeInDays > 0, 'IBGV0: Invalid YieldIndex');\\n        require(yieldValue > 0, 'IBGV0: Invalid YieldValue');\\n        yieldRate[timeInDays] = yieldValue;\\n        return(timeInDays, yieldRate[timeInDays]);\\n    }\\n\\n    function updateBGBFToken(address _token) external virtual onlyOwner {\\n        require(_token != address(0), \\\"IBGV0: Invalid Token Address\\\");\\n        bgbf = IERC20(_token);\\n    }\\n\\n    function updatePlanStatus(uint plan, bool status) external virtual onlyOwner {\\n        require(planActiveStatus[plan] != status, \\\"IBGV0: Plan already has required status\\\");\\n        require(plan >= 1 && plan <= maxPlans, 'IBGV0: Invalid Plan');\\n        planActiveStatus[plan] = status;\\n    }\\n\\n    function updateTreasuryWallet(address _newWallet) external virtual onlyOwner {\\n        require(_newWallet != address(0), 'IBGV0: Invalid Address');\\n        require(_newWallet != treasuryWallet, \\\"IBGV0: Wallet is same as previous\\\");\\n        treasuryWallet = _newWallet;\\n    }\\n\\n    function updateDirectCommissionWallet(address _newWallet) external virtual onlyOwner {\\n        require(_newWallet != address(0), 'IBGV0: Invalid Address');\\n        require(_newWallet != directCommissionWallet, \\\"IBGV0: Wallet is same as previous\\\");\\n        directCommissionWallet = _newWallet;\\n    }\\n\\n    function updateYieldMatchingWallet(address _newWallet) external virtual onlyOwner {\\n        require(_newWallet != address(0), 'IBGV0: Invalid Address');\\n        require(_newWallet != yieldMatchingWallet, \\\"IBGV0: Wallet is same as previous\\\");\\n        yieldMatchingWallet = _newWallet;\\n    }\\n\\n    function updateYieldWallet(address _newWallet) external virtual onlyOwner {\\n        require(_newWallet != address(0), 'IBGV0: Invalid Address');\\n        require(_newWallet != yieldWallet, \\\"IBGV0: Wallet is same as previous\\\");\\n        yieldWallet = _newWallet;\\n    }\\n\\n    function walletBalance() external virtual onlyOwner {\\n        uint value = ibg.balanceOf(address(this));\\n\\n        require(value > 0, \\\"IBGV0: Invalid balance\\\");\\n        TransferHelper.safeTransfer(address(ibg), treasuryWallet, value);\\n    }\\n}\\n\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomeRecieved\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"DirectReferralIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reciever\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomeLost\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LostIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_pack\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentPackAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"PackPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"registrationTime\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakedBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingPeriod\",\"type\":\"uint256\"}],\"name\":\"StakedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yieldRecieved\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"YieldIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomeRecieved\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"YieldMatchingIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reciever\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"matchingLostIncome\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"YieldMatchingLostIncome\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"IBGPlanDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"IBGTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedIBGTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"IBGYieldIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"IBGYieldMatchingIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"IBGYieldMatchingLostIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnYield\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IBGToUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SERVICE_START_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calculateAccumulatedYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calculateStakedInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calculateYieldAndInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawableYield\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableInvestment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cycleDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investmentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yieldRateValue\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnstaked\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withdrawInvestment\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"directReferralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getInvestmentDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investmentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investmentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnstaked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"increaseIBGAfterLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"increaseRateIBG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ibg\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryWallet\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pack\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPeriod\",\"type\":\"uint256\"}],\"name\":\"investment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pack\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPeriod\",\"type\":\"uint256\"}],\"name\":\"investmentAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"packPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"planActiveStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plans\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pack\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPeriod\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pack\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPeriod\",\"type\":\"uint256\"}],\"name\":\"registerAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBase\",\"type\":\"uint256\"}],\"name\":\"setIBGIncreaseBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setIBGIncreaseRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"walks\",\"type\":\"uint256\"}],\"name\":\"setMaxWalks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"}],\"name\":\"setPackagePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setlastRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalIBGDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"updateBGBFToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"updateDirectCommissionWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateDirectReferralRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"updatePack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planNumber\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"planName\",\"type\":\"string\"}],\"name\":\"updatePlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"updatePlanStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeValue\",\"type\":\"uint256\"}],\"name\":\"updateStakingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"updateTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateYieldMatchingRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"updateYieldMatchingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeInDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yieldValue\",\"type\":\"uint256\"}],\"name\":\"updateYieldRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"updateYieldWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referralCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directReferrerIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lostIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPlan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investmentCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"onlyYield\",\"type\":\"bool\"}],\"name\":\"withdrawYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"stakingPeriod\",\"type\":\"uint8\"}],\"name\":\"yieldAndInvestment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"yieldMatchingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"yieldRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"IBGV0","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}