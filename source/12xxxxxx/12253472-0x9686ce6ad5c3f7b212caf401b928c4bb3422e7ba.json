{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.1.2 https://hardhat.org\r\n\r\n// File contracts/common/interfaces.sol\r\n\r\npragma solidity ^0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface TokenInterface {\r\n    function approve(address, uint256) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external;\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n    function balanceOf(address) external view returns (uint);\r\n    function decimals() external view returns (uint);\r\n}\r\n\r\ninterface MemoryInterface {\r\n    function getUint(uint id) external returns (uint num);\r\n    function setUint(uint id, uint val) external;\r\n}\r\n\r\ninterface AccountInterface {\r\n    function enable(address) external;\r\n    function disable(address) external;\r\n    function isAuth(address) external view returns (bool);\r\n    function cast(\r\n        string[] calldata _targets,\r\n        bytes[] calldata _datas,\r\n        address _origin\r\n    ) external payable returns (bytes32);\r\n}\r\n\r\ninterface AaveInterface {\r\n    function deposit(address _asset, uint256 _amount, address _onBehalfOf, uint16 _referralCode) external;\r\n    function withdraw(address _asset, uint256 _amount, address _to) external;\r\n    function borrow(\r\n        address _asset,\r\n        uint256 _amount,\r\n        uint256 _interestRateMode,\r\n        uint16 _referralCode,\r\n        address _onBehalfOf\r\n    ) external;\r\n    function repay(address _asset, uint256 _amount, uint256 _rateMode, address _onBehalfOf) external;\r\n    function setUserUseReserveAsCollateral(address _asset, bool _useAsCollateral) external;\r\n    function getUserAccountData(address user) external view returns (\r\n        uint256 totalCollateralETH,\r\n        uint256 totalDebtETH,\r\n        uint256 availableBorrowsETH,\r\n        uint256 currentLiquidationThreshold,\r\n        uint256 ltv,\r\n        uint256 healthFactor\r\n    );\r\n}\r\n\r\ninterface AaveLendingPoolProviderInterface {\r\n    function getLendingPool() external view returns (address);\r\n}\r\n\r\n// Aave Protocol Data Provider\r\ninterface AaveDataProviderInterface {\r\n    function getReserveTokensAddresses(address _asset) external view returns (\r\n        address aTokenAddress,\r\n        address stableDebtTokenAddress,\r\n        address variableDebtTokenAddress\r\n    );\r\n    function getUserReserveData(address _asset, address _user) external view returns (\r\n        uint256 currentATokenBalance,\r\n        uint256 currentStableDebt,\r\n        uint256 currentVariableDebt,\r\n        uint256 principalStableDebt,\r\n        uint256 scaledVariableDebt,\r\n        uint256 stableBorrowRate,\r\n        uint256 liquidityRate,\r\n        uint40 stableRateLastUpdated,\r\n        bool usageAsCollateralEnabled\r\n    );\r\n    function getReserveConfigurationData(address asset) external view returns (\r\n        uint256 decimals,\r\n        uint256 ltv,\r\n        uint256 liquidationThreshold,\r\n        uint256 liquidationBonus,\r\n        uint256 reserveFactor,\r\n        bool usageAsCollateralEnabled,\r\n        bool borrowingEnabled,\r\n        bool stableBorrowRateEnabled,\r\n        bool isActive,\r\n        bool isFrozen\r\n    );\r\n}\r\n\r\ninterface AaveAddressProviderRegistryInterface {\r\n    function getAddressesProvidersList() external view returns (address[] memory);\r\n}\r\n\r\ninterface ATokenInterface {\r\n    function scaledBalanceOf(address _user) external view returns (uint256);\r\n    function isTransferAllowed(address _user, uint256 _amount) external view returns (bool);\r\n    function balanceOf(address _user) external view returns(uint256);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function approve(address, uint256) external;\r\n}\r\n\r\ninterface AaveMigratorInterface {\r\n    function migrate(AaveDataRaw memory _data) external;\r\n    function migrateWithFlash(AaveDataRaw memory _data, uint ethAmt) external;\r\n}\r\n\r\nstruct AaveDataRaw {\r\n    address targetDsa;\r\n    uint[] supplyAmts;\r\n    uint[] variableBorrowAmts;\r\n    uint[] stableBorrowAmts;\r\n    address[] supplyTokens;\r\n    address[] borrowTokens;\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        z = SafeMath.add(x, y);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal virtual pure returns (uint z) {\r\n        z = SafeMath.sub(x, y);\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        z = SafeMath.mul(x, y);\r\n    }\r\n\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        z = SafeMath.div(x, y);\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = SafeMath.add(SafeMath.mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = SafeMath.add(SafeMath.mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = SafeMath.add(SafeMath.mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = SafeMath.add(SafeMath.mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y >= 0, \"int-overflow\");\r\n    }\r\n\r\n    function toRad(uint wad) internal pure returns (uint rad) {\r\n        rad = mul(wad, 10 ** 27);\r\n    }\r\n}\r\n\r\nabstract contract Stores {\r\n\r\n    /**\r\n    * @dev Return ethereum address\r\n    */\r\n    address constant internal ethAddr = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    /**\r\n    * @dev Return Wrapped ETH address\r\n    */\r\n    address constant internal wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    /**\r\n    * @dev Return memory variable address\r\n    */\r\n    MemoryInterface constant internal instaMemory = MemoryInterface(0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F);\r\n\r\n    /**\r\n    * @dev Get Uint value from InstaMemory Contract.\r\n    */\r\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\r\n        returnVal = getId == 0 ? val : instaMemory.getUint(getId);\r\n    }\r\n\r\n    /**\r\n    * @dev Set Uint value in InstaMemory Contract.\r\n    */\r\n    function setUint(uint setId, uint val) virtual internal {\r\n        if (setId != 0) instaMemory.setUint(setId, val);\r\n    }\r\n\r\n}\r\n\r\n\r\nabstract contract Helpers is DSMath, Stores {\r\n\r\n    /**\r\n     * @dev Insta Aave migrator contract\r\n    */\r\n    AaveMigratorInterface constant internal migrator = AaveMigratorInterface(address(0xA0557234eB7b3c503388202D3768Cfa2f1AE9Dc2));\r\n\r\n    /**\r\n     * @dev Aave Data Provider\r\n    */\r\n    AaveDataProviderInterface constant internal aaveData = AaveDataProviderInterface(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\r\n}\r\n\r\ncontract Events {\r\n    event LogAaveV2Migrate(\r\n        address indexed user,\r\n        address indexed targetDsa,\r\n        address[] supplyTokens,\r\n        address[] borrowTokens\r\n    );\r\n}\r\n\r\ncontract AaveMigrateResolver is Helpers, Events {\r\n\r\n    function migrate(\r\n        address targetDsa,\r\n        address[] memory supplyTokens,\r\n        address[] memory borrowTokens,\r\n        uint[] memory variableBorrowAmts,\r\n        uint[] memory stableBorrowAmts,\r\n        uint[] memory supplyAmts,\r\n        uint ethAmt // if ethAmt is > 0 then use migrateWithflash\r\n    ) external payable {\r\n        require(supplyTokens.length > 0, \"0-length-not-allowed\");\r\n        require(supplyTokens.length == supplyAmts.length, \"invalid-length\");\r\n        require(borrowTokens.length == variableBorrowAmts.length && borrowTokens.length  == stableBorrowAmts.length, \"invalid-length\");\r\n        require(targetDsa != address(0), \"invalid-address\");\r\n\r\n        AaveDataRaw memory data;\r\n\r\n        data.targetDsa = targetDsa;\r\n        data.supplyTokens = supplyTokens;\r\n        data.borrowTokens = borrowTokens;\r\n        data.variableBorrowAmts = variableBorrowAmts;\r\n        data.stableBorrowAmts = stableBorrowAmts;\r\n        data.supplyAmts = supplyAmts;\r\n\r\n        for (uint i = 0; i < data.supplyTokens.length; i++) {\r\n            address _token = data.supplyTokens[i] == ethAddr ? wethAddr : data.supplyTokens[i];\r\n            data.supplyTokens[i] = _token;\r\n            (address _aToken, ,) = aaveData.getReserveTokensAddresses(_token);\r\n            ATokenInterface _aTokenContract = ATokenInterface(_aToken);\r\n\r\n            if (data.supplyAmts[i] == uint(-1)) {\r\n                data.supplyAmts[i] = _aTokenContract.balanceOf(address(this));\r\n            }\r\n\r\n            _aTokenContract.approve(address(migrator), data.supplyAmts[i]);\r\n        }\r\n\r\n        if (ethAmt > 0) {\r\n            migrator.migrateWithFlash(data, ethAmt);\r\n        } else {\r\n            migrator.migrate(data);\r\n        }\r\n\r\n        emit LogAaveV2Migrate(msg.sender, data.targetDsa, data.supplyTokens, data.borrowTokens);\r\n    }\r\n\r\n}\r\n\r\ncontract ConnectAaveV2PolygonMigrator is AaveMigrateResolver {\r\n\r\n    /**\r\n     * @dev Connector Details\r\n    */\r\n    function connectorID() public pure returns(uint _type, uint _id) {\r\n        (_type, _id) = (1, 90);\r\n    }\r\n\r\n    string constant public name = \"Aave-V2-Polygon-Migrator-v1\";\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"targetDsa\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"supplyTokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"borrowTokens\",\"type\":\"address[]\"}],\"name\":\"LogAaveV2Migrate\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"connectorID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetDsa\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"supplyTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"borrowTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"variableBorrowAmts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stableBorrowAmts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"supplyAmts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"ethAmt\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConnectAaveV2PolygonMigrator","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4dea25f3f4db4f72a4634d33a4003238a4f55566a47f9724f1db479a7bafa2a2"}]}