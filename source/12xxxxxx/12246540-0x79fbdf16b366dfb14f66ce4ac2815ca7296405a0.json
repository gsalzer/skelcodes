{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n/// ClipperMom.sol -- governance interface for the Clipper\r\n\r\n// Copyright (C) 2021 Maker Ecosystem Growth Holdings, INC.\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.6.12;\r\n\r\ninterface ClipLike {\r\n    function file(bytes32, uint256) external;\r\n    function ilk() external view returns (bytes32);\r\n    function stopped() external view returns (uint256);\r\n}\r\n\r\ninterface AuthorityLike {\r\n    function canCall(address src, address dst, bytes4 sig) external view returns (bool);\r\n}\r\n\r\ninterface OsmLike {\r\n    function peek() external view returns (uint256, bool);\r\n    function peep() external view returns (uint256, bool);\r\n}\r\n\r\ninterface SpotterLike {\r\n    function ilks(bytes32) external view returns (OsmLike, uint256);\r\n}\r\n\r\ncontract ClipperMom {\r\n    address public owner;\r\n    address public authority;\r\n    mapping (address => uint256) public locked;    // timestamp when becomes unlocked (per clipper)\r\n    mapping (address => uint256) public tolerance; // clipper -> ray\r\n\r\n    SpotterLike public immutable spotter;\r\n\r\n    event SetOwner(address indexed oldOwner, address indexed newOwner);\r\n    event SetAuthority(address indexed oldAuthority, address indexed newAuthority);\r\n    event SetBreaker(address indexed clip, uint256 level);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"ClipperMom/only-owner\");\r\n        _;\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ClipperMom/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    constructor(address spotter_) public {\r\n        owner = msg.sender;\r\n        spotter = SpotterLike(spotter_);\r\n        emit SetOwner(address(0), msg.sender);\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, y) / RAY;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == address(0)) {\r\n            return false;\r\n        } else {\r\n            return AuthorityLike(authority).canCall(src, address(this), sig);\r\n        }\r\n    }\r\n\r\n    function getPrices(address clip) internal view returns (uint256 cur, uint256 nxt) {\r\n        (OsmLike osm, ) = spotter.ilks(ClipLike(clip).ilk());\r\n        bool has;\r\n        (cur, has) = osm.peek();\r\n        require(has, \"ClipperMom/invalid-cur-price\");\r\n        (nxt, has) = osm.peep();\r\n        require(has, \"ClipperMom/invalid-nxt-price\");\r\n    }\r\n\r\n    // Governance actions with delay\r\n    function setOwner(address owner_) external onlyOwner {\r\n        emit SetOwner(owner, owner_);\r\n        owner = owner_;\r\n    }\r\n\r\n    function setAuthority(address authority_) external onlyOwner {\r\n        emit SetAuthority(authority, authority_);\r\n        authority = authority_;\r\n    }\r\n\r\n    // Set the price tolerance for a specific ilk.\r\n    // The price tolerance is the minimum acceptable value a new price can have relative to the previous price\r\n    // For instance, a tolerance of 0.6 means that a new price can't be lower than 60% of the previous price\r\n    // 0.6 * RAY = 600000000000000000000000000 => means acceptable drop from previous price is up to 40%\r\n    function setPriceTolerance(address clip, uint256 value) external onlyOwner {\r\n        require(value <= 1 * RAY, \"ClipperMom/tolerance-out-of-bounds\");\r\n        tolerance[clip] = value;\r\n    }\r\n\r\n    // Governance action without delay\r\n    function setBreaker(address clip, uint256 level, uint256 delay) external auth {\r\n        require(level <= 3, \"ClipperMom/nonexistent-level\");\r\n        ClipLike(clip).file(\"stopped\", level);\r\n        // If governance changes the status of the breaker we want to lock for one hour\r\n        // the permissionless function so the osm can pull new nxt price to compare\r\n        locked[clip] = add(block.timestamp, delay);\r\n        emit SetBreaker(clip, level);\r\n    }\r\n\r\n    /**\r\n        The following implements a permissionless circuit breaker in case the price reported by an oracle\r\n        for a particular collateral type will drop below than a governance-defined % from 1 hour to the next.\r\n\r\n        The setPriceTolerance function sets that % (as a value between 0 and RAY) for a specific collateral type.\r\n        \r\n        tripBreaker takes the address of some ilk's Clipper.\r\n        It then gets the current and next price and checks whether the next price is less than the minimum\r\n        acceptable next price based on the tolerance. If the next price is unacceptable (lower than rmul(current_price, tolerance)),\r\n        it stops creation of new auctions and resets of current auctions for the Clipper's ilk. Currently, governance\r\n        must reset the breaker manually.\r\n    */\r\n    function tripBreaker(address clip) external {\r\n        require(ClipLike(clip).stopped() < 2, \"ClipperMom/clipper-already-stopped\");\r\n        require(block.timestamp > locked[clip], \"ClipperMom/temporary-locked\");\r\n      \r\n        (uint256 cur, uint256 nxt) = getPrices(clip);\r\n\r\n        // tolerance[clip] == 0 will always make the following require to revert\r\n        require(nxt < rmul(cur, tolerance[clip]), \"ClipperMom/price-within-bounds\");\r\n        ClipLike(clip).file(\"stopped\", 2);\r\n        emit SetBreaker(clip, 2);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spotter_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAuthority\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"SetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"clip\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"SetBreaker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clip\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setBreaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clip\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setPriceTolerance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spotter\",\"outputs\":[{\"internalType\":\"contract SpotterLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tolerance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clip\",\"type\":\"address\"}],\"name\":\"tripBreaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ClipperMom","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000065c79fcb50ca1594b025960e539ed7a9a6d434a3","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://167e5aaf890843712f735082632b27ed62221454f66affaa6e94d5ed81df2227"}]}