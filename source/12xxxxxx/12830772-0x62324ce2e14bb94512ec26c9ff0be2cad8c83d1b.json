{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport '@openzeppelin/contracts/utils/Context.sol';\\n\\nimport './libraries/WadRayMath.sol';\\nimport './libraries/Math.sol';\\n\\nimport './interfaces/IDToken.sol';\\nimport './interfaces/IMoneyPool.sol';\\n\\n/**\\n * @title DToken\\n * @notice The DToken balance of borrower is the amount of money that the borrower\\n * would be required to repay and seize the collateralized asset bond token.\\n *\\n * @author Aave\\n **/\\ncontract DToken is IDToken, Context {\\n  using WadRayMath for uint256;\\n\\n  uint256 internal _totalAverageRealAssetBorrowRate;\\n  mapping(address => uint256) internal _userLastUpdateTimestamp;\\n  mapping(address => uint256) internal _userAverageRealAssetBorrowRate;\\n  uint256 internal _lastUpdateTimestamp;\\n\\n  uint256 internal _totalSupply;\\n  mapping(address => uint256) internal _balances;\\n\\n  string private _name;\\n  string private _symbol;\\n\\n  IMoneyPool internal _moneyPool;\\n  address internal _underlyingAsset;\\n\\n  constructor(\\n    IMoneyPool moneyPool,\\n    address underlyingAsset_,\\n    string memory name_,\\n    string memory symbol_\\n  ) {\\n    _moneyPool = moneyPool;\\n    _underlyingAsset = underlyingAsset_;\\n\\n    _name = name_;\\n    _symbol = symbol_;\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the decimals of the token.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return 18;\\n  }\\n\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    recipient;\\n    amount;\\n    require(false, 'DTokenTransferNotAllowed');\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    sender;\\n    recipient;\\n    amount;\\n    require(false, 'DTokenTransferFromNotAllowed');\\n    return true;\\n  }\\n\\n  function allowance(address owner, address spender)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    owner;\\n    spender;\\n    require(false, 'DTokenAllowanceNotAllowed');\\n    return 0;\\n  }\\n\\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n    spender;\\n    amount;\\n    require(false, 'DTokenApproveNotAllowed');\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the average stable rate across all the stable rate debt\\n   * @return the average stable rate\\n   **/\\n  function getTotalAverageRealAssetBorrowRate() external view virtual override returns (uint256) {\\n    return _totalAverageRealAssetBorrowRate;\\n  }\\n\\n  /**\\n   * @dev Returns the timestamp of the last account action\\n   * @return The last update timestamp\\n   **/\\n  function getUserLastUpdateTimestamp(address account)\\n    external\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    return _userLastUpdateTimestamp[account];\\n  }\\n\\n  /**\\n   * @dev Returns the stable rate of the account\\n   * @param account The address of the account\\n   * @return The stable rate of account\\n   **/\\n  function getUserAverageRealAssetBorrowRate(address account)\\n    external\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    return _userAverageRealAssetBorrowRate[account];\\n  }\\n\\n  /**\\n   * @dev Calculates the current account debt balance\\n   * @return The accumulated debt of the account\\n   **/\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n    uint256 accountBalance = _balances[account];\\n    uint256 stableRate = _userAverageRealAssetBorrowRate[account];\\n\\n    // strict equality is not dangerous here\\n    // divide-before-multiply dangerous-strict-equalities\\n    if (accountBalance == 0) {\\n      return 0;\\n    }\\n    uint256 cumulatedInterest = Math.calculateCompoundedInterest(\\n      stableRate,\\n      _userLastUpdateTimestamp[account],\\n      block.timestamp\\n    );\\n    return accountBalance.rayMul(cumulatedInterest);\\n  }\\n\\n  struct MintLocalVars {\\n    uint256 previousSupply;\\n    uint256 nextSupply;\\n    uint256 amountInRay;\\n    uint256 newStableRate;\\n    uint256 currentAvgStableRate;\\n  }\\n\\n  /**\\n   * @dev Mints debt token to the `receiver` address.\\n   * -  Only callable by the LendingPool\\n   * - The resulting rate is the weighted average between the rate of the new debt\\n   * and the rate of the principal debt\\n   * @param account The address receiving the borrowed underlying, being the delegatee in case\\n   * of credit delegate, or same as `receiver` otherwise\\n   * @param receiver The address receiving the debt tokens\\n   * @param amount The amount of debt tokens to mint\\n   * @param rate The rate of the debt being minted\\n   **/\\n  function mint(\\n    address account,\\n    address receiver,\\n    uint256 amount,\\n    uint256 rate\\n  ) external override onlyMoneyPool {\\n    MintLocalVars memory vars;\\n\\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(receiver);\\n\\n    vars.previousSupply = totalSupply();\\n    vars.currentAvgStableRate = _totalAverageRealAssetBorrowRate;\\n    vars.nextSupply = _totalSupply = vars.previousSupply + amount;\\n\\n    vars.amountInRay = amount.wadToRay();\\n\\n    (, vars.newStableRate) = Math.calculateRateInIncreasingBalance(\\n      _userAverageRealAssetBorrowRate[receiver],\\n      currentBalance,\\n      amount,\\n      rate\\n    );\\n\\n    _userAverageRealAssetBorrowRate[receiver] = vars.newStableRate;\\n\\n    //solium-disable-next-line\\n    _lastUpdateTimestamp = _userLastUpdateTimestamp[receiver] = block.timestamp;\\n\\n    // Calculates the updated average stable rate\\n    (, vars.currentAvgStableRate) = Math.calculateRateInIncreasingBalance(\\n      vars.currentAvgStableRate,\\n      vars.previousSupply,\\n      amount,\\n      rate\\n    );\\n\\n    _totalAverageRealAssetBorrowRate = vars.currentAvgStableRate;\\n\\n    _mint(receiver, amount + balanceIncrease);\\n\\n    emit Transfer(address(0), receiver, amount);\\n\\n    emit Mint(\\n      account,\\n      receiver,\\n      amount + balanceIncrease,\\n      currentBalance,\\n      balanceIncrease,\\n      vars.newStableRate,\\n      vars.currentAvgStableRate,\\n      vars.nextSupply\\n    );\\n  }\\n\\n  /**\\n   * @dev Burns debt of `account`\\n   * @param account The address of the account getting his debt burned\\n   * @param amount The amount of debt tokens getting burned\\n   **/\\n  function burn(address account, uint256 amount) external override onlyMoneyPool {\\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(account);\\n\\n    uint256 previousSupply = totalSupply();\\n    uint256 newAvgStableRate = 0;\\n    uint256 nextSupply = 0;\\n    uint256 userStableRate = _userAverageRealAssetBorrowRate[account];\\n\\n    // Since the total supply and each single account debt accrue separately,\\n    // there might be accumulation errors so that the last borrower repaying\\n    // mght actually try to repay more than the available debt supply.\\n    // In this case we simply set the total supply and the avg stable rate to 0\\n    if (previousSupply <= amount) {\\n      _totalAverageRealAssetBorrowRate = 0;\\n      _totalSupply = 0;\\n    } else {\\n      nextSupply = _totalSupply = previousSupply - amount;\\n      uint256 firstTerm = _totalAverageRealAssetBorrowRate.rayMul(previousSupply.wadToRay());\\n      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());\\n\\n      // For the same reason described above, when the last account is repaying it might\\n      // happen that account rate * account balance > avg rate * total supply. In that case,\\n      // we simply set the avg rate to 0\\n      if (secondTerm >= firstTerm) {\\n        newAvgStableRate = _totalAverageRealAssetBorrowRate = _totalSupply = 0;\\n      } else {\\n        newAvgStableRate = _totalAverageRealAssetBorrowRate = (firstTerm - secondTerm).rayDiv(\\n          nextSupply.wadToRay()\\n        );\\n      }\\n    }\\n\\n    if (amount == currentBalance) {\\n      _userAverageRealAssetBorrowRate[account] = 0;\\n      _userLastUpdateTimestamp[account] = 0;\\n    } else {\\n      //solium-disable-next-line\\n      _userLastUpdateTimestamp[account] = block.timestamp;\\n    }\\n    //solium-disable-next-line\\n    _lastUpdateTimestamp = block.timestamp;\\n\\n    if (balanceIncrease > amount) {\\n      uint256 amountToMint = balanceIncrease - amount;\\n      _mint(account, amountToMint);\\n      emit Mint(\\n        account,\\n        account,\\n        amountToMint,\\n        currentBalance,\\n        balanceIncrease,\\n        userStableRate,\\n        newAvgStableRate,\\n        nextSupply\\n      );\\n    } else {\\n      uint256 amountToBurn = amount - balanceIncrease;\\n      _burn(account, amountToBurn);\\n      emit Burn(\\n        account,\\n        amountToBurn,\\n        currentBalance,\\n        balanceIncrease,\\n        newAvgStableRate,\\n        nextSupply\\n      );\\n    }\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Calculates the increase in balance since the last account interaction\\n   * @param account The address of the account for which the interest is being accumulated\\n   * @return The principal principal balance, the new principal balance and the balance increase\\n   **/\\n  function _calculateBalanceIncrease(address account)\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    uint256 previousprincipalBalance = _balances[account];\\n\\n    // strict equality is not dangerous here\\n    // divide-before-multiply dangerous-strict-equalities\\n    if (previousprincipalBalance == 0) {\\n      return (0, 0, 0);\\n    }\\n\\n    // Calculation of the accrued interest since the last accumulation\\n    uint256 balanceIncrease = balanceOf(account) - previousprincipalBalance;\\n\\n    return (previousprincipalBalance, previousprincipalBalance + balanceIncrease, balanceIncrease);\\n  }\\n\\n  /**\\n   * @dev Returns the principal and total supply, the average borrow rate and the last supply update timestamp\\n   **/\\n  function getDTokenData()\\n    public\\n    view\\n    override\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    uint256 avgRate = _totalAverageRealAssetBorrowRate;\\n    return (_totalSupply, _calcTotalSupply(avgRate), avgRate, _lastUpdateTimestamp);\\n  }\\n\\n  /**\\n   * @dev Returns the the total supply and the average stable rate\\n   **/\\n  function getTotalSupplyAndAvgRate() public view override returns (uint256, uint256) {\\n    uint256 avgRate = _totalAverageRealAssetBorrowRate;\\n    return (_calcTotalSupply(avgRate), avgRate);\\n  }\\n\\n  /**\\n   * @dev Returns the total supply\\n   **/\\n  function totalSupply() public view override returns (uint256) {\\n    return _calcTotalSupply(_totalAverageRealAssetBorrowRate);\\n  }\\n\\n  /**\\n   * @dev Returns the timestamp at which the total supply was updated\\n   **/\\n  function getTotalSupplyLastUpdated() public view override returns (uint256) {\\n    return _lastUpdateTimestamp;\\n  }\\n\\n  /**\\n   * @dev Returns the principal debt balance of the account from\\n   * @param account The account's address\\n   * @return The debt balance of the account since the last burn/mint action\\n   **/\\n  function principalBalanceOf(address account) external view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev Returns the address of the lending pool where this aToken is used\\n   **/\\n  function POOL() public view returns (IMoneyPool) {\\n    return _moneyPool;\\n  }\\n\\n  /**\\n   * @dev For internal usage in the logic of the parent contracts\\n   **/\\n  function _getMoneyPool() internal view returns (IMoneyPool) {\\n    return _moneyPool;\\n  }\\n\\n  /**\\n   * @dev Calculates the total supply\\n   * @param avgRate The average rate at which the total supply increases\\n   * @return The debt balance of the account since the last burn/mint action\\n   **/\\n  function _calcTotalSupply(uint256 avgRate) internal view virtual returns (uint256) {\\n    uint256 principalSupply = _totalSupply;\\n\\n    // strict equality is not dangerous here\\n    // divide-before-multiply dangerous-strict-equalities\\n    if (principalSupply == 0) {\\n      return 0;\\n    }\\n\\n    uint256 cumulatedInterest = Math.calculateCompoundedInterest(\\n      avgRate,\\n      _lastUpdateTimestamp,\\n      block.timestamp\\n    );\\n\\n    return principalSupply.rayMul(cumulatedInterest);\\n  }\\n\\n  /**\\n   * @dev Mints stable debt tokens to an account\\n   * @param account The account receiving the debt tokens\\n   * @param amount The amount being minted\\n   **/\\n  function _mint(address account, uint256 amount) internal {\\n    uint256 oldAccountBalance = _balances[account];\\n    _balances[account] = oldAccountBalance + amount;\\n  }\\n\\n  /**\\n   * @dev Burns stable debt tokens of an account\\n   * @param account The account getting his debt burned\\n   * @param amount The amount being burned\\n   **/\\n  function _burn(address account, uint256 amount) internal {\\n    uint256 oldAccountBalance = _balances[account];\\n    _balances[account] = oldAccountBalance - amount;\\n  }\\n\\n  modifier onlyMoneyPool {\\n    require(_msgSender() == address(_moneyPool), 'OnlyMoneyPool');\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\n\\ninterface IDToken is IERC20Metadata {\\n  /**\\n   * @dev Emitted when new stable debt is minted\\n   * @param account The address of the account who triggered the minting\\n   * @param receiver The recipient of stable debt tokens\\n   * @param amount The amount minted\\n   * @param currentBalance The current balance of the account\\n   * @param balanceIncrease The increase in balance since the last action of the account\\n   * @param newRate The rate of the debt after the minting\\n   * @param avgStableRate The new average stable rate after the minting\\n   * @param newTotalSupply The new total supply of the stable debt token after the action\\n   **/\\n  event Mint(\\n    address indexed account,\\n    address indexed receiver,\\n    uint256 amount,\\n    uint256 currentBalance,\\n    uint256 balanceIncrease,\\n    uint256 newRate,\\n    uint256 avgStableRate,\\n    uint256 newTotalSupply\\n  );\\n\\n  /**\\n   * @dev Emitted when new stable debt is burned\\n   * @param account The address of the account\\n   * @param amount The amount being burned\\n   * @param currentBalance The current balance of the account\\n   * @param balanceIncrease The the increase in balance since the last action of the account\\n   * @param avgStableRate The new average stable rate after the burning\\n   * @param newTotalSupply The new total supply of the stable debt token after the action\\n   **/\\n  event Burn(\\n    address indexed account,\\n    uint256 amount,\\n    uint256 currentBalance,\\n    uint256 balanceIncrease,\\n    uint256 avgStableRate,\\n    uint256 newTotalSupply\\n  );\\n\\n  /**\\n   * @dev Mints debt token to the `receiver` address.\\n   * - The resulting rate is the weighted average between the rate of the new debt\\n   * and the rate of the previous debt\\n   * @param account The address receiving the borrowed underlying, being the delegatee in case\\n   * of credit delegate, or same as `receiver` otherwise\\n   * @param receiver The address receiving the debt tokens\\n   * @param amount The amount of debt tokens to mint\\n   * @param rate The rate of the debt being minted\\n   **/\\n  function mint(\\n    address account,\\n    address receiver,\\n    uint256 amount,\\n    uint256 rate\\n  ) external;\\n\\n  /**\\n   * @dev Burns debt of `account`\\n   * - The resulting rate is the weighted average between the rate of the new debt\\n   * and the rate of the previous debt\\n   * @param account The address of the account getting his debt burned\\n   * @param amount The amount of debt tokens getting burned\\n   **/\\n  function burn(address account, uint256 amount) external;\\n\\n  /**\\n   * @dev Returns the average rate of all the stable rate loans.\\n   * @return The average stable rate\\n   **/\\n  function getTotalAverageRealAssetBorrowRate() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the stable rate of the account debt\\n   * @return The stable rate of the account\\n   **/\\n  function getUserAverageRealAssetBorrowRate(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the timestamp of the last update of the account\\n   * @return The timestamp\\n   **/\\n  function getUserLastUpdateTimestamp(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the principal, the total supply and the average stable rate\\n   **/\\n  function getDTokenData()\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  /**\\n   * @dev Returns the timestamp of the last update of the total supply\\n   * @return The timestamp\\n   **/\\n  function getTotalSupplyLastUpdated() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the total supply and the average stable rate\\n   **/\\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\\n\\n  /**\\n   * @dev Returns the principal debt balance of the account\\n   * @return The debt balance of the account since the last burn/mint action\\n   **/\\n  function principalBalanceOf(address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMoneyPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport '../libraries/DataStruct.sol';\\n\\ninterface IMoneyPool {\\n  event NewReserve(\\n    address indexed asset,\\n    address lToken,\\n    address dToken,\\n    address interestModel,\\n    address tokenizer,\\n    address incentivePool,\\n    uint256 moneyPoolFactor\\n  );\\n\\n  event Deposit(address indexed asset, address indexed account, uint256 amount);\\n\\n  event Withdraw(\\n    address indexed asset,\\n    address indexed account,\\n    address indexed to,\\n    uint256 amount\\n  );\\n\\n  event Borrow(\\n    address indexed asset,\\n    address indexed collateralServiceProvider,\\n    address indexed borrower,\\n    uint256 tokenId,\\n    uint256 borrowAPY,\\n    uint256 borrowAmount\\n  );\\n\\n  event Repay(\\n    address indexed asset,\\n    address indexed borrower,\\n    uint256 tokenId,\\n    uint256 userDTokenBalance,\\n    uint256 feeOnCollateralServiceProvider\\n  );\\n\\n  event Liquidation(\\n    address indexed asset,\\n    address indexed borrower,\\n    uint256 tokenId,\\n    uint256 userDTokenBalance,\\n    uint256 feeOnCollateralServiceProvider\\n  );\\n\\n  function deposit(\\n    address asset,\\n    address account,\\n    uint256 amount\\n  ) external;\\n\\n  function withdraw(\\n    address asset,\\n    address account,\\n    uint256 amount\\n  ) external;\\n\\n  function borrow(address asset, uint256 tokenID) external;\\n\\n  function repay(address asset, uint256 tokenId) external;\\n\\n  function liquidate(address asset, uint256 tokenId) external;\\n\\n  function getLTokenInterestIndex(address asset) external view returns (uint256);\\n\\n  function getReserveData(address asset) external view returns (DataStruct.ReserveData memory);\\n\\n  function addNewReserve(\\n    address asset,\\n    address lToken,\\n    address dToken,\\n    address interestModel,\\n    address tokenizer,\\n    address incentivePool,\\n    uint256 moneyPoolFactor_\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DataStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nlibrary DataStruct {\\n  /**\\n    @notice The main reserve data struct.\\n   */\\n  struct ReserveData {\\n    uint256 moneyPoolFactor;\\n    uint256 lTokenInterestIndex;\\n    uint256 borrowAPY;\\n    uint256 depositAPY;\\n    uint256 lastUpdateTimestamp;\\n    address lTokenAddress;\\n    address dTokenAddress;\\n    address interestModelAddress;\\n    address tokenizerAddress;\\n    uint8 id;\\n    bool isPaused;\\n    bool isActivated;\\n  }\\n\\n  /**\\n   * @notice The asset bond data struct.\\n   * @param ipfsHash The IPFS hash that contains the informations and contracts\\n   * between Collateral Service Provider and lender.\\n   * @param maturityTimestamp The amount of time measured in seconds that can elapse\\n   * before the NPL company liquidate the loan and seize the asset bond collateral.\\n   * @param borrower The address of the borrower.\\n   */\\n  struct AssetBondData {\\n    AssetBondState state;\\n    address borrower;\\n    address signer;\\n    address collateralServiceProvider;\\n    uint256 principal;\\n    uint256 debtCeiling;\\n    uint256 couponRate;\\n    uint256 interestRate;\\n    uint256 delinquencyRate;\\n    uint256 loanStartTimestamp;\\n    uint256 collateralizeTimestamp;\\n    uint256 maturityTimestamp;\\n    uint256 liquidationTimestamp;\\n    string ipfsHash; // refactor : gas\\n    string signerOpinionHash;\\n  }\\n\\n  struct AssetBondIdData {\\n    uint256 nonce;\\n    uint256 countryCode;\\n    uint256 collateralServiceProviderIdentificationNumber;\\n    uint256 collateralLatitude;\\n    uint256 collateralLatitudeSign;\\n    uint256 collateralLongitude;\\n    uint256 collateralLongitudeSign;\\n    uint256 collateralDetail;\\n    uint256 collateralCategory;\\n    uint256 productNumber;\\n  }\\n\\n  /**\\n    @notice The states of asset bond\\n    * EMPTY: After\\n    * SETTLED:\\n    * CONFIRMED:\\n    * COLLATERALIZED:\\n    * DELINQUENT:\\n    * REDEEMED:\\n    * LIQUIDATED:\\n   */\\n  enum AssetBondState {\\n    EMPTY,\\n    SETTLED,\\n    CONFIRMED,\\n    COLLATERALIZED,\\n    DELINQUENT,\\n    REDEEMED,\\n    LIQUIDATED\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport './WadRayMath.sol';\\n\\nlibrary Math {\\n  using WadRayMath for uint256;\\n\\n  uint256 internal constant SECONDSPERYEAR = 365 days;\\n\\n  function calculateLinearInterest(\\n    uint256 rate,\\n    uint256 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    uint256 timeDelta = currentTimestamp - uint256(lastUpdateTimestamp);\\n\\n    return ((rate * timeDelta) / SECONDSPERYEAR) + WadRayMath.ray();\\n  }\\n\\n  /**\\n   * @notice Author : AAVE\\n   * @dev Function to calculate the interest using a compounded interest rate formula\\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n   *\\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\\n   *\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate compounded during the timeDelta, in ray\\n   **/\\n  function calculateCompoundedInterest(\\n    uint256 rate,\\n    uint256 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    //solium-disable-next-line\\n    uint256 exp = currentTimestamp - lastUpdateTimestamp;\\n\\n    if (exp == 0) {\\n      return WadRayMath.ray();\\n    }\\n\\n    uint256 expMinusOne = exp - 1;\\n\\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n    // loss of precision is endurable\\n    // slither-disable-next-line divide-before-multiply\\n    uint256 ratePerSecond = rate / SECONDSPERYEAR;\\n\\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\n\\n    uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\\n    uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\\n\\n    return WadRayMath.ray() + (ratePerSecond * exp) + secondTerm + thirdTerm;\\n  }\\n\\n  function calculateRateInIncreasingBalance(\\n    uint256 averageRate,\\n    uint256 totalBalance,\\n    uint256 amountIn,\\n    uint256 rate\\n  ) internal pure returns (uint256, uint256) {\\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\\n    uint256 weightedAmountRate = amountIn.wadToRay().rayMul(rate);\\n\\n    uint256 newTotalBalance = totalBalance + amountIn;\\n    uint256 newAverageRate = (weightedAverageRate + weightedAmountRate).rayDiv(\\n      newTotalBalance.wadToRay()\\n    );\\n\\n    return (newTotalBalance, newAverageRate);\\n  }\\n\\n  function calculateRateInDecreasingBalance(\\n    uint256 averageRate,\\n    uint256 totalBalance,\\n    uint256 amountOut,\\n    uint256 rate\\n  ) internal pure returns (uint256, uint256) {\\n    // if decreasing amount exceeds totalBalance,\\n    // overall rate and balacne would be set 0\\n    if (totalBalance <= amountOut) {\\n      return (0, 0);\\n    }\\n\\n    uint256 weightedAverageRate = totalBalance.wadToRay().rayMul(averageRate);\\n    uint256 weightedAmountRate = amountOut.wadToRay().rayMul(rate);\\n\\n    if (weightedAverageRate <= weightedAmountRate) {\\n      return (0, 0);\\n    }\\n\\n    uint256 newTotalBalance = totalBalance - amountOut;\\n\\n    uint256 newAverageRate = (weightedAverageRate - weightedAmountRate).rayDiv(\\n      newTotalBalance.wadToRay()\\n    );\\n\\n    return (newTotalBalance, newAverageRate);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant halfWAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return halfRAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return halfWAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfWAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfRAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n    return result;\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IMoneyPool\",\"name\":\"moneyPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingAsset_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"avgStableRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalSupply\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"avgStableRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalSupply\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"POOL\",\"outputs\":[{\"internalType\":\"contract IMoneyPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDTokenData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalAverageRealAssetBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSupplyAndAvgRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSupplyLastUpdated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserAverageRealAssetBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserLastUpdateTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"principalBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DToken","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"000000000000000000000000a93008fd32eb24e488ddaa6c0aa152559fda9e8c0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001a456c7966695f446169537461626c65636f696e5f44546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000f454c46495f4441495f44546f6b656e0000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}