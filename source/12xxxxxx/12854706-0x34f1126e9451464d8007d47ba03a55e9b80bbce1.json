{"status":"1","message":"OK","result":[{"SourceCode":"// File: @chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface LinkTokenInterface {\r\n\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 remaining\r\n    );\r\n\r\n  function approve(\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n  function balanceOf(\r\n    address owner\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 balance\r\n    );\r\n\r\n  function decimals()\r\n    external\r\n    view\r\n    returns (\r\n      uint8 decimalPlaces\r\n    );\r\n\r\n  function decreaseApproval(\r\n    address spender,\r\n    uint256 addedValue\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n  function increaseApproval(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  ) external;\r\n\r\n  function name()\r\n    external\r\n    view\r\n    returns (\r\n      string memory tokenName\r\n    );\r\n\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (\r\n      string memory tokenSymbol\r\n    );\r\n\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (\r\n      uint256 totalTokensIssued\r\n    );\r\n\r\n  function transfer(\r\n    address to,\r\n    uint256 value\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n  function transferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/dev/VRFRequestIDBase.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract VRFRequestIDBase {\r\n\r\n  /**\r\n   * @notice returns the seed which is actually input to the VRF coordinator\r\n   *\r\n   * @dev To prevent repetition of VRF output due to repetition of the\r\n   * @dev user-supplied seed, that seed is combined in a hash with the\r\n   * @dev user-specific nonce, and the address of the consuming contract. The\r\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\r\n   * @dev the final seed, but the nonce does protect against repetition in\r\n   * @dev requests which are included in a single block.\r\n   *\r\n   * @param _userSeed VRF seed input provided by user\r\n   * @param _requester Address of the requesting contract\r\n   * @param _nonce User-specific nonce at the time of the request\r\n   */\r\n  function makeVRFInputSeed(\r\n    bytes32 _keyHash,\r\n    uint256 _userSeed,\r\n    address _requester,\r\n    uint256 _nonce\r\n  )\r\n    internal\r\n    pure\r\n    returns (\r\n      uint256\r\n    )\r\n  {\r\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the id for this request\r\n   * @param _keyHash The serviceAgreement ID to be used for this request\r\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\r\n   * @return The id for this request\r\n   *\r\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\r\n   * @dev contract, but the one generated by makeVRFInputSeed\r\n   */\r\n  function makeRequestId(\r\n    bytes32 _keyHash,\r\n    uint256 _vRFInputSeed\r\n  )\r\n    internal\r\n    pure\r\n    returns (\r\n      bytes32\r\n    )\r\n  {\r\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/dev/VRFConsumerBase.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/** ****************************************************************************\r\n * @notice Interface for contracts using VRF randomness\r\n * *****************************************************************************\r\n * @dev PURPOSE\r\n *\r\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\r\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\r\n * @dev making his output up to suit himself. Reggie provides Vera a public key\r\n * @dev to which he knows the secret key. Each time Vera provides a seed to\r\n * @dev Reggie, he gives back a value which is computed completely\r\n * @dev deterministically from the seed and the secret key.\r\n *\r\n * @dev Reggie provides a proof by which Vera can verify that the output was\r\n * @dev correctly computed once Reggie tells it to her, but without that proof,\r\n * @dev the output is indistinguishable to her from a uniform random sample\r\n * @dev from the output space.\r\n *\r\n * @dev The purpose of this contract is to make it easy for unrelated contracts\r\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\r\n * @dev simple access to a verifiable source of randomness.\r\n * *****************************************************************************\r\n * @dev USAGE\r\n *\r\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\r\n * @dev initialize VRFConsumerBase's attributes in their constructor as\r\n * @dev shown:\r\n *\r\n * @dev   contract VRFConsumer {\r\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\r\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\r\n * @dev         <initialization with other arguments goes here>\r\n * @dev       }\r\n * @dev   }\r\n *\r\n * @dev The oracle will have given you an ID for the VRF keypair they have\r\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\r\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\r\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\r\n * @dev want to generate randomness from.\r\n *\r\n * @dev Once the VRFCoordinator has received and validated the oracle's response\r\n * @dev to your request, it will call your contract's fulfillRandomness method.\r\n *\r\n * @dev The randomness argument to fulfillRandomness is the actual random value\r\n * @dev generated from your seed.\r\n *\r\n * @dev The requestId argument is generated from the keyHash and the seed by\r\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\r\n * @dev requests open, you can use the requestId to track which seed is\r\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\r\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\r\n * @dev if your contract could have multiple requests in flight simultaneously.)\r\n *\r\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\r\n * @dev differ. (Which is critical to making unpredictable randomness! See the\r\n * @dev next section.)\r\n *\r\n * *****************************************************************************\r\n * @dev SECURITY CONSIDERATIONS\r\n *\r\n * @dev A method with the ability to call your fulfillRandomness method directly\r\n * @dev could spoof a VRF response with any random value, so it's critical that\r\n * @dev it cannot be directly called by anything other than this base contract\r\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\r\n *\r\n * @dev For your users to trust that your contract's random behavior is free\r\n * @dev from malicious interference, it's best if you can write it so that all\r\n * @dev behaviors implied by a VRF response are executed *during* your\r\n * @dev fulfillRandomness method. If your contract must store the response (or\r\n * @dev anything derived from it) and use it later, you must ensure that any\r\n * @dev user-significant behavior which depends on that stored value cannot be\r\n * @dev manipulated by a subsequent VRF request.\r\n *\r\n * @dev Similarly, both miners and the VRF oracle itself have some influence\r\n * @dev over the order in which VRF responses appear on the blockchain, so if\r\n * @dev your contract could have multiple VRF requests in flight simultaneously,\r\n * @dev you must ensure that the order in which the VRF responses arrive cannot\r\n * @dev be used to manipulate your contract's user-significant behavior.\r\n *\r\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\r\n * @dev block in which the request is made, user-provided seeds have no impact\r\n * @dev on its economic security properties. They are only included for API\r\n * @dev compatability with previous versions of this contract.\r\n *\r\n * @dev Since the block hash of the block which contains the requestRandomness\r\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\r\n * @dev miner could, in principle, fork the blockchain to evict the block\r\n * @dev containing the request, forcing the request to be included in a\r\n * @dev different block with a different hash, and therefore a different input\r\n * @dev to the VRF. However, such an attack would incur a substantial economic\r\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\r\n * @dev until it calls responds to a request.\r\n */\r\nabstract contract VRFConsumerBase is VRFRequestIDBase {\r\n\r\n  /**\r\n   * @notice fulfillRandomness handles the VRF response. Your contract must\r\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\r\n   * @notice principles to keep in mind when implementing your fulfillRandomness\r\n   * @notice method.\r\n   *\r\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\r\n   * @dev signature, and will call it once it has verified the proof\r\n   * @dev associated with the randomness. (It is triggered via a call to\r\n   * @dev rawFulfillRandomness, below.)\r\n   *\r\n   * @param requestId The Id initially returned by requestRandomness\r\n   * @param randomness the VRF output\r\n   */\r\n  function fulfillRandomness(\r\n    bytes32 requestId,\r\n    uint256 randomness\r\n  )\r\n    internal\r\n    virtual;\r\n\r\n  /**\r\n   * @dev In order to keep backwards compatibility we have kept the user\r\n   * seed field around. We remove the use of it because given that the blockhash\r\n   * enters later, it overrides whatever randomness the used seed provides.\r\n   * Given that it adds no security, and can easily lead to misunderstandings,\r\n   * we have removed it from usage and can now provide a simpler API.\r\n   */\r\n  uint256 constant private USER_SEED_PLACEHOLDER = 0;\r\n\r\n  /**\r\n   * @notice requestRandomness initiates a request for VRF output given _seed\r\n   *\r\n   * @dev The fulfillRandomness method receives the output, once it's provided\r\n   * @dev by the Oracle, and verified by the vrfCoordinator.\r\n   *\r\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\r\n   * @dev the _fee must exceed the fee specified during registration of the\r\n   * @dev _keyHash.\r\n   *\r\n   * @dev The _seed parameter is vestigial, and is kept only for API\r\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\r\n   * @dev your own randomness, here, but it's not necessary because the VRF\r\n   * @dev oracle will mix the hash of the block containing your request into the\r\n   * @dev VRF seed it ultimately uses.\r\n   *\r\n   * @param _keyHash ID of public key against which randomness is generated\r\n   * @param _fee The amount of LINK to send with the request\r\n   *\r\n   * @return requestId unique ID for this request\r\n   *\r\n   * @dev The returned requestId can be used to distinguish responses to\r\n   * @dev concurrent requests. It is passed as the first argument to\r\n   * @dev fulfillRandomness.\r\n   */\r\n  function requestRandomness(\r\n    bytes32 _keyHash,\r\n    uint256 _fee\r\n  )\r\n    internal\r\n    returns (\r\n      bytes32 requestId\r\n    )\r\n  {\r\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\r\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\r\n    // the hash of the block containing this request to obtain the seed/input\r\n    // which is finally passed to the VRF cryptographic machinery.\r\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\r\n    // nonces[_keyHash] must stay in sync with\r\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\r\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\r\n    // This provides protection against the user repeating their input seed,\r\n    // which would result in a predictable/duplicate output, if multiple such\r\n    // requests appeared in the same block.\r\n    nonces[_keyHash] = nonces[_keyHash] + 1;\r\n    return makeRequestId(_keyHash, vRFSeed);\r\n  }\r\n\r\n  LinkTokenInterface immutable internal LINK;\r\n  address immutable private vrfCoordinator;\r\n\r\n  // Nonces for each VRF key from which randomness has been requested.\r\n  //\r\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\r\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\r\n\r\n  /**\r\n   * @param _vrfCoordinator address of VRFCoordinator contract\r\n   * @param _link address of LINK token contract\r\n   *\r\n   * @dev https://docs.chain.link/docs/link-token-contracts\r\n   */\r\n  constructor(\r\n    address _vrfCoordinator,\r\n    address _link\r\n  ) {\r\n    vrfCoordinator = _vrfCoordinator;\r\n    LINK = LinkTokenInterface(_link);\r\n  }\r\n\r\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\r\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\r\n  // the origin of the call\r\n  function rawFulfillRandomness(\r\n    bytes32 requestId,\r\n    uint256 randomness\r\n  )\r\n    external\r\n  {\r\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\r\n    fulfillRandomness(requestId, randomness);\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n// File: contracts/OwnershipAgreementv3.sol\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n\r\n/// @title Creates an Ownership Agreement, with an optional Operator role\r\n/// @author Dr. Jonathan Shahen at UREEQA\r\n/// @notice TODO\r\n/// @dev Maximum number of Owners is set to 255 (unit8.MAX_VALUE)\r\ncontract OwnershipAgreementv3 {\r\n    /*\r\n     * Storage\r\n     */\r\n\r\n    // ResolutionTypes:\r\n    uint constant private resTypeNone = 0; // This indicates that the resolution hasn't been set (default value)\r\n    uint constant private resTypeAddOwner = 1;\r\n    uint constant private resTypeRemoveOwner = 2;\r\n    uint constant private resTypeReplaceOwner = 3;\r\n    uint constant private resTypeAddOperator = 4;\r\n    uint constant private resTypeRemoveOperator = 5;\r\n    uint constant private resTypeReplaceOperator = 6;\r\n    uint constant private resTypeUpdateThreshold = 7;\r\n    uint constant private resTypeUpdateTransactionLimit = 8;\r\n    uint constant private resTypePause = 9;\r\n    uint constant private resTypeUnpause = 10;\r\n    uint constant private resTypeCustom = 1000; // Custom resoutions for each subclass\r\n\r\n    struct Resolution {\r\n        // Has the resolution already been passed\r\n        bool passed;\r\n        // The type of resolution\r\n        uint256 resType;\r\n        // The old address, can be address(0). oldAddress and newAddress cannot both equal address(0).\r\n        address oldAddress;\r\n        // The new address, can be address(0). oldAddress and newAddress cannot both equal address(0).\r\n        address newAddress;\r\n        // Able to store extra information for custom resolutions\r\n        bytes32[] extra;\r\n    }\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    // Set of owners\r\n    // NOTE: we utilize a set, so we can enumerate the owners and so that the list only contains one instance of an account\r\n    // NOTE: address(0) is not a valid owner\r\n    EnumerableSet.AddressSet private _owners;\r\n    // Value to indicate if the smart contract is paused\r\n    bool private _paused;\r\n    // An address, usually controlled by a computer, that performs regular/automated operations within the smart contract\r\n    // NOTE: address(0) is not a valid operator\r\n    EnumerableSet.AddressSet private _operators;\r\n    // Limit the number of operators\r\n    uint256 public operatorLimit = 1;\r\n    // The number of owners it takes to come to an agreement\r\n    uint256 public ownerAgreementThreshold = 1;\r\n    // Limit per Transaction to impose\r\n    // A limit of zero means no limit imposed\r\n    uint256 public transactionLimit = 0;\r\n    // Stores each vote for each resolution number (int)\r\n    mapping(address => mapping(uint256 => bool)) public ownerVotes;\r\n    // The next available resolution number\r\n    uint256 public nextResolution = 1;\r\n    mapping(address => uint256) lastOwnerResolutionNumber;\r\n    // Stores the resolutions\r\n    mapping(uint256 => Resolution) public resolutions;\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // EVENTS\r\n    // ////////////////////////////////////////////////////\r\n    event OwnerAddition(address owner);\r\n    event OwnerRemoval(address owner);\r\n    event OwnerReplacement(address oldOwner, address newOwner);\r\n\r\n    event OperatorAddition(address newOperator);\r\n    event OperatorRemoval(address oldOperator);\r\n    event OperatorReplacement(address oldOperator, address newOperator);\r\n\r\n    event UpdateThreshold(uint256 newThreshold);\r\n    event UpdateNumberOfOperators(uint256 newOperators);\r\n    event UpdateTransactionLimit(uint256 newLimit);\r\n    /// @dev Emitted when the pause is triggered by `account`.\r\n    event Paused(address account);\r\n    /// @dev Emitted when the pause is lifted by `account`.\r\n    event Unpaused(address account);\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // MODIFIERS\r\n    // ////////////////////////////////////////////////////\r\n    function isValidAddress(address newAddr) public pure {\r\n        require(newAddr != address(0), \"Invaild Address\");\r\n    }\r\n\r\n    modifier onlyOperators() {\r\n        isValidAddress(msg.sender);\r\n        require(\r\n            EnumerableSet.contains(_operators, msg.sender) == true,\r\n            \"Only the operator can run this function.\"\r\n        );\r\n        _;\r\n    }\r\n    modifier onlyOwners() {\r\n        isValidAddress(msg.sender);\r\n        require(\r\n            EnumerableSet.contains(_owners, msg.sender) == true,\r\n            \"Only an owner can run this function.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnersOrOperator() {\r\n        isValidAddress(msg.sender);\r\n        require(\r\n            EnumerableSet.contains(_operators, msg.sender) == true ||\r\n                EnumerableSet.contains(_owners, msg.sender) == true,\r\n            \"Only an owner or the operator can run this function.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address thisOwner) {\r\n        require(\r\n            EnumerableSet.contains(_owners, thisOwner) == true,\r\n            \"Owner does not exists.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     * Requirements: The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Smart Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     * Requirements: The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Smart Contract is not paused\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to make a function callable only when the amount is within the transaction limit\r\n    modifier withinLimit(uint256 amount) {\r\n        require(\r\n            transactionLimit == 0 || amount <= transactionLimit,\r\n            \"Amount is over the transaction limit\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // CONSTRUCTOR\r\n    // ////////////////////////////////////////////////////\r\n    constructor() {\r\n        _addOwner(msg.sender);\r\n        _paused = false;\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // VIEW FUNCTIONS\r\n    // ////////////////////////////////////////////////////\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        if(EnumerableSet.length(_owners) == 0) return address(0);\r\n        return EnumerableSet.at(_owners, 0);\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners() public view returns (address[] memory) {\r\n        uint256 len = EnumerableSet.length(_owners);\r\n        address[] memory o = new address[](len);\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            o[i] = EnumerableSet.at(_owners, i);\r\n        }\r\n\r\n        return o;\r\n    }\r\n\r\n    /// @dev Returns the number of owners.\r\n    /// @return Number of owners.\r\n    function getNumberOfOwners() public view returns (uint) {\r\n        return EnumerableSet.length(_owners);\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOperators() public view returns (address[] memory) {\r\n        uint256 len = EnumerableSet.length(_operators);\r\n        address[] memory o = new address[](len);\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            o[i] = EnumerableSet.at(_operators, i);\r\n        }\r\n\r\n        return o;\r\n    }\r\n\r\n    /// @dev Returns the number of operators.\r\n    /// @return Number of operators.\r\n    function getNumberOfOperators() public view returns (uint8) {\r\n        return uint8(EnumerableSet.length(_operators));\r\n    }\r\n\r\n    /// @dev How many owners does it take to approve a resolution\r\n    /// @return minimum number of owner votes\r\n    function getVoteThreshold() public view returns (uint256) {\r\n        return ownerAgreementThreshold;\r\n    }\r\n\r\n    /// @dev Returns the maximum amount a transaction can contain\r\n    /// @return maximum amount or zero is no limit\r\n    function getTransactionLimit() public view returns (uint256) {\r\n        return transactionLimit;\r\n    }\r\n\r\n    /// @dev Returns the next available resolution.\r\n    /// @return The next available resolution number\r\n    function getNextResolutionNumber() public view returns (uint256) {\r\n        return nextResolution;\r\n    }\r\n\r\n    /// @dev Returns the next available resolution.\r\n    /// @return The next available resolution number\r\n    function getLastOwnerResolutionNumber(address thisOwner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return lastOwnerResolutionNumber[thisOwner];\r\n    }\r\n\r\n    /// @dev Returns true if the contract is paused, and false otherwise.\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /// @dev Helper function to fail if resolution number is already in use.\r\n    function resolutionAlreadyUsed(uint256 resNum) public view {\r\n        require(\r\n            // atleast one of the address must not be equal to address(0)\r\n            !(resolutions[resNum].oldAddress != address(0) ||\r\n                resolutions[resNum].newAddress != address(0)),\r\n            \"Resolution is already in use.\"\r\n        );\r\n    }\r\n\r\n    function isResolutionPassed(uint256 resNum) public view returns (bool) {\r\n        return resolutions[resNum].passed;\r\n    }\r\n\r\n    function canResolutionPass(uint256 resNum) public view returns (bool) {\r\n        uint256 voteCount = 0;\r\n        uint256 len = EnumerableSet.length(_owners);\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            if (ownerVotes[EnumerableSet.at(_owners, i)][resNum] == true) {\r\n                voteCount++;\r\n            }\r\n        }\r\n\r\n        return voteCount >= ownerAgreementThreshold;\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // PUBLIC FUNCTIONS\r\n    // ////////////////////////////////////////////////////\r\n\r\n    /// @notice Vote Yes on a Resolution.\r\n    /// @dev The owner who tips the agreement threshold will pay the gas for performing the resolution.\r\n    /// @return TRUE if the resolution passed\r\n    function voteResolution(uint256 resNum) public onlyOwners() returns (bool) {\r\n        ownerVotes[msg.sender][resNum] = true;\r\n\r\n        // If the reolution has already passed, then do nothing\r\n        if (isResolutionPassed(resNum)) {\r\n            return true;\r\n        }\r\n\r\n        // If the resolution can now be passed, then do so\r\n        if (canResolutionPass(resNum)) {\r\n            _performResolution(resNum);\r\n            return true;\r\n        }\r\n\r\n        // The resolution cannot be passed yet\r\n        return false;\r\n    }\r\n\r\n    /// @dev Create a resolution to add an owner. Performs addition if threshold is 1 or zero.\r\n    function createResolutionAddOwner(address newOwner) public onlyOwners() {\r\n        isValidAddress(newOwner);\r\n        require(\r\n            !EnumerableSet.contains(_owners, newOwner),\r\n            \"newOwner already exists.\"\r\n        );\r\n\r\n        createResolution(resTypeAddOwner, address(0), newOwner, new bytes32[](0));\r\n    }\r\n\r\n    /// @dev Create a resolution to remove an owner. Performs removal if threshold is 1 or zero.\r\n    /// @dev Updates the threshold to keep it less than or equal to the number of new owners\r\n    function createResolutionRemoveOwner(address oldOwner) public onlyOwners() {\r\n        isValidAddress(oldOwner);\r\n        require(getNumberOfOwners() > 1, \"Must always be one owner\");\r\n        require(\r\n            EnumerableSet.contains(_owners, oldOwner),\r\n            \"owner is not an owner.\"\r\n        );\r\n\r\n        createResolution(resTypeRemoveOwner, oldOwner, address(0), new bytes32[](0));\r\n    }\r\n\r\n    /// @dev Create a resolution to repalce an owner. Performs replacement if threshold is 1 or zero.\r\n    function createResolutionReplaceOwner(address oldOwner, address newOwner)\r\n        public\r\n        onlyOwners()\r\n    {\r\n        isValidAddress(oldOwner);\r\n        isValidAddress(newOwner);\r\n        require(\r\n            EnumerableSet.contains(_owners, oldOwner),\r\n            \"oldOwner is not an owner.\"\r\n        );\r\n        require(\r\n            !EnumerableSet.contains(_owners, newOwner),\r\n            \"newOwner already exists.\"\r\n        );\r\n\r\n        createResolution(resTypeReplaceOwner, oldOwner, newOwner, new bytes32[](0));\r\n    }\r\n\r\n    /// @dev Create a resolution to add an operator. Performs addition if threshold is 1 or zero.\r\n    function createResolutionAddOperator(address newOperator)\r\n        public\r\n        onlyOwners()\r\n    {\r\n        isValidAddress(newOperator);\r\n        require(\r\n            !EnumerableSet.contains(_operators, newOperator),\r\n            \"newOperator already exists.\"\r\n        );\r\n\r\n        createResolution(resTypeAddOperator, address(0), newOperator, new bytes32[](0));\r\n    }\r\n\r\n    /// @dev Create a resolution to remove the operator. Performs removal if threshold is 1 or zero.\r\n    function createResolutionRemoveOperator(address operator)\r\n        public\r\n        onlyOwners()\r\n    {\r\n        require(\r\n            EnumerableSet.contains(_operators, operator),\r\n            \"operator is not an Operator.\"\r\n        );\r\n        createResolution(resTypeRemoveOperator, operator, address(0), new bytes32[](0));\r\n    }\r\n\r\n    /// @dev Create a resolution to replace the operator account. Performs replacement if threshold is 1 or zero.\r\n    function createResolutionReplaceOperator(\r\n        address oldOperator,\r\n        address newOperator\r\n    ) public onlyOwners() {\r\n        isValidAddress(oldOperator);\r\n        isValidAddress(newOperator);\r\n        require(\r\n            EnumerableSet.contains(_operators, oldOperator),\r\n            \"oldOperator is not an Operator.\"\r\n        );\r\n        require(\r\n            !EnumerableSet.contains(_operators, newOperator),\r\n            \"newOperator already exists.\"\r\n        );\r\n\r\n        createResolution(resTypeReplaceOperator, oldOperator, newOperator,new bytes32[](0));\r\n    }\r\n\r\n    /// @dev Create a resolution to update the transaction limit. Performs update if threshold is 1 or zero.\r\n    function createResolutionUpdateTransactionLimit(uint160 newLimit)\r\n        public\r\n        onlyOwners()\r\n    {\r\n        createResolution(\r\n            resTypeUpdateTransactionLimit,\r\n            address(0),\r\n            address(newLimit),\r\n            new bytes32[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Create a resolution to update the owner agreement threshold. Performs update if threshold is 1 or zero.\r\n    function createResolutionUpdateThreshold(uint160 threshold)\r\n        public\r\n        onlyOwners()\r\n    {\r\n        createResolution(\r\n            resTypeUpdateThreshold,\r\n            address(0),\r\n            address(threshold),\r\n            new bytes32[](0)\r\n        );\r\n    }\r\n\r\n    /// @dev Pause the contract. Does not require owner agreement.\r\n    function pause() public onlyOwners() {\r\n        _pause();\r\n    }\r\n\r\n    /// @dev Create a resolution to unpause the contract. Performs update if threshold is 1 or zero.\r\n    function createResolutionUnpause() public onlyOwners() {\r\n        createResolution(resTypeUnpause, address(1), address(1), new bytes32[](0));\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // INTERNAL FUNCTIONS\r\n    // ////////////////////////////////////////////////////\r\n    /// @dev Create a resolution and check if we can call perofrm the resolution with 1 vote.\r\n    function createResolution(\r\n        uint256 resType,\r\n        address oldAddress,\r\n        address newAddress,\r\n        bytes32[] memory extra\r\n    ) internal {\r\n        uint256 resNum = nextResolution;\r\n        nextResolution++;\r\n        resolutionAlreadyUsed(resNum);\r\n\r\n        resolutions[resNum].resType = resType;\r\n        resolutions[resNum].oldAddress = oldAddress;\r\n        resolutions[resNum].newAddress = newAddress;\r\n        resolutions[resNum].extra = extra;\r\n\r\n        ownerVotes[msg.sender][resNum] = true;\r\n        lastOwnerResolutionNumber[msg.sender] = resNum;\r\n\r\n        // Check if agreement is already reached\r\n        if (ownerAgreementThreshold <= 1) {\r\n            _performResolution(resNum);\r\n        }\r\n    }\r\n\r\n    /// @dev Performs the resolution and then marks it as passed. No checks prevent it from performing the resolutions.\r\n    function _performResolution(uint256 resNum) internal {\r\n        if (resolutions[resNum].resType == resTypeAddOwner) {\r\n            _addOwner(resolutions[resNum].newAddress);\r\n        } else if (resolutions[resNum].resType == resTypeRemoveOwner) {\r\n            _removeOwner(resolutions[resNum].oldAddress);\r\n        } else if (resolutions[resNum].resType == resTypeReplaceOwner) {\r\n            _replaceOwner(\r\n                resolutions[resNum].oldAddress,\r\n                resolutions[resNum].newAddress\r\n            );\r\n        } else if (resolutions[resNum].resType == resTypeAddOperator) {\r\n            _addOperator(resolutions[resNum].newAddress);\r\n        } else if (resolutions[resNum].resType == resTypeRemoveOperator) {\r\n            _removeOperator(resolutions[resNum].oldAddress);\r\n        } else if (resolutions[resNum].resType == resTypeReplaceOperator) {\r\n            _replaceOperator(\r\n                resolutions[resNum].oldAddress,\r\n                resolutions[resNum].newAddress\r\n            );\r\n        } else if (\r\n            resolutions[resNum].resType == resTypeUpdateTransactionLimit\r\n        ) {\r\n            _updateTransactionLimit(uint160(resolutions[resNum].newAddress));\r\n        } else if (resolutions[resNum].resType == resTypeUpdateThreshold) {\r\n            _updateThreshold(uint160(resolutions[resNum].newAddress));\r\n        } else if (resolutions[resNum].resType == resTypePause) {\r\n            _pause();\r\n        } else if (resolutions[resNum].resType == resTypeUnpause) {\r\n            _unpause();\r\n        } else {\r\n            _customResolutions(resNum);\r\n            return;\r\n        }\r\n\r\n        resolutions[resNum].passed = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Able to handle Custom Resolutions.\r\n     * \r\n     * Requirements:\r\n     * \r\n     * - Must set the resolution passed: resolutions[resNum].passed = true;\r\n     * - You should check the resolutions[resNum].resType to know what to perform\r\n     */\r\n    function _customResolutions(uint256 resNum) internal virtual {}\r\n\r\n    /// @dev\r\n    function _addOwner(address newOwner) internal {\r\n        EnumerableSet.add(_owners, newOwner);\r\n        emit OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev\r\n    function _removeOwner(address newOwner) internal {\r\n        EnumerableSet.remove(_owners, newOwner);\r\n        emit OwnerRemoval(newOwner);\r\n\r\n        uint numOwners = getNumberOfOwners();\r\n        if (ownerAgreementThreshold > numOwners) {\r\n            _updateThreshold(numOwners);\r\n        }\r\n    }\r\n\r\n    /// @dev\r\n    function _replaceOwner(address oldOwner, address newOwner) internal {\r\n        EnumerableSet.remove(_owners, oldOwner);\r\n        EnumerableSet.add(_owners, newOwner);\r\n        emit OwnerReplacement(oldOwner, newOwner);\r\n    }\r\n\r\n    /// @dev\r\n    function _addOperator(address operator) internal {\r\n        EnumerableSet.add(_operators, operator);\r\n        emit OperatorAddition(operator);\r\n    }\r\n\r\n    /// @dev\r\n    function _removeOperator(address operator) internal {\r\n        EnumerableSet.remove(_operators, operator);\r\n        emit OperatorRemoval(operator);\r\n    }\r\n\r\n    /// @dev\r\n    function _replaceOperator(address oldOperator, address newOperator)\r\n        internal\r\n    {\r\n        emit OperatorReplacement(oldOperator, newOperator);\r\n        EnumerableSet.remove(_operators, oldOperator);\r\n        EnumerableSet.add(_operators, newOperator);\r\n    }\r\n\r\n    /// @dev Internal function to update and emit the new transaction limit\r\n    function _updateTransactionLimit(uint256 newLimit) internal {\r\n        emit UpdateTransactionLimit(newLimit);\r\n        transactionLimit = newLimit;\r\n    }\r\n\r\n    /// @dev Internal function to update and emit the new voting threshold\r\n    function _updateThreshold(uint threshold) internal {\r\n        require(\r\n            threshold <= getNumberOfOwners(),\r\n            \"Unable to set threshold above the number of owners\"\r\n        );\r\n        emit UpdateThreshold(threshold);\r\n        ownerAgreementThreshold = threshold;\r\n    }\r\n\r\n    /// @dev Internal function to update and emit the new voting threshold\r\n    function _updateNumberOfOperators(uint160 numOperators) internal {\r\n        require(\r\n            numOperators >= getNumberOfOperators(),\r\n            \"Unable to set number of Operators below the number of operators\"\r\n        );\r\n        emit UpdateNumberOfOperators(numOperators);\r\n        operatorLimit = numOperators;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements: The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements: The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// File: contracts/UreeqaRandomNumberv1.sol\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n\r\n\r\n/// @title Random Numbers by UREEQA.\r\n/// @author Dr. Jonathan Shahen at UREEQA\r\n/// @notice Random number generatation for UREEQA that utilizes ChainLink\r\n/// @dev Utilize the block number if you require to check state of other smart contracts\r\ncontract UreeqaRandomNumberv1 is OwnershipAgreementv3, VRFConsumerBase {\r\n    // ////////////////////////////////////////////////////\r\n    // STORAGE\r\n    // ////////////////////////////////////////////////////\r\n    struct RandomNumber {\r\n        uint256 id;\r\n        bytes32 fileHash;\r\n        bytes32 requestId;\r\n        uint256 blockTime;\r\n        uint256 blockNumber;\r\n        uint256 randomNumber;\r\n    }\r\n\r\n    // ChainLink settings\r\n    bytes32 keyHash;\r\n    // How much LINK it costs for a random number\r\n    uint256 fee;\r\n\r\n    // Store all the staked content. ID => RandomNumber\r\n    mapping(uint256 => RandomNumber) randomNumbers;\r\n    // Store all the staked content. ID => RandomNumber\r\n    mapping(bytes32 => uint256) requestIdToId;\r\n    // Last ID Used\r\n    uint256 lastId;\r\n    // Number of Random Numbers\r\n    uint256 numberOfRandomNumbers;\r\n    // Reference filehash to id\r\n    mapping(bytes32 => uint256) hashToId;\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // CONSTRUCTOR\r\n    // ////////////////////////////////////////////////////\r\n    constructor(\r\n        address vrfCoordinator,\r\n        address linkToken,\r\n        bytes32 _keyHash,\r\n        uint256 _fee,\r\n        address operator\r\n    ) VRFConsumerBase(vrfCoordinator, linkToken) {\r\n        keyHash = _keyHash;\r\n        fee = _fee;\r\n        if (operator != address(0)) {\r\n            createResolutionAddOperator(operator);\r\n        }\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // EVENTS\r\n    // ////////////////////////////////////////////////////\r\n    event NewRandomNumber(uint256 id, bytes32 fileHash);\r\n\r\n    event RandomNumberGenerated(\r\n        uint256 id,\r\n        bytes32 fileHash,\r\n        uint256 blockNumber,\r\n        uint256 randomNumber\r\n    );\r\n\r\n    event FileHashChanged(\r\n        uint256 id,\r\n        bytes32 old_fileHash,\r\n        bytes32 new_fileHash\r\n    );\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // MODIFIERS\r\n    // ////////////////////////////////////////////////////\r\n\r\n    modifier nonZeroId(uint256 id) {\r\n        require(id != 0, \"Content Staking ID cannot be 0.\");\r\n        _;\r\n    }\r\n    modifier nonZeroFileHash(bytes32 fileHash) {\r\n        require(fileHash != 0, \"File hash cannot be 0.\");\r\n        _;\r\n    }\r\n    modifier idMustExists(uint256 id) {\r\n        require(randomNumbers[id].id != 0, \"ID does not exists\");\r\n        _;\r\n    }\r\n    modifier idMustBeUnique(uint256 id) {\r\n        require(randomNumbers[id].id == 0, \"ID must be unique\");\r\n        _;\r\n    }\r\n    modifier hashMustBeUnique(bytes32 fileHash) {\r\n        require(hashToId[fileHash] == 0, \"File Hash must be unique\");\r\n        _;\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // VIEW FUNCTIONS\r\n    // ////////////////////////////////////////////////////\r\n\r\n    /// @dev Returns the last id that was created\r\n    function getLastId() public view returns (uint256) {\r\n        return lastId;\r\n    }\r\n\r\n    /// @dev Get the ID from a filehash\r\n    function getId(bytes32 fileHash)\r\n        public\r\n        view\r\n        nonZeroFileHash(fileHash)\r\n        returns (uint256)\r\n    {\r\n        return hashToId[fileHash];\r\n    }\r\n\r\n    /// @dev Get the ID from a filehash\r\n    function getFileHash(uint256 id)\r\n        public\r\n        view\r\n        nonZeroId(id)\r\n        idMustExists(id)\r\n        returns (bytes32)\r\n    {\r\n        return randomNumbers[id].fileHash;\r\n    }\r\n\r\n    /// @dev Get the Block Time when the random number was generated\r\n    function getBlockTime(uint256 id)\r\n        public\r\n        view\r\n        nonZeroId(id)\r\n        idMustExists(id)\r\n        returns (uint256)\r\n    {\r\n        return randomNumbers[id].blockTime;\r\n    }\r\n\r\n    /// @dev Get the Block Number when the random number was generated\r\n    function getBlockNumber(uint256 id)\r\n        public\r\n        view\r\n        nonZeroId(id)\r\n        idMustExists(id)\r\n        returns (uint256)\r\n    {\r\n        return randomNumbers[id].blockNumber;\r\n    }\r\n\r\n    /// @dev Return the generated random number. Zero represents a non-generated number.\r\n    function getRandomNumber(uint256 id)\r\n        public\r\n        view\r\n        nonZeroId(id)\r\n        idMustExists(id)\r\n        returns (uint256)\r\n    {\r\n        return randomNumbers[id].randomNumber;\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // PUBLIC/OPERATOR FUNCTIONS\r\n    // ////////////////////////////////////////////////////\r\n\r\n    /// @dev Creates a new random number\r\n    function newRandomNumber(uint256 id, bytes32 fileHash)\r\n        public\r\n        onlyOperators()\r\n        nonZeroId(id)\r\n        idMustBeUnique(id)\r\n        nonZeroFileHash(fileHash)\r\n        hashMustBeUnique(fileHash)\r\n    {\r\n        randomNumbers[id].id = id;\r\n        randomNumbers[id].fileHash = fileHash;\r\n\r\n        emit NewRandomNumber(id, fileHash);\r\n\r\n        hashToId[fileHash] = id;\r\n        lastId = id;\r\n        numberOfRandomNumbers += 1;\r\n    }\r\n\r\n    /// @dev Bulk creation to reduce gas fees.\r\n    function bulkRandomNumbers(\r\n        uint256[] memory ids,\r\n        bytes32[] memory fileHashes\r\n    ) public onlyOperators() {\r\n        require(\r\n            ids.length == fileHashes.length,\r\n            \"Arrays must be the same length\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            newRandomNumber(ids[i], fileHashes[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Generate the random number\r\n    function generateRandomNumber(uint256 id)\r\n        public\r\n        onlyOperators()\r\n        nonZeroId(id)\r\n        idMustExists(id)\r\n    {\r\n        require(\r\n            randomNumbers[id].requestId == 0,\r\n            \"Request already exists for this ID.\"\r\n        );\r\n        require(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK\");\r\n        bytes32 requestId = requestRandomness(keyHash, fee);\r\n        randomNumbers[id].requestId = requestId;\r\n        requestIdToId[requestId] = id;\r\n    }\r\n\r\n    /// @dev Generate the random numbers\r\n    function bulkGenerateRandomNumbers(uint256[] memory ids)\r\n        public\r\n        onlyOperators()\r\n    {\r\n        require(\r\n            LINK.balanceOf(address(this)) >= fee * ids.length,\r\n            \"Not enough LINK\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            require(ids[i] != 0, \"ID cannot be 0\");\r\n            require(randomNumbers[ids[i]].fileHash != 0, \"ID does not exists\");\r\n            require(\r\n                randomNumbers[ids[i]].requestId == 0,\r\n                \"Request already exists for this ID.\"\r\n            );\r\n\r\n            bytes32 requestId = requestRandomness(keyHash, fee);\r\n            randomNumbers[ids[i]].requestId = requestId;\r\n            requestIdToId[requestId] = ids[i];\r\n        }\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // OWNER FUNCTIONS\r\n    // ////////////////////////////////////////////////////\r\n\r\n    /// @dev Update a file hash, resets the old file hash.\r\n    function updateFileHash(uint256 id, bytes32 newFileHash)\r\n        public\r\n        onlyOwners()\r\n        nonZeroId(id)\r\n        idMustExists(id)\r\n    {\r\n        bytes32 oldFileHash = randomNumbers[id].fileHash;\r\n\r\n        emit FileHashChanged(id, oldFileHash, newFileHash);\r\n\r\n        randomNumbers[id].fileHash = newFileHash;\r\n        hashToId[oldFileHash] = 0;\r\n        hashToId[newFileHash] = id;\r\n    }\r\n\r\n    /// @dev transfer LINK tokens from this contract to another address\r\n    function transferLINK(address sendTo, uint256 amount) public onlyOwners() {\r\n        LINK.transfer(sendTo, amount);\r\n    }\r\n\r\n    /// @dev updates the CHAINLINK fee\r\n    function updateLINKFee(uint256 new_fee) public onlyOwners() {\r\n        fee = new_fee;\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // CHAINLINK FUNCTIONS\r\n    // ////////////////////////////////////////////////////\r\n\r\n    /**\r\n     * Callback function used by VRF Coordinator\r\n     */\r\n    function fulfillRandomness(bytes32 requestId, uint256 randomness)\r\n        internal\r\n        override\r\n    {\r\n        require(requestIdToId[requestId] != 0, \"Unknown request ID\");\r\n        require(randomNumbers[requestIdToId[requestId]].randomNumber == 0, \"Request ID already fulfilled\");\r\n        \r\n        randomNumbers[requestIdToId[requestId]].randomNumber = randomness;\r\n        randomNumbers[requestIdToId[requestId]].blockTime = block.timestamp;\r\n        randomNumbers[requestIdToId[requestId]].blockNumber = block.number;\r\n\r\n        emit RandomNumberGenerated(\r\n            requestIdToId[requestId],\r\n            randomNumbers[requestIdToId[requestId]].fileHash,\r\n            randomNumbers[requestIdToId[requestId]].blockNumber,\r\n            randomNumbers[requestIdToId[requestId]].randomNumber\r\n        );\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // INTERNAL FUNCTIONS\r\n    // ////////////////////////////////////////////////////\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"old_fileHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"new_fileHash\",\"type\":\"bytes32\"}],\"name\":\"FileHashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fileHash\",\"type\":\"bytes32\"}],\"name\":\"NewRandomNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"}],\"name\":\"OperatorRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorReplacement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerReplacement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fileHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"RandomNumberGenerated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newOperators\",\"type\":\"uint256\"}],\"name\":\"UpdateNumberOfOperators\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"UpdateThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"UpdateTransactionLimit\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"bulkGenerateRandomNumbers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"fileHashes\",\"type\":\"bytes32[]\"}],\"name\":\"bulkRandomNumbers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"resNum\",\"type\":\"uint256\"}],\"name\":\"canResolutionPass\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"createResolutionAddOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"createResolutionAddOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"createResolutionRemoveOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"createResolutionRemoveOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"createResolutionReplaceOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"createResolutionReplaceOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createResolutionUnpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"threshold\",\"type\":\"uint160\"}],\"name\":\"createResolutionUpdateThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"newLimit\",\"type\":\"uint160\"}],\"name\":\"createResolutionUpdateTransactionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"generateRandomNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getFileHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"fileHash\",\"type\":\"bytes32\"}],\"name\":\"getId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"thisOwner\",\"type\":\"address\"}],\"name\":\"getLastOwnerResolutionNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextResolutionNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfOperators\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfOwners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getRandomNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransactionLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVoteThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"resNum\",\"type\":\"uint256\"}],\"name\":\"isResolutionPassed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"isValidAddress\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"fileHash\",\"type\":\"bytes32\"}],\"name\":\"newRandomNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextResolution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAgreementThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerVotes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"resNum\",\"type\":\"uint256\"}],\"name\":\"resolutionAlreadyUsed\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolutions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"passed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"resType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferLINK\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"newFileHash\",\"type\":\"bytes32\"}],\"name\":\"updateFileHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_fee\",\"type\":\"uint256\"}],\"name\":\"updateLINKFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"resNum\",\"type\":\"uint256\"}],\"name\":\"voteResolution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UreeqaRandomNumberv1","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f0d54349addcf704f77ae15b96510dea15cb7952000000000000000000000000514910771af9ca656af840dff83e8264ecf986caaa77729d3466ca35ae8d28b3bbac7cc36a5031efdc430821c02bc31a238af4450000000000000000000000000000000000000000000000001bc16d674ec8000000000000000000000000000085b576bf8d956721608122ac8cf65e2baafad2c1","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fdc80af93550ff5f83b8a103843f7e4be2a93557f37f53f2519091765eecbf65"}]}