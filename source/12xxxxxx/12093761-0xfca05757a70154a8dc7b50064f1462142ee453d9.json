{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/oracleIterators/ChainlinkOracleIterator.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"./IOracleIterator.sol\\\";\\n\\ncontract ChainlinkOracleIterator is IOracleIterator {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant PHASE_OFFSET = 64;\\n    int256 public constant NEGATIVE_INFINITY = type(int256).min;\\n    uint256 private constant MAX_ITERATION = 24;\\n\\n    function isOracleIterator() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    function symbol() external pure override returns (string memory) {\\n        return \\\"ChainlinkIterator\\\";\\n    }\\n\\n    function getUnderlyingValue(\\n        address _oracle,\\n        uint256 _timestamp,\\n        uint256[] calldata _roundHints\\n    ) external view override returns (int256) {\\n        require(_timestamp > 0, \\\"Zero timestamp\\\");\\n        require(_oracle != address(0), \\\"Zero oracle\\\");\\n        require(_roundHints.length == 1, \\\"Wrong number of hints\\\");\\n        AggregatorV3Interface oracle = AggregatorV3Interface(_oracle);\\n\\n        uint80 latestRoundId;\\n        (latestRoundId, , , , ) = oracle.latestRoundData();\\n\\n        uint80 roundHint = uint80(_roundHints[0]);\\n        if (roundHint == 0) {\\n            return getIteratedAnswer(oracle, _timestamp, latestRoundId);\\n        }\\n\\n        uint256 phaseId;\\n        (phaseId, ) = parseIds(latestRoundId);\\n\\n        if (checkSamePhase(roundHint, phaseId)) {\\n            return\\n                getHintedAnswer(oracle, _timestamp, roundHint, latestRoundId);\\n        }\\n\\n        int256 answer = getIteratedAnswer(oracle, _timestamp, latestRoundId);\\n        if (answer == NEGATIVE_INFINITY) {\\n            return\\n                getHintedAnswer(oracle, _timestamp, roundHint, latestRoundId);\\n        }\\n        return answer;\\n    }\\n\\n    function getHintedAnswer(\\n        AggregatorV3Interface _oracle,\\n        uint256 _timestamp,\\n        uint80 _roundHint,\\n        uint256 _latestRoundId\\n    ) internal view returns (int256) {\\n        int256 hintAnswer;\\n        uint256 hintTimestamp;\\n        (, hintAnswer, , hintTimestamp, ) = _oracle.getRoundData(_roundHint);\\n\\n        require(\\n            hintTimestamp > 0 && hintTimestamp <= _timestamp,\\n            \\\"Incorrect hint\\\"\\n        );\\n\\n        if (_roundHint + 1 > _latestRoundId) {\\n            return hintAnswer;\\n        }\\n\\n        uint256 timestampNext;\\n        (, , , timestampNext, ) = _oracle.getRoundData(_roundHint + 1);\\n        if (timestampNext == 0 || timestampNext > _timestamp) {\\n            return hintAnswer;\\n        }\\n\\n        return NEGATIVE_INFINITY;\\n    }\\n\\n    function getIteratedAnswer(\\n        AggregatorV3Interface _oracle,\\n        uint256 _timestamp,\\n        uint80 _latestRoundId\\n    ) internal view returns (int256) {\\n        uint256 roundTimestamp = 0;\\n        int256 roundAnswer = 0;\\n        uint80 roundId = _latestRoundId;\\n\\n        for (uint256 i = 0; i < MAX_ITERATION; i++) {\\n            (, roundAnswer, , roundTimestamp, ) = _oracle.getRoundData(roundId);\\n            roundId = roundId - 1;\\n            if (roundTimestamp <= _timestamp) {\\n                return roundAnswer;\\n            }\\n            if (roundId == 0) {\\n                return NEGATIVE_INFINITY;\\n            }\\n        }\\n\\n        return NEGATIVE_INFINITY;\\n    }\\n\\n    function checkSamePhase(uint80 _roundHint, uint256 _phase)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        uint256 currentPhaseId;\\n        (currentPhaseId, ) = parseIds(_roundHint);\\n        return currentPhaseId == _phase;\\n    }\\n\\n    function parseIds(uint256 _roundId) internal pure returns (uint16, uint64) {\\n        uint16 phaseId = uint16(_roundId >> PHASE_OFFSET);\\n        uint64 aggregatorRoundId = uint64(_roundId);\\n\\n        return (phaseId, aggregatorRoundId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"contracts/oracleIterators/IOracleIterator.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IOracleIterator {\\n    /// @notice Proof of oracle iterator contract\\n    /// @dev Verifies that contract is a oracle iterator contract\\n    /// @return true if contract is a oracle iterator contract\\n    function isOracleIterator() external pure returns (bool);\\n\\n    /// @notice Symbol of the oracle iterator\\n    /// @dev Should be resolved through OracleIteratorRegistry contract\\n    /// @return oracle iterator symbol\\n    function symbol() external pure returns (string memory);\\n\\n    /// @notice Algorithm that, for the type of oracle used by the derivative,\\n    //  finds the value closest to a given timestamp\\n    /// @param _oracle iteratable oracle through\\n    /// @param _timestamp a given timestamp\\n    /// @param _roundHints specified rounds for a given timestamp\\n    /// @return the value closest to a given timestamp\\n    function getUnderlyingValue(\\n        address _oracle,\\n        uint256 _timestamp,\\n        uint256[] calldata _roundHints\\n    ) external view returns (int256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"NEGATIVE_INFINITY\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_roundHints\",\"type\":\"uint256[]\"}],\"name\":\"getUnderlyingValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOracleIterator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ChainlinkOracleIterator","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}