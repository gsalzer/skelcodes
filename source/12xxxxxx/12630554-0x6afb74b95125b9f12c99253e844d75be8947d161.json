{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/devin/gysr/core-private/contracts/ERC20BaseRewardModule.sol\": {\r\n      \"content\": \"/*\\nERC20BaseRewardModule\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"./interfaces/IRewardModule.sol\\\";\\n\\n/**\\n * @title ERC20 base reward module\\n *\\n * @notice this abstract class implements common ERC20 funding and unlocking\\n * logic, which is inherited by other reward modules.\\n */\\nabstract contract ERC20BaseRewardModule is IRewardModule {\\n    using SafeERC20 for IERC20;\\n\\n    // single funding/reward schedule\\n    struct Funding {\\n        uint256 amount;\\n        uint256 shares;\\n        uint256 locked;\\n        uint256 updated;\\n        uint256 start;\\n        uint256 duration;\\n    }\\n\\n    // constants\\n    uint256 public constant INITIAL_SHARES_PER_TOKEN = 10**6;\\n    uint256 public constant MAX_ACTIVE_FUNDINGS = 16;\\n\\n    // funding/reward state fields\\n    mapping(address => Funding[]) private _fundings;\\n    mapping(address => uint256) private _shares;\\n    mapping(address => uint256) private _locked;\\n\\n    /**\\n     * @notice getter for total token shares\\n     */\\n    function totalShares(address token) public view returns (uint256) {\\n        return _shares[token];\\n    }\\n\\n    /**\\n     * @notice getter for total locked token shares\\n     */\\n    function lockedShares(address token) public view returns (uint256) {\\n        return _locked[token];\\n    }\\n\\n    /**\\n     * @notice getter for funding schedule struct\\n     */\\n    function fundings(address token, uint256 index)\\n        public\\n        view\\n        returns (\\n            uint256 amount,\\n            uint256 shares,\\n            uint256 locked,\\n            uint256 updated,\\n            uint256 start,\\n            uint256 duration\\n        )\\n    {\\n        Funding storage f = _fundings[token][index];\\n        return (f.amount, f.shares, f.locked, f.updated, f.start, f.duration);\\n    }\\n\\n    /**\\n     * @param token contract address of reward token\\n     * @return number of active funding schedules\\n     */\\n    function fundingCount(address token) public view returns (uint256) {\\n        return _fundings[token].length;\\n    }\\n\\n    /**\\n     * @notice compute number of unlockable shares for a specific funding schedule\\n     * @param token contract address of reward token\\n     * @param idx index of the funding\\n     * @return the number of unlockable shares\\n     */\\n    function unlockable(address token, uint256 idx)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        Funding storage funding = _fundings[token][idx];\\n\\n        // funding schedule is in future\\n        if (block.timestamp < funding.start) {\\n            return 0;\\n        }\\n        // empty\\n        if (funding.locked == 0) {\\n            return 0;\\n        }\\n        // handle zero-duration period or leftover dust from integer division\\n        if (block.timestamp >= funding.start + funding.duration) {\\n            return funding.locked;\\n        }\\n\\n        return\\n            ((block.timestamp - funding.updated) * funding.shares) /\\n            funding.duration;\\n    }\\n\\n    /**\\n     * @notice fund pool by locking up reward tokens for future distribution\\n     * @param token contract address of reward token\\n     * @param amount number of reward tokens to lock up as funding\\n     * @param duration period (seconds) over which funding will be unlocked\\n     * @param start time (seconds) at which funding begins to unlock\\n     */\\n    function _fund(\\n        address token,\\n        uint256 amount,\\n        uint256 duration,\\n        uint256 start\\n    ) internal {\\n        requireController();\\n        // validate\\n        require(amount > 0, \\\"rm1\\\");\\n        require(start >= block.timestamp, \\\"rm2\\\");\\n        require(_fundings[token].length < MAX_ACTIVE_FUNDINGS, \\\"rm3\\\");\\n\\n        IERC20 rewardToken = IERC20(token);\\n\\n        // do transfer of funding\\n        uint256 total = rewardToken.balanceOf(address(this));\\n        rewardToken.safeTransferFrom(msg.sender, address(this), amount);\\n        uint256 actual = rewardToken.balanceOf(address(this)) - total;\\n\\n        // mint shares at current rate\\n        uint256 minted =\\n            (total > 0)\\n                ? (_shares[token] * actual) / total\\n                : actual * INITIAL_SHARES_PER_TOKEN;\\n\\n        _locked[token] += minted;\\n        _shares[token] += minted;\\n\\n        // create new funding\\n        _fundings[token].push(\\n            Funding({\\n                amount: amount,\\n                shares: minted,\\n                locked: minted,\\n                updated: start,\\n                start: start,\\n                duration: duration\\n            })\\n        );\\n\\n        emit RewardsFunded(token, amount, minted, start);\\n    }\\n\\n    /**\\n     * @dev internal function to clean up stale funding schedules\\n     * @param token contract address of reward token to clean up\\n     */\\n    function _clean(address token) internal {\\n        // check for stale funding schedules to expire\\n        uint256 removed = 0;\\n        uint256 originalSize = _fundings[token].length;\\n        for (uint256 i = 0; i < originalSize; i++) {\\n            Funding storage funding = _fundings[token][i - removed];\\n            uint256 idx = i - removed;\\n\\n            if (\\n                unlockable(token, idx) == 0 &&\\n                block.timestamp >= funding.start + funding.duration\\n            ) {\\n                emit RewardsExpired(\\n                    token,\\n                    funding.amount,\\n                    funding.shares,\\n                    funding.start\\n                );\\n\\n                // remove at idx by copying last element here, then popping off last\\n                // (we don't care about order)\\n                _fundings[token][idx] = _fundings[token][\\n                    _fundings[token].length - 1\\n                ];\\n                _fundings[token].pop();\\n                removed++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev unlocks reward tokens based on funding schedules\\n     * @param token contract addres of reward token\\n     * @return shares number of shares unlocked\\n     */\\n    function _unlockTokens(address token) internal returns (uint256 shares) {\\n        // get unlockable shares for each funding schedule\\n        for (uint256 i = 0; i < _fundings[token].length; i++) {\\n            uint256 s = unlockable(token, i);\\n            Funding storage funding = _fundings[token][i];\\n            if (s > 0) {\\n                funding.locked -= s;\\n                funding.updated = block.timestamp;\\n                shares += s;\\n            }\\n        }\\n\\n        // do unlocking\\n        if (shares > 0) {\\n            _locked[token] -= shares;\\n            emit RewardsUnlocked(token, shares);\\n        }\\n    }\\n\\n    /**\\n     * @dev distribute reward tokens to user\\n     * @param user address of user receiving rweard\\n     * @param token contract address of reward token\\n     * @param shares number of shares to be distributed\\n     * @return amount number of reward tokens distributed\\n     */\\n    function _distribute(\\n        address user,\\n        address token,\\n        uint256 shares\\n    ) internal returns (uint256 amount) {\\n        // compute reward amount in tokens\\n        IERC20 rewardToken = IERC20(token);\\n        amount =\\n            (rewardToken.balanceOf(address(this)) * shares) /\\n            _shares[token];\\n\\n        // update overall reward shares\\n        _shares[token] -= shares;\\n\\n        // do reward\\n        rewardToken.safeTransfer(user, amount);\\n        emit RewardsDistributed(user, token, amount, shares);\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/ERC20CompetitiveRewardModule.sol\": {\r\n      \"content\": \"/*\\nERC20CompetitiveRewardModule\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./interfaces/IRewardModule.sol\\\";\\nimport \\\"./ERC20BaseRewardModule.sol\\\";\\nimport \\\"./GysrUtils.sol\\\";\\n\\n/**\\n * @title ERC20 competitive reward module\\n *\\n * @notice this reward module distributes a single ERC20 token as the staking reward.\\n * It is designed to offer competitive and engaging reward mechanics.\\n *\\n * @dev share seconds are the primary unit of accounting in this module. They\\n * are accrued over time and burned during reward distribution. Users can\\n * earn a time multiplier as an incentive for longer term staking. They can\\n * also receive a GYSR multiplier by spending GYSR at the time of unstaking.\\n *\\n * h/t https://github.com/ampleforth/token-geyser\\n */\\ncontract ERC20CompetitiveRewardModule is ERC20BaseRewardModule {\\n    using SafeERC20 for IERC20;\\n    using GysrUtils for uint256;\\n\\n    // single stake by user\\n    struct Stake {\\n        uint256 shares;\\n        uint256 timestamp;\\n    }\\n\\n    mapping(address => Stake[]) public stakes;\\n\\n    // configuration fields\\n    uint256 public immutable bonusMin;\\n    uint256 public immutable bonusMax;\\n    uint256 public immutable bonusPeriod;\\n    IERC20 private immutable _token;\\n    address private immutable _factory;\\n\\n    // global state fields\\n    uint256 public totalStakingShares;\\n    uint256 public totalStakingShareSeconds;\\n    uint256 public lastUpdated;\\n    uint256 private _usage;\\n\\n    /**\\n     * @param token_ the token that will be rewarded\\n     * @param bonusMin_ initial time bonus\\n     * @param bonusMax_ maximum time bonus\\n     * @param bonusPeriod_ period (in seconds) over which time bonus grows to max\\n     * @param factory_ address of module factory\\n     */\\n    constructor(\\n        address token_,\\n        uint256 bonusMin_,\\n        uint256 bonusMax_,\\n        uint256 bonusPeriod_,\\n        address factory_\\n    ) {\\n        require(bonusMin_ <= bonusMax_, \\\"crm1\\\");\\n\\n        _token = IERC20(token_);\\n        _factory = factory_;\\n\\n        bonusMin = bonusMin_;\\n        bonusMax = bonusMax_;\\n        bonusPeriod = bonusPeriod_;\\n\\n        lastUpdated = block.timestamp;\\n    }\\n\\n    // -- IRewardModule -------------------------------------------------------\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function tokens()\\n        external\\n        view\\n        override\\n        returns (address[] memory tokens_)\\n    {\\n        tokens_ = new address[](1);\\n        tokens_[0] = address(_token);\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function balances()\\n        external\\n        view\\n        override\\n        returns (uint256[] memory balances_)\\n    {\\n        balances_ = new uint256[](1);\\n        balances_[0] = totalLocked();\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function usage() external view override returns (uint256) {\\n        return _usage;\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function factory() external view override returns (address) {\\n        return _factory;\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function stake(\\n        address account,\\n        address,\\n        uint256 shares,\\n        bytes calldata\\n    ) external override onlyOwner returns (uint256, uint256) {\\n        _update();\\n        _stake(account, shares);\\n        return (0, 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function unstake(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) external override onlyOwner returns (uint256, uint256) {\\n        _update();\\n        return _unstake(account, user, shares, data);\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function claim(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) external override onlyOwner returns (uint256 spent, uint256 vested) {\\n        _update();\\n        (spent, vested) = _unstake(account, user, shares, data);\\n        _stake(account, shares);\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function update(address) external override {\\n        requireOwner();\\n        _update();\\n    }\\n\\n    /**\\n     * @inheritdoc IRewardModule\\n     */\\n    function clean() external override {\\n        requireOwner();\\n        _update();\\n        _clean(address(_token));\\n    }\\n\\n    // -- ERC20CompetitiveRewardModule ----------------------------------------\\n\\n    /**\\n     * @notice fund module by locking up reward tokens for distribution\\n     * @param amount number of reward tokens to lock up as funding\\n     * @param duration period (seconds) over which funding will be unlocked\\n     */\\n    function fund(uint256 amount, uint256 duration) external {\\n        _update();\\n        _fund(address(_token), amount, duration, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice fund module by locking up reward tokens for distribution\\n     * @param amount number of reward tokens to lock up as funding\\n     * @param duration period (seconds) over which funding will be unlocked\\n     * @param start time (seconds) at which funding begins to unlock\\n     */\\n    function fund(\\n        uint256 amount,\\n        uint256 duration,\\n        uint256 start\\n    ) external {\\n        _update();\\n        _fund(address(_token), amount, duration, start);\\n    }\\n\\n    /**\\n     * @notice compute time bonus earned as a function of staking time\\n     * @param time length of time for which the tokens have been staked\\n     * @return bonus multiplier for time\\n     */\\n    function timeBonus(uint256 time) public view returns (uint256) {\\n        if (time >= bonusPeriod) {\\n            return 10**DECIMALS + bonusMax;\\n        }\\n\\n        // linearly interpolate between bonus min and bonus max\\n        uint256 bonus = bonusMin + ((bonusMax - bonusMin) * time) / bonusPeriod;\\n        return 10**DECIMALS + bonus;\\n    }\\n\\n    /**\\n     * @return total number of locked reward tokens\\n     */\\n    function totalLocked() public view returns (uint256) {\\n        if (lockedShares(address(_token)) == 0) {\\n            return 0;\\n        }\\n        return\\n            (_token.balanceOf(address(this)) * lockedShares(address(_token))) /\\n            totalShares(address(_token));\\n    }\\n\\n    /**\\n     * @return total number of unlocked reward tokens\\n     */\\n    function totalUnlocked() public view returns (uint256) {\\n        uint256 unlockedShares =\\n            totalShares(address(_token)) - lockedShares(address(_token));\\n\\n        if (unlockedShares == 0) {\\n            return 0;\\n        }\\n        return\\n            (_token.balanceOf(address(this)) * unlockedShares) /\\n            totalShares(address(_token));\\n    }\\n\\n    /**\\n     * @param addr address of interest\\n     * @return number of active stakes for user\\n     */\\n    function stakeCount(address addr) public view returns (uint256) {\\n        return stakes[addr].length;\\n    }\\n\\n    // -- ERC20CompetitiveRewardModule internal -------------------------------\\n\\n    /**\\n     * @dev internal implementation of stake method\\n     * @param account address of staking account\\n     * @param shares number of shares burned\\n     */\\n    function _stake(address account, uint256 shares) private {\\n        // update user staking info\\n        stakes[account].push(Stake(shares, block.timestamp));\\n\\n        // add newly minted shares to global total\\n        totalStakingShares += shares;\\n    }\\n\\n    /**\\n     * @dev internal implementation of unstake method\\n     * @param account address of staking account\\n     * @param user address of user\\n     * @param shares number of shares burned\\n     * @param data additional data\\n     * @return spent amount of gysr spent\\n     * @return vested amount of gysr vested\\n     */\\n    function _unstake(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) private returns (uint256 spent, uint256 vested) {\\n        // validate\\n        // note: we assume shares has been validated upstream\\n        require(data.length == 0 || data.length == 32, \\\"crm2\\\");\\n\\n        // parse GYSR amount from data\\n        if (data.length == 32) {\\n            assembly {\\n                spent := calldataload(164)\\n            }\\n        }\\n\\n        uint256 bonus = spent.gysrBonus(shares, totalStakingShares, _usage);\\n\\n        // do unstaking, first-in last-out, respecting time bonus\\n        uint256 shareSeconds;\\n        uint256 timeWeightedShareSeconds;\\n        (shareSeconds, timeWeightedShareSeconds) = _unstakeFirstInLastOut(\\n            account,\\n            shares\\n        );\\n\\n        // compute and apply GYSR token bonus\\n        uint256 gysrWeightedShareSeconds =\\n            (bonus * timeWeightedShareSeconds) / 10**DECIMALS;\\n\\n        // get reward in shares\\n        uint256 unlockedShares =\\n            totalShares(address(_token)) - lockedShares(address(_token));\\n\\n        uint256 rewardShares =\\n            (unlockedShares * gysrWeightedShareSeconds) /\\n                (totalStakingShareSeconds + gysrWeightedShareSeconds);\\n\\n        // reward\\n        if (rewardShares > 0) {\\n            _distribute(user, address(_token), rewardShares);\\n\\n            // update usage\\n            uint256 ratio;\\n            if (spent > 0) {\\n                vested = spent;\\n                emit GysrSpent(user, spent);\\n                emit GysrVested(user, vested);\\n                ratio = ((bonus - 10**DECIMALS) * 10**DECIMALS) / bonus;\\n            }\\n            uint256 weight =\\n                (shareSeconds * 10**DECIMALS) /\\n                    (totalStakingShareSeconds + shareSeconds);\\n            _usage =\\n                _usage -\\n                (weight * _usage) /\\n                10**DECIMALS +\\n                (weight * ratio) /\\n                10**DECIMALS;\\n        }\\n    }\\n\\n    /**\\n     * @dev internal implementation of update method to\\n     * unlock tokens and do global accounting\\n     */\\n    function _update() private {\\n        _unlockTokens(address(_token));\\n\\n        // global accounting\\n        totalStakingShareSeconds +=\\n            (block.timestamp - lastUpdated) *\\n            totalStakingShares;\\n        lastUpdated = block.timestamp;\\n    }\\n\\n    /**\\n     * @dev helper function to actually execute unstaking, first-in last-out, \\n     while computing and applying time bonus. This function also updates\\n     user and global totals for shares and share-seconds.\\n     * @param user address of user\\n     * @param shares number of staking shares to burn\\n     * @return rawShareSeconds raw share seconds burned\\n     * @return bonusShareSeconds time bonus weighted share seconds\\n     */\\n    function _unstakeFirstInLastOut(address user, uint256 shares)\\n        private\\n        returns (uint256 rawShareSeconds, uint256 bonusShareSeconds)\\n    {\\n        // redeem first-in-last-out\\n        uint256 sharesLeftToBurn = shares;\\n        Stake[] storage userStakes = stakes[user];\\n        while (sharesLeftToBurn > 0) {\\n            Stake storage lastStake = userStakes[userStakes.length - 1];\\n            uint256 stakeTime = block.timestamp - lastStake.timestamp;\\n\\n            uint256 bonus = timeBonus(stakeTime);\\n\\n            if (lastStake.shares <= sharesLeftToBurn) {\\n                // fully redeem a past stake\\n                bonusShareSeconds +=\\n                    (lastStake.shares * stakeTime * bonus) /\\n                    10**DECIMALS;\\n                rawShareSeconds += lastStake.shares * stakeTime;\\n                sharesLeftToBurn -= lastStake.shares;\\n                userStakes.pop();\\n            } else {\\n                // partially redeem a past stake\\n                bonusShareSeconds +=\\n                    (sharesLeftToBurn * stakeTime * bonus) /\\n                    10**DECIMALS;\\n                rawShareSeconds += sharesLeftToBurn * stakeTime;\\n                lastStake.shares -= sharesLeftToBurn;\\n                sharesLeftToBurn = 0;\\n            }\\n        }\\n\\n        // update global totals\\n        totalStakingShareSeconds -= rawShareSeconds;\\n        totalStakingShares -= shares;\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/GysrUtils.sol\": {\r\n      \"content\": \"/*\\nGYSRUtils\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./MathUtils.sol\\\";\\n\\n/**\\n * @title GYSR utilities\\n *\\n * @notice this library implements utility methods for the GYSR multiplier\\n * and spending mechanics\\n */\\nlibrary GysrUtils {\\n    using MathUtils for int128;\\n\\n    // constants\\n    uint256 public constant DECIMALS = 18;\\n    uint256 public constant GYSR_PROPORTION = 10**(DECIMALS - 2); // 1%\\n\\n    /**\\n     * @notice compute GYSR bonus as a function of usage ratio, stake amount,\\n     * and GYSR spent\\n     * @param gysr number of GYSR token applied to bonus\\n     * @param amount number of tokens or shares to unstake\\n     * @param total number of tokens or shares in overall pool\\n     * @param ratio usage ratio from 0 to 1\\n     * @return multiplier value\\n     */\\n    function gysrBonus(\\n        uint256 gysr,\\n        uint256 amount,\\n        uint256 total,\\n        uint256 ratio\\n    ) internal pure returns (uint256) {\\n        if (amount == 0) {\\n            return 0;\\n        }\\n        if (total == 0) {\\n            return 0;\\n        }\\n        if (gysr == 0) {\\n            return 10**DECIMALS;\\n        }\\n\\n        // scale GYSR amount with respect to proportion\\n        uint256 portion = (GYSR_PROPORTION * total) / 10**DECIMALS;\\n        if (amount > portion) {\\n            gysr = (gysr * portion) / amount;\\n        }\\n\\n        // 1 + gysr / (0.01 + ratio)\\n        uint256 x = 2**64 + (2**64 * gysr) / (10**(DECIMALS - 2) + ratio);\\n\\n        return\\n            10**DECIMALS +\\n            (uint256(int256(int128(uint128(x)).logbase10())) * 10**DECIMALS) /\\n            2**64;\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/MathUtils.sol\": {\r\n      \"content\": \"/*\\nMathUtils\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: BSD-4-Clause\\n*/\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Math utilities\\n *\\n * @notice this library implements various logarithmic math utilies which support\\n * other contracts and specifically the GYSR multiplier calculation\\n *\\n * @dev h/t https://github.com/abdk-consulting/abdk-libraries-solidity\\n */\\nlibrary MathUtils {\\n    /**\\n     * @notice calculate binary logarithm of x\\n     *\\n     * @param x signed 64.64-bit fixed point number, require x > 0\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function logbase2(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x > 0);\\n\\n            int256 msb = 0;\\n            int256 xc = x;\\n            if (xc >= 0x10000000000000000) {\\n                xc >>= 64;\\n                msb += 64;\\n            }\\n            if (xc >= 0x100000000) {\\n                xc >>= 32;\\n                msb += 32;\\n            }\\n            if (xc >= 0x10000) {\\n                xc >>= 16;\\n                msb += 16;\\n            }\\n            if (xc >= 0x100) {\\n                xc >>= 8;\\n                msb += 8;\\n            }\\n            if (xc >= 0x10) {\\n                xc >>= 4;\\n                msb += 4;\\n            }\\n            if (xc >= 0x4) {\\n                xc >>= 2;\\n                msb += 2;\\n            }\\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\\n\\n            int256 result = (msb - 64) << 64;\\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n                ux *= ux;\\n                uint256 b = ux >> 255;\\n                ux >>= 127 + b;\\n                result += bit * int256(b);\\n            }\\n\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * @notice calculate natural logarithm of x\\n     * @dev magic constant comes from ln(2) * 2^128 -> hex\\n     * @param x signed 64.64-bit fixed point number, require x > 0\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function ln(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x > 0);\\n\\n            return\\n                int128(\\n                    int256(\\n                        (uint256(int256(logbase2(x))) *\\n                            0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128\\n                    )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @notice calculate logarithm base 10 of x\\n     * @dev magic constant comes from log10(2) * 2^128 -> hex\\n     * @param x signed 64.64-bit fixed point number, require x > 0\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function logbase10(int128 x) internal pure returns (int128) {\\n        require(x > 0);\\n\\n        return\\n            int128(\\n                int256(\\n                    (uint256(int256(logbase2(x))) *\\n                        0x4d104d427de7fce20a6e420e02236748) >> 128\\n                )\\n            );\\n    }\\n\\n    // wrapper functions to allow testing\\n    function testlogbase2(int128 x) public pure returns (int128) {\\n        return logbase2(x);\\n    }\\n\\n    function testlogbase10(int128 x) public pure returns (int128) {\\n        return logbase10(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/OwnerController.sol\": {\r\n      \"content\": \"/*\\nOwnerController\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Owner controller\\n *\\n * @notice this base contract implements an owner-controller access model.\\n *\\n * @dev the contract is an adapted version of the OpenZeppelin Ownable contract.\\n * It allows the owner to designate an additional account as the controller to\\n * perform restricted operations.\\n *\\n * Other changes include supporting role verification with a require method\\n * in addition to the modifier option, and removing some unneeded functionality.\\n *\\n * Original contract here:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n */\\ncontract OwnerController {\\n    address private _owner;\\n    address private _controller;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    event ControlTransferred(\\n        address indexed previousController,\\n        address indexed newController\\n    );\\n\\n    constructor() {\\n        _owner = msg.sender;\\n        _controller = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n        emit ControlTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current controller.\\n     */\\n    function controller() public view returns (address) {\\n        return _controller;\\n    }\\n\\n    /**\\n     * @dev Modifier that throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"oc1\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier that throws if called by any account other than the controller.\\n     */\\n    modifier onlyController() {\\n        require(_controller == msg.sender, \\\"oc2\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    function requireOwner() internal view {\\n        require(_owner == msg.sender, \\\"oc1\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the controller.\\n     */\\n    function requireController() internal view {\\n        require(_controller == msg.sender, \\\"oc2\\\");\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`). This can\\n     * include renouncing ownership by transferring to the zero address.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual {\\n        requireOwner();\\n        require(newOwner != address(0), \\\"oc3\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a new account (`newController`).\\n     * Can only be called by the owner.\\n     */\\n    function transferControl(address newController) public virtual {\\n        requireOwner();\\n        require(newController != address(0), \\\"oc4\\\");\\n        emit ControlTransferred(_controller, newController);\\n        _controller = newController;\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/info/ERC20CompetitiveRewardModuleInfo.sol\": {\r\n      \"content\": \"/*\\nERC20CompetitiveRewardModuleInfo\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport \\\"../interfaces/IRewardModule.sol\\\";\\nimport \\\"../ERC20CompetitiveRewardModule.sol\\\";\\nimport \\\"../GysrUtils.sol\\\";\\n\\n/**\\n * @title ERC20 competitive reward module info library\\n *\\n * @notice this library provides read-only convenience functions to query\\n * additional information about the ERC20CompetitiveRewardModule contract.\\n */\\nlibrary ERC20CompetitiveRewardModuleInfo {\\n    using GysrUtils for uint256;\\n\\n    /**\\n     * @notice convenience function to get token metadata in a single call\\n     * @param module address of reward module\\n     * @return address\\n     * @return name\\n     * @return symbol\\n     * @return decimals\\n     */\\n    function token(address module)\\n        public\\n        view\\n        returns (\\n            address,\\n            string memory,\\n            string memory,\\n            uint8\\n        )\\n    {\\n        IRewardModule m = IRewardModule(module);\\n        IERC20Metadata tkn = IERC20Metadata(m.tokens()[0]);\\n        return (address(tkn), tkn.name(), tkn.symbol(), tkn.decimals());\\n    }\\n\\n    /**\\n     * @notice preview estimated rewards\\n     * @param module address of reward module\\n     * @param addr account address of interest for preview\\n     * @param shares number of shares that would be unstaked\\n     * @param gysr number of GYSR tokens that would be applied\\n     * @return estimated reward\\n     * @return estimated time multiplier\\n     * @return estimated gysr multiplier\\n     */\\n    function rewards(\\n        address module,\\n        address addr,\\n        uint256 shares,\\n        uint256 gysr\\n    )\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        ERC20CompetitiveRewardModule m = ERC20CompetitiveRewardModule(module);\\n\\n        // get associated share seconds\\n        uint256 rawShareSeconds;\\n        uint256 bonusShareSeconds;\\n        (rawShareSeconds, bonusShareSeconds) = userShareSeconds(\\n            module,\\n            addr,\\n            shares\\n        );\\n        if (rawShareSeconds == 0) {\\n            return (0, 0, 0);\\n        }\\n\\n        uint256 timeBonus = (bonusShareSeconds * 1e18) / rawShareSeconds;\\n\\n        // apply gysr bonus\\n        uint256 gysrBonus =\\n            gysr.gysrBonus(shares, m.totalStakingShares(), m.usage());\\n        bonusShareSeconds = (gysrBonus * bonusShareSeconds) / 1e18;\\n\\n        // compute rewards based on expected updates\\n        uint256 reward =\\n            (unlocked(module) * bonusShareSeconds) /\\n                (totalShareSeconds(module) +\\n                    bonusShareSeconds -\\n                    rawShareSeconds);\\n\\n        return (reward, timeBonus, gysrBonus);\\n    }\\n\\n    /**\\n     * @notice compute effective unlocked rewards\\n     * @param module address of reward module\\n     * @return estimated current unlocked rewards\\n     */\\n    function unlocked(address module) public view returns (uint256) {\\n        ERC20CompetitiveRewardModule m = ERC20CompetitiveRewardModule(module);\\n\\n        // compute expected updates to global totals\\n        uint256 deltaUnlocked;\\n        address tkn = m.tokens()[0];\\n        uint256 totalLockedShares = m.lockedShares(tkn);\\n        if (totalLockedShares != 0) {\\n            uint256 sharesToUnlock;\\n            for (uint256 i = 0; i < m.fundingCount(tkn); i++) {\\n                sharesToUnlock = sharesToUnlock + m.unlockable(tkn, i);\\n            }\\n            deltaUnlocked =\\n                (sharesToUnlock * m.totalLocked()) /\\n                totalLockedShares;\\n        }\\n        return m.totalUnlocked() + deltaUnlocked;\\n    }\\n\\n    /**\\n     * @notice compute user share seconds for given number of shares\\n     * @param module module contract address\\n     * @param addr user address\\n     * @param shares number of shares\\n     * @return raw share seconds\\n     * @return time bonus share seconds\\n     */\\n    function userShareSeconds(\\n        address module,\\n        address addr,\\n        uint256 shares\\n    ) public view returns (uint256, uint256) {\\n        require(shares > 0, \\\"crmi1\\\");\\n\\n        ERC20CompetitiveRewardModule m = ERC20CompetitiveRewardModule(module);\\n\\n        uint256 rawShareSeconds;\\n        uint256 timeBonusShareSeconds;\\n\\n        // compute first-in-last-out, time bonus weighted, share seconds\\n        uint256 i = m.stakeCount(addr);\\n        while (shares > 0) {\\n            require(i > 0, \\\"crmi2\\\");\\n            i -= 1;\\n            uint256 s;\\n            uint256 time;\\n            (s, time) = m.stakes(addr, i);\\n            time = block.timestamp - time;\\n\\n            // only redeem partial stake if more shares left than needed to burn\\n            s = s < shares ? s : shares;\\n\\n            rawShareSeconds += (s * time);\\n            timeBonusShareSeconds += ((s * time * m.timeBonus(time)) / 1e18);\\n            shares -= s;\\n        }\\n        return (rawShareSeconds, timeBonusShareSeconds);\\n    }\\n\\n    /**\\n     * @notice compute total expected share seconds for a rewards module\\n     * @param module address for reward module\\n     * @return expected total shares seconds\\n     */\\n    function totalShareSeconds(address module) public view returns (uint256) {\\n        ERC20CompetitiveRewardModule m = ERC20CompetitiveRewardModule(module);\\n\\n        return\\n            m.totalStakingShareSeconds() +\\n            (block.timestamp - m.lastUpdated()) *\\n            m.totalStakingShares();\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/interfaces/IEvents.sol\": {\r\n      \"content\": \"/*\\nIEvents\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n */\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title GYSR event system\\n *\\n * @notice common interface to define GYSR event system\\n */\\ninterface IEvents {\\n    // staking\\n    event Staked(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n    event Unstaked(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n    event Claimed(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n\\n    // rewards\\n    event RewardsDistributed(\\n        address indexed user,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares\\n    );\\n    event RewardsFunded(\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n    event RewardsUnlocked(address indexed token, uint256 shares);\\n    event RewardsExpired(\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    // gysr\\n    event GysrSpent(address indexed user, uint256 amount);\\n    event GysrVested(address indexed user, uint256 amount);\\n    event GysrWithdrawn(uint256 amount);\\n}\\n\"\r\n    },\r\n    \"/home/devin/gysr/core-private/contracts/interfaces/IRewardModule.sol\": {\r\n      \"content\": \"/*\\nIRewardModule\\n\\nhttps://github.com/gysr-io/core\\n\\nSPDX-License-Identifier: MIT\\n*/\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IEvents.sol\\\";\\n\\nimport \\\"../OwnerController.sol\\\";\\n\\n/**\\n * @title Reward module interface\\n *\\n * @notice this contract defines the common interface that any reward module\\n * must implement to be compatible with the modular Pool architecture.\\n */\\nabstract contract IRewardModule is OwnerController, IEvents {\\n    // constants\\n    uint256 public constant DECIMALS = 18;\\n\\n    /**\\n     * @return array of reward tokens\\n     */\\n    function tokens() external view virtual returns (address[] memory);\\n\\n    /**\\n     * @return array of reward token balances\\n     */\\n    function balances() external view virtual returns (uint256[] memory);\\n\\n    /**\\n     * @return GYSR usage ratio for reward module\\n     */\\n    function usage() external view virtual returns (uint256);\\n\\n    /**\\n     * @return address of module factory\\n     */\\n    function factory() external view virtual returns (address);\\n\\n    /**\\n     * @notice perform any necessary accounting for new stake\\n     * @param account address of staking account\\n     * @param user address of user\\n     * @param shares number of new shares minted\\n     * @param data addtional data\\n     * @return amount of gysr spent\\n     * @return amount of gysr vested\\n     */\\n    function stake(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) external virtual returns (uint256, uint256);\\n\\n    /**\\n     * @notice reward user and perform any necessary accounting for unstake\\n     * @param account address of staking account\\n     * @param user address of user\\n     * @param shares number of shares burned\\n     * @param data additional data\\n     * @return amount of gysr spent\\n     * @return amount of gysr vested\\n     */\\n    function unstake(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) external virtual returns (uint256, uint256);\\n\\n    /**\\n     * @notice reward user and perform and necessary accounting for existing stake\\n     * @param account address of staking account\\n     * @param user address of user\\n     * @param shares number of shares being claimed against\\n     * @param data addtional data\\n     * @return amount of gysr spent\\n     * @return amount of gysr vested\\n     */\\n    function claim(\\n        address account,\\n        address user,\\n        uint256 shares,\\n        bytes calldata data\\n    ) external virtual returns (uint256, uint256);\\n\\n    /**\\n     * @notice method called by anyone to update accounting\\n     * @param user address of user for update\\n     * @dev will only be called ad hoc and should not contain essential logic\\n     */\\n    function update(address user) external virtual;\\n\\n    /**\\n     * @notice method called by owner to clean up and perform additional accounting\\n     * @dev will only be called ad hoc and should not contain any essential logic\\n     */\\n    function clean() external virtual;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gysr\",\"type\":\"uint256\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"totalShareSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"unlocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"userShareSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ERC20CompetitiveRewardModuleInfo","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}