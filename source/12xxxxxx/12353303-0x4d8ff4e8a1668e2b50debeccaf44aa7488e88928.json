{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GNU AGPLv3\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ILookRevTree {\r\n    function addLeafToOpenBranch(uint256 genesisBranch, uint256 tokenID) external returns (uint256);\r\n    function addLeavesToOpenBranches(uint256[] calldata tokenIDs) external returns (uint256);\r\n    function getTokenPubID(uint256 tokenID) external view returns (string memory);\r\n    function updateNFTTokenPubID(uint256 tokenID, string calldata pubID) external;\r\n}\r\n\r\ninterface LookRevLeafNFT {\r\n    function getNFTTokenRecipient(uint256 tokenID) external view returns (address);\r\n}\r\n\r\ninterface INextTree {\r\n    function migrateTokens(uint256 branch, uint256[] calldata tokenIDs, address leafNFT) external;\r\n}\r\n\r\n\r\n// File: node_modules\\@openzeppelin\\contracts\\math\\SafeMath.sol\r\n\r\n/**\r\n * @dev Patched. Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks. Patched.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a && c >= b, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n                \r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n/// LookRevTree registry\r\ncontract LookRevTree is\r\n    ILookRevTree\r\n    {\r\n    struct GenesisBranch {\r\n        uint256 id;\r\n        string name;\r\n        uint256 maxLevel;\r\n        uint256 openBranch;\r\n        uint256 leavesCount;\r\n        uint256 baseValue;\r\n        uint8 state;\r\n        uint256 harvestTime;\r\n        string uri;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    /// Branch structure\r\n    struct Branch {\r\n        uint256 id;\r\n        uint256 level;\r\n        uint256 genesisBranch;\r\n        uint256 availableLeaves;\r\n        uint256 createdAt;\r\n    }\r\n    \r\n    /// Leaf structure\r\n    struct Leaf {\r\n        uint256 id;\r\n        uint256 branchId;\r\n        uint256 tokenID;\r\n        uint256 createdAt;\r\n    }\r\n        \r\n    /// Genesis branches\r\n    mapping(uint256 => GenesisBranch) public genesisBranches;\r\n    /// Mapping branch id to branches\r\n    mapping(uint256 => Branch) public branches;\r\n    /// Mapping genesisBranchID => level => brancheIDs\r\n    mapping(uint256 => mapping(uint256 => uint256[])) public branchesAtLevel;\r\n\r\n    /// Mapping leafID to leaves\r\n    mapping(uint256 => Leaf) public leaves;\r\n    /// Mapping tokenID => leafID\r\n    mapping(uint256 => uint256) public tokenIDToLeafID;\r\n\r\n    mapping(uint256 => string) private tokenIDToPubID;\r\n        \r\n    /// Branch operators\r\n    /// Mapping genesisBranchID => operator address => approval\r\n    mapping(uint256 => mapping(address => bool)) public operators;\r\n    \r\n    /// Index of next genesis branch\r\n    uint256 public nextGenesisBranchId = 1;\r\n    /// Index of next branch\r\n    uint256 public nextBranchId = 1;\r\n    /// Index of next leaf\r\n    uint256 public nextLeafId = 1;\r\n    /// Average leaf cost, set with initial value\r\n    uint256 public averageLeafCost = 5 * 10 ** 16;\r\n    /// Maximum level of the tree, set with initial value\r\n    uint256 public treeMaxLevel = 1;\r\n    /// Start time\r\n    uint256 public START_TIME;\r\n    \r\n    /// Maximum number of leaves on a branch\r\n    uint256 constant public MAX_SUPPLY = 10;\r\n\r\n    /// Minimum base value of a leafNFT is 0.05 ETH\r\n    uint256 public MIN_BASE_VALUE = 5 * 10 ** 16;\r\n    /// Side branches count\r\n    uint256 public BRANCH_UNIT = 2;\r\n        \r\n    /// Initial first harvest time is 100 days after the branch vest day\r\n    uint256 constant public FIRST_HARVEST_TIME = (86400 * 100);\r\n\r\n    uint256 constant public HARVEST_START_COUNT = 1000;\r\n\r\n    string public baseURI = \"https://lookrev.com/branch/\";\r\n    \r\n    // State 0 = OPEN, 1 = PAUSE, 2 = STOP\r\n    uint8 public treeStatus;\r\n    string public statusInfo;\r\n\r\n    /// Address for tree upgrade\r\n    address public nextTree;\r\n    /// LookRevLeafNFT ERC721 contract address\r\n    address public lrLeaf;\r\n    address[] private leafVersions;\r\n\r\n    address private admin;\r\n    address private ceo;\r\n    address private cfo;\r\n\r\n    /// @dev Emitted when creates genesis branch\r\n    event GenesisBranchCreated(\r\n        uint256 indexed id,\r\n        string indexed name,\r\n        uint256 indexed firstAvailableBranch,\r\n        uint256 count\r\n    );\r\n    \r\n    /// @dev Emitted when creates branch\r\n    event BranchCreated(\r\n        uint256 indexed id,\r\n        uint256 indexed genesisBranch,\r\n        uint256 indexed level\r\n    );\r\n        \r\n    /// @dev Emitted when adds new leaves\r\n    event AddedLeaves(\r\n        uint256 indexed branchID,\r\n        uint256 indexed leafID,\r\n        uint256 indexed tokenID,\r\n        uint256 count\r\n    );\r\n        \r\n    /// @dev Emitted when harvest time of a branch is scheduled\r\n    event HarvestTimeScheduled(\r\n        uint256 indexed genesisBranchID,\r\n        uint256 indexed openBranchID,\r\n        uint256 leavesCount,\r\n        uint256 indexed harvestTime\r\n    );\r\n\r\n    /// @dev Emitted when enables or removes operator of a branch\r\n    event OperatorUpdated(\r\n        uint256 indexed branchID,\r\n        address indexed operator,\r\n        bool indexed approved\r\n    );\r\n    \r\n    /// @dev Emitted when updates contract\r\n    event VersionUpdated(\r\n        string indexed str,\r\n        address indexed newaddress\r\n    );\r\n\r\n    /// @dev Emitted when updates role\r\n    event RoleUpdated(\r\n        string indexed str,\r\n        address indexed newaddress\r\n    );\r\n\r\n    /// Constructor\r\n    constructor() {\r\n        admin = msg.sender;\r\n        treeStatus = 0;\r\n    }\r\n\r\n    /// Create genesis branches\r\n    function createGenesisBranch(string[] calldata _names) public {\r\n        require(msg.sender == admin, \"LookRevTree: Not authorized\");\r\n        require(treeStatus == 0, \"LookRevTree: Tree is currently not OPEN.\");\r\n        for (uint256 i = 0; i < _names.length; i++) {\r\n            string memory _n = _names[i];\r\n            genesisBranches[nextGenesisBranchId] = GenesisBranch(nextGenesisBranchId, _n, 1, nextBranchId, 0, MIN_BASE_VALUE, 0, 0, string(abi.encodePacked(baseURI, Strings.toString(nextGenesisBranchId))), block.timestamp);\r\n            // Create a level 1 branch\r\n            branches[nextBranchId] = Branch(nextBranchId, 1, nextGenesisBranchId, MAX_SUPPLY, block.timestamp);\r\n            branchesAtLevel[nextGenesisBranchId][1].push(nextBranchId);\r\n            nextGenesisBranchId += 1;\r\n            nextBranchId += 1;\r\n        }\r\n        emit GenesisBranchCreated(nextGenesisBranchId - 1, _names[0], nextBranchId - 1, _names.length);\r\n    }\r\n    \r\n    /// Creating a branch from the genesis branch\r\n    /// @param branch BranchID of the genesis branch\r\n    function _createBranch(uint256 branch) internal {\r\n        require(genesisBranches[branch].state == 0, \"LookRevTree: Branch is not OPEN\");\r\n        uint256 _maxLevel = genesisBranches[branch].maxLevel;\r\n        uint256 _count = branchesAtLevel[branch][_maxLevel].length;\r\n        if (_count < _maxLevel * BRANCH_UNIT) {\r\n            _createNewBranch(branch, _maxLevel);\r\n        } else {\r\n            genesisBranches[branch].maxLevel += 1;\r\n            _createNewBranch(branch, _maxLevel + 1);\r\n        }\r\n    }\r\n    \r\n    /// Creating a new branch from the genesis branch\r\n    /// @dev Adding a subbranch increase the baseValue of the genesis branch\r\n    /// @param branch BranchID of the genesis branch\r\n    function _createNewBranch(uint256 branch, uint256 level) internal {\r\n        require(treeStatus == 0, \"LookRevTree: Tree is currently not OPEN.\");\r\n        branches[nextBranchId] = Branch(nextBranchId, level, branch, MAX_SUPPLY, block.timestamp);\r\n        branchesAtLevel[branch][level].push(nextBranchId);\r\n\r\n        /// increase the base value of branch when adding in subBranch\r\n        genesisBranches[branch].baseValue = genesisBranches[branch].baseValue * 102 / 100;\r\n        emit BranchCreated(nextBranchId, branch, level);\r\n        nextBranchId += 1;\r\n        // update treeMaxLevel of the tree\r\n        if (level > treeMaxLevel) {\r\n            treeMaxLevel = level;\r\n        }\r\n    }\r\n        \r\n    /// Get average cost of leaf on the tree\r\n    function _getAverageLeafCost() internal returns (uint256) {\r\n        if (nextGenesisBranchId < 3) {\r\n            averageLeafCost = genesisBranches[1].baseValue;\r\n            return averageLeafCost;\r\n        }\r\n        uint256 _sum = 0;\r\n        for (uint256 i = 1; i < nextGenesisBranchId; i++) {\r\n            _sum = SafeMath.add(_sum, genesisBranches[i].baseValue);\r\n        }\r\n        averageLeafCost = SafeMath.div(_sum, nextGenesisBranchId - 1);\r\n        return averageLeafCost;\r\n    }\r\n\r\n    /// Add new leaf to an open branch, called by the LeafNFT contract\r\n    /// @dev This function may grow new branch if current branch is full.\r\n    /// @dev Do not use manually except for maintenance purpose.\r\n    /// @param genesisBranch BranchID of the genesis branch\r\n    /// @param tokenID LookRevLeafNFT ERC721 token ID\r\n    /// @return uint256 updated average leaf cost\r\n    function addLeafToOpenBranch(uint256 genesisBranch, uint256 tokenID) external override returns (uint256) {\r\n        require(msg.sender == admin || msg.sender == lrLeaf, \"LookRevTree: Not authorized\");\r\n        _addLeafToOpenBranch(genesisBranch, tokenID);\r\n        return _getAverageLeafCost();\r\n    }\r\n\r\n    function _addLeafToOpenBranch(uint256 genesisBranch, uint256 tokenID) internal {\r\n        require(genesisBranch > 0, \"LookRevTree: Branch index is out of range\");\r\n        if (genesisBranch >= nextGenesisBranchId) {\r\n            genesisBranch = nextGenesisBranchId - 1;\r\n        }\r\n        require(genesisBranches[genesisBranch].state == 0, \"LookRevTree: Branch is not OPEN\");\r\n        uint256 _b = genesisBranches[genesisBranch].openBranch;\r\n        if (branches[_b].availableLeaves < 1) {\r\n            _updateBranchStatus(_b);\r\n        }\r\n        _addLeaf(genesisBranches[genesisBranch].openBranch, tokenID);\r\n        emit AddedLeaves(genesisBranch, nextLeafId - 1, tokenID, 1);\r\n    }\r\n\r\n    /// @dev Get branch that has minimum leaves, for the balance of the tree\r\n    function _getMinLeavesBranch() internal view returns (uint256) {\r\n        uint256 minCount = 10000;\r\n        uint256 b = nextBranchId - 1;\r\n        for (uint256 i = 1; i < nextGenesisBranchId; i++) {\r\n            if (genesisBranches[i].state == 0 && genesisBranches[i].leavesCount < minCount) {\r\n                minCount = genesisBranches[i].leavesCount;\r\n                b = genesisBranches[i].openBranch;\r\n            }\r\n        }\r\n        return b;\r\n    }\r\n\r\n    /// @dev Add leaves on open branches, growing a balanced tree\r\n    /// Can add multiple leaves.\r\n    /// @dev This function is going to add new leaves on the open branches on the tree\r\n    /// @dev Do not use manually except for maintenance purpose.\r\n    /// @param tokenIDs to add to the branches\r\n    function addLeavesToOpenBranches(uint256[] calldata tokenIDs) external override returns (uint256) {\r\n        require(msg.sender == admin || msg.sender == lrLeaf, \"LookRevTree: Not authorized.\");\r\n        require(tokenIDs.length > 0, \"LookRevTree: tokenIDs can not be empty\");\r\n        require(tokenIDToLeafID[tokenIDs[0]] == 0, \"LookRevTree: TokenID already registered\");\r\n        \r\n        uint256 _branchid = _getMinLeavesBranch();\r\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\r\n            if (branches[_branchid].availableLeaves < 1) {\r\n                _updateBranchStatus(_branchid);\r\n                _branchid = _getMinLeavesBranch();\r\n            }\r\n            _addLeaf(_branchid, tokenIDs[i]);\r\n        }\r\n        emit AddedLeaves(_branchid, nextLeafId - 1, tokenIDs[0], tokenIDs.length);\r\n        return _getAverageLeafCost();\r\n    }\r\n    \r\n    /// @dev Called internally. Precheck to ensure the branch is open and available for new leaves\r\n    /// @param branch BranchID of the subbranch\r\n    /// @param tokenID of the added leaf\r\n    function _addLeaf(uint256 branch, uint256 tokenID) internal {\r\n        require(treeStatus == 0, \"LookRevTree: Tree is currently not OPEN.\");\r\n        require(branch < nextBranchId && branch > 0, \"LookRevTree: Branch index is out of range\");\r\n        require(tokenIDToLeafID[tokenID] == 0, \"LookRevTree: TokenID already registered\");\r\n        /// prevent reentry\r\n        tokenIDToLeafID[tokenID] = nextLeafId;\r\n        \r\n        leaves[nextLeafId] = Leaf(nextLeafId, branch, tokenID, block.timestamp);\r\n        genesisBranches[branches[branch].genesisBranch].leavesCount += 1;\r\n        branches[branch].availableLeaves -= 1;\r\n        nextLeafId += 1;\r\n    }\r\n        \r\n    /// @dev update the subbranch status, usually when the subbranch is full\r\n    function _updateBranchStatus(uint256 subbranch) internal {\r\n        uint256 _g = branches[subbranch].genesisBranch;\r\n        if (genesisBranches[_g].leavesCount >= HARVEST_START_COUNT) {\r\n            _setFirstHarvestTime(_g);\r\n        }\r\n        _createBranch(_g);\r\n        genesisBranches[_g].openBranch = nextBranchId - 1;\r\n    }\r\n\r\n    ///=================================\r\n    /// Methods for leaf owners\r\n    ///=================================\r\n        \r\n    function getTokenPubID(uint256 tokenID) external view override returns (string memory) {\r\n        address _owner = LookRevLeafNFT(lrLeaf).getNFTTokenRecipient(tokenID);\r\n        require(_owner == msg.sender || msg.sender == admin, \"LookRevTree: Require owner of the leafNFT\");\r\n        return tokenIDToPubID[tokenID];\r\n    }\r\n    \r\n    /// @dev PubID can only be updated before leaf migration and is preserved with the tree\r\n    function updateNFTTokenPubID(uint256 tokenID, string calldata pubID) external override {\r\n        require(tokenIDToLeafID[tokenID] > 0, \"LookRevTree: tokenID not found\");\r\n        require(bytes(pubID).length > 0, \"LookRevTree: pubID can not be empty\");\r\n        address _owner = LookRevLeafNFT(lrLeaf).getNFTTokenRecipient(tokenID);\r\n        require(_owner == msg.sender || msg.sender == admin, \"LookRevTree: Require owner of the leafNFT\");\r\n        tokenIDToPubID[tokenID] = pubID;\r\n    }\r\n        \r\n    function updateNFTTokenPubIDs(uint256[] calldata tokenIDs, string[] calldata pubIDs) public {\r\n        require(msg.sender == admin, \"LookRevTree: Require admin\");\r\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\r\n            tokenIDToPubID[tokenIDs[i]] = pubIDs[i];\r\n        }\r\n    }\r\n\r\n    ///==========================================\r\n    /// Maintenance methods for branch operators\r\n    ///==========================================\r\n        \r\n    /// Set the first harvest time for a genesis branch\r\n    /// @dev The first harvest time is 100 days after the current block time\r\n    /// @param branch branchID of the genesis branch\r\n    function _setFirstHarvestTime(uint256 branch) internal {\r\n        if (genesisBranches[branch].harvestTime != 0) {\r\n            // already set the first harvest time\r\n            return;\r\n        }\r\n        genesisBranches[branch].harvestTime = block.timestamp + FIRST_HARVEST_TIME;\r\n        emit HarvestTimeScheduled(branch, genesisBranches[branch].openBranch, genesisBranches[branch].leavesCount, genesisBranches[branch].harvestTime);\r\n    }\r\n    \r\n    /// Update genesis branch information\r\n    /// @param branch BranchID of the genesis branch\r\n    /// @param newName New name of the genesis branch\r\n    /// @param newURI New uri of the genesis branch\r\n    /// @param newState New state of the genesis branch 0 = OPEN, 1 = PAUSE, 2 = STOP\r\n    /// @param timeToHarvest Havest time adjusted with delay from the current block time\r\n    /// Require admin or branch operator\r\n    function updateBranchInfo(uint256 branch, string calldata newName, string calldata newURI, uint8 newState, uint256 timeToHarvest) public {\r\n        require(msg.sender == admin || operators[branch][msg.sender] == true, \"LookRevTree: Not authorized\");\r\n        require(branch < nextGenesisBranchId && branch > 0, \"LookRevTree: Branch index is out of range\");\r\n        genesisBranches[branch].name = newName;\r\n        genesisBranches[branch].uri = newURI;\r\n        genesisBranches[branch].state = newState;\r\n        genesisBranches[branch].harvestTime = block.timestamp + timeToHarvest;\r\n    }\r\n\r\n    ///===============================\r\n    /// Maintenance methods for admin\r\n    ///===============================\r\n    \r\n    function updateTreeStatus(string calldata str, uint8 _to) public {\r\n        require(msg.sender == admin, \"LookRevTree: Not authorized\");\r\n        statusInfo = str;\r\n        treeStatus = _to;\r\n    }\r\n    \r\n    /// Add or remove operator for a genesis branch\r\n    function updateOperator(uint256[] calldata branch, address operator, bool approved) public {\r\n        require(msg.sender == admin, \"LookRevTree: Not authorized\");\r\n        require(operator != address(0), \"LookRevTree: operator needs valid address\");\r\n        for (uint256 i = 0; i < branch.length; i++) {\r\n            operators[branch[i]][operator] = approved;\r\n        }\r\n        emit OperatorUpdated(branch[0], operator, approved);\r\n    }\r\n\r\n    /// Adjust base value\r\n    /// @dev Can only increase base value of leaf when it is out of sync from market value\r\n    /// @dev Need to wait at least 100 days between updates\r\n    /// @param value updated baseValue for new genesis branches\r\n    function adjustBaseValue(uint256 value) public {\r\n        require(msg.sender == admin, \"LookRevTree: Not authorized\");\r\n        require(value > MIN_BASE_VALUE, \"LookRevTree: Can only increase base value\");\r\n        require(block.timestamp >= START_TIME + 100 days, \"LooksCoin: Wait for 100 days after last update\");\r\n        MIN_BASE_VALUE = value;\r\n        START_TIME = block.timestamp;\r\n    }\r\n\r\n    function updateLeafVersion(address _leaf) public {\r\n        require(msg.sender == admin, \"LookRevTree: Not authorized\");\r\n        lrLeaf = _leaf;\r\n        leafVersions.push(_leaf);\r\n        emit VersionUpdated(\"Leaf Version Updated\", _leaf);\r\n    }\r\n    \r\n    function getLeafVersions() public view returns (address[] memory) {\r\n        require(msg.sender == admin, \"LookRevTree: Not authorized\");\r\n        return leafVersions;\r\n    }\r\n    \r\n    function updateNextContract(address _new) public {\r\n        require(msg.sender == admin, \"LookRevTree: Not authorized\");\r\n        nextTree = _new;\r\n    }\r\n\r\n    function updateRole(uint256 _role, address _new) public {\r\n        require(msg.sender == admin || msg.sender == ceo || msg.sender == cfo, \"LookRevTree: Not authorized\");\r\n        if (_role == 1) {\r\n            admin = _new;\r\n            emit RoleUpdated(\"admin\", _new);\r\n        } else if (_role == 2) {\r\n            ceo = _new;\r\n            emit RoleUpdated(\"ceo\", _new);\r\n        } else if (_role == 3) {\r\n            cfo = _new;\r\n            emit RoleUpdated(\"cfo\", _new);\r\n        }\r\n    }\r\n\r\n    function getRoles() public view returns (address[] memory) {\r\n        require(msg.sender == admin || msg.sender == ceo || msg.sender == cfo, \"LookRevTree: Not authorized\");\r\n        address[] memory _roles = new address[](3);\r\n        _roles[0] = admin;\r\n        _roles[1] = ceo;\r\n        _roles[2] = cfo;\r\n        return _roles;\r\n    }\r\n\r\n    function removeLeaf(uint256 leafID) public {\r\n        require(msg.sender == admin, \"LookRevTree: Not authorized\");\r\n        _removeLeaf(leafID);\r\n    }\r\n\r\n    /// @dev PubID is preserved with the tree since it is not affected by migration\r\n    function _removeLeaf(uint256 leafID) internal {\r\n        if (leafID <= 0 || leafID >= nextLeafId) {\r\n            return;\r\n        }\r\n        uint256 _tokenID = leaves[leafID].tokenID;\r\n        if (_tokenID < 1) {\r\n            return;\r\n        }\r\n        tokenIDToLeafID[_tokenID] = 0;\r\n        delete leaves[leafID];\r\n    }\r\n    \r\n    function migrateNFTTokens(uint256 newBranchID, uint256[] calldata tokenIDs) external {\r\n        require(msg.sender == admin, \"LookRevTree: Not authorized\");\r\n        require(nextTree != address(0), \"LookRevTree: Need to set nextTree\");\r\n        \r\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\r\n            if (tokenIDs[i] > 0) {\r\n                _removeLeaf(tokenIDToLeafID[tokenIDs[i]]);\r\n            }\r\n        }\r\n        INextTree(nextTree).migrateTokens(newBranchID, tokenIDs, lrLeaf);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"branchID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"leafID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"AddedLeaves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"genesisBranch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"BranchCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"firstAvailableBranch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"GenesisBranchCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"genesisBranchID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"openBranchID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leavesCount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"harvestTime\",\"type\":\"uint256\"}],\"name\":\"HarvestTimeScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"branchID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"OperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newaddress\",\"type\":\"address\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newaddress\",\"type\":\"address\"}],\"name\":\"VersionUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BRANCH_UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FIRST_HARVEST_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HARVEST_START_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BASE_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"START_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"genesisBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"addLeafToOpenBranch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"addLeavesToOpenBranches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"adjustBaseValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"averageLeafCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"branches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"genesisBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLeaves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"branchesAtLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_names\",\"type\":\"string[]\"}],\"name\":\"createGenesisBranch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"genesisBranches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openBranch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leavesCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseValue\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"harvestTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLeafVersions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoles\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getTokenPubID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"leaves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"branchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lrLeaf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBranchID\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"migrateNFTTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextBranchId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextGenesisBranchId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextLeafId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextTree\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leafID\",\"type\":\"uint256\"}],\"name\":\"removeLeaf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"statusInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIDToLeafID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treeMaxLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treeStatus\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"branch\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"newState\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timeToHarvest\",\"type\":\"uint256\"}],\"name\":\"updateBranchInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leaf\",\"type\":\"address\"}],\"name\":\"updateLeafVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"pubID\",\"type\":\"string\"}],\"name\":\"updateNFTTokenPubID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"pubIDs\",\"type\":\"string[]\"}],\"name\":\"updateNFTTokenPubIDs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"updateNextContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"branch\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"updateOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_role\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"updateRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_to\",\"type\":\"uint8\"}],\"name\":\"updateTreeStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LookRevTree","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e34f43ff22bc259895ef60908ebeaeb383711d4a304843ad2b2ffeb5504fb1f6"}]}