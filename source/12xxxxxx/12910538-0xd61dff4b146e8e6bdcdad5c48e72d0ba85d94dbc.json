{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/ZkSync.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeMathUInt128.sol\\\";\\nimport \\\"./SafeCast.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\nimport \\\"./Storage.sol\\\";\\nimport \\\"./Config.sol\\\";\\nimport \\\"./Events.sol\\\";\\n\\nimport \\\"./Bytes.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\nimport \\\"./UpgradeableMaster.sol\\\";\\nimport \\\"./RegenesisMultisig.sol\\\";\\nimport \\\"./AdditionalZkSync.sol\\\";\\n\\n/// @title zkSync main contract\\n/// @author Matter Labs\\ncontract ZkSync is UpgradeableMaster, Storage, Config, Events, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using SafeMathUInt128 for uint128;\\n\\n    bytes32 private constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n    /// @notice Data needed to process onchain operation from block public data.\\n    /// @notice Onchain operations is operations that need some processing on L1: Deposits, Withdrawals, ChangePubKey.\\n    /// @param ethWitness Some external data that can be needed for operation processing\\n    /// @param publicDataOffset Byte offset in public data for onchain operation\\n    struct OnchainOperationData {\\n        bytes ethWitness;\\n        uint32 publicDataOffset;\\n    }\\n\\n    /// @notice Data needed to commit new block\\n    struct CommitBlockInfo {\\n        bytes32 newStateHash;\\n        bytes publicData;\\n        uint256 timestamp;\\n        OnchainOperationData[] onchainOperations;\\n        uint32 blockNumber;\\n        uint32 feeAccount;\\n    }\\n\\n    /// @notice Data needed to execute committed and verified block\\n    /// @param commitmentsInSlot verified commitments in one slot\\n    /// @param commitmentIdx index such that commitmentsInSlot[commitmentIdx] is current block commitment\\n    struct ExecuteBlockInfo {\\n        StoredBlockInfo storedBlock;\\n        bytes[] pendingOnchainOpsPubdata;\\n    }\\n\\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\\n    struct ProofInput {\\n        uint256[] recursiveInput;\\n        uint256[] proof;\\n        uint256[] commitments;\\n        uint8[] vkIndexes;\\n        uint256[16] subproofsLimbs;\\n    }\\n\\n    // Upgrade functional\\n\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external pure override returns (uint256) {\\n        return 0;\\n    }\\n\\n    /// @notice Notification that upgrade notice period started\\n    /// @dev Can be external because Proxy contract intercepts illegal calls of this function\\n    function upgradeNoticePeriodStarted() external override {\\n        upgradeStartTimestamp = block.timestamp;\\n    }\\n\\n    /// @notice Notification that upgrade preparation status is activated\\n    /// @dev Can be external because Proxy contract intercepts illegal calls of this function\\n    function upgradePreparationStarted() external override {\\n        upgradePreparationActive = true;\\n        upgradePreparationActivationTime = block.timestamp;\\n\\n        require(block.timestamp >= upgradeStartTimestamp.add(approvedUpgradeNoticePeriod));\\n    }\\n\\n    /// @dev When upgrade is finished or canceled we must clean upgrade-related state.\\n    function clearUpgradeStatus() internal {\\n        upgradePreparationActive = false;\\n        upgradePreparationActivationTime = 0;\\n        approvedUpgradeNoticePeriod = UPGRADE_NOTICE_PERIOD;\\n        emit NoticePeriodChange(approvedUpgradeNoticePeriod);\\n        upgradeStartTimestamp = 0;\\n        for (uint256 i = 0; i < SECURITY_COUNCIL_MEMBERS_NUMBER; ++i) {\\n            securityCouncilApproves[i] = false;\\n        }\\n        numberOfApprovalsFromSecurityCouncil = 0;\\n    }\\n\\n    /// @notice Notification that upgrade canceled\\n    /// @dev Can be external because Proxy contract intercepts illegal calls of this function\\n    function upgradeCanceled() external override {\\n        clearUpgradeStatus();\\n    }\\n\\n    /// @notice Notification that upgrade finishes\\n    /// @dev Can be external because Proxy contract intercepts illegal calls of this function\\n    function upgradeFinishes() external override {\\n        clearUpgradeStatus();\\n    }\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external view override returns (bool) {\\n        return !exodusMode;\\n    }\\n\\n    /// @notice zkSync contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param initializationParameters Encoded representation of initialization parameters:\\n    /// @dev _governanceAddress The address of Governance contract\\n    /// @dev _verifierAddress The address of Verifier contract\\n    /// @dev _genesisStateHash Genesis blocks (first block) state tree root hash\\n    function initialize(bytes calldata initializationParameters) external {\\n        initializeReentrancyGuard();\\n\\n        (address _governanceAddress, address _verifierAddress, address _additionalZkSync, bytes32 _genesisStateHash) =\\n            abi.decode(initializationParameters, (address, address, address, bytes32));\\n\\n        verifier = Verifier(_verifierAddress);\\n        governance = Governance(_governanceAddress);\\n        additionalZkSync = AdditionalZkSync(_additionalZkSync);\\n\\n        StoredBlockInfo memory storedBlockZero =\\n            StoredBlockInfo(0, 0, EMPTY_STRING_KECCAK, 0, _genesisStateHash, bytes32(0));\\n        storedBlockHashes[0] = hashStoredBlockInfo(storedBlockZero);\\n        approvedUpgradeNoticePeriod = UPGRADE_NOTICE_PERIOD;\\n        emit NoticePeriodChange(approvedUpgradeNoticePeriod);\\n    }\\n\\n    /// @notice zkSync contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    // solhint-disable-next-line no-empty-blocks\\n    function upgrade(bytes calldata upgradeParameters) external nonReentrant {}\\n\\n    function cutUpgradeNoticePeriod() external {\\n        /// All functions delegated to additional contract should NOT be nonReentrant\\n        delegateAdditional();\\n    }\\n\\n    /// @notice Sends tokens\\n    /// @dev NOTE: will revert if transfer call fails or rollup balance difference (before and after transfer) is bigger than _maxAmount\\n    /// @dev This function is used to allow tokens to spend zkSync contract balance up to amount that is requested\\n    /// @param _token Token address\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @param _maxAmount Maximum possible amount of tokens to transfer to this account\\n    function _transferERC20(\\n        IERC20 _token,\\n        address _to,\\n        uint128 _amount,\\n        uint128 _maxAmount\\n    ) external returns (uint128 withdrawnAmount) {\\n        require(msg.sender == address(this), \\\"5\\\"); // wtg10 - can be called only from this contract as one \\\"external\\\" call (to revert all this function state changes if it is needed)\\n\\n        uint256 balanceBefore = _token.balanceOf(address(this));\\n        require(Utils.sendERC20(_token, _to, _amount), \\\"6\\\"); // wtg11 - ERC20 transfer fails\\n        uint256 balanceAfter = _token.balanceOf(address(this));\\n        uint256 balanceDiff = balanceBefore.sub(balanceAfter);\\n        require(balanceDiff <= _maxAmount, \\\"7\\\"); // wtg12 - rollup balance difference (before and after transfer) is bigger than _maxAmount\\n\\n        return SafeCast.toUint128(balanceDiff);\\n    }\\n\\n    /// @notice Accrues users balances from deposit priority requests in Exodus mode\\n    /// @dev WARNING: Only for Exodus mode\\n    /// @dev Canceling may take several separate transactions to be completed\\n    /// @param _n number of requests to process\\n    function cancelOutstandingDepositsForExodusMode(uint64 _n, bytes[] memory _depositsPubdata) external {\\n        /// All functions delegated to additional contract should NOT be nonReentrant\\n        delegateAdditional();\\n    }\\n\\n    /// @notice Deposit ETH to Layer 2 - transfer ether from user into contract, validate it, register deposit\\n    /// @param _zkSyncAddress The receiver Layer 2 address\\n    function depositETH(address _zkSyncAddress) external payable {\\n        require(_zkSyncAddress != SPECIAL_ACCOUNT_ADDRESS, \\\"P\\\");\\n        requireActive();\\n        registerDeposit(0, SafeCast.toUint128(msg.value), _zkSyncAddress);\\n    }\\n\\n    /// @notice Deposit ERC20 token to Layer 2 - transfer ERC20 tokens from user into contract, validate it, register deposit\\n    /// @param _token Token address\\n    /// @param _amount Token amount\\n    /// @param _zkSyncAddress Receiver Layer 2 address\\n    function depositERC20(\\n        IERC20 _token,\\n        uint104 _amount,\\n        address _zkSyncAddress\\n    ) external nonReentrant {\\n        require(_zkSyncAddress != SPECIAL_ACCOUNT_ADDRESS, \\\"P\\\");\\n        requireActive();\\n\\n        // Get token id by its address\\n        uint16 tokenId = governance.validateTokenAddress(address(_token));\\n        require(!governance.pausedTokens(tokenId), \\\"b\\\"); // token deposits are paused\\n\\n        uint256 balanceBefore = _token.balanceOf(address(this));\\n        require(Utils.transferFromERC20(_token, msg.sender, address(this), SafeCast.toUint128(_amount)), \\\"c\\\"); // token transfer failed deposit\\n        uint256 balanceAfter = _token.balanceOf(address(this));\\n        uint128 depositAmount = SafeCast.toUint128(balanceAfter.sub(balanceBefore));\\n        require(depositAmount <= MAX_DEPOSIT_AMOUNT, \\\"C\\\");\\n\\n        registerDeposit(tokenId, depositAmount, _zkSyncAddress);\\n    }\\n\\n    /// @notice Returns amount of tokens that can be withdrawn by `address` from zkSync contract\\n    /// @param _address Address of the tokens owner\\n    /// @param _token Address of token, zero address is used for ETH\\n    function getPendingBalance(address _address, address _token) public view returns (uint128) {\\n        uint16 tokenId = 0;\\n        if (_token != address(0)) {\\n            tokenId = governance.validateTokenAddress(_token);\\n        }\\n        return pendingBalances[packAddressAndTokenId(_address, tokenId)].balanceToWithdraw;\\n    }\\n\\n    /// @notice  Withdraws tokens from zkSync contract to the owner\\n    /// @param _owner Address of the tokens owner\\n    /// @param _token Address of tokens, zero address is used for ETH\\n    /// @param _amount Amount to withdraw to request.\\n    ///         NOTE: We will call ERC20.transfer(.., _amount), but if according to internal logic of ERC20 token zkSync contract\\n    ///         balance will be decreased by value more then _amount we will try to subtract this value from user pending balance\\n    function withdrawPendingBalance(\\n        address payable _owner,\\n        address _token,\\n        uint128 _amount\\n    ) external nonReentrant {\\n        if (_token == address(0)) {\\n            registerWithdrawal(0, _amount, _owner);\\n            (bool success, ) = _owner.call{value: _amount}(\\\"\\\");\\n            require(success, \\\"d\\\"); // ETH withdraw failed\\n        } else {\\n            uint16 tokenId = governance.validateTokenAddress(_token);\\n            bytes22 packedBalanceKey = packAddressAndTokenId(_owner, tokenId);\\n            uint128 balance = pendingBalances[packedBalanceKey].balanceToWithdraw;\\n            // We will allow withdrawals of `value` such that:\\n            // `value` <= user pending balance\\n            // `value` can be bigger then `_amount` requested if token takes fee from sender in addition to `_amount` requested\\n            uint128 withdrawnAmount = this._transferERC20(IERC20(_token), _owner, _amount, balance);\\n            registerWithdrawal(tokenId, withdrawnAmount, _owner);\\n        }\\n    }\\n\\n    /// @notice  Withdraws NFT from zkSync contract to the owner\\n    /// @param _tokenId Id of NFT token\\n    function withdrawPendingNFTBalance(uint32 _tokenId) external nonReentrant {\\n        Operations.WithdrawNFT memory op = pendingWithdrawnNFTs[_tokenId];\\n        require(op.creatorAddress != address(0), \\\"op\\\"); // No NFT to withdraw\\n        NFTFactory _factory = governance.getNFTFactory(op.creatorAccountId, op.creatorAddress);\\n        _factory.mintNFTFromZkSync(\\n            op.creatorAddress,\\n            op.receiver,\\n            op.creatorAccountId,\\n            op.serialId,\\n            op.contentHash,\\n            op.tokenId\\n        );\\n        // Save withdrawn nfts for future deposits\\n        withdrawnNFTs[op.tokenId] = address(_factory);\\n        emit WithdrawalNFT(op.tokenId);\\n        delete pendingWithdrawnNFTs[_tokenId];\\n    }\\n\\n    /// @notice Register full exit request - pack pubdata, add priority request\\n    /// @param _accountId Numerical id of the account\\n    /// @param _token Token address, 0 address for ether\\n    function requestFullExit(uint32 _accountId, address _token) public nonReentrant {\\n        requireActive();\\n        require(_accountId <= MAX_ACCOUNT_ID, \\\"e\\\");\\n        require(_accountId != SPECIAL_ACCOUNT_ID, \\\"v\\\"); // request full exit for nft storage account\\n\\n        uint16 tokenId;\\n        if (_token == address(0)) {\\n            tokenId = 0;\\n        } else {\\n            tokenId = governance.validateTokenAddress(_token);\\n        }\\n\\n        // Priority Queue request\\n        Operations.FullExit memory op =\\n            Operations.FullExit({\\n                accountId: _accountId,\\n                owner: msg.sender,\\n                tokenId: tokenId,\\n                amount: 0, // unknown at this point\\n                nftCreatorAccountId: uint32(0), // unknown at this point\\n                nftCreatorAddress: address(0), // unknown at this point\\n                nftSerialId: uint32(0), // unknown at this point\\n                nftContentHash: bytes32(0) // unknown at this point\\n            });\\n        bytes memory pubData = Operations.writeFullExitPubdataForPriorityQueue(op);\\n        addPriorityRequest(Operations.OpType.FullExit, pubData);\\n\\n        // User must fill storage slot of balancesToWithdraw(msg.sender, tokenId) with nonzero value\\n        // In this case operator should just overwrite this slot during confirming withdrawal\\n        bytes22 packedBalanceKey = packAddressAndTokenId(msg.sender, tokenId);\\n        pendingBalances[packedBalanceKey].gasReserveValue = FILLED_GAS_RESERVE_VALUE;\\n    }\\n\\n    /// @notice Register full exit nft request - pack pubdata, add priority request\\n    /// @param _accountId Numerical id of the account\\n    /// @param _tokenId NFT token id in zkSync network\\n    function requestFullExitNFT(uint32 _accountId, uint32 _tokenId) public nonReentrant {\\n        requireActive();\\n        require(_accountId <= MAX_ACCOUNT_ID, \\\"e\\\");\\n        require(_accountId != SPECIAL_ACCOUNT_ID, \\\"v\\\"); // request full exit nft for nft storage account\\n        require(MAX_FUNGIBLE_TOKEN_ID < _tokenId && _tokenId < SPECIAL_NFT_TOKEN_ID, \\\"T\\\"); // request full exit nft for invalid token id\\n\\n        // Priority Queue request\\n        Operations.FullExit memory op =\\n            Operations.FullExit({\\n                accountId: _accountId,\\n                owner: msg.sender,\\n                tokenId: _tokenId,\\n                amount: 0, // unknown at this point\\n                nftCreatorAccountId: uint32(0), // unknown at this point\\n                nftCreatorAddress: address(0), // unknown at this point\\n                nftSerialId: uint32(0), // unknown at this point\\n                nftContentHash: bytes32(0) // unknown at this point\\n            });\\n        bytes memory pubData = Operations.writeFullExitPubdataForPriorityQueue(op);\\n        addPriorityRequest(Operations.OpType.FullExit, pubData);\\n    }\\n\\n    /// @dev Process one block commit using previous block StoredBlockInfo,\\n    /// @dev returns new block StoredBlockInfo\\n    /// @dev NOTE: Does not change storage (except events, so we can't mark it view)\\n    function commitOneBlock(StoredBlockInfo memory _previousBlock, CommitBlockInfo memory _newBlock)\\n        internal\\n        view\\n        returns (StoredBlockInfo memory storedNewBlock)\\n    {\\n        require(_newBlock.blockNumber == _previousBlock.blockNumber + 1, \\\"f\\\"); // only commit next block\\n\\n        // Check timestamp of the new block\\n        {\\n            require(_newBlock.timestamp >= _previousBlock.timestamp, \\\"g\\\"); // Block should be after previous block\\n            bool timestampNotTooSmall = block.timestamp.sub(COMMIT_TIMESTAMP_NOT_OLDER) <= _newBlock.timestamp;\\n            bool timestampNotTooBig = _newBlock.timestamp <= block.timestamp.add(COMMIT_TIMESTAMP_APPROXIMATION_DELTA);\\n            require(timestampNotTooSmall && timestampNotTooBig, \\\"h\\\"); // New block timestamp is not valid\\n        }\\n\\n        // Check onchain operations\\n        (bytes32 pendingOnchainOpsHash, uint64 priorityReqCommitted, bytes memory onchainOpsOffsetCommitment) =\\n            collectOnchainOps(_newBlock);\\n\\n        // Create block commitment for verification proof\\n        bytes32 commitment = createBlockCommitment(_previousBlock, _newBlock, onchainOpsOffsetCommitment);\\n\\n        return\\n            StoredBlockInfo(\\n                _newBlock.blockNumber,\\n                priorityReqCommitted,\\n                pendingOnchainOpsHash,\\n                _newBlock.timestamp,\\n                _newBlock.newStateHash,\\n                commitment\\n            );\\n    }\\n\\n    /// @notice Commit block\\n    /// @notice 1. Checks onchain operations, timestamp.\\n    /// @notice 2. Store block commitments\\n    function commitBlocks(StoredBlockInfo memory _lastCommittedBlockData, CommitBlockInfo[] memory _newBlocksData)\\n        external\\n        nonReentrant\\n    {\\n        requireActive();\\n        governance.requireActiveValidator(msg.sender);\\n        // Check that we commit blocks after last committed block\\n        require(storedBlockHashes[totalBlocksCommitted] == hashStoredBlockInfo(_lastCommittedBlockData), \\\"i\\\"); // incorrect previous block data\\n\\n        for (uint32 i = 0; i < _newBlocksData.length; ++i) {\\n            _lastCommittedBlockData = commitOneBlock(_lastCommittedBlockData, _newBlocksData[i]);\\n\\n            totalCommittedPriorityRequests += _lastCommittedBlockData.priorityOperations;\\n            storedBlockHashes[_lastCommittedBlockData.blockNumber] = hashStoredBlockInfo(_lastCommittedBlockData);\\n\\n            emit BlockCommit(_lastCommittedBlockData.blockNumber);\\n        }\\n\\n        totalBlocksCommitted += uint32(_newBlocksData.length);\\n\\n        require(totalCommittedPriorityRequests <= totalOpenPriorityRequests, \\\"j\\\");\\n    }\\n\\n    /// @dev 1. Try to send token to _recipients\\n    /// @dev 2. On failure: Increment _recipients balance to withdraw.\\n    function withdrawOrStoreNFT(Operations.WithdrawNFT memory op) internal {\\n        NFTFactory _factory = governance.getNFTFactory(op.creatorAccountId, op.creatorAddress);\\n        try\\n            _factory.mintNFTFromZkSync{gas: WITHDRAWAL_NFT_GAS_LIMIT}(\\n                op.creatorAddress,\\n                op.receiver,\\n                op.creatorAccountId,\\n                op.serialId,\\n                op.contentHash,\\n                op.tokenId\\n            )\\n        {\\n            // Save withdrawn nfts for future deposits\\n            withdrawnNFTs[op.tokenId] = address(_factory);\\n            emit WithdrawalNFT(op.tokenId);\\n        } catch {\\n            pendingWithdrawnNFTs[op.tokenId] = op;\\n            emit WithdrawalNFTPending(op.tokenId);\\n        }\\n    }\\n\\n    /// @dev 1. Try to send token to _recipients\\n    /// @dev 2. On failure: Increment _recipients balance to withdraw.\\n    function withdrawOrStore(\\n        uint16 _tokenId,\\n        address _recipient,\\n        uint128 _amount\\n    ) internal {\\n        bytes22 packedBalanceKey = packAddressAndTokenId(_recipient, _tokenId);\\n\\n        bool sent = false;\\n        if (_tokenId == 0) {\\n            address payable toPayable = address(uint160(_recipient));\\n            sent = sendETHNoRevert(toPayable, _amount);\\n        } else {\\n            address tokenAddr = governance.tokenAddresses(_tokenId);\\n            // We use `_transferERC20` here to check that `ERC20` token indeed transferred `_amount`\\n            // and fail if token subtracted from zkSync balance more then `_amount` that was requested.\\n            // This can happen if token subtracts fee from sender while transferring `_amount` that was requested to transfer.\\n            try this._transferERC20{gas: WITHDRAWAL_GAS_LIMIT}(IERC20(tokenAddr), _recipient, _amount, _amount) {\\n                sent = true;\\n            } catch {\\n                sent = false;\\n            }\\n        }\\n        if (sent) {\\n            emit Withdrawal(_tokenId, _amount);\\n        } else {\\n            increaseBalanceToWithdraw(packedBalanceKey, _amount);\\n            emit WithdrawalPending(_tokenId, _amount);\\n        }\\n    }\\n\\n    /// @dev Executes one block\\n    /// @dev 1. Processes all pending operations (Send Exits, Complete priority requests)\\n    /// @dev 2. Finalizes block on Ethereum\\n    /// @dev _executedBlockIdx is index in the array of the blocks that we want to execute together\\n    function executeOneBlock(ExecuteBlockInfo memory _blockExecuteData, uint32 _executedBlockIdx) internal {\\n        // Ensure block was committed\\n        require(\\n            hashStoredBlockInfo(_blockExecuteData.storedBlock) ==\\n                storedBlockHashes[_blockExecuteData.storedBlock.blockNumber],\\n            \\\"exe10\\\" // executing block should be committed\\n        );\\n        require(_blockExecuteData.storedBlock.blockNumber == totalBlocksExecuted + _executedBlockIdx + 1, \\\"k\\\"); // Execute blocks in order\\n\\n        bytes32 pendingOnchainOpsHash = EMPTY_STRING_KECCAK;\\n        for (uint32 i = 0; i < _blockExecuteData.pendingOnchainOpsPubdata.length; ++i) {\\n            bytes memory pubData = _blockExecuteData.pendingOnchainOpsPubdata[i];\\n\\n            Operations.OpType opType = Operations.OpType(uint8(pubData[0]));\\n\\n            if (opType == Operations.OpType.PartialExit) {\\n                Operations.PartialExit memory op = Operations.readPartialExitPubdata(pubData);\\n                // Circuit guarantees that partial exits are available only for fungible tokens\\n                require(op.tokenId <= MAX_FUNGIBLE_TOKEN_ID, \\\"mf1\\\");\\n                withdrawOrStore(uint16(op.tokenId), op.owner, op.amount);\\n            } else if (opType == Operations.OpType.ForcedExit) {\\n                Operations.ForcedExit memory op = Operations.readForcedExitPubdata(pubData);\\n                // Circuit guarantees that forced exits are available only for fungible tokens\\n                require(op.tokenId <= MAX_FUNGIBLE_TOKEN_ID, \\\"mf2\\\");\\n                withdrawOrStore(uint16(op.tokenId), op.target, op.amount);\\n            } else if (opType == Operations.OpType.FullExit) {\\n                Operations.FullExit memory op = Operations.readFullExitPubdata(pubData);\\n                if (op.tokenId <= MAX_FUNGIBLE_TOKEN_ID) {\\n                    withdrawOrStore(uint16(op.tokenId), op.owner, op.amount);\\n                } else {\\n                    if (op.amount == 1) {\\n                        Operations.WithdrawNFT memory withdrawNftOp =\\n                            Operations.WithdrawNFT(\\n                                op.nftCreatorAccountId,\\n                                op.nftCreatorAddress,\\n                                op.nftSerialId,\\n                                op.nftContentHash,\\n                                op.owner,\\n                                op.tokenId\\n                            );\\n                        withdrawOrStoreNFT(withdrawNftOp);\\n                    }\\n                }\\n            } else if (opType == Operations.OpType.WithdrawNFT) {\\n                Operations.WithdrawNFT memory op = Operations.readWithdrawNFTPubdata(pubData);\\n                withdrawOrStoreNFT(op);\\n            } else {\\n                revert(\\\"l\\\"); // unsupported op in block execution\\n            }\\n\\n            pendingOnchainOpsHash = Utils.concatHash(pendingOnchainOpsHash, pubData);\\n        }\\n        require(pendingOnchainOpsHash == _blockExecuteData.storedBlock.pendingOnchainOperationsHash, \\\"m\\\"); // incorrect onchain ops executed\\n    }\\n\\n    /// @notice Execute blocks, completing priority operations and processing withdrawals.\\n    /// @notice 1. Processes all pending operations (Send Exits, Complete priority requests)\\n    /// @notice 2. Finalizes block on Ethereum\\n    function executeBlocks(ExecuteBlockInfo[] memory _blocksData) external nonReentrant {\\n        requireActive();\\n        governance.requireActiveValidator(msg.sender);\\n\\n        uint64 priorityRequestsExecuted = 0;\\n        uint32 nBlocks = uint32(_blocksData.length);\\n        for (uint32 i = 0; i < nBlocks; ++i) {\\n            executeOneBlock(_blocksData[i], i);\\n            priorityRequestsExecuted += _blocksData[i].storedBlock.priorityOperations;\\n            emit BlockVerification(_blocksData[i].storedBlock.blockNumber);\\n        }\\n\\n        firstPriorityRequestId += priorityRequestsExecuted;\\n        totalCommittedPriorityRequests -= priorityRequestsExecuted;\\n        totalOpenPriorityRequests -= priorityRequestsExecuted;\\n\\n        totalBlocksExecuted += nBlocks;\\n        require(totalBlocksExecuted <= totalBlocksProven, \\\"n\\\"); // Can't execute blocks more then committed and proven currently.\\n    }\\n\\n    /// @notice Blocks commitment verification.\\n    /// @notice Only verifies block commitments without any other processing\\n    function proveBlocks(StoredBlockInfo[] memory _committedBlocks, ProofInput memory _proof) external nonReentrant {\\n        requireActive();\\n\\n        uint32 currentTotalBlocksProven = totalBlocksProven;\\n        for (uint256 i = 0; i < _committedBlocks.length; ++i) {\\n            require(hashStoredBlockInfo(_committedBlocks[i]) == storedBlockHashes[currentTotalBlocksProven + 1], \\\"o1\\\");\\n            ++currentTotalBlocksProven;\\n\\n            require(_proof.commitments[i] & INPUT_MASK == uint256(_committedBlocks[i].commitment) & INPUT_MASK, \\\"o\\\"); // incorrect block commitment in proof\\n        }\\n\\n        bool success =\\n            verifier.verifyAggregatedBlockProof(\\n                _proof.recursiveInput,\\n                _proof.proof,\\n                _proof.vkIndexes,\\n                _proof.commitments,\\n                _proof.subproofsLimbs\\n            );\\n        require(success, \\\"p\\\"); // Aggregated proof verification fail\\n\\n        require(currentTotalBlocksProven <= totalBlocksCommitted, \\\"q\\\");\\n        totalBlocksProven = currentTotalBlocksProven;\\n    }\\n\\n    /// @notice Reverts unverified blocks\\n    function revertBlocks(StoredBlockInfo[] memory _blocksToRevert) external {\\n        /// All functions delegated to additional contract should NOT be nonReentrant\\n        delegateAdditional();\\n    }\\n\\n    /// @notice Checks if Exodus mode must be entered. If true - enters exodus mode and emits ExodusMode event.\\n    /// @dev Exodus mode must be entered in case of current ethereum block number is higher than the oldest\\n    /// @dev of existed priority requests expiration block number.\\n    /// @return bool flag that is true if the Exodus mode must be entered.\\n    function activateExodusMode() public returns (bool) {\\n        bool trigger =\\n            block.number >= priorityRequests[firstPriorityRequestId].expirationBlock &&\\n                priorityRequests[firstPriorityRequestId].expirationBlock != 0;\\n        if (trigger) {\\n            if (!exodusMode) {\\n                exodusMode = true;\\n                emit ExodusMode();\\n            }\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /// @notice Withdraws token from ZkSync to root chain in case of exodus mode. User must provide proof that he owns funds\\n    /// @param _storedBlockInfo Last verified block\\n    /// @param _owner Owner of the account\\n    /// @param _accountId Id of the account in the tree\\n    /// @param _proof Proof\\n    /// @param _tokenId Verified token id\\n    /// @param _amount Amount for owner (must be total amount, not part of it)\\n    function performExodus(\\n        StoredBlockInfo memory _storedBlockInfo,\\n        address _owner,\\n        uint32 _accountId,\\n        uint32 _tokenId,\\n        uint128 _amount,\\n        uint32 _nftCreatorAccountId,\\n        address _nftCreatorAddress,\\n        uint32 _nftSerialId,\\n        bytes32 _nftContentHash,\\n        uint256[] memory _proof\\n    ) external {\\n        /// All functions delegated to additional should NOT be nonReentrant\\n        delegateAdditional();\\n    }\\n\\n    /// @notice Set data for changing pubkey hash using onchain authorization.\\n    ///         Transaction author (msg.sender) should be L2 account address\\n    /// @notice New pubkey hash can be reset, to do that user should send two transactions:\\n    ///         1) First `setAuthPubkeyHash` transaction for already used `_nonce` will set timer.\\n    ///         2) After `AUTH_FACT_RESET_TIMELOCK` time is passed second `setAuthPubkeyHash` transaction will reset pubkey hash for `_nonce`.\\n    /// @param _pubkeyHash New pubkey hash\\n    /// @param _nonce Nonce of the change pubkey L2 transaction\\n    function setAuthPubkeyHash(bytes calldata _pubkeyHash, uint32 _nonce) external {\\n        /// All functions delegated to additional contract should NOT be nonReentrant\\n        delegateAdditional();\\n    }\\n\\n    /// @notice Register deposit request - pack pubdata, add priority request and emit OnchainDeposit event\\n    /// @param _tokenId Token by id\\n    /// @param _amount Token amount\\n    /// @param _owner Receiver\\n    function registerDeposit(\\n        uint16 _tokenId,\\n        uint128 _amount,\\n        address _owner\\n    ) internal {\\n        // Priority Queue request\\n        Operations.Deposit memory op =\\n            Operations.Deposit({\\n                accountId: 0, // unknown at this point\\n                owner: _owner,\\n                tokenId: _tokenId,\\n                amount: _amount\\n            });\\n        bytes memory pubData = Operations.writeDepositPubdataForPriorityQueue(op);\\n        addPriorityRequest(Operations.OpType.Deposit, pubData);\\n        emit Deposit(_tokenId, _amount);\\n    }\\n\\n    /// @notice Register withdrawal - update user balance and emit OnchainWithdrawal event\\n    /// @param _token - token by id\\n    /// @param _amount - token amount\\n    /// @param _to - address to withdraw to\\n    function registerWithdrawal(\\n        uint16 _token,\\n        uint128 _amount,\\n        address payable _to\\n    ) internal {\\n        bytes22 packedBalanceKey = packAddressAndTokenId(_to, _token);\\n        uint128 balance = pendingBalances[packedBalanceKey].balanceToWithdraw;\\n        pendingBalances[packedBalanceKey].balanceToWithdraw = balance.sub(_amount);\\n        emit Withdrawal(_token, _amount);\\n    }\\n\\n    /// @dev Gets operations packed in bytes array. Unpacks it and stores onchain operations.\\n    /// @dev Priority operations must be committed in the same order as they are in the priority queue.\\n    /// @dev NOTE: does not change storage! (only emits events)\\n    /// @dev processableOperationsHash - hash of the all operations that needs to be executed  (Deposit, Exits, ChangPubKey)\\n    /// @dev priorityOperationsProcessed - number of priority operations processed in this block (Deposits, FullExits)\\n    /// @dev offsetsCommitment - array where 1 is stored in chunk where onchainOperation begins and other are 0 (used in commitments)\\n    function collectOnchainOps(CommitBlockInfo memory _newBlockData)\\n        internal\\n        view\\n        returns (\\n            bytes32 processableOperationsHash,\\n            uint64 priorityOperationsProcessed,\\n            bytes memory offsetsCommitment\\n        )\\n    {\\n        bytes memory pubData = _newBlockData.publicData;\\n\\n        uint64 uncommittedPriorityRequestsOffset = firstPriorityRequestId + totalCommittedPriorityRequests;\\n        priorityOperationsProcessed = 0;\\n        processableOperationsHash = EMPTY_STRING_KECCAK;\\n\\n        require(pubData.length % CHUNK_BYTES == 0, \\\"A\\\"); // pubdata length must be a multiple of CHUNK_BYTES\\n        offsetsCommitment = new bytes(pubData.length / CHUNK_BYTES);\\n        for (uint256 i = 0; i < _newBlockData.onchainOperations.length; ++i) {\\n            OnchainOperationData memory onchainOpData = _newBlockData.onchainOperations[i];\\n\\n            uint256 pubdataOffset = onchainOpData.publicDataOffset;\\n            require(pubdataOffset < pubData.length, \\\"A1\\\");\\n            require(pubdataOffset % CHUNK_BYTES == 0, \\\"B\\\"); // offsets should be on chunks boundaries\\n            uint256 chunkId = pubdataOffset / CHUNK_BYTES;\\n            require(offsetsCommitment[chunkId] == 0x00, \\\"C\\\"); // offset commitment should be empty\\n            offsetsCommitment[chunkId] = bytes1(0x01);\\n\\n            Operations.OpType opType = Operations.OpType(uint8(pubData[pubdataOffset]));\\n\\n            if (opType == Operations.OpType.Deposit) {\\n                bytes memory opPubData = Bytes.slice(pubData, pubdataOffset, DEPOSIT_BYTES);\\n\\n                Operations.Deposit memory depositData = Operations.readDepositPubdata(opPubData);\\n\\n                checkPriorityOperation(depositData, uncommittedPriorityRequestsOffset + priorityOperationsProcessed);\\n                priorityOperationsProcessed++;\\n            } else if (opType == Operations.OpType.ChangePubKey) {\\n                bytes memory opPubData = Bytes.slice(pubData, pubdataOffset, CHANGE_PUBKEY_BYTES);\\n\\n                Operations.ChangePubKey memory op = Operations.readChangePubKeyPubdata(opPubData);\\n\\n                if (onchainOpData.ethWitness.length != 0) {\\n                    bool valid = verifyChangePubkey(onchainOpData.ethWitness, op);\\n                    require(valid, \\\"D\\\"); // failed to verify change pubkey hash signature\\n                } else {\\n                    bool valid = authFacts[op.owner][op.nonce] == keccak256(abi.encodePacked(op.pubKeyHash));\\n                    require(valid, \\\"E\\\"); // new pub key hash is not authenticated properly\\n                }\\n            } else {\\n                bytes memory opPubData;\\n\\n                if (opType == Operations.OpType.PartialExit) {\\n                    opPubData = Bytes.slice(pubData, pubdataOffset, PARTIAL_EXIT_BYTES);\\n                } else if (opType == Operations.OpType.ForcedExit) {\\n                    opPubData = Bytes.slice(pubData, pubdataOffset, FORCED_EXIT_BYTES);\\n                } else if (opType == Operations.OpType.WithdrawNFT) {\\n                    opPubData = Bytes.slice(pubData, pubdataOffset, WITHDRAW_NFT_BYTES);\\n                } else if (opType == Operations.OpType.FullExit) {\\n                    opPubData = Bytes.slice(pubData, pubdataOffset, FULL_EXIT_BYTES);\\n\\n                    Operations.FullExit memory fullExitData = Operations.readFullExitPubdata(opPubData);\\n\\n                    checkPriorityOperation(\\n                        fullExitData,\\n                        uncommittedPriorityRequestsOffset + priorityOperationsProcessed\\n                    );\\n                    priorityOperationsProcessed++;\\n                } else {\\n                    revert(\\\"F\\\"); // unsupported op\\n                }\\n\\n                processableOperationsHash = Utils.concatHash(processableOperationsHash, opPubData);\\n            }\\n        }\\n    }\\n\\n    /// @notice Checks that change operation is correct\\n    function verifyChangePubkey(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        Operations.ChangePubkeyType changePkType = Operations.ChangePubkeyType(uint8(_ethWitness[0]));\\n        if (changePkType == Operations.ChangePubkeyType.ECRECOVER) {\\n            return verifyChangePubkeyECRECOVER(_ethWitness, _changePk);\\n        } else if (changePkType == Operations.ChangePubkeyType.CREATE2) {\\n            return verifyChangePubkeyCREATE2(_ethWitness, _changePk);\\n        } else if (changePkType == Operations.ChangePubkeyType.OldECRECOVER) {\\n            return verifyChangePubkeyOldECRECOVER(_ethWitness, _changePk);\\n        } else if (changePkType == Operations.ChangePubkeyType.ECRECOVERV2) {\\n            return verifyChangePubkeyECRECOVERV2(_ethWitness, _changePk);\\n        } else {\\n            revert(\\\"G\\\"); // Incorrect ChangePubKey type\\n        }\\n    }\\n\\n    /// @notice Checks that signature is valid for pubkey change message\\n    /// @param _ethWitness Signature (65 bytes)\\n    /// @param _changePk Parsed change pubkey operation\\n    function verifyChangePubkeyECRECOVER(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        (, bytes memory signature) = Bytes.read(_ethWitness, 1, 65); // offset is 1 because we skip type of ChangePubkey\\n        bytes32 messageHash =\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n60\\\",\\n                    _changePk.pubKeyHash,\\n                    _changePk.nonce,\\n                    _changePk.accountId,\\n                    bytes32(0)\\n                )\\n            );\\n        address recoveredAddress = Utils.recoverAddressFromEthSignature(signature, messageHash);\\n        return recoveredAddress == _changePk.owner && recoveredAddress != address(0);\\n    }\\n\\n    /// @notice Checks that signature is valid for pubkey change message\\n    /// @param _ethWitness Signature (65 bytes) + 32 bytes of the arbitrary signed data\\n    /// @notice additional 32 bytes can be used to sign batches and ChangePubKey with one signature\\n    /// @param _changePk Parsed change pubkey operation\\n    function verifyChangePubkeyECRECOVERV2(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        (uint256 offset, bytes memory signature) = Bytes.read(_ethWitness, 1, 65); // offset is 1 because we skip type of ChangePubkey\\n        (, bytes32 additionalData) = Bytes.readBytes32(_ethWitness, offset);\\n        bytes32 messageHash =\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n60\\\",\\n                    _changePk.pubKeyHash,\\n                    _changePk.nonce,\\n                    _changePk.accountId,\\n                    additionalData\\n                )\\n            );\\n        address recoveredAddress = Utils.recoverAddressFromEthSignature(signature, messageHash);\\n        return recoveredAddress == _changePk.owner && recoveredAddress != address(0);\\n    }\\n\\n    /// @notice Checks that signature is valid for pubkey change message, old version differs by form of the signed message.\\n    /// @param _ethWitness Signature (65 bytes)\\n    /// @param _changePk Parsed change pubkey operation\\n    function verifyChangePubkeyOldECRECOVER(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        (, bytes memory signature) = Bytes.read(_ethWitness, 1, 65); // offset is 1 because we skip type of ChangePubkey\\n        bytes32 messageHash =\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n152\\\",\\n                    \\\"Register zkSync pubkey:\\\\n\\\\n\\\",\\n                    Bytes.bytesToHexASCIIBytes(abi.encodePacked(_changePk.pubKeyHash)),\\n                    \\\"\\\\n\\\",\\n                    \\\"nonce: 0x\\\",\\n                    Bytes.bytesToHexASCIIBytes(Bytes.toBytesFromUInt32(_changePk.nonce)),\\n                    \\\"\\\\n\\\",\\n                    \\\"account id: 0x\\\",\\n                    Bytes.bytesToHexASCIIBytes(Bytes.toBytesFromUInt32(_changePk.accountId)),\\n                    \\\"\\\\n\\\\n\\\",\\n                    \\\"Only sign this message for a trusted client!\\\"\\n                )\\n            );\\n        address recoveredAddress = Utils.recoverAddressFromEthSignature(signature, messageHash);\\n        return recoveredAddress == _changePk.owner && recoveredAddress != address(0);\\n    }\\n\\n    /// @notice Checks that signature is valid for pubkey change message\\n    /// @param _ethWitness Create2 deployer address, saltArg, codeHash\\n    /// @param _changePk Parsed change pubkey operation\\n    function verifyChangePubkeyCREATE2(bytes memory _ethWitness, Operations.ChangePubKey memory _changePk)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        address creatorAddress;\\n        bytes32 saltArg; // salt arg is additional bytes that are encoded in the CREATE2 salt\\n        bytes32 codeHash;\\n        uint256 offset = 1; // offset is 1 because we skip type of ChangePubkey\\n        (offset, creatorAddress) = Bytes.readAddress(_ethWitness, offset);\\n        (offset, saltArg) = Bytes.readBytes32(_ethWitness, offset);\\n        (offset, codeHash) = Bytes.readBytes32(_ethWitness, offset);\\n        // salt from CREATE2 specification\\n        bytes32 salt = keccak256(abi.encodePacked(saltArg, _changePk.pubKeyHash));\\n        // Address computation according to CREATE2 definition: https://eips.ethereum.org/EIPS/eip-1014\\n        address recoveredAddress =\\n            address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), creatorAddress, salt, codeHash)))));\\n        // This type of change pubkey can be done only once\\n        return recoveredAddress == _changePk.owner && _changePk.nonce == 0;\\n    }\\n\\n    /// @dev Creates block commitment from its data\\n    /// @dev _offsetCommitment - hash of the array where 1 is stored in chunk where onchainOperation begins and 0 for other chunks\\n    function createBlockCommitment(\\n        StoredBlockInfo memory _previousBlock,\\n        CommitBlockInfo memory _newBlockData,\\n        bytes memory _offsetCommitment\\n    ) internal view returns (bytes32 commitment) {\\n        bytes32 hash = sha256(abi.encodePacked(uint256(_newBlockData.blockNumber), uint256(_newBlockData.feeAccount)));\\n        hash = sha256(abi.encodePacked(hash, _previousBlock.stateHash));\\n        hash = sha256(abi.encodePacked(hash, _newBlockData.newStateHash));\\n        hash = sha256(abi.encodePacked(hash, uint256(_newBlockData.timestamp)));\\n\\n        bytes memory pubdata = abi.encodePacked(_newBlockData.publicData, _offsetCommitment);\\n\\n        /// The code below is equivalent to `commitment = sha256(abi.encodePacked(hash, _publicData))`\\n\\n        /// We use inline assembly instead of this concise and readable code in order to avoid copying of `_publicData` (which saves ~90 gas per transfer operation).\\n\\n        /// Specifically, we perform the following trick:\\n        /// First, replace the first 32 bytes of `_publicData` (where normally its length is stored) with the value of `hash`.\\n        /// Then, we call `sha256` precompile passing the `_publicData` pointer and the length of the concatenated byte buffer.\\n        /// Finally, we put the `_publicData.length` back to its original location (to the first word of `_publicData`).\\n        assembly {\\n            let hashResult := mload(0x40)\\n            let pubDataLen := mload(pubdata)\\n            mstore(pubdata, hash)\\n            // staticcall to the sha256 precompile at address 0x2\\n            let success := staticcall(gas(), 0x2, pubdata, add(pubDataLen, 0x20), hashResult, 0x20)\\n            mstore(pubdata, pubDataLen)\\n\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n                case 0 {\\n                    invalid()\\n                }\\n\\n            commitment := mload(hashResult)\\n        }\\n    }\\n\\n    /// @notice Checks that deposit is same as operation in priority queue\\n    /// @param _deposit Deposit data\\n    /// @param _priorityRequestId Operation's id in priority queue\\n    function checkPriorityOperation(Operations.Deposit memory _deposit, uint64 _priorityRequestId) internal view {\\n        Operations.OpType priorReqType = priorityRequests[_priorityRequestId].opType;\\n        require(priorReqType == Operations.OpType.Deposit, \\\"H\\\"); // incorrect priority op type\\n\\n        bytes20 hashedPubdata = priorityRequests[_priorityRequestId].hashedPubData;\\n        require(Operations.checkDepositInPriorityQueue(_deposit, hashedPubdata), \\\"I\\\");\\n    }\\n\\n    /// @notice Checks that FullExit is same as operation in priority queue\\n    /// @param _fullExit FullExit data\\n    /// @param _priorityRequestId Operation's id in priority queue\\n    function checkPriorityOperation(Operations.FullExit memory _fullExit, uint64 _priorityRequestId) internal view {\\n        Operations.OpType priorReqType = priorityRequests[_priorityRequestId].opType;\\n        require(priorReqType == Operations.OpType.FullExit, \\\"J\\\"); // incorrect priority op type\\n\\n        bytes20 hashedPubdata = priorityRequests[_priorityRequestId].hashedPubData;\\n        require(Operations.checkFullExitInPriorityQueue(_fullExit, hashedPubdata), \\\"K\\\");\\n    }\\n\\n    // Priority queue\\n\\n    /// @notice Saves priority request in storage\\n    /// @dev Calculates expiration block for request, store this request and emit NewPriorityRequest event\\n    /// @param _opType Rollup operation type\\n    /// @param _pubData Operation pubdata\\n    function addPriorityRequest(Operations.OpType _opType, bytes memory _pubData) internal {\\n        // Expiration block is: current block number + priority expiration delta\\n        uint64 expirationBlock = uint64(block.number + PRIORITY_EXPIRATION);\\n\\n        uint64 nextPriorityRequestId = firstPriorityRequestId + totalOpenPriorityRequests;\\n\\n        bytes20 hashedPubData = Utils.hashBytesToBytes20(_pubData);\\n\\n        priorityRequests[nextPriorityRequestId] = PriorityOperation({\\n            hashedPubData: hashedPubData,\\n            expirationBlock: expirationBlock,\\n            opType: _opType\\n        });\\n\\n        emit NewPriorityRequest(msg.sender, nextPriorityRequestId, _opType, _pubData, uint256(expirationBlock));\\n\\n        totalOpenPriorityRequests++;\\n    }\\n\\n    function increaseBalanceToWithdraw(bytes22 _packedBalanceKey, uint128 _amount) internal {\\n        uint128 balance = pendingBalances[_packedBalanceKey].balanceToWithdraw;\\n        pendingBalances[_packedBalanceKey] = PendingBalance(balance.add(_amount), FILLED_GAS_RESERVE_VALUE);\\n    }\\n\\n    /// @notice Sends ETH\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function sendETHNoRevert(address payable _to, uint256 _amount) internal returns (bool) {\\n        (bool callSuccess, ) = _to.call{gas: WITHDRAWAL_GAS_LIMIT, value: _amount}(\\\"\\\");\\n        return callSuccess;\\n    }\\n\\n    /// @notice Delegates the call to the additional part of the main contract.\\n    /// @notice Should be only use to delegate the external calls as it passes the calldata\\n    /// @notice All functions delegated to additional contract should NOT be nonReentrant\\n    function delegateAdditional() internal {\\n        address _target = address(additionalZkSync);\\n        assembly {\\n            // The pointer to the free memory slot\\n            let ptr := mload(0x40)\\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\\n            calldatacopy(ptr, 0x0, calldatasize())\\n            // Delegatecall method of the implementation contract, returns 0 on error\\n            let result := delegatecall(gas(), _target, ptr, calldatasize(), 0x0, 0)\\n            // Get the size of the last return data\\n            let size := returndatasize()\\n            // Copy the size length of bytes from return data at zero position to pointer position\\n            returndatacopy(ptr, 0x0, size)\\n\\n            // Depending on result value\\n            switch result\\n                case 0 {\\n                    // End execution and revert state changes\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    // Return data with length of size at pointers position\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    /// @dev Address of lock flag variable.\\n    /// @dev Flag is placed at random memory location to not interfere with Storage contract.\\n    uint256 private constant LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4; // keccak256(\\\"ReentrancyGuard\\\") - 1;\\n\\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/security/ReentrancyGuard.sol\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    function initializeReentrancyGuard() internal {\\n        uint256 lockSlotOldValue;\\n\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange every call to nonReentrant\\n        // will be cheaper.\\n        assembly {\\n            lockSlotOldValue := sload(LOCK_FLAG_ADDRESS)\\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\\n        }\\n\\n        // Check that storage slot for reentrancy guard is empty to rule out possibility of slot conflict\\n        require(lockSlotOldValue == 0, \\\"1B\\\");\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        uint256 _status;\\n        assembly {\\n            _status := sload(LOCK_FLAG_ADDRESS)\\n        }\\n\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status == _NOT_ENTERED);\\n\\n        // Any calls to nonReentrant after this point will fail\\n        assembly {\\n            sstore(LOCK_FLAG_ADDRESS, _ENTERED)\\n        }\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        assembly {\\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"14\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"v\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"15\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"x\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"y\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/SafeMathUInt128.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUInt128 {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\\n        uint128 c = a + b;\\n        require(c >= a, \\\"12\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return sub(a, b, \\\"aa\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint128 a,\\n        uint128 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint128) {\\n        require(b <= a, errorMessage);\\n        uint128 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint128 c = a * b;\\n        require(c / a == b, \\\"13\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return div(a, b, \\\"ac\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint128 a,\\n        uint128 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint128) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint128 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\\n        return mod(a, b, \\\"ad\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint128 a,\\n        uint128 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint128) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/SafeCast.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and then downcasting.\\n *\\n * _Available since v2.5.0._\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"16\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"17\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"18\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"19\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"1a\\\");\\n        return uint8(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Utils.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Bytes.sol\\\";\\n\\nlibrary Utils {\\n    /// @notice Returns lesser of two values\\n    function minU32(uint32 a, uint32 b) internal pure returns (uint32) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Returns lesser of two values\\n    function minU64(uint64 a, uint64 b) internal pure returns (uint64) {\\n        return a < b ? a : b;\\n    }\\n\\n    /// @notice Sends tokens\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transfer` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function sendERC20(\\n        IERC20 _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) =\\n            address(_token).call(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", _to, _amount));\\n        // `transfer` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Transfers token from one address to another\\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\\n    /// @dev NOTE: call `transferFrom` to this token may return (bool) or nothing\\n    /// @param _token Token address\\n    /// @param _from Address of sender\\n    /// @param _to Address of recipient\\n    /// @param _amount Amount of tokens to transfer\\n    /// @return bool flag indicating that transfer is successful\\n    function transferFromERC20(\\n        IERC20 _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (bool) {\\n        (bool callSuccess, bytes memory callReturnValueEncoded) =\\n            address(_token).call(abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", _from, _to, _amount));\\n        // `transferFrom` method may return (bool) or nothing.\\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\\n        return callSuccess && returnedSuccess;\\n    }\\n\\n    /// @notice Recovers signer's address from ethereum signature for given message\\n    /// @param _signature 65 bytes concatenated. R (32) + S (32) + V (1)\\n    /// @param _messageHash signed message hash.\\n    /// @return address of the signer\\n    function recoverAddressFromEthSignature(bytes memory _signature, bytes32 _messageHash)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(_signature.length == 65, \\\"P\\\"); // incorrect signature length\\n\\n        bytes32 signR;\\n        bytes32 signS;\\n        uint8 signV;\\n        assembly {\\n            signR := mload(add(_signature, 32))\\n            signS := mload(add(_signature, 64))\\n            signV := byte(0, mload(add(_signature, 96)))\\n        }\\n\\n        return ecrecover(_messageHash, signV, signR, signS);\\n    }\\n\\n    /// @notice Returns new_hash = hash(old_hash + bytes)\\n    function concatHash(bytes32 _hash, bytes memory _bytes) internal pure returns (bytes32) {\\n        bytes32 result;\\n        assembly {\\n            let bytesLen := add(mload(_bytes), 32)\\n            mstore(_bytes, _hash)\\n            result := keccak256(_bytes, bytesLen)\\n        }\\n        return result;\\n    }\\n\\n    function hashBytesToBytes20(bytes memory _bytes) internal pure returns (bytes20) {\\n        return bytes20(uint160(uint256(keccak256(_bytes))));\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Storage.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n// solhint-disable max-states-count\\n\\n\\n\\n\\n\\nimport \\\"./IERC20.sol\\\";\\n\\nimport \\\"./Governance.sol\\\";\\nimport \\\"./Verifier.sol\\\";\\nimport \\\"./Operations.sol\\\";\\nimport \\\"./NFTFactory.sol\\\";\\nimport \\\"./AdditionalZkSync.sol\\\";\\n\\n/// @title zkSync storage contract\\n/// @author Matter Labs\\ncontract Storage {\\n    /// @dev Flag indicates that upgrade preparation status is active\\n    /// @dev Will store false in case of not active upgrade mode\\n    bool internal upgradePreparationActive;\\n\\n    /// @dev Upgrade preparation activation timestamp (as seconds since unix epoch)\\n    /// @dev Will be equal to zero in case of not active upgrade mode\\n    uint256 internal upgradePreparationActivationTime;\\n\\n    /// @dev Verifier contract. Used to verify block proof and exit proof\\n    Verifier internal verifier;\\n\\n    /// @dev Governance contract. Contains the governor (the owner) of whole system, validators list, possible tokens list\\n    Governance internal governance;\\n\\n    uint8 internal constant FILLED_GAS_RESERVE_VALUE = 0xff; // we use it to set gas revert value so slot will not be emptied with 0 balance\\n    struct PendingBalance {\\n        uint128 balanceToWithdraw;\\n        uint8 gasReserveValue; // gives user opportunity to fill storage slot with nonzero value\\n    }\\n\\n    /// @dev Root-chain balances (per owner and token id, see packAddressAndTokenId) to withdraw\\n    mapping(bytes22 => PendingBalance) internal pendingBalances;\\n\\n    // @dev Pending withdrawals are not used in this version\\n    struct PendingWithdrawalDEPRECATED {\\n        address to;\\n        uint16 tokenId;\\n    }\\n    mapping(uint32 => PendingWithdrawalDEPRECATED) internal pendingWithdrawalsDEPRECATED;\\n    uint32 internal firstPendingWithdrawalIndexDEPRECATED;\\n    uint32 internal numberOfPendingWithdrawalsDEPRECATED;\\n\\n    /// @dev Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\\n    uint32 public totalBlocksExecuted;\\n\\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\\n    uint32 public totalBlocksCommitted;\\n\\n    /// @Old rollup block stored data - not used in current version\\n    /// @member validator Block producer\\n    /// @member committedAtBlock ETH block number at which this block was committed\\n    /// @member cumulativeOnchainOperations Total number of operations in this and all previous blocks\\n    /// @member priorityOperations Total number of priority operations for this block\\n    /// @member commitment Hash of the block circuit commitment\\n    /// @member stateRoot New tree root hash\\n    ///\\n    /// Consider memory alignment when changing field order: https://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html\\n    struct BlockDEPRECATED {\\n        uint32 committedAtBlock;\\n        uint64 priorityOperations;\\n        uint32 chunks;\\n        bytes32 withdrawalsDataHash; // can be restricted to 16 bytes to reduce number of required storage slots\\n        bytes32 commitment;\\n        bytes32 stateRoot;\\n    }\\n    mapping(uint32 => BlockDEPRECATED) internal blocksDEPRECATED;\\n\\n    /// @dev Flag indicates that a user has exited in the exodus mode certain token balance (per account id and tokenId)\\n    mapping(uint32 => mapping(uint32 => bool)) internal performedExodus;\\n\\n    /// @dev Flag indicates that exodus (mass exit) mode is triggered\\n    /// @dev Once it was raised, it can not be cleared again, and all users must exit\\n    bool public exodusMode;\\n\\n    /// @dev User authenticated fact hashes for some nonce.\\n    mapping(address => mapping(uint32 => bytes32)) public authFacts;\\n\\n    /// @notice Old Priority Operation container\\n    /// @member opType Priority operation type\\n    /// @member pubData Priority operation public data\\n    /// @member expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\\n    struct PriorityOperationDEPRECATED {\\n        Operations.OpType opType;\\n        bytes pubData;\\n        uint256 expirationBlock;\\n    }\\n\\n    /// @dev Priority Requests mapping (request id - operation)\\n    /// @dev Contains op type, pubdata and expiration block of unsatisfied requests.\\n    /// @dev Numbers are in order of requests receiving\\n    mapping(uint64 => PriorityOperationDEPRECATED) internal priorityRequestsDEPRECATED;\\n\\n    /// @dev First open priority request id\\n    uint64 public firstPriorityRequestId;\\n\\n    /// @dev Total number of requests\\n    uint64 public totalOpenPriorityRequests;\\n\\n    /// @dev Total number of committed requests.\\n    /// @dev Used in checks: if the request matches the operation on Rollup contract and if provided number of requests is not too big\\n    uint64 internal totalCommittedPriorityRequests;\\n\\n    /// @notice Packs address and token id into single word to use as a key in balances mapping\\n    function packAddressAndTokenId(address _address, uint16 _tokenId) internal pure returns (bytes22) {\\n        return bytes22((uint176(_address) | (uint176(_tokenId) << 160)));\\n    }\\n\\n    /// @Rollup block stored data\\n    /// @member blockNumber Rollup block number\\n    /// @member priorityOperations Number of priority operations processed\\n    /// @member pendingOnchainOperationsHash Hash of all operations that must be processed after verify\\n    /// @member timestamp Rollup block timestamp, have the same format as Ethereum block constant\\n    /// @member stateHash Root hash of the rollup state\\n    /// @member commitment Verified input for the zkSync circuit\\n    struct StoredBlockInfo {\\n        uint32 blockNumber;\\n        uint64 priorityOperations;\\n        bytes32 pendingOnchainOperationsHash;\\n        uint256 timestamp;\\n        bytes32 stateHash;\\n        bytes32 commitment;\\n    }\\n\\n    /// @notice Returns the keccak hash of the ABI-encoded StoredBlockInfo\\n    function hashStoredBlockInfo(StoredBlockInfo memory _storedBlockInfo) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(_storedBlockInfo));\\n    }\\n\\n    /// @dev Stored hashed StoredBlockInfo for some block number\\n    mapping(uint32 => bytes32) public storedBlockHashes;\\n\\n    /// @dev Total blocks proven.\\n    uint32 public totalBlocksProven;\\n\\n    /// @notice Priority Operation container\\n    /// @member hashedPubData Hashed priority operation public data\\n    /// @member expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\\n    /// @member opType Priority operation type\\n    struct PriorityOperation {\\n        bytes20 hashedPubData;\\n        uint64 expirationBlock;\\n        Operations.OpType opType;\\n    }\\n\\n    /// @dev Priority Requests mapping (request id - operation)\\n    /// @dev Contains op type, pubdata and expiration block of unsatisfied requests.\\n    /// @dev Numbers are in order of requests receiving\\n    mapping(uint64 => PriorityOperation) internal priorityRequests;\\n\\n    /// @dev Timer for authFacts entry reset (address, nonce -> timer).\\n    /// @dev Used when user wants to reset `authFacts` for some nonce.\\n    mapping(address => mapping(uint32 => uint256)) internal authFactsResetTimer;\\n\\n    mapping(uint32 => address) internal withdrawnNFTs;\\n\\n    mapping(uint32 => Operations.WithdrawNFT) internal pendingWithdrawnNFTs;\\n\\n    AdditionalZkSync internal additionalZkSync;\\n\\n    /// @dev Upgrade notice period, possibly shorten by the security council\\n    uint256 internal approvedUpgradeNoticePeriod;\\n\\n    /// @dev Upgrade start timestamp (as seconds since unix epoch)\\n    /// @dev Will be equal to zero in case of not active upgrade mode\\n    uint256 internal upgradeStartTimestamp;\\n\\n    /// @dev Stores boolean flags which means the confirmations of the upgrade for each member of security council\\n    /// @dev Will store zeroes in case of not active upgrade mode\\n    mapping(uint256 => bool) internal securityCouncilApproves;\\n    uint256 internal numberOfApprovalsFromSecurityCouncil;\\n\\n    /// @notice Checks that current state not is exodus mode\\n    function requireActive() internal view {\\n        require(!exodusMode, \\\"L\\\"); // exodus mode activated\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Config.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title zkSync configuration constants\\n/// @author Matter Labs\\ncontract Config {\\n    /// @dev ERC20 tokens and ETH withdrawals gas limit, used only for complete withdrawals\\n    uint256 internal constant WITHDRAWAL_GAS_LIMIT = 100000;\\n\\n    /// @dev NFT withdrawals gas limit, used only for complete withdrawals\\n    uint256 internal constant WITHDRAWAL_NFT_GAS_LIMIT = 300000;\\n\\n    /// @dev Bytes in one chunk\\n    uint8 internal constant CHUNK_BYTES = 10;\\n\\n    /// @dev zkSync address length\\n    uint8 internal constant ADDRESS_BYTES = 20;\\n\\n    uint8 internal constant PUBKEY_HASH_BYTES = 20;\\n\\n    /// @dev Public key bytes length\\n    uint8 internal constant PUBKEY_BYTES = 32;\\n\\n    /// @dev Ethereum signature r/s bytes length\\n    uint8 internal constant ETH_SIGN_RS_BYTES = 32;\\n\\n    /// @dev Success flag bytes length\\n    uint8 internal constant SUCCESS_FLAG_BYTES = 1;\\n\\n    /// @dev Max amount of tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 internal constant MAX_AMOUNT_OF_REGISTERED_TOKENS = 1023;\\n\\n    /// @dev Max account id that could be registered in the network\\n    uint32 internal constant MAX_ACCOUNT_ID = 16777215;\\n\\n    /// @dev Expected average period of block creation\\n    uint256 internal constant BLOCK_PERIOD = 15 seconds;\\n\\n    /// @dev ETH blocks verification expectation\\n    /// @dev Blocks can be reverted if they are not verified for at least EXPECT_VERIFICATION_IN.\\n    /// @dev If set to 0 validator can revert blocks at any time.\\n    uint256 internal constant EXPECT_VERIFICATION_IN = 0 hours / BLOCK_PERIOD;\\n\\n    uint256 internal constant NOOP_BYTES = 1 * CHUNK_BYTES;\\n    uint256 internal constant DEPOSIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant MINT_NFT_BYTES = 5 * CHUNK_BYTES;\\n    uint256 internal constant TRANSFER_TO_NEW_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant PARTIAL_EXIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant TRANSFER_BYTES = 2 * CHUNK_BYTES;\\n    uint256 internal constant FORCED_EXIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant WITHDRAW_NFT_BYTES = 10 * CHUNK_BYTES;\\n\\n    /// @dev Full exit operation length\\n    uint256 internal constant FULL_EXIT_BYTES = 11 * CHUNK_BYTES;\\n\\n    /// @dev ChangePubKey operation length\\n    uint256 internal constant CHANGE_PUBKEY_BYTES = 6 * CHUNK_BYTES;\\n\\n    /// @dev Expiration delta for priority request to be satisfied (in seconds)\\n    /// @dev NOTE: Priority expiration should be > (EXPECT_VERIFICATION_IN * BLOCK_PERIOD)\\n    /// @dev otherwise incorrect block with priority op could not be reverted.\\n    uint256 internal constant PRIORITY_EXPIRATION_PERIOD = 3 days;\\n\\n    /// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\\n    uint256 internal constant PRIORITY_EXPIRATION =\\n        PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD;\\n\\n    /// @dev Maximum number of priority request to clear during verifying the block\\n    /// @dev Cause deleting storage slots cost 5k gas per each slot it's unprofitable to clear too many slots\\n    /// @dev Value based on the assumption of ~750k gas cost of verifying and 5 used storage slots per PriorityOperation structure\\n    uint64 internal constant MAX_PRIORITY_REQUESTS_TO_DELETE_IN_VERIFY = 6;\\n\\n    /// @dev Reserved time for users to send full exit priority operation in case of an upgrade (in seconds)\\n    uint256 internal constant MASS_FULL_EXIT_PERIOD = 9 days;\\n\\n    /// @dev Reserved time for users to withdraw funds from full exit priority operation in case of an upgrade (in seconds)\\n    uint256 internal constant TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT = 2 days;\\n\\n    /// @dev Notice period before activation preparation status of upgrade mode (in seconds)\\n    /// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\\n    uint256 internal constant UPGRADE_NOTICE_PERIOD =\\n        MASS_FULL_EXIT_PERIOD+PRIORITY_EXPIRATION_PERIOD+TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT;\\n\\n    /// @dev Timestamp - seconds since unix epoch\\n    uint256 internal constant COMMIT_TIMESTAMP_NOT_OLDER = 24 hours;\\n\\n    /// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\\n    /// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\\n    uint256 internal constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 15 minutes;\\n\\n    /// @dev Bit mask to apply for verifier public input before verifying.\\n    uint256 internal constant INPUT_MASK = 14474011154664524427946373126085988481658748083205070504932198000989141204991;\\n\\n    /// @dev Auth fact reset timelock.\\n    uint256 internal constant AUTH_FACT_RESET_TIMELOCK = 1 days;\\n\\n    /// @dev Max deposit of ERC20 token that is possible to deposit\\n    uint128 internal constant MAX_DEPOSIT_AMOUNT = 20282409603651670423947251286015;\\n\\n    uint32 internal constant SPECIAL_ACCOUNT_ID = 16777215;\\n    address internal constant SPECIAL_ACCOUNT_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n    uint32 internal constant SPECIAL_NFT_TOKEN_ID = 2147483646;\\n\\n    uint32 internal constant MAX_FUNGIBLE_TOKEN_ID = 65535;\\n\\n    uint256 internal constant SECURITY_COUNCIL_MEMBERS_NUMBER = 15;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Events.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\n/// @title zkSync events\\n/// @author Matter Labs\\ninterface Events {\\n    /// @notice Event emitted when a block is committed\\n    event BlockCommit(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when a block is verified\\n    event BlockVerification(uint32 indexed blockNumber);\\n\\n    /// @notice Event emitted when user funds are withdrawn from the zkSync state and contract\\n    event Withdrawal(uint16 indexed tokenId, uint128 amount);\\n\\n    /// @notice Event emitted when user funds are withdrawn from the zkSync state but not from contract\\n    event WithdrawalPending(uint16 indexed tokenId, uint128 amount);\\n\\n    /// @notice Event emitted when user NFT is withdrawn from the zkSync state and contract\\n    event WithdrawalNFT(uint32 indexed tokenId);\\n\\n    /// @notice Event emitted when user NFT is withdrawn from the zkSync state but not from contract\\n    event WithdrawalNFTPending(uint32 indexed tokenId);\\n\\n    /// @notice Event emitted when user funds are deposited to the zkSync contract\\n    event Deposit(uint16 indexed tokenId, uint128 amount);\\n\\n    /// @notice Event emitted when user sends a authentication fact (e.g. pub-key hash)\\n    event FactAuth(address indexed sender, uint32 nonce, bytes fact);\\n\\n    /// @notice Event emitted when blocks are reverted\\n    event BlocksRevert(uint32 totalBlocksVerified, uint32 totalBlocksCommitted);\\n\\n    /// @notice Exodus mode entered event\\n    event ExodusMode();\\n\\n    /// @notice New priority request event. Emitted when a request is placed into mapping\\n    event NewPriorityRequest(\\n        address sender,\\n        uint64 serialId,\\n        Operations.OpType opType,\\n        bytes pubData,\\n        uint256 expirationBlock\\n    );\\n\\n    /// @notice Deposit committed event.\\n    event DepositCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Full exit committed event.\\n    event FullExitCommit(\\n        uint32 indexed zkSyncBlockId,\\n        uint32 indexed accountId,\\n        address owner,\\n        uint16 indexed tokenId,\\n        uint128 amount\\n    );\\n\\n    /// @notice Notice period changed\\n    event NoticePeriodChange(uint256 newNoticePeriod);\\n}\\n\\n/// @title Upgrade events\\n/// @author Matter Labs\\ninterface UpgradeEvents {\\n    /// @notice Event emitted when new upgradeable contract is added to upgrade gatekeeper's list of managed contracts\\n    event NewUpgradable(uint256 indexed versionId, address indexed upgradeable);\\n\\n    /// @notice Upgrade mode enter event\\n    event NoticePeriodStart(\\n        uint256 indexed versionId,\\n        address[] newTargets,\\n        uint256 noticePeriod // notice period (in seconds)\\n    );\\n\\n    /// @notice Upgrade mode cancel event\\n    event UpgradeCancel(uint256 indexed versionId);\\n\\n    /// @notice Upgrade mode preparation status event\\n    event PreparationStart(uint256 indexed versionId);\\n\\n    /// @notice Upgrade mode complete event\\n    event UpgradeComplete(uint256 indexed versionId, address[] newTargets);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Bytes.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n// Functions named bytesToX, except bytesToBytes20, where X is some type of size N < 32 (size of one word)\\n// implements the following algorithm:\\n// f(bytes memory input, uint offset) -> X out\\n// where byte representation of out is N bytes from input at the given offset\\n// 1) We compute memory location of the word W such that last N bytes of W is input[offset..offset+N]\\n// W_address = input + 32 (skip stored length of bytes) + offset - (32 - N) == input + offset + N\\n// 2) We load W from memory into out, last N bytes of W are placed into out\\n\\nlibrary Bytes {\\n    function toBytesFromUInt16(uint16 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 2);\\n    }\\n\\n    function toBytesFromUInt24(uint24 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 3);\\n    }\\n\\n    function toBytesFromUInt32(uint32 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 4);\\n    }\\n\\n    function toBytesFromUInt128(uint128 self) internal pure returns (bytes memory _bts) {\\n        return toBytesFromUIntTruncated(uint256(self), 16);\\n    }\\n\\n    // Copies 'len' lower bytes from 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length 'len'.\\n    function toBytesFromUIntTruncated(uint256 self, uint8 byteLength) private pure returns (bytes memory bts) {\\n        require(byteLength <= 32, \\\"Q\\\");\\n        bts = new bytes(byteLength);\\n        // Even though the bytes will allocate a full word, we don't want\\n        // any potential garbage bytes in there.\\n        uint256 data = self << ((32 - byteLength) * 8);\\n        assembly {\\n            mstore(\\n                add(bts, 32), // BYTES_HEADER_SIZE\\n                data\\n            )\\n        }\\n    }\\n\\n    // Copies 'self' into a new 'bytes memory'.\\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length '20'.\\n    function toBytesFromAddress(address self) internal pure returns (bytes memory bts) {\\n        bts = toBytesFromUIntTruncated(uint256(self), 20);\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToAddress(bytes memory self, uint256 _start) internal pure returns (address addr) {\\n        uint256 offset = _start + 20;\\n        require(self.length >= offset, \\\"R\\\");\\n        assembly {\\n            addr := mload(add(self, offset))\\n        }\\n    }\\n\\n    // Reasoning about why this function works is similar to that of other similar functions, except NOTE below.\\n    // NOTE: that bytes1..32 is stored in the beginning of the word unlike other primitive types\\n    // NOTE: theoretically possible overflow of (_start + 20)\\n    function bytesToBytes20(bytes memory self, uint256 _start) internal pure returns (bytes20 r) {\\n        require(self.length >= (_start + 20), \\\"S\\\");\\n        assembly {\\n            r := mload(add(add(self, 0x20), _start))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x2)\\n    function bytesToUInt16(bytes memory _bytes, uint256 _start) internal pure returns (uint16 r) {\\n        uint256 offset = _start + 0x2;\\n        require(_bytes.length >= offset, \\\"T\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x3)\\n    function bytesToUInt24(bytes memory _bytes, uint256 _start) internal pure returns (uint24 r) {\\n        uint256 offset = _start + 0x3;\\n        require(_bytes.length >= offset, \\\"U\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x4)\\n    function bytesToUInt32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 r) {\\n        uint256 offset = _start + 0x4;\\n        require(_bytes.length >= offset, \\\"V\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x10)\\n    function bytesToUInt128(bytes memory _bytes, uint256 _start) internal pure returns (uint128 r) {\\n        uint256 offset = _start + 0x10;\\n        require(_bytes.length >= offset, \\\"W\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // See comment at the top of this file for explanation of how this function works.\\n    // NOTE: theoretically possible overflow of (_start + 0x14)\\n    function bytesToUInt160(bytes memory _bytes, uint256 _start) internal pure returns (uint160 r) {\\n        uint256 offset = _start + 0x14;\\n        require(_bytes.length >= offset, \\\"X\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_start + 0x20)\\n    function bytesToBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 r) {\\n        uint256 offset = _start + 0x20;\\n        require(_bytes.length >= offset, \\\"Y\\\");\\n        assembly {\\n            r := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\\n    // Get slice from bytes arrays\\n    // Returns the newly created 'bytes memory'\\n    // NOTE: theoretically possible overflow of (_start + _length)\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_bytes.length >= (_start + _length), \\\"Z\\\"); // bytes length is less then start byte + length bytes\\n\\n        bytes memory tempBytes = new bytes(_length);\\n\\n        if (_length != 0) {\\n            assembly {\\n                let slice_curr := add(tempBytes, 0x20)\\n                let slice_end := add(slice_curr, _length)\\n\\n                for {\\n                    let array_current := add(_bytes, add(_start, 0x20))\\n                } lt(slice_curr, slice_end) {\\n                    slice_curr := add(slice_curr, 0x20)\\n                    array_current := add(array_current, 0x20)\\n                } {\\n                    mstore(slice_curr, mload(array_current))\\n                }\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /// Reads byte stream\\n    /// @return newOffset - offset + amount of bytes read\\n    /// @return data - actually read data\\n    // NOTE: theoretically possible overflow of (_offset + _length)\\n    function read(\\n        bytes memory _data,\\n        uint256 _offset,\\n        uint256 _length\\n    ) internal pure returns (uint256 newOffset, bytes memory data) {\\n        data = slice(_data, _offset, _length);\\n        newOffset = _offset + _length;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readBool(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bool r) {\\n        newOffset = _offset + 1;\\n        r = uint8(_data[_offset]) != 0;\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 1)\\n    function readUint8(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint8 r) {\\n        newOffset = _offset + 1;\\n        r = uint8(_data[_offset]);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 2)\\n    function readUInt16(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint16 r) {\\n        newOffset = _offset + 2;\\n        r = bytesToUInt16(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 3)\\n    function readUInt24(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint24 r) {\\n        newOffset = _offset + 3;\\n        r = bytesToUInt24(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 4)\\n    function readUInt32(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint32 r) {\\n        newOffset = _offset + 4;\\n        r = bytesToUInt32(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 16)\\n    function readUInt128(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint128 r) {\\n        newOffset = _offset + 16;\\n        r = bytesToUInt128(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readUInt160(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint160 r) {\\n        newOffset = _offset + 20;\\n        r = bytesToUInt160(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readAddress(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, address r) {\\n        newOffset = _offset + 20;\\n        r = bytesToAddress(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 20)\\n    function readBytes20(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bytes20 r) {\\n        newOffset = _offset + 20;\\n        r = bytesToBytes20(_data, _offset);\\n    }\\n\\n    // NOTE: theoretically possible overflow of (_offset + 32)\\n    function readBytes32(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bytes32 r) {\\n        newOffset = _offset + 32;\\n        r = bytesToBytes32(_data, _offset);\\n    }\\n\\n    /// Trim bytes into single word\\n    function trim(bytes memory _data, uint256 _newLength) internal pure returns (uint256 r) {\\n        require(_newLength <= 0x20, \\\"10\\\"); // new_length is longer than word\\n        require(_data.length >= _newLength, \\\"11\\\"); // data is to short\\n\\n        uint256 a;\\n        assembly {\\n            a := mload(add(_data, 0x20)) // load bytes into uint256\\n        }\\n\\n        return a >> ((0x20 - _newLength) * 8);\\n    }\\n\\n    // Helper function for hex conversion.\\n    function halfByteToHex(bytes1 _byte) internal pure returns (bytes1 _hexByte) {\\n        require(uint8(_byte) < 0x10, \\\"hbh11\\\"); // half byte's value is out of 0..15 range.\\n\\n        // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n        return bytes1(uint8(0x66656463626139383736353433323130 >> (uint8(_byte) * 8)));\\n    }\\n\\n    // Convert bytes to ASCII hex representation\\n    function bytesToHexASCIIBytes(bytes memory _input) internal pure returns (bytes memory _output) {\\n        bytes memory outStringBytes = new bytes(_input.length * 2);\\n\\n        // code in `assembly` construction is equivalent of the next code:\\n        // for (uint i = 0; i < _input.length; ++i) {\\n        //     outStringBytes[i*2] = halfByteToHex(_input[i] >> 4);\\n        //     outStringBytes[i*2+1] = halfByteToHex(_input[i] & 0x0f);\\n        // }\\n        assembly {\\n            let input_curr := add(_input, 0x20)\\n            let input_end := add(input_curr, mload(_input))\\n\\n            for {\\n                let out_curr := add(outStringBytes, 0x20)\\n            } lt(input_curr, input_end) {\\n                input_curr := add(input_curr, 0x01)\\n                out_curr := add(out_curr, 0x02)\\n            } {\\n                let curr_input_byte := shr(0xf8, mload(input_curr))\\n                // here outStringByte from each half of input byte calculates by the next:\\n                //\\n                // \\\"FEDCBA9876543210\\\" ASCII-encoded, shifted and automatically truncated.\\n                // outStringByte = byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byteHalf) * 8)))\\n                mstore(\\n                    out_curr,\\n                    shl(0xf8, shr(mul(shr(0x04, curr_input_byte), 0x08), 0x66656463626139383736353433323130))\\n                )\\n                mstore(\\n                    add(out_curr, 0x01),\\n                    shl(0xf8, shr(mul(and(0x0f, curr_input_byte), 0x08), 0x66656463626139383736353433323130))\\n                )\\n            }\\n        }\\n        return outStringBytes;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Operations.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./Bytes.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\n/// @title zkSync operations tools\\nlibrary Operations {\\n    // Circuit ops and their pubdata (chunks * bytes)\\n\\n    /// @notice zkSync circuit operation type\\n    enum OpType {\\n        Noop,\\n        Deposit,\\n        TransferToNew,\\n        PartialExit,\\n        _CloseAccount, // used for correct op id offset\\n        Transfer,\\n        FullExit,\\n        ChangePubKey,\\n        ForcedExit,\\n        MintNFT,\\n        WithdrawNFT,\\n        Swap\\n    }\\n\\n    // Byte lengths\\n\\n    uint8 internal constant OP_TYPE_BYTES = 1;\\n    uint8 internal constant TOKEN_BYTES = 4;\\n    uint8 internal constant PUBKEY_BYTES = 32;\\n    uint8 internal constant NONCE_BYTES = 4;\\n    uint8 internal constant PUBKEY_HASH_BYTES = 20;\\n    uint8 internal constant ADDRESS_BYTES = 20;\\n    uint8 internal constant CONTENT_HASH_BYTES = 32;\\n    /// @dev Packed fee bytes lengths\\n    uint8 internal constant FEE_BYTES = 2;\\n    /// @dev zkSync account id bytes lengths\\n    uint8 internal constant ACCOUNT_ID_BYTES = 4;\\n    /// @dev zkSync nft serial id bytes lengths\\n    uint8 internal constant NFT_SERIAL_ID_BYTES = 4;\\n    uint8 internal constant AMOUNT_BYTES = 16;\\n    /// @dev Signature (for example full exit signature) bytes length\\n    uint8 internal constant SIGNATURE_BYTES = 64;\\n\\n    // Deposit pubdata\\n    struct Deposit {\\n        // uint8 opType\\n        uint32 accountId;\\n        uint32 tokenId;\\n        uint128 amount;\\n        address owner;\\n    }\\n\\n    uint256 internal constant PACKED_DEPOSIT_PUBDATA_BYTES =\\n        OP_TYPE_BYTES + ACCOUNT_ID_BYTES + TOKEN_BYTES + AMOUNT_BYTES + ADDRESS_BYTES;\\n\\n    /// Deserialize deposit pubdata\\n    function readDepositPubdata(bytes memory _data) internal pure returns (Deposit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.tokenId) = Bytes.readUInt32(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n\\n        require(offset == PACKED_DEPOSIT_PUBDATA_BYTES, \\\"N\\\"); // reading invalid deposit pubdata size\\n    }\\n\\n    /// Serialize deposit pubdata\\n    function writeDepositPubdataForPriorityQueue(Deposit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            uint8(OpType.Deposit),\\n            bytes4(0), // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\\n            op.tokenId, // tokenId\\n            op.amount, // amount\\n            op.owner // owner\\n        );\\n    }\\n\\n    /// @notice Write deposit pubdata for priority queue check.\\n    function checkDepositInPriorityQueue(Deposit memory op, bytes20 hashedPubdata) internal pure returns (bool) {\\n        return Utils.hashBytesToBytes20(writeDepositPubdataForPriorityQueue(op)) == hashedPubdata;\\n    }\\n\\n    // FullExit pubdata\\n\\n    struct FullExit {\\n        // uint8 opType\\n        uint32 accountId;\\n        address owner;\\n        uint32 tokenId;\\n        uint128 amount;\\n        uint32 nftCreatorAccountId;\\n        address nftCreatorAddress;\\n        uint32 nftSerialId;\\n        bytes32 nftContentHash;\\n    }\\n\\n    uint256 public constant PACKED_FULL_EXIT_PUBDATA_BYTES =\\n        OP_TYPE_BYTES +\\n            ACCOUNT_ID_BYTES +\\n            ADDRESS_BYTES +\\n            TOKEN_BYTES +\\n            AMOUNT_BYTES +\\n            ACCOUNT_ID_BYTES +\\n            ADDRESS_BYTES +\\n            NFT_SERIAL_ID_BYTES +\\n            CONTENT_HASH_BYTES;\\n\\n    function readFullExitPubdata(bytes memory _data) internal pure returns (FullExit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n        (offset, parsed.tokenId) = Bytes.readUInt32(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        (offset, parsed.nftCreatorAccountId) = Bytes.readUInt32(_data, offset); // nftCreatorAccountId\\n        (offset, parsed.nftCreatorAddress) = Bytes.readAddress(_data, offset); // nftCreatorAddress\\n        (offset, parsed.nftSerialId) = Bytes.readUInt32(_data, offset); // nftSerialId\\n        (offset, parsed.nftContentHash) = Bytes.readBytes32(_data, offset); // nftContentHash\\n\\n        require(offset == PACKED_FULL_EXIT_PUBDATA_BYTES, \\\"O\\\"); // reading invalid full exit pubdata size\\n    }\\n\\n    function writeFullExitPubdataForPriorityQueue(FullExit memory op) internal pure returns (bytes memory buf) {\\n        buf = abi.encodePacked(\\n            uint8(OpType.FullExit),\\n            op.accountId, // accountId\\n            op.owner, // owner\\n            op.tokenId, // tokenId\\n            uint128(0), // amount -- ignored\\n            uint32(0), // nftCreatorAccountId -- ignored\\n            address(0), // nftCreatorAddress -- ignored\\n            uint32(0), // nftSerialId -- ignored\\n            bytes32(0) // nftContentHash -- ignored\\n        );\\n    }\\n\\n    function checkFullExitInPriorityQueue(FullExit memory op, bytes20 hashedPubdata) internal pure returns (bool) {\\n        return Utils.hashBytesToBytes20(writeFullExitPubdataForPriorityQueue(op)) == hashedPubdata;\\n    }\\n\\n    // PartialExit pubdata\\n\\n    struct PartialExit {\\n        //uint8 opType; -- present in pubdata, ignored at serialization\\n        //uint32 accountId; -- present in pubdata, ignored at serialization\\n        uint32 tokenId;\\n        uint128 amount;\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n        address owner;\\n    }\\n\\n    function readPartialExitPubdata(bytes memory _data) internal pure returns (PartialExit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES; // opType + accountId (ignored)\\n        (offset, parsed.tokenId) = Bytes.readUInt32(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        offset += FEE_BYTES; // fee (ignored)\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n    }\\n\\n    // ForcedExit pubdata\\n\\n    struct ForcedExit {\\n        //uint8 opType; -- present in pubdata, ignored at serialization\\n        //uint32 initiatorAccountId; -- present in pubdata, ignored at serialization\\n        //uint32 targetAccountId; -- present in pubdata, ignored at serialization\\n        uint32 tokenId;\\n        uint128 amount;\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n        address target;\\n    }\\n\\n    function readForcedExitPubdata(bytes memory _data) internal pure returns (ForcedExit memory parsed) {\\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\\n        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES * 2; // opType + initiatorAccountId + targetAccountId (ignored)\\n        (offset, parsed.tokenId) = Bytes.readUInt32(_data, offset); // tokenId\\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\\n        offset += FEE_BYTES; // fee (ignored)\\n        (offset, parsed.target) = Bytes.readAddress(_data, offset); // target\\n    }\\n\\n    // ChangePubKey\\n\\n    enum ChangePubkeyType {ECRECOVER, CREATE2, OldECRECOVER, ECRECOVERV2}\\n\\n    struct ChangePubKey {\\n        // uint8 opType; -- present in pubdata, ignored at serialization\\n        uint32 accountId;\\n        bytes20 pubKeyHash;\\n        address owner;\\n        uint32 nonce;\\n        //uint32 tokenId; -- present in pubdata, ignored at serialization\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n    }\\n\\n    function readChangePubKeyPubdata(bytes memory _data) internal pure returns (ChangePubKey memory parsed) {\\n        uint256 offset = OP_TYPE_BYTES;\\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\\n        (offset, parsed.pubKeyHash) = Bytes.readBytes20(_data, offset); // pubKeyHash\\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\\n        (offset, parsed.nonce) = Bytes.readUInt32(_data, offset); // nonce\\n    }\\n\\n    struct WithdrawNFT {\\n        //uint8 opType; -- present in pubdata, ignored at serialization\\n        //uint32 accountId; -- present in pubdata, ignored at serialization\\n        uint32 creatorAccountId;\\n        address creatorAddress;\\n        uint32 serialId;\\n        bytes32 contentHash;\\n        address receiver;\\n        uint32 tokenId;\\n        //uint32 feeTokenId;\\n        //uint16 fee; -- present in pubdata, ignored at serialization\\n    }\\n\\n    function readWithdrawNFTPubdata(bytes memory _data) internal pure returns (WithdrawNFT memory parsed) {\\n        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES; // opType + accountId (ignored)\\n        (offset, parsed.creatorAccountId) = Bytes.readUInt32(_data, offset);\\n        (offset, parsed.creatorAddress) = Bytes.readAddress(_data, offset);\\n        (offset, parsed.serialId) = Bytes.readUInt32(_data, offset);\\n        (offset, parsed.contentHash) = Bytes.readBytes32(_data, offset);\\n        (offset, parsed.receiver) = Bytes.readAddress(_data, offset);\\n        (offset, parsed.tokenId) = Bytes.readUInt32(_data, offset);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/UpgradeableMaster.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Interface of the upgradeable master contract (defines notice period duration and allows finish upgrade during preparation of it)\\n/// @author Matter Labs\\ninterface UpgradeableMaster {\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external returns (uint256);\\n\\n    /// @notice Notifies contract that notice period started\\n    function upgradeNoticePeriodStarted() external;\\n\\n    /// @notice Notifies contract that upgrade preparation status is activated\\n    function upgradePreparationStarted() external;\\n\\n    /// @notice Notifies contract that upgrade canceled\\n    function upgradeCanceled() external;\\n\\n    /// @notice Notifies contract that upgrade finishes\\n    function upgradeFinishes() external;\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external returns (bool);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/RegenesisMultisig.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Config.sol\\\";\\n\\n/// @title Regenesis Multisig contract\\n/// @author Matter Labs\\ncontract RegenesisMultisig is Ownable, Config {\\n    event CandidateAccepted(bytes32 oldRootHash, bytes32 newRootHash);\\n    event CandidateApproval(uint256 currentApproval);\\n\\n    bytes32 public oldRootHash;\\n    bytes32 public newRootHash;\\n\\n    bytes32 public candidateOldRootHash;\\n    bytes32 public candidateNewRootHash;\\n\\n    /// @dev Stores boolean flags which means the confirmations of the upgrade for each member of security council\\n    mapping(uint256 => bool) internal securityCouncilApproves;\\n    uint256 internal numberOfApprovalsFromSecurityCouncil;\\n\\n    uint256 securityCouncilThreshold;\\n\\n    constructor(uint256 threshold) Ownable(msg.sender) {\\n        securityCouncilThreshold = threshold;\\n    }\\n\\n    function submitHash(bytes32 _oldRootHash, bytes32 _newRootHash) external {\\n        // Only zkSync team can submit the hashes\\n        require(msg.sender == getMaster(), \\\"1\\\");\\n\\n        candidateOldRootHash = _oldRootHash;\\n        candidateNewRootHash = _newRootHash;\\n\\n        oldRootHash = bytes32(0);\\n        newRootHash = bytes32(0);\\n\\n        for (uint256 i = 0; i < SECURITY_COUNCIL_MEMBERS_NUMBER; ++i) {\\n            securityCouncilApproves[i] = false;\\n        }\\n        numberOfApprovalsFromSecurityCouncil = 0;\\n    }\\n\\n    function approveHash(bytes32 _oldRootHash, bytes32 _newRootHash) external {\\n        require(_oldRootHash == candidateOldRootHash, \\\"2\\\");\\n        require(_newRootHash == candidateNewRootHash, \\\"3\\\");\\n\\n        address payable[SECURITY_COUNCIL_MEMBERS_NUMBER] memory SECURITY_COUNCIL_MEMBERS =\\n            [0xa2602ea835E03fb39CeD30B43d6b6EAf6aDe1769,0x9D5d6D4BaCCEDf6ECE1883456AA785dc996df607,0x002A5dc50bbB8d5808e418Aeeb9F060a2Ca17346,0x71E805aB236c945165b9Cd0bf95B9f2F0A0488c3,0x76C6cE74EAb57254E785d1DcC3f812D274bCcB11,0xFBfF3FF69D65A9103Bf4fdBf988f5271D12B3190,0xAfC2F2D803479A2AF3A72022D54cc0901a0ec0d6,0x4d1E3089042Ab3A93E03CA88B566b99Bd22438C6,0x19eD6cc20D44e5cF4Bb4894F50162F72402d8567,0x39415255619783A2E71fcF7d8f708A951d92e1b6,0x399a6a13D298CF3F41a562966C1a450136Ea52C2,0xee8AE1F1B4B1E1956C8Bda27eeBCE54Cf0bb5eaB,0xe7CCD4F3feA7df88Cf9B59B30f738ec1E049231f,0xA093284c707e207C36E3FEf9e0B6325fd9d0e33B,0x225d3822De44E58eE935440E0c0B829C4232086e];\\n        for (uint256 id = 0; id < SECURITY_COUNCIL_MEMBERS_NUMBER; ++id) {\\n            if (SECURITY_COUNCIL_MEMBERS[id] == msg.sender) {\\n                require(securityCouncilApproves[id] == false);\\n                securityCouncilApproves[id] = true;\\n                numberOfApprovalsFromSecurityCouncil++;\\n                emit CandidateApproval(numberOfApprovalsFromSecurityCouncil);\\n\\n                // It is ok to check for strict equality since the numberOfApprovalsFromSecurityCouncil\\n                // is increased by one at a time. It is better to do so not to emit the\\n                // CandidateAccepted event more than once\\n                if (numberOfApprovalsFromSecurityCouncil == securityCouncilThreshold) {\\n                    oldRootHash = candidateOldRootHash;\\n                    newRootHash = candidateNewRootHash;\\n                    emit CandidateAccepted(oldRootHash, newRootHash);\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/AdditionalZkSync.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeMathUInt128.sol\\\";\\nimport \\\"./SafeCast.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\nimport \\\"./Storage.sol\\\";\\nimport \\\"./Config.sol\\\";\\nimport \\\"./Events.sol\\\";\\n\\nimport \\\"./Bytes.sol\\\";\\nimport \\\"./Operations.sol\\\";\\n\\nimport \\\"./UpgradeableMaster.sol\\\";\\n\\n/// @title zkSync additional main contract\\n/// @author Matter Labs\\ncontract AdditionalZkSync is Storage, Config, Events, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using SafeMathUInt128 for uint128;\\n\\n    function increaseBalanceToWithdraw(bytes22 _packedBalanceKey, uint128 _amount) internal {\\n        uint128 balance = pendingBalances[_packedBalanceKey].balanceToWithdraw;\\n        pendingBalances[_packedBalanceKey] = PendingBalance(balance.add(_amount), FILLED_GAS_RESERVE_VALUE);\\n    }\\n\\n    /// @notice Withdraws token from ZkSync to root chain in case of exodus mode. User must provide proof that he owns funds\\n    /// @param _storedBlockInfo Last verified block\\n    /// @param _owner Owner of the account\\n    /// @param _accountId Id of the account in the tree\\n    /// @param _proof Proof\\n    /// @param _tokenId Verified token id\\n    /// @param _amount Amount for owner (must be total amount, not part of it)\\n    function performExodus(\\n        StoredBlockInfo memory _storedBlockInfo,\\n        address _owner,\\n        uint32 _accountId,\\n        uint32 _tokenId,\\n        uint128 _amount,\\n        uint32 _nftCreatorAccountId,\\n        address _nftCreatorAddress,\\n        uint32 _nftSerialId,\\n        bytes32 _nftContentHash,\\n        uint256[] memory _proof\\n    ) external {\\n        require(_accountId <= MAX_ACCOUNT_ID, \\\"e\\\");\\n        require(_accountId != SPECIAL_ACCOUNT_ID, \\\"v\\\");\\n        require(_tokenId < SPECIAL_NFT_TOKEN_ID, \\\"T\\\");\\n\\n        require(exodusMode, \\\"s\\\"); // must be in exodus mode\\n        require(!performedExodus[_accountId][_tokenId], \\\"t\\\"); // already exited\\n        require(storedBlockHashes[totalBlocksExecuted] == hashStoredBlockInfo(_storedBlockInfo), \\\"u\\\"); // incorrect stored block info\\n\\n        bool proofCorrect =\\n            verifier.verifyExitProof(\\n                _storedBlockInfo.stateHash,\\n                _accountId,\\n                _owner,\\n                _tokenId,\\n                _amount,\\n                _nftCreatorAccountId,\\n                _nftCreatorAddress,\\n                _nftSerialId,\\n                _nftContentHash,\\n                _proof\\n            );\\n        require(proofCorrect, \\\"x\\\");\\n\\n        if (_tokenId <= MAX_FUNGIBLE_TOKEN_ID) {\\n            bytes22 packedBalanceKey = packAddressAndTokenId(_owner, uint16(_tokenId));\\n            increaseBalanceToWithdraw(packedBalanceKey, _amount);\\n            emit WithdrawalPending(uint16(_tokenId), _amount);\\n        } else {\\n            require(_amount != 0, \\\"Z\\\"); // Unsupported nft amount\\n            Operations.WithdrawNFT memory withdrawNftOp =\\n                Operations.WithdrawNFT(\\n                    _nftCreatorAccountId,\\n                    _nftCreatorAddress,\\n                    _nftSerialId,\\n                    _nftContentHash,\\n                    _owner,\\n                    _tokenId\\n                );\\n            pendingWithdrawnNFTs[_tokenId] = withdrawNftOp;\\n            emit WithdrawalNFTPending(_tokenId);\\n        }\\n        performedExodus[_accountId][_tokenId] = true;\\n    }\\n\\n    function cancelOutstandingDepositsForExodusMode(uint64 _n, bytes[] memory _depositsPubdata) external {\\n        require(exodusMode, \\\"8\\\"); // exodus mode not active\\n        uint64 toProcess = Utils.minU64(totalOpenPriorityRequests, _n);\\n        require(toProcess > 0, \\\"9\\\"); // no deposits to process\\n        uint64 currentDepositIdx = 0;\\n        for (uint64 id = firstPriorityRequestId; id < firstPriorityRequestId + toProcess; id++) {\\n            if (priorityRequests[id].opType == Operations.OpType.Deposit) {\\n                bytes memory depositPubdata = _depositsPubdata[currentDepositIdx];\\n                require(Utils.hashBytesToBytes20(depositPubdata) == priorityRequests[id].hashedPubData, \\\"a\\\");\\n                ++currentDepositIdx;\\n\\n                Operations.Deposit memory op = Operations.readDepositPubdata(depositPubdata);\\n                bytes22 packedBalanceKey = packAddressAndTokenId(op.owner, uint16(op.tokenId));\\n                pendingBalances[packedBalanceKey].balanceToWithdraw += op.amount;\\n            }\\n            delete priorityRequests[id];\\n        }\\n        firstPriorityRequestId += toProcess;\\n        totalOpenPriorityRequests -= toProcess;\\n    }\\n\\n    uint256 internal constant SECURITY_COUNCIL_2_WEEKS_THRESHOLD = 8;\\n    uint256 internal constant SECURITY_COUNCIL_1_WEEK_THRESHOLD = 10;\\n    uint256 internal constant SECURITY_COUNCIL_3_DAYS_THRESHOLD = 12;\\n\\n    function cutUpgradeNoticePeriod() external {\\n        requireActive();\\n\\n        address payable[SECURITY_COUNCIL_MEMBERS_NUMBER] memory SECURITY_COUNCIL_MEMBERS =\\n            [0xa2602ea835E03fb39CeD30B43d6b6EAf6aDe1769,0x9D5d6D4BaCCEDf6ECE1883456AA785dc996df607,0x002A5dc50bbB8d5808e418Aeeb9F060a2Ca17346,0x71E805aB236c945165b9Cd0bf95B9f2F0A0488c3,0x76C6cE74EAb57254E785d1DcC3f812D274bCcB11,0xFBfF3FF69D65A9103Bf4fdBf988f5271D12B3190,0xAfC2F2D803479A2AF3A72022D54cc0901a0ec0d6,0x4d1E3089042Ab3A93E03CA88B566b99Bd22438C6,0x19eD6cc20D44e5cF4Bb4894F50162F72402d8567,0x39415255619783A2E71fcF7d8f708A951d92e1b6,0x399a6a13D298CF3F41a562966C1a450136Ea52C2,0xee8AE1F1B4B1E1956C8Bda27eeBCE54Cf0bb5eaB,0xe7CCD4F3feA7df88Cf9B59B30f738ec1E049231f,0xA093284c707e207C36E3FEf9e0B6325fd9d0e33B,0x225d3822De44E58eE935440E0c0B829C4232086e];\\n        for (uint256 id = 0; id < SECURITY_COUNCIL_MEMBERS_NUMBER; ++id) {\\n            if (SECURITY_COUNCIL_MEMBERS[id] == msg.sender) {\\n                require(upgradeStartTimestamp != 0);\\n                require(securityCouncilApproves[id] == false);\\n                securityCouncilApproves[id] = true;\\n                numberOfApprovalsFromSecurityCouncil++;\\n\\n                if (numberOfApprovalsFromSecurityCouncil == SECURITY_COUNCIL_2_WEEKS_THRESHOLD) {\\n                    if (approvedUpgradeNoticePeriod > 2 weeks) {\\n                        approvedUpgradeNoticePeriod = 2 weeks;\\n                        emit NoticePeriodChange(approvedUpgradeNoticePeriod);\\n                    }\\n                } else if (numberOfApprovalsFromSecurityCouncil == SECURITY_COUNCIL_1_WEEK_THRESHOLD) {\\n                    if (approvedUpgradeNoticePeriod > 1 weeks) {\\n                        approvedUpgradeNoticePeriod = 1 weeks;\\n                        emit NoticePeriodChange(approvedUpgradeNoticePeriod);\\n                    }\\n                } else if (numberOfApprovalsFromSecurityCouncil == SECURITY_COUNCIL_3_DAYS_THRESHOLD) {\\n                    if (approvedUpgradeNoticePeriod > 3 days) {\\n                        approvedUpgradeNoticePeriod = 3 days;\\n                        emit NoticePeriodChange(approvedUpgradeNoticePeriod);\\n                    }\\n                }\\n\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @notice Set data for changing pubkey hash using onchain authorization.\\n    ///         Transaction author (msg.sender) should be L2 account address\\n    /// @notice New pubkey hash can be reset, to do that user should send two transactions:\\n    ///         1) First `setAuthPubkeyHash` transaction for already used `_nonce` will set timer.\\n    ///         2) After `AUTH_FACT_RESET_TIMELOCK` time is passed second `setAuthPubkeyHash` transaction will reset pubkey hash for `_nonce`.\\n    /// @param _pubkeyHash New pubkey hash\\n    /// @param _nonce Nonce of the change pubkey L2 transaction\\n    function setAuthPubkeyHash(bytes calldata _pubkeyHash, uint32 _nonce) external {\\n        requireActive();\\n\\n        require(_pubkeyHash.length == PUBKEY_HASH_BYTES, \\\"y\\\"); // PubKeyHash should be 20 bytes.\\n        if (authFacts[msg.sender][_nonce] == bytes32(0)) {\\n            authFacts[msg.sender][_nonce] = keccak256(_pubkeyHash);\\n        } else {\\n            uint256 currentResetTimer = authFactsResetTimer[msg.sender][_nonce];\\n            if (currentResetTimer == 0) {\\n                authFactsResetTimer[msg.sender][_nonce] = block.timestamp;\\n            } else {\\n                require(block.timestamp.sub(currentResetTimer) >= AUTH_FACT_RESET_TIMELOCK, \\\"z\\\");\\n                authFactsResetTimer[msg.sender][_nonce] = 0;\\n                authFacts[msg.sender][_nonce] = keccak256(_pubkeyHash);\\n            }\\n        }\\n    }\\n\\n    /// @notice Reverts unverified blocks\\n    function revertBlocks(StoredBlockInfo[] memory _blocksToRevert) external {\\n        requireActive();\\n\\n        governance.requireActiveValidator(msg.sender);\\n\\n        uint32 blocksCommitted = totalBlocksCommitted;\\n        uint32 blocksToRevert = Utils.minU32(uint32(_blocksToRevert.length), blocksCommitted - totalBlocksExecuted);\\n        uint64 revertedPriorityRequests = 0;\\n\\n        for (uint32 i = 0; i < blocksToRevert; ++i) {\\n            StoredBlockInfo memory storedBlockInfo = _blocksToRevert[i];\\n            require(storedBlockHashes[blocksCommitted] == hashStoredBlockInfo(storedBlockInfo), \\\"r\\\"); // incorrect stored block info\\n\\n            delete storedBlockHashes[blocksCommitted];\\n\\n            --blocksCommitted;\\n            revertedPriorityRequests += storedBlockInfo.priorityOperations;\\n        }\\n\\n        totalBlocksCommitted = blocksCommitted;\\n        totalCommittedPriorityRequests -= revertedPriorityRequests;\\n        if (totalBlocksCommitted < totalBlocksProven) {\\n            totalBlocksProven = totalBlocksCommitted;\\n        }\\n\\n        emit BlocksRevert(totalBlocksExecuted, blocksCommitted);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Governance.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Config.sol\\\";\\nimport \\\"./Utils.sol\\\";\\nimport \\\"./NFTFactory.sol\\\";\\nimport \\\"./TokenGovernance.sol\\\";\\n\\n/// @title Governance Contract\\n/// @author Matter Labs\\ncontract Governance is Config {\\n    /// @notice Token added to Franklin net\\n    event NewToken(address indexed token, uint16 indexed tokenId);\\n\\n    /// @notice Default nft factory has set\\n    event SetDefaultNFTFactory(address indexed factory);\\n\\n    /// @notice NFT factory registered new creator account\\n    event NFTFactoryRegisteredCreator(\\n        uint32 indexed creatorAccountId,\\n        address indexed creatorAddress,\\n        address factoryAddress\\n    );\\n\\n    /// @notice Governor changed\\n    event NewGovernor(address newGovernor);\\n\\n    /// @notice Token Governance changed\\n    event NewTokenGovernance(TokenGovernance newTokenGovernance);\\n\\n    /// @notice Validator's status changed\\n    event ValidatorStatusUpdate(address indexed validatorAddress, bool isActive);\\n\\n    event TokenPausedUpdate(address indexed token, bool paused);\\n\\n    /// @notice Address which will exercise governance over the network i.e. add tokens, change validator set, conduct upgrades\\n    address public networkGovernor;\\n\\n    /// @notice Total number of ERC20 tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 public totalTokens;\\n\\n    /// @notice List of registered tokens by tokenId\\n    mapping(uint16 => address) public tokenAddresses;\\n\\n    /// @notice List of registered tokens by address\\n    mapping(address => uint16) public tokenIds;\\n\\n    /// @notice List of permitted validators\\n    mapping(address => bool) public validators;\\n\\n    /// @notice Paused tokens list, deposits are impossible to create for paused tokens\\n    mapping(uint16 => bool) public pausedTokens;\\n\\n    /// @notice Address that is authorized to add tokens to the Governance.\\n    TokenGovernance public tokenGovernance;\\n\\n    /// @notice NFT Creator address to factory address mapping\\n    mapping(uint32 => mapping(address => NFTFactory)) public nftFactories;\\n\\n    /// @notice Address which will be used if NFT token has no factories\\n    NFTFactory public defaultFactory;\\n\\n    /// @notice Governance contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param initializationParameters Encoded representation of initialization parameters:\\n    ///     _networkGovernor The address of network governor\\n    function initialize(bytes calldata initializationParameters) external {\\n        address _networkGovernor = abi.decode(initializationParameters, (address));\\n\\n        networkGovernor = _networkGovernor;\\n    }\\n\\n    /// @notice Governance contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    // solhint-disable-next-line no-empty-blocks\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    /// @notice Change current governor\\n    /// @param _newGovernor Address of the new governor\\n    function changeGovernor(address _newGovernor) external {\\n        requireGovernor(msg.sender);\\n        if (networkGovernor != _newGovernor) {\\n            networkGovernor = _newGovernor;\\n            emit NewGovernor(_newGovernor);\\n        }\\n    }\\n\\n    /// @notice Change current token governance\\n    /// @param _newTokenGovernance Address of the new token governor\\n    function changeTokenGovernance(TokenGovernance _newTokenGovernance) external {\\n        requireGovernor(msg.sender);\\n        if (tokenGovernance != _newTokenGovernance) {\\n            tokenGovernance = _newTokenGovernance;\\n            emit NewTokenGovernance(_newTokenGovernance);\\n        }\\n    }\\n\\n    /// @notice Add token to the list of networks tokens\\n    /// @param _token Token address\\n    function addToken(address _token) external {\\n        require(msg.sender == address(tokenGovernance), \\\"1E\\\");\\n        require(tokenIds[_token] == 0, \\\"1e\\\"); // token exists\\n        require(totalTokens < MAX_AMOUNT_OF_REGISTERED_TOKENS, \\\"1f\\\"); // no free identifiers for tokens\\n\\n        totalTokens++;\\n        uint16 newTokenId = totalTokens; // it is not `totalTokens - 1` because tokenId = 0 is reserved for eth\\n\\n        tokenAddresses[newTokenId] = _token;\\n        tokenIds[_token] = newTokenId;\\n        emit NewToken(_token, newTokenId);\\n    }\\n\\n    /// @notice Pause token deposits for the given token\\n    /// @param _tokenAddr Token address\\n    /// @param _tokenPaused Token paused status\\n    function setTokenPaused(address _tokenAddr, bool _tokenPaused) external {\\n        requireGovernor(msg.sender);\\n\\n        uint16 tokenId = this.validateTokenAddress(_tokenAddr);\\n        if (pausedTokens[tokenId] != _tokenPaused) {\\n            pausedTokens[tokenId] = _tokenPaused;\\n            emit TokenPausedUpdate(_tokenAddr, _tokenPaused);\\n        }\\n    }\\n\\n    /// @notice Change validator status (active or not active)\\n    /// @param _validator Validator address\\n    /// @param _active Active flag\\n    function setValidator(address _validator, bool _active) external {\\n        requireGovernor(msg.sender);\\n        if (validators[_validator] != _active) {\\n            validators[_validator] = _active;\\n            emit ValidatorStatusUpdate(_validator, _active);\\n        }\\n    }\\n\\n    /// @notice Check if specified address is is governor\\n    /// @param _address Address to check\\n    function requireGovernor(address _address) public view {\\n        require(_address == networkGovernor, \\\"1g\\\"); // only by governor\\n    }\\n\\n    /// @notice Checks if validator is active\\n    /// @param _address Validator address\\n    function requireActiveValidator(address _address) external view {\\n        require(validators[_address], \\\"1h\\\"); // validator is not active\\n    }\\n\\n    /// @notice Validate token id (must be less than or equal to total tokens amount)\\n    /// @param _tokenId Token id\\n    /// @return bool flag that indicates if token id is less than or equal to total tokens amount\\n    function isValidTokenId(uint16 _tokenId) external view returns (bool) {\\n        return _tokenId <= totalTokens;\\n    }\\n\\n    /// @notice Validate token address\\n    /// @param _tokenAddr Token address\\n    /// @return tokens id\\n    function validateTokenAddress(address _tokenAddr) external view returns (uint16) {\\n        uint16 tokenId = tokenIds[_tokenAddr];\\n        require(tokenId != 0, \\\"1i\\\"); // 0 is not a valid token\\n        return tokenId;\\n    }\\n\\n    function packRegisterNFTFactoryMsg(\\n        uint32 _creatorAccountId,\\n        address _creatorAddress,\\n        address _factoryAddress\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n141\\\",\\n                \\\"\\\\nCreator's account ID in zkSync: \\\",\\n                Bytes.bytesToHexASCIIBytes(abi.encodePacked((_creatorAccountId))),\\n                \\\"\\\\nCreator: \\\",\\n                Bytes.bytesToHexASCIIBytes(abi.encodePacked((_creatorAddress))),\\n                \\\"\\\\nFactory: \\\",\\n                Bytes.bytesToHexASCIIBytes(abi.encodePacked((_factoryAddress)))\\n            );\\n    }\\n\\n    /// @notice Register creator corresponding to the factory\\n    /// @param _creatorAccountId Creator's zkSync account ID\\n    /// @param _creatorAddress NFT creator address\\n    /// @param _signature Creator's signature\\n    function registerNFTFactoryCreator(\\n        uint32 _creatorAccountId,\\n        address _creatorAddress,\\n        bytes memory _signature\\n    ) external {\\n        require(address(nftFactories[_creatorAccountId][_creatorAddress]) == address(0), \\\"Q\\\");\\n        bytes32 messageHash = keccak256(packRegisterNFTFactoryMsg(_creatorAccountId, _creatorAddress, msg.sender));\\n\\n        address recoveredAddress = Utils.recoverAddressFromEthSignature(_signature, messageHash);\\n        require(recoveredAddress == _creatorAddress && recoveredAddress != address(0), \\\"ws\\\");\\n        nftFactories[_creatorAccountId][_creatorAddress] = NFTFactory(msg.sender);\\n        emit NFTFactoryRegisteredCreator(_creatorAccountId, _creatorAddress, msg.sender);\\n    }\\n\\n    //@notice Set default factory for our contract. This factory will be used to mint an NFT token that has no factory\\n    //@param _factory Address of NFT factory\\n    function setDefaultNFTFactory(address _factory) external {\\n        requireGovernor(msg.sender);\\n        require(address(_factory) != address(0), \\\"mb1\\\"); // Factory should be non zero\\n        require(address(defaultFactory) == address(0), \\\"mb2\\\"); // NFTFactory is already set\\n        defaultFactory = NFTFactory(_factory);\\n        emit SetDefaultNFTFactory(_factory);\\n    }\\n\\n    function getNFTFactory(uint32 _creatorAccountId, address _creatorAddress) external view returns (NFTFactory) {\\n        NFTFactory _factory = nftFactories[_creatorAccountId][_creatorAddress];\\n        if (address(_factory) == address(0)) {\\n            require(address(defaultFactory) != address(0), \\\"fs\\\"); // NFTFactory does not set\\n            return defaultFactory;\\n        } else {\\n            return _factory;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Verifier.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\nimport \\\"./KeysWithPlonkVerifier.sol\\\";\\nimport \\\"./Config.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract Verifier is KeysWithPlonkVerifier, KeysWithPlonkVerifierOld, Config {\\n    // solhint-disable-next-line no-empty-blocks\\n    function initialize(bytes calldata) external {}\\n\\n    /// @notice Verifier contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    // solhint-disable-next-line no-empty-blocks\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    function verifyAggregatedBlockProof(\\n        uint256[] memory _recursiveInput,\\n        uint256[] memory _proof,\\n        uint8[] memory _vkIndexes,\\n        uint256[] memory _individualVksInputs,\\n        uint256[16] memory _subproofsLimbs\\n    ) external view returns (bool) {\\n        for (uint256 i = 0; i < _individualVksInputs.length; ++i) {\\n            uint256 commitment = _individualVksInputs[i];\\n            _individualVksInputs[i] = commitment & INPUT_MASK;\\n        }\\n        VerificationKey memory vk = getVkAggregated(uint32(_vkIndexes.length));\\n\\n        return\\n            verify_serialized_proof_with_recursion(\\n                _recursiveInput,\\n                _proof,\\n                VK_TREE_ROOT,\\n                VK_MAX_INDEX,\\n                _vkIndexes,\\n                _individualVksInputs,\\n                _subproofsLimbs,\\n                vk\\n            );\\n    }\\n\\n    function verifyExitProof(\\n        bytes32 _rootHash,\\n        uint32 _accountId,\\n        address _owner,\\n        uint32 _tokenId,\\n        uint128 _amount,\\n        uint32 _nftCreatorAccountId,\\n        address _nftCreatorAddress,\\n        uint32 _nftSerialId,\\n        bytes32 _nftContentHash,\\n        uint256[] calldata _proof\\n    ) external view returns (bool) {\\n        bytes32 commitment =\\n            sha256(\\n                abi.encodePacked(\\n                    _rootHash,\\n                    _accountId,\\n                    _owner,\\n                    _tokenId,\\n                    _amount,\\n                    _nftCreatorAccountId,\\n                    _nftCreatorAddress,\\n                    _nftSerialId,\\n                    _nftContentHash\\n                )\\n            );\\n\\n        uint256[] memory inputs = new uint256[](1);\\n        inputs[0] = uint256(commitment) & INPUT_MASK;\\n        ProofOld memory proof = deserialize_proof_old(inputs, _proof);\\n        VerificationKeyOld memory vk = getVkExit();\\n        require(vk.num_inputs == inputs.length, \\\"n1\\\");\\n        return verify_old(proof, vk);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/NFTFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\ninterface NFTFactory {\\n    function mintNFTFromZkSync(\\n        address creator,\\n        address recipient,\\n        uint32 creatorAccountId,\\n        uint32 serialId,\\n        bytes32 contentHash,\\n        // Even though the token id can fit into the uint32, we still use\\n        // the uint256 to preserve consistency with the ERC721 parent contract\\n        uint256 tokenId\\n    ) external;\\n\\n    event MintNFTFromZkSync(\\n        address indexed creator,\\n        address indexed recipient,\\n        uint32 creatorAccountId,\\n        uint32 serialId,\\n        bytes32 contentHash,\\n        uint256 tokenId\\n    );\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/TokenGovernance.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Governance.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\n/// @title Token Governance Contract\\n/// @author Matter Labs\\n/// @notice Contract is used to allow anyone to add new ERC20 tokens to zkSync given sufficient payment\\ncontract TokenGovernance {\\n    /// @notice Token lister added or removed (see `tokenLister`)\\n    event TokenListerUpdate(address indexed tokenLister, bool isActive);\\n\\n    /// @notice Listing fee token set\\n    event ListingFeeTokenUpdate(IERC20 indexed newListingFeeToken);\\n\\n    /// @notice Listing fee set\\n    event ListingFeeUpdate(uint256 newListingFee);\\n\\n    /// @notice Maximum number of listed tokens updated\\n    event ListingCapUpdate(uint16 newListingCap);\\n\\n    /// @notice The treasury (the account which will receive the fee) was updated\\n    event TreasuryUpdate(address newTreasury);\\n\\n    /// @notice zkSync governance contract\\n    Governance public governance;\\n\\n    /// @notice Token used to collect listing fee for addition of new token to zkSync network\\n    IERC20 public listingFeeToken;\\n\\n    /// @notice Token listing fee\\n    uint256 public listingFee;\\n\\n    /// @notice Max number of tokens that can be listed using this contract\\n    uint16 public listingCap;\\n\\n    /// @notice Addresses that can list tokens without fee\\n    mapping(address => bool) public tokenLister;\\n\\n    /// @notice Address that collects listing payments\\n    address public treasury;\\n\\n    constructor(\\n        Governance _governance,\\n        IERC20 _listingFeeToken,\\n        uint256 _listingFee,\\n        uint16 _listingCap,\\n        address _treasury\\n    ) {\\n        governance = _governance;\\n        listingFeeToken = _listingFeeToken;\\n        listingFee = _listingFee;\\n        listingCap = _listingCap;\\n        treasury = _treasury;\\n\\n        address governor = governance.networkGovernor();\\n        // We add zkSync governor as a first token lister.\\n        tokenLister[governor] = true;\\n        emit TokenListerUpdate(governor, true);\\n    }\\n\\n    /// @notice Adds new ERC20 token to zkSync network.\\n    /// @notice If caller is not present in the `tokenLister` map payment of `listingFee` in `listingFeeToken` should be made.\\n    /// @notice NOTE: before calling this function make sure to approve `listingFeeToken` transfer for this contract.\\n    function addToken(address _token) external {\\n        require(governance.totalTokens() < listingCap, \\\"can't add more tokens\\\"); // Impossible to add more tokens using this contract\\n        if (!tokenLister[msg.sender]) {\\n            // Collect fees\\n            bool feeTransferOk = Utils.transferFromERC20(listingFeeToken, msg.sender, treasury, listingFee);\\n            require(feeTransferOk, \\\"fee transfer failed\\\"); // Failed to receive payment for token addition.\\n        }\\n        governance.addToken(_token);\\n    }\\n\\n    /// Governance functions (this contract is governed by zkSync governor)\\n\\n    /// @notice Set new listing token and fee\\n    /// @notice Can be called only by zkSync governor\\n    function setListingFeeToken(IERC20 _newListingFeeToken, uint256 _newListingFee) external {\\n        governance.requireGovernor(msg.sender);\\n        listingFeeToken = _newListingFeeToken;\\n        listingFee = _newListingFee;\\n\\n        emit ListingFeeTokenUpdate(_newListingFeeToken);\\n    }\\n\\n    /// @notice Set new listing fee\\n    /// @notice Can be called only by zkSync governor\\n    function setListingFee(uint256 _newListingFee) external {\\n        governance.requireGovernor(msg.sender);\\n        listingFee = _newListingFee;\\n\\n        emit ListingFeeUpdate(_newListingFee);\\n    }\\n\\n    /// @notice Enable or disable token lister. If enabled new tokens can be added by that address without payment\\n    /// @notice Can be called only by zkSync governor\\n    function setLister(address _listerAddress, bool _active) external {\\n        governance.requireGovernor(msg.sender);\\n        if (tokenLister[_listerAddress] != _active) {\\n            tokenLister[_listerAddress] = _active;\\n            emit TokenListerUpdate(_listerAddress, _active);\\n        }\\n    }\\n\\n    /// @notice Change maximum amount of tokens that can be listed using this method\\n    /// @notice Can be called only by zkSync governor\\n    function setListingCap(uint16 _newListingCap) external {\\n        governance.requireGovernor(msg.sender);\\n        listingCap = _newListingCap;\\n\\n        emit ListingCapUpdate(_newListingCap);\\n    }\\n\\n    /// @notice Change address that collects payments for listing tokens.\\n    /// @notice Can be called only by zkSync governor\\n    function setTreasury(address _newTreasury) external {\\n        governance.requireGovernor(msg.sender);\\n        treasury = _newTreasury;\\n\\n        emit TreasuryUpdate(_newTreasury);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/KeysWithPlonkVerifier.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./PlonkCore.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract KeysWithPlonkVerifier is VerifierWithDeserialize {\\n\\n    uint256 constant VK_TREE_ROOT = 0x12d3ca8e7e185734779f3969f1d0a9dbb357a737ed605c37c7157c341012e6d9;\\n    uint8 constant VK_MAX_INDEX = 3;\\n\\n    function getVkAggregated(uint32 _proofs) internal pure returns (VerificationKey memory vk) {\\n        if (_proofs == uint32(1)) { return getVkAggregated1(); }\\n        else if (_proofs == uint32(4)) { return getVkAggregated4(); }\\n        else if (_proofs == uint32(8)) { return getVkAggregated8(); }\\n    }\\n\\n    \\n    function getVkAggregated1() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 4194304;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x18c95f1ae6514e11a1b30fd7923947c5ffcec5347f16e91b4dd654168326bede);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x19fbd6706b4cbde524865701eae0ae6a270608a09c3afdab7760b685c1c6c41b,\\n            0x25082a191f0690c175cc9af1106c6c323b5b5de4e24dc23be1e965e1851bca48\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x16c02d9ca95023d1812a58d16407d1ea065073f02c916290e39242303a8a1d8e,\\n            0x230338b422ce8533e27cd50086c28cb160cf05a7ae34ecd5899dbdf449dc7ce0\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x1db0d133243750e1ea692050bbf6068a49dc9f6bae1f11960b6ce9e10adae0f5,\\n            0x12a453ed0121ae05de60848b4374d54ae4b7127cb307372e14e8daf5097c5123\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x1062ed5e86781fd34f78938e5950c2481a79f132085d2bc7566351ddff9fa3b7,\\n            0x2fd7aac30f645293cc99883ab57d8c99a518d5b4ab40913808045e8653497346\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x062755048bb95739f845e8659795813127283bf799443d62fea600ae23e7f263,\\n            0x2af86098beaa241281c78a454c5d1aa6e9eedc818c96cd1e6518e1ac2d26aa39\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x0994e25148bbd25be655034f81062d1ebf0a1c2b41e0971434beab1ae8101474,\\n            0x27cc8cfb1fafd13068aeee0e08a272577d89f8aa0fb8507aabbc62f37587b98f\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x044edf69ce10cfb6206795f92c3be2b0d26ab9afd3977b789840ee58c7dbe927,\\n            0x2a8aa20c106f8dc7e849bc9698064dcfa9ed0a4050d794a1db0f13b0ee3def37\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x136967f1a2696db05583a58dbf8971c5d9d1dc5f5c97e88f3b4822aa52fefa1c,\\n            0x127b41299ea5c840c3b12dbe7b172380f432b7b63ce3b004750d6abb9e7b3b7a\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x02fd5638bf3cc2901395ad1124b951e474271770a337147a2167e9797ab9d951,\\n            0x0fcb2e56b077c8461c36911c9252008286d782e96030769bf279024fc81d412a\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x1865c60ecad86f81c6c952445707203c9c7fdace3740232ceb704aefd5bd45b3,\\n            0x2f35e29b39ec8bb054e2cff33c0299dd13f8c78ea24a07622128a7444aba3f26\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x2a86ec9c6c1f903650b5abbf0337be556b03f79aecc4d917e90c7db94518dde6,\\n            0x15b1b6be641336eebd58e7991be2991debbbd780e70c32b49225aa98d10b7016\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x213e42fcec5297b8e01a602684fcd412208d15bdac6b6331a8819d478ba46899,\\n            0x03223485f4e808a3b2496ae1a3c0dfbcbf4391cffc57ee01e8fca114636ead18\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x2e9b02f8cf605ad1a36e99e990a07d435de06716448ad53053c7a7a5341f71e1,\\n            0x2d6fdf0bc8bd89112387b1894d6f24b45dcb122c09c84344b6fc77a619dd1d59\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkAggregated4() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 8388608;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x1283ba6f4b7b1a76ba2008fe823128bea4adb9269cbfd7c41c223be65bc60863);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x2988e24b15bce9a1e3a4d1d9a8f7c7a65db6c29fd4c6f4afe1a3fbd954d4b4b6,\\n            0x0bdb6e5ba27a22e03270c7c71399b866b28d7cec504d30e665d67be58e306e12\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x20f3d30d3a91a7419d658f8c035e42a811c9f75eac2617e65729033286d36089,\\n            0x07ac91e8194eb78a9db537e9459dd6ca26bef8770dde54ac3dd396450b1d4cfe\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x0311872bab6df6e9095a9afe40b12e2ed58f00cc88835442e6b4cf73fb3e147d,\\n            0x2cdfc5b5e73737809b54644b2f96494f8fcc1dd0fb440f64f44930b432c4542d\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x28fd545b1e960d2eff3142271affa4096ef724212031fdabe22dd4738f36472b,\\n            0x2c743150ee9894ff3965d8f1129399a3b89a1a9289d4cfa904b0a648d3a8a9fa\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x2c283ce950eee1173b78657e57c80658a8398e7970a9a45b20cd39aff16ad61a,\\n            0x081c003cbd09f7c3e0d723d6ebbaf432421c188d5759f5ee8ff1ee1dc357d4a8\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x2eb50a2dd293a71a0c038e958c5237bd7f50b2f0c9ee6385895a553de1517d43,\\n            0x15fdc2b5b28fc351f987b98aa6caec7552cefbafa14e6651061eec4f41993b65\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x17a9403e5c846c1ca5e767c89250113aa156fdb1f026aa0b4db59c09d06816ec,\\n            0x2512241972ca3ee4839ac72a4cab39ddb413a7553556abd7909284b34ee73f6b\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x09edd69c8baa7928b16615e993e3032bc8cbf9f42bfa3cf28caba1078d371edb,\\n            0x12e5c39148af860a87b14ae938f33eafa91deeb548cda4cc23ed9ba3e6e496b8\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x0e25c0027706ca3fd3daae849f7c50ec88d4d030da02452001dec7b554cc71b4,\\n            0x2421da0ca385ff7ba9e5ae68890655669248c8c8187e67d12b2a7ae97e2cff8b\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x151536359fe184567bce57379833f6fae485e5cc9bc27423d83d281aaf2701df,\\n            0x116beb145bc27faae5a8ae30c28040d3baafb3ea47360e528227b94adb9e4f26\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x23ee338093db23364a6e44acfb60d810a4c4bd6565b185374f7840152d3ae82c,\\n            0x0f6714f3ee113b9dfb6b653f04bf497602588b16b96ac682d9a5dd880a0aa601\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x05860b0ea3c6f22150812aee304bf35e1a95cfa569a8da52b42dba44a122378a,\\n            0x19e5a9f3097289272e65e842968752c5355d1cdb2d3d737050e4dfe32ebe1e41\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x3046881fcbe369ac6f99fea8b9505de85ded3de3bc445060be4bc6ef651fa352,\\n            0x06fe14c1dd6c2f2b48aebeb6fd525573d276b2e148ad25e75c57a58588f755ec\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkAggregated8() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 16777216;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x1951441010b2b95a6e47a6075066a50a036f5ba978c050f2821df86636c0facb);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x218bdb295b7207114aeea948e2d3baef158d4057812f94005d8ff54341b6ce6f,\\n            0x1398585c039ba3cf336687301e95fbbf6b0638d31c64b1d815bb49091d0c1aad\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x2e40b8a98e688c9e00f607a64520a850d35f277dc0b645628494337bb75870e8,\\n            0x2da4ef753cc4869e53cff171009dbffea9166b8ffbafd17783d712278a79f13e\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x1b638de3c6cc2e0badc48305ee3533678a45f52edf30277303551128772303a2,\\n            0x2794c375cbebb7c28379e8abf42d529a1c291319020099935550c83796ba14ac\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x189cd01d67b44cf2c1e10765c69adaafd6a5929952cf55732e312ecf00166956,\\n            0x15976c99ef2c911bd3a72c9613b7fe9e66b03dd8963bfed705c96e3e88fdb1af\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x0745a77052dc66afc61163ec3737651e5b846ca7ec7fae1853515d0f10a51bd9,\\n            0x2bd27ecf4fb7f5053cc6de3ddb7a969fac5150a6fb5555ca917d16a7836e4c0a\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x2787aea173d07508083893b02ea962be71c3b628d1da7d7c4db0def49f73ad8f,\\n            0x22fdc951a97dc2ac7d8292a6c263898022f4623c643a56b9265b33c72e628886\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x0aafe35c49634858e44e9af259cac47a6f8402eb870f9f95217dcb8a33a73e64,\\n            0x1b47a7641a7c918784e84fc2494bfd8014ebc77069b94650d25cb5e25fbb7003\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x11cfc3fe28dfd5d663d53ceacc5ec620da85ae5aa971f0f003f57e75cd05bf9f,\\n            0x28b325f30984634fc46c6750f402026d4ff43e5325cbe34d35bf8ac4fc9cc533\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x2ada816636b9447def36e35dd3ab0e3f7a8bbe3ae32a5a4904dee3fc26e58015,\\n            0x2cd12d1a50aaadef4e19e1b1955c932e992e688c2883da862bd7fad17aae66f6\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x20cc506f273be4d114cbf2807c14a769d03169168892e2855cdfa78c3095c89d,\\n            0x08f99d338aee985d780d036473c624de9fd7960b2a4a7ad361c8c125cf11899e\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x01260265d3b1167eac1030f3d04326f08a1f2bb1e026e54afec844e3729386e2,\\n            0x16d75b53ec2552c63e84ea5f4bfe1507c3198045875457c1d9295d6699f39d56\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x1f4d73c63d163c3f5ef1b5caa41988cacbdbca38334e8f54d7ee9bbbb622e200,\\n            0x2f48f5f93d9845526ef0348f1c3def63cfc009645eb2a95d1746c7941e888a78\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x1dbd386fe258366222becc570a7f6405b25ff52818b93bdd54eaa20a6b22025a,\\n            0x2b2b4e978ac457d752f50b02609bd7d2054286b963821b2ec7cd3dd1507479fa\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n\\n}\\n\\n// Hardcoded constants to avoid accessing store\\ncontract KeysWithPlonkVerifierOld is VerifierWithDeserializeOld {\\n\\n    \\n    function getVkExit() internal pure returns(VerificationKeyOld memory vk) {\\n        vk.domain_size = 524288;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0cf1526aaafac6bacbb67d11a4077806b123f767e4b0883d14cc0193568fc082);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x114dd473f77a15b602201577dd4b64a32a783cb32fbc02911e512df6a219695d,\\n            0x04c68f82a5dd7d0cc90318bdff493b3d552d148ad859c373ffe55275e043c43b\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x245e8c882af503cb5421f5135b4295a920ccf68b42ae7fb967f044f54e2aaa29,\\n            0x071322ee387a9ce49fe7ef2edb6e9237203dee49ec47483af85e356b79fb06fd\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x0187754ab593b07a420b3b4d215c20ed49acf90fc4c97e4b06e8f5bc0a2eb3f4,\\n            0x0170f9286ce950286a16ea25136c163c0b32019f31b89c256a612d40b863d0b6\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x0defecfae1d2b9ec9b2ee4d4798c625fa50f6a4ddb7747a7293df0c17fcb90c2,\\n            0x0f91d08fceebf85fb80f12cda78cefa1ee9dbf5cfe7c4f0704b3c6620fa50c55\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x2f7fef3b3fb64af6640f93803a18b3e5ce4e0e60aecd4f924c833fa6fa6da961,\\n            0x03908fc737113ac7f3529fe3b36efca200c66d1d85d2fc081973214c586de732\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x14ce3c0e9b78fc331327249e707f58fa4bb0ed746bdc9c2262ad0cf905609627,\\n            0x09e64fdac452b424e98fc4a92f7222693d0d84ab48aadd9c46151dbe5f1a34a9\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x1d10bfd923c17d9623ec02db00099355b373021432ae1edef69b0f5f461f78d6,\\n            0x24e370a93f65f42888781d0158bb6ef9136c8bbd047d7993b8276bc8df8b640a\\n        );\\n\\n        vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x1fd1755ed4d06d91d50db4771d332cfa2bc2ca0e10ac8b77e0d6b73b993e788e,\\n            0x0bdbf3b7f0d3cffdcf818f1fba18b90914eda59b454bd1858c6c0916b817f883\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x1f3b8d12ffa2ceb2bb42d232ad2cf11bce3183472b622e11cc841d26f42ad507,\\n            0x0ce815e32b3bd14311cde210cda1bd351617d539ed3e9d96a8605f364f3a29b0\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x123afa8c1cec1956d7330db062498a2a3e3a9862926c02e1228d9cfb63d3c301,\\n            0x0f5af15ff0a3e35486c541f72956b53ff6d0740384ef6463c866146c1bd2afc8\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x01069e38ea6396af1623921101d3d3d14ee46942fb23bf1d110efb994c3ee573,\\n            0x232a8ce7151e69601a7867f9dcac8e2de4dd8352d119c90bbb0fb84720c02513\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1, 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4, 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/PlonkCore.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n// solhint-disable\\n\\n\\n\\n\\nlibrary PairingsBn254 {\\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant bn254_b_coeff = 3;\\n\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n\\n    struct Fr {\\n        uint256 value;\\n    }\\n\\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\\n        require(fr < r_mod);\\n        return Fr({value: fr});\\n    }\\n\\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\\n        n.value = self.value;\\n    }\\n\\n    function assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = other.value;\\n    }\\n\\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\\n        require(fr.value != 0);\\n        return pow(fr, r_mod - 2);\\n    }\\n\\n    function add_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, other.value, r_mod);\\n    }\\n\\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\\n    }\\n\\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = mulmod(self.value, other.value, r_mod);\\n    }\\n\\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\\n        uint256[1] memory result;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\\n        }\\n        require(success);\\n        return Fr({value: result[0]});\\n    }\\n\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint256[2] X;\\n        uint256[2] Y;\\n    }\\n\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        if (x == 0 && y == 0) {\\n            // point of infinity is (0,0)\\n            return G1Point(x, y);\\n        }\\n\\n        // check encoding\\n        require(x < q_mod);\\n        require(y < q_mod);\\n        // check on curve\\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\\n        rhs = mulmod(rhs, x, q_mod); // x^3\\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\\n        require(lhs == rhs);\\n\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\\n        return G2Point(x, y);\\n    }\\n\\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\\n        result.X = self.X;\\n        result.Y = self.Y;\\n    }\\n\\n    function P2() internal pure returns (G2Point memory) {\\n        // for some reason ethereum expects to have c1*v + c0 form\\n\\n        return\\n            G2Point(\\n                [\\n                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\\n                ],\\n                [\\n                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n                ]\\n            );\\n    }\\n\\n    function negate(G1Point memory self) internal pure {\\n        // The prime q in the base field F_q for G1\\n        if (self.Y == 0) {\\n            require(self.X == 0);\\n            return;\\n        }\\n\\n        self.Y = q_mod - self.Y;\\n    }\\n\\n    function point_add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\\n        point_add_into_dest(p1, p2, r);\\n        return r;\\n    }\\n\\n    function point_add_assign(G1Point memory p1, G1Point memory p2) internal view {\\n        point_add_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_add_into_dest(\\n        G1Point memory p1,\\n        G1Point memory p2,\\n        G1Point memory dest\\n    ) internal view {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we add zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we add into zero, and we add non-zero point\\n            dest.X = p2.X;\\n            dest.Y = p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_sub_assign(G1Point memory p1, G1Point memory p2) internal view {\\n        point_sub_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_sub_into_dest(\\n        G1Point memory p1,\\n        G1Point memory p2,\\n        G1Point memory dest\\n    ) internal view {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we subtracted zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we subtract from zero, and we subtract non-zero point\\n            dest.X = p2.X;\\n            dest.Y = q_mod - p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = q_mod - p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_mul(G1Point memory p, Fr memory s) internal view returns (G1Point memory r) {\\n        point_mul_into_dest(p, s, r);\\n        return r;\\n    }\\n\\n    function point_mul_assign(G1Point memory p, Fr memory s) internal view {\\n        point_mul_into_dest(p, s, p);\\n    }\\n\\n    function point_mul_into_dest(\\n        G1Point memory p,\\n        Fr memory s,\\n        G1Point memory dest\\n    ) internal view {\\n        uint256[3] memory input;\\n        input[0] = p.X;\\n        input[1] = p.Y;\\n        input[2] = s.value;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\\n        }\\n        require(success);\\n    }\\n\\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\\n        require(p1.length == p2.length);\\n        uint256 elements = p1.length;\\n        uint256 inputSize = elements * 6;\\n        uint256[] memory input = new uint256[](inputSize);\\n        for (uint256 i = 0; i < elements; i++) {\\n            input[i * 6 + 0] = p1[i].X;\\n            input[i * 6 + 1] = p1[i].Y;\\n            input[i * 6 + 2] = p2[i].X[0];\\n            input[i * 6 + 3] = p2[i].X[1];\\n            input[i * 6 + 4] = p2[i].Y[0];\\n            input[i * 6 + 5] = p2[i].Y[1];\\n        }\\n        uint256[1] memory out;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\\n        }\\n        require(success);\\n        return out[0] != 0;\\n    }\\n\\n    /// Convenience method for a pairing check for two pairs.\\n    function pairingProd2(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2\\n    ) internal view returns (bool) {\\n        G1Point[] memory p1 = new G1Point[](2);\\n        G2Point[] memory p2 = new G2Point[](2);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        return pairing(p1, p2);\\n    }\\n}\\n\\nlibrary TranscriptLibrary {\\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint32 constant DST_0 = 0;\\n    uint32 constant DST_1 = 1;\\n    uint32 constant DST_CHALLENGE = 2;\\n\\n    struct Transcript {\\n        bytes32 state_0;\\n        bytes32 state_1;\\n        uint32 challenge_counter;\\n    }\\n\\n    function new_transcript() internal pure returns (Transcript memory t) {\\n        t.state_0 = bytes32(0);\\n        t.state_1 = bytes32(0);\\n        t.challenge_counter = 0;\\n    }\\n\\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\\n        bytes32 old_state_0 = self.state_0;\\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\\n    }\\n\\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\\n        update_with_u256(self, value.value);\\n    }\\n\\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\\n        update_with_u256(self, p.X);\\n        update_with_u256(self, p.Y);\\n    }\\n\\n    function get_challenge(Transcript memory self) internal pure returns (PairingsBn254.Fr memory challenge) {\\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\\n        self.challenge_counter += 1;\\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\\n    }\\n}\\n\\ncontract Plonk4VerifierWithAccessToDNext {\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\\n\\n    uint256 constant ZERO = 0;\\n    uint256 constant ONE = 1;\\n    uint256 constant TWO = 2;\\n    uint256 constant THREE = 3;\\n    uint256 constant FOUR = 4;\\n\\n    uint256 constant STATE_WIDTH = 4;\\n    uint256 constant NUM_DIFFERENT_GATES = 2;\\n    uint256 constant NUM_SETUP_POLYS_FOR_MAIN_GATE = 7;\\n    uint256 constant NUM_SETUP_POLYS_RANGE_CHECK_GATE = 0;\\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP = 1;\\n    uint256 constant NUM_GATE_SELECTORS_OPENED_EXPLICITLY = 1;\\n\\n    uint256 constant RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK =\\n        0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    uint256 constant LIMB_WIDTH = 68;\\n\\n    struct VerificationKey {\\n        uint256 domain_size;\\n        uint256 num_inputs;\\n        PairingsBn254.Fr omega;\\n        PairingsBn254.G1Point[NUM_SETUP_POLYS_FOR_MAIN_GATE + NUM_SETUP_POLYS_RANGE_CHECK_GATE] gate_setup_commitments;\\n        PairingsBn254.G1Point[NUM_DIFFERENT_GATES] gate_selector_commitments;\\n        PairingsBn254.G1Point[STATE_WIDTH] copy_permutation_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_non_residues;\\n        PairingsBn254.G2Point g2_x;\\n    }\\n\\n    struct Proof {\\n        uint256[] input_values;\\n        PairingsBn254.G1Point[STATE_WIDTH] wire_commitments;\\n        PairingsBn254.G1Point copy_permutation_grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH] wire_values_at_z;\\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] wire_values_at_z_omega;\\n        PairingsBn254.Fr[NUM_GATE_SELECTORS_OPENED_EXPLICITLY] gate_selector_values_at_z;\\n        PairingsBn254.Fr copy_grand_product_at_z_omega;\\n        PairingsBn254.Fr quotient_polynomial_at_z;\\n        PairingsBn254.Fr linearization_polynomial_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH - 1] permutation_polynomials_at_z;\\n        PairingsBn254.G1Point opening_at_z_proof;\\n        PairingsBn254.G1Point opening_at_z_omega_proof;\\n    }\\n\\n    struct PartialVerifierState {\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr[] cached_lagrange_evals;\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function batch_evaluate_lagrange_poly_out_of_domain(\\n        uint256[] memory poly_nums,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr[] memory res) {\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory tmp_1 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory tmp_2 = PairingsBn254.new_fr(domain_size);\\n        PairingsBn254.Fr memory vanishing_at_z = at.pow(domain_size);\\n        vanishing_at_z.sub_assign(one);\\n        // we can not have random point z be in domain\\n        require(vanishing_at_z.value != 0);\\n        PairingsBn254.Fr[] memory nums = new PairingsBn254.Fr[](poly_nums.length);\\n        PairingsBn254.Fr[] memory dens = new PairingsBn254.Fr[](poly_nums.length);\\n        // numerators in a form omega^i * (z^n - 1)\\n        // denoms in a form (z - omega^i) * N\\n        for (uint256 i = 0; i < poly_nums.length; i++) {\\n            tmp_1 = omega.pow(poly_nums[i]); // power of omega\\n            nums[i].assign(vanishing_at_z);\\n            nums[i].mul_assign(tmp_1);\\n\\n            dens[i].assign(at); // (X - omega^i) * N\\n            dens[i].sub_assign(tmp_1);\\n            dens[i].mul_assign(tmp_2); // mul by domain size\\n        }\\n\\n        PairingsBn254.Fr[] memory partial_products = new PairingsBn254.Fr[](poly_nums.length);\\n        partial_products[0].assign(PairingsBn254.new_fr(1));\\n        for (uint256 i = 1; i < dens.length - 1; i++) {\\n            partial_products[i].assign(dens[i - 1]);\\n            partial_products[i].mul_assign(dens[i]);\\n        }\\n\\n        tmp_2.assign(partial_products[partial_products.length - 1]);\\n        tmp_2.mul_assign(dens[dens.length - 1]);\\n        tmp_2 = tmp_2.inverse(); // tmp_2 contains a^-1 * b^-1 (with! the last one)\\n\\n        for (uint256 i = dens.length - 1; i < dens.length; i--) {\\n            dens[i].assign(tmp_2); // all inversed\\n            dens[i].mul_assign(partial_products[i]); // clear lowest terms\\n            tmp_2.mul_assign(dens[i]);\\n        }\\n\\n        for (uint256 i = 0; i < nums.length; i++) {\\n            nums[i].mul_assign(dens[i]);\\n        }\\n\\n        return nums;\\n    }\\n\\n    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)\\n        internal\\n        view\\n        returns (PairingsBn254.Fr memory res)\\n    {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function verify_at_z(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.Fr memory lhs = evaluate_vanishing(vk.domain_size, state.z);\\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\\n\\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\\n\\n        // public inputs\\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\\n            tmp.assign(state.cached_lagrange_evals[i]);\\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            inputs_term.add_assign(tmp);\\n        }\\n\\n        inputs_term.mul_assign(proof.gate_selector_values_at_z[0]);\\n        rhs.add_assign(inputs_term);\\n\\n        // now we need 5th power\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.copy_grand_product_at_z_omega);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp.mul_assign(state.beta);\\n            tmp.add_assign(state.gamma);\\n            tmp.add_assign(proof.wire_values_at_z[i]);\\n\\n            z_part.mul_assign(tmp);\\n        }\\n\\n        tmp.assign(state.gamma);\\n        // we need a wire value of the last polynomial in enumeration\\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH - 1]);\\n\\n        z_part.mul_assign(tmp);\\n        z_part.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(z_part);\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        tmp.assign(state.cached_lagrange_evals[0]);\\n        tmp.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(tmp);\\n\\n        return lhs.value == rhs.value;\\n    }\\n\\n    function add_contribution_from_range_constraint_gates(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        PairingsBn254.Fr memory current_alpha\\n    ) internal pure returns (PairingsBn254.Fr memory res) {\\n        // now add contribution from range constraint gate\\n        // we multiply selector commitment by all the factors (alpha*(c - 4d)(c - 4d - 1)(..-2)(..-3) + alpha^2 * (4b - c)()()() + {} + {})\\n\\n        PairingsBn254.Fr memory one_fr = PairingsBn254.new_fr(ONE);\\n        PairingsBn254.Fr memory two_fr = PairingsBn254.new_fr(TWO);\\n        PairingsBn254.Fr memory three_fr = PairingsBn254.new_fr(THREE);\\n        PairingsBn254.Fr memory four_fr = PairingsBn254.new_fr(FOUR);\\n\\n        res = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t0 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t1 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t2 = PairingsBn254.new_fr(0);\\n\\n        for (uint256 i = 0; i < 3; i++) {\\n            current_alpha.mul_assign(state.alpha);\\n\\n            // high - 4*low\\n\\n            // this is 4*low\\n            t0 = PairingsBn254.copy(proof.wire_values_at_z[3 - i]);\\n            t0.mul_assign(four_fr);\\n\\n            // high\\n            t1 = PairingsBn254.copy(proof.wire_values_at_z[2 - i]);\\n            t1.sub_assign(t0);\\n\\n            // t0 is now t1 - {0,1,2,3}\\n\\n            // first unroll manually for -0;\\n            t2 = PairingsBn254.copy(t1);\\n\\n            // -1\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(one_fr);\\n            t2.mul_assign(t0);\\n\\n            // -2\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(two_fr);\\n            t2.mul_assign(t0);\\n\\n            // -3\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(three_fr);\\n            t2.mul_assign(t0);\\n\\n            t2.mul_assign(current_alpha);\\n\\n            res.add_assign(t2);\\n        }\\n\\n        // now also d_next - 4a\\n\\n        current_alpha.mul_assign(state.alpha);\\n\\n        // high - 4*low\\n\\n        // this is 4*low\\n        t0 = PairingsBn254.copy(proof.wire_values_at_z[0]);\\n        t0.mul_assign(four_fr);\\n\\n        // high\\n        t1 = PairingsBn254.copy(proof.wire_values_at_z_omega[0]);\\n        t1.sub_assign(t0);\\n\\n        // t0 is now t1 - {0,1,2,3}\\n\\n        // first unroll manually for -0;\\n        t2 = PairingsBn254.copy(t1);\\n\\n        // -1\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(one_fr);\\n        t2.mul_assign(t0);\\n\\n        // -2\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(two_fr);\\n        t2.mul_assign(t0);\\n\\n        // -3\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(three_fr);\\n        t2.mul_assign(t0);\\n\\n        t2.mul_assign(current_alpha);\\n\\n        res.add_assign(t2);\\n\\n        return res;\\n    }\\n\\n    function reconstruct_linearization_commitment(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point memory res) {\\n        // we compute what power of v is used as a delinearization factor in batch opening of\\n        // commitments. Let's label W(x) = 1 / (x - z) *\\n        // [\\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\\n        // + v (r(x) - r(z))\\n        // + v^{2..5} * (witness(x) - witness(z))\\n        // + v^{6} * (selector(x) - selector(z))\\n        // + v^{7..9} * (permutation(x) - permutation(z))\\n        // ]\\n        // W'(x) = 1 / (x - z*omega) *\\n        // [\\n        // + v^10 (z(x) - z(z*omega)) <- we need this power\\n        // + v^11 * (d(x) - d(z*omega))\\n        // ]\\n        //\\n\\n        // we reconstruct linearization polynomial virtual selector\\n        // for that purpose we first linearize over main gate (over all it's selectors)\\n        // and multiply them by value(!) of the corresponding main gate selector\\n        res = PairingsBn254.copy_g1(vk.gate_setup_commitments[STATE_WIDTH + 1]); // index of q_const(x)\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\\n\\n        // addition gates\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            tmp_g1 = vk.gate_setup_commitments[i].point_mul(proof.wire_values_at_z[i]);\\n            res.point_add_assign(tmp_g1);\\n        }\\n\\n        // multiplication gate\\n        tmp_fr.assign(proof.wire_values_at_z[0]);\\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\\n        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH].point_mul(tmp_fr);\\n        res.point_add_assign(tmp_g1);\\n\\n        // d_next\\n        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH + 2].point_mul(proof.wire_values_at_z_omega[0]); // index of q_d_next(x)\\n        res.point_add_assign(tmp_g1);\\n\\n        // multiply by main gate selector(z)\\n        res.point_mul_assign(proof.gate_selector_values_at_z[0]); // these is only one explicitly opened selector\\n\\n        PairingsBn254.Fr memory current_alpha = PairingsBn254.new_fr(ONE);\\n\\n        // calculate scalar contribution from the range check gate\\n        tmp_fr = add_contribution_from_range_constraint_gates(state, proof, current_alpha);\\n        tmp_g1 = vk.gate_selector_commitments[1].point_mul(tmp_fr); // selector commitment for range constraint gate * scalar\\n        res.point_add_assign(tmp_g1);\\n\\n        // proceed as normal to copy permutation\\n        current_alpha.mul_assign(state.alpha); // alpha^5\\n\\n        PairingsBn254.Fr memory alpha_for_grand_product = PairingsBn254.copy(current_alpha);\\n\\n        // z * non_res * beta + gamma + a\\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\\n        grand_product_part_at_z.mul_assign(state.beta);\\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\\n        grand_product_part_at_z.add_assign(state.gamma);\\n        for (uint256 i = 0; i < vk.copy_permutation_non_residues.length; i++) {\\n            tmp_fr.assign(state.z);\\n            tmp_fr.mul_assign(vk.copy_permutation_non_residues[i]);\\n            tmp_fr.mul_assign(state.beta);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i + 1]);\\n\\n            grand_product_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        grand_product_part_at_z.mul_assign(alpha_for_grand_product);\\n\\n        // alpha^n & L_{0}(z), and we bump current_alpha\\n        current_alpha.mul_assign(state.alpha);\\n\\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\\n        tmp_fr.mul_assign(current_alpha);\\n\\n        grand_product_part_at_z.add_assign(tmp_fr);\\n\\n        // prefactor for grand_product(x) is complete\\n\\n        // add to the linearization a part from the term\\n        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp_fr.assign(state.beta);\\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\\n\\n            last_permutation_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        last_permutation_part_at_z.mul_assign(state.beta);\\n        last_permutation_part_at_z.mul_assign(proof.copy_grand_product_at_z_omega);\\n        last_permutation_part_at_z.mul_assign(alpha_for_grand_product); // we multiply by the power of alpha from the argument\\n\\n        // actually multiply prefactors by z(x) and perm_d(x) and combine them\\n        tmp_g1 = proof.copy_permutation_grand_product_commitment.point_mul(grand_product_part_at_z);\\n        tmp_g1.point_sub_assign(vk.copy_permutation_commitments[STATE_WIDTH - 1].point_mul(last_permutation_part_at_z));\\n\\n        res.point_add_assign(tmp_g1);\\n        // multiply them by v immedately as linearization has a factor of v^1\\n        res.point_mul_assign(state.v);\\n        // res now contains contribution from the gates linearization and\\n        // copy permutation part\\n\\n        // now we need to add a part that is the rest\\n        // for z(x*omega):\\n        // - (a(z) + beta*perm_a + gamma)*()*()*(d(z) + gamma) * z(x*omega)\\n    }\\n\\n    function aggregate_commitments(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point[2] memory res) {\\n        PairingsBn254.G1Point memory d = reconstruct_linearization_commitment(state, proof, vk);\\n\\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\\n        for (uint256 i = 1; i < proof.quotient_poly_commitments.length; i++) {\\n            tmp_fr.mul_assign(z_in_domain_size);\\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        commitment_aggregation.point_add_assign(d);\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint256 i = 0; i < NUM_GATE_SELECTORS_OPENED_EXPLICITLY; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.gate_selector_commitments[0].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint256 i = 0; i < vk.copy_permutation_commitments.length - 1; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.copy_permutation_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        // now do prefactor for grand_product(x*omega)\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        commitment_aggregation.point_add_assign(proof.copy_permutation_grand_product_commitment.point_mul(tmp_fr));\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH - 1].point_mul(tmp_fr);\\n        commitment_aggregation.point_add_assign(tmp_g1);\\n\\n        // collect opening values\\n        aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.wire_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_fr.assign(proof.gate_selector_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.copy_grand_product_at_z_omega);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\\n\\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\\n\\n        tmp_fr.assign(state.z);\\n        tmp_fr.mul_assign(vk.omega);\\n        tmp_fr.mul_assign(state.u);\\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\\n\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\\n        pair_with_x.negate();\\n\\n        res[0] = pair_with_generator;\\n        res[1] = pair_with_x;\\n\\n        return res;\\n    }\\n\\n    function verify_initial(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        require(proof.input_values.length == vk.num_inputs);\\n        require(vk.num_inputs >= 1);\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            transcript.update_with_g1(proof.wire_commitments[i]);\\n        }\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\\n        }\\n\\n        state.z = transcript.get_challenge();\\n\\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {\\n            lagrange_poly_numbers[i] = i;\\n        }\\n\\n        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain(\\n            lagrange_poly_numbers,\\n            vk.domain_size,\\n            vk.omega,\\n            state.z\\n        );\\n\\n        bool valid = verify_at_z(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.gate_selector_values_at_z[0]);\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.copy_grand_product_at_z_omega);\\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\\n\\n        state.v = transcript.get_challenge();\\n        transcript.update_with_g1(proof.opening_at_z_proof);\\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\\n        state.u = transcript.get_challenge();\\n\\n        return true;\\n    }\\n\\n    // This verifier is for a PLONK with a state width 4\\n    // and main gate equation\\n    // q_a(X) * a(X) +\\n    // q_b(X) * b(X) +\\n    // q_c(X) * c(X) +\\n    // q_d(X) * d(X) +\\n    // q_m(X) * a(X) * b(X) +\\n    // q_constants(X)+\\n    // q_d_next(X) * d(X*omega)\\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\\n    // q_d_next(X) \\\"peeks\\\" into the next row of the trace, so it takes\\n    // the same d(X) polynomial, but shifted\\n\\n    function aggregate_for_verification(Proof memory proof, VerificationKey memory vk)\\n        internal\\n        view\\n        returns (bool valid, PairingsBn254.G1Point[2] memory part)\\n    {\\n        PartialVerifierState memory state;\\n\\n        valid = verify_initial(state, proof, vk);\\n\\n        if (valid == false) {\\n            return (valid, part);\\n        }\\n\\n        part = aggregate_commitments(state, proof, vk);\\n\\n        (valid, part);\\n    }\\n\\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\\n        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        valid = PairingsBn254.pairingProd2(\\n            recursive_proof_part[0],\\n            PairingsBn254.P2(),\\n            recursive_proof_part[1],\\n            vk.g2_x\\n        );\\n\\n        return valid;\\n    }\\n\\n    function verify_recursive(\\n        Proof memory proof,\\n        VerificationKey memory vk,\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[16] memory subproofs_limbs\\n    ) internal view returns (bool) {\\n        (uint256 recursive_input, PairingsBn254.G1Point[2] memory aggregated_g1s) =\\n            reconstruct_recursive_public_input(\\n                recursive_vks_root,\\n                max_valid_index,\\n                recursive_vks_indexes,\\n                individual_vks_inputs,\\n                subproofs_limbs\\n            );\\n\\n        assert(recursive_input == proof.input_values[0]);\\n\\n        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        // aggregated_g1s = inner\\n        // recursive_proof_part = outer\\n        PairingsBn254.G1Point[2] memory combined = combine_inner_and_outer(aggregated_g1s, recursive_proof_part);\\n\\n        valid = PairingsBn254.pairingProd2(combined[0], PairingsBn254.P2(), combined[1], vk.g2_x);\\n\\n        return valid;\\n    }\\n\\n    function combine_inner_and_outer(PairingsBn254.G1Point[2] memory inner, PairingsBn254.G1Point[2] memory outer)\\n        internal\\n        view\\n        returns (PairingsBn254.G1Point[2] memory result)\\n    {\\n        // reuse the transcript primitive\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        transcript.update_with_g1(inner[0]);\\n        transcript.update_with_g1(inner[1]);\\n        transcript.update_with_g1(outer[0]);\\n        transcript.update_with_g1(outer[1]);\\n        PairingsBn254.Fr memory challenge = transcript.get_challenge();\\n        // 1 * inner + challenge * outer\\n        result[0] = PairingsBn254.copy_g1(inner[0]);\\n        result[1] = PairingsBn254.copy_g1(inner[1]);\\n        PairingsBn254.G1Point memory tmp = outer[0].point_mul(challenge);\\n        result[0].point_add_assign(tmp);\\n        tmp = outer[1].point_mul(challenge);\\n        result[1].point_add_assign(tmp);\\n\\n        return result;\\n    }\\n\\n    function reconstruct_recursive_public_input(\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[16] memory subproofs_aggregated\\n    ) internal pure returns (uint256 recursive_input, PairingsBn254.G1Point[2] memory reconstructed_g1s) {\\n        assert(recursive_vks_indexes.length == individual_vks_inputs.length);\\n        bytes memory concatenated = abi.encodePacked(recursive_vks_root);\\n        uint8 index;\\n        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {\\n            index = recursive_vks_indexes[i];\\n            assert(index <= max_valid_index);\\n            concatenated = abi.encodePacked(concatenated, index);\\n        }\\n        uint256 input;\\n        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {\\n            input = individual_vks_inputs[i];\\n            assert(input < r_mod);\\n            concatenated = abi.encodePacked(concatenated, input);\\n        }\\n\\n        concatenated = abi.encodePacked(concatenated, subproofs_aggregated);\\n\\n        bytes32 commitment = sha256(concatenated);\\n        recursive_input = uint256(commitment) & RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK;\\n\\n        reconstructed_g1s[0] = PairingsBn254.new_g1_checked(\\n            subproofs_aggregated[0] +\\n                (subproofs_aggregated[1] << LIMB_WIDTH) +\\n                (subproofs_aggregated[2] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[3] << (3 * LIMB_WIDTH)),\\n            subproofs_aggregated[4] +\\n                (subproofs_aggregated[5] << LIMB_WIDTH) +\\n                (subproofs_aggregated[6] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[7] << (3 * LIMB_WIDTH))\\n        );\\n\\n        reconstructed_g1s[1] = PairingsBn254.new_g1_checked(\\n            subproofs_aggregated[8] +\\n                (subproofs_aggregated[9] << LIMB_WIDTH) +\\n                (subproofs_aggregated[10] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[11] << (3 * LIMB_WIDTH)),\\n            subproofs_aggregated[12] +\\n                (subproofs_aggregated[13] << LIMB_WIDTH) +\\n                (subproofs_aggregated[14] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[15] << (3 * LIMB_WIDTH))\\n        );\\n\\n        return (recursive_input, reconstructed_g1s);\\n    }\\n}\\n\\ncontract VerifierWithDeserialize is Plonk4VerifierWithAccessToDNext {\\n    uint256 constant SERIALIZED_PROOF_LENGTH = 34;\\n\\n    function deserialize_proof(uint256[] memory public_inputs, uint256[] memory serialized_proof)\\n        internal\\n        pure\\n        returns (Proof memory proof)\\n    {\\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH);\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i++) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n\\n            j += 2;\\n        }\\n\\n        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j + 1]\\n        );\\n        j += 2;\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j + 1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {\\n            proof.gate_selector_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        proof.copy_grand_product_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n        j += 2;\\n\\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n    }\\n\\n    function verify_serialized_proof(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof,\\n        VerificationKey memory vk\\n    ) public view returns (bool) {\\n        require(vk.num_inputs == public_inputs.length);\\n\\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\\n\\n        bool valid = verify(proof, vk);\\n\\n        return valid;\\n    }\\n\\n    function verify_serialized_proof_with_recursion(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof,\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[16] memory subproofs_limbs,\\n        VerificationKey memory vk\\n    ) public view returns (bool) {\\n        require(vk.num_inputs == public_inputs.length);\\n\\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\\n\\n        bool valid =\\n            verify_recursive(\\n                proof,\\n                vk,\\n                recursive_vks_root,\\n                max_valid_index,\\n                recursive_vks_indexes,\\n                individual_vks_inputs,\\n                subproofs_limbs\\n            );\\n\\n        return valid;\\n    }\\n}\\n\\ncontract Plonk4VerifierWithAccessToDNextOld {\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\\n\\n    uint256 constant STATE_WIDTH_OLD = 4;\\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD = 1;\\n\\n    struct VerificationKeyOld {\\n        uint256 domain_size;\\n        uint256 num_inputs;\\n        PairingsBn254.Fr omega;\\n        PairingsBn254.G1Point[STATE_WIDTH_OLD + 2] selector_commitments; // STATE_WIDTH for witness + multiplication + constant\\n        PairingsBn254.G1Point[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD] next_step_selector_commitments;\\n        PairingsBn254.G1Point[STATE_WIDTH_OLD] permutation_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH_OLD - 1] permutation_non_residues;\\n        PairingsBn254.G2Point g2_x;\\n    }\\n\\n    struct ProofOld {\\n        uint256[] input_values;\\n        PairingsBn254.G1Point[STATE_WIDTH_OLD] wire_commitments;\\n        PairingsBn254.G1Point grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH_OLD] quotient_poly_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH_OLD] wire_values_at_z;\\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD] wire_values_at_z_omega;\\n        PairingsBn254.Fr grand_product_at_z_omega;\\n        PairingsBn254.Fr quotient_polynomial_at_z;\\n        PairingsBn254.Fr linearization_polynomial_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH_OLD - 1] permutation_polynomials_at_z;\\n        PairingsBn254.G1Point opening_at_z_proof;\\n        PairingsBn254.G1Point opening_at_z_omega_proof;\\n    }\\n\\n    struct PartialVerifierStateOld {\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr[] cached_lagrange_evals;\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain_old(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function batch_evaluate_lagrange_poly_out_of_domain_old(\\n        uint256[] memory poly_nums,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr[] memory res) {\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory tmp_1 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory tmp_2 = PairingsBn254.new_fr(domain_size);\\n        PairingsBn254.Fr memory vanishing_at_z = at.pow(domain_size);\\n        vanishing_at_z.sub_assign(one);\\n        // we can not have random point z be in domain\\n        require(vanishing_at_z.value != 0);\\n        PairingsBn254.Fr[] memory nums = new PairingsBn254.Fr[](poly_nums.length);\\n        PairingsBn254.Fr[] memory dens = new PairingsBn254.Fr[](poly_nums.length);\\n        // numerators in a form omega^i * (z^n - 1)\\n        // denoms in a form (z - omega^i) * N\\n        for (uint256 i = 0; i < poly_nums.length; i++) {\\n            tmp_1 = omega.pow(poly_nums[i]); // power of omega\\n            nums[i].assign(vanishing_at_z);\\n            nums[i].mul_assign(tmp_1);\\n\\n            dens[i].assign(at); // (X - omega^i) * N\\n            dens[i].sub_assign(tmp_1);\\n            dens[i].mul_assign(tmp_2); // mul by domain size\\n        }\\n\\n        PairingsBn254.Fr[] memory partial_products = new PairingsBn254.Fr[](poly_nums.length);\\n        partial_products[0].assign(PairingsBn254.new_fr(1));\\n        for (uint256 i = 1; i < dens.length - 1; i++) {\\n            partial_products[i].assign(dens[i - 1]);\\n            partial_products[i].mul_assign(dens[i]);\\n        }\\n\\n        tmp_2.assign(partial_products[partial_products.length - 1]);\\n        tmp_2.mul_assign(dens[dens.length - 1]);\\n        tmp_2 = tmp_2.inverse(); // tmp_2 contains a^-1 * b^-1 (with! the last one)\\n\\n        for (uint256 i = dens.length - 1; i < dens.length; i--) {\\n            dens[i].assign(tmp_2); // all inversed\\n            dens[i].mul_assign(partial_products[i]); // clear lowest terms\\n            tmp_2.mul_assign(dens[i]);\\n        }\\n\\n        for (uint256 i = 0; i < nums.length; i++) {\\n            nums[i].mul_assign(dens[i]);\\n        }\\n\\n        return nums;\\n    }\\n\\n    function evaluate_vanishing_old(uint256 domain_size, PairingsBn254.Fr memory at)\\n        internal\\n        view\\n        returns (PairingsBn254.Fr memory res)\\n    {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function verify_at_z(\\n        PartialVerifierStateOld memory state,\\n        ProofOld memory proof,\\n        VerificationKeyOld memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.Fr memory lhs = evaluate_vanishing_old(vk.domain_size, state.z);\\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\\n\\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\\n\\n        // public inputs\\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\\n            tmp.assign(state.cached_lagrange_evals[i]);\\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            rhs.add_assign(tmp);\\n        }\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.grand_product_at_z_omega);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp.mul_assign(state.beta);\\n            tmp.add_assign(state.gamma);\\n            tmp.add_assign(proof.wire_values_at_z[i]);\\n\\n            z_part.mul_assign(tmp);\\n        }\\n\\n        tmp.assign(state.gamma);\\n        // we need a wire value of the last polynomial in enumeration\\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH_OLD - 1]);\\n\\n        z_part.mul_assign(tmp);\\n        z_part.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(z_part);\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        tmp.assign(state.cached_lagrange_evals[0]);\\n        tmp.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(tmp);\\n\\n        return lhs.value == rhs.value;\\n    }\\n\\n    function reconstruct_d(\\n        PartialVerifierStateOld memory state,\\n        ProofOld memory proof,\\n        VerificationKeyOld memory vk\\n    ) internal view returns (PairingsBn254.G1Point memory res) {\\n        // we compute what power of v is used as a delinearization factor in batch opening of\\n        // commitments. Let's label W(x) = 1 / (x - z) *\\n        // [\\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\\n        // + v (r(x) - r(z))\\n        // + v^{2..5} * (witness(x) - witness(z))\\n        // + v^(6..8) * (permutation(x) - permutation(z))\\n        // ]\\n        // W'(x) = 1 / (x - z*omega) *\\n        // [\\n        // + v^9 (z(x) - z(z*omega)) <- we need this power\\n        // + v^10 * (d(x) - d(z*omega))\\n        // ]\\n        //\\n        // we pay a little for a few arithmetic operations to not introduce another constant\\n        uint256 power_for_z_omega_opening = 1 + 1 + STATE_WIDTH_OLD + STATE_WIDTH_OLD - 1;\\n        res = PairingsBn254.copy_g1(vk.selector_commitments[STATE_WIDTH_OLD + 1]);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\\n\\n        // addition gates\\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\\n            tmp_g1 = vk.selector_commitments[i].point_mul(proof.wire_values_at_z[i]);\\n            res.point_add_assign(tmp_g1);\\n        }\\n\\n        // multiplication gate\\n        tmp_fr.assign(proof.wire_values_at_z[0]);\\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\\n        tmp_g1 = vk.selector_commitments[STATE_WIDTH_OLD].point_mul(tmp_fr);\\n        res.point_add_assign(tmp_g1);\\n\\n        // d_next\\n        tmp_g1 = vk.next_step_selector_commitments[0].point_mul(proof.wire_values_at_z_omega[0]);\\n        res.point_add_assign(tmp_g1);\\n\\n        // z * non_res * beta + gamma + a\\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\\n        grand_product_part_at_z.mul_assign(state.beta);\\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\\n        grand_product_part_at_z.add_assign(state.gamma);\\n        for (uint256 i = 0; i < vk.permutation_non_residues.length; i++) {\\n            tmp_fr.assign(state.z);\\n            tmp_fr.mul_assign(vk.permutation_non_residues[i]);\\n            tmp_fr.mul_assign(state.beta);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i + 1]);\\n\\n            grand_product_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        grand_product_part_at_z.mul_assign(state.alpha);\\n\\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\\n        tmp_fr.mul_assign(state.alpha);\\n        tmp_fr.mul_assign(state.alpha);\\n\\n        grand_product_part_at_z.add_assign(tmp_fr);\\n\\n        PairingsBn254.Fr memory grand_product_part_at_z_omega = state.v.pow(power_for_z_omega_opening);\\n        grand_product_part_at_z_omega.mul_assign(state.u);\\n\\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp_fr.assign(state.beta);\\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\\n\\n            last_permutation_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        last_permutation_part_at_z.mul_assign(state.beta);\\n        last_permutation_part_at_z.mul_assign(proof.grand_product_at_z_omega);\\n        last_permutation_part_at_z.mul_assign(state.alpha);\\n\\n        // add to the linearization\\n        tmp_g1 = proof.grand_product_commitment.point_mul(grand_product_part_at_z);\\n        tmp_g1.point_sub_assign(vk.permutation_commitments[STATE_WIDTH_OLD - 1].point_mul(last_permutation_part_at_z));\\n\\n        res.point_add_assign(tmp_g1);\\n        res.point_mul_assign(state.v);\\n\\n        res.point_add_assign(proof.grand_product_commitment.point_mul(grand_product_part_at_z_omega));\\n    }\\n\\n    function verify_commitments(\\n        PartialVerifierStateOld memory state,\\n        ProofOld memory proof,\\n        VerificationKeyOld memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.G1Point memory d = reconstruct_d(state, proof, vk);\\n\\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\\n        for (uint256 i = 1; i < proof.quotient_poly_commitments.length; i++) {\\n            tmp_fr.mul_assign(z_in_domain_size);\\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        commitment_aggregation.point_add_assign(d);\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint256 i = 0; i < vk.permutation_commitments.length - 1; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.permutation_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH_OLD - 1].point_mul(tmp_fr);\\n        commitment_aggregation.point_add_assign(tmp_g1);\\n\\n        // collect opening values\\n        aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.wire_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.grand_product_at_z_omega);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\\n\\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\\n\\n        tmp_fr.assign(state.z);\\n        tmp_fr.mul_assign(vk.omega);\\n        tmp_fr.mul_assign(state.u);\\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\\n\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\\n        pair_with_x.negate();\\n\\n        return PairingsBn254.pairingProd2(pair_with_generator, PairingsBn254.P2(), pair_with_x, vk.g2_x);\\n    }\\n\\n    function verify_initial(\\n        PartialVerifierStateOld memory state,\\n        ProofOld memory proof,\\n        VerificationKeyOld memory vk\\n    ) internal view returns (bool) {\\n        require(proof.input_values.length == vk.num_inputs);\\n        require(vk.num_inputs >= 1);\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            transcript.update_with_g1(proof.wire_commitments[i]);\\n        }\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\\n        }\\n\\n        state.z = transcript.get_challenge();\\n\\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {\\n            lagrange_poly_numbers[i] = i;\\n        }\\n\\n        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain_old(\\n            lagrange_poly_numbers,\\n            vk.domain_size,\\n            vk.omega,\\n            state.z\\n        );\\n\\n        bool valid = verify_at_z(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\\n        transcript.update_with_fr(proof.grand_product_at_z_omega);\\n\\n        state.v = transcript.get_challenge();\\n        transcript.update_with_g1(proof.opening_at_z_proof);\\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\\n        state.u = transcript.get_challenge();\\n\\n        return true;\\n    }\\n\\n    // This verifier is for a PLONK with a state width 4\\n    // and main gate equation\\n    // q_a(X) * a(X) +\\n    // q_b(X) * b(X) +\\n    // q_c(X) * c(X) +\\n    // q_d(X) * d(X) +\\n    // q_m(X) * a(X) * b(X) +\\n    // q_constants(X)+\\n    // q_d_next(X) * d(X*omega)\\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\\n    // q_d_next(X) \\\"peeks\\\" into the next row of the trace, so it takes\\n    // the same d(X) polynomial, but shifted\\n\\n    function verify_old(ProofOld memory proof, VerificationKeyOld memory vk) internal view returns (bool) {\\n        PartialVerifierStateOld memory state;\\n\\n        bool valid = verify_initial(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        valid = verify_commitments(state, proof, vk);\\n\\n        return valid;\\n    }\\n}\\n\\ncontract VerifierWithDeserializeOld is Plonk4VerifierWithAccessToDNextOld {\\n    uint256 constant SERIALIZED_PROOF_LENGTH_OLD = 33;\\n\\n    function deserialize_proof_old(uint256[] memory public_inputs, uint256[] memory serialized_proof)\\n        internal\\n        pure\\n        returns (ProofOld memory proof)\\n    {\\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH_OLD);\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i++) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n\\n            j += 2;\\n        }\\n\\n        proof.grand_product_commitment = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n        j += 2;\\n\\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j + 1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        proof.grand_product_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n        j += 2;\\n\\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Upgradeable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Interface of the upgradeable contract\\n/// @author Matter Labs\\ninterface Upgradeable {\\n    /// @notice Upgrades target of upgradeable contract\\n    /// @param newTarget New target\\n    /// @param newTargetInitializationParameters New target initialization parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Ownable Contract\\n/// @author Matter Labs\\ncontract Ownable {\\n    /// @dev Storage position of the masters address (keccak256('eip1967.proxy.admin') - 1)\\n    bytes32 private constant MASTER_POSITION = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice Contract constructor\\n    /// @dev Sets msg sender address as masters address\\n    /// @param masterAddress Master address\\n    constructor(address masterAddress) {\\n        setMaster(masterAddress);\\n    }\\n\\n    /// @notice Check if specified address is master\\n    /// @param _address Address to check\\n    function requireMaster(address _address) internal view {\\n        require(_address == getMaster(), \\\"1c\\\"); // oro11 - only by master\\n    }\\n\\n    /// @notice Returns contract masters address\\n    /// @return master Master's address\\n    function getMaster() public view returns (address master) {\\n        bytes32 position = MASTER_POSITION;\\n        assembly {\\n            master := sload(position)\\n        }\\n    }\\n\\n    /// @dev Sets new masters address\\n    /// @param _newMaster New master's address\\n    function setMaster(address _newMaster) internal {\\n        bytes32 position = MASTER_POSITION;\\n        assembly {\\n            sstore(position, _newMaster)\\n        }\\n    }\\n\\n    /// @notice Transfer mastership of the contract to new master\\n    /// @param _newMaster New masters address\\n    function transferMastership(address _newMaster) external {\\n        requireMaster(msg.sender);\\n        require(_newMaster != address(0), \\\"1d\\\"); // otp11 - new masters address can't be zero address\\n        setMaster(_newMaster);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"}],\"name\":\"BlockCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"}],\"name\":\"BlockVerification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"totalBlocksVerified\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"totalBlocksCommitted\",\"type\":\"uint32\"}],\"name\":\"BlocksRevert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"zkSyncBlockId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"DepositCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ExodusMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fact\",\"type\":\"bytes\"}],\"name\":\"FactAuth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"zkSyncBlockId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"FullExitCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"serialId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"enum Operations.OpType\",\"name\":\"opType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationBlock\",\"type\":\"uint256\"}],\"name\":\"NewPriorityRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newNoticePeriod\",\"type\":\"uint256\"}],\"name\":\"NoticePeriodChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"WithdrawalNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"WithdrawalNFTPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"WithdrawalPending\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_maxAmount\",\"type\":\"uint128\"}],\"name\":\"_transferERC20\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"withdrawnAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateExodusMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"authFacts\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_n\",\"type\":\"uint64\"},{\"internalType\":\"bytes[]\",\"name\":\"_depositsPubdata\",\"type\":\"bytes[]\"}],\"name\":\"cancelOutstandingDepositsForExodusMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"priorityOperations\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"pendingOnchainOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"stateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct Storage.StoredBlockInfo\",\"name\":\"_lastCommittedBlockData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"newStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"publicData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"ethWitness\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"publicDataOffset\",\"type\":\"uint32\"}],\"internalType\":\"struct ZkSync.OnchainOperationData[]\",\"name\":\"onchainOperations\",\"type\":\"tuple[]\"},{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"feeAccount\",\"type\":\"uint32\"}],\"internalType\":\"struct ZkSync.CommitBlockInfo[]\",\"name\":\"_newBlocksData\",\"type\":\"tuple[]\"}],\"name\":\"commitBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cutUpgradeNoticePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint104\",\"name\":\"_amount\",\"type\":\"uint104\"},{\"internalType\":\"address\",\"name\":\"_zkSyncAddress\",\"type\":\"address\"}],\"name\":\"depositERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_zkSyncAddress\",\"type\":\"address\"}],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"priorityOperations\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"pendingOnchainOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"stateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct Storage.StoredBlockInfo\",\"name\":\"storedBlock\",\"type\":\"tuple\"},{\"internalType\":\"bytes[]\",\"name\":\"pendingOnchainOpsPubdata\",\"type\":\"bytes[]\"}],\"internalType\":\"struct ZkSync.ExecuteBlockInfo[]\",\"name\":\"_blocksData\",\"type\":\"tuple[]\"}],\"name\":\"executeBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exodusMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstPriorityRequestId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNoticePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getPendingBalance\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initializationParameters\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReadyForUpgrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"priorityOperations\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"pendingOnchainOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"stateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct Storage.StoredBlockInfo\",\"name\":\"_storedBlockInfo\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_accountId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_nftCreatorAccountId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_nftCreatorAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_nftSerialId\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_nftContentHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"}],\"name\":\"performExodus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"priorityOperations\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"pendingOnchainOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"stateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct Storage.StoredBlockInfo[]\",\"name\":\"_committedBlocks\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"recursiveInput\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"proof\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"commitments\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"vkIndexes\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[16]\",\"name\":\"subproofsLimbs\",\"type\":\"uint256[16]\"}],\"internalType\":\"struct ZkSync.ProofInput\",\"name\":\"_proof\",\"type\":\"tuple\"}],\"name\":\"proveBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_accountId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"requestFullExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_accountId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"}],\"name\":\"requestFullExitNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"priorityOperations\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"pendingOnchainOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"stateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct Storage.StoredBlockInfo[]\",\"name\":\"_blocksToRevert\",\"type\":\"tuple[]\"}],\"name\":\"revertBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_pubkeyHash\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"}],\"name\":\"setAuthPubkeyHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"storedBlockHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBlocksCommitted\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBlocksExecuted\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBlocksProven\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalOpenPriorityRequests\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"upgradeParameters\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeCanceled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeFinishes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeNoticePeriodStarted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradePreparationStarted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"}],\"name\":\"withdrawPendingBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"}],\"name\":\"withdrawPendingNFTBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ZkSync","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}