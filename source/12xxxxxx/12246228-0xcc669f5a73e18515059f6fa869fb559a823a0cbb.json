{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n/// DssDeploy.sol\r\n\r\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.5.12;\r\n\r\ninterface VatLike {\r\n    function dai(address) external view returns (uint256);\r\n    function ilks(bytes32 ilk) external returns (\r\n        uint256 Art,   // [wad]\r\n        uint256 rate,  // [ray]\r\n        uint256 spot,  // [ray]\r\n        uint256 line,  // [rad]\r\n        uint256 dust   // [rad]\r\n    );\r\n    function urns(bytes32 ilk, address urn) external returns (\r\n        uint256 ink,   // [wad]\r\n        uint256 art    // [wad]\r\n    );\r\n    function debt() external returns (uint256);\r\n    function move(address src, address dst, uint256 rad) external;\r\n    function hope(address) external;\r\n    function flux(bytes32 ilk, address src, address dst, uint256 rad) external;\r\n    function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external;\r\n    function suck(address u, address v, uint256 rad) external;\r\n    function cage() external;\r\n}\r\n\r\ninterface CatLike {\r\n    function ilks(bytes32) external returns (\r\n        address flip,\r\n        uint256 chop,  // [ray]\r\n        uint256 lump   // [rad]\r\n    );\r\n    function cage() external;\r\n}\r\n\r\ninterface DogLike {\r\n    function ilks(bytes32) external returns (\r\n        address clip,\r\n        uint256 chop,\r\n        uint256 hole,\r\n        uint256 dirt\r\n    );\r\n    function cage() external;\r\n}\r\n\r\ninterface PotLike {\r\n    function cage() external;\r\n}\r\n\r\ninterface VowLike {\r\n    function cage() external;\r\n}\r\n\r\ninterface FlipLike {\r\n    function bids(uint256 id) external view returns (\r\n        uint256 bid,   // [rad]\r\n        uint256 lot,   // [wad]\r\n        address guy,\r\n        uint48  tic,   // [unix epoch time]\r\n        uint48  end,   // [unix epoch time]\r\n        address usr,\r\n        address gal,\r\n        uint256 tab    // [rad]\r\n    );\r\n    function yank(uint256 id) external;\r\n}\r\n\r\ninterface ClipLike {\r\n    function sales(uint256 id) external view returns (\r\n        uint256 pos,\r\n        uint256 tab,\r\n        uint256 lot,\r\n        address usr,\r\n        uint96  tic,\r\n        uint256 top\r\n    );\r\n    function yank(uint256 id) external;\r\n}\r\n\r\ninterface PipLike {\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ninterface SpotLike {\r\n    function par() external view returns (uint256);\r\n    function ilks(bytes32) external view returns (\r\n        PipLike pip,\r\n        uint256 mat    // [ray]\r\n    );\r\n    function cage() external;\r\n}\r\n\r\n/*\r\n    This is the `End` and it coordinates Global Settlement. This is an\r\n    involved, stateful process that takes place over nine steps.\r\n\r\n    First we freeze the system and lock the prices for each ilk.\r\n\r\n    1. `cage()`:\r\n        - freezes user entrypoints\r\n        - cancels flop/flap auctions\r\n        - starts cooldown period\r\n        - stops pot drips\r\n\r\n    2. `cage(ilk)`:\r\n       - set the cage price for each `ilk`, reading off the price feed\r\n\r\n    We must process some system state before it is possible to calculate\r\n    the final dai / collateral price. In particular, we need to determine\r\n\r\n      a. `gap`, the collateral shortfall per collateral type by\r\n         considering under-collateralised CDPs.\r\n\r\n      b. `debt`, the outstanding dai supply after including system\r\n         surplus / deficit\r\n\r\n    We determine (a) by processing all under-collateralised CDPs with\r\n    `skim`:\r\n\r\n    3. `skim(ilk, urn)`:\r\n       - cancels CDP debt\r\n       - any excess collateral remains\r\n       - backing collateral taken\r\n\r\n    We determine (b) by processing ongoing dai generating processes,\r\n    i.e. auctions. We need to ensure that auctions will not generate any\r\n    further dai income.\r\n\r\n    In the two-way auction model (Flipper) this occurs when\r\n    all auctions are in the reverse (`dent`) phase. There are two ways\r\n    of ensuring this:\r\n\r\n    4a. i) `wait`: set the cooldown period to be at least as long as the\r\n           longest auction duration, which needs to be determined by the\r\n           cage administrator.\r\n\r\n           This takes a fairly predictable time to occur but with altered\r\n           auction dynamics due to the now varying price of dai.\r\n\r\n       ii) `skip`: cancel all ongoing auctions and seize the collateral.\r\n\r\n           This allows for faster processing at the expense of more\r\n           processing calls. This option allows dai holders to retrieve\r\n           their collateral faster.\r\n\r\n           `skip(ilk, id)`:\r\n            - cancel individual flip auctions in the `tend` (forward) phase\r\n            - retrieves collateral and debt (including penalty) to owner's CDP\r\n            - returns dai to last bidder\r\n            - `dent` (reverse) phase auctions can continue normally\r\n\r\n    Option (i), `wait`, is sufficient (if all auctions were bidded at least\r\n    once) for processing the system settlement but option (ii), `skip`,\r\n    will speed it up. Both options are available in this implementation,\r\n    with `skip` being enabled on a per-auction basis.\r\n\r\n    In the case of the Dutch Auctions model (Clipper) they keep recovering\r\n    debt during the whole lifetime and there isn't a max duration time\r\n    guaranteed for the auction to end.\r\n    So the way to ensure the protocol will not receive extra dai income is:\r\n\r\n    4b. i) `snip`: cancel all ongoing auctions and seize the collateral.\r\n\r\n           `snip(ilk, id)`:\r\n            - cancel individual running clip auctions\r\n            - retrieves remaining collateral and debt (including penalty)\r\n              to owner's CDP\r\n\r\n    When a CDP has been processed and has no debt remaining, the\r\n    remaining collateral can be removed.\r\n\r\n    5. `free(ilk)`:\r\n        - remove collateral from the caller's CDP\r\n        - owner can call as needed\r\n\r\n    After the processing period has elapsed, we enable calculation of\r\n    the final price for each collateral type.\r\n\r\n    6. `thaw()`:\r\n       - only callable after processing time period elapsed\r\n       - assumption that all under-collateralised CDPs are processed\r\n       - fixes the total outstanding supply of dai\r\n       - may also require extra CDP processing to cover vow surplus\r\n\r\n    7. `flow(ilk)`:\r\n        - calculate the `fix`, the cash price for a given ilk\r\n        - adjusts the `fix` in the case of deficit / surplus\r\n\r\n    At this point we have computed the final price for each collateral\r\n    type and dai holders can now turn their dai into collateral. Each\r\n    unit dai can claim a fixed basket of collateral.\r\n\r\n    Dai holders must first `pack` some dai into a `bag`. Once packed,\r\n    dai cannot be unpacked and is not transferrable. More dai can be\r\n    added to a bag later.\r\n\r\n    8. `pack(wad)`:\r\n        - put some dai into a bag in preparation for `cash`\r\n\r\n    Finally, collateral can be obtained with `cash`. The bigger the bag,\r\n    the more collateral can be released.\r\n\r\n    9. `cash(ilk, wad)`:\r\n        - exchange some dai from your bag for gems from a specific ilk\r\n        - the number of gems is limited by how big your bag is\r\n*/\r\n\r\ncontract End {\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\r\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"End/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    VatLike  public vat;   // CDP Engine\r\n    CatLike  public cat;\r\n    DogLike  public dog;\r\n    VowLike  public vow;   // Debt Engine\r\n    PotLike  public pot;\r\n    SpotLike public spot;\r\n\r\n    uint256  public live;  // Active Flag\r\n    uint256  public when;  // Time of cage                   [unix epoch time]\r\n    uint256  public wait;  // Processing Cooldown Length             [seconds]\r\n    uint256  public debt;  // Total outstanding dai following processing [rad]\r\n\r\n    mapping (bytes32 => uint256) public tag;  // Cage price              [ray]\r\n    mapping (bytes32 => uint256) public gap;  // Collateral shortfall    [wad]\r\n    mapping (bytes32 => uint256) public Art;  // Total debt per ilk      [wad]\r\n    mapping (bytes32 => uint256) public fix;  // Final cash price        [ray]\r\n\r\n    mapping (address => uint256)                      public bag;  //    [wad]\r\n    mapping (bytes32 => mapping (address => uint256)) public out;  //    [wad]\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n\r\n    event File(bytes32 indexed what, uint256 data);\r\n    event File(bytes32 indexed what, address data);\r\n\r\n    event Cage();\r\n    event Cage(bytes32 indexed ilk);\r\n    event Snip(bytes32 indexed ilk, uint256 indexed id, address indexed usr, uint256 tab, uint256 lot, uint256 art);\r\n    event Skip(bytes32 indexed ilk, uint256 indexed id, address indexed usr, uint256 tab, uint256 lot, uint256 art);\r\n    event Skim(bytes32 indexed ilk, address indexed urn, uint256 wad, uint256 art);\r\n    event Free(bytes32 indexed ilk, address indexed usr, uint256 ink);\r\n    event Thaw();\r\n    event Flow(bytes32 indexed ilk);\r\n    event Pack(address indexed usr, uint256 wad);\r\n    event Cash(bytes32 indexed ilk, address indexed usr, uint256 wad);\r\n\r\n    // --- Init ---\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x + y;\r\n        require(z >= x);\r\n    }\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, y) / RAY;\r\n    }\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, RAY) / y;\r\n    }\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, WAD) / y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, address data) external auth {\r\n        require(live == 1, \"End/not-live\");\r\n        if (what == \"vat\")  vat = VatLike(data);\r\n        else if (what == \"cat\")   cat = CatLike(data);\r\n        else if (what == \"dog\")   dog = DogLike(data);\r\n        else if (what == \"vow\")   vow = VowLike(data);\r\n        else if (what == \"pot\")   pot = PotLike(data);\r\n        else if (what == \"spot\") spot = SpotLike(data);\r\n        else revert(\"End/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n    function file(bytes32 what, uint256 data) external auth {\r\n        require(live == 1, \"End/not-live\");\r\n        if (what == \"wait\") wait = data;\r\n        else revert(\"End/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n\r\n    // --- Settlement ---\r\n    function cage() external auth {\r\n        require(live == 1, \"End/not-live\");\r\n        live = 0;\r\n        when = block.timestamp;\r\n        vat.cage();\r\n        cat.cage();\r\n        dog.cage();\r\n        vow.cage();\r\n        spot.cage();\r\n        pot.cage();\r\n        emit Cage();\r\n    }\r\n\r\n    function cage(bytes32 ilk) external {\r\n        require(live == 0, \"End/still-live\");\r\n        require(tag[ilk] == 0, \"End/tag-ilk-already-defined\");\r\n        (Art[ilk],,,,) = vat.ilks(ilk);\r\n        (PipLike pip,) = spot.ilks(ilk);\r\n        // par is a ray, pip returns a wad\r\n        tag[ilk] = wdiv(spot.par(), uint256(pip.read()));\r\n        emit Cage(ilk);\r\n    }\r\n\r\n    function snip(bytes32 ilk, uint256 id) external {\r\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\r\n\r\n        (address _clip,,,) = dog.ilks(ilk);\r\n        ClipLike clip = ClipLike(_clip);\r\n        (, uint256 rate,,,) = vat.ilks(ilk);\r\n        (, uint256 tab, uint256 lot, address usr,,) = clip.sales(id);\r\n\r\n        vat.suck(address(vow), address(vow),  tab);\r\n        clip.yank(id);\r\n\r\n        uint256 art = tab / rate;\r\n        Art[ilk] = add(Art[ilk], art);\r\n        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\r\n        vat.grab(ilk, usr, address(this), address(vow), int256(lot), int256(art));\r\n        emit Snip(ilk, id, usr, tab, lot, art);\r\n    }\r\n\r\n    function skip(bytes32 ilk, uint256 id) external {\r\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\r\n\r\n        (address _flip,,) = cat.ilks(ilk);\r\n        FlipLike flip = FlipLike(_flip);\r\n        (, uint256 rate,,,) = vat.ilks(ilk);\r\n        (uint256 bid, uint256 lot,,,, address usr,, uint256 tab) = flip.bids(id);\r\n\r\n        vat.suck(address(vow), address(vow),  tab);\r\n        vat.suck(address(vow), address(this), bid);\r\n        vat.hope(address(flip));\r\n        flip.yank(id);\r\n\r\n        uint256 art = tab / rate;\r\n        Art[ilk] = add(Art[ilk], art);\r\n        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\r\n        vat.grab(ilk, usr, address(this), address(vow), int256(lot), int256(art));\r\n        emit Skip(ilk, id, usr, tab, lot, art);\r\n    }\r\n\r\n    function skim(bytes32 ilk, address urn) external {\r\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\r\n        (, uint256 rate,,,) = vat.ilks(ilk);\r\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\r\n\r\n        uint256 owe = rmul(rmul(art, rate), tag[ilk]);\r\n        uint256 wad = min(ink, owe);\r\n        gap[ilk] = add(gap[ilk], sub(owe, wad));\r\n\r\n        require(wad <= 2**255 && art <= 2**255, \"End/overflow\");\r\n        vat.grab(ilk, urn, address(this), address(vow), -int256(wad), -int256(art));\r\n        emit Skim(ilk, urn, wad, art);\r\n    }\r\n\r\n    function free(bytes32 ilk) external {\r\n        require(live == 0, \"End/still-live\");\r\n        (uint256 ink, uint256 art) = vat.urns(ilk, msg.sender);\r\n        require(art == 0, \"End/art-not-zero\");\r\n        require(ink <= 2**255, \"End/overflow\");\r\n        vat.grab(ilk, msg.sender, msg.sender, address(vow), -int256(ink), 0);\r\n        emit Free(ilk, msg.sender, ink);\r\n    }\r\n\r\n    function thaw() external {\r\n        require(live == 0, \"End/still-live\");\r\n        require(debt == 0, \"End/debt-not-zero\");\r\n        require(vat.dai(address(vow)) == 0, \"End/surplus-not-zero\");\r\n        require(block.timestamp >= add(when, wait), \"End/wait-not-finished\");\r\n        debt = vat.debt();\r\n        emit Thaw();\r\n    }\r\n    function flow(bytes32 ilk) external {\r\n        require(debt != 0, \"End/debt-zero\");\r\n        require(fix[ilk] == 0, \"End/fix-ilk-already-defined\");\r\n\r\n        (, uint256 rate,,,) = vat.ilks(ilk);\r\n        uint256 wad = rmul(rmul(Art[ilk], rate), tag[ilk]);\r\n        fix[ilk] = rdiv(mul(sub(wad, gap[ilk]), RAY), debt);\r\n        emit Flow(ilk);\r\n    }\r\n\r\n    function pack(uint256 wad) external {\r\n        require(debt != 0, \"End/debt-zero\");\r\n        vat.move(msg.sender, address(vow), mul(wad, RAY));\r\n        bag[msg.sender] = add(bag[msg.sender], wad);\r\n        emit Pack(msg.sender, wad);\r\n    }\r\n    function cash(bytes32 ilk, uint256 wad) external {\r\n        require(fix[ilk] != 0, \"End/fix-ilk-not-defined\");\r\n        vat.flux(ilk, address(this), msg.sender, rmul(wad, fix[ilk]));\r\n        out[ilk][msg.sender] = add(out[ilk][msg.sender], wad);\r\n        require(out[ilk][msg.sender] <= bag[msg.sender], \"End/insufficient-bag-balance\");\r\n        emit Cash(ilk, msg.sender, wad);\r\n    }\r\n}\r\n\r\ncontract EndFab {\r\n    function newEnd(address owner) public returns (End end) {\r\n        end = new End();\r\n        end.rely(owner);\r\n        end.deny(address(this));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"newEnd\",\"outputs\":[{\"internalType\":\"contract End\",\"name\":\"end\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EndFab","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cd799a75248f90ba6ba528e4bb1bb7c3f32007c9e3155ee012896188097420d1"}]}