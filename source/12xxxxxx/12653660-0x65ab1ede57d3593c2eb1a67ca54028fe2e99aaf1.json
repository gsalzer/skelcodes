{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\r\n    external returns (bytes4);\r\n}\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\ncontract Pausable is Context {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n    bool private _paused;\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n        if (valueIndex != 0) {\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            set._indexes[lastvalue] = toDeleteIndex + 1;\r\n            set._values.pop();\r\n            delete set._indexes[value];\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\nlibrary EnumerableMap {\r\n    struct MapEntry {\r\n        uint256 _key;\r\n        uint256 _value;\r\n    }\r\n    struct Map {\r\n        MapEntry[] _entries;\r\n        mapping(uint256 => uint256) _indexes;\r\n    }\r\n    function _set(\r\n        Map storage map,\r\n        uint256 key,\r\n        uint256 value\r\n    ) private returns (bool) {\r\n        uint256 keyIndex = map._indexes[key];\r\n        if (keyIndex == 0) {\r\n            map._entries.push(MapEntry({_key: key, _value: value}));\r\n            map._indexes[key] = map._entries.length;\r\n            return true;\r\n        } else {\r\n            map._entries[keyIndex - 1]._value = value;\r\n            return false;\r\n        }\r\n    }\r\n    function _remove(Map storage map, uint256 key) private returns (bool) {\r\n        uint256 keyIndex = map._indexes[key];\r\n        if (keyIndex != 0) {\r\n            uint256 toDeleteIndex = keyIndex - 1;\r\n            uint256 lastIndex = map._entries.length - 1;\r\n            MapEntry storage lastEntry = map._entries[lastIndex];\r\n            map._entries[toDeleteIndex] = lastEntry;\r\n            map._indexes[lastEntry._key] = toDeleteIndex + 1;\r\n            map._entries.pop();\r\n            delete map._indexes[key];\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _contains(Map storage map, uint256 key) private view returns (bool) {\r\n        return map._indexes[key] != 0;\r\n    }\r\n    function _length(Map storage map) private view returns (uint256) {\r\n        return map._entries.length;\r\n    }\r\n    function _at(Map storage map, uint256 index) private view returns (uint256, uint256) {\r\n        require(map._entries.length > index, 'EnumerableMap: index out of bounds');\r\n        MapEntry storage entry = map._entries[index];\r\n        return (entry._key, entry._value);\r\n    }\r\n    function _get(Map storage map, uint256 key) private view returns (uint256) {\r\n        return _get(map, key, 'EnumerableMap: nonexistent key');\r\n    }\r\n    function _get(\r\n        Map storage map,\r\n        uint256 key,\r\n        string memory errorMessage\r\n    ) private view returns (uint256) {\r\n        uint256 keyIndex = map._indexes[key];\r\n        require(keyIndex != 0, errorMessage);\r\n        return map._entries[keyIndex - 1]._value;\r\n    }\r\n    struct UintToUintMap {\r\n        Map _inner;\r\n    }\r\n    function set(\r\n        UintToUintMap storage map,\r\n        uint256 key,\r\n        uint256 value\r\n    ) internal returns (bool) {\r\n        return _set(map._inner, key, value);\r\n    }\r\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\r\n        return _remove(map._inner, key);\r\n    }\r\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\r\n        return _contains(map._inner, key);\r\n    }\r\n    function length(UintToUintMap storage map) internal view returns (uint256) {\r\n        return _length(map._inner);\r\n    }\r\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\r\n        return _at(map._inner, index);\r\n    }\r\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\r\n        return _get(map._inner, key);\r\n    }\r\n    function get(\r\n        UintToUintMap storage map,\r\n        uint256 key,\r\n        string memory errorMessage\r\n    ) internal view returns (uint256) {\r\n        return _get(map._inner, key, errorMessage);\r\n    }\r\n}\r\n\r\ninterface IBidNFT {\r\n    function buyToken(uint256 _tokenId) external;\r\n    function buyTokenTo(uint256 _tokenId, address _to) external;\r\n    function setCurrentPrice(uint256 _tokenId, uint256 _price) external;\r\n    function readyToSellToken(uint256 _tokenId, uint256 _price) external;\r\n    function readyToSellTokenTo(uint256 _tokenId, uint256 _price, address _to) external;\r\n    function cancelSellToken(uint256 _tokenId) external;\r\n    function bidToken(uint256 _tokenId, uint256 _price) external;\r\n    function updateBidPrice(uint256 _tokenId, uint256 _price) external;\r\n    function sellTokenTo(uint256 _tokenId, address _to) external;\r\n    function cancelBidToken(uint256 _tokenId) external;\r\n}\r\n\r\ncontract STARSWAP is IBidNFT, ERC721Holder, Ownable, Pausable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using EnumerableMap for EnumerableMap.UintToUintMap;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    struct AskEntry {\r\n        uint256 tokenId;\r\n        uint256 price;\r\n    }\r\n    struct BidEntry {\r\n        address bidder;\r\n        uint256 price;\r\n    }\r\n    struct UserBidEntry {\r\n        uint256 tokenId;\r\n        uint256 price;\r\n    }\r\n    IERC721 public nft;\r\n    IERC20 public quoteErc20;\r\n    address public feeAddr;\r\n    uint256 public feePercent;\r\n    EnumerableMap.UintToUintMap private _asksMap;\r\n    mapping(uint256 => address) private _tokenSellers;\r\n    mapping(address => EnumerableSet.UintSet) private _userSellingTokens;\r\n    mapping(uint256 => BidEntry[]) private _tokenBids;\r\n    mapping(address => EnumerableMap.UintToUintMap) private _userBids;\r\n    event Trade(address indexed seller, address indexed buyer, uint256 indexed tokenId, uint256 price, uint256 fee);\r\n    event Ask(address indexed seller, uint256 indexed tokenId, uint256 price);\r\n    event CancelSellToken(address indexed seller, uint256 indexed tokenId);\r\n    event FeeAddressTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event SetFeePercent(address indexed seller, uint256 oldFeePercent, uint256 newFeePercent);\r\n    event Bid(address indexed bidder, uint256 indexed tokenId, uint256 price);\r\n    event CancelBidToken(address indexed bidder, uint256 indexed tokenId);\r\n\r\n    constructor(\r\n        address _nftAddress,\r\n        address _quoteErc20Address,\r\n        address _feeAddr,\r\n        uint256 _feePercent\r\n    ) public {\r\n        require(_nftAddress != address(0) && _nftAddress != address(this));\r\n        require(_quoteErc20Address != address(0) && _quoteErc20Address != address(this));\r\n        nft = IERC721(_nftAddress);\r\n        quoteErc20 = IERC20(_quoteErc20Address);\r\n        feeAddr = _feeAddr;\r\n        feePercent = _feePercent;\r\n        emit FeeAddressTransferred(address(0), feeAddr);\r\n        emit SetFeePercent(_msgSender(), 0, feePercent);\r\n    }\r\n    function buyToken(uint256 _tokenId) public override whenNotPaused {\r\n        buyTokenTo(_tokenId, _msgSender());\r\n    }\r\n    function buyTokenTo(uint256 _tokenId, address _to) public override whenNotPaused {\r\n        require(_msgSender() != address(0) && _msgSender() != address(this), 'Wrong msg sender');\r\n        require(_asksMap.contains(_tokenId), 'Token not in sell book');\r\n        require(!_userBids[_msgSender()].contains(_tokenId), 'You must cancel your bid first');\r\n        nft.safeTransferFrom(address(this), _to, _tokenId);\r\n        uint256 price = _asksMap.get(_tokenId);\r\n        uint256 feeAmount = price.mul(feePercent).div(100);\r\n        if (feeAmount != 0) {\r\n            quoteErc20.safeTransferFrom(_msgSender(), feeAddr, feeAmount);\r\n        }\r\n        quoteErc20.safeTransferFrom(_msgSender(), _tokenSellers[_tokenId], price.sub(feeAmount));\r\n        _asksMap.remove(_tokenId);\r\n        _userSellingTokens[_tokenSellers[_tokenId]].remove(_tokenId);\r\n        emit Trade(_tokenSellers[_tokenId], _to, _tokenId, price, feeAmount);\r\n        delete _tokenSellers[_tokenId];\r\n    }\r\n    function setCurrentPrice(uint256 _tokenId, uint256 _price) public override whenNotPaused {\r\n        require(_userSellingTokens[_msgSender()].contains(_tokenId), 'Only Seller can update price');\r\n        require(_price != 0, 'Price must be granter than zero');\r\n        _asksMap.set(_tokenId, _price);\r\n        emit Ask(_msgSender(), _tokenId, _price);\r\n    }\r\n    function readyToSellToken(uint256 _tokenId, uint256 _price) public override whenNotPaused {\r\n        readyToSellTokenTo(_tokenId, _price, address(_msgSender()));\r\n    }\r\n    function readyToSellTokenTo(\r\n        uint256 _tokenId,\r\n        uint256 _price,\r\n        address _to\r\n    ) public override whenNotPaused {\r\n        require(_msgSender() == nft.ownerOf(_tokenId), 'Only Token Owner can sell token');\r\n        require(_price != 0, 'Price must be granter than zero');\r\n        nft.safeTransferFrom(address(_msgSender()), address(this), _tokenId);\r\n        _asksMap.set(_tokenId, _price);\r\n        _tokenSellers[_tokenId] = _to;\r\n        _userSellingTokens[_to].add(_tokenId);\r\n        emit Ask(_to, _tokenId, _price);\r\n    }\r\n    function cancelSellToken(uint256 _tokenId) public override whenNotPaused {\r\n        require(_userSellingTokens[_msgSender()].contains(_tokenId), 'Only Seller can cancel sell token');\r\n        nft.safeTransferFrom(address(this), _msgSender(), _tokenId);\r\n        _asksMap.remove(_tokenId);\r\n        _userSellingTokens[_tokenSellers[_tokenId]].remove(_tokenId);\r\n        delete _tokenSellers[_tokenId];\r\n        emit CancelSellToken(_msgSender(), _tokenId);\r\n    }\r\n    function getAskLength() public view returns (uint256) {\r\n        return _asksMap.length();\r\n    }\r\n    function getAsks() public view returns (AskEntry[] memory) {\r\n        AskEntry[] memory asks = new AskEntry[](_asksMap.length());\r\n        for (uint256 i = 0; i < _asksMap.length(); ++i) {\r\n            (uint256 tokenId, uint256 price) = _asksMap.at(i);\r\n            asks[i] = AskEntry({tokenId: tokenId, price: price});\r\n        }\r\n        return asks;\r\n    }\r\n    function getAsksDesc() public view returns (AskEntry[] memory) {\r\n        AskEntry[] memory asks = new AskEntry[](_asksMap.length());\r\n        if (_asksMap.length() > 0) {\r\n            for (uint256 i = _asksMap.length() - 1; i > 0; --i) {\r\n                (uint256 tokenId, uint256 price) = _asksMap.at(i);\r\n                asks[_asksMap.length() - 1 - i] = AskEntry({tokenId: tokenId, price: price});\r\n            }\r\n            (uint256 tokenId, uint256 price) = _asksMap.at(0);\r\n            asks[_asksMap.length() - 1] = AskEntry({tokenId: tokenId, price: price});\r\n        }\r\n        return asks;\r\n    }\r\n    function getAsksByPage(uint256 page, uint256 size) public view returns (AskEntry[] memory) {\r\n        if (_asksMap.length() > 0) {\r\n            uint256 from = page == 0 ? 0 : (page - 1) * size;\r\n            uint256 to = Math.min((page == 0 ? 1 : page) * size, _asksMap.length());\r\n            AskEntry[] memory asks = new AskEntry[]((to - from));\r\n            for (uint256 i = 0; from < to; ++i) {\r\n                (uint256 tokenId, uint256 price) = _asksMap.at(from);\r\n                asks[i] = AskEntry({tokenId: tokenId, price: price});\r\n                ++from;\r\n            }\r\n            return asks;\r\n        } else {\r\n            return new AskEntry[](0);\r\n        }\r\n    }\r\n    function getAsksByPageDesc(uint256 page, uint256 size) public view returns (AskEntry[] memory) {\r\n        if (_asksMap.length() > 0) {\r\n            uint256 from = _asksMap.length() - 1 - (page == 0 ? 0 : (page - 1) * size);\r\n            uint256 to = _asksMap.length() - 1 - Math.min((page == 0 ? 1 : page) * size - 1, _asksMap.length() - 1);\r\n            uint256 resultSize = from - to + 1;\r\n            AskEntry[] memory asks = new AskEntry[](resultSize);\r\n            if (to == 0) {\r\n                for (uint256 i = 0; from > to; ++i) {\r\n                    (uint256 tokenId, uint256 price) = _asksMap.at(from);\r\n                    asks[i] = AskEntry({tokenId: tokenId, price: price});\r\n                    --from;\r\n                }\r\n                (uint256 tokenId, uint256 price) = _asksMap.at(0);\r\n                asks[resultSize - 1] = AskEntry({tokenId: tokenId, price: price});\r\n            } else {\r\n                for (uint256 i = 0; from >= to; ++i) {\r\n                    (uint256 tokenId, uint256 price) = _asksMap.at(from);\r\n                    asks[i] = AskEntry({tokenId: tokenId, price: price});\r\n                    --from;\r\n                }\r\n            }\r\n            return asks;\r\n        }\r\n        return new AskEntry[](0);\r\n    }\r\n    function getAsksByUser(address user) public view returns (AskEntry[] memory) {\r\n        AskEntry[] memory asks = new AskEntry[](_userSellingTokens[user].length());\r\n        for (uint256 i = 0; i < _userSellingTokens[user].length(); ++i) {\r\n            uint256 tokenId = _userSellingTokens[user].at(i);\r\n            uint256 price = _asksMap.get(tokenId);\r\n            asks[i] = AskEntry({tokenId: tokenId, price: price});\r\n        }\r\n        return asks;\r\n    }\r\n    function getAsksByUserDesc(address user) public view returns (AskEntry[] memory) {\r\n        AskEntry[] memory asks = new AskEntry[](_userSellingTokens[user].length());\r\n        if (_userSellingTokens[user].length() > 0) {\r\n            for (uint256 i = _userSellingTokens[user].length() - 1; i > 0; --i) {\r\n                uint256 tokenId = _userSellingTokens[user].at(i);\r\n                uint256 price = _asksMap.get(tokenId);\r\n                asks[_userSellingTokens[user].length() - 1 - i] = AskEntry({tokenId: tokenId, price: price});\r\n            }\r\n            uint256 tokenId = _userSellingTokens[user].at(0);\r\n            uint256 price = _asksMap.get(tokenId);\r\n            asks[_userSellingTokens[user].length() - 1] = AskEntry({tokenId: tokenId, price: price});\r\n        }\r\n        return asks;\r\n    }\r\n    function pause() public onlyOwner whenNotPaused {\r\n        _pause();\r\n    }\r\n    function unpause() public onlyOwner whenPaused {\r\n        _unpause();\r\n    }\r\n    function transferFeeAddress(address _feeAddr) public {\r\n        require(_msgSender() == feeAddr, 'FORBIDDEN');\r\n        feeAddr = _feeAddr;\r\n        emit FeeAddressTransferred(_msgSender(), feeAddr);\r\n    }\r\n    function setFeePercent(uint256 _feePercent) public onlyOwner {\r\n        require(feePercent != _feePercent, 'Not need update');\r\n        emit SetFeePercent(_msgSender(), feePercent, _feePercent);\r\n        feePercent = _feePercent;\r\n    }\r\n    function bidToken(uint256 _tokenId, uint256 _price) public override whenNotPaused {\r\n        require(_msgSender() != address(0) && _msgSender() != address(this), 'Wrong msg sender');\r\n        require(_price != 0, 'Price must be granter than zero');\r\n        require(_asksMap.contains(_tokenId), 'Token not in sell book');\r\n        address _seller = _tokenSellers[_tokenId];\r\n        address _to = address(_msgSender());\r\n        require(_seller != _to, 'Owner cannot bid');\r\n        require(!_userBids[_to].contains(_tokenId), 'Bidder already exists');\r\n        quoteErc20.safeTransferFrom(address(_msgSender()), address(this), _price);\r\n        _userBids[_to].set(_tokenId, _price);\r\n        _tokenBids[_tokenId].push(BidEntry({bidder: _to, price: _price}));\r\n        emit Bid(_msgSender(), _tokenId, _price);\r\n    }\r\n    function updateBidPrice(uint256 _tokenId, uint256 _price) public override whenNotPaused {\r\n        require(_userBids[_msgSender()].contains(_tokenId), 'Only Bidder can update the bid price');\r\n        require(_price != 0, 'Price must be granter than zero');\r\n        address _to = address(_msgSender()); // find  bid and the index\r\n        (BidEntry memory bidEntry, uint256 _index) = getBidByTokenIdAndAddress(_tokenId, _to);\r\n        require(bidEntry.price != 0, 'Bidder does not exist');\r\n        require(bidEntry.price != _price, 'The bid price cannot be the same');\r\n        if (_price > bidEntry.price) {\r\n            quoteErc20.safeTransferFrom(address(_msgSender()), address(this), _price - bidEntry.price);\r\n        } else {\r\n            quoteErc20.transfer(_to, bidEntry.price - _price);\r\n        }\r\n        _userBids[_to].set(_tokenId, _price);\r\n        _tokenBids[_tokenId][_index] = BidEntry({bidder: _to, price: _price});\r\n        emit Bid(_msgSender(), _tokenId, _price);\r\n    }\r\n    function getBidByTokenIdAndAddress(uint256 _tokenId, address _address)\r\n        private\r\n        view\r\n        returns (BidEntry memory, uint256)\r\n    {\r\n        BidEntry[] memory bidEntries = _tokenBids[_tokenId];\r\n        uint256 len = bidEntries.length;\r\n        uint256 _index;\r\n        BidEntry memory bidEntry;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            if (_address == bidEntries[i].bidder) {\r\n                _index = i;\r\n                bidEntry = BidEntry({bidder: bidEntries[i].bidder, price: bidEntries[i].price});\r\n                break;\r\n            }\r\n        }\r\n        return (bidEntry, _index);\r\n    }\r\n    function delBidByTokenIdAndIndex(uint256 _tokenId, uint256 _index) private {\r\n        _userBids[_tokenBids[_tokenId][_index].bidder].remove(_tokenId);\r\n        uint256 len = _tokenBids[_tokenId].length;\r\n        for (uint256 i = _index; i < len - 1; i++) {\r\n            _tokenBids[_tokenId][i] = _tokenBids[_tokenId][i + 1];\r\n        }\r\n        _tokenBids[_tokenId].pop();\r\n    }\r\n    function sellTokenTo(uint256 _tokenId, address _to) public override whenNotPaused {\r\n        require(_asksMap.contains(_tokenId), 'Token not in sell book');\r\n        address _seller = _tokenSellers[_tokenId];\r\n        address _owner = address(_msgSender());\r\n        require(_seller == _owner, 'Only owner can sell token');\r\n        (BidEntry memory bidEntry, uint256 _index) = getBidByTokenIdAndAddress(_tokenId, _to);\r\n        require(bidEntry.price != 0, 'Bidder does not exist');\r\n        nft.safeTransferFrom(address(this), _to, _tokenId);\r\n        uint256 price = bidEntry.price;\r\n        uint256 feeAmount = price.mul(feePercent).div(100);\r\n        if (feeAmount != 0) {\r\n            quoteErc20.transfer(feeAddr, feeAmount);\r\n        }\r\n        quoteErc20.transfer(_seller, price.sub(feeAmount));\r\n        _asksMap.remove(_tokenId);\r\n        _userSellingTokens[_tokenSellers[_tokenId]].remove(_tokenId);\r\n        delBidByTokenIdAndIndex(_tokenId, _index);\r\n        emit Trade(_tokenSellers[_tokenId], _to, _tokenId, price, feeAmount);\r\n        delete _tokenSellers[_tokenId];\r\n    }\r\n    function cancelBidToken(uint256 _tokenId) public override whenNotPaused {\r\n        require(_userBids[_msgSender()].contains(_tokenId), 'Only Bidder can cancel the bid');\r\n        address _address = address(_msgSender());\r\n        (BidEntry memory bidEntry, uint256 _index) = getBidByTokenIdAndAddress(_tokenId, _address);\r\n        require(bidEntry.price != 0, 'Bidder does not exist');\r\n        quoteErc20.transfer(_address, bidEntry.price);\r\n        delBidByTokenIdAndIndex(_tokenId, _index);\r\n        emit CancelBidToken(_msgSender(), _tokenId);\r\n    }\r\n    function getBidsLength(uint256 _tokenId) public view returns (uint256) {\r\n        return _tokenBids[_tokenId].length;\r\n    }\r\n    function getBids(uint256 _tokenId) public view returns (BidEntry[] memory) {\r\n        return _tokenBids[_tokenId];\r\n    }\r\n    function getUserBids(address user) public view returns (UserBidEntry[] memory) {\r\n        uint256 len = _userBids[user].length();\r\n        UserBidEntry[] memory bids = new UserBidEntry[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            (uint256 tokenId, uint256 price) = _userBids[user].at(i);\r\n            bids[i] = UserBidEntry({tokenId: tokenId, price: price});\r\n        }\r\n        return bids;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_quoteErc20Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feePercent\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Ask\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"CancelBidToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"CancelSellToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"FeeAddressTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFeePercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeePercent\",\"type\":\"uint256\"}],\"name\":\"SetFeePercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"bidToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"buyTokenTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelBidToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelSellToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAskLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAsks\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct STARSWAP.AskEntry[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getAsksByPage\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct STARSWAP.AskEntry[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getAsksByPageDesc\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct STARSWAP.AskEntry[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAsksByUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct STARSWAP.AskEntry[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAsksByUserDesc\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct STARSWAP.AskEntry[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAsksDesc\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct STARSWAP.AskEntry[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getBids\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct STARSWAP.BidEntry[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getBidsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserBids\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct STARSWAP.UserBidEntry[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteErc20\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"readyToSellToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"readyToSellTokenTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"sellTokenTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setCurrentPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feePercent\",\"type\":\"uint256\"}],\"name\":\"setFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAddr\",\"type\":\"address\"}],\"name\":\"transferFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateBidPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"STARSWAP","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d35e1708704731c34bd409fab1874d6d66ad559b000000000000000000000000ab456bdb0a373bbac6c4a76176e9f159cacd5752000000000000000000000000ef202eabac14281319465d63358842a743b75c770000000000000000000000000000000000000000000000000000000000000005","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f83350997e1147c40035f48bcd379ed08f898a03189ee22c5417052a1a904f73"}]}