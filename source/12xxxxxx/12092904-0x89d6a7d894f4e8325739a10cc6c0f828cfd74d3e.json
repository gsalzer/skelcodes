{"status":"1","message":"OK","result":[{"SourceCode":"{\"BlobFormation.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\nimport \\u0027./LibInteger.sol\\u0027;\\n\\n/**\\n * @title BlobFormation \\n * @dev HBF token contract adhering to ERC20 standard\\n */\\ncontract BlobFormation\\n{\\n    using LibInteger for uint;\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n\\n    /**\\n     * @dev The admin of the contract\\n     */\\n    address payable private _admin;\\n\\n    /**\\n     * @dev The current supply of token\\n     */\\n    uint private _supply;\\n\\n    /**\\n     * @dev Permitted addresses to carry out special functions\\n     */\\n    mapping (address =\\u003e bool) private _permissions;\\n\\n    /**\\n     * @dev Number of tokens held by an address\\n     */\\n    mapping (address =\\u003e uint) private _token_balances;\\n\\n    /**\\n     * @dev Approved allowances for third party addresses\\n     */\\n    mapping (address =\\u003e mapping(address =\\u003e uint)) private _token_allowances;\\n\\n    /**\\n     * Number of decimals in base currency\\n     */\\n    uint private constant _decimals = 18;\\n\\n    /**\\n     * @dev The Maximum supply of token\\n     */\\n    uint private constant _max_supply = 400000 * 10**_decimals;\\n\\n    /**\\n     * @dev The name of token\\n     */\\n    string private constant _name = \\\"Hash Blob Formation\\\";\\n\\n    /**\\n     * @dev The symbol of token\\n     */\\n    string private constant _symbol = \\\"HBF\\\";\\n\\n    /**\\n     * @dev Initialise the contract\\n     */\\n    constructor() public\\n    {\\n        //The contract creator becomes the admin\\n        _admin = msg.sender;\\n\\n        //Mint max supply and send it to the admin\\n        _supply = _max_supply;\\n        _token_balances[_admin] = _supply;\\n        emit Transfer(address(0), _admin, _supply);\\n    }\\n\\n    /**\\n     * @dev Allow access only for the admin of contract\\n     */\\n    modifier onlyAdmin()\\n    {\\n        require(msg.sender == _admin);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the permitted addresses\\n     */\\n    modifier onlyPermitted()\\n    {\\n        require(_permissions[msg.sender]);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Give or revoke permission of accounts\\n     * @param account The address to change permission\\n     * @param permission True if the permission should be granted, false if it should be revoked\\n     */\\n    function permit(address account, bool permission) public onlyAdmin\\n    {\\n        _permissions[account] = permission;\\n    }\\n\\n    /**\\n     * @dev Withdraw from the balance of this contract\\n     * @param amount The amount to be withdrawn, if zero is provided the whole balance will be withdrawn\\n     */\\n    function clean(uint amount) public onlyAdmin\\n    {\\n        if (amount == 0){\\n            _admin.transfer(address(this).balance);\\n        } else {\\n            _admin.transfer(amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Moves tokens from the caller\\u0027s account to someone else\\n     * @param to The recipient address\\n     * @param value The number of tokens to send\\n     */\\n    function transfer(address to, uint value) public\\n    {\\n        _send(msg.sender, to, value);\\n    }\\n\\n    /**\\n     * @dev Sets amount of tokens spender is allowed to transfer from caller\\u0027s tokens\\n     * @param spender The spender to allow\\n     * @param value The number of tokens to allow\\n     */\\n    function approve(address spender, uint value) public\\n    {\\n        _token_allowances[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n    }\\n\\n    /**\\n     * @dev Moves tokens using the allowance mechanism\\n     * @param from The owner of tokens\\n     * @param to The recipient address\\n     * @param value The number of tokens to send\\n     */\\n    function transferFrom(address from, address to, uint value) public\\n    {\\n        _token_allowances[from][msg.sender] = _token_allowances[from][msg.sender].sub(value);\\n        _send(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Burn tokens forever\\n     * @param from The owner of tokens\\n     * @param value The number of tokens to be burned\\n     */\\n    function burn(address from, uint value) public onlyPermitted\\n    {\\n        //Must set number of tokens that needs to be burned\\n        require(value \\u003e 0);\\n\\n        //The total supply must be greater than the tokens that needs to be burned\\n        require(_supply \\u003e= value);\\n\\n        //The owner must have enough tokens available\\n        require(_token_balances[from] \\u003e= value);\\n\\n        //Reduce supply\\n        _supply = _supply.sub(value);\\n\\n        //Reduce owner\\u0027s balance\\n        _token_balances[from] = _token_balances[from].sub(value);\\n\\n        //Emit events and return\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Get the total number of tokens in existance\\n     * @return uint Number of tokens\\n     */\\n    function totalSupply() public view returns (uint)\\n    {\\n        return _supply;\\n    }\\n\\n    /**\\n     * @dev Get the maximum number of tokens minted\\n     * @return uint Maximum number of tokens\\n     */\\n    function maxSupply() public pure returns (uint)\\n    {\\n        return _max_supply;\\n    }\\n\\n    /**\\n     * @dev Get the total number of tokens spender is allowed to spend out of owner\\u0027s tokens\\n     * @param owner The tokens owner\\n     * @param spender The allowed spender\\n     * @return uint Number of tokens allowed to spend\\n     */\\n    function allowance(address owner, address spender) public view returns (uint)\\n    {\\n        return _token_allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Get number of tokens belonging to an account\\n     * @param account The address of account to check\\n     * @return uint The tokens balance\\n     */\\n    function balanceOf(address account) public view returns (uint)\\n    {\\n        return _token_balances[account];\\n    }\\n\\n    /**\\n     * @dev Get name of token\\n     * @return string The name\\n     */\\n    function name() public pure returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Get symbol of token\\n     * @return string The symbol\\n     */\\n    function symbol() public pure returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Get number of decimals of token\\n     * @return uint The decimals count\\n     */\\n    function decimals() public pure returns (uint)\\n    {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev Check whether the provided address is permitted\\n     * @param account The address to check\\n     * @return bool True if the address is permitted, otherwise false\\n     */\\n    function isPermitted(address account) public view returns (bool)\\n    {\\n        return _permissions[account];\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one account to another\\n     * @param from The token owner\\n     * @param to The token receiver\\n     * @param value The number of tokens to transfer\\n     */\\n    function _send(address from, address to, uint value) private\\n    {\\n        //Reduce the balance from owner\\n        _token_balances[from] = _token_balances[from].sub(value);\\n\\n        //Increase the balance of receiver\\n        _token_balances[to] = _token_balances[to].add(value);\\n\\n        //Emit events\\n        emit Transfer(from, to, value);\\n    }\\n}\"},\"LibInteger.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\n/**\\n * @title LibInteger \\n * @dev Integer related utility functions\\n */\\nlibrary LibInteger\\n{    \\n    /**\\n     * @dev Safely multiply, revert on overflow\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function mul(uint a, uint b) internal pure returns (uint)\\n    {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely divide, revert if divisor is zero\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function div(uint a, uint b) internal pure returns (uint)\\n    {\\n        require(b \\u003e 0, \\\"\\\");\\n        uint c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely substract, revert if answer is negative\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function sub(uint a, uint b) internal pure returns (uint)\\n    {\\n        require(b \\u003c= a, \\\"\\\");\\n        uint c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely add, revert if overflow\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function add(uint a, uint b) internal pure returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Convert number to string\\n     * @param value The number to convert\\n     * @return string The string representation\\n    */\\n    function toString(uint value) internal pure returns (string memory)\\n    {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n\\n        uint temp = value;\\n        uint digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n        uint index = digits - 1;\\n        \\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        \\n        return string(buffer);\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPermitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"clean\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"permission\",\"type\":\"bool\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BlobFormation","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6094187b42b7a7e0ea213b7d9b28486e0fca9367e77da2a27dd2c73f69f8217c"}]}