{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\n\n\n// Part: IERC721\n\ninterface IERC721 {\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\n    \n    function setApprovalForAll(address operator, bool approved) external;\n\n    function approve(address to, uint256 tokenId) external;\n    \n    function isApprovedForAll(address owner, address operator) external returns (bool);\n}\n\n// Part: IERC721Sale\n\ninterface IERC721Sale {\n    /* An ECDSA signature. */\n    struct Sig {\n        /* v parameter */\n        uint8 v;\n        /* r parameter */\n        bytes32 r;\n        /* s parameter */\n        bytes32 s;\n    }\n\n    function buy(address token, uint256 tokenId, uint256 price, uint256 sellerFee, Sig memory signature) external payable;\n\n    function buyerFee() external view returns(uint256);\n}\n\n// File: UniqueOneMarket.sol\n\nlibrary UniqueOneMarket {\n    address public constant ERC721SALE = 0x06dB0695AD7A72b025a83a500C7E728d4a35297e;\n\n    struct UniqueOneBuy {\n        address token; \n        uint256 tokenId; \n        uint256 price; \n        uint256 sellerFee; \n        IERC721Sale.Sig signature;\n    }\n\n    function buyAssetsForEth(bytes memory data, address recipient) public {\n        UniqueOneBuy[] memory uniqueOneBuys;\n\n        (uniqueOneBuys) = abi.decode(\n            data,\n            (UniqueOneBuy[])\n        );\n\n        for (uint256 i = 0; i < uniqueOneBuys.length; i++) {\n            _buyAssetForEth(\n                uniqueOneBuys[i].tokenId, \n                uniqueOneBuys[i].price, \n                uniqueOneBuys[i].sellerFee, \n                uniqueOneBuys[i].signature, \n                uniqueOneBuys[i].token, \n                recipient);\n        }\n    }\n\n    function estimateBatchAssetPriceInEth(bytes memory data) public view returns(uint256 totalCost) {\n        uint256[] memory prices;\n\n        (prices) = abi.decode(\n            data,\n            (uint256[])\n        );\n\n        for (uint256 i = 0; i < prices.length; i++) {\n            totalCost += prices[i] = prices[i] + prices[i]*IERC721Sale(ERC721SALE).buyerFee()/10000;\n        }\n    }\n \n    function _buyAssetForEth(uint256 _tokenId, uint256 _price, uint256 _sellerFee, IERC721Sale.Sig memory _signature, address _token, address _recipient) internal {\n        bytes memory _data = abi.encodeWithSelector(IERC721Sale(ERC721SALE).buy.selector, _token, _tokenId, _price, _sellerFee, _signature);\n        _price = _price + _price*IERC721Sale(ERC721SALE).buyerFee()/10000;\n \n        (bool success, ) = ERC721SALE.call{value:_price}(_data);\n        require(success, \"_buyAssetForEth: uniqueone buy failed.\");\n\n        IERC721(_token).transferFrom(address(this), _recipient, _tokenId);               \n    }\n}\n","ABI":"[{\"inputs\":[],\"name\":\"ERC721SALE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"estimateBatchAssetPriceInEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniqueOneMarket","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}