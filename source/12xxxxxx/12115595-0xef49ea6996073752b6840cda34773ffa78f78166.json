{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/common/governance/IGovernance.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ninterface IGovernance {\r\n    function update(address target, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/common/governance/Governable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Governable {\r\n    IGovernance public governance;\r\n\r\n    constructor(address _governance) public {\r\n        governance = IGovernance(_governance);\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        _assertGovernance();\r\n        _;\r\n    }\r\n\r\n    function _assertGovernance() private view {\r\n        require(\r\n            msg.sender == address(governance),\r\n            \"Only governance contract is authorized\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/IWithdrawManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract IWithdrawManager {\r\n    function createExitQueue(address token) external;\r\n\r\n    function verifyInclusion(\r\n        bytes calldata data,\r\n        uint8 offset,\r\n        bool verifyTxInclusion\r\n    ) external view returns (uint256 age);\r\n\r\n    function addExitToQueue(\r\n        address exitor,\r\n        address childToken,\r\n        address rootToken,\r\n        uint256 exitAmountOrTokenId,\r\n        bytes32 txHash,\r\n        bool isRegularExit,\r\n        uint256 priority\r\n    ) external;\r\n\r\n    function addInput(\r\n        uint256 exitId,\r\n        uint256 age,\r\n        address utxoOwner,\r\n        address token\r\n    ) external;\r\n\r\n    function challengeExit(\r\n        uint256 exitId,\r\n        uint256 inputId,\r\n        bytes calldata challengeData,\r\n        address adjudicatorPredicate\r\n    ) external;\r\n}\r\n\r\n// File: contracts/common/Registry.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract Registry is Governable {\r\n    // @todo hardcode constants\r\n    bytes32 private constant WETH_TOKEN = keccak256(\"wethToken\");\r\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\"depositManager\");\r\n    bytes32 private constant STAKE_MANAGER = keccak256(\"stakeManager\");\r\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\"validatorShare\");\r\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\"withdrawManager\");\r\n    bytes32 private constant CHILD_CHAIN = keccak256(\"childChain\");\r\n    bytes32 private constant STATE_SENDER = keccak256(\"stateSender\");\r\n    bytes32 private constant SLASHING_MANAGER = keccak256(\"slashingManager\");\r\n\r\n    address public erc20Predicate;\r\n    address public erc721Predicate;\r\n\r\n    mapping(bytes32 => address) public contractMap;\r\n    mapping(address => address) public rootToChildToken;\r\n    mapping(address => address) public childToRootToken;\r\n    mapping(address => bool) public proofValidatorContracts;\r\n    mapping(address => bool) public isERC721;\r\n\r\n    enum Type {Invalid, ERC20, ERC721, Custom}\r\n    struct Predicate {\r\n        Type _type;\r\n    }\r\n    mapping(address => Predicate) public predicates;\r\n\r\n    event TokenMapped(address indexed rootToken, address indexed childToken);\r\n    event ProofValidatorAdded(address indexed validator, address indexed from);\r\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\r\n    event PredicateAdded(address indexed predicate, address indexed from);\r\n    event PredicateRemoved(address indexed predicate, address indexed from);\r\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\r\n\r\n    constructor(address _governance) public Governable(_governance) {}\r\n\r\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\r\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\r\n        contractMap[_key] = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Map root token to child token\r\n     * @param _rootToken Token address on the root chain\r\n     * @param _childToken Token address on the child chain\r\n     * @param _isERC721 Is the token being mapped ERC721\r\n     */\r\n    function mapToken(\r\n        address _rootToken,\r\n        address _childToken,\r\n        bool _isERC721\r\n    ) external onlyGovernance {\r\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \"INVALID_TOKEN_ADDRESS\");\r\n        rootToChildToken[_rootToken] = _childToken;\r\n        childToRootToken[_childToken] = _rootToken;\r\n        isERC721[_rootToken] = _isERC721;\r\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\r\n        emit TokenMapped(_rootToken, _childToken);\r\n    }\r\n\r\n    function addErc20Predicate(address predicate) public onlyGovernance {\r\n        require(predicate != address(0x0), \"Can not add null address as predicate\");\r\n        erc20Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC20);\r\n    }\r\n\r\n    function addErc721Predicate(address predicate) public onlyGovernance {\r\n        erc721Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC721);\r\n    }\r\n\r\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\r\n        require(predicates[predicate]._type == Type.Invalid, \"Predicate already added\");\r\n        predicates[predicate]._type = _type;\r\n        emit PredicateAdded(predicate, msg.sender);\r\n    }\r\n\r\n    function removePredicate(address predicate) public onlyGovernance {\r\n        require(predicates[predicate]._type != Type.Invalid, \"Predicate does not exist\");\r\n        delete predicates[predicate];\r\n        emit PredicateRemoved(predicate, msg.sender);\r\n    }\r\n\r\n    function getValidatorShareAddress() public view returns (address) {\r\n        return contractMap[VALIDATOR_SHARE];\r\n    }\r\n\r\n    function getWethTokenAddress() public view returns (address) {\r\n        return contractMap[WETH_TOKEN];\r\n    }\r\n\r\n    function getDepositManagerAddress() public view returns (address) {\r\n        return contractMap[DEPOSIT_MANAGER];\r\n    }\r\n\r\n    function getStakeManagerAddress() public view returns (address) {\r\n        return contractMap[STAKE_MANAGER];\r\n    }\r\n\r\n    function getSlashingManagerAddress() public view returns (address) {\r\n        return contractMap[SLASHING_MANAGER];\r\n    }\r\n\r\n    function getWithdrawManagerAddress() public view returns (address) {\r\n        return contractMap[WITHDRAW_MANAGER];\r\n    }\r\n\r\n    function getChildChainAndStateSender() public view returns (address, address) {\r\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\r\n    }\r\n\r\n    function isTokenMapped(address _token) public view returns (bool) {\r\n        return rootToChildToken[_token] != address(0x0);\r\n    }\r\n\r\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\r\n        require(isTokenMapped(_token), \"TOKEN_NOT_MAPPED\");\r\n        return isERC721[_token];\r\n    }\r\n\r\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\r\n        if (isTokenMappedAndIsErc721(_token)) {\r\n            return erc721Predicate;\r\n        }\r\n        return erc20Predicate;\r\n    }\r\n\r\n    function isChildTokenErc721(address childToken) public view returns (bool) {\r\n        address rootToken = childToRootToken[childToken];\r\n        require(rootToken != address(0x0), \"Child token is not mapped\");\r\n        return isERC721[rootToken];\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/Lockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract Lockable {\r\n    bool public locked;\r\n\r\n    modifier onlyWhenUnlocked() {\r\n        _assertUnlocked();\r\n        _;\r\n    }\r\n\r\n    function _assertUnlocked() private view {\r\n        require(!locked, \"locked\");\r\n    }\r\n\r\n    function lock() public {\r\n        locked = true;\r\n    }\r\n\r\n    function unlock() public {\r\n        locked = false;\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/GovernanceLockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract GovernanceLockable is Lockable, Governable {\r\n    constructor(address governance) public Governable(governance) {}\r\n\r\n    function lock() public onlyGovernance {\r\n        super.lock();\r\n    }\r\n\r\n    function unlock() public onlyGovernance {\r\n        super.unlock();\r\n    }\r\n}\r\n\r\n// File: contracts/staking/stakeManager/IStakeManager.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract IStakeManager {\r\n    // validator replacement\r\n    function startAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\r\n\r\n    function transferFunds(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function delegationDeposit(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function unstake(uint256 validatorId) external;\r\n\r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes memory signerPubkey\r\n    ) public;\r\n\r\n    function checkSignatures(\r\n        uint256 blockInterval,\r\n        bytes32 voteHash,\r\n        bytes32 stateRoot,\r\n        address proposer,\r\n        uint[3][] calldata sigs\r\n    ) external returns (uint256);\r\n\r\n    function updateValidatorState(uint256 validatorId, int256 amount) public;\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n\r\n    function slash(bytes calldata slashingInfoList) external returns (uint256);\r\n\r\n    function validatorStake(uint256 validatorId) public view returns (uint256);\r\n\r\n    function epoch() public view returns (uint256);\r\n\r\n    function getRegistry() public view returns (address);\r\n\r\n    function withdrawalDelay() public view returns (uint256);\r\n\r\n    function delegatedAmount(uint256 validatorId) public view returns(uint256);\r\n\r\n    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;\r\n\r\n    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);\r\n\r\n    function delegatorsReward(uint256 validatorId) public view returns(uint256);\r\n\r\n    function dethroneAndStake(\r\n        address auctionUser,\r\n        uint256 heimdallFee,\r\n        uint256 validatorId,\r\n        uint256 auctionAmount,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/RootChainable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title RootChainable\r\n */\r\ncontract RootChainable is Ownable {\r\n    address public rootChain;\r\n\r\n    // Rootchain changed\r\n    event RootChainChanged(\r\n        address indexed previousRootChain,\r\n        address indexed newRootChain\r\n    );\r\n\r\n    // only root chain\r\n    modifier onlyRootChain() {\r\n        require(msg.sender == rootChain);\r\n        _;\r\n    }\r\n\r\n    /**\r\n   * @dev Allows the current owner to change root chain address.\r\n   * @param newRootChain The address to new rootchain.\r\n   */\r\n    function changeRootChain(address newRootChain) public onlyOwner {\r\n        require(newRootChain != address(0));\r\n        emit RootChainChanged(rootChain, newRootChain);\r\n        rootChain = newRootChain;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/StakingInfo.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n// dummy interface to avoid cyclic dependency\r\ncontract IStakeManagerLocal {\r\n    enum Status {Inactive, Active, Locked, Unstaked}\r\n\r\n    struct Validator {\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 activationEpoch;\r\n        uint256 deactivationEpoch;\r\n        uint256 jailTime;\r\n        address signer;\r\n        address contractAddress;\r\n        Status status;\r\n    }\r\n\r\n    mapping(uint256 => Validator) public validators;\r\n    bytes32 public accountStateRoot;\r\n    uint256 public activeAmount; // delegation amount from validator contract\r\n    uint256 public validatorRewards;\r\n\r\n    function currentValidatorSetTotalStake() public view returns (uint256);\r\n\r\n    // signer to Validator mapping\r\n    function signerToValidator(address validatorAddress)\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function isValidator(uint256 validatorId) public view returns (bool);\r\n}\r\n\r\ncontract StakingInfo is Ownable {\r\n    using SafeMath for uint256;\r\n    mapping(uint256 => uint256) public validatorNonce;\r\n\r\n    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.\r\n    /// @param signer validator address.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param activationEpoch validator's first epoch as proposer.\r\n    /// @param amount staking amount.\r\n    /// @param total total staking amount.\r\n    /// @param signerPubkey public key of the validator\r\n    event Staked(\r\n        address indexed signer,\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        uint256 indexed activationEpoch,\r\n        uint256 amount,\r\n        uint256 total,\r\n        bytes signerPubkey\r\n    );\r\n\r\n    /// @dev Emitted when validator unstakes in 'unstakeClaim()'\r\n    /// @param user address of the validator.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param amount staking amount.\r\n    /// @param total total staking amount.\r\n    event Unstaked(\r\n        address indexed user,\r\n        uint256 indexed validatorId,\r\n        uint256 amount,\r\n        uint256 total\r\n    );\r\n\r\n    /// @dev Emitted when validator unstakes in '_unstake()'.\r\n    /// @param user address of the validator.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param deactivationEpoch last epoch for validator.\r\n    /// @param amount staking amount.\r\n    event UnstakeInit(\r\n        address indexed user,\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        uint256 deactivationEpoch,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param oldSigner old address of the validator.\r\n    /// @param newSigner new address of the validator.\r\n    /// @param signerPubkey public key of the validator.\r\n    event SignerChange(\r\n        uint256 indexed validatorId,\r\n        uint256 nonce,\r\n        address indexed oldSigner,\r\n        address indexed newSigner,\r\n        bytes signerPubkey\r\n    );\r\n    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);\r\n    event Jailed(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed exitEpoch,\r\n        address indexed signer\r\n    );\r\n    event UnJailed(uint256 indexed validatorId, address indexed signer);\r\n    event Slashed(uint256 indexed nonce, uint256 indexed amount);\r\n    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);\r\n    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);\r\n    event ProposerBonusChange(\r\n        uint256 newProposerBonus,\r\n        uint256 oldProposerBonus\r\n    );\r\n\r\n    event RewardUpdate(uint256 newReward, uint256 oldReward);\r\n\r\n    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().\r\n    /// @param validatorId unique integer to identify a validator.\r\n    /// @param nonce to synchronize the events in heimdal.\r\n    /// @param newAmount the updated stake amount.\r\n    event StakeUpdate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed nonce,\r\n        uint256 indexed newAmount\r\n    );\r\n    event ClaimRewards(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed amount,\r\n        uint256 indexed totalAmount\r\n    );\r\n    event StartAuction(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed amount,\r\n        uint256 indexed auctionAmount\r\n    );\r\n    event ConfirmAuction(\r\n        uint256 indexed newValidatorId,\r\n        uint256 indexed oldValidatorId,\r\n        uint256 indexed amount\r\n    );\r\n    event TopUpFee(address indexed user, uint256 indexed fee);\r\n    event ClaimFee(address indexed user, uint256 indexed fee);\r\n    // Delegator events\r\n    event ShareMinted(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed amount,\r\n        uint256 tokens\r\n    );\r\n    event ShareBurned(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed amount,\r\n        uint256 tokens\r\n    );\r\n    event DelegatorClaimedRewards(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed rewards\r\n    );\r\n    event DelegatorRestaked(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed totalStaked\r\n    );\r\n    event DelegatorUnstaked(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n    event UpdateCommissionRate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed newCommissionRate,\r\n        uint256 indexed oldCommissionRate\r\n    );\r\n\r\n    Registry public registry;\r\n\r\n    modifier onlyValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        (, , , , , , _contract, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n        require(_contract == msg.sender,\r\n        \"Invalid sender, not validator\");\r\n        _;\r\n    }\r\n\r\n    modifier StakeManagerOrValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        address _stakeManager = registry.getStakeManagerAddress();\r\n        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(\r\n            validatorId\r\n        );\r\n        require(_contract == msg.sender || _stakeManager == msg.sender,\r\n        \"Invalid sender, not stake manager or validator contract\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyStakeManager() {\r\n        require(registry.getStakeManagerAddress() == msg.sender,\r\n        \"Invalid sender, not stake manager\");\r\n        _;\r\n    }\r\n    modifier onlySlashingManager() {\r\n        require(registry.getSlashingManagerAddress() == msg.sender,\r\n        \"Invalid sender, not slashing manager\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _registry) public {\r\n        registry = Registry(_registry);\r\n    }\r\n\r\n    function updateNonce(\r\n        uint256[] calldata validatorIds,\r\n        uint256[] calldata nonces\r\n    ) external onlyOwner {\r\n        require(validatorIds.length == nonces.length, \"args length mismatch\");\r\n\r\n        for (uint256 i = 0; i < validatorIds.length; ++i) {\r\n            validatorNonce[validatorIds[i]] = nonces[i];\r\n        }\r\n    } \r\n\r\n    function logStaked(\r\n        address signer,\r\n        bytes memory signerPubkey,\r\n        uint256 validatorId,\r\n        uint256 activationEpoch,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit Staked(\r\n            signer,\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            activationEpoch,\r\n            amount,\r\n            total,\r\n            signerPubkey\r\n        );\r\n    }\r\n\r\n    function logUnstaked(\r\n        address user,\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 total\r\n    ) public onlyStakeManager {\r\n        emit Unstaked(user, validatorId, amount, total);\r\n    }\r\n\r\n    function logUnstakeInit(\r\n        address user,\r\n        uint256 validatorId,\r\n        uint256 deactivationEpoch,\r\n        uint256 amount\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit UnstakeInit(\r\n            user,\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            deactivationEpoch,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function logSignerChange(\r\n        uint256 validatorId,\r\n        address oldSigner,\r\n        address newSigner,\r\n        bytes memory signerPubkey\r\n    ) public onlyStakeManager {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit SignerChange(\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            oldSigner,\r\n            newSigner,\r\n            signerPubkey\r\n        );\r\n    }\r\n\r\n    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit Restaked(validatorId, amount, total);\r\n    }\r\n\r\n    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit Jailed(validatorId, exitEpoch, signer);\r\n    }\r\n\r\n    function logUnjailed(uint256 validatorId, address signer)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit UnJailed(validatorId, signer);\r\n    }\r\n\r\n    function logSlashed(uint256 nonce, uint256 amount)\r\n        public\r\n        onlySlashingManager\r\n    {\r\n        emit Slashed(nonce, amount);\r\n    }\r\n\r\n    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit ThresholdChange(newThreshold, oldThreshold);\r\n    }\r\n\r\n    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit DynastyValueChange(newDynasty, oldDynasty);\r\n    }\r\n\r\n    function logProposerBonusChange(\r\n        uint256 newProposerBonus,\r\n        uint256 oldProposerBonus\r\n    ) public onlyStakeManager {\r\n        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);\r\n    }\r\n\r\n    function logRewardUpdate(uint256 newReward, uint256 oldReward)\r\n        public\r\n        onlyStakeManager\r\n    {\r\n        emit RewardUpdate(newReward, oldReward);\r\n    }\r\n\r\n    function logStakeUpdate(uint256 validatorId)\r\n        public\r\n        StakeManagerOrValidatorContract(validatorId)\r\n    {\r\n        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\r\n        emit StakeUpdate(\r\n            validatorId,\r\n            validatorNonce[validatorId],\r\n            totalValidatorStake(validatorId)\r\n        );\r\n    }\r\n\r\n    function logClaimRewards(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 totalAmount\r\n    ) public onlyStakeManager {\r\n        emit ClaimRewards(validatorId, amount, totalAmount);\r\n    }\r\n\r\n    function logStartAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        uint256 auctionAmount\r\n    ) public onlyStakeManager {\r\n        emit StartAuction(validatorId, amount, auctionAmount);\r\n    }\r\n\r\n    function logConfirmAuction(\r\n        uint256 newValidatorId,\r\n        uint256 oldValidatorId,\r\n        uint256 amount\r\n    ) public onlyStakeManager {\r\n        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);\r\n    }\r\n\r\n    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {\r\n        emit TopUpFee(user, fee);\r\n    }\r\n\r\n    function logClaimFee(address user, uint256 fee) public onlyStakeManager {\r\n        emit ClaimFee(user, fee);\r\n    }\r\n\r\n    function getStakerDetails(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 amount,\r\n            uint256 reward,\r\n            uint256 activationEpoch,\r\n            uint256 deactivationEpoch,\r\n            address signer,\r\n            uint256 _status\r\n        )\r\n    {\r\n        IStakeManagerLocal stakeManager = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        );\r\n        address _contract;\r\n        IStakeManagerLocal.Status status;\r\n        (\r\n            amount,\r\n            reward,\r\n            activationEpoch,\r\n            deactivationEpoch,\r\n            ,\r\n            signer,\r\n            _contract,\r\n            status\r\n        ) = stakeManager.validators(validatorId);\r\n        _status = uint256(status);\r\n        if (_contract != address(0x0)) {\r\n            reward += IStakeManagerLocal(_contract).validatorRewards();\r\n        }\r\n    }\r\n\r\n    function totalValidatorStake(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (uint256 validatorStake)\r\n    {\r\n        address contractAddress;\r\n        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n        if (contractAddress != address(0x0)) {\r\n            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();\r\n        }\r\n    }\r\n\r\n    function getAccountStateRoot()\r\n        public\r\n        view\r\n        returns (bytes32 accountStateRoot)\r\n    {\r\n        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())\r\n            .accountStateRoot();\r\n    }\r\n\r\n    function getValidatorContractAddress(uint256 validatorId)\r\n        public\r\n        view\r\n        returns (address ValidatorContract)\r\n    {\r\n        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(\r\n            registry.getStakeManagerAddress()\r\n        )\r\n            .validators(validatorId);\r\n    }\r\n\r\n    // validator Share contract logging func\r\n    function logShareMinted(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareMinted(validatorId, user, amount, tokens);\r\n    }\r\n\r\n    function logShareBurned(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareBurned(validatorId, user, amount, tokens);\r\n    }\r\n\r\n    function logDelegatorClaimRewards(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 rewards\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorClaimedRewards(validatorId, user, rewards);\r\n    }\r\n\r\n    function logDelegatorRestaked(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 totalStaked\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorRestaked(validatorId, user, totalStaked);\r\n    }\r\n\r\n    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)\r\n        public\r\n        onlyValidatorContract(validatorId)\r\n    {\r\n        emit DelegatorUnstaked(validatorId, user, amount);\r\n    }\r\n\r\n    // deprecated\r\n    function logUpdateCommissionRate(\r\n        uint256 validatorId,\r\n        uint256 newCommissionRate,\r\n        uint256 oldCommissionRate\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit UpdateCommissionRate(\r\n            validatorId,\r\n            newCommissionRate,\r\n            oldCommissionRate\r\n        );\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/drafts/Counters.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    /*\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A contract implementing SupportsInterfaceWithLookup\r\n     * implement ERC165 itself\r\n     */\r\n    constructor () internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    /*\r\n     * 0x80ac58cd ===\r\n     *     bytes4(keccak256('balanceOf(address)')) ^\r\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *     bytes4(keccak256('approve(address,uint256)')) ^\r\n     *     bytes4(keccak256('getApproved(uint256)')) ^\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0));\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId));\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender);\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0));\r\n        require(!_exists(tokenId));\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == owner);\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from);\r\n        require(to != address(0));\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Enumerable is IERC721 {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n    /*\r\n     * 0x780e9d63 ===\r\n     *     bytes4(keccak256('totalSupply()')) ^\r\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\r\n     */\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor () public {\r\n        // register the supported interface to conform to ERC721Enumerable via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n     * @param owner address owning the tokens list to be accessed\r\n     * @param index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n        require(index < balanceOf(owner));\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract\r\n     * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * Reverts if the index is greater or equal to the total number of tokens\r\n     * @param index uint256 representing the index to be accessed of the tokens list\r\n     * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply());\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        super._transferFrom(from, to, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(from, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to address the beneficiary that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        super._mint(to, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n        _addTokenToAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\r\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\r\n        _ownedTokensIndex[tokenId] = 0;\r\n\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the list of token IDs of the requested owner\r\n     * @param owner address owning the tokens\r\n     * @return uint256[] List of token IDs owned by the requested address\r\n     */\r\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\r\n        return _ownedTokens[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _ownedTokens[from].length--;\r\n\r\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\r\n        // lastTokenId, or just over the end of the array if the token was the last one).\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _allTokens.length--;\r\n        _allTokensIndex[tokenId] = 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n    /*\r\n     * 0x5b5e139f ===\r\n     *     bytes4(keccak256('name()')) ^\r\n     *     bytes4(keccak256('symbol()')) ^\r\n     *     bytes4(keccak256('tokenURI(uint256)'))\r\n     */\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name\r\n     * @return string representing the token name\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given token ID\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId));\r\n        return _tokenURIs[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the token URI for a given token\r\n     * Reverts if the token ID does not exist\r\n     * @param tokenId uint256 ID of the token to set its URI\r\n     * @param uri string URI to assign\r\n     */\r\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\r\n        require(_exists(tokenId));\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        // Clear metadata (if any)\r\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\r\n            delete _tokenURIs[tokenId];\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\r\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n}\r\n\r\n// File: contracts/staking/stakeManager/StakingNFT.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract StakingNFT is ERC721Full, Ownable {\r\n    constructor(string memory name, string memory symbol)\r\n        public\r\n        ERC721Full(name, symbol)\r\n    {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    function mint(address to, uint256 tokenId) public onlyOwner {\r\n        require(\r\n            balanceOf(to) == 0,\r\n            \"Validators MUST NOT own multiple stake position\"\r\n        );\r\n        _mint(to, tokenId);\r\n    }\r\n\r\n    function burn(uint256 tokenId) public onlyOwner {\r\n        _burn(tokenId);\r\n    }\r\n\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(\r\n            balanceOf(to) == 0,\r\n            \"Validators MUST NOT own multiple stake position\"\r\n        );\r\n        super._transferFrom(from, to, tokenId);\r\n    }\r\n}\r\n\r\n// File: contracts/common/misc/ERCProxy.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.5.2;\r\n\r\n// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\r\n\r\ninterface ERCProxy {\r\n    function proxyType() external pure returns (uint256 proxyTypeId);\r\n    function implementation() external view returns (address codeAddr);\r\n}\r\n\r\n// File: contracts/common/misc/DelegateProxyForwarder.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract DelegateProxyForwarder {\r\n    function delegatedFwd(address _dst, bytes memory _calldata) internal {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let result := delegatecall(\r\n                sub(gas, 10000),\r\n                _dst,\r\n                add(_calldata, 0x20),\r\n                mload(_calldata),\r\n                0,\r\n                0\r\n            )\r\n            let size := returndatasize\r\n\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }\r\n    }\r\n    \r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_target)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/common/misc/DelegateProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract DelegateProxy is ERCProxy, DelegateProxyForwarder {\r\n    function proxyType() external pure returns (uint256 proxyTypeId) {\r\n        // Upgradeable proxy\r\n        proxyTypeId = 2;\r\n    }\r\n\r\n    function implementation() external view returns (address);\r\n}\r\n\r\n// File: contracts/common/misc/UpgradableProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract UpgradableProxy is DelegateProxy {\r\n    event ProxyUpdated(address indexed _new, address indexed _old);\r\n    event OwnerUpdate(address _new, address _old);\r\n\r\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(\"matic.network.proxy.implementation\");\r\n    bytes32 constant OWNER_SLOT = keccak256(\"matic.network.proxy.owner\");\r\n\r\n    constructor(address _proxyTo) public {\r\n        setOwner(msg.sender);\r\n        setImplementation(_proxyTo);\r\n    }\r\n\r\n    function() external payable {\r\n        // require(currentContract != 0, \"If app code has not been set yet, do not call\");\r\n        // Todo: filter out some calls or handle in the end fallback\r\n        delegatedFwd(loadImplementation(), msg.data);\r\n    }\r\n\r\n    modifier onlyProxyOwner() {\r\n        require(loadOwner() == msg.sender, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    function owner() external view returns(address) {\r\n        return loadOwner();\r\n    }\r\n\r\n    function loadOwner() internal view returns(address) {\r\n        address _owner;\r\n        bytes32 position = OWNER_SLOT;\r\n        assembly {\r\n            _owner := sload(position)\r\n        }\r\n        return _owner;\r\n    }\r\n\r\n    function implementation() external view returns (address) {\r\n        return loadImplementation();\r\n    }\r\n\r\n    function loadImplementation() internal view returns(address) {\r\n        address _impl;\r\n        bytes32 position = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            _impl := sload(position)\r\n        }\r\n        return _impl;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyProxyOwner {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnerUpdate(newOwner, loadOwner());\r\n        setOwner(newOwner);\r\n    }\r\n\r\n    function setOwner(address newOwner) private {\r\n        bytes32 position = OWNER_SLOT;\r\n        assembly {\r\n            sstore(position, newOwner)\r\n        }\r\n    }\r\n\r\n    function updateImplementation(address _newProxyTo) public onlyProxyOwner {\r\n        require(_newProxyTo != address(0x0), \"INVALID_PROXY_ADDRESS\");\r\n        require(isContract(_newProxyTo), \"DESTINATION_ADDRESS_IS_NOT_A_CONTRACT\");\r\n\r\n        emit ProxyUpdated(_newProxyTo, loadImplementation());\r\n        \r\n        setImplementation(_newProxyTo);\r\n    }\r\n\r\n    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {\r\n        updateImplementation(_newProxyTo);\r\n\r\n        (bool success, bytes memory returnData) = address(this).call.value(msg.value)(data);\r\n        require(success, string(returnData));\r\n    }\r\n\r\n    function setImplementation(address _newProxyTo) private {\r\n        bytes32 position = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            sstore(position, _newProxyTo)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShareProxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract ValidatorShareProxy is UpgradableProxy {\r\n    constructor(address _registry) public UpgradableProxy(_registry) {}\r\n\r\n    function loadImplementation() internal view returns (address) {\r\n        return Registry(super.loadImplementation()).getValidatorShareAddress();\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://eips.ethereum.org/EIPS/eip-20\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to tr vbmansfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n    }\r\n}\r\n\r\n// File: contracts/common/tokens/ERC20NonTradable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ERC20NonTradable is ERC20 {\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        revert(\"disabled\");\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/Initializable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract Initializable {\r\n    bool inited = false;\r\n\r\n    modifier initializer() {\r\n        require(!inited, \"already inited\");\r\n        inited = true;\r\n        \r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/EventsHub.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract IStakeManagerEventsHub {\r\n    struct Validator {\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 activationEpoch;\r\n        uint256 deactivationEpoch;\r\n        uint256 jailTime;\r\n        address signer;\r\n        address contractAddress;\r\n    }\r\n\r\n    mapping(uint256 => Validator) public validators;\r\n}\r\n\r\ncontract EventsHub is Initializable {\r\n    Registry public registry;\r\n\r\n    modifier onlyValidatorContract(uint256 validatorId) {\r\n        address _contract;\r\n        (, , , , , , _contract) = IStakeManagerEventsHub(registry.getStakeManagerAddress()).validators(validatorId);\r\n        require(_contract == msg.sender, \"not validator\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyStakeManager() {\r\n        require(registry.getStakeManagerAddress() == msg.sender,\r\n        \"Invalid sender, not stake manager\");\r\n        _;\r\n    }\r\n\r\n    function initialize(Registry _registry) external initializer {\r\n        registry = _registry;\r\n    }\r\n\r\n    event ShareBurnedWithId(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 indexed amount,\r\n        uint256 tokens,\r\n        uint256 nonce\r\n    );\r\n\r\n    function logShareBurnedWithId(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 tokens,\r\n        uint256 nonce\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit ShareBurnedWithId(validatorId, user, amount, tokens, nonce);\r\n    }\r\n\r\n    event DelegatorUnstakeWithId(\r\n        uint256 indexed validatorId,\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 nonce\r\n    );\r\n\r\n    function logDelegatorUnstakedWithId(\r\n        uint256 validatorId,\r\n        address user,\r\n        uint256 amount,\r\n        uint256 nonce\r\n    ) public onlyValidatorContract(validatorId) {\r\n        emit DelegatorUnstakeWithId(validatorId, user, amount, nonce);\r\n    }\r\n\r\n    event RewardParams(\r\n        uint256 rewardDecreasePerCheckpoint,\r\n        uint256 maxRewardedCheckpoints,\r\n        uint256 checkpointRewardDelta\r\n    );\r\n\r\n    function logRewardParams(\r\n        uint256 rewardDecreasePerCheckpoint,\r\n        uint256 maxRewardedCheckpoints,\r\n        uint256 checkpointRewardDelta\r\n    ) public onlyStakeManager {\r\n        emit RewardParams(rewardDecreasePerCheckpoint, maxRewardedCheckpoints, checkpointRewardDelta);\r\n    }\r\n\r\n    event UpdateCommissionRate(\r\n        uint256 indexed validatorId,\r\n        uint256 indexed newCommissionRate,\r\n        uint256 indexed oldCommissionRate\r\n    );\r\n\r\n    function logUpdateCommissionRate(\r\n        uint256 validatorId,\r\n        uint256 newCommissionRate,\r\n        uint256 oldCommissionRate\r\n    ) public onlyStakeManager {\r\n        emit UpdateCommissionRate(\r\n            validatorId,\r\n            newCommissionRate,\r\n            oldCommissionRate\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/OwnableLockable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract OwnableLockable is Lockable, Ownable {\r\n    function lock() public onlyOwner {\r\n        super.lock();\r\n    }\r\n\r\n    function unlock() public onlyOwner {\r\n        super.unlock();\r\n    }\r\n}\r\n\r\n// File: contracts/staking/validatorShare/IValidatorShare.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n// note this contract interface is only for stakeManager use\r\ncontract IValidatorShare {\r\n    function withdrawRewards() public;\r\n\r\n    function unstakeClaimTokens() public;\r\n\r\n    function getLiquidRewards(address user) public view returns (uint256);\r\n    \r\n    function owner() public view returns (address);\r\n\r\n    function restake() public returns(uint256, uint256);\r\n\r\n    function unlock() external;\r\n\r\n    function lock() external;\r\n\r\n    function drain(\r\n        address token,\r\n        address payable destination,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function slash(uint256 valPow, uint256 delegatedAmount, uint256 totalAmountToSlash) external returns (uint256);\r\n\r\n    function updateDelegation(bool delegation) external;\r\n\r\n    function migrateOut(address user, uint256 amount) external;\r\n\r\n    function migrateIn(address user, uint256 amount) external;\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShare.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ValidatorShare is IValidatorShare, ERC20NonTradable, OwnableLockable, Initializable {\r\n    struct DelegatorUnbond {\r\n        uint256 shares;\r\n        uint256 withdrawEpoch;\r\n    }\r\n\r\n    uint256 constant EXCHANGE_RATE_PRECISION = 100;\r\n    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares\r\n    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10**29;\r\n    uint256 constant MAX_COMMISION_RATE = 100;\r\n    uint256 constant REWARD_PRECISION = 10**25;\r\n\r\n    StakingInfo public stakingLogger;\r\n    IStakeManager public stakeManager;\r\n    uint256 public validatorId;\r\n    uint256 public validatorRewards_deprecated;\r\n    uint256 public commissionRate_deprecated;\r\n    uint256 public lastCommissionUpdate_deprecated;\r\n    uint256 public minAmount;\r\n\r\n    uint256 public totalStake_deprecated;\r\n    uint256 public rewardPerShare;\r\n    uint256 public activeAmount;\r\n\r\n    bool public delegation;\r\n\r\n    uint256 public withdrawPool;\r\n    uint256 public withdrawShares;\r\n\r\n    mapping(address => uint256) amountStaked_deprecated; // deprecated, keep for foundation delegators\r\n    mapping(address => DelegatorUnbond) public unbonds;\r\n    mapping(address => uint256) public initalRewardPerShare;\r\n\r\n    mapping(address => uint256) public unbondNonces;\r\n    mapping(address => mapping(uint256 => DelegatorUnbond)) public unbonds_new;\r\n\r\n    EventsHub public eventsHub;\r\n\r\n    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address\r\n    function initialize(\r\n        uint256 _validatorId,\r\n        address _stakingLogger,\r\n        address _stakeManager\r\n    ) external initializer {\r\n        validatorId = _validatorId;\r\n        stakingLogger = StakingInfo(_stakingLogger);\r\n        stakeManager = IStakeManager(_stakeManager);\r\n        _transferOwnership(_stakeManager);\r\n        _getOrCacheEventsHub();\r\n\r\n        minAmount = 10**18;\r\n        delegation = true;\r\n    }\r\n\r\n    /**\r\n        Public View Methods\r\n    */\r\n\r\n    function exchangeRate() public view returns (uint256) {\r\n        uint256 totalShares = totalSupply();\r\n        uint256 precision = _getRatePrecision();\r\n        return totalShares == 0 ? precision : stakeManager.delegatedAmount(validatorId).mul(precision).div(totalShares);\r\n    }\r\n\r\n    function getTotalStake(address user) public view returns (uint256, uint256) {\r\n        uint256 shares = balanceOf(user);\r\n        uint256 rate = exchangeRate();\r\n        if (shares == 0) {\r\n            return (0, rate);\r\n        }\r\n\r\n        return (rate.mul(shares).div(_getRatePrecision()), rate);\r\n    }\r\n\r\n    function withdrawExchangeRate() public view returns (uint256) {\r\n        uint256 precision = _getRatePrecision();\r\n        if (validatorId < 8) {\r\n            // fix of potentially broken withdrawals for future unbonding\r\n            // foundation validators have no slashing enabled and thus we can return default exchange rate\r\n            // because without slashing rate will stay constant\r\n            return precision;\r\n        }\r\n\r\n        uint256 _withdrawShares = withdrawShares;\r\n        return _withdrawShares == 0 ? precision : withdrawPool.mul(precision).div(_withdrawShares);\r\n    }\r\n\r\n    function getLiquidRewards(address user) public view returns (uint256) {\r\n        return _calculateReward(user, getRewardPerShare());\r\n    }\r\n\r\n    function getRewardPerShare() public view returns (uint256) {\r\n        return _calculateRewardPerShareWithRewards(stakeManager.delegatorsReward(validatorId));\r\n    }\r\n\r\n    /**\r\n        Public Methods\r\n     */\r\n\r\n    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public returns(uint256 amountToDeposit) {\r\n        _withdrawAndTransferReward(msg.sender);\r\n        \r\n        amountToDeposit = _buyShares(_amount, _minSharesToMint, msg.sender);\r\n        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), \"deposit failed\");\r\n        \r\n        return amountToDeposit;\r\n    }\r\n\r\n    function restake() public returns(uint256, uint256) {\r\n        address user = msg.sender;\r\n        uint256 liquidReward = _withdrawReward(user);\r\n        uint256 amountRestaked;\r\n\r\n        require(liquidReward >= minAmount, \"Too small rewards to restake\");\r\n\r\n        if (liquidReward != 0) {\r\n            amountRestaked = _buyShares(liquidReward, 0, user);\r\n\r\n            if (liquidReward > amountRestaked) {\r\n                // return change to the user\r\n                require(\r\n                    stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, user),\r\n                    \"Insufficent rewards\"\r\n                );\r\n                stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidReward - amountRestaked);\r\n            }\r\n\r\n            (uint256 totalStaked, ) = getTotalStake(user);\r\n            stakingLogger.logDelegatorRestaked(validatorId, user, totalStaked);\r\n        }\r\n        \r\n        return (amountRestaked, liquidReward);\r\n    }\r\n\r\n    function sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) public {\r\n        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);\r\n\r\n        DelegatorUnbond memory unbond = unbonds[msg.sender];\r\n        unbond.shares = unbond.shares.add(_withdrawPoolShare);\r\n        // refresh undond period\r\n        unbond.withdrawEpoch = stakeManager.epoch();\r\n        unbonds[msg.sender] = unbond;\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);\r\n        logger.logStakeUpdate(validatorId);\r\n    }\r\n\r\n    function withdrawRewards() public {\r\n        uint256 rewards = _withdrawAndTransferReward(msg.sender);\r\n        require(rewards >= minAmount, \"Too small rewards amount\");\r\n    }\r\n\r\n    function migrateOut(address user, uint256 amount) external onlyOwner {\r\n        _withdrawAndTransferReward(user);\r\n        (uint256 totalStaked, uint256 rate) = getTotalStake(user);\r\n        require(totalStaked >= amount, \"Migrating too much\");\r\n\r\n        uint256 precision = _getRatePrecision();\r\n        uint256 shares = amount.mul(precision).div(rate);\r\n        _burn(user, shares);\r\n\r\n        stakeManager.updateValidatorState(validatorId, -int256(amount));\r\n        activeAmount = activeAmount.sub(amount);\r\n\r\n        stakingLogger.logShareBurned(validatorId, user, amount, shares);\r\n        stakingLogger.logStakeUpdate(validatorId);\r\n        stakingLogger.logDelegatorUnstaked(validatorId, user, amount);\r\n    }\r\n\r\n    function migrateIn(address user, uint256 amount) external onlyOwner {\r\n        _withdrawAndTransferReward(user);\r\n        _buyShares(amount, 0, user);\r\n    }\r\n\r\n    function unstakeClaimTokens() public {\r\n        DelegatorUnbond memory unbond = unbonds[msg.sender];\r\n        uint256 amount = _unstakeClaimTokens(unbond);\r\n        delete unbonds[msg.sender];\r\n        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, amount);\r\n    }\r\n\r\n    function slash(\r\n        uint256 validatorStake,\r\n        uint256 delegatedAmount,\r\n        uint256 totalAmountToSlash\r\n    ) external onlyOwner returns (uint256) {\r\n        uint256 _withdrawPool = withdrawPool;\r\n        uint256 delegationAmount = delegatedAmount.add(_withdrawPool);\r\n        if (delegationAmount == 0) {\r\n            return 0;\r\n        }\r\n        // total amount to be slashed from delegation pool (active + inactive)\r\n        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(validatorStake.add(delegationAmount));\r\n        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);\r\n\r\n        // slash inactive pool\r\n        uint256 stakeSlashed = _amountToSlash.sub(_amountToSlashWithdrawalPool);\r\n        stakeManager.decreaseValidatorDelegatedAmount(validatorId, stakeSlashed);\r\n        activeAmount = activeAmount.sub(stakeSlashed);\r\n\r\n        withdrawPool = withdrawPool.sub(_amountToSlashWithdrawalPool);\r\n        return _amountToSlash;\r\n    }\r\n\r\n    function updateDelegation(bool _delegation) external onlyOwner {\r\n        delegation = _delegation;\r\n    }\r\n\r\n    function drain(\r\n        address token,\r\n        address payable destination,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        if (token == address(0x0)) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(ERC20(token).transfer(destination, amount), \"Drain failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n        New shares exit API\r\n     */\r\n\r\n    function sellVoucher_new(uint256 claimAmount, uint256 maximumSharesToBurn) public {\r\n        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);\r\n\r\n        uint256 unbondNonce = unbondNonces[msg.sender].add(1);\r\n\r\n        DelegatorUnbond memory unbond = DelegatorUnbond({\r\n            shares: _withdrawPoolShare,\r\n            withdrawEpoch: stakeManager.epoch()\r\n        });\r\n        unbonds_new[msg.sender][unbondNonce] = unbond;\r\n        unbondNonces[msg.sender] = unbondNonce;\r\n\r\n        _getOrCacheEventsHub().logShareBurnedWithId(validatorId, msg.sender, claimAmount, shares, unbondNonce);\r\n        stakingLogger.logStakeUpdate(validatorId);\r\n    }\r\n\r\n    function unstakeClaimTokens_new(uint256 unbondNonce) public {\r\n        DelegatorUnbond memory unbond = unbonds_new[msg.sender][unbondNonce];\r\n        uint256 amount = _unstakeClaimTokens(unbond);\r\n        delete unbonds_new[msg.sender][unbondNonce];\r\n        _getOrCacheEventsHub().logDelegatorUnstakedWithId(validatorId, msg.sender, amount, unbondNonce);\r\n    }\r\n\r\n    /**\r\n        Private Methods\r\n     */\r\n\r\n    function _getOrCacheEventsHub() private returns(EventsHub) {\r\n        EventsHub _eventsHub = eventsHub;\r\n        if (_eventsHub == EventsHub(0x0)) {\r\n            _eventsHub = EventsHub(Registry(stakeManager.getRegistry()).contractMap(keccak256(\"eventsHub\")));\r\n            eventsHub = _eventsHub;\r\n        }\r\n        return _eventsHub;\r\n    }\r\n\r\n    function _sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) private returns(uint256, uint256) {\r\n        // first get how much staked in total and compare to target unstake amount\r\n        (uint256 totalStaked, uint256 rate) = getTotalStake(msg.sender);\r\n        require(totalStaked != 0 && totalStaked >= claimAmount, \"Too much requested\");\r\n\r\n        // convert requested amount back to shares\r\n        uint256 precision = _getRatePrecision();\r\n        uint256 shares = claimAmount.mul(precision).div(rate);\r\n        require(shares <= maximumSharesToBurn, \"too much slippage\");\r\n\r\n        _withdrawAndTransferReward(msg.sender);\r\n\r\n        _burn(msg.sender, shares);\r\n        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));\r\n        activeAmount = activeAmount.sub(claimAmount);\r\n\r\n        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());\r\n        withdrawPool = withdrawPool.add(claimAmount);\r\n        withdrawShares = withdrawShares.add(_withdrawPoolShare);\r\n\r\n        return (shares, _withdrawPoolShare);\r\n    }\r\n\r\n    function _unstakeClaimTokens(DelegatorUnbond memory unbond) private returns(uint256) {\r\n        uint256 shares = unbond.shares;\r\n        require(\r\n            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,\r\n            \"Incomplete withdrawal period\"\r\n        );\r\n\r\n        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());\r\n        withdrawShares = withdrawShares.sub(shares);\r\n        withdrawPool = withdrawPool.sub(_amount);\r\n\r\n        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), \"Insufficent rewards\");\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function _getRatePrecision() private view returns (uint256) {\r\n        // if foundation validator, use old precision\r\n        if (validatorId < 8) {\r\n            return EXCHANGE_RATE_PRECISION;\r\n        }\r\n\r\n        return EXCHANGE_RATE_HIGH_PRECISION;\r\n    }\r\n\r\n    function _calculateRewardPerShareWithRewards(uint256 accumulatedReward) private view returns (uint256) {\r\n        uint256 _rewardPerShare = rewardPerShare;\r\n        if (accumulatedReward != 0) {\r\n            uint256 totalShares = totalSupply();\r\n            \r\n            if (totalShares != 0) {\r\n                _rewardPerShare = _rewardPerShare.add(accumulatedReward.mul(REWARD_PRECISION).div(totalShares));\r\n            }\r\n        }\r\n\r\n        return _rewardPerShare;\r\n    }\r\n\r\n    function _calculateReward(address user, uint256 _rewardPerShare) private view returns (uint256) {\r\n        uint256 shares = balanceOf(user);\r\n        if (shares == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 _initialRewardPerShare = initalRewardPerShare[user];\r\n\r\n        if (_initialRewardPerShare == _rewardPerShare) {\r\n            return 0;\r\n        }\r\n\r\n        return _rewardPerShare.sub(_initialRewardPerShare).mul(shares).div(REWARD_PRECISION);\r\n    }\r\n\r\n    function _withdrawReward(address user) private returns (uint256) {\r\n        uint256 _rewardPerShare = _calculateRewardPerShareWithRewards(\r\n            stakeManager.withdrawDelegatorsReward(validatorId)\r\n        );\r\n        uint256 liquidRewards = _calculateReward(user, _rewardPerShare);\r\n        \r\n        rewardPerShare = _rewardPerShare;\r\n        initalRewardPerShare[user] = _rewardPerShare;\r\n        return liquidRewards;\r\n    }\r\n\r\n    function _withdrawAndTransferReward(address user) private returns (uint256) {\r\n        uint256 liquidRewards = _withdrawReward(user);\r\n        if (liquidRewards != 0) {\r\n            require(stakeManager.transferFunds(validatorId, liquidRewards, user), \"Insufficent rewards\");\r\n            stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidRewards);\r\n        }\r\n        return liquidRewards;\r\n    }\r\n\r\n    function _buyShares(\r\n        uint256 _amount,\r\n        uint256 _minSharesToMint,\r\n        address user\r\n    ) private onlyWhenUnlocked returns (uint256) {\r\n        require(delegation, \"Delegation is disabled\");\r\n\r\n        uint256 rate = exchangeRate();\r\n        uint256 precision = _getRatePrecision();\r\n        uint256 shares = _amount.mul(precision).div(rate);\r\n        require(shares >= _minSharesToMint, \"Too much slippage\");\r\n        require(unbonds[user].shares == 0, \"Ongoing exit\");\r\n\r\n        _mint(user, shares);\r\n\r\n        // clamp amount of tokens in case resulted shares requires less tokens than anticipated\r\n        _amount = rate.mul(shares).div(precision);\r\n\r\n        stakeManager.updateValidatorState(validatorId, int256(_amount));\r\n        activeAmount = activeAmount.add(_amount);\r\n\r\n        StakingInfo logger = stakingLogger;\r\n        logger.logShareMinted(validatorId, user, _amount, shares);\r\n        logger.logStakeUpdate(validatorId);\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // get rewards for recipient \r\n        _withdrawAndTransferReward(to);\r\n        // convert rewards to shares\r\n        _withdrawAndTransferReward(from);\r\n        // move shares to recipient\r\n        super._transfer(from, to, value);\r\n    }\r\n}\r\n\r\n// File: contracts/staking/validatorShare/ValidatorShareFactory.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract ValidatorShareFactory {\r\n    /**\r\n    - factory to create new validatorShare contracts\r\n   */\r\n    function create(uint256 validatorId, address loggerAddress, address registry) public returns (address) {\r\n        ValidatorShareProxy proxy = new ValidatorShareProxy(registry);\r\n\r\n        proxy.transferOwnership(msg.sender);\r\n\r\n        address proxyAddr = address(proxy);\r\n        (bool success, bytes memory data) = proxyAddr.call.gas(gasleft())(\r\n            abi.encodeWithSelector(\r\n                ValidatorShare(proxyAddr).initialize.selector, \r\n                validatorId, \r\n                loggerAddress, \r\n                msg.sender\r\n            )\r\n        );\r\n        require(success, string(data));\r\n\r\n        return proxyAddr;\r\n    }\r\n}\r\n\r\n// File: contracts/staking/stakeManager/StakeManagerStorage.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract StakeManagerStorage is GovernanceLockable, RootChainable {\r\n    enum Status {Inactive, Active, Locked, Unstaked}\r\n\r\n    struct Auction {\r\n        uint256 amount;\r\n        uint256 startEpoch;\r\n        address user;\r\n        bool acceptDelegation;\r\n        bytes signerPubkey;\r\n    }\r\n\r\n    struct State {\r\n        uint256 amount;\r\n        uint256 stakerCount;\r\n    }\r\n\r\n    struct StateChange {\r\n        int256 amount;\r\n        int256 stakerCount;\r\n    }\r\n\r\n    struct Validator {\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 activationEpoch;\r\n        uint256 deactivationEpoch;\r\n        uint256 jailTime;\r\n        address signer;\r\n        address contractAddress;\r\n        Status status;\r\n        uint256 commissionRate;\r\n        uint256 lastCommissionUpdate;\r\n        uint256 delegatorsReward;\r\n        uint256 delegatedAmount;\r\n        uint256 initialRewardPerStake;\r\n    }\r\n\r\n    uint256 constant MAX_COMMISION_RATE = 100;\r\n    uint256 constant MAX_PROPOSER_BONUS = 100;\r\n    uint256 constant REWARD_PRECISION = 10**25;\r\n    uint256 internal constant INCORRECT_VALIDATOR_ID = 2**256 - 1;\r\n    uint256 internal constant INITIALIZED_AMOUNT = 1;\r\n\r\n    IERC20 public token;\r\n    address public registry;\r\n    StakingInfo public logger;\r\n    StakingNFT public NFTContract;\r\n    ValidatorShareFactory public validatorShareFactory;\r\n    uint256 public WITHDRAWAL_DELAY; // unit: epoch\r\n    uint256 public currentEpoch;\r\n\r\n    // genesis/governance variables\r\n    uint256 public dynasty; // unit: epoch 50 days\r\n    uint256 public CHECKPOINT_REWARD; // update via governance\r\n    uint256 public minDeposit; // in ERC20 token\r\n    uint256 public minHeimdallFee; // in ERC20 token\r\n    uint256 public checkPointBlockInterval;\r\n    uint256 public signerUpdateLimit;\r\n\r\n    uint256 public validatorThreshold; //128\r\n    uint256 public totalStaked;\r\n    uint256 public NFTCounter;\r\n    uint256 public totalRewards;\r\n    uint256 public totalRewardsLiquidated;\r\n    uint256 public auctionPeriod; // 1 week in epochs\r\n    uint256 public proposerBonus; // 10 % of total rewards\r\n    bytes32 public accountStateRoot;\r\n    // Stop validator auction for some time when updating dynasty value\r\n    uint256 public replacementCoolDown;\r\n    bool public delegationEnabled;\r\n\r\n    mapping(uint256 => Validator) public validators;\r\n    mapping(address => uint256) public signerToValidator;\r\n    // current epoch stake power and stakers count\r\n    State public validatorState;\r\n    mapping(uint256 => StateChange) public validatorStateChanges;\r\n\r\n    mapping(address => uint256) public userFeeExit;\r\n    //Ongoing auctions for validatorId\r\n    mapping(uint256 => Auction) public validatorAuction;\r\n    // validatorId to last signer update epoch\r\n    mapping(uint256 => uint256) public latestSignerUpdateEpoch;\r\n\r\n    uint256 public totalHeimdallFee;\r\n}\r\n\r\n// File: contracts/staking/stakeManager/StakeManagerStorageExtension.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract StakeManagerStorageExtension {\r\n    address public eventsHub;\r\n    uint256 public rewardPerStake;\r\n    address public extensionCode;\r\n    address[] public signers;\r\n\r\n    uint256 constant CHK_REWARD_PRECISION = 100;\r\n    uint256 public prevBlockInterval;\r\n    // how much less reward per skipped checkpoint, 0 - 100%\r\n    uint256 public rewardDecreasePerCheckpoint;\r\n    // how many checkpoints to reward\r\n    uint256 public maxRewardedCheckpoints;\r\n    // increase / decrease value for faster or slower checkpoints, 0 - 100%\r\n    uint256 public checkpointRewardDelta;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the average of two numbers. Since these are integers,\r\n     * averages of an even and odd number cannot be represented, and will be\r\n     * rounded down.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/staking/stakeManager/StakeManagerExtension.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract StakeManagerExtension is StakeManagerStorage, Initializable, StakeManagerStorageExtension {\r\n    using SafeMath for uint256;\r\n\r\n    constructor() public GovernanceLockable(address(0x0)) {}\r\n\r\n    function startAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        bool _acceptDelegation,\r\n        bytes calldata _signerPubkey\r\n    ) external {\r\n        uint256 currentValidatorAmount = validators[validatorId].amount;\r\n\r\n        require(\r\n            validators[validatorId].deactivationEpoch == 0 && currentValidatorAmount != 0,\r\n            \"Invalid validator for an auction\"\r\n        );\r\n        uint256 senderValidatorId = signerToValidator[msg.sender];\r\n        // make sure that signer wasn't used already\r\n        require(\r\n            NFTContract.balanceOf(msg.sender) == 0 && // existing validators can't bid\r\n                senderValidatorId != INCORRECT_VALIDATOR_ID,\r\n            \"Already used address\"\r\n        );\r\n\r\n        uint256 _currentEpoch = currentEpoch;\r\n        uint256 _replacementCoolDown = replacementCoolDown;\r\n        // when dynasty period is updated validators are in cooldown period\r\n        require(_replacementCoolDown == 0 || _replacementCoolDown <= _currentEpoch, \"Cooldown period\");\r\n        // (auctionPeriod--dynasty)--(auctionPeriod--dynasty)--(auctionPeriod--dynasty)\r\n        // if it's auctionPeriod then will get residue smaller then auctionPeriod\r\n        // from (CurrentPeriod of validator )%(auctionPeriod--dynasty)\r\n        // make sure that its `auctionPeriod` window\r\n        // dynasty = 30, auctionPeriod = 7, activationEpoch = 1, currentEpoch = 39\r\n        // residue 1 = (39-1)% (7+30), if residue <= auctionPeriod it's `auctionPeriod`\r\n\r\n        require(\r\n            (_currentEpoch.sub(validators[validatorId].activationEpoch) % dynasty.add(auctionPeriod)) < auctionPeriod,\r\n            \"Invalid auction period\"\r\n        );\r\n\r\n        uint256 perceivedStake = currentValidatorAmount;\r\n        perceivedStake = perceivedStake.add(validators[validatorId].delegatedAmount);\r\n\r\n        Auction storage auction = validatorAuction[validatorId];\r\n        uint256 currentAuctionAmount = auction.amount;\r\n\r\n        perceivedStake = Math.max(perceivedStake, currentAuctionAmount);\r\n\r\n        require(perceivedStake < amount, \"Must bid higher\");\r\n        require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\r\n\r\n        //replace prev auction\r\n        if (currentAuctionAmount != 0) {\r\n            require(token.transfer(auction.user, currentAuctionAmount), \"Bid return failed\");\r\n        }\r\n\r\n        // create new auction\r\n        auction.amount = amount;\r\n        auction.user = msg.sender;\r\n        auction.acceptDelegation = _acceptDelegation;\r\n        auction.signerPubkey = _signerPubkey;\r\n\r\n        logger.logStartAuction(validatorId, currentValidatorAmount, amount);\r\n    }\r\n\r\n    function confirmAuctionBid(\r\n        uint256 validatorId,\r\n        uint256 heimdallFee, /** for new validator */\r\n        IStakeManager stakeManager\r\n    ) external {\r\n        Auction storage auction = validatorAuction[validatorId];\r\n        address auctionUser = auction.user;\r\n\r\n        require(\r\n            msg.sender == auctionUser || NFTContract.tokenOfOwnerByIndex(msg.sender, 0) == validatorId,\r\n            \"Only bidder can confirm\"\r\n        );\r\n\r\n        uint256 _currentEpoch = currentEpoch;\r\n        require(\r\n            _currentEpoch.sub(auction.startEpoch) % auctionPeriod.add(dynasty) >= auctionPeriod,\r\n            \"Not allowed before auctionPeriod\"\r\n        );\r\n        require(auction.user != address(0x0), \"Invalid auction\");\r\n\r\n        uint256 validatorAmount = validators[validatorId].amount;\r\n        uint256 perceivedStake = validatorAmount;\r\n        uint256 auctionAmount = auction.amount;\r\n\r\n        perceivedStake = perceivedStake.add(validators[validatorId].delegatedAmount);\r\n\r\n        // validator is last auctioner\r\n        if (perceivedStake >= auctionAmount && validators[validatorId].deactivationEpoch == 0) {\r\n            require(token.transfer(auctionUser, auctionAmount), \"Bid return failed\");\r\n            //cleanup auction data\r\n            auction.startEpoch = _currentEpoch;\r\n            logger.logConfirmAuction(validatorId, validatorId, validatorAmount);\r\n        } else {\r\n            stakeManager.dethroneAndStake(\r\n                auctionUser, \r\n                heimdallFee,\r\n                validatorId,\r\n                auctionAmount,\r\n                auction.acceptDelegation,\r\n                auction.signerPubkey\r\n            );\r\n        }\r\n        uint256 startEpoch = auction.startEpoch;\r\n        delete validatorAuction[validatorId];\r\n        validatorAuction[validatorId].startEpoch = startEpoch;\r\n    }\r\n\r\n    function migrateValidatorsData(uint256 validatorIdFrom, uint256 validatorIdTo) external {       \r\n        for (uint256 i = validatorIdFrom; i < validatorIdTo; ++i) {\r\n            ValidatorShare contractAddress = ValidatorShare(validators[i].contractAddress);\r\n            if (contractAddress != ValidatorShare(0)) {\r\n                // move validator rewards out from ValidatorShare contract\r\n                validators[i].reward = contractAddress.validatorRewards_deprecated().add(INITIALIZED_AMOUNT);\r\n                validators[i].delegatedAmount = contractAddress.activeAmount();\r\n                validators[i].commissionRate = contractAddress.commissionRate_deprecated();\r\n            } else {\r\n                validators[i].reward = validators[i].reward.add(INITIALIZED_AMOUNT);\r\n            }\r\n\r\n            validators[i].delegatorsReward = INITIALIZED_AMOUNT;\r\n        }\r\n    }\r\n\r\n    function updateCheckpointRewardParams(\r\n        uint256 _rewardDecreasePerCheckpoint,\r\n        uint256 _maxRewardedCheckpoints,\r\n        uint256 _checkpointRewardDelta\r\n    ) external {\r\n        require(_maxRewardedCheckpoints.mul(_rewardDecreasePerCheckpoint) <= CHK_REWARD_PRECISION);\r\n        require(_checkpointRewardDelta <= CHK_REWARD_PRECISION);\r\n\r\n        rewardDecreasePerCheckpoint = _rewardDecreasePerCheckpoint;\r\n        maxRewardedCheckpoints = _maxRewardedCheckpoints;\r\n        checkpointRewardDelta = _checkpointRewardDelta;\r\n\r\n        _getOrCacheEventsHub().logRewardParams(_rewardDecreasePerCheckpoint, _maxRewardedCheckpoints, _checkpointRewardDelta);\r\n    }\r\n\r\n    function updateCommissionRate(uint256 validatorId, uint256 newCommissionRate) external {\r\n        uint256 _epoch = currentEpoch;\r\n        uint256 _lastCommissionUpdate = validators[validatorId].lastCommissionUpdate;\r\n\r\n        require( // withdrawalDelay == dynasty\r\n            (_lastCommissionUpdate.add(WITHDRAWAL_DELAY) <= _epoch) || _lastCommissionUpdate == 0, // For initial setting of commission rate\r\n            \"Cooldown\"\r\n        );\r\n\r\n        require(newCommissionRate <= MAX_COMMISION_RATE, \"Incorrect value\");\r\n        _getOrCacheEventsHub().logUpdateCommissionRate(validatorId, newCommissionRate, validators[validatorId].commissionRate);\r\n        validators[validatorId].commissionRate = newCommissionRate;\r\n        validators[validatorId].lastCommissionUpdate = _epoch;\r\n    }\r\n\r\n    function _getOrCacheEventsHub() private returns(EventsHub) {\r\n        EventsHub _eventsHub = EventsHub(eventsHub);\r\n        if (_eventsHub == EventsHub(0x0)) {\r\n            _eventsHub = EventsHub(Registry(registry).contractMap(keccak256(\"eventsHub\")));\r\n            eventsHub = address(_eventsHub);\r\n        }\r\n        return _eventsHub;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousRootChain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRootChain\",\"type\":\"address\"}],\"name\":\"RootChainChanged\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHECKPOINT_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NFTContract\",\"outputs\":[{\"internalType\":\"contract StakingNFT\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NFTCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAWAL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRootChain\",\"type\":\"address\"}],\"name\":\"changeRootChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkPointBlockInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkpointRewardDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"heimdallFee\",\"type\":\"uint256\"},{\"internalType\":\"contract IStakeManager\",\"name\":\"stakeManager\",\"type\":\"address\"}],\"name\":\"confirmAuctionBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegationEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dynasty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eventsHub\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extensionCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract IGovernance\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"latestSignerUpdateEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logger\",\"outputs\":[{\"internalType\":\"contract StakingInfo\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRewardedCheckpoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorIdFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validatorIdTo\",\"type\":\"uint256\"}],\"name\":\"migrateValidatorsData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minHeimdallFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prevBlockInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposerBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"replacementCoolDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardDecreasePerCheckpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPerStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootChain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"signerToValidator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signerUpdateLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_acceptDelegation\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_signerPubkey\",\"type\":\"bytes\"}],\"name\":\"startAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHeimdallFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewardsLiquidated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardDecreasePerCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxRewardedCheckpoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_checkpointRewardDelta\",\"type\":\"uint256\"}],\"name\":\"updateCheckpointRewardParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCommissionRate\",\"type\":\"uint256\"}],\"name\":\"updateCommissionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userFeeExit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validatorAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"acceptDelegation\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"signerPubkey\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorShareFactory\",\"outputs\":[{\"internalType\":\"contract ValidatorShareFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakerCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validatorStateChanges\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"stakerCount\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activationEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deactivationEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jailTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"enum StakeManagerStorage.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"commissionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCommissionUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatorsReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialRewardPerStake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StakeManagerExtension","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://99d2489bb9106ea5118a43946dba9b8144f585eacb98b4d280c16a6988609aaa"}]}