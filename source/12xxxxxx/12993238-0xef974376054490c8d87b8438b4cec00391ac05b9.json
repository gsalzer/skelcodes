{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/Verifier.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\nimport \\\"./KeysWithPlonkVerifier.sol\\\";\\nimport \\\"./Config.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract Verifier is KeysWithPlonkVerifier, KeysWithPlonkVerifierOld, Config {\\n    // solhint-disable-next-line no-empty-blocks\\n    function initialize(bytes calldata) external {}\\n\\n    /// @notice Verifier contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    // solhint-disable-next-line no-empty-blocks\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    function verifyAggregatedBlockProof(\\n        uint256[] memory _recursiveInput,\\n        uint256[] memory _proof,\\n        uint8[] memory _vkIndexes,\\n        uint256[] memory _individualVksInputs,\\n        uint256[16] memory _subproofsLimbs\\n    ) external view returns (bool) {\\n        for (uint256 i = 0; i < _individualVksInputs.length; ++i) {\\n            uint256 commitment = _individualVksInputs[i];\\n            _individualVksInputs[i] = commitment & INPUT_MASK;\\n        }\\n        VerificationKey memory vk = getVkAggregated(uint32(_vkIndexes.length));\\n\\n        return\\n            verify_serialized_proof_with_recursion(\\n                _recursiveInput,\\n                _proof,\\n                VK_TREE_ROOT,\\n                VK_MAX_INDEX,\\n                _vkIndexes,\\n                _individualVksInputs,\\n                _subproofsLimbs,\\n                vk\\n            );\\n    }\\n\\n    function verifyExitProof(\\n        bytes32 _rootHash,\\n        uint32 _accountId,\\n        address _owner,\\n        uint32 _tokenId,\\n        uint128 _amount,\\n        uint32 _nftCreatorAccountId,\\n        address _nftCreatorAddress,\\n        uint32 _nftSerialId,\\n        bytes32 _nftContentHash,\\n        uint256[] calldata _proof\\n    ) external view returns (bool) {\\n        bytes32 commitment =\\n            sha256(\\n                abi.encodePacked(\\n                    _rootHash,\\n                    _accountId,\\n                    _owner,\\n                    _tokenId,\\n                    _amount,\\n                    _nftCreatorAccountId,\\n                    _nftCreatorAddress,\\n                    _nftSerialId,\\n                    _nftContentHash\\n                )\\n            );\\n\\n        uint256[] memory inputs = new uint256[](1);\\n        inputs[0] = uint256(commitment) & INPUT_MASK;\\n        ProofOld memory proof = deserialize_proof_old(inputs, _proof);\\n        VerificationKeyOld memory vk = getVkExit();\\n        require(vk.num_inputs == inputs.length, \\\"n1\\\");\\n        return verify_old(proof, vk);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/KeysWithPlonkVerifier.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./PlonkCore.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract KeysWithPlonkVerifier is VerifierWithDeserialize {\\n\\n    uint256 constant VK_TREE_ROOT = 0x27b59e90e3e7a8232ef7af89bfb6bde89dc22ed5918db6ecf2028997ffedbe2f;\\n    uint8 constant VK_MAX_INDEX = 3;\\n\\n    function getVkAggregated(uint32 _proofs) internal pure returns (VerificationKey memory vk) {\\n        if (_proofs == uint32(1)) { return getVkAggregated1(); }\\n        else if (_proofs == uint32(4)) { return getVkAggregated4(); }\\n        else if (_proofs == uint32(8)) { return getVkAggregated8(); }\\n        else if (_proofs == uint32(18)) { return getVkAggregated18(); }\\n    }\\n\\n    \\n    function getVkAggregated1() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 4194304;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x18c95f1ae6514e11a1b30fd7923947c5ffcec5347f16e91b4dd654168326bede);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x19fbd6706b4cbde524865701eae0ae6a270608a09c3afdab7760b685c1c6c41b,\\n            0x25082a191f0690c175cc9af1106c6c323b5b5de4e24dc23be1e965e1851bca48\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x16c02d9ca95023d1812a58d16407d1ea065073f02c916290e39242303a8a1d8e,\\n            0x230338b422ce8533e27cd50086c28cb160cf05a7ae34ecd5899dbdf449dc7ce0\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x1db0d133243750e1ea692050bbf6068a49dc9f6bae1f11960b6ce9e10adae0f5,\\n            0x12a453ed0121ae05de60848b4374d54ae4b7127cb307372e14e8daf5097c5123\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x1062ed5e86781fd34f78938e5950c2481a79f132085d2bc7566351ddff9fa3b7,\\n            0x2fd7aac30f645293cc99883ab57d8c99a518d5b4ab40913808045e8653497346\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x062755048bb95739f845e8659795813127283bf799443d62fea600ae23e7f263,\\n            0x2af86098beaa241281c78a454c5d1aa6e9eedc818c96cd1e6518e1ac2d26aa39\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x0994e25148bbd25be655034f81062d1ebf0a1c2b41e0971434beab1ae8101474,\\n            0x27cc8cfb1fafd13068aeee0e08a272577d89f8aa0fb8507aabbc62f37587b98f\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x044edf69ce10cfb6206795f92c3be2b0d26ab9afd3977b789840ee58c7dbe927,\\n            0x2a8aa20c106f8dc7e849bc9698064dcfa9ed0a4050d794a1db0f13b0ee3def37\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x136967f1a2696db05583a58dbf8971c5d9d1dc5f5c97e88f3b4822aa52fefa1c,\\n            0x127b41299ea5c840c3b12dbe7b172380f432b7b63ce3b004750d6abb9e7b3b7a\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x02fd5638bf3cc2901395ad1124b951e474271770a337147a2167e9797ab9d951,\\n            0x0fcb2e56b077c8461c36911c9252008286d782e96030769bf279024fc81d412a\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x1865c60ecad86f81c6c952445707203c9c7fdace3740232ceb704aefd5bd45b3,\\n            0x2f35e29b39ec8bb054e2cff33c0299dd13f8c78ea24a07622128a7444aba3f26\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x2a86ec9c6c1f903650b5abbf0337be556b03f79aecc4d917e90c7db94518dde6,\\n            0x15b1b6be641336eebd58e7991be2991debbbd780e70c32b49225aa98d10b7016\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x213e42fcec5297b8e01a602684fcd412208d15bdac6b6331a8819d478ba46899,\\n            0x03223485f4e808a3b2496ae1a3c0dfbcbf4391cffc57ee01e8fca114636ead18\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x2e9b02f8cf605ad1a36e99e990a07d435de06716448ad53053c7a7a5341f71e1,\\n            0x2d6fdf0bc8bd89112387b1894d6f24b45dcb122c09c84344b6fc77a619dd1d59\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkAggregated4() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 8388608;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x1283ba6f4b7b1a76ba2008fe823128bea4adb9269cbfd7c41c223be65bc60863);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x2988e24b15bce9a1e3a4d1d9a8f7c7a65db6c29fd4c6f4afe1a3fbd954d4b4b6,\\n            0x0bdb6e5ba27a22e03270c7c71399b866b28d7cec504d30e665d67be58e306e12\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x20f3d30d3a91a7419d658f8c035e42a811c9f75eac2617e65729033286d36089,\\n            0x07ac91e8194eb78a9db537e9459dd6ca26bef8770dde54ac3dd396450b1d4cfe\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x0311872bab6df6e9095a9afe40b12e2ed58f00cc88835442e6b4cf73fb3e147d,\\n            0x2cdfc5b5e73737809b54644b2f96494f8fcc1dd0fb440f64f44930b432c4542d\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x28fd545b1e960d2eff3142271affa4096ef724212031fdabe22dd4738f36472b,\\n            0x2c743150ee9894ff3965d8f1129399a3b89a1a9289d4cfa904b0a648d3a8a9fa\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x2c283ce950eee1173b78657e57c80658a8398e7970a9a45b20cd39aff16ad61a,\\n            0x081c003cbd09f7c3e0d723d6ebbaf432421c188d5759f5ee8ff1ee1dc357d4a8\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x2eb50a2dd293a71a0c038e958c5237bd7f50b2f0c9ee6385895a553de1517d43,\\n            0x15fdc2b5b28fc351f987b98aa6caec7552cefbafa14e6651061eec4f41993b65\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x17a9403e5c846c1ca5e767c89250113aa156fdb1f026aa0b4db59c09d06816ec,\\n            0x2512241972ca3ee4839ac72a4cab39ddb413a7553556abd7909284b34ee73f6b\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x09edd69c8baa7928b16615e993e3032bc8cbf9f42bfa3cf28caba1078d371edb,\\n            0x12e5c39148af860a87b14ae938f33eafa91deeb548cda4cc23ed9ba3e6e496b8\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x0e25c0027706ca3fd3daae849f7c50ec88d4d030da02452001dec7b554cc71b4,\\n            0x2421da0ca385ff7ba9e5ae68890655669248c8c8187e67d12b2a7ae97e2cff8b\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x151536359fe184567bce57379833f6fae485e5cc9bc27423d83d281aaf2701df,\\n            0x116beb145bc27faae5a8ae30c28040d3baafb3ea47360e528227b94adb9e4f26\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x23ee338093db23364a6e44acfb60d810a4c4bd6565b185374f7840152d3ae82c,\\n            0x0f6714f3ee113b9dfb6b653f04bf497602588b16b96ac682d9a5dd880a0aa601\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x05860b0ea3c6f22150812aee304bf35e1a95cfa569a8da52b42dba44a122378a,\\n            0x19e5a9f3097289272e65e842968752c5355d1cdb2d3d737050e4dfe32ebe1e41\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x3046881fcbe369ac6f99fea8b9505de85ded3de3bc445060be4bc6ef651fa352,\\n            0x06fe14c1dd6c2f2b48aebeb6fd525573d276b2e148ad25e75c57a58588f755ec\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkAggregated8() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 16777216;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x1951441010b2b95a6e47a6075066a50a036f5ba978c050f2821df86636c0facb);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x218bdb295b7207114aeea948e2d3baef158d4057812f94005d8ff54341b6ce6f,\\n            0x1398585c039ba3cf336687301e95fbbf6b0638d31c64b1d815bb49091d0c1aad\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x2e40b8a98e688c9e00f607a64520a850d35f277dc0b645628494337bb75870e8,\\n            0x2da4ef753cc4869e53cff171009dbffea9166b8ffbafd17783d712278a79f13e\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x1b638de3c6cc2e0badc48305ee3533678a45f52edf30277303551128772303a2,\\n            0x2794c375cbebb7c28379e8abf42d529a1c291319020099935550c83796ba14ac\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x189cd01d67b44cf2c1e10765c69adaafd6a5929952cf55732e312ecf00166956,\\n            0x15976c99ef2c911bd3a72c9613b7fe9e66b03dd8963bfed705c96e3e88fdb1af\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x0745a77052dc66afc61163ec3737651e5b846ca7ec7fae1853515d0f10a51bd9,\\n            0x2bd27ecf4fb7f5053cc6de3ddb7a969fac5150a6fb5555ca917d16a7836e4c0a\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x2787aea173d07508083893b02ea962be71c3b628d1da7d7c4db0def49f73ad8f,\\n            0x22fdc951a97dc2ac7d8292a6c263898022f4623c643a56b9265b33c72e628886\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x0aafe35c49634858e44e9af259cac47a6f8402eb870f9f95217dcb8a33a73e64,\\n            0x1b47a7641a7c918784e84fc2494bfd8014ebc77069b94650d25cb5e25fbb7003\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x11cfc3fe28dfd5d663d53ceacc5ec620da85ae5aa971f0f003f57e75cd05bf9f,\\n            0x28b325f30984634fc46c6750f402026d4ff43e5325cbe34d35bf8ac4fc9cc533\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x2ada816636b9447def36e35dd3ab0e3f7a8bbe3ae32a5a4904dee3fc26e58015,\\n            0x2cd12d1a50aaadef4e19e1b1955c932e992e688c2883da862bd7fad17aae66f6\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x20cc506f273be4d114cbf2807c14a769d03169168892e2855cdfa78c3095c89d,\\n            0x08f99d338aee985d780d036473c624de9fd7960b2a4a7ad361c8c125cf11899e\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x01260265d3b1167eac1030f3d04326f08a1f2bb1e026e54afec844e3729386e2,\\n            0x16d75b53ec2552c63e84ea5f4bfe1507c3198045875457c1d9295d6699f39d56\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x1f4d73c63d163c3f5ef1b5caa41988cacbdbca38334e8f54d7ee9bbbb622e200,\\n            0x2f48f5f93d9845526ef0348f1c3def63cfc009645eb2a95d1746c7941e888a78\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x1dbd386fe258366222becc570a7f6405b25ff52818b93bdd54eaa20a6b22025a,\\n            0x2b2b4e978ac457d752f50b02609bd7d2054286b963821b2ec7cd3dd1507479fa\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkAggregated18() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 33554432;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0d94d63997367c97a8ed16c17adaae39262b9af83acb9e003f94c217303dd160);\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x0eab7c0217fbc357eb9e2622da6e5df9a99e5fa8dbaaf6b45a7136bbc49704c0,\\n            0x00199f1c9e2ef5efbec5e3792cb6db0d6211e2da57e2e5a7cf91fb4037bd0013\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x020c5ecdbb37b9f99b131cdfd0fec8c5565985599093db03d85a9bcd75a8a186,\\n            0x0be3b767834382739f1309adedb540ce5261b7038c168d32619a6e6333974b1b\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x092fc8636803f28250ac33b8ea688b37cf0718f83c82a1ce7bca70e7c8643b93,\\n            0x10c907fcb34fb6e9d4e334428e8226ba84e5977a7dc1ada2509cc6cf445123ca\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x1f66b77eaae034cf3646e0c32418a1dfecb3bf090cc271aad0d64ba327758b29,\\n            0x2b8766fbe83c45b39e274998a000cf59e7332800025e7af711368c6b7ea11cd9\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x017336a15f6e61def3ec02f139a0972c4272e126ac40d49ed10d447db6857643,\\n            0x22cc7cb62310a031acd86dd1a9ea18ee55e1b6a4fbf1c2d64ca9a7cc6458ed7a\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x057992ff5d056557b795ab7e6964fab546fdcd8b5c1d3718e4f619e1091ef9a0,\\n            0x026916de04486781c504fb054e0b3755dd4836b610973e0ca092b35810ed3698\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x252a53377145970214c9af5cd95c5fdd72e4d890b96d5ab31ef7736b2280aaa3,\\n            0x2a1ccbea423d1a58325c4d0e5aa01a6a2a7c7fbaa61fb8f3669f720dfb4dfd4d\\n        );\\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x17da1e8102c91916c778e89d737bdc8a14f4dfcf14fc89896f921dfc81e98556,\\n            0x1b9571239471b65bc5d4bcc3b1b3831bcc6986ad4d1417292dc3067ae632b796\\n        );\\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\\n            0x242b5b8848746eb790629cf0853e256249d83cad8e189d474ed3a5c56b5a92be,\\n            0x2ca4e4882f0d7408ba134458945a2dd7cbced64e735fd42c9204eaf8608c58cc\\n        );\\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x281ccb20cea7001ae0d3ef5deedc46db687f1493cd77631dc2c16275b96f677a,\\n            0x24bede6b53ee4762939dbabb5947023d3ab31b00a1d14bcb6a5da69d7ce0d67e\\n        );\\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x1e72df4c2223fb15e72862350f51994b7f381a829a00b21535b04e8c342c15e7,\\n            0x22b7bb45c2e3b957952824beee1145bfcb5d2c575636266ad44032c1ae24e1ea\\n        );\\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x0059ea736670b355b3b6479db53d9b19727aa128514dee7d6c6788e80233452f,\\n            0x24718998fb0ff667c66457f6558ff028352b2d55cb86a07a0c11fc3c2753df38\\n        );\\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x0bee5ac3770c7603b2ccbc9e10a0ceafa231e77dde3fd6b9d514958ae7c200e8,\\n            0x11339336bbdafda32635c143b7bd0c4cdb7b7948489d75240c89ca2a440ef39c\\n        );\\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n\\n}\\n\\n// Hardcoded constants to avoid accessing store\\ncontract KeysWithPlonkVerifierOld is VerifierWithDeserializeOld {\\n\\n    \\n    function getVkExit() internal pure returns(VerificationKeyOld memory vk) {\\n        vk.domain_size = 524288;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0cf1526aaafac6bacbb67d11a4077806b123f767e4b0883d14cc0193568fc082);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x114dd473f77a15b602201577dd4b64a32a783cb32fbc02911e512df6a219695d,\\n            0x04c68f82a5dd7d0cc90318bdff493b3d552d148ad859c373ffe55275e043c43b\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x245e8c882af503cb5421f5135b4295a920ccf68b42ae7fb967f044f54e2aaa29,\\n            0x071322ee387a9ce49fe7ef2edb6e9237203dee49ec47483af85e356b79fb06fd\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x0187754ab593b07a420b3b4d215c20ed49acf90fc4c97e4b06e8f5bc0a2eb3f4,\\n            0x0170f9286ce950286a16ea25136c163c0b32019f31b89c256a612d40b863d0b6\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x0defecfae1d2b9ec9b2ee4d4798c625fa50f6a4ddb7747a7293df0c17fcb90c2,\\n            0x0f91d08fceebf85fb80f12cda78cefa1ee9dbf5cfe7c4f0704b3c6620fa50c55\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x2f7fef3b3fb64af6640f93803a18b3e5ce4e0e60aecd4f924c833fa6fa6da961,\\n            0x03908fc737113ac7f3529fe3b36efca200c66d1d85d2fc081973214c586de732\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x14ce3c0e9b78fc331327249e707f58fa4bb0ed746bdc9c2262ad0cf905609627,\\n            0x09e64fdac452b424e98fc4a92f7222693d0d84ab48aadd9c46151dbe5f1a34a9\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x1d10bfd923c17d9623ec02db00099355b373021432ae1edef69b0f5f461f78d6,\\n            0x24e370a93f65f42888781d0158bb6ef9136c8bbd047d7993b8276bc8df8b640a\\n        );\\n\\n        vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x1fd1755ed4d06d91d50db4771d332cfa2bc2ca0e10ac8b77e0d6b73b993e788e,\\n            0x0bdbf3b7f0d3cffdcf818f1fba18b90914eda59b454bd1858c6c0916b817f883\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x1f3b8d12ffa2ceb2bb42d232ad2cf11bce3183472b622e11cc841d26f42ad507,\\n            0x0ce815e32b3bd14311cde210cda1bd351617d539ed3e9d96a8605f364f3a29b0\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x123afa8c1cec1956d7330db062498a2a3e3a9862926c02e1228d9cfb63d3c301,\\n            0x0f5af15ff0a3e35486c541f72956b53ff6d0740384ef6463c866146c1bd2afc8\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x01069e38ea6396af1623921101d3d3d14ee46942fb23bf1d110efb994c3ee573,\\n            0x232a8ce7151e69601a7867f9dcac8e2de4dd8352d119c90bbb0fb84720c02513\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1, 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4, 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Config.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title zkSync configuration constants\\n/// @author Matter Labs\\ncontract Config {\\n    /// @dev ERC20 tokens and ETH withdrawals gas limit, used only for complete withdrawals\\n    uint256 internal constant WITHDRAWAL_GAS_LIMIT = 100000;\\n\\n    /// @dev NFT withdrawals gas limit, used only for complete withdrawals\\n    uint256 internal constant WITHDRAWAL_NFT_GAS_LIMIT = 300000;\\n\\n    /// @dev Bytes in one chunk\\n    uint8 internal constant CHUNK_BYTES = 10;\\n\\n    /// @dev zkSync address length\\n    uint8 internal constant ADDRESS_BYTES = 20;\\n\\n    uint8 internal constant PUBKEY_HASH_BYTES = 20;\\n\\n    /// @dev Public key bytes length\\n    uint8 internal constant PUBKEY_BYTES = 32;\\n\\n    /// @dev Ethereum signature r/s bytes length\\n    uint8 internal constant ETH_SIGN_RS_BYTES = 32;\\n\\n    /// @dev Success flag bytes length\\n    uint8 internal constant SUCCESS_FLAG_BYTES = 1;\\n\\n    /// @dev Max amount of tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 internal constant MAX_AMOUNT_OF_REGISTERED_TOKENS = 1023;\\n\\n    /// @dev Max account id that could be registered in the network\\n    uint32 internal constant MAX_ACCOUNT_ID = 16777215;\\n\\n    /// @dev Expected average period of block creation\\n    uint256 internal constant BLOCK_PERIOD = 15 seconds;\\n\\n    /// @dev ETH blocks verification expectation\\n    /// @dev Blocks can be reverted if they are not verified for at least EXPECT_VERIFICATION_IN.\\n    /// @dev If set to 0 validator can revert blocks at any time.\\n    uint256 internal constant EXPECT_VERIFICATION_IN = 0 hours / BLOCK_PERIOD;\\n\\n    uint256 internal constant NOOP_BYTES = 1 * CHUNK_BYTES;\\n    uint256 internal constant DEPOSIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant MINT_NFT_BYTES = 5 * CHUNK_BYTES;\\n    uint256 internal constant TRANSFER_TO_NEW_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant PARTIAL_EXIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant TRANSFER_BYTES = 2 * CHUNK_BYTES;\\n    uint256 internal constant FORCED_EXIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant WITHDRAW_NFT_BYTES = 10 * CHUNK_BYTES;\\n\\n    /// @dev Full exit operation length\\n    uint256 internal constant FULL_EXIT_BYTES = 11 * CHUNK_BYTES;\\n\\n    /// @dev ChangePubKey operation length\\n    uint256 internal constant CHANGE_PUBKEY_BYTES = 6 * CHUNK_BYTES;\\n\\n    /// @dev Expiration delta for priority request to be satisfied (in seconds)\\n    /// @dev NOTE: Priority expiration should be > (EXPECT_VERIFICATION_IN * BLOCK_PERIOD)\\n    /// @dev otherwise incorrect block with priority op could not be reverted.\\n    uint256 internal constant PRIORITY_EXPIRATION_PERIOD = 7 days;\\n\\n    /// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\\n    uint256 internal constant PRIORITY_EXPIRATION =\\n        PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD;\\n\\n    /// @dev Maximum number of priority request to clear during verifying the block\\n    /// @dev Cause deleting storage slots cost 5k gas per each slot it's unprofitable to clear too many slots\\n    /// @dev Value based on the assumption of ~750k gas cost of verifying and 5 used storage slots per PriorityOperation structure\\n    uint64 internal constant MAX_PRIORITY_REQUESTS_TO_DELETE_IN_VERIFY = 6;\\n\\n    /// @dev Reserved time for users to send full exit priority operation in case of an upgrade (in seconds)\\n    uint256 internal constant MASS_FULL_EXIT_PERIOD = 9 days;\\n\\n    /// @dev Reserved time for users to withdraw funds from full exit priority operation in case of an upgrade (in seconds)\\n    uint256 internal constant TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT = 2 days;\\n\\n    /// @dev Notice period before activation preparation status of upgrade mode (in seconds)\\n    /// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\\n    uint256 internal constant UPGRADE_NOTICE_PERIOD =\\n        MASS_FULL_EXIT_PERIOD+PRIORITY_EXPIRATION_PERIOD+TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT;\\n\\n    /// @dev Timestamp - seconds since unix epoch\\n    uint256 internal constant COMMIT_TIMESTAMP_NOT_OLDER = 24 hours;\\n\\n    /// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\\n    /// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\\n    uint256 internal constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 15 minutes;\\n\\n    /// @dev Bit mask to apply for verifier public input before verifying.\\n    uint256 internal constant INPUT_MASK = 14474011154664524427946373126085988481658748083205070504932198000989141204991;\\n\\n    /// @dev Auth fact reset timelock.\\n    uint256 internal constant AUTH_FACT_RESET_TIMELOCK = 1 days;\\n\\n    /// @dev Max deposit of ERC20 token that is possible to deposit\\n    uint128 internal constant MAX_DEPOSIT_AMOUNT = 20282409603651670423947251286015;\\n\\n    uint32 internal constant SPECIAL_ACCOUNT_ID = 16777215;\\n    address internal constant SPECIAL_ACCOUNT_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n    uint32 internal constant SPECIAL_NFT_TOKEN_ID = 2147483646;\\n\\n    uint32 internal constant MAX_FUNGIBLE_TOKEN_ID = 65535;\\n\\n    uint256 internal constant SECURITY_COUNCIL_MEMBERS_NUMBER = 15;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/PlonkCore.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n// solhint-disable\\n\\n\\n\\n\\nlibrary PairingsBn254 {\\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant bn254_b_coeff = 3;\\n\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n\\n    struct Fr {\\n        uint256 value;\\n    }\\n\\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\\n        require(fr < r_mod);\\n        return Fr({value: fr});\\n    }\\n\\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\\n        n.value = self.value;\\n    }\\n\\n    function assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = other.value;\\n    }\\n\\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\\n        require(fr.value != 0);\\n        return pow(fr, r_mod - 2);\\n    }\\n\\n    function add_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, other.value, r_mod);\\n    }\\n\\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\\n    }\\n\\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = mulmod(self.value, other.value, r_mod);\\n    }\\n\\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\\n        uint256[1] memory result;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\\n        }\\n        require(success);\\n        return Fr({value: result[0]});\\n    }\\n\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint256[2] X;\\n        uint256[2] Y;\\n    }\\n\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        if (x == 0 && y == 0) {\\n            // point of infinity is (0,0)\\n            return G1Point(x, y);\\n        }\\n\\n        // check encoding\\n        require(x < q_mod);\\n        require(y < q_mod);\\n        // check on curve\\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\\n        rhs = mulmod(rhs, x, q_mod); // x^3\\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\\n        require(lhs == rhs);\\n\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\\n        return G2Point(x, y);\\n    }\\n\\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\\n        result.X = self.X;\\n        result.Y = self.Y;\\n    }\\n\\n    function P2() internal pure returns (G2Point memory) {\\n        // for some reason ethereum expects to have c1*v + c0 form\\n\\n        return\\n            G2Point(\\n                [\\n                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\\n                ],\\n                [\\n                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n                ]\\n            );\\n    }\\n\\n    function negate(G1Point memory self) internal pure {\\n        // The prime q in the base field F_q for G1\\n        if (self.Y == 0) {\\n            require(self.X == 0);\\n            return;\\n        }\\n\\n        self.Y = q_mod - self.Y;\\n    }\\n\\n    function point_add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\\n        point_add_into_dest(p1, p2, r);\\n        return r;\\n    }\\n\\n    function point_add_assign(G1Point memory p1, G1Point memory p2) internal view {\\n        point_add_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_add_into_dest(\\n        G1Point memory p1,\\n        G1Point memory p2,\\n        G1Point memory dest\\n    ) internal view {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we add zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we add into zero, and we add non-zero point\\n            dest.X = p2.X;\\n            dest.Y = p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_sub_assign(G1Point memory p1, G1Point memory p2) internal view {\\n        point_sub_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_sub_into_dest(\\n        G1Point memory p1,\\n        G1Point memory p2,\\n        G1Point memory dest\\n    ) internal view {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we subtracted zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we subtract from zero, and we subtract non-zero point\\n            dest.X = p2.X;\\n            dest.Y = q_mod - p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = q_mod - p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_mul(G1Point memory p, Fr memory s) internal view returns (G1Point memory r) {\\n        point_mul_into_dest(p, s, r);\\n        return r;\\n    }\\n\\n    function point_mul_assign(G1Point memory p, Fr memory s) internal view {\\n        point_mul_into_dest(p, s, p);\\n    }\\n\\n    function point_mul_into_dest(\\n        G1Point memory p,\\n        Fr memory s,\\n        G1Point memory dest\\n    ) internal view {\\n        uint256[3] memory input;\\n        input[0] = p.X;\\n        input[1] = p.Y;\\n        input[2] = s.value;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\\n        }\\n        require(success);\\n    }\\n\\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\\n        require(p1.length == p2.length);\\n        uint256 elements = p1.length;\\n        uint256 inputSize = elements * 6;\\n        uint256[] memory input = new uint256[](inputSize);\\n        for (uint256 i = 0; i < elements; i++) {\\n            input[i * 6 + 0] = p1[i].X;\\n            input[i * 6 + 1] = p1[i].Y;\\n            input[i * 6 + 2] = p2[i].X[0];\\n            input[i * 6 + 3] = p2[i].X[1];\\n            input[i * 6 + 4] = p2[i].Y[0];\\n            input[i * 6 + 5] = p2[i].Y[1];\\n        }\\n        uint256[1] memory out;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\\n        }\\n        require(success);\\n        return out[0] != 0;\\n    }\\n\\n    /// Convenience method for a pairing check for two pairs.\\n    function pairingProd2(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2\\n    ) internal view returns (bool) {\\n        G1Point[] memory p1 = new G1Point[](2);\\n        G2Point[] memory p2 = new G2Point[](2);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        return pairing(p1, p2);\\n    }\\n}\\n\\nlibrary TranscriptLibrary {\\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint32 constant DST_0 = 0;\\n    uint32 constant DST_1 = 1;\\n    uint32 constant DST_CHALLENGE = 2;\\n\\n    struct Transcript {\\n        bytes32 state_0;\\n        bytes32 state_1;\\n        uint32 challenge_counter;\\n    }\\n\\n    function new_transcript() internal pure returns (Transcript memory t) {\\n        t.state_0 = bytes32(0);\\n        t.state_1 = bytes32(0);\\n        t.challenge_counter = 0;\\n    }\\n\\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\\n        bytes32 old_state_0 = self.state_0;\\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\\n    }\\n\\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\\n        update_with_u256(self, value.value);\\n    }\\n\\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\\n        update_with_u256(self, p.X);\\n        update_with_u256(self, p.Y);\\n    }\\n\\n    function get_challenge(Transcript memory self) internal pure returns (PairingsBn254.Fr memory challenge) {\\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\\n        self.challenge_counter += 1;\\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\\n    }\\n}\\n\\ncontract Plonk4VerifierWithAccessToDNext {\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\\n\\n    uint256 constant ZERO = 0;\\n    uint256 constant ONE = 1;\\n    uint256 constant TWO = 2;\\n    uint256 constant THREE = 3;\\n    uint256 constant FOUR = 4;\\n\\n    uint256 constant STATE_WIDTH = 4;\\n    uint256 constant NUM_DIFFERENT_GATES = 2;\\n    uint256 constant NUM_SETUP_POLYS_FOR_MAIN_GATE = 7;\\n    uint256 constant NUM_SETUP_POLYS_RANGE_CHECK_GATE = 0;\\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP = 1;\\n    uint256 constant NUM_GATE_SELECTORS_OPENED_EXPLICITLY = 1;\\n\\n    uint256 constant RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK =\\n        0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    uint256 constant LIMB_WIDTH = 68;\\n\\n    struct VerificationKey {\\n        uint256 domain_size;\\n        uint256 num_inputs;\\n        PairingsBn254.Fr omega;\\n        PairingsBn254.G1Point[NUM_SETUP_POLYS_FOR_MAIN_GATE + NUM_SETUP_POLYS_RANGE_CHECK_GATE] gate_setup_commitments;\\n        PairingsBn254.G1Point[NUM_DIFFERENT_GATES] gate_selector_commitments;\\n        PairingsBn254.G1Point[STATE_WIDTH] copy_permutation_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_non_residues;\\n        PairingsBn254.G2Point g2_x;\\n    }\\n\\n    struct Proof {\\n        uint256[] input_values;\\n        PairingsBn254.G1Point[STATE_WIDTH] wire_commitments;\\n        PairingsBn254.G1Point copy_permutation_grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH] wire_values_at_z;\\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] wire_values_at_z_omega;\\n        PairingsBn254.Fr[NUM_GATE_SELECTORS_OPENED_EXPLICITLY] gate_selector_values_at_z;\\n        PairingsBn254.Fr copy_grand_product_at_z_omega;\\n        PairingsBn254.Fr quotient_polynomial_at_z;\\n        PairingsBn254.Fr linearization_polynomial_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH - 1] permutation_polynomials_at_z;\\n        PairingsBn254.G1Point opening_at_z_proof;\\n        PairingsBn254.G1Point opening_at_z_omega_proof;\\n    }\\n\\n    struct PartialVerifierState {\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr[] cached_lagrange_evals;\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function batch_evaluate_lagrange_poly_out_of_domain(\\n        uint256[] memory poly_nums,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr[] memory res) {\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory tmp_1 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory tmp_2 = PairingsBn254.new_fr(domain_size);\\n        PairingsBn254.Fr memory vanishing_at_z = at.pow(domain_size);\\n        vanishing_at_z.sub_assign(one);\\n        // we can not have random point z be in domain\\n        require(vanishing_at_z.value != 0);\\n        PairingsBn254.Fr[] memory nums = new PairingsBn254.Fr[](poly_nums.length);\\n        PairingsBn254.Fr[] memory dens = new PairingsBn254.Fr[](poly_nums.length);\\n        // numerators in a form omega^i * (z^n - 1)\\n        // denoms in a form (z - omega^i) * N\\n        for (uint256 i = 0; i < poly_nums.length; i++) {\\n            tmp_1 = omega.pow(poly_nums[i]); // power of omega\\n            nums[i].assign(vanishing_at_z);\\n            nums[i].mul_assign(tmp_1);\\n\\n            dens[i].assign(at); // (X - omega^i) * N\\n            dens[i].sub_assign(tmp_1);\\n            dens[i].mul_assign(tmp_2); // mul by domain size\\n        }\\n\\n        PairingsBn254.Fr[] memory partial_products = new PairingsBn254.Fr[](poly_nums.length);\\n        partial_products[0].assign(PairingsBn254.new_fr(1));\\n        for (uint256 i = 1; i < dens.length - 1; i++) {\\n            partial_products[i].assign(dens[i - 1]);\\n            partial_products[i].mul_assign(dens[i]);\\n        }\\n\\n        tmp_2.assign(partial_products[partial_products.length - 1]);\\n        tmp_2.mul_assign(dens[dens.length - 1]);\\n        tmp_2 = tmp_2.inverse(); // tmp_2 contains a^-1 * b^-1 (with! the last one)\\n\\n        for (uint256 i = dens.length - 1; i < dens.length; i--) {\\n            dens[i].assign(tmp_2); // all inversed\\n            dens[i].mul_assign(partial_products[i]); // clear lowest terms\\n            tmp_2.mul_assign(dens[i]);\\n        }\\n\\n        for (uint256 i = 0; i < nums.length; i++) {\\n            nums[i].mul_assign(dens[i]);\\n        }\\n\\n        return nums;\\n    }\\n\\n    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)\\n        internal\\n        view\\n        returns (PairingsBn254.Fr memory res)\\n    {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function verify_at_z(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.Fr memory lhs = evaluate_vanishing(vk.domain_size, state.z);\\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\\n\\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\\n\\n        // public inputs\\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\\n            tmp.assign(state.cached_lagrange_evals[i]);\\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            inputs_term.add_assign(tmp);\\n        }\\n\\n        inputs_term.mul_assign(proof.gate_selector_values_at_z[0]);\\n        rhs.add_assign(inputs_term);\\n\\n        // now we need 5th power\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.copy_grand_product_at_z_omega);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp.mul_assign(state.beta);\\n            tmp.add_assign(state.gamma);\\n            tmp.add_assign(proof.wire_values_at_z[i]);\\n\\n            z_part.mul_assign(tmp);\\n        }\\n\\n        tmp.assign(state.gamma);\\n        // we need a wire value of the last polynomial in enumeration\\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH - 1]);\\n\\n        z_part.mul_assign(tmp);\\n        z_part.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(z_part);\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        tmp.assign(state.cached_lagrange_evals[0]);\\n        tmp.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(tmp);\\n\\n        return lhs.value == rhs.value;\\n    }\\n\\n    function add_contribution_from_range_constraint_gates(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        PairingsBn254.Fr memory current_alpha\\n    ) internal pure returns (PairingsBn254.Fr memory res) {\\n        // now add contribution from range constraint gate\\n        // we multiply selector commitment by all the factors (alpha*(c - 4d)(c - 4d - 1)(..-2)(..-3) + alpha^2 * (4b - c)()()() + {} + {})\\n\\n        PairingsBn254.Fr memory one_fr = PairingsBn254.new_fr(ONE);\\n        PairingsBn254.Fr memory two_fr = PairingsBn254.new_fr(TWO);\\n        PairingsBn254.Fr memory three_fr = PairingsBn254.new_fr(THREE);\\n        PairingsBn254.Fr memory four_fr = PairingsBn254.new_fr(FOUR);\\n\\n        res = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t0 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t1 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory t2 = PairingsBn254.new_fr(0);\\n\\n        for (uint256 i = 0; i < 3; i++) {\\n            current_alpha.mul_assign(state.alpha);\\n\\n            // high - 4*low\\n\\n            // this is 4*low\\n            t0 = PairingsBn254.copy(proof.wire_values_at_z[3 - i]);\\n            t0.mul_assign(four_fr);\\n\\n            // high\\n            t1 = PairingsBn254.copy(proof.wire_values_at_z[2 - i]);\\n            t1.sub_assign(t0);\\n\\n            // t0 is now t1 - {0,1,2,3}\\n\\n            // first unroll manually for -0;\\n            t2 = PairingsBn254.copy(t1);\\n\\n            // -1\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(one_fr);\\n            t2.mul_assign(t0);\\n\\n            // -2\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(two_fr);\\n            t2.mul_assign(t0);\\n\\n            // -3\\n            t0 = PairingsBn254.copy(t1);\\n            t0.sub_assign(three_fr);\\n            t2.mul_assign(t0);\\n\\n            t2.mul_assign(current_alpha);\\n\\n            res.add_assign(t2);\\n        }\\n\\n        // now also d_next - 4a\\n\\n        current_alpha.mul_assign(state.alpha);\\n\\n        // high - 4*low\\n\\n        // this is 4*low\\n        t0 = PairingsBn254.copy(proof.wire_values_at_z[0]);\\n        t0.mul_assign(four_fr);\\n\\n        // high\\n        t1 = PairingsBn254.copy(proof.wire_values_at_z_omega[0]);\\n        t1.sub_assign(t0);\\n\\n        // t0 is now t1 - {0,1,2,3}\\n\\n        // first unroll manually for -0;\\n        t2 = PairingsBn254.copy(t1);\\n\\n        // -1\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(one_fr);\\n        t2.mul_assign(t0);\\n\\n        // -2\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(two_fr);\\n        t2.mul_assign(t0);\\n\\n        // -3\\n        t0 = PairingsBn254.copy(t1);\\n        t0.sub_assign(three_fr);\\n        t2.mul_assign(t0);\\n\\n        t2.mul_assign(current_alpha);\\n\\n        res.add_assign(t2);\\n\\n        return res;\\n    }\\n\\n    function reconstruct_linearization_commitment(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point memory res) {\\n        // we compute what power of v is used as a delinearization factor in batch opening of\\n        // commitments. Let's label W(x) = 1 / (x - z) *\\n        // [\\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\\n        // + v (r(x) - r(z))\\n        // + v^{2..5} * (witness(x) - witness(z))\\n        // + v^{6} * (selector(x) - selector(z))\\n        // + v^{7..9} * (permutation(x) - permutation(z))\\n        // ]\\n        // W'(x) = 1 / (x - z*omega) *\\n        // [\\n        // + v^10 (z(x) - z(z*omega)) <- we need this power\\n        // + v^11 * (d(x) - d(z*omega))\\n        // ]\\n        //\\n\\n        // we reconstruct linearization polynomial virtual selector\\n        // for that purpose we first linearize over main gate (over all it's selectors)\\n        // and multiply them by value(!) of the corresponding main gate selector\\n        res = PairingsBn254.copy_g1(vk.gate_setup_commitments[STATE_WIDTH + 1]); // index of q_const(x)\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\\n\\n        // addition gates\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            tmp_g1 = vk.gate_setup_commitments[i].point_mul(proof.wire_values_at_z[i]);\\n            res.point_add_assign(tmp_g1);\\n        }\\n\\n        // multiplication gate\\n        tmp_fr.assign(proof.wire_values_at_z[0]);\\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\\n        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH].point_mul(tmp_fr);\\n        res.point_add_assign(tmp_g1);\\n\\n        // d_next\\n        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH + 2].point_mul(proof.wire_values_at_z_omega[0]); // index of q_d_next(x)\\n        res.point_add_assign(tmp_g1);\\n\\n        // multiply by main gate selector(z)\\n        res.point_mul_assign(proof.gate_selector_values_at_z[0]); // these is only one explicitly opened selector\\n\\n        PairingsBn254.Fr memory current_alpha = PairingsBn254.new_fr(ONE);\\n\\n        // calculate scalar contribution from the range check gate\\n        tmp_fr = add_contribution_from_range_constraint_gates(state, proof, current_alpha);\\n        tmp_g1 = vk.gate_selector_commitments[1].point_mul(tmp_fr); // selector commitment for range constraint gate * scalar\\n        res.point_add_assign(tmp_g1);\\n\\n        // proceed as normal to copy permutation\\n        current_alpha.mul_assign(state.alpha); // alpha^5\\n\\n        PairingsBn254.Fr memory alpha_for_grand_product = PairingsBn254.copy(current_alpha);\\n\\n        // z * non_res * beta + gamma + a\\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\\n        grand_product_part_at_z.mul_assign(state.beta);\\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\\n        grand_product_part_at_z.add_assign(state.gamma);\\n        for (uint256 i = 0; i < vk.copy_permutation_non_residues.length; i++) {\\n            tmp_fr.assign(state.z);\\n            tmp_fr.mul_assign(vk.copy_permutation_non_residues[i]);\\n            tmp_fr.mul_assign(state.beta);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i + 1]);\\n\\n            grand_product_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        grand_product_part_at_z.mul_assign(alpha_for_grand_product);\\n\\n        // alpha^n & L_{0}(z), and we bump current_alpha\\n        current_alpha.mul_assign(state.alpha);\\n\\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\\n        tmp_fr.mul_assign(current_alpha);\\n\\n        grand_product_part_at_z.add_assign(tmp_fr);\\n\\n        // prefactor for grand_product(x) is complete\\n\\n        // add to the linearization a part from the term\\n        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp_fr.assign(state.beta);\\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\\n\\n            last_permutation_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        last_permutation_part_at_z.mul_assign(state.beta);\\n        last_permutation_part_at_z.mul_assign(proof.copy_grand_product_at_z_omega);\\n        last_permutation_part_at_z.mul_assign(alpha_for_grand_product); // we multiply by the power of alpha from the argument\\n\\n        // actually multiply prefactors by z(x) and perm_d(x) and combine them\\n        tmp_g1 = proof.copy_permutation_grand_product_commitment.point_mul(grand_product_part_at_z);\\n        tmp_g1.point_sub_assign(vk.copy_permutation_commitments[STATE_WIDTH - 1].point_mul(last_permutation_part_at_z));\\n\\n        res.point_add_assign(tmp_g1);\\n        // multiply them by v immedately as linearization has a factor of v^1\\n        res.point_mul_assign(state.v);\\n        // res now contains contribution from the gates linearization and\\n        // copy permutation part\\n\\n        // now we need to add a part that is the rest\\n        // for z(x*omega):\\n        // - (a(z) + beta*perm_a + gamma)*()*()*(d(z) + gamma) * z(x*omega)\\n    }\\n\\n    function aggregate_commitments(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point[2] memory res) {\\n        PairingsBn254.G1Point memory d = reconstruct_linearization_commitment(state, proof, vk);\\n\\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\\n        for (uint256 i = 1; i < proof.quotient_poly_commitments.length; i++) {\\n            tmp_fr.mul_assign(z_in_domain_size);\\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        commitment_aggregation.point_add_assign(d);\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint256 i = 0; i < NUM_GATE_SELECTORS_OPENED_EXPLICITLY; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.gate_selector_commitments[0].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint256 i = 0; i < vk.copy_permutation_commitments.length - 1; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.copy_permutation_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        // now do prefactor for grand_product(x*omega)\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        commitment_aggregation.point_add_assign(proof.copy_permutation_grand_product_commitment.point_mul(tmp_fr));\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH - 1].point_mul(tmp_fr);\\n        commitment_aggregation.point_add_assign(tmp_g1);\\n\\n        // collect opening values\\n        aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.wire_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_fr.assign(proof.gate_selector_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.copy_grand_product_at_z_omega);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\\n\\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\\n\\n        tmp_fr.assign(state.z);\\n        tmp_fr.mul_assign(vk.omega);\\n        tmp_fr.mul_assign(state.u);\\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\\n\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\\n        pair_with_x.negate();\\n\\n        res[0] = pair_with_generator;\\n        res[1] = pair_with_x;\\n\\n        return res;\\n    }\\n\\n    function verify_initial(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        require(proof.input_values.length == vk.num_inputs);\\n        require(vk.num_inputs >= 1);\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            transcript.update_with_g1(proof.wire_commitments[i]);\\n        }\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\\n        }\\n\\n        state.z = transcript.get_challenge();\\n\\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {\\n            lagrange_poly_numbers[i] = i;\\n        }\\n\\n        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain(\\n            lagrange_poly_numbers,\\n            vk.domain_size,\\n            vk.omega,\\n            state.z\\n        );\\n\\n        bool valid = verify_at_z(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.gate_selector_values_at_z[0]);\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.copy_grand_product_at_z_omega);\\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\\n\\n        state.v = transcript.get_challenge();\\n        transcript.update_with_g1(proof.opening_at_z_proof);\\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\\n        state.u = transcript.get_challenge();\\n\\n        return true;\\n    }\\n\\n    // This verifier is for a PLONK with a state width 4\\n    // and main gate equation\\n    // q_a(X) * a(X) +\\n    // q_b(X) * b(X) +\\n    // q_c(X) * c(X) +\\n    // q_d(X) * d(X) +\\n    // q_m(X) * a(X) * b(X) +\\n    // q_constants(X)+\\n    // q_d_next(X) * d(X*omega)\\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\\n    // q_d_next(X) \\\"peeks\\\" into the next row of the trace, so it takes\\n    // the same d(X) polynomial, but shifted\\n\\n    function aggregate_for_verification(Proof memory proof, VerificationKey memory vk)\\n        internal\\n        view\\n        returns (bool valid, PairingsBn254.G1Point[2] memory part)\\n    {\\n        PartialVerifierState memory state;\\n\\n        valid = verify_initial(state, proof, vk);\\n\\n        if (valid == false) {\\n            return (valid, part);\\n        }\\n\\n        part = aggregate_commitments(state, proof, vk);\\n\\n        (valid, part);\\n    }\\n\\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\\n        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        valid = PairingsBn254.pairingProd2(\\n            recursive_proof_part[0],\\n            PairingsBn254.P2(),\\n            recursive_proof_part[1],\\n            vk.g2_x\\n        );\\n\\n        return valid;\\n    }\\n\\n    function verify_recursive(\\n        Proof memory proof,\\n        VerificationKey memory vk,\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[16] memory subproofs_limbs\\n    ) internal view returns (bool) {\\n        (uint256 recursive_input, PairingsBn254.G1Point[2] memory aggregated_g1s) =\\n            reconstruct_recursive_public_input(\\n                recursive_vks_root,\\n                max_valid_index,\\n                recursive_vks_indexes,\\n                individual_vks_inputs,\\n                subproofs_limbs\\n            );\\n\\n        assert(recursive_input == proof.input_values[0]);\\n\\n        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        // aggregated_g1s = inner\\n        // recursive_proof_part = outer\\n        PairingsBn254.G1Point[2] memory combined = combine_inner_and_outer(aggregated_g1s, recursive_proof_part);\\n\\n        valid = PairingsBn254.pairingProd2(combined[0], PairingsBn254.P2(), combined[1], vk.g2_x);\\n\\n        return valid;\\n    }\\n\\n    function combine_inner_and_outer(PairingsBn254.G1Point[2] memory inner, PairingsBn254.G1Point[2] memory outer)\\n        internal\\n        view\\n        returns (PairingsBn254.G1Point[2] memory result)\\n    {\\n        // reuse the transcript primitive\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        transcript.update_with_g1(inner[0]);\\n        transcript.update_with_g1(inner[1]);\\n        transcript.update_with_g1(outer[0]);\\n        transcript.update_with_g1(outer[1]);\\n        PairingsBn254.Fr memory challenge = transcript.get_challenge();\\n        // 1 * inner + challenge * outer\\n        result[0] = PairingsBn254.copy_g1(inner[0]);\\n        result[1] = PairingsBn254.copy_g1(inner[1]);\\n        PairingsBn254.G1Point memory tmp = outer[0].point_mul(challenge);\\n        result[0].point_add_assign(tmp);\\n        tmp = outer[1].point_mul(challenge);\\n        result[1].point_add_assign(tmp);\\n\\n        return result;\\n    }\\n\\n    function reconstruct_recursive_public_input(\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[16] memory subproofs_aggregated\\n    ) internal pure returns (uint256 recursive_input, PairingsBn254.G1Point[2] memory reconstructed_g1s) {\\n        assert(recursive_vks_indexes.length == individual_vks_inputs.length);\\n        bytes memory concatenated = abi.encodePacked(recursive_vks_root);\\n        uint8 index;\\n        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {\\n            index = recursive_vks_indexes[i];\\n            assert(index <= max_valid_index);\\n            concatenated = abi.encodePacked(concatenated, index);\\n        }\\n        uint256 input;\\n        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {\\n            input = individual_vks_inputs[i];\\n            assert(input < r_mod);\\n            concatenated = abi.encodePacked(concatenated, input);\\n        }\\n\\n        concatenated = abi.encodePacked(concatenated, subproofs_aggregated);\\n\\n        bytes32 commitment = sha256(concatenated);\\n        recursive_input = uint256(commitment) & RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK;\\n\\n        reconstructed_g1s[0] = PairingsBn254.new_g1_checked(\\n            subproofs_aggregated[0] +\\n                (subproofs_aggregated[1] << LIMB_WIDTH) +\\n                (subproofs_aggregated[2] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[3] << (3 * LIMB_WIDTH)),\\n            subproofs_aggregated[4] +\\n                (subproofs_aggregated[5] << LIMB_WIDTH) +\\n                (subproofs_aggregated[6] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[7] << (3 * LIMB_WIDTH))\\n        );\\n\\n        reconstructed_g1s[1] = PairingsBn254.new_g1_checked(\\n            subproofs_aggregated[8] +\\n                (subproofs_aggregated[9] << LIMB_WIDTH) +\\n                (subproofs_aggregated[10] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[11] << (3 * LIMB_WIDTH)),\\n            subproofs_aggregated[12] +\\n                (subproofs_aggregated[13] << LIMB_WIDTH) +\\n                (subproofs_aggregated[14] << (2 * LIMB_WIDTH)) +\\n                (subproofs_aggregated[15] << (3 * LIMB_WIDTH))\\n        );\\n\\n        return (recursive_input, reconstructed_g1s);\\n    }\\n}\\n\\ncontract VerifierWithDeserialize is Plonk4VerifierWithAccessToDNext {\\n    uint256 constant SERIALIZED_PROOF_LENGTH = 34;\\n\\n    function deserialize_proof(uint256[] memory public_inputs, uint256[] memory serialized_proof)\\n        internal\\n        pure\\n        returns (Proof memory proof)\\n    {\\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH);\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i++) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n\\n            j += 2;\\n        }\\n\\n        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j + 1]\\n        );\\n        j += 2;\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j + 1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {\\n            proof.gate_selector_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        proof.copy_grand_product_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n        j += 2;\\n\\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n    }\\n\\n    function verify_serialized_proof(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof,\\n        VerificationKey memory vk\\n    ) public view returns (bool) {\\n        require(vk.num_inputs == public_inputs.length);\\n\\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\\n\\n        bool valid = verify(proof, vk);\\n\\n        return valid;\\n    }\\n\\n    function verify_serialized_proof_with_recursion(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof,\\n        uint256 recursive_vks_root,\\n        uint8 max_valid_index,\\n        uint8[] memory recursive_vks_indexes,\\n        uint256[] memory individual_vks_inputs,\\n        uint256[16] memory subproofs_limbs,\\n        VerificationKey memory vk\\n    ) public view returns (bool) {\\n        require(vk.num_inputs == public_inputs.length);\\n\\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\\n\\n        bool valid =\\n            verify_recursive(\\n                proof,\\n                vk,\\n                recursive_vks_root,\\n                max_valid_index,\\n                recursive_vks_indexes,\\n                individual_vks_inputs,\\n                subproofs_limbs\\n            );\\n\\n        return valid;\\n    }\\n}\\n\\ncontract Plonk4VerifierWithAccessToDNextOld {\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\\n\\n    uint256 constant STATE_WIDTH_OLD = 4;\\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD = 1;\\n\\n    struct VerificationKeyOld {\\n        uint256 domain_size;\\n        uint256 num_inputs;\\n        PairingsBn254.Fr omega;\\n        PairingsBn254.G1Point[STATE_WIDTH_OLD + 2] selector_commitments; // STATE_WIDTH for witness + multiplication + constant\\n        PairingsBn254.G1Point[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD] next_step_selector_commitments;\\n        PairingsBn254.G1Point[STATE_WIDTH_OLD] permutation_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH_OLD - 1] permutation_non_residues;\\n        PairingsBn254.G2Point g2_x;\\n    }\\n\\n    struct ProofOld {\\n        uint256[] input_values;\\n        PairingsBn254.G1Point[STATE_WIDTH_OLD] wire_commitments;\\n        PairingsBn254.G1Point grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH_OLD] quotient_poly_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH_OLD] wire_values_at_z;\\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD] wire_values_at_z_omega;\\n        PairingsBn254.Fr grand_product_at_z_omega;\\n        PairingsBn254.Fr quotient_polynomial_at_z;\\n        PairingsBn254.Fr linearization_polynomial_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH_OLD - 1] permutation_polynomials_at_z;\\n        PairingsBn254.G1Point opening_at_z_proof;\\n        PairingsBn254.G1Point opening_at_z_omega_proof;\\n    }\\n\\n    struct PartialVerifierStateOld {\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr[] cached_lagrange_evals;\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain_old(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function batch_evaluate_lagrange_poly_out_of_domain_old(\\n        uint256[] memory poly_nums,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr[] memory res) {\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory tmp_1 = PairingsBn254.new_fr(0);\\n        PairingsBn254.Fr memory tmp_2 = PairingsBn254.new_fr(domain_size);\\n        PairingsBn254.Fr memory vanishing_at_z = at.pow(domain_size);\\n        vanishing_at_z.sub_assign(one);\\n        // we can not have random point z be in domain\\n        require(vanishing_at_z.value != 0);\\n        PairingsBn254.Fr[] memory nums = new PairingsBn254.Fr[](poly_nums.length);\\n        PairingsBn254.Fr[] memory dens = new PairingsBn254.Fr[](poly_nums.length);\\n        // numerators in a form omega^i * (z^n - 1)\\n        // denoms in a form (z - omega^i) * N\\n        for (uint256 i = 0; i < poly_nums.length; i++) {\\n            tmp_1 = omega.pow(poly_nums[i]); // power of omega\\n            nums[i].assign(vanishing_at_z);\\n            nums[i].mul_assign(tmp_1);\\n\\n            dens[i].assign(at); // (X - omega^i) * N\\n            dens[i].sub_assign(tmp_1);\\n            dens[i].mul_assign(tmp_2); // mul by domain size\\n        }\\n\\n        PairingsBn254.Fr[] memory partial_products = new PairingsBn254.Fr[](poly_nums.length);\\n        partial_products[0].assign(PairingsBn254.new_fr(1));\\n        for (uint256 i = 1; i < dens.length - 1; i++) {\\n            partial_products[i].assign(dens[i - 1]);\\n            partial_products[i].mul_assign(dens[i]);\\n        }\\n\\n        tmp_2.assign(partial_products[partial_products.length - 1]);\\n        tmp_2.mul_assign(dens[dens.length - 1]);\\n        tmp_2 = tmp_2.inverse(); // tmp_2 contains a^-1 * b^-1 (with! the last one)\\n\\n        for (uint256 i = dens.length - 1; i < dens.length; i--) {\\n            dens[i].assign(tmp_2); // all inversed\\n            dens[i].mul_assign(partial_products[i]); // clear lowest terms\\n            tmp_2.mul_assign(dens[i]);\\n        }\\n\\n        for (uint256 i = 0; i < nums.length; i++) {\\n            nums[i].mul_assign(dens[i]);\\n        }\\n\\n        return nums;\\n    }\\n\\n    function evaluate_vanishing_old(uint256 domain_size, PairingsBn254.Fr memory at)\\n        internal\\n        view\\n        returns (PairingsBn254.Fr memory res)\\n    {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function verify_at_z(\\n        PartialVerifierStateOld memory state,\\n        ProofOld memory proof,\\n        VerificationKeyOld memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.Fr memory lhs = evaluate_vanishing_old(vk.domain_size, state.z);\\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\\n\\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\\n\\n        // public inputs\\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\\n            tmp.assign(state.cached_lagrange_evals[i]);\\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            rhs.add_assign(tmp);\\n        }\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.grand_product_at_z_omega);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp.mul_assign(state.beta);\\n            tmp.add_assign(state.gamma);\\n            tmp.add_assign(proof.wire_values_at_z[i]);\\n\\n            z_part.mul_assign(tmp);\\n        }\\n\\n        tmp.assign(state.gamma);\\n        // we need a wire value of the last polynomial in enumeration\\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH_OLD - 1]);\\n\\n        z_part.mul_assign(tmp);\\n        z_part.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(z_part);\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        tmp.assign(state.cached_lagrange_evals[0]);\\n        tmp.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(tmp);\\n\\n        return lhs.value == rhs.value;\\n    }\\n\\n    function reconstruct_d(\\n        PartialVerifierStateOld memory state,\\n        ProofOld memory proof,\\n        VerificationKeyOld memory vk\\n    ) internal view returns (PairingsBn254.G1Point memory res) {\\n        // we compute what power of v is used as a delinearization factor in batch opening of\\n        // commitments. Let's label W(x) = 1 / (x - z) *\\n        // [\\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\\n        // + v (r(x) - r(z))\\n        // + v^{2..5} * (witness(x) - witness(z))\\n        // + v^(6..8) * (permutation(x) - permutation(z))\\n        // ]\\n        // W'(x) = 1 / (x - z*omega) *\\n        // [\\n        // + v^9 (z(x) - z(z*omega)) <- we need this power\\n        // + v^10 * (d(x) - d(z*omega))\\n        // ]\\n        //\\n        // we pay a little for a few arithmetic operations to not introduce another constant\\n        uint256 power_for_z_omega_opening = 1 + 1 + STATE_WIDTH_OLD + STATE_WIDTH_OLD - 1;\\n        res = PairingsBn254.copy_g1(vk.selector_commitments[STATE_WIDTH_OLD + 1]);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\\n\\n        // addition gates\\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\\n            tmp_g1 = vk.selector_commitments[i].point_mul(proof.wire_values_at_z[i]);\\n            res.point_add_assign(tmp_g1);\\n        }\\n\\n        // multiplication gate\\n        tmp_fr.assign(proof.wire_values_at_z[0]);\\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\\n        tmp_g1 = vk.selector_commitments[STATE_WIDTH_OLD].point_mul(tmp_fr);\\n        res.point_add_assign(tmp_g1);\\n\\n        // d_next\\n        tmp_g1 = vk.next_step_selector_commitments[0].point_mul(proof.wire_values_at_z_omega[0]);\\n        res.point_add_assign(tmp_g1);\\n\\n        // z * non_res * beta + gamma + a\\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\\n        grand_product_part_at_z.mul_assign(state.beta);\\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\\n        grand_product_part_at_z.add_assign(state.gamma);\\n        for (uint256 i = 0; i < vk.permutation_non_residues.length; i++) {\\n            tmp_fr.assign(state.z);\\n            tmp_fr.mul_assign(vk.permutation_non_residues[i]);\\n            tmp_fr.mul_assign(state.beta);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i + 1]);\\n\\n            grand_product_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        grand_product_part_at_z.mul_assign(state.alpha);\\n\\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\\n        tmp_fr.mul_assign(state.alpha);\\n        tmp_fr.mul_assign(state.alpha);\\n\\n        grand_product_part_at_z.add_assign(tmp_fr);\\n\\n        PairingsBn254.Fr memory grand_product_part_at_z_omega = state.v.pow(power_for_z_omega_opening);\\n        grand_product_part_at_z_omega.mul_assign(state.u);\\n\\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp_fr.assign(state.beta);\\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\\n\\n            last_permutation_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        last_permutation_part_at_z.mul_assign(state.beta);\\n        last_permutation_part_at_z.mul_assign(proof.grand_product_at_z_omega);\\n        last_permutation_part_at_z.mul_assign(state.alpha);\\n\\n        // add to the linearization\\n        tmp_g1 = proof.grand_product_commitment.point_mul(grand_product_part_at_z);\\n        tmp_g1.point_sub_assign(vk.permutation_commitments[STATE_WIDTH_OLD - 1].point_mul(last_permutation_part_at_z));\\n\\n        res.point_add_assign(tmp_g1);\\n        res.point_mul_assign(state.v);\\n\\n        res.point_add_assign(proof.grand_product_commitment.point_mul(grand_product_part_at_z_omega));\\n    }\\n\\n    function verify_commitments(\\n        PartialVerifierStateOld memory state,\\n        ProofOld memory proof,\\n        VerificationKeyOld memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.G1Point memory d = reconstruct_d(state, proof, vk);\\n\\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\\n        for (uint256 i = 1; i < proof.quotient_poly_commitments.length; i++) {\\n            tmp_fr.mul_assign(z_in_domain_size);\\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        commitment_aggregation.point_add_assign(d);\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint256 i = 0; i < vk.permutation_commitments.length - 1; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.permutation_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH_OLD - 1].point_mul(tmp_fr);\\n        commitment_aggregation.point_add_assign(tmp_g1);\\n\\n        // collect opening values\\n        aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.wire_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.grand_product_at_z_omega);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\\n\\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\\n\\n        tmp_fr.assign(state.z);\\n        tmp_fr.mul_assign(vk.omega);\\n        tmp_fr.mul_assign(state.u);\\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\\n\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\\n        pair_with_x.negate();\\n\\n        return PairingsBn254.pairingProd2(pair_with_generator, PairingsBn254.P2(), pair_with_x, vk.g2_x);\\n    }\\n\\n    function verify_initial(\\n        PartialVerifierStateOld memory state,\\n        ProofOld memory proof,\\n        VerificationKeyOld memory vk\\n    ) internal view returns (bool) {\\n        require(proof.input_values.length == vk.num_inputs);\\n        require(vk.num_inputs >= 1);\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            transcript.update_with_g1(proof.wire_commitments[i]);\\n        }\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\\n        }\\n\\n        state.z = transcript.get_challenge();\\n\\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {\\n            lagrange_poly_numbers[i] = i;\\n        }\\n\\n        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain_old(\\n            lagrange_poly_numbers,\\n            vk.domain_size,\\n            vk.omega,\\n            state.z\\n        );\\n\\n        bool valid = verify_at_z(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\\n        transcript.update_with_fr(proof.grand_product_at_z_omega);\\n\\n        state.v = transcript.get_challenge();\\n        transcript.update_with_g1(proof.opening_at_z_proof);\\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\\n        state.u = transcript.get_challenge();\\n\\n        return true;\\n    }\\n\\n    // This verifier is for a PLONK with a state width 4\\n    // and main gate equation\\n    // q_a(X) * a(X) +\\n    // q_b(X) * b(X) +\\n    // q_c(X) * c(X) +\\n    // q_d(X) * d(X) +\\n    // q_m(X) * a(X) * b(X) +\\n    // q_constants(X)+\\n    // q_d_next(X) * d(X*omega)\\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\\n    // q_d_next(X) \\\"peeks\\\" into the next row of the trace, so it takes\\n    // the same d(X) polynomial, but shifted\\n\\n    function verify_old(ProofOld memory proof, VerificationKeyOld memory vk) internal view returns (bool) {\\n        PartialVerifierStateOld memory state;\\n\\n        bool valid = verify_initial(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        valid = verify_commitments(state, proof, vk);\\n\\n        return valid;\\n    }\\n}\\n\\ncontract VerifierWithDeserializeOld is Plonk4VerifierWithAccessToDNextOld {\\n    uint256 constant SERIALIZED_PROOF_LENGTH_OLD = 33;\\n\\n    function deserialize_proof_old(uint256[] memory public_inputs, uint256[] memory serialized_proof)\\n        internal\\n        pure\\n        returns (ProofOld memory proof)\\n    {\\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH_OLD);\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i++) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n\\n            j += 2;\\n        }\\n\\n        proof.grand_product_commitment = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n        j += 2;\\n\\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j + 1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        proof.grand_product_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j += 1;\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j += 1;\\n        }\\n\\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n        j += 2;\\n\\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"upgradeParameters\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_recursiveInput\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_vkIndexes\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_individualVksInputs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[16]\",\"name\":\"_subproofsLimbs\",\"type\":\"uint256[16]\"}],\"name\":\"verifyAggregatedBlockProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_rootHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_accountId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_nftCreatorAccountId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_nftCreatorAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_nftSerialId\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_nftContentHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"}],\"name\":\"verifyExitProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"public_inputs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"serialized_proof\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"domain_size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num_inputs\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct PairingsBn254.Fr\",\"name\":\"omega\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"struct PairingsBn254.G1Point[7]\",\"name\":\"gate_setup_commitments\",\"type\":\"tuple[7]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"struct PairingsBn254.G1Point[2]\",\"name\":\"gate_selector_commitments\",\"type\":\"tuple[2]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"struct PairingsBn254.G1Point[4]\",\"name\":\"copy_permutation_commitments\",\"type\":\"tuple[4]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct PairingsBn254.Fr[3]\",\"name\":\"copy_permutation_non_residues\",\"type\":\"tuple[3]\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"X\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"Y\",\"type\":\"uint256[2]\"}],\"internalType\":\"struct PairingsBn254.G2Point\",\"name\":\"g2_x\",\"type\":\"tuple\"}],\"internalType\":\"struct Plonk4VerifierWithAccessToDNext.VerificationKey\",\"name\":\"vk\",\"type\":\"tuple\"}],\"name\":\"verify_serialized_proof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"public_inputs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"serialized_proof\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"recursive_vks_root\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"max_valid_index\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"recursive_vks_indexes\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"individual_vks_inputs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[16]\",\"name\":\"subproofs_limbs\",\"type\":\"uint256[16]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"domain_size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num_inputs\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct PairingsBn254.Fr\",\"name\":\"omega\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"struct PairingsBn254.G1Point[7]\",\"name\":\"gate_setup_commitments\",\"type\":\"tuple[7]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"struct PairingsBn254.G1Point[2]\",\"name\":\"gate_selector_commitments\",\"type\":\"tuple[2]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"X\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Y\",\"type\":\"uint256\"}],\"internalType\":\"struct PairingsBn254.G1Point[4]\",\"name\":\"copy_permutation_commitments\",\"type\":\"tuple[4]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct PairingsBn254.Fr[3]\",\"name\":\"copy_permutation_non_residues\",\"type\":\"tuple[3]\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"X\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"Y\",\"type\":\"uint256[2]\"}],\"internalType\":\"struct PairingsBn254.G2Point\",\"name\":\"g2_x\",\"type\":\"tuple\"}],\"internalType\":\"struct Plonk4VerifierWithAccessToDNext.VerificationKey\",\"name\":\"vk\",\"type\":\"tuple\"}],\"name\":\"verify_serialized_proof_with_recursion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Verifier","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}