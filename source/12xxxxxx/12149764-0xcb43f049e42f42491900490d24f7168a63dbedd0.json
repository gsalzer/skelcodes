{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"},\"ERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./IERC1155.sol\\\";\\r\\nimport \\\"./IERC1155MetadataURI.sol\\\";\\r\\nimport \\\"./IERC1155Receiver.sol\\\";\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./ERC165.sol\\\";\\r\\nimport \\\"./safemath.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n *\\r\\n * @dev Implementation of the basic standard multi-token.\\r\\n * See https://eips.ethereum.org/EIPS/eip-1155\\r\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    // Mapping from token ID to account balances\\r\\n    mapping (uint256 =\\u003e mapping(address =\\u003e uint256)) private _balances;\\r\\n\\r\\n    // Mapping from account to operator approvals\\r\\n    mapping (address =\\u003e mapping(address =\\u003e bool)) private _operatorApprovals;\\r\\n\\r\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\r\\n    string private _uri;\\r\\n\\r\\n    /*\\r\\n     *     bytes4(keccak256(\\u0027balanceOf(address,uint256)\\u0027)) == 0x00fdd58e\\r\\n     *     bytes4(keccak256(\\u0027balanceOfBatch(address[],uint256[])\\u0027)) == 0x4e1273f4\\r\\n     *     bytes4(keccak256(\\u0027setApprovalForAll(address,bool)\\u0027)) == 0xa22cb465\\r\\n     *     bytes4(keccak256(\\u0027isApprovedForAll(address,address)\\u0027)) == 0xe985e9c5\\r\\n     *     bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256,uint256,bytes)\\u0027)) == 0xf242432a\\r\\n     *     bytes4(keccak256(\\u0027safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\u0027)) == 0x2eb2c2d6\\r\\n     *\\r\\n     *     =\\u003e 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\\r\\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\r\\n\\r\\n    /*\\r\\n     *     bytes4(keccak256(\\u0027uri(uint256)\\u0027)) == 0x0e89341c\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\\r\\n\\r\\n    /**\\r\\n     * @dev See {_setURI}.\\r\\n     */\\r\\n    constructor (string memory uri_) {\\r\\n        _setURI(uri_);\\r\\n\\r\\n        // register the supported interfaces to conform to ERC1155 via ERC165\\r\\n        _registerInterface(_INTERFACE_ID_ERC1155);\\r\\n\\r\\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\\r\\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155MetadataURI-uri}.\\r\\n     *\\r\\n     * This implementation returns the same URI for *all* token types. It relies\\r\\n     * on the token type ID substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\r\\n     *\\r\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\r\\n     * actual token type ID.\\r\\n     */\\r\\n    function uri(uint256) external view virtual override returns (string memory) {\\r\\n        return _uri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\r\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\r\\n        return _balances[id][account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-balanceOfBatch}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(\\r\\n        address[] memory accounts,\\r\\n        uint256[] memory ids\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\r\\n\\r\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c accounts.length; ++i) {\\r\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\r\\n        }\\r\\n\\r\\n        return batchBalances;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-setApprovalForAll}.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\r\\n\\r\\n        _operatorApprovals[_msgSender()][operator] = approved;\\r\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-isApprovedForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\r\\n        return _operatorApprovals[account][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    )\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n    {\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n        require(\\r\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\r\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\r\\n        );\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\r\\n\\r\\n        _balances[id][from] = _balances[id][from].sub(amount, \\\"ERC1155: insufficient balance for transfer\\\");\\r\\n        _balances[id][to] = _balances[id][to].add(amount);\\r\\n\\r\\n        emit TransferSingle(operator, from, to, id, amount);\\r\\n\\r\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    )\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n    {\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n        require(\\r\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\r\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\r\\n        );\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c ids.length; ++i) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n\\r\\n            _balances[id][from] = _balances[id][from].sub(\\r\\n                amount,\\r\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\r\\n            );\\r\\n            _balances[id][to] = _balances[id][to].add(amount);\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, from, to, ids, amounts);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\r\\n     * substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\r\\n     *\\r\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\r\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\r\\n     * clients with the token type ID.\\r\\n     *\\r\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\r\\n     * interpreted by clients as\\r\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\r\\n     * for token type ID 0x4cce0.\\r\\n     *\\r\\n     * See {uri}.\\r\\n     *\\r\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\r\\n     * this function emits no events.\\r\\n     */\\r\\n    function _setURI(string memory newuri) internal virtual {\\r\\n        _uri = newuri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\r\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\r\\n\\r\\n        _balances[id][account] = _balances[id][account].add(amount);\\r\\n        emit TransferSingle(operator, address(0), account, id, amount);\\r\\n\\r\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\r\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\r\\n\\r\\n        for (uint i = 0; i \\u003c ids.length; i++) {\\r\\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens of token type `id`.\\r\\n     */\\r\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\r\\n\\r\\n        _balances[id][account] = _balances[id][account].sub(\\r\\n            amount,\\r\\n            \\\"ERC1155: burn amount exceeds balance\\\"\\r\\n        );\\r\\n\\r\\n        emit TransferSingle(operator, account, address(0), id, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     */\\r\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\r\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\r\\n\\r\\n        for (uint i = 0; i \\u003c ids.length; i++) {\\r\\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\\r\\n                amounts[i],\\r\\n                \\\"ERC1155: burn amount exceeds balance\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any token transfer. This includes minting\\r\\n     * and burning, as well as batched variants.\\r\\n     *\\r\\n     * The same hook is called on both single and batched variants. For single\\r\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\r\\n     *\\r\\n     * Calling conditions (for each `id` and `amount` pair):\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     * of token type `id` will be  transferred to `to`.\\r\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\r\\n     * for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens of token type `id`\\r\\n     * will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     * - `ids` and `amounts` have the same, non-zero length.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    { }\\r\\n\\r\\n    function _doSafeTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    )\\r\\n        private\\r\\n    {\\r\\n        if (to.isContract()) {\\r\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\r\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _doSafeBatchTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    )\\r\\n        private\\r\\n    {\\r\\n        if (to.isContract()) {\\r\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\\r\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\r\\n        uint256[] memory array = new uint256[](1);\\r\\n        array[0] = element;\\r\\n\\r\\n        return array;\\r\\n    }\\r\\n}\\r\\n\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts may inherit from this and call {_registerInterface} to declare\\r\\n * their support of an interface.\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /*\\r\\n     * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\r\\n\\r\\n    /**\\r\\n     * @dev Mapping of interface ids to whether or not it\\u0027s supported.\\r\\n     */\\r\\n    mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\r\\n\\r\\n    constructor () {\\r\\n        // Derived contracts need only register support for their own interfaces,\\r\\n        // we register support for ERC165 itself here\\r\\n        _registerInterface(_INTERFACE_ID_ERC165);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     *\\r\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return _supportedInterfaces[interfaceId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Registers the contract as an implementer of the interface defined by\\r\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\r\\n     * registering its interface id is not required.\\r\\n     *\\r\\n     * See {IERC165-supportsInterface}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\r\\n     */\\r\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\r\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\r\\n        _supportedInterfaces[interfaceId] = true;\\r\\n    }\\r\\n}\\r\\n\"},\"IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155 is IERC165 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\r\\n     * `approved`.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\r\\n     *\\r\\n     * If an {URI} event was emitted for `id`, the standard\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\r\\n     * returned by {IERC1155MetadataURI-uri}.\\r\\n     */\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller\\u0027s tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the caller.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``\\u0027s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``\\u0027s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\r\\n}\\r\\n\"},\"IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./IERC1155.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\r\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155MetadataURI is IERC1155 {\\r\\n    /**\\r\\n     * @dev Returns the URI for token type `id`.\\r\\n     *\\r\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\r\\n     * clients with the actual token type ID.\\r\\n     */\\r\\n    function uri(uint256 id) external view returns (string memory);\\r\\n}\"},\"IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155Receiver is IERC165 {\\r\\n\\r\\n    /**\\r\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\r\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\r\\n        To accept the transfer, this must return\\r\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n        (i.e. 0xf23a6e61, or its own function selector).\\r\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\r\\n        @param from The address which previously owned the token\\r\\n        @param id The ID of the token being transferred\\r\\n        @param value The amount of tokens being transferred\\r\\n        @param data Additional data with no specified format\\r\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\r\\n    */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    )\\r\\n        external\\r\\n        returns(bytes4);\\r\\n\\r\\n    /**\\r\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\r\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\r\\n        been updated. To accept the transfer(s), this must return\\r\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n        (i.e. 0xbc197c81, or its own function selector).\\r\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\r\\n        @param from The address which previously owned the token\\r\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\r\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\r\\n        @param data Additional data with no specified format\\r\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\r\\n    */\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    )\\r\\n        external\\r\\n        returns(bytes4);\\r\\n}\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"},\"lynccrafter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n  /**\\r\\n   * LYNC Network\\r\\n   * https://lync.network\\r\\n   *\\r\\n   * Additional details for contract and wallet information:\\r\\n   * https://lync.network/tracking/\\r\\n   *\\r\\n   * The cryptocurrency network designed for passive token rewards for its community.\\r\\n   */\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./ERC1155.sol\\\";\\r\\n\\r\\ncontract LYNCCrafter is ERC1155 {\\r\\n\\r\\n    address public owner;\\r\\n    address public rewardContract;\\r\\n    uint256 public cardID = 1;\\r\\n    uint256 public cardCountETH = 9950;\\r\\n    uint256 public cardCountLYNC = 9975;\\r\\n\\r\\n    //Card statistics\\r\\n    struct CardStats {\\r\\n        string collectionName;\\r\\n        uint256 cardType;\\r\\n        uint256 boostAmount;\\r\\n        uint256 redeemInitial;\\r\\n        uint256 redeemLeft;\\r\\n        uint256 redeemInterval;\\r\\n        uint256 useLastTimeStamp;\\r\\n        uint256 tokenReward;\\r\\n        uint256 percentageReward;\\r\\n    }\\r\\n\\r\\n    //Events\\r\\n    event BulkCardCrafted(address indexed _to, uint256 cardID, uint256 _amountOfCards, uint256 _tokenReward, uint256 _percentageReward);\\r\\n    event CollectionCardCrafted(address indexed _to, uint256 cardID, uint256 _redeemInitial, uint256 _redeemInterval, uint256 _tokenReward, uint256 _percentageReward);\\r\\n    event BoosterCardCrafted(address indexed _to, uint256 cardID, uint256 _amountOfCards, uint256 _boostAmount);\\r\\n    event BulkBoosterCardIncreased(address indexed _to, uint256 _amountOfCards, uint256 _cardID);\\r\\n    event RewardCardCrafted(address indexed _to, uint256 _cardCounter);\\r\\n    event CardStatsUpdated(uint256 _cardID);\\r\\n    event BoosterCardApplied(uint256 _cardID, uint256 _newRedeemTotal);\\r\\n    event CardBurned(uint256 _cardID, uint256 _amount);\\r\\n    event CardBurnedByOwner(address indexed _cardholder, uint256 _cardID, uint256 _amount);\\r\\n    event RewardContractAddressUpdated(address indexed _previousRewardAddress, address indexed _newRewardAddress);\\r\\n    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\\r\\n    event OwnershipRenounced(address indexed _previousOwner, address indexed _newOwner);\\r\\n\\r\\n    //Mappings\\r\\n    mapping(uint256 =\\u003e CardStats) public cards;\\r\\n    mapping(string =\\u003e mapping(uint256 =\\u003e uint256)) public collections;\\r\\n\\r\\n    //Constructor\\r\\n    constructor(string memory _uri) ERC1155(_uri) {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    //Craft a destructable / bulk card\\r\\n    function craftBulkCard(address _to, uint256 _amountOfCards, uint256 _tokenReward, uint256 _percentageReward) public onlyOwner {\\r\\n\\r\\n        //Craft and add stats\\r\\n        _mint(_to, cardID, _amountOfCards, \\\"\\\");\\r\\n        cards[cardID].cardType = 1;\\r\\n        cards[cardID].tokenReward = _tokenReward;\\r\\n        cards[cardID].percentageReward = _percentageReward;\\r\\n        emit BulkCardCrafted(_to, cardID,  _amountOfCards, _tokenReward, _percentageReward);\\r\\n\\r\\n        //Update cardID\\r\\n        cardID += 1;\\r\\n    }\\r\\n\\r\\n    //Craft a collection card\\r\\n    function craftCollectionCard(address _to, string memory _collectionName, uint256 _amountOfCards, uint256 _redeemInitial, uint256 _redeemInterval, uint256 _tokenReward, uint256 _percentageReward) public onlyOwner {\\r\\n\\r\\n        //Make sure collection name is unique\\r\\n        require(collections[_collectionName][0] == 0, \\\"This collection name aready exists!\\\");\\r\\n\\r\\n        //Record the size of the collection\\r\\n        collections[_collectionName][0] = _amountOfCards;\\r\\n\\r\\n        //Loop to create multiple cards\\r\\n        for (uint256 i = 1; i \\u003c= _amountOfCards; i++) {\\r\\n\\r\\n            //Add this card into the collection\\r\\n            collections[_collectionName][i] = cardID;\\r\\n\\r\\n            //Mint the card and add stats to card\\r\\n            _mint(_to, cardID, 1, \\\"\\\");\\r\\n            cards[cardID].collectionName = _collectionName;\\r\\n            cards[cardID].cardType = 2;\\r\\n            cards[cardID].redeemInitial = _redeemInitial;\\r\\n            cards[cardID].redeemLeft = _redeemInitial;\\r\\n            cards[cardID].redeemInterval = _redeemInterval;\\r\\n            cards[cardID].tokenReward = _tokenReward;\\r\\n            cards[cardID].percentageReward = _percentageReward;\\r\\n            emit CollectionCardCrafted(_to, cardID, _redeemInitial, _redeemInterval, _tokenReward, _percentageReward);\\r\\n\\r\\n            //Update the cardID\\r\\n            cardID += 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Craft a booster card\\r\\n    function craftBoosterCard(address _to, uint256 _amountOfCards, uint256 _boostAmount) public onlyOwner {\\r\\n        _mint(_to, cardID, _amountOfCards, \\\"\\\");\\r\\n        cards[cardID].cardType = 3;\\r\\n        cards[cardID].boostAmount = _boostAmount;\\r\\n        emit BoosterCardCrafted(_to, cardID, _amountOfCards, _boostAmount);\\r\\n\\r\\n        //Update the cardID\\r\\n        cardID += 1;\\r\\n    }\\r\\n\\r\\n    //Increase a destructable / booster card quantity\\r\\n    function increaseBulkBoosterCard(address _to, uint256 _amountOfCards, uint256 _cardID) public onlyOwner {\\r\\n\\r\\n        //Check card type and cardID count\\r\\n        require(cards[_cardID].cardType != 2, \\\"Cannot increase a collection / unique card\\\");\\r\\n        require(_cardID \\u003e 0 \\u0026\\u0026 _cardID \\u003c cardID, \\\"Card ID has not been crafted yet\\\");\\r\\n\\r\\n        //Increase cards\\r\\n        _mint(_to, _cardID, _amountOfCards, \\\"\\\");\\r\\n        emit BulkBoosterCardIncreased(_to, _amountOfCards, _cardID);\\r\\n    }\\r\\n\\r\\n    //Craft a reward card\\r\\n    function craftRewardCard(address _to, uint256 _cardID, string memory _collectionName) public onlyRewardContract {\\r\\n\\r\\n        //Set counters\\r\\n        uint256 _cardCounter;\\r\\n\\r\\n        if(_cardID \\u003c 3) {\\r\\n            _cardCounter = cardCountETH;\\r\\n            cardCountETH += 1;\\r\\n        } else {\\r\\n            _cardCounter = cardCountLYNC;\\r\\n            cardCountLYNC += 1;\\r\\n        }\\r\\n\\r\\n        //Increase the size of the collection\\r\\n        collections[_collectionName][0] += 1;\\r\\n\\r\\n        //Crafter the card and add stats\\r\\n        _mint(_to, _cardCounter, 1, \\\"\\\");\\r\\n        cards[_cardCounter].collectionName = _collectionName;\\r\\n        cards[_cardCounter].cardType = 2;\\r\\n        cards[_cardCounter].redeemInitial = 6;\\r\\n        cards[_cardCounter].redeemLeft = 6;\\r\\n        cards[_cardCounter].redeemInterval = 28;\\r\\n        cards[_cardCounter].tokenReward = 400;\\r\\n        cards[_cardCounter].percentageReward = 4;\\r\\n        emit RewardCardCrafted(_to, _cardCounter);\\r\\n    }\\r\\n\\r\\n    //Update collection / unique card redeem count and timestamp\\r\\n    function updateCardStats(uint256 _cardID) public onlyRewardContract {\\r\\n        cards[_cardID].redeemLeft -= 1;\\r\\n        cards[_cardID].useLastTimeStamp = block.timestamp;\\r\\n        emit CardStatsUpdated(_cardID);\\r\\n    }\\r\\n\\r\\n    //Apply booster card to collection / unique card\\r\\n    function applyCardBooster(uint256 _cardID, uint256 _newRedeemTotal) public onlyRewardContract {\\r\\n        cards[_cardID].redeemLeft += _newRedeemTotal;\\r\\n        emit BoosterCardApplied(_cardID, _newRedeemTotal);\\r\\n    }\\r\\n\\r\\n    //Burn card\\r\\n    function burnCard(address _cardholder, uint256 _cardID, uint256 _amount) public onlyRewardContract {\\r\\n        _burn(_cardholder, _cardID, _amount);\\r\\n        emit CardBurned(_cardID, _amount);\\r\\n    }\\r\\n\\r\\n    //Owner burn card overide\\r\\n    function ownerBurnCard(address _cardholder, uint256 _cardID, uint256 _amount) public onlyOwner {\\r\\n        _burn(_cardholder, _cardID, _amount);\\r\\n        emit CardBurnedByOwner(_cardholder, _cardID, _amount);\\r\\n    }\\r\\n\\r\\n    //Update the reward contract address\\r\\n    function updateRewardContractAddress(address _newRewardContractAddress) public onlyOwner {\\r\\n        require(_newRewardContractAddress != address(0), \\\"New reward contract address cannot be a zero address\\\");\\r\\n        emit RewardContractAddressUpdated(rewardContract, _newRewardContractAddress);\\r\\n        rewardContract = _newRewardContractAddress;\\r\\n    }\\r\\n\\r\\n    //Transfer ownership to new owner\\r\\n    function transferOwnership(address _newOwner) public onlyOwner {\\r\\n        require(_newOwner != address(0), \\\"New owner cannot be a zero address\\\");\\r\\n        emit OwnershipTransferred(owner, _newOwner);\\r\\n        owner = _newOwner;\\r\\n    }\\r\\n\\r\\n    //Remove owner from the contract\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipRenounced(owner, address(0));\\r\\n        owner = address(0);\\r\\n    }\\r\\n\\r\\n    //Modifiers\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"Only the owner of the crafter contract can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRewardContract() {\\r\\n        require(rewardContract == msg.sender, \\\"Only the reward contract address can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"},\"lyncnftrewards.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n  /**\\r\\n   * LYNC Network\\r\\n   * https://lync.network\\r\\n   *\\r\\n   * Additional details for contract and wallet information:\\r\\n   * https://lync.network/tracking/\\r\\n   *\\r\\n   * The cryptocurrency network designed for passive token rewards for its community.\\r\\n   */\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./lynctoken.sol\\\";\\r\\nimport \\\"./lyncstakingv1.sol\\\";\\r\\nimport \\\"./lynccrafter.sol\\\";\\r\\n\\r\\ncontract LYNCNFTRewardsV1 {\\r\\n\\r\\n    //Enable SafeMath\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address payable public owner;\\r\\n    uint256 public oneDay = 86400;          // in seconds\\r\\n    uint256 public SCALAR = 1e18;           // multiplier\\r\\n\\r\\n    LYNCToken public tokenContract;\\r\\n    LYNCStakingV1 public stakingContract;\\r\\n    LYNCCrafter public crafterContract;\\r\\n\\r\\n    //Events\\r\\n    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\\r\\n    event OwnershipRenounced(address indexed _previousOwner, address indexed _newOwner);\\r\\n\\r\\n    //On deployment\\r\\n    constructor(LYNCToken _tokenContract, LYNCStakingV1 _stakingContract, LYNCCrafter _crafterContract) {\\r\\n        owner = msg.sender;\\r\\n        tokenContract = _tokenContract;\\r\\n        stakingContract = _stakingContract;\\r\\n        crafterContract = _crafterContract;\\r\\n    }\\r\\n\\r\\n    //MulDiv functions : source https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\\r\\n    function mulDiv(uint x, uint y, uint z) public pure returns (uint) {\\r\\n          (uint l, uint h) = fullMul (x, y);\\r\\n          assert (h \\u003c z);\\r\\n          uint mm = mulmod(x, y, z);\\r\\n          if (mm \\u003e l) h -= 1;\\r\\n          l -= mm;\\r\\n          uint pow2 = z \\u0026 -z;\\r\\n          z /= pow2;\\r\\n          l /= pow2;\\r\\n          l += h * ((-pow2) / pow2 + 1);\\r\\n          uint r = 1;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          return l * r;\\r\\n    }\\r\\n\\r\\n    //Required for MulDiv\\r\\n    function fullMul(uint x, uint y) private pure returns (uint l, uint h) {\\r\\n          uint mm = mulmod(x, y, uint (-1));\\r\\n          l = x * y;\\r\\n          h = mm - l;\\r\\n          if (mm \\u003c l) h -= 1;\\r\\n    }\\r\\n\\r\\n    //Redeem lotto cards\\r\\n    function redeemLotto(uint256 _cardID) public {\\r\\n\\r\\n        //Check ownership of card\\r\\n        require(crafterContract.balanceOf(msg.sender, _cardID) \\u003e 0, \\\"You do not own this card\\\");\\r\\n        //Make sure card is a lotto card\\r\\n        require(_cardID \\u003c 5, \\\"Card is not a lotto card\\\");\\r\\n\\r\\n        uint256 _cardAmount = 1;\\r\\n        string memory _collectionName;\\r\\n\\r\\n        if(_cardID \\u003c 3) {\\r\\n            _collectionName = \\\"Ethereum Lotto\\\";\\r\\n            if(_cardID == 1) {\\r\\n                _cardAmount = 10;\\r\\n                require(crafterContract.balanceOf(msg.sender, _cardID) \\u003e= _cardAmount, \\\"10 common cards required to craft\\\");\\r\\n            } else {\\r\\n                require(crafterContract.balanceOf(msg.sender, _cardID) \\u003e= _cardAmount, \\\"1 rare card required to craft\\\");\\r\\n            }\\r\\n        } else {\\r\\n            _collectionName = \\\"LYNC Token Lotto\\\";\\r\\n            if(_cardID ==  3) {\\r\\n                _cardAmount = 10;\\r\\n                require(crafterContract.balanceOf(msg.sender, _cardID) \\u003e= _cardAmount, \\\"10 common cards required to craft\\\");\\r\\n            } else {\\r\\n                require(crafterContract.balanceOf(msg.sender, _cardID) \\u003e= _cardAmount, \\\"1 rare card required to craft\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        //Craft reward card\\r\\n        crafterContract.craftRewardCard(msg.sender, _cardID, _collectionName);\\r\\n        //Burn card(s)\\r\\n        crafterContract.burnCard(msg.sender, _cardID, _cardAmount);\\r\\n    }\\r\\n\\r\\n    //Redeem reward card\\r\\n    function redeemReward(uint256 _cardID) public {\\r\\n\\r\\n        //Check ownership of card\\r\\n        require(crafterContract.balanceOf(msg.sender, _cardID) \\u003e 0, \\\"You do not own this card\\\");\\r\\n\\r\\n        //Grab card data\\r\\n        (,uint256 cardType,,,uint256 _redeemLeft,uint256 _redeemInterval,uint256 _redeemLastTimeStamp,uint256 _tokenReward,uint256 _percentageRedeem) = crafterContract.cards(_cardID);\\r\\n\\r\\n        //Check card last redeem timestamp against its interval\\r\\n        require(block.timestamp \\u003e (_redeemLastTimeStamp + _redeemInterval.mul(oneDay)), \\\"This card has already been redeemed this interval, wait until reset\\\");\\r\\n         //Make sure this is is not a booster card\\r\\n        require(cardType != 3, \\\"Booster cards do not have any rewards associated with them\\\");\\r\\n\\r\\n        //Update or burn card\\r\\n        if(cardType != 2) {\\r\\n            //Burn the card\\r\\n            crafterContract.burnCard(msg.sender, _cardID, 1);\\r\\n        } else {\\r\\n            require(_redeemLeft \\u003e 0, \\\"No redeems available on this card\\\");\\r\\n            crafterContract.updateCardStats(_cardID);\\r\\n        }\\r\\n\\r\\n        //Token redeem\\r\\n        if(_tokenReward \\u003e 0) {\\r\\n            //Send token reward\\r\\n            require(tokenContract.transfer(msg.sender, _tokenReward.mul(SCALAR)));\\r\\n        }\\r\\n\\r\\n        //Percentage redeem\\r\\n        if(_percentageRedeem \\u003e 0) {\\r\\n\\r\\n            //Get balance from staking contract\\r\\n            (uint256 _stakedTokens,,) = stakingContract.stakerInformation(msg.sender);\\r\\n            //Calculate percentage\\r\\n            uint256 _percentageReward = mulDiv(_stakedTokens, _percentageRedeem, 100);\\r\\n            //Send token reward\\r\\n            require(tokenContract.transfer(msg.sender, _percentageReward));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function redeemBoosterCard(uint256 _cardID, uint256 _cardToBoost) public {\\r\\n\\r\\n        //Check ownership of card\\r\\n        require(crafterContract.balanceOf(msg.sender, _cardID) \\u003e 0, \\\"You do not own this card\\\");\\r\\n\\r\\n        //Grab data from booster card\\r\\n        (,uint256 _cardType, uint256 boostAmount,,,,,,) = crafterContract.cards(_cardID);\\r\\n\\r\\n        //Make sure this is a booster card\\r\\n        require(_cardType == 3, \\\"This is not a booster card\\\");\\r\\n\\r\\n        //Grab data from card to boost\\r\\n        (,uint256 _cardTypeToBoost,,uint256 _intialRedeems,,,,,) = crafterContract.cards(_cardToBoost);\\r\\n\\r\\n        //Check card being boosted is not a destructable / bulk card or another booster card\\r\\n        require(_cardTypeToBoost == 2, \\\"Destructable and booster cards cannot be boosted\\\");\\r\\n\\r\\n        //Check card being boosted had initial redeems\\r\\n        require(_intialRedeems \\u003e 0, \\\"Collectable cards with no rewards cannot be boosted\\\");\\r\\n\\r\\n        //Boost and burn\\r\\n        crafterContract.applyCardBooster(_cardToBoost, boostAmount);\\r\\n        crafterContract.burnCard(msg.sender,_cardID,1);\\r\\n    }\\r\\n\\r\\n    //Transfer ownership to new owner\\r\\n    function transferOwnership(address payable _newOwner) public onlyOwner {\\r\\n        require(_newOwner != address(0), \\\"New owner cannot be a zero address\\\");\\r\\n        emit OwnershipTransferred(owner, _newOwner);\\r\\n        owner = _newOwner;\\r\\n    }\\r\\n\\r\\n    //Remove owner from the contract\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipRenounced(owner, address(0));\\r\\n        owner = address(0);\\r\\n    }\\r\\n\\r\\n    //Close the contract and transfer any balances to the owner\\r\\n    function closeContract() public payable onlyOwner {\\r\\n        require(tokenContract.transfer(owner, tokenContract.balanceOf(address(this))));\\r\\n        selfdestruct(owner);\\r\\n    }\\r\\n\\r\\n    //Modifiers\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"Only the owner of the rewards contract can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"},\"lyncstakingv1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n    /**\\r\\n     * LYNC Network\\r\\n     * https://lync.network\\r\\n     *\\r\\n     * Additional details for contract and wallet information:\\r\\n     * https://lync.network/tracking/\\r\\n     *\\r\\n     * The cryptocurrency network designed for passive token rewards for its community.\\r\\n     */\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./lynctoken.sol\\\";\\r\\n\\r\\ncontract LYNCStakingV1 {\\r\\n\\r\\n  //Enable SafeMath\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n    address public owner;\\r\\n    address public contractAddress;\\r\\n    uint256 public totalRewards = 0;\\r\\n    uint256 public totalRewardsClaimed = 0;\\r\\n    uint256 public totalStakedV1 = 0;\\r\\n    uint256 public oneDay = 86400;          // in seconds\\r\\n    uint256 public SCALAR = 1e18;           // multiplier\\r\\n    uint256 public minimumTokenStake = 98;  // takes into account transfer fee\\r\\n    uint256 public endOfStakeFee = 4;       // 4% including 1% tx fee = approx 5%\\r\\n\\r\\n    LYNCToken public tokenContract;\\r\\n\\r\\n    //Events\\r\\n\\tevent Stake(address _from, uint256 tokens);\\r\\n\\tevent Unstake(address _to, uint256 tokens);\\r\\n\\tevent UnstakeFee(address _to, uint256 tokens);\\r\\n\\tevent CollectRewards(address _to, uint256 tokens);\\r\\n\\r\\n\\t//User data\\r\\n\\tstruct Staker {\\r\\n\\t\\tuint256 staked;\\r\\n\\t\\tuint256 poolAtLastClaim;\\r\\n\\t\\tuint256 userTimeStamp;\\r\\n\\t}\\r\\n\\r\\n    //Mappings\\r\\n    mapping(address =\\u003e Staker) stakers;\\r\\n\\r\\n    //On deployment\\r\\n    constructor(LYNCToken _tokenContract) {\\r\\n        owner = msg.sender;\\r\\n        tokenContract = _tokenContract;\\r\\n        contractAddress = address(this);\\r\\n    }\\r\\n\\r\\n    //MulDiv functions : source https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\\r\\n    function mulDiv(uint x, uint y, uint z) public pure returns (uint) {\\r\\n          (uint l, uint h) = fullMul (x, y);\\r\\n          assert (h \\u003c z);\\r\\n          uint mm = mulmod(x, y, z);\\r\\n          if (mm \\u003e l) h -= 1;\\r\\n          l -= mm;\\r\\n          uint pow2 = z \\u0026 -z;\\r\\n          z /= pow2;\\r\\n          l /= pow2;\\r\\n          l += h * ((-pow2) / pow2 + 1);\\r\\n          uint r = 1;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          r *= 2 - z * r;\\r\\n          return l * r;\\r\\n    }\\r\\n\\r\\n    //Required for MulDiv\\r\\n    function fullMul(uint x, uint y) private pure returns (uint l, uint h) {\\r\\n          uint mm = mulmod(x, y, uint (-1));\\r\\n          l = x * y;\\r\\n          h = mm - l;\\r\\n          if (mm \\u003c l) h -= 1;\\r\\n    }\\r\\n\\r\\n    //Return current reward pool unclaimed\\r\\n    function rewardPoolBalance() public view returns(uint256) {\\r\\n        return tokenContract.balanceOf(address(this)).sub(totalStakedV1);\\r\\n    }\\r\\n\\r\\n    //Return staker information\\r\\n    function stakerInformation(address _stakerAddress) public view returns(uint256, uint256, uint256) {\\r\\n        return (stakers[_stakerAddress].staked, stakers[_stakerAddress].poolAtLastClaim, stakers[_stakerAddress].userTimeStamp);\\r\\n    }\\r\\n\\r\\n    //Stake tokens\\r\\n    function stakeTokens(uint256 _numberOfTokens) external returns (bool) {\\r\\n\\r\\n        //Check if user is already staking\\r\\n        if(stakers[msg.sender].staked == 0) {\\r\\n\\r\\n            //Require minimum stake\\r\\n            require(_numberOfTokens \\u003e (minimumTokenStake * SCALAR), \\\"Not enough tokens to start staking\\\");\\r\\n\\r\\n            //Transfer tokens and update data\\r\\n            require(tokenContract.transferFrom(msg.sender, address(this), _numberOfTokens));\\r\\n            stakers[msg.sender].poolAtLastClaim = totalRewards;\\r\\n            stakers[msg.sender].userTimeStamp = block.timestamp;\\r\\n        } else {\\r\\n\\r\\n            //Transfer tokens\\r\\n            require(tokenContract.transferFrom(msg.sender, address(this), _numberOfTokens));\\r\\n        }\\r\\n\\r\\n        //Update staking totals\\r\\n        uint256 _feeAmount = (_numberOfTokens.mul(tokenContract.feePercent())).div(100);\\r\\n        uint256 _stakedAfterFee = _numberOfTokens.sub(_feeAmount);\\r\\n\\r\\n        //Update data\\r\\n        stakers[msg.sender].staked = (stakers[msg.sender].staked).add(_stakedAfterFee);\\r\\n        totalStakedV1 = totalStakedV1.add(_stakedAfterFee);\\r\\n        totalRewards = rewardPoolBalance().add(totalRewardsClaimed);\\r\\n\\r\\n        emit Stake(msg.sender, _numberOfTokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //Unstake tokens\\r\\n    function unstakeTokens() external returns (bool) {\\r\\n\\r\\n        //Minus 4% fee for unstaking\\r\\n        uint256 _stakedTokens = stakers[msg.sender].staked;\\r\\n        uint256 _feeAmount = (_stakedTokens.mul(endOfStakeFee)).div(100);\\r\\n        uint256 _unstakeTokens = (stakers[msg.sender].staked).sub(_feeAmount);\\r\\n\\r\\n        //Send stakers tokens and remove from total staked\\r\\n        require(tokenContract.transfer(msg.sender, _unstakeTokens));\\r\\n        totalStakedV1 = totalStakedV1.sub(_stakedTokens);\\r\\n\\r\\n        //Update data\\r\\n        stakers[msg.sender].staked = 0;\\r\\n        stakers[msg.sender].poolAtLastClaim = 0;\\r\\n        stakers[msg.sender].userTimeStamp = 0;\\r\\n        totalRewards = rewardPoolBalance().add(totalRewardsClaimed);\\r\\n\\r\\n        emit Unstake(msg.sender, _unstakeTokens);\\r\\n        emit UnstakeFee(msg.sender, _feeAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //Claim current token rewards\\r\\n    function claimRewards() external returns (bool) {\\r\\n\\r\\n        totalRewards = rewardPoolBalance().add(totalRewardsClaimed);\\r\\n        require(stakers[msg.sender].staked \\u003e 0, \\\"You do not have any tokens staked\\\");\\r\\n        require(block.timestamp \\u003e (stakers[msg.sender].userTimeStamp + oneDay), \\\"You can only claim 24 hours after staking and once every 24 hours\\\");\\r\\n\\r\\n        //Calculated user share of reward pool since last claim\\r\\n        uint256 _poolSinceLastClaim = totalRewards.sub(stakers[msg.sender].poolAtLastClaim);\\r\\n        uint256 _rewardPercent = mulDiv(stakers[msg.sender].staked, 10000, totalStakedV1);\\r\\n        uint256 _rewardToClaim = mulDiv(_poolSinceLastClaim, _rewardPercent, 10000);\\r\\n\\r\\n        //Send tokens\\r\\n        require(tokenContract.transfer(msg.sender, _rewardToClaim));\\r\\n\\r\\n        //Update data\\r\\n        stakers[msg.sender].poolAtLastClaim = totalRewards;\\r\\n        stakers[msg.sender].userTimeStamp = block.timestamp;\\r\\n        totalRewardsClaimed = totalRewardsClaimed.add(_rewardToClaim);\\r\\n        totalRewards = rewardPoolBalance().add(totalRewardsClaimed);\\r\\n\\r\\n        emit CollectRewards(msg.sender, _rewardToClaim);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //Update the minimum tokens to start staking\\r\\n    function updateStakeMinimum(uint256 _minimumTokenStake) public onlyOwner {\\r\\n        minimumTokenStake = _minimumTokenStake;\\r\\n    }\\r\\n\\r\\n    //Modifiers\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"Only current owner can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"},\"lynctoken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n    /**\\r\\n     * LYNC Network\\r\\n     * https://lync.network\\r\\n     *\\r\\n     * Additional details for contract and wallet information:\\r\\n     * https://lync.network/tracking/\\r\\n     *\\r\\n     * The cryptocurrency network designed for passive token rewards for its community.\\r\\n     */\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./safemath.sol\\\";\\r\\n\\r\\ncontract LYNCToken {\\r\\n\\r\\n    //Enable SafeMath\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    //Token details\\r\\n    string constant public name = \\\"LYNC Network\\\";\\r\\n    string constant public symbol = \\\"LYNC\\\";\\r\\n    uint8 constant public decimals = 18;\\r\\n\\r\\n    //Reward pool and owner address\\r\\n    address public owner;\\r\\n    address public rewardPoolAddress;\\r\\n\\r\\n    //Supply and tranasction fee\\r\\n    uint256 public maxTokenSupply = 1e24;   // 1,000,000 tokens\\r\\n    uint256 public feePercent = 1;          // initial transaction fee percentage\\r\\n    uint256 public feePercentMax = 10;      // maximum transaction fee percentage\\r\\n\\r\\n    //Events\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokens);\\r\\n    event Approval(address indexed _owner,address indexed _spender, uint256 _tokens);\\r\\n    event TranserFee(uint256 _tokens);\\r\\n    event UpdateFee(uint256 _fee);\\r\\n    event RewardPoolUpdated(address indexed _rewardPoolAddress, address indexed _newRewardPoolAddress);\\r\\n    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\\r\\n    event OwnershipRenounced(address indexed _previousOwner, address indexed _newOwner);\\r\\n\\r\\n    //Mappings\\r\\n    mapping(address =\\u003e uint256) public balanceOf;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowances;\\r\\n\\r\\n    //On deployment\\r\\n    constructor () {\\r\\n        owner = msg.sender;\\r\\n        rewardPoolAddress = address(this);\\r\\n        balanceOf[msg.sender] = maxTokenSupply;\\r\\n        emit Transfer(address(0), msg.sender, maxTokenSupply);\\r\\n    }\\r\\n\\r\\n    //ERC20 totalSupply\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return maxTokenSupply;\\r\\n    }\\r\\n\\r\\n    //ERC20 transfer\\r\\n    function transfer(address _to, uint256 _tokens) public returns (bool) {\\r\\n        transferWithFee(msg.sender, _to, _tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //ERC20 transferFrom\\r\\n    function transferFrom(address _from, address _to, uint256 _tokens) public returns (bool) {\\r\\n        require(_tokens \\u003c= balanceOf[_from], \\\"Not enough tokens in the approved address balance\\\");\\r\\n        require(_tokens \\u003c= allowances[_from][msg.sender], \\\"token amount is larger than the current allowance\\\");\\r\\n        transferWithFee(_from, _to, _tokens);\\r\\n        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //ERC20 approve\\r\\n    function approve(address _spender, uint256 _tokens) public returns (bool) {\\r\\n        allowances[msg.sender][_spender] = _tokens;\\r\\n        emit Approval(msg.sender, _spender, _tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //ERC20 allowance\\r\\n    function allowance(address _owner, address _spender) public view returns (uint256) {\\r\\n        return allowances[_owner][_spender];\\r\\n    }\\r\\n\\r\\n    //Transfer with transaction fee applied\\r\\n    function transferWithFee(address _from, address _to, uint256 _tokens) internal returns (bool) {\\r\\n        require(balanceOf[_from] \\u003e= _tokens, \\\"Not enough tokens in the senders balance\\\");\\r\\n        uint256 _feeAmount = (_tokens.mul(feePercent)).div(100);\\r\\n        balanceOf[_from] = balanceOf[_from].sub(_tokens);\\r\\n        balanceOf[_to] = balanceOf[_to].add(_tokens.sub(_feeAmount));\\r\\n        balanceOf[rewardPoolAddress] = balanceOf[rewardPoolAddress].add(_feeAmount);\\r\\n        emit Transfer(_from, _to, _tokens.sub(_feeAmount));\\r\\n        emit Transfer(_from, rewardPoolAddress, _feeAmount);\\r\\n        emit TranserFee(_tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //Update transaction fee percentage\\r\\n    function updateFee(uint256 _updateFee) public onlyOwner {\\r\\n        require(_updateFee \\u003c= feePercentMax, \\\"Transaction fee cannot be greater than 10%\\\");\\r\\n        feePercent = _updateFee;\\r\\n        emit UpdateFee(_updateFee);\\r\\n    }\\r\\n\\r\\n    //Update the reward pool address\\r\\n    function updateRewardPool(address _newRewardPoolAddress) public onlyOwner {\\r\\n        require(_newRewardPoolAddress != address(0), \\\"New reward pool address cannot be a zero address\\\");\\r\\n        rewardPoolAddress = _newRewardPoolAddress;\\r\\n        emit RewardPoolUpdated(rewardPoolAddress, _newRewardPoolAddress);\\r\\n    }\\r\\n\\r\\n    //Transfer current token balance to the reward pool address\\r\\n    function rewardPoolBalanceTransfer() public onlyOwner returns (bool) {\\r\\n        uint256 _currentBalance = balanceOf[address(this)];\\r\\n        transferWithFee(address(this), rewardPoolAddress, _currentBalance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //Transfer ownership to new owner\\r\\n    function transferOwnership(address _newOwner) public onlyOwner {\\r\\n        require(_newOwner != address(0), \\\"New owner cannot be a zero address\\\");\\r\\n        emit OwnershipTransferred(owner, _newOwner);\\r\\n        owner = _newOwner;\\r\\n    }\\r\\n\\r\\n    //Remove owner from the contract\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipRenounced(owner, address(0));\\r\\n        owner = address(0);\\r\\n    }\\r\\n\\r\\n    //Modifiers\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"Only current owner can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"},\"safemath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract LYNCToken\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"contract LYNCStakingV1\",\"name\":\"_stakingContract\",\"type\":\"address\"},{\"internalType\":\"contract LYNCCrafter\",\"name\":\"_crafterContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SCALAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crafterContract\",\"outputs\":[{\"internalType\":\"contract LYNCCrafter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cardID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cardToBoost\",\"type\":\"uint256\"}],\"name\":\"redeemBoosterCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cardID\",\"type\":\"uint256\"}],\"name\":\"redeemLotto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cardID\",\"type\":\"uint256\"}],\"name\":\"redeemReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingContract\",\"outputs\":[{\"internalType\":\"contract LYNCStakingV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract LYNCToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LYNCNFTRewardsV1","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008f87ec6aad3b2a8c44f1298a1af56169b8e574cf0000000000000000000000005659668b6323ec0360fbda5624b8247d443d3dd9000000000000000000000000778aef7198cc1aa931ce0911c8bec9250e2732a4","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://493657b3e13a63b196f8284f4c3a67b5569c0bfb7f62a9a6e7ff48f30f7b8345"}]}