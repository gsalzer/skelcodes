{"status":"1","message":"OK","result":[{"SourceCode":"{\"Crowdsale.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./KaikenInuToken.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\nimport \\\"./PullPayment.sol\\\";\\nimport \\\"./Whitelist.sol\\\";\\nimport \\\"./TokenBonus.sol\\\";\\n\\ncontract Crowdsale is Pausable, PullPayment, Whitelist, TokenBonus {\\n    using SafeMath for uint256;\\n\\n    address private wallet = 0x47C8bbEAD537e7d013034B3d83AF6f0ee84e14a2;\\n    address private team = 0x092406Df82C3631bC0F0D77937379c3CbaABcA8F;\\n\\n    KaikenInuToken public token;\\n\\n    // Presale period\\n    uint256 public presaleRate;                                         \\n    uint256 public totalTokensForPresale;                                \\n    bool public ICO;                                                \\n    bool public presale;                                                \\n\\n    uint256 public rate;                                                 \\n    uint256 public totalTokensForSale = 20000000000000000000000000000000000000;      // 200 000 000 000 000 KaikenInu tokens will be sold\\n    uint256 public totalTokensForPreSale = 20000000000000000000000000000000000000;      // 200 000 000 000 000 KaikenInu tokens will be sold\\n    uint256 public  maxFundingGoal;                                      \\n    uint256 public  minFundingGoal;                                      \\n    bool public crowdsale;                                          \\n\\n    uint256 public  REFUNDSTART;                                        \\n    uint256 public  REFUNDEADLINE;                                      \\n    uint256 public savedBalance;                                        \\n    uint256 public savedTokenBalance;                                   \\n    uint256 public savedPresaleTokenBalance;                            \\n    mapping (address =\\u003e uint256) balances;                              \\n\\n    event Contribution(address indexed _contributor, uint256 indexed _value, uint256 indexed _tokens);    \\n    event PayEther(address indexed _receiver, uint256 indexed _value, uint256 indexed _timestamp);         \\n    event BurnTokens(uint256 indexed _value, uint256 indexed _timestamp);                                 \\n\\n    constructor(address _token) public {\\n        token = KaikenInuToken(_token);\\n    }\\n\\n    function () public payable whenNotPaused {\\n        uint256 _tokensAmount;\\n        if (msg.sender != wallet) {\\n          require(ICO || presale || crowdsale);\\n          if (ICO || presale) {\\n              buyPresaleTokens(msg.sender,_tokensAmount);\\n          }else{\\n              buyTokens(msg.sender);\\n          }\\n        }\\n    }\\n\\n    // Function to set Rate \\u0026 tokens to sell for ICO\\n    function startPresale(uint256 _rate, uint256 _totalTokensForPresale, uint256 _maxCap, uint256 _minCap) public onlyOwner {\\n        presaleRate = _rate;\\n        totalTokensForPresale = _totalTokensForPresale;\\n        maxFundingGoal = _maxCap;\\n        minFundingGoal = _minCap;\\n        ICO = true;\\n    }\\n\\n    // Function to move to the second period for presale\\n    function updatePresale() public onlyOwner {\\n        require(ICO);\\n        ICO = false;\\n        presale = true;\\n    }\\n\\n    // Function to close the presale\\n    function closePresale() public onlyOwner {\\n        require(presale || ICO);\\n        ICO = false;\\n        presale = false;\\n    }\\n\\n    function startCrowdsale(uint256 _rate, uint256 _maxCap, uint256 _minCap) public onlyOwner {\\n        require(!presale || !ICO);\\n        rate = _rate;\\n        maxFundingGoal = _maxCap;\\n        minFundingGoal = _minCap;\\n        crowdsale = true;\\n    }\\n\\n    function closeCrowdsale() public onlyOwner{\\n      require(crowdsale);\\n\\t    crowdsale = false;\\n        REFUNDSTART = now;\\n\\t    REFUNDEADLINE = REFUNDSTART + 30 days;\\n    }\\n\\n    function isComplete() public view returns (bool) {\\n        return (savedBalance \\u003e= maxFundingGoal) || (savedTokenBalance \\u003e= totalTokensForSale) || (crowdsale == false);\\n    }\\n\\n    function isSuccessful() public view returns (bool) {\\n        return (savedBalance \\u003e= minFundingGoal);\\n    }\\n\\n    function refundPeriodOver() public view returns (bool) {\\n        return (now \\u003e REFUNDEADLINE);\\n    }\\n\\n    function refundPeriodStart() public view returns (bool) {\\n        return (now \\u003e REFUNDSTART);\\n    }\\n\\n    function finalize() public onlyOwner {\\n        require(crowdsale);\\n        crowdsale = false;\\n        REFUNDSTART = now;\\n        REFUNDEADLINE = REFUNDSTART+ 30 days;\\n    }\\n\\n    function payout(address _newOwner) public onlyOwner {\\n        require((isSuccessful() \\u0026\\u0026 isComplete()) || refundPeriodOver());\\n        if (isSuccessful() \\u0026\\u0026 isComplete()) {\\n            uint256 tokensToBurn =  token.balanceOf(address(this)).sub(savedBonusToken);\\n            require(token.burn(tokensToBurn));\\n            transferTokenOwnership(_newOwner);\\n            crowdsale = false;\\n        }else {\\n            if (refundPeriodOver()) {\\n                wallet.transfer(address(this).balance);\\n                emit PayEther(wallet, address(this).balance, now);\\n                require(token.burn(token.balanceOf(address(this))));\\n                transferTokenOwnership(_newOwner);\\n            }\\n        }\\n    }\\n\\n    // Function to transferOwnership of the KaikenInu token\\n    function transferTokenOwnership(address _newOwner) public onlyOwner {\\n        token.transferOwnership(_newOwner);\\n    }\\n    \\n    /* When MIN_CAP is not reach the smart contract will be credited to make refund possible by backers\\n     * 1) backer call the \\\"refund\\\" function of the Crowdsale contract\\n     * 2) backer call the \\\"withdraw\\\" function of the Crowdsale contract to get a refund in ETH\\n     */\\n    function refund() public {\\n        require(!isSuccessful());\\n        require(refundPeriodStart());\\n        require(!refundPeriodOver());\\n        require(balances[msg.sender] \\u003e 0);\\n        uint256 amountToRefund = balances[msg.sender].mul(95).div(100);\\n        asyncSend(msg.sender, amountToRefund);\\n        balances[msg.sender] = 0;\\n    }\\n\\n    function withdraw() public {\\n        withdrawPayments();\\n        savedBalance = address(this).balance;\\n    }\\n\\n    function buyTokens(address buyer) public payable {\\n        // require(!isComplete());\\n        address _beneficiary;\\n        if (isWhitelisted(_beneficiary)) {\\n            uint256 tokensAmount;\\n            if (msg.value \\u003e= 10 ether) {\\n                savedBalance = savedBalance.add(msg.value);\\n                tokensAmount = msg.value.mul(presaleRate);\\n                uint256 bonus = tokensAmount.mul(30).div(100);\\n                savedTokenBalance = savedTokenBalance.add(tokensAmount.add(bonus));\\n                token.transfer(_beneficiary, tokensAmount);\\n                savedBonusToken = savedBonusToken.add(bonus);\\n                bonusBalances[_beneficiary] = bonusBalances[_beneficiary].add(bonus);\\n                bonusList.push(_beneficiary);\\n                wallet.transfer(msg.value);\\n                emit PayEther(wallet, msg.value, now);\\n            }else {\\n                savedBalance = savedBalance.add(msg.value);\\n                tokensAmount = msg.value.mul(presaleRate);\\n                uint256 tokensToTransfer = tokensAmount.mul(130).div(100);\\n                savedTokenBalance = savedTokenBalance.add(tokensToTransfer);\\n                token.transfer(_beneficiary, tokensToTransfer);\\n                wallet.transfer(msg.value);\\n                emit PayEther(wallet, msg.value, now);\\n            }\\n        }else {\\n            balances[buyer] = balances[buyer].add(msg.value);\\n            savedBalance = savedBalance.add(msg.value);\\n            savedTokenBalance = savedTokenBalance.add(msg.value.mul(rate));\\n            token.transfer(_beneficiary, msg.value.mul(rate));\\n            wallet.transfer(msg.value);\\n            emit PayEther(wallet, msg.value, now);\\n        }\\n    }\\n\\n    function buyPresaleTokens(address buyer, uint256 _tokensAmount) public payable {\\n        // require(isPresaleWhitelisted(_beneficiary));\\n        require((savedBalance.add(msg.value)) \\u003c= maxFundingGoal);\\n        require((savedPresaleTokenBalance.add(msg.value.mul(presaleRate))) \\u003c= totalTokensForPresale);\\n        uint256 tokensAmount = _tokensAmount;\\n\\n        if (msg.value \\u003e= 10 ether) {\\n            savedBalance = savedBalance.add(msg.value);\\n            tokensAmount = msg.value.mul(presaleRate);\\n            uint256 bonus = tokensAmount.mul(checkPresaleBonus()).div(100);\\n            savedTokenBalance = savedTokenBalance.add(tokensAmount.add(bonus));\\n            token.transfer(buyer, tokensAmount);\\n            savedBonusToken = savedBonusToken.add(bonus);\\n            bonusBalances[buyer] = bonusBalances[buyer].add(bonus);\\n            bonusList.push(buyer);\\n            wallet.transfer(msg.value);\\n            emit PayEther(wallet, msg.value, now);\\n        }else {\\n            savedBalance = savedBalance.add(msg.value);\\n            tokensAmount = msg.value.mul(presaleRate);\\n            uint256 tokensToTransfer = tokensAmount.add((tokensAmount.mul(checkPresaleBonus())).div(100));\\n            savedTokenBalance = savedTokenBalance.add(tokensToTransfer);\\n            token.transfer(buyer, tokensToTransfer);\\n            wallet.transfer(msg.value);\\n            emit PayEther(wallet, msg.value, now);\\n        }\\n    }\\n\\n    function checkPresaleBonus() internal view returns (uint256){\\n        if(ICO \\u0026\\u0026 msg.value \\u003e= 1 ether){\\n          return 40000;\\n        }else if(presale \\u0026\\u0026 msg.value \\u003e= 1 ether){\\n          return 30000;\\n        }else{\\n          return 0;\\n        }\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\ncontract ERC20 {\\n  function totalSupply() public view returns (uint256);\\n\\n  function balanceOf(address _who) public view returns (uint256);\\n\\n  function allowance(address _owner, address _spender)\\n    public view returns (uint256);\\n\\n  function transfer(address _to, uint256 _value) public returns (bool);\\n\\n  function approve(address _spender, uint256 _value)\\n    public returns (bool);\\n\\n  function transferFrom(address _from, address _to, uint256 _value)\\n    public returns (bool);\\n\\n  function burn(uint256 _value)\\n    public returns (bool);\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n\\n  event Burn(\\n    address indexed burner,\\n    uint256 value\\n  );\\n\\n}\\n\"},\"KaikenInuToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract KaikenInuToken is ERC20, Ownable {\\n  using SafeMath for uint256;\\n\\n    string public constant name = \\\"KaikenInu\\\";\\n    string public constant symbol = \\\"KaikenInu\\\";\\n    uint8 public constant decimals = 9;\\n    uint256 private totalSupply_ = 1000000000 * 10**6 * 10**9;\\n    uint256 public _taxFee = 2;\\n    uint256 private _previousTaxFee = _taxFee;\\n    uint256 public _liquidityFee = 1;\\n    uint256 private _previousLiquidityFee = _liquidityFee;\\n    uint256 public _burnFee = 1;\\n    uint256 private _previousBurnFee = _burnFee;\\n    uint256 public _marketingFee = 1;\\n    \\n    bool public locked = true;\\n    mapping (address =\\u003e uint256) private balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private allowed;\\n\\n  modifier onlyWhenUnlocked() {\\n    require(!locked || msg.sender == owner);\\n    _;\\n  }\\n\\n  constructor() public {\\n      balances[msg.sender] = totalSupply_;\\n  }\\n\\n  function totalSupply() public view returns (uint256) {\\n    return totalSupply_;\\n  }\\n\\n  function balanceOf(address _owner) public view returns (uint256) {\\n    return balances[_owner];\\n  }\\n\\n  function allowance(\\n    address _owner,\\n    address _spender\\n   )\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  function transfer(address _to, uint256 _value) public onlyWhenUnlocked returns (bool) {\\n    require(_value \\u003c= balances[msg.sender]);\\n    require(_to != address(0));\\n\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    emit Transfer(msg.sender, _to, _value);\\n    return true;\\n  }\\n\\n  function approve(address _spender, uint256 _value) public returns (bool) {\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  )\\n    public\\n    onlyWhenUnlocked\\n    returns (bool)\\n  {\\n    require(_value \\u003c= balances[_from]);\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n    require(_to != address(0));\\n\\n    balances[_from] = balances[_from].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n    emit Transfer(_from, _to, _value);\\n    return true;\\n  }\\n\\n  function increaseApproval(\\n    address _spender,\\n    uint256 _addedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    allowed[msg.sender][_spender] = (\\n      allowed[msg.sender][_spender].add(_addedValue));\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n  function decreaseApproval(\\n    address _spender,\\n    uint256 _subtractedValue\\n  )\\n    public\\n    returns (bool)\\n  {\\n    uint256 oldValue = allowed[msg.sender][_spender];\\n    if (_subtractedValue \\u003e= oldValue) {\\n      allowed[msg.sender][_spender] = 0;\\n    } else {\\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n    }\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n  function burn(uint256 _value) public returns (bool success){\\n    require(_value \\u003e 0);\\n    require(_value \\u003c= balances[msg.sender]);\\n    address burner = msg.sender;\\n    balances[burner] = balances[burner].sub(_value);\\n    totalSupply_ = totalSupply_.sub(_value);\\n    emit Burn(burner, _value);\\n    return true;\\n  }\\n\\n  function unlock() public onlyOwner {\\n    locked = false;\\n  }\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   * @notice Renouncing to ownership will leave the contract without an owner.\\n   * It will not be possible to call the functions with the `onlyOwner`\\n   * modifier anymore.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipRenounced(owner);\\n    owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address _newOwner) public onlyOwner {\\n    _transferOwnership(_newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address _newOwner) internal {\\n    require(_newOwner != address(0));\\n    emit OwnershipTransferred(owner, _newOwner);\\n    owner = _newOwner;\\n  }\\n}\\n\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract Pausable is Ownable {\\n  event Pause();\\n  event Unpause();\\n\\n  bool public paused = false;\\n\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() public onlyOwner whenNotPaused {\\n    paused = true;\\n    emit Pause();\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpause, returns to normal state\\n   */\\n  function unpause() public onlyOwner whenPaused {\\n    paused = false;\\n    emit Unpause();\\n  }\\n}\\n\"},\"PullPayment.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ncontract PullPayment {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) public payments;\\n\\n    uint256 public totalPayments;\\n\\n    /**\\n    * @dev withdraw accumulated balance, called by payee.\\n    */\\n    function withdrawPayments() internal {\\n        uint256 payment = payments[msg.sender];\\n\\n        require(payment != 0);\\n        require(address(this).balance \\u003e= payment);\\n\\n        totalPayments = totalPayments.sub(payment);\\n        payments[msg.sender] = 0;\\n\\n        msg.sender.transfer(payment);\\n    }\\n    /**\\n    * @dev Called by the payer to store the sent amount as credit to be pulled.\\n    * @param dest The destination address of the funds.\\n    * @param amount The amount to transfer.\\n    */\\n    function asyncSend(address dest, uint256 amount) internal {\\n        payments[dest] = payments[dest].add(amount);\\n        totalPayments = totalPayments.add(amount);\\n    }\\n\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (_a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = _a * _b;\\n    require(c / _a == _b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    require(_b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = _a / _b;\\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    require(_b \\u003c= _a);\\n    uint256 c = _a - _b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    uint256 c = _a + _b;\\n    require(c \\u003e= _a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\"},\"TokenBonus.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./KaikenInuToken.sol\\\";\\n\\n\\ncontract TokenBonus is Ownable {\\n    using SafeMath for uint256;\\n\\n    address public owner;\\n    mapping (address =\\u003e uint256) public bonusBalances;   // visible to the public or not ???\\n    address[] public bonusList;\\n    uint256 public savedBonusToken;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    function distributeBonusToken(address _token, uint256 _percent) public onlyOwner {\\n        for (uint256 i = 0; i \\u003c bonusList.length; i++) {\\n            require(KaikenInuToken(_token).balanceOf(address(this)) \\u003e= savedBonusToken);\\n\\n            uint256 amountToTransfer = bonusBalances[bonusList[i]].mul(_percent).div(100);\\n            KaikenInuToken(_token).transfer(bonusList[i], amountToTransfer);\\n            bonusBalances[bonusList[i]] = bonusBalances[bonusList[i]].sub(amountToTransfer);\\n            savedBonusToken = savedBonusToken.sub(amountToTransfer);\\n        }\\n    }\\n}\\n\"},\"Whitelist.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract Whitelist is Ownable{\\n\\n  // Whitelisted address\\n  mapping(address =\\u003e bool) public whitelist;\\n  mapping(address =\\u003e bool) public presalewhitelist;\\n\\n  event AddedBeneficiary(address indexed _beneficiary);\\n  event AddedPresaleBeneficiary(address indexed _beneficiary);\\n\\n  function isPresaleWhitelisted(address _beneficiary) public view returns (bool) {\\n    return (presalewhitelist[_beneficiary]);\\n  }\\n\\n  function addManyToPresaleWhitelist(address[] _beneficiaries) public onlyOwner {\\n    for (uint256 i = 0; i \\u003c _beneficiaries.length; i++) {\\n      presalewhitelist[_beneficiaries[i]] = true;\\n      emit AddedPresaleBeneficiary(_beneficiaries[i]);\\n    }\\n  }\\n\\n  function removeFromPresaleWhitelist(address _beneficiary) public onlyOwner {\\n    presalewhitelist[_beneficiary] = false;\\n  }\\n\\n  function addManyToWhitelist(address[] _beneficiaries) public onlyOwner {\\n    for (uint256 i = 0; i \\u003c _beneficiaries.length; i++) {\\n      whitelist[_beneficiaries[i]] = true;\\n      emit AddedBeneficiary(_beneficiaries[i]);\\n    }\\n  }\\n\\n  function removeFromWhitelist(address _beneficiary) public onlyOwner {\\n    whitelist[_beneficiary] = false;\\n  }\\n\\n  function isWhitelisted(address _beneficiary) public view returns (bool) {\\n    return (whitelist[_beneficiary]);\\n  }\\n\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_marketingFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_taxFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_liquidityFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_burnFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"KaikenInuToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6e4f3c2e311abddff048ce1539edab8c939a4ff95ddde8660e4d99c0faaddb10"}]}