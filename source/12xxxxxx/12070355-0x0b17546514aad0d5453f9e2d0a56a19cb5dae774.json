{"status":"1","message":"OK","result":[{"SourceCode":"// File: localhost/helpers/VaultParameters.sol\r\n\r\n// SPDX-License-Identifier: bsl-1.1\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.6.8;\r\n\r\n\r\n/**\r\n * @title Auth\r\n * @dev Manages USDP's system access\r\n **/\r\ncontract Auth {\r\n\r\n    // address of the the contract with vault parameters\r\n    VaultParameters public vaultParameters;\r\n\r\n    constructor(address _parameters) public {\r\n        vaultParameters = VaultParameters(_parameters);\r\n    }\r\n\r\n    // ensures tx's sender is a manager\r\n    modifier onlyManager() {\r\n        require(vaultParameters.isManager(msg.sender), \"Unit Protocol: AUTH_FAILED\");\r\n        _;\r\n    }\r\n\r\n    // ensures tx's sender is able to modify the Vault\r\n    modifier hasVaultAccess() {\r\n        require(vaultParameters.canModifyVault(msg.sender), \"Unit Protocol: AUTH_FAILED\");\r\n        _;\r\n    }\r\n\r\n    // ensures tx's sender is the Vault\r\n    modifier onlyVault() {\r\n        require(msg.sender == vaultParameters.vault(), \"Unit Protocol: AUTH_FAILED\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title VaultParameters\r\n **/\r\ncontract VaultParameters is Auth {\r\n\r\n    // map token to stability fee percentage; 3 decimals\r\n    mapping(address => uint) public stabilityFee;\r\n\r\n    // map token to liquidation fee percentage, 0 decimals\r\n    mapping(address => uint) public liquidationFee;\r\n\r\n    // map token to USDP mint limit\r\n    mapping(address => uint) public tokenDebtLimit;\r\n\r\n    // permissions to modify the Vault\r\n    mapping(address => bool) public canModifyVault;\r\n\r\n    // managers\r\n    mapping(address => bool) public isManager;\r\n\r\n    // enabled oracle types\r\n    mapping(uint => mapping (address => bool)) public isOracleTypeEnabled;\r\n\r\n    // address of the Vault\r\n    address payable public vault;\r\n\r\n    // The foundation address\r\n    address public foundation;\r\n\r\n    /**\r\n     * The address for an Ethereum contract is deterministically computed from the address of its creator (sender)\r\n     * and how many transactions the creator has sent (nonce). The sender and nonce are RLP encoded and then\r\n     * hashed with Keccak-256.\r\n     * Therefore, the Vault address can be pre-computed and passed as an argument before deployment.\r\n    **/\r\n    constructor(address payable _vault, address _foundation) public Auth(address(this)) {\r\n        require(_vault != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        require(_foundation != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        isManager[msg.sender] = true;\r\n        vault = _vault;\r\n        foundation = _foundation;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Grants and revokes manager's status of any address\r\n     * @param who The target address\r\n     * @param permit The permission flag\r\n     **/\r\n    function setManager(address who, bool permit) external onlyManager {\r\n        isManager[who] = permit;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the foundation address\r\n     * @param newFoundation The new foundation address\r\n     **/\r\n    function setFoundation(address newFoundation) external onlyManager {\r\n        require(newFoundation != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        foundation = newFoundation;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets ability to use token as the main collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param stabilityFeeValue The percentage of the year stability fee (3 decimals)\r\n     * @param liquidationFeeValue The liquidation fee percentage (0 decimals)\r\n     * @param usdpLimit The USDP token issue limit\r\n     * @param oracles The enables oracle types\r\n     **/\r\n    function setCollateral(\r\n        address asset,\r\n        uint stabilityFeeValue,\r\n        uint liquidationFeeValue,\r\n        uint usdpLimit,\r\n        uint[] calldata oracles\r\n    ) external onlyManager {\r\n        setStabilityFee(asset, stabilityFeeValue);\r\n        setLiquidationFee(asset, liquidationFeeValue);\r\n        setTokenDebtLimit(asset, usdpLimit);\r\n        for (uint i=0; i < oracles.length; i++) {\r\n            setOracleType(oracles[i], asset, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets a permission for an address to modify the Vault\r\n     * @param who The target address\r\n     * @param permit The permission flag\r\n     **/\r\n    function setVaultAccess(address who, bool permit) external onlyManager {\r\n        canModifyVault[who] = permit;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the percentage of the year stability fee for a particular collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param newValue The stability fee percentage (3 decimals)\r\n     **/\r\n    function setStabilityFee(address asset, uint newValue) public onlyManager {\r\n        stabilityFee[asset] = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the percentage of the liquidation fee for a particular collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param newValue The liquidation fee percentage (0 decimals)\r\n     **/\r\n    function setLiquidationFee(address asset, uint newValue) public onlyManager {\r\n        require(newValue <= 100, \"Unit Protocol: VALUE_OUT_OF_RANGE\");\r\n        liquidationFee[asset] = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Enables/disables oracle types\r\n     * @param _type The type of the oracle\r\n     * @param asset The address of the main collateral token\r\n     * @param enabled The control flag\r\n     **/\r\n    function setOracleType(uint _type, address asset, bool enabled) public onlyManager {\r\n        isOracleTypeEnabled[_type][asset] = enabled;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets USDP limit for a specific collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param limit The limit number\r\n     **/\r\n    function setTokenDebtLimit(address asset, uint limit) public onlyManager {\r\n        tokenDebtLimit[asset] = limit;\r\n    }\r\n}\r\n\r\n// File: localhost/abstract/OracleSimple.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.6.8;\r\n\r\n\r\n/**\r\n * @title OracleSimple\r\n **/\r\nabstract contract OracleSimple {\r\n    // returns Q112-encoded value\r\n    function assetToUsd(address asset, uint amount) public virtual view returns (uint) {}\r\n}\r\n\r\n\r\n/**\r\n * @title OracleSimplePoolToken\r\n **/\r\nabstract contract OracleSimplePoolToken is OracleSimple {\r\n    ChainlinkedOracleSimple public oracleMainAsset;\r\n}\r\n\r\n\r\n/**\r\n * @title ChainlinkedOracleSimple\r\n **/\r\nabstract contract ChainlinkedOracleSimple is OracleSimple {\r\n    address public WETH;\r\n    // returns ordinary value\r\n    function ethToUsd(uint ethAmount) public virtual view returns (uint) {}\r\n\r\n    // returns Q112-encoded value\r\n    function assetToEth(address asset, uint amount) public virtual view returns (uint) {}\r\n}\r\n\r\n// File: localhost/helpers/AggregatorInterface.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.6.8;\r\n\r\ninterface AggregatorInterface {\r\n    function latestAnswer() external view returns (int256); // deprecated\r\n    function latestTimestamp() external view returns (uint256); // deprecated\r\n    function latestRound() external view returns (uint256);\r\n    function decimals() external view returns (uint256);\r\n\r\n    function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n        uint80 roundId,\r\n        int256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint80 answeredInRound\r\n    );\r\n}\r\n\r\n// File: localhost/helpers/SafeMath.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.6.8;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: localhost/impl/ChainlinkedOracleMainAsset.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\ninterface ERC20 {\r\n    function decimals() external view returns(uint8);\r\n}\r\n\r\n/**\r\n * @title ChainlinkedOracleMainAsset\r\n * @dev Calculates the USD price of desired tokens\r\n **/\r\ncontract ChainlinkedOracleMainAsset is ChainlinkedOracleSimple, Auth {\r\n    using SafeMath for uint;\r\n\r\n    mapping (address => address) public usdAggregators;\r\n    mapping (address => address) public ethAggregators;\r\n\r\n    uint public constant Q112 = 2 ** 112;\r\n\r\n    uint public constant USD_TYPE = 0;\r\n    uint public constant ETH_TYPE = 1;\r\n\r\n    event NewAggregator(address indexed asset, address indexed aggregator, uint aggType);\r\n\r\n    constructor(\r\n        address[] memory tokenAddresses1,\r\n        address[] memory _usdAggregators,\r\n        address[] memory tokenAddresses2,\r\n        address[] memory _ethAggregators,\r\n        address weth,\r\n        address vaultParameters\r\n    )\r\n        public\r\n        Auth(vaultParameters)\r\n    {\r\n        require(tokenAddresses1.length == _usdAggregators.length, \"Unit Protocol: ARGUMENTS_LENGTH_MISMATCH\");\r\n        require(tokenAddresses2.length == _ethAggregators.length, \"Unit Protocol: ARGUMENTS_LENGTH_MISMATCH\");\r\n        require(weth != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        require(vaultParameters != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        WETH = weth;\r\n\r\n        for (uint i = 0; i < tokenAddresses1.length; i++) {\r\n            usdAggregators[tokenAddresses1[i]] = _usdAggregators[i];\r\n            emit NewAggregator(tokenAddresses1[i], _usdAggregators[i], USD_TYPE);\r\n        }\r\n\r\n        for (uint i = 0; i < tokenAddresses2.length; i++) {\r\n            ethAggregators[tokenAddresses2[i]] = _ethAggregators[i];\r\n            emit NewAggregator(tokenAddresses2[i], _ethAggregators[i], ETH_TYPE);\r\n        }\r\n    }\r\n\r\n    function setAggeregators(\r\n        address[] calldata tokenAddresses1,\r\n        address[] calldata _usdAggregators,\r\n        address[] calldata tokenAddresses2,\r\n        address[] calldata _ethAggregators\r\n    ) external onlyManager {\r\n        require(tokenAddresses1.length == _usdAggregators.length, \"Unit Protocol: ARGUMENTS_LENGTH_MISMATCH\");\r\n        require(tokenAddresses2.length == _ethAggregators.length, \"Unit Protocol: ARGUMENTS_LENGTH_MISMATCH\");\r\n\r\n        for (uint i = 0; i < tokenAddresses1.length; i++) {\r\n            usdAggregators[tokenAddresses1[i]] = _usdAggregators[i];\r\n            emit NewAggregator(tokenAddresses1[i], _usdAggregators[i], USD_TYPE);\r\n        }\r\n\r\n        for (uint i = 0; i < tokenAddresses2.length; i++) {\r\n            ethAggregators[tokenAddresses2[i]] = _ethAggregators[i];\r\n            emit NewAggregator(tokenAddresses2[i], _ethAggregators[i], ETH_TYPE);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice {asset}/USD or {asset}/ETH pair must be registered at Chainlink\r\n     * @param asset The token address\r\n     * @param amount Amount of tokens\r\n     * @return Q112-encoded price of asset amount in USD\r\n     **/\r\n    function assetToUsd(address asset, uint amount) public override view returns (uint) {\r\n        if (amount == 0) {\r\n            return 0;\r\n        }\r\n        if (usdAggregators[asset] != address(0)) {\r\n            return _assetToUsd(asset, amount);\r\n        }\r\n        return ethToUsd(assetToEth(asset, amount));\r\n    }\r\n\r\n    function _assetToUsd(address asset, uint amount) internal view returns (uint) {\r\n        AggregatorInterface agg = AggregatorInterface(usdAggregators[asset]);\r\n        (, int256 answer, , uint256 updatedAt, ) = agg.latestRoundData();\r\n        require(updatedAt > block.timestamp - 24 hours, \"Unit Protocol: STALE_CHAINLINK_PRICE\");\r\n        require(answer >= 0, \"Unit Protocol: NEGATIVE_CHAINLINK_PRICE\");\r\n        int decimals = 18 - int(ERC20(asset).decimals()) - int(agg.decimals());\r\n        if (decimals < 0) {\r\n            return amount.mul(uint(answer)).mul(Q112).div(10 ** uint(-decimals));\r\n        } else {\r\n            return amount.mul(uint(answer)).mul(Q112).mul(10 ** uint(decimals));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice {asset}/ETH pair must be registered at Chainlink\r\n     * @param asset The token address\r\n     * @param amount Amount of tokens\r\n     * @return Q112-encoded price of asset amount in ETH\r\n     **/\r\n    function assetToEth(address asset, uint amount) public view override returns (uint) {\r\n        if (amount == 0) {\r\n            return 0;\r\n        }\r\n        if (asset == WETH) {\r\n            return amount.mul(Q112);\r\n        }\r\n        AggregatorInterface agg = AggregatorInterface(ethAggregators[asset]);\r\n        require(address(agg) != address (0), \"Unit Protocol: AGGREGATOR_DOES_NOT_EXIST\");\r\n        (, int256 answer, , uint256 updatedAt, ) = agg.latestRoundData();\r\n        require(updatedAt > block.timestamp - 24 hours, \"Unit Protocol: STALE_CHAINLINK_PRICE\");\r\n        require(answer >= 0, \"Unit Protocol: NEGATIVE_CHAINLINK_PRICE\");\r\n        int decimals = 18 - int(ERC20(asset).decimals()) - int(agg.decimals());\r\n        if (decimals < 0) {\r\n            return amount.mul(uint(answer)).mul(Q112).div(10 ** uint(-decimals));\r\n        } else {\r\n            return amount.mul(uint(answer)).mul(Q112).mul(10 ** uint(decimals));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice ETH/USD price feed from Chainlink, see for more info: https://feeds.chain.link/eth-usd\r\n     * returns The price of given amount of Ether in USD (0 decimals)\r\n     **/\r\n    function ethToUsd(uint ethAmount) public override view returns (uint) {\r\n        AggregatorInterface agg = AggregatorInterface(usdAggregators[WETH]);\r\n        (, int256 answer, , uint256 updatedAt, ) = agg.latestRoundData();\r\n        require(updatedAt > block.timestamp - 6 hours, \"Unit Protocol: STALE_CHAINLINK_PRICE\");\r\n        return ethAmount.mul(uint(answer)).div(10 ** agg.decimals());\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_usdAggregators\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddresses2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_ethAggregators\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultParameters\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"aggType\",\"type\":\"uint256\"}],\"name\":\"NewAggregator\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Q112\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USD_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"assetToEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"assetToUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethAggregators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"ethToUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_usdAggregators\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddresses2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_ethAggregators\",\"type\":\"address[]\"}],\"name\":\"setAggeregators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usdAggregators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultParameters\",\"outputs\":[{\"internalType\":\"contract VaultParameters\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ChainlinkedOracleMainAsset","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004c0000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000b46f8cf42e504efe8bef895f848741daa55e9f1d0000000000000000000000000000000000000000000000000000000000000008000000000000000000000000ade00c28244d5ce17d72e40330b1c318cd12b7c3000000000000000000000000d46ba6d942050d489dbd938a2c909a5d5039a161000000000000000000000000e28b3b32b6c345a34ff64674606124dd5aceca300000000000000000000000007d1afa7b718fb893db30a3abc0cfc608aacfebb00000000000000000000000004575f41308ec1483f3d399aa9a2826d74da13deb0000000000000000000000008ce9137d39326ad0cd6491fb5cc0cba0e089b6a90000000000000000000000004c19596f5aaff459fa38b0f7ed92f11ae6543784000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000008000000000000000000000000231e764b44b2c1b7ca171fa8021a24ed520cde10000000000000000000000000e20ca8d7546932360e37e9d72c1a47334af57706000000000000000000000000ae2ebe3c4d20ce13ce47cbb49b6d7ee631cd816e0000000000000000000000007bac85a8a13a4bcd8abb3eb7d6b4d632c5a57676000000000000000000000000d75aaae4af0c398ca13e2667be57af2cca8b5de6000000000000000000000000fb0cfd6c19e25db4a08d8a204a387cea48cc138f00000000000000000000000026929b85fe284eeab939831002e1928183a10fb10000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000e41d2489571d322189246dafa5ebde1f4699f4980000000000000000000000000d8775f648430679a709e98d2b0cb6250d2887ef000000000000000000000000dd974d5c2e2928dea5f71b9825b8b646686bd200000000000000000000000000bbbbca6a901c926f240b89eacb641d8aec7aeafd0000000000000000000000000f5d2fb29fb7d3cfee444a200298f468908cc942000000000000000000000000221657776846890989a759ba2973e427dff5c9bb000000000000000000000000f629cbd94d3791c9250152bd8dfbdf380e2a3b9c000000000000000000000000a117000000f279d81a1d3cc75430faa017fa5a2e00000000000000000000000056d811088235f11c8920698a204a5010a788f4b3000000000000000000000000a0b73e1ff0b80914ab6fe0444e65848c4c34450b0000000000000000000000001776e1f26f98b1a5df9cd347953a26dd3cb466710000000000000000000000008207c1ffc5b6804f6024322ccf34f29c3541ae260000000000000000000000000258f474786ddfd37abce6df6bbb1dd5dfc4434a000000000000000000000000000000000000000000000000000000000000000d0000000000000000000000002da4983a622a8498bb1a21fae9d8f6c6649399620000000000000000000000000d16d4528239e9ee52fa531af613acdb23d88c94000000000000000000000000656c0544ef4c98a6a98491833a89204abb045d6b000000000000000000000000160ac928a16c93ed4895c2de6f81ecce9a7eb7b400000000000000000000000082a44d92d6c329826dc557c5e1be6ebec5d5feb9000000000000000000000000d4ce430c3b67b3e2f7026d86e7128588629e245500000000000000000000000024d9ab51950f3d62e9144fdc2f3135daa6ce8d1b0000000000000000000000008f83670260f8f7708143b836a2a6f11ef0abac010000000000000000000000008f7c7181ed1a2ba41cfc3f5d064ef91b67daef66000000000000000000000000ca696a9eb93b81adfe6435759a29ab4cf2991a960000000000000000000000009cb2a01a7e64992d32a34db7ceea4c919c391f6a0000000000000000000000002c881b6f3f6b5ff6c975813f87a4dad0b241c15b000000000000000000000000ba9b2a360eb8abdb677d6d7f27e12de11aa052ef","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1af87b5a0fab3fc82aebfb2ba1c2f14194038fdb6aac3aafd1888aa10a7a6ace"}]}