{"status":"1","message":"OK","result":[{"SourceCode":"\"\"\"\r\n@title Liquidator\r\n@notice Loan liquidation contract for the Greenwood Protocol\r\n@author Greenwood Labs\r\n\"\"\"\r\n\r\n# define the interfaces used by the contract\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface AAVE_V2_PRICE_FEED:\r\n    def getAssetPrice(_asset: address) -> uint256: view\r\n\r\ninterface COMPTROLLER:\r\n    def markets(_c_token: address) -> (bool, uint256, bool): view\r\n\r\ninterface COMPOUND_PRICE_FEED:\r\n    def price(_ticker: String[10]) -> uint256: view\r\n\r\ninterface CTOKEN:\r\n    def mint(_mint_amount: uint256) -> uint256: payable\r\n    def borrow(_borrow_amount: uint256) -> uint256: payable\r\n    def repayBorrow(_repay_amount: uint256) -> uint256: payable\r\n    def borrowIndex() -> uint256: nonpayable\r\n    def redeemUnderlying(_redeem_amount: uint256) -> uint256: payable\r\n    def exchangeRateStored() -> uint256: nonpayable\r\n    def borrowRatePerBlock() -> uint256: nonpayable\r\n    def borrowBalanceCurrent(_account: address) -> uint256: nonpayable\r\n    def accrualBlockNumber() -> uint256: nonpayable\r\n\r\ninterface ESCROW:\r\n    def liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_index: uint256, _key_count: uint256, _loan_keys: bytes32[100], _liquidator: address, _redeem_amount: uint256, _repay_amount: uint256, _store: address, _version: String[11]): payable\r\n\r\ninterface REGISTRY:\r\n    def getAddress(_contract: String[20], _version: String[11], ) -> address: nonpayable\r\n    def governance() -> address: nonpayable\r\n\r\ninterface STORE:\r\n    def getAssetContext(_ticker: String[10]) -> AssetContext: view\r\n    def recordLoan(_borrower: address, _borrow_asset: address, _collateral_asset: address, _collateralization_ratio: uint256, _collateral_locked: uint256, _index: uint256, _principal: uint256, _protocol: String[10], _version: String[11]): nonpayable\r\n    def updateLoan(_collateral_locked: uint256, _index: uint256, _loan_key: bytes32, _outstanding: uint256, _version: String[11]): nonpayable\r\n    def getLoan(_loan_key: bytes32) -> Loan: view\r\n    def getLoanProtocol(_loan_key: bytes32) -> String[10]: view\r\n\r\n# decalre the constants used by the contract\r\nLOOP_LIMIT: constant(uint256) = 100\r\nTEN_EXP_6: constant(uint256) = 1000000\r\nTEN_EXP_18: constant(uint256) = 1000000000000000000\r\nZERO_BYTES_32: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000000000000\r\n\r\n# define the events used by the contract\r\nevent SetRegistry:\r\n    previousRegistry: address\r\n    newRegistry: address\r\n    governance: address\r\n    blockNumber: uint256\r\n\r\n#  define the structs used by the contract\r\nstruct AaveV2CollateralCalculation:\r\n    isLiquidatable: bool\r\n    outstanding: uint256\r\n\r\nstruct AaveV2Data:\r\n    collateralAssetLTV: uint256\r\n    borrowIndex: uint256\r\n    variableDebtTokenAddress: address\r\n    escrowBorrowBalance: uint256\r\n    scaledBalanceOf: uint256\r\n    borrowAssetPriceExp: uint256\r\n    collateralAssetPriceExp: uint256\r\n\r\nstruct AssetContext:\r\n    aToken: address\r\n    aaveV2PriceFeed: address\r\n    aaveV2LendingPool: address\r\n    cToken: address\r\n    compoundPriceFeed: address\r\n    comptroller: address\r\n    decimals: uint256\r\n    underlying: address\r\n\r\nstruct CompoundData:\r\n    collateralFactorMantissa: uint256\r\n    borrowIndex: uint256\r\n    borrowAssetPriceExp: uint256\r\n    collateralAssetPriceExp: uint256\r\n\r\nstruct CompoundCollateralCalculation:\r\n    isLiquidatable: bool\r\n    outstanding: uint256\r\n\r\nstruct Loan:\r\n    collateralAsset: address\r\n    borrowAsset: address\r\n    outstanding: uint256\r\n    collateralizationRatio: uint256\r\n    collateralLocked: uint256\r\n    borrower: address\r\n    lastBorrowIndex: uint256\r\n    repaymentTime: uint256\r\n\r\n# define the storage variables used by the contract\r\nregistry: public(address)\r\naaveV2Data: AaveV2Data\r\ncompoundData: CompoundData\r\n\r\n@external\r\ndef __init__(_registry: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _registry The address of the Greenwood Registry\r\n    \"\"\"\r\n\r\n    # set the address of the Escrow\r\n    self.registry = _registry\r\n\r\n@internal\r\ndef isAuthorized(_caller: address, _role: String[20], _version: String[11]) -> bool:\r\n    \"\"\"\r\n    @notice Method for role-based security\r\n    @param _caller The address that called the permissioned method\r\n    @param _role The requested authorization level\r\n    @param _version The version of Greenwood to use\r\n    @return True if the caller is authorized, False otherwise\r\n    \"\"\"\r\n\r\n    # check if the requested role is \"controller\"\r\n    if keccak256(_role) == keccak256(\"controller\"):\r\n\r\n        # get the address of the Controller from the Registry\r\n        escrow: address = REGISTRY(self.registry).getAddress(\"controller\", _version)\r\n\r\n        # return the equality comparison boolean\r\n        return escrow == _caller\r\n    \r\n    # check if the requested role is \"governance\"\r\n    elif keccak256(_role) == keccak256(\"governance\"):\r\n\r\n        # get the address of the Governance from the Registry\r\n        governance: address = REGISTRY(self.registry).governance()\r\n\r\n        # return the equality comparison boolean\r\n        return governance == _caller\r\n\r\n    # catch extraneous role arguments\r\n    else:\r\n\r\n        # revert\r\n        raise \"Unhandled role argument\"\r\n\r\n\r\n@internal\r\ndef fetchAaveV2Data(_borrow_context: AssetContext, _collateral_context: AssetContext, _escrow: address) -> AaveV2Data:\r\n    \"\"\"\r\n    @notice Get Aave V2 data for liquidation calculations\r\n    @param _borrow_context The AssetContext struct of the asset being borrowed\r\n    @param _collateral_context The AssetContext struct of the asset being used as collateral\r\n    @param _escrow The address of the Greenwood Escrow to use\r\n    @return AaveV2Data struct\r\n    \"\"\"\r\n\r\n    # get the LTV ratio of the collateral asset\r\n    collateralReserveData: Bytes[768] = raw_call(\r\n        _collateral_context.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"getReserveData(address)\"),\r\n            convert(_collateral_context.underlying, bytes32)\r\n        ),\r\n        max_outsize=768\r\n    )\r\n\r\n    # parse the LTV from collateralReserveData and convert it to a percentage\r\n    collateralAssetLTV: uint256 = convert(slice(collateralReserveData, 30, 2), uint256)\r\n\r\n    # get the current borrowIndex of the borrow asset\r\n    borrowReserveData: Bytes[768] = raw_call(\r\n        _borrow_context.aaveV2LendingPool,\r\n        concat(\r\n            method_id(\"getReserveData(address)\"),\r\n            convert(_borrow_context.underlying, bytes32)\r\n        ),\r\n        max_outsize=768\r\n    )\r\n\r\n    # parse the variableBorrowIndex from borrowReserveData\r\n    borrowIndex: uint256 = convert(slice(borrowReserveData, 64, 32), uint256)\r\n\r\n    # parse the variableDebtTokenAddress from borrowReserveData\r\n    variableDebtTokenAddress: address = convert(convert(slice(borrowReserveData, 288, 32), bytes32), address)\r\n\r\n    # get variableDebtToken balance of the Escrow\r\n    escrowBorrowBalance: uint256 = ERC20(variableDebtTokenAddress).balanceOf(_escrow)\r\n\r\n    # get the variableDebtToken scaledBalanceOf the Escrow\r\n    scaledBalanceOfResponse: Bytes[32] = raw_call(\r\n        variableDebtTokenAddress,\r\n        concat(\r\n            method_id(\"scaledBalanceOf(address)\"),\r\n            convert(_escrow, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n\r\n    # convert the scaledBalanceOfResponse to a uint256\r\n    scaledBalanceOf: uint256 = convert(scaledBalanceOfResponse, uint256)\r\n\r\n    # get the price of the borrow asset and the collateral asset denominated in ETH\r\n    borrowAssetPriceExp: uint256 = AAVE_V2_PRICE_FEED(_borrow_context.aaveV2PriceFeed).getAssetPrice(_borrow_context.underlying)\r\n    collateralAssetPriceExp: uint256 = AAVE_V2_PRICE_FEED(_collateral_context.aaveV2PriceFeed).getAssetPrice(_collateral_context.underlying)\r\n\r\n    # scale down the prices and convert them to decimals\r\n    borrowAssetPrice: decimal = convert(borrowAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\r\n    collateralAssetPrice: decimal = convert(collateralAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\r\n\r\n    # return the data\r\n    return AaveV2Data({\r\n        collateralAssetLTV: collateralAssetLTV,\r\n        borrowIndex: borrowIndex,\r\n        variableDebtTokenAddress: variableDebtTokenAddress,\r\n        escrowBorrowBalance: escrowBorrowBalance,\r\n        scaledBalanceOf: scaledBalanceOf,\r\n        borrowAssetPriceExp: borrowAssetPriceExp,\r\n        collateralAssetPriceExp: collateralAssetPriceExp,\r\n    })\r\n\r\n@internal\r\ndef fetchCompoundData(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext) -> CompoundData:\r\n    \"\"\"\r\n    @notice Get Compound data for liquidation calculations\r\n    @param _borrow_ticker The ticker string of the asset that is being borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _borrow_context The AssetContext struct of the asset being borrowed\r\n    @param _collateral_context The AssetContext struct of the asset being used as collateral\r\n    @return CompoundData struct\r\n    \"\"\"\r\n\r\n    # setup memory variables to handle comptroller return values\r\n    isListed: bool = False\r\n    collateralFactorMantissa: uint256 = 0\r\n    isComped: bool = False\r\n\r\n    # get the collateral factor for the collateral asset using the comptroller\r\n    isListed, collateralFactorMantissa, isComped  = COMPTROLLER(_collateral_context.comptroller).markets(_collateral_context.cToken)\r\n\r\n    # get the current borrowIndex from the cToken\r\n    borrowIndex: uint256 = CTOKEN(_borrow_context.cToken).borrowIndex()\r\n\r\n    # get the price of the borrow asset and the collateral asset denominated in USD\r\n    borrowAssetPriceExp: uint256 = COMPOUND_PRICE_FEED(_borrow_context.compoundPriceFeed).price(_borrow_ticker)\r\n    collateralAssetPriceExp: uint256 = COMPOUND_PRICE_FEED(_collateral_context.compoundPriceFeed).price(_collateral_ticker)\r\n\r\n    # return the data\r\n    return CompoundData({\r\n        collateralFactorMantissa: collateralFactorMantissa,\r\n        borrowIndex: borrowIndex,\r\n        borrowAssetPriceExp: borrowAssetPriceExp,\r\n        collateralAssetPriceExp: collateralAssetPriceExp\r\n    })\r\n\r\n@internal\r\ndef checkAaveV2Collateral(_borrow_context: AssetContext, _collateral_context: AssetContext, _aave_v2_data: AaveV2Data, _escrow: address, _loan: Loan) -> AaveV2CollateralCalculation:\r\n    \"\"\"\r\n    @notice Calculate the required collateral and liquidatibility for an Aave V2 loan\r\n    @param _borrow_context The AssetContext struct of the asset being borrowed\r\n    @param _collateral_context The AssetContext struct of the asset being used as collateral\r\n    @param _aave_v2_data The AaveV2Data struct with data for liquidation calculatios\r\n    @param _escrow The address of the Greenwood Escrow to use\r\n    @param _loan A Loan struct containing loan data\r\n    @return AaveV2CollateralCalculation struct\r\n    \"\"\"\r\n\r\n    # scale down the LTV to a percentage\r\n    collateralAssetLTV: decimal = convert(_aave_v2_data.collateralAssetLTV, decimal) / 10000.0\r\n\r\n    # calculate the borrow balance increase of the Escrow\r\n    balanceIncrease: decimal = ((convert(_aave_v2_data.escrowBorrowBalance, decimal) - convert(_aave_v2_data.scaledBalanceOf, decimal)) * (convert(_loan.lastBorrowIndex, decimal) / convert(10 ** 27, decimal))) / convert(10 ** 18, decimal)\r\n\r\n    # declare a memory variable to store the amount of interest accrued\r\n    interestAccrued: decimal = 0.0\r\n\r\n    # check that the Escrow borrow balance is not equal to the balance increase to prevent division by 0\r\n    if convert(_aave_v2_data.escrowBorrowBalance, decimal) != balanceIncrease:\r\n\r\n        # calculate the interest accrued since the last action on the loan\r\n        interestAccrued = balanceIncrease / (convert(_aave_v2_data.escrowBorrowBalance, decimal) - balanceIncrease)\r\n\r\n    # apply interest accrued to the outstanding balance of the loan\r\n    borrowBalanceScaled: uint256 = convert(convert(_loan.outstanding, decimal) * (1.0 + interestAccrued), uint256)\r\n\r\n    # scale down the prices and convert them to decimals\r\n    borrowAssetPrice: decimal = convert(_aave_v2_data.borrowAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\r\n    collateralAssetPrice: decimal = convert(_aave_v2_data.collateralAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\r\n\r\n    # convert the borrow balance to a decimal and scale it down\r\n    borrowBalance: decimal = convert(borrowBalanceScaled, decimal) / convert(10 ** _borrow_context.decimals, decimal)\r\n\r\n    # calculate the value of the borrow balance denominated in ETH\r\n    borrowAmountInETH: decimal = borrowBalance * borrowAssetPrice\r\n\r\n    # calculate the required collateral denominated in ETH\r\n    requiredCollateralInETH: decimal = borrowAmountInETH / collateralAssetLTV\r\n\r\n    # calculate the required collateral denominated in the collateral asset \r\n    requiredCollateral: decimal = requiredCollateralInETH / collateralAssetPrice\r\n\r\n    # calculate the required collateral for Greenwood denominated in the collateral asset \r\n    requiredCollateralGreenwood: decimal = requiredCollateral * (convert(_loan.collateralizationRatio, decimal) / 100.0)\r\n\r\n    # scale the required collateral for Greenwood by the decimals of the collateral asset\r\n    requiredCollateralScaled: uint256 = convert(requiredCollateralGreenwood * convert(10 ** _collateral_context.decimals, decimal), uint256)\r\n\r\n    # subtract the required collateral from the collateral locked to see if the loan is undercollateralized\r\n    collateralDifference: int128 = convert(_loan.collateralLocked, int128) - convert(requiredCollateralScaled, int128)\r\n\r\n    # check if the collateral difference is negative\r\n    if collateralDifference < 0:\r\n\r\n        # if the collateral difference is negative return True\r\n        return AaveV2CollateralCalculation({\r\n            isLiquidatable: True,\r\n            outstanding: borrowBalanceScaled\r\n        })\r\n\r\n    # check if the collateral difference is non-negative\r\n    elif collateralDifference >= 0:\r\n        \r\n        # if the collateral difference is non-negative return False\r\n        return AaveV2CollateralCalculation({\r\n            isLiquidatable: False,\r\n            outstanding: 0\r\n        })\r\n\r\n    else:\r\n\r\n        # return False as a fallback case\r\n        return AaveV2CollateralCalculation({\r\n            isLiquidatable: False,\r\n            outstanding: 0\r\n        })\r\n\r\n@internal\r\ndef checkCompoundCollateral(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _compound_data: CompoundData, _loan: Loan) -> CompoundCollateralCalculation:\r\n    \"\"\"\r\n    @notice Calculate the required collateral and liquidatibility for a Compound loan\r\n    @param _borrow_ticker The ticker string of the asset that is being borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _borrow_context The AssetContext struct of the asset being borrowed\r\n    @param _collateral_context The AssetContext struct of the asset being used as collateral\r\n    @param _compound_data The CompoundData struct with data for liquidation calculatios\r\n    @param _loan A Loan struct containing loan data\r\n    @return CompoundCollateralCalculation struct\r\n    \"\"\"\r\n\r\n    # convert collateralFactorMantissa to a percentage\r\n    collateralFactor: decimal = convert(_compound_data.collateralFactorMantissa, decimal) / convert(TEN_EXP_18, decimal)\r\n\r\n    # calculate the interestAccrued since the last action on the loan\r\n    interestAccrued: decimal = convert(_compound_data.borrowIndex, decimal) / convert(_loan.lastBorrowIndex, decimal) - 1.0\r\n\r\n    # apply interest accrued to the outstanding balance of the loan\r\n    borrowBalanceScaled: uint256 = convert(convert(_loan.outstanding, decimal) * (1.0 + interestAccrued), uint256)\r\n\r\n    # convert the prices to decimals\r\n    borrowAssetPrice: decimal = convert(_compound_data.borrowAssetPriceExp, decimal) / convert(TEN_EXP_6, decimal)\r\n    collateralAssetPrice: decimal = convert(_compound_data.collateralAssetPriceExp, decimal) / convert(TEN_EXP_6, decimal)\r\n\r\n    # convert the borrow balance to a decimal and scale it down\r\n    borrowBalance: decimal = convert(borrowBalanceScaled, decimal) / convert(10 ** _borrow_context.decimals, decimal)\r\n\r\n    # calculate the value of the outstanding balance denominated in USD\r\n    borrowAmountInUSD: decimal = borrowBalance * borrowAssetPrice\r\n\r\n    # calculate the required collateral denominated in USD\r\n    requiredCollateralInUSD: decimal = borrowAmountInUSD / collateralFactor\r\n\r\n    # calculate the required collateral denominated in the collateral asset \r\n    requiredCollateral: decimal = requiredCollateralInUSD / collateralAssetPrice\r\n\r\n    # calculate the required collateral for Greenwood denominated in the collateral asset \r\n    requiredCollateralGreenwood: decimal = requiredCollateral * (convert(_loan.collateralizationRatio, decimal) / 100.0)\r\n\r\n    # scale the required collateral for Greenwood by the decimals of the collateral asset\r\n    requiredCollateralScaled: uint256 = convert(requiredCollateralGreenwood * convert(10 ** _collateral_context.decimals, decimal), uint256)\r\n\r\n    # subtract the required collateral from the collateral locked to see if the loan is undercollateralized\r\n    collateralDifference: int128 = convert(_loan.collateralLocked, int128) - convert(requiredCollateralScaled, int128)\r\n\r\n    # check if the collateral difference is negative\r\n    if collateralDifference < 0:\r\n\r\n        # if the collateral difference is negative return True\r\n        return CompoundCollateralCalculation({\r\n            isLiquidatable: True,\r\n            outstanding: borrowBalanceScaled\r\n        })\r\n\r\n    # check if the collateral difference is non-negative\r\n    elif collateralDifference >= 0:\r\n        \r\n        # if the collateral difference is non-negative return False\r\n        return CompoundCollateralCalculation({\r\n            isLiquidatable: False,\r\n            outstanding: 0\r\n        })\r\n\r\n    else:\r\n\r\n        # return False as a fallback case\r\n        return CompoundCollateralCalculation({\r\n            isLiquidatable: False,\r\n            outstanding: 0\r\n        })\r\n\r\n\r\n@external\r\n@payable\r\ndef liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _aave_v2_escrow: address, _compound_escrow: address, _key_count: uint256, _liquidator: address, _loan_keys: bytes32[100], _aave_v2_loan_keys: bytes32[100], _compound_loan_keys: bytes32[100], _store: address, _version: String[11]):\r\n    \"\"\"\r\n    @notice Compile undercollateralized loans for liquidation\r\n    @param _borrow_ticker The ticker string of the asset that is being borrowed\r\n    @param _collateral_ticker The ticker string of the asset that is being used as collateral\r\n    @param _store The address of the Greenwood AaveV2Escrow to use\r\n    @param _store The address of the Greenwood CompoundEscrow to use\r\n    @param _key_count The number of uinque identifiers in the _loan_keys array\r\n    @param _liquidator The address that submitted the liquidation request\r\n    @param _loan_keys An array of uinque identifiers for loans\r\n    @param _aave_v2_loan_keys An empty array to store loan keys for Aave V2 loans\r\n    @param _compound_loan_keys An empty array to store loan keys for Compound loans\r\n    @param _store The address of the Greenwood Store to use\r\n    @param _version The version of Greenwood to use\r\n    @dev Only the Controller or the Governance can call this method\r\n    \"\"\"\r\n\r\n    # require that the method is being called by the Controller or the Governance\r\n    assert self.isAuthorized(msg.sender, \"controller\", _version) == True or self.isAuthorized(msg.sender, \"governance\", _version) == True, \"Only Controller or Governance can call this method\"\r\n\r\n    # get the asset contexts for the borrow asset and the collateral asset from the Store\r\n    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\r\n    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\r\n\r\n    # declare memory variables to store the number of loan keys that have been processed and the current indexes of the loanKey arrays\r\n    loanKeyCounter: uint256 = 0\r\n    currentAaveV2Index: uint256 = 0\r\n    currentCompoundIndex: uint256 = 0\r\n\r\n    # declare memory variables to store the loan keys of loans that need to be liquidated\r\n    aaveV2LoanKeys: bytes32[100] = _aave_v2_loan_keys\r\n    compoundLoanKeys: bytes32[100] = _compound_loan_keys\r\n\r\n    # declare memory variables to store the status of fetched data\r\n    isAaveV2DataFetched: bool = False\r\n    isCompoundDataFetched: bool = False\r\n\r\n    # declare memory variables to accumulate outstanding balances and collateral locked\r\n    aaveV2Outstanding: uint256 = 0\r\n    compoundOutstanding: uint256 = 0\r\n    aaveV2CollateralLocked: uint256 = 0\r\n    compoundCollateralLocked: uint256 = 0\r\n\r\n    # loop over the loan keys\r\n    for i in range(LOOP_LIMIT):\r\n\r\n        if loanKeyCounter < _key_count:\r\n\r\n            # get the current loan key from loan keys\r\n            currentKey: bytes32 = _loan_keys[i]\r\n        \r\n            # get loan data from the Store\r\n            currentLoan: Loan = STORE(_store).getLoan(currentKey)\r\n\r\n            # require that a loan was returned\r\n            assert currentLoan.borrowAsset != ZERO_ADDRESS, \"No loan returned from the Store\"\r\n\r\n            # get loan protocol from the Store\r\n            currentProtocol: String[10] = STORE(_store).getLoanProtocol(currentKey)\r\n\r\n            # require that a loan protocol was returned\r\n            assert keccak256(currentProtocol) == keccak256(\"aavev2\") or keccak256(currentProtocol) == keccak256(\"compound\"), \"Invalid protocol returned from the Store\"\r\n\r\n            # require that the outstanding balance of the loan is non-negative\r\n            assert currentLoan.outstanding > 0, \"Outstanding balance must be greater than 0\"\r\n\r\n            # require that the underlying asset of the loan and contexts match\r\n            assert currentLoan.borrowAsset == borrowContext.underlying, \"Borrow context mismatch\"\r\n            assert currentLoan.collateralAsset == collateralContext.underlying, \"Collateral context mismatch\"\r\n\r\n            # check if the loan was originated with Aave V2 but Aave V2 data has not been fetched\r\n            if keccak256(currentProtocol) == keccak256(\"aavev2\") and isAaveV2DataFetched == False:\r\n\r\n                # get Aave V2 data\r\n                self.aaveV2Data = self.fetchAaveV2Data(borrowContext, collateralContext, _aave_v2_escrow)\r\n\r\n                # prevent refetching the data\r\n                isAaveV2DataFetched = True\r\n\r\n                # check if the current loan is liquidatable\r\n                aaveV2CollateralCalculation: AaveV2CollateralCalculation = self.checkAaveV2Collateral(borrowContext, collateralContext, self.aaveV2Data , _aave_v2_escrow, currentLoan)\r\n\r\n                # handle the return from checkAaveV2Collateral\r\n                if aaveV2CollateralCalculation.isLiquidatable == True:\r\n\r\n                    # if the current loan is liquidatable write the loan key to a byte array\r\n                    aaveV2LoanKeys[currentAaveV2Index] = currentKey\r\n\r\n                    # add the outstanding balance to the overall outstanding balance for the batch of aave loans\r\n                    aaveV2Outstanding += aaveV2CollateralCalculation.outstanding\r\n\r\n                    # add the locked collateral to the overall collateral to redeem\r\n                    aaveV2CollateralLocked += currentLoan.collateralLocked\r\n\r\n                    # increment the index\r\n                    currentAaveV2Index += 1\r\n\r\n            # check if the loan was originated with Aave V2 and Aave V2 data has been fetched\r\n            elif keccak256(currentProtocol) == keccak256(\"aavev2\") and isAaveV2DataFetched == True:\r\n                \r\n                # check if the current loan is liquidatable\r\n                aaveV2CollateralCalculation: AaveV2CollateralCalculation = self.checkAaveV2Collateral(borrowContext, collateralContext, self.aaveV2Data , _aave_v2_escrow, currentLoan)\r\n\r\n                # handle the return from checkAaveV2Collateral\r\n                if aaveV2CollateralCalculation.isLiquidatable == True:\r\n\r\n                    # if the current loan is liquidatable write the loan key to a byte array\r\n                    aaveV2LoanKeys[currentAaveV2Index] = currentKey\r\n\r\n                    # add the outstanding balance to the overall outstanding balance for the batch of aave loans\r\n                    aaveV2Outstanding += aaveV2CollateralCalculation.outstanding\r\n\r\n                    # add the locked collateral to the overall collateral to redeem\r\n                    aaveV2CollateralLocked += currentLoan.collateralLocked\r\n\r\n                    # increment the index\r\n                    currentAaveV2Index += 1\r\n            \r\n            # check if the loan was originated with Compound but Compound data has not been fetched\r\n            elif keccak256(currentProtocol) == keccak256(\"compound\") and isCompoundDataFetched == False:\r\n\r\n                # fetch compound data\r\n                self.compoundData = self.fetchCompoundData(_borrow_ticker, _collateral_ticker, borrowContext, collateralContext)\r\n\r\n                # set isCompoundDataFetched to True to prevent refetching the data\r\n                isCompoundDataFetched = True\r\n\r\n                # check if the current loan is liquidatable\r\n                compoundCollateralCalculation: CompoundCollateralCalculation = self.checkCompoundCollateral(_borrow_ticker, _collateral_ticker, borrowContext, collateralContext, self.compoundData, currentLoan)\r\n\r\n                # handle the return from checkCompoundCollateral\r\n                if compoundCollateralCalculation.isLiquidatable == True:\r\n\r\n                    # if the current loan is liquidatable write the loan key to a byte array\r\n                    compoundLoanKeys[currentCompoundIndex] = currentKey\r\n\r\n                    # add the outstanding balance to the overall outstanding balance for the batch of aave loans\r\n                    compoundOutstanding += compoundCollateralCalculation.outstanding\r\n\r\n                    # add the locked collateral to the overall collateral to redeem\r\n                    compoundCollateralLocked += currentLoan.collateralLocked\r\n\r\n                    # increment the index\r\n                    currentCompoundIndex += 1\r\n\r\n            # check if the loan was originated with Compound and Compound data has been fetched\r\n            elif keccak256(currentProtocol) == keccak256(\"compound\") and isCompoundDataFetched == True:\r\n\r\n                # check if the current loan is liquidatable\r\n                compoundCollateralCalculation: CompoundCollateralCalculation = self.checkCompoundCollateral(_borrow_ticker, _collateral_ticker, borrowContext, collateralContext, self.compoundData, currentLoan)\r\n\r\n                # handle the return from checkCompoundCollateral\r\n                if compoundCollateralCalculation.isLiquidatable == True:\r\n\r\n                    # if the current loan is liquidatable write the loan key to a byte array\r\n                    compoundLoanKeys[currentCompoundIndex] = currentKey\r\n\r\n                    # add the outstanding balance to the overall outstanding balance for the batch of aave loans\r\n                    compoundOutstanding += compoundCollateralCalculation.outstanding\r\n\r\n                    # add the locked collateral to the overall collateral to redeem\r\n                    compoundCollateralLocked += currentLoan.collateralLocked\r\n\r\n                    # increment the index\r\n                    currentCompoundIndex += 1\r\n\r\n            # catch extraneous lending protocols\r\n            else:\r\n\r\n                # revert\r\n                raise \"Unhandled loan protocol\"\r\n\r\n            # increment the loan key counter\r\n            loanKeyCounter += 1\r\n\r\n        # all loan keys have been processed\r\n        elif loanKeyCounter == _key_count:\r\n\r\n            # halt loop execution\r\n            break\r\n\r\n        else:\r\n\r\n            # halt loop execution as a fallback case\r\n            break\r\n\r\n    # check if aaveV2LoanKeys is empty\r\n    if aaveV2LoanKeys[0] != ZERO_BYTES_32:\r\n        \r\n        # call liquidate on the Escrow with the aave v2 loan keys\r\n        ESCROW(_aave_v2_escrow).liquidate(_borrow_ticker, _collateral_ticker, self.aaveV2Data.borrowIndex, currentAaveV2Index, aaveV2LoanKeys, _liquidator, aaveV2CollateralLocked, aaveV2Outstanding, _store, _version)\r\n\r\n    # check if compoundLoanKeys is empty\r\n    if compoundLoanKeys[0] != ZERO_BYTES_32:\r\n\r\n        # call liquidate on the Escrow with the compound loan keys\r\n        ESCROW(_compound_escrow).liquidate(_borrow_ticker, _collateral_ticker, self.compoundData.borrowIndex, currentCompoundIndex, compoundLoanKeys, _liquidator, compoundCollateralLocked, compoundOutstanding, _store, _version, value=msg.value)\r\n\r\n\r\n@external\r\ndef setRegistry(_new_registry: address):\r\n    \"\"\"\r\n    @notice Updates the address of the Registry\r\n    @param _new_registry The address of the new Greenwood Registry\r\n    @dev Only the Governance can call this method\r\n    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\r\n    \"\"\"\r\n\r\n    # require that the method caller is the Governance\r\n    assert self.isAuthorized(msg.sender, \"governance\", \"\") == True, \"Only Governance can call this method\"\r\n\r\n    # get the previous Registry\r\n    previousRegistry: address = self.registry\r\n\r\n    # update the address of the Registry\r\n    self.registry = _new_registry\r\n\r\n    # emit a SetRegistry event\r\n    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)","ABI":"[{\"name\":\"SetRegistry\",\"inputs\":[{\"type\":\"address\",\"name\":\"previousRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"newRegistry\",\"indexed\":false},{\"type\":\"address\",\"name\":\"governance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"blockNumber\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"liquidate\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_borrow_ticker\"},{\"type\":\"string\",\"name\":\"_collateral_ticker\"},{\"type\":\"address\",\"name\":\"_aave_v2_escrow\"},{\"type\":\"address\",\"name\":\"_compound_escrow\"},{\"type\":\"uint256\",\"name\":\"_key_count\"},{\"type\":\"address\",\"name\":\"_liquidator\"},{\"type\":\"bytes32[100]\",\"name\":\"_loan_keys\"},{\"type\":\"bytes32[100]\",\"name\":\"_aave_v2_loan_keys\"},{\"type\":\"bytes32[100]\",\"name\":\"_compound_loan_keys\"},{\"type\":\"address\",\"name\":\"_store\"},{\"type\":\"string\",\"name\":\"_version\"}],\"stateMutability\":\"payable\",\"type\":\"function\",\"gas\":28277763},{\"name\":\"setRegistry\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_new_registry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":46958},{\"name\":\"registry\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1361}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.3","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000001ddbb7a21905c6a8dbd76b20b7c6b3a55d1af24f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}