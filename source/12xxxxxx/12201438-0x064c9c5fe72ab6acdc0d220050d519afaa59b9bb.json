{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC1155 {\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n}\r\n\r\ninterface IERC721 {\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\r\n    \r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n    \r\n    function isApprovedForAll(address owner, address operator) external returns (bool);\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n        * @dev Returns the amount of tokens owned by `account`.\r\n        */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n        *\r\n        * Returns a boolean value indicating whether the operation succeeded.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\ninterface INFT20Pair {\r\n    function withdraw(\r\n        uint256[] calldata _tokenIds,\r\n        uint256[] calldata amounts,\r\n        address recipient\r\n    ) external;\r\n\r\n    function withdraw(\r\n        uint256[] calldata _tokenIds,\r\n        uint256[] calldata amounts\r\n    ) external;\r\n\r\n    function track1155(uint256 _tokenId) external returns (uint256);\r\n\r\n    function multi721Deposit(uint256[] memory _ids, address _referral) external;\r\n}\r\n\r\ninterface INft20Registry {\r\n    function nftToErc20(address nftAddr) external view returns (address erc20Addr);\r\n}\r\n\r\nlibrary Nft20Market {\r\n\r\n    struct NftDetails {\r\n        address nftAddr;\r\n        uint256[] tokenIds;\r\n        uint256[] amounts;\r\n    }\r\n\r\n    INft20Registry public constant Nft20Registry = INft20Registry(0xB0244fDEf4E48c2bCBAcf10cC8dd07f0CB45E7Bf); \r\n    uint256 public constant NFT20_NFT_VALUE = 100 * 10**18;\r\n    address public constant REFERRAL = 0x073Ab1C0CAd3677cDe9BDb0cDEEDC2085c029579;\r\n\r\n    function _approve(address _operator, address _token) internal {\r\n        if(!IERC721(_token).isApprovedForAll(address(this), _operator)) {\r\n            IERC721(_token).setApprovalForAll(_operator, true);\r\n        }\r\n    }\r\n\r\n    function sellERC721ForERC20Equivalent(\r\n        bytes memory data\r\n    ) external returns (address _erc20Address, uint256 _erc20Amount) {        \r\n        address _fromERC721;\r\n        uint256[] memory _ids;\r\n        \r\n        (_fromERC721, _ids) = abi.decode(\r\n            data,\r\n            (address, uint256[])\r\n        );\r\n\r\n        // NFT20 ERC20 for the _fromERC721\r\n        _erc20Address = Nft20Registry.nftToErc20(_fromERC721);\r\n\r\n        // save gas in case only a single ERC721 needs to be sold\r\n        if(_ids.length == 1) {\r\n            // transfer the token to NFT20 ERC20\r\n            IERC721(_fromERC721).safeTransferFrom(\r\n                address(this),\r\n                _erc20Address,\r\n                _ids[0],\r\n                abi.encodePacked(REFERRAL) // referral\r\n            );\r\n        }\r\n        // in case multiple ERC721(s) need to be sold\r\n        else {\r\n            // approve tokens to the NFT20 ERC20 contract\r\n            _approve(_erc20Address, _fromERC721);\r\n            // mint NFT20 ERC20 \r\n            INFT20Pair(_erc20Address).multi721Deposit(\r\n                _ids,\r\n                REFERRAL // referral\r\n            );\r\n        }\r\n\r\n        return (\r\n            _erc20Address,\r\n            IERC20(_erc20Address).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function sellERC1155ForERC20Equivalent(\r\n        bytes memory data\r\n    ) external returns (address _erc20Address, uint256 _erc20Amount) {\r\n        address _fromERC1155;\r\n        uint256 _id;\r\n        uint256 _amount;\r\n        \r\n        (_fromERC1155, _id, _amount) = abi.decode(\r\n            data,\r\n            (address, uint256, uint256)\r\n        );\r\n\r\n        // NFT20 ERC20 for the _fromERC1155\r\n        _erc20Address = Nft20Registry.nftToErc20(_fromERC1155);\r\n\r\n        // transfer the token to NFT20 ERC20\r\n        IERC1155(_fromERC1155).safeTransferFrom(\r\n            address(this),\r\n            _erc20Address,\r\n            _id,\r\n            _amount,\r\n            abi.encodePacked(REFERRAL) // referral\r\n        );\r\n        return (\r\n            _erc20Address,\r\n            IERC20(_erc20Address).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function sellERC1155BatchForERC20Equivalent(\r\n        bytes memory data\r\n    ) external returns (address _erc20Address, uint256 _erc20Amount) {\r\n        address _fromERC1155;\r\n        uint256[] memory _ids;\r\n        uint256[] memory _amounts;\r\n\r\n        (_fromERC1155, _ids, _amounts) = abi.decode(\r\n            data,\r\n            (address, uint256[], uint256[])\r\n        );\r\n\r\n        // NFT20 ERC20 for the _fromERC1155\r\n        _erc20Address = Nft20Registry.nftToErc20(_fromERC1155);\r\n\r\n        // transfer the tokens to NFT20 ERC20\r\n        IERC1155(_fromERC1155).safeBatchTransferFrom(\r\n            address(this),\r\n            _erc20Address,\r\n            _ids,\r\n            _amounts,\r\n            abi.encodePacked(REFERRAL) // referral\r\n        );\r\n        return (\r\n            _erc20Address,\r\n            IERC20(_erc20Address).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function buyAssetsForErc20(bytes memory data, address recipient) external {\r\n        address _nftAddr;\r\n        address _fromERC20;\r\n        uint256[] memory _ids;\r\n        uint256[] memory _amounts;\r\n        \r\n        (_nftAddr, _fromERC20, _ids, _amounts) = abi.decode(\r\n            data,\r\n            (address, address, uint256[], uint256[])\r\n        );\r\n\r\n        // Handle special cases where we cannot directly send NFTs to the recipient\r\n        if(\r\n            _fromERC20 == 0x22C4AD011Cce6a398B15503e0aB64286568933Ed || // Doki Doki\r\n            _fromERC20 == 0x303Af77Cf2774AABff12462C110A0CCf971D7DbE || // Node Runners\r\n            _fromERC20 == 0xaDBEBbd65a041E3AEb474FE9fe6939577eB2544F || // Chonker Finance\r\n            _fromERC20 == 0x57C31c042Cb2F6a50F3dA70ADe4fEE20C86B7493    // Block Art         \r\n        ) {\r\n            for(uint256 i = 0; i < _ids.length; i++) {\r\n                uint256[] memory _tempIds = new uint256[](1);\r\n                uint256[] memory _tempAmounts = new uint256[](1);\r\n                _tempIds[0] =  _ids[i];\r\n                _tempAmounts[0] =  _amounts[i];\r\n                INFT20Pair(_fromERC20).withdraw(_tempIds, _tempAmounts);\r\n                \r\n                // transfer the ERC721 to the recipient\r\n                if(_fromERC20 == 0x57C31c042Cb2F6a50F3dA70ADe4fEE20C86B7493) {\r\n                    IERC721(_nftAddr).transferFrom(address(this), recipient, _ids[i]);\r\n                }\r\n            }\r\n            // transfer the ERC1155 to the recipient\r\n            IERC1155(_nftAddr).safeBatchTransferFrom(address(this), recipient, _ids, _amounts, \"\");\r\n        }\r\n        // send NFTs to the recipient\r\n        else {\r\n            INFT20Pair(_fromERC20).withdraw(_ids, _amounts, recipient);\r\n        }\r\n    }\r\n\r\n    function estimateBatchAssetPriceInErc20(bytes memory data) public view returns(address[] memory erc20Addrs, uint256[] memory erc20Amounts) {\r\n        // get nft details\r\n        NftDetails[] memory nftDetails;\r\n        (nftDetails) = abi.decode(\r\n            data,\r\n            (NftDetails[])\r\n        );\r\n\r\n        // initialize return variables\r\n        erc20Addrs = new address[](nftDetails.length); \r\n        erc20Amounts = new uint256[](nftDetails.length);\r\n\r\n        for (uint256 i = 0; i < nftDetails.length; i++) {\r\n            // populate equivalent ERC20 \r\n            erc20Addrs[i] = Nft20Registry.nftToErc20(nftDetails[i].nftAddr);\r\n            // nft should be supported\r\n            require(erc20Addrs[i] != address(0), \"estimateBatchAssetPriceInErc20: unsupported nft\");\r\n            // calculate token amount needed\r\n            for (uint256 j = 0; j < nftDetails[i].tokenIds.length; j++) {\r\n                erc20Amounts[i] = erc20Amounts[i] + nftDetails[i].amounts[j]*NFT20_NFT_VALUE;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"NFT20_NFT_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Nft20Registry\",\"outputs\":[{\"internalType\":\"contract INft20Registry\",\"name\":\"\",\"type\":\"INft20Registry\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRAL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"estimateBatchAssetPriceInErc20\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"erc20Addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"erc20Amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Nft20Market","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e1d95a0e07bde98e74e4fca007d3f2381d2b36fb467101e8ff309212bf8fd767"}]}