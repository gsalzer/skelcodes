{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.3;\r\n\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\nlibrary Clones {\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create2(0, ptr, 0x37, salt)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create2 failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\r\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\r\n            mstore(add(ptr, 0x4c), salt)\r\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\r\n            predicted := keccak256(add(ptr, 0x37), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\r\n        return predictDeterministicAddress(implementation, salt, address(this));\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\ncontract Governance is ReentrancyGuard {\r\n\r\n\tuint constant public governance_challenging_period = 10 days;\r\n\tuint constant public governance_freeze_period = 30 days;\r\n\r\n\taddress public votingTokenAddress;\r\n\taddress public governedContractAddress;\r\n\r\n\tmapping(address => uint) public balances;\r\n\r\n\tVotedValue[] public votedValues;\r\n\tmapping(string => VotedValue) public votedValuesMap;\r\n\r\n\r\n\tconstructor(address _governedContractAddress, address _votingTokenAddress){\r\n\t\tinit(_governedContractAddress, _votingTokenAddress);\r\n\t}\r\n\r\n\tfunction init(address _governedContractAddress, address _votingTokenAddress) public {\r\n\t\trequire(governedContractAddress == address(0), \"governance already initialized\");\r\n\t\tgovernedContractAddress = _governedContractAddress;\r\n\t\tvotingTokenAddress = _votingTokenAddress;\r\n\t}\r\n\r\n\tfunction addressBelongsToGovernance(address addr) public view returns (bool) {\r\n\t\tfor (uint i = 0; i < votedValues.length; i++)\r\n\t\t\tif (address(votedValues[i]) == addr)\r\n\t\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction isUntiedFromAllVotes(address addr) public view returns (bool) {\r\n\t\tfor (uint i = 0; i < votedValues.length; i++)\r\n\t\t\tif (votedValues[i].hasVote(addr))\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction addVotedValue(string memory name, VotedValue votedValue) external {\r\n\t\trequire(msg.sender == governedContractAddress, \"not authorized\");\r\n\t\tvotedValues.push(votedValue);\r\n\t\tvotedValuesMap[name] = votedValue;\r\n\t}\r\n\r\n\r\n\t// deposit\r\n\r\n\tfunction deposit(uint amount) payable external {\r\n\t\tdeposit(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction deposit(address from, uint amount) nonReentrant payable public {\r\n\t\trequire(from == msg.sender || addressBelongsToGovernance(msg.sender), \"not allowed\");\r\n\t\tif (votingTokenAddress == address(0))\r\n\t\t\trequire(msg.value == amount, \"wrong amount received\");\r\n\t\telse {\r\n\t\t\trequire(msg.value == 0, \"don't send ETH\");\r\n\t\t\trequire(IERC20(votingTokenAddress).transferFrom(from, address(this), amount), \"failed to pull gov deposit\");\r\n\t\t}\r\n\t\tbalances[from] += amount;\r\n\t}\r\n\r\n\r\n\t// withdrawal functions\r\n\r\n\tfunction withdraw() external {\r\n\t\twithdraw(balances[msg.sender]);\r\n\t}\r\n\r\n\tfunction withdraw(uint amount) nonReentrant public {\r\n\t\trequire(amount > 0, \"zero withdrawal requested\");\r\n\t\trequire(amount <= balances[msg.sender], \"not enough balance\");\r\n\t\trequire(isUntiedFromAllVotes(msg.sender), \"some votes not removed yet\");\r\n\t\tbalances[msg.sender] -= amount;\r\n\t\tif (votingTokenAddress == address(0))\r\n\t\t\tpayable(msg.sender).transfer(amount);\r\n\t\telse\r\n\t\t\trequire(IERC20(votingTokenAddress).transfer(msg.sender, amount), \"failed to withdraw gov deposit\");\r\n\t}\r\n}\r\n\r\n\r\nabstract contract VotedValue is ReentrancyGuard {\r\n\tGovernance public governance;\r\n\tuint public challenging_period_start_ts;\r\n\tmapping(address => bool) public hasVote;\r\n\r\n\tconstructor(Governance _governance){\r\n\t\tgovernance = _governance;\r\n\t}\r\n\r\n\tfunction checkVoteChangeLock() view public {\r\n\t\trequire(challenging_period_start_ts + governance.governance_challenging_period() + governance.governance_freeze_period() < block.timestamp, \"you cannot change your vote yet\");\r\n\t}\r\n\r\n\tfunction checkChallengingPeriodExpiry() view public {\r\n\t\trequire(block.timestamp > challenging_period_start_ts + governance.governance_challenging_period(), \"challenging period not expired yet\");\r\n\t}\r\n}\r\n\r\n\r\ncontract VotedValueUint is VotedValue {\r\n\r\n\tfunction(uint) external validationCallback;\r\n\tfunction(uint) external commitCallback;\r\n\r\n\tuint public leader;\r\n\tuint public current_value;\r\n\r\n\tmapping(address => uint) public choices;\r\n\tmapping(uint => uint) public votesByValue;\r\n\tmapping(uint => mapping(address => uint)) public votesByValueAddress;\r\n\r\n\tconstructor() VotedValue(Governance(address(0))) {}\r\n\r\n\t// constructor(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) VotedValue(_governance) {\r\n\t// \tleader = initial_value;\r\n\t// \tcurrent_value = initial_value;\r\n\t// \tvalidationCallback = _validationCallback;\r\n\t// \tcommitCallback = _commitCallback;\r\n\t// }\r\n\r\n\tfunction init(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = _governance;\r\n\t\tleader = initial_value;\r\n\t\tcurrent_value = initial_value;\r\n\t\tvalidationCallback = _validationCallback;\r\n\t\tcommitCallback = _commitCallback;\r\n\t}\r\n\r\n\tfunction vote(uint value) nonReentrant external {\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction voteAndDeposit(uint value, uint amount) nonReentrant payable external {\r\n\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction _vote(uint value) private {\r\n\t\tvalidationCallback(value);\r\n\t\tuint prev_choice = choices[msg.sender];\r\n\t\tbool hadVote = hasVote[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\r\n\t\t// first, remove votes from the previous choice\r\n\t\tif (hadVote)\r\n\t\t\tremoveVote(prev_choice);\r\n\r\n\t\t// then, add them to the new choice\r\n\t\tuint balance = governance.balances(msg.sender);\r\n\t\trequire(balance > 0, \"no balance\");\r\n\t\tvotesByValue[value] += balance;\r\n\t\tvotesByValueAddress[value][msg.sender] = balance;\r\n\t\tchoices[msg.sender] = value;\r\n\t\thasVote[msg.sender] = true;\r\n\r\n\t\t// check if the leader has just changed\r\n\t\tif (votesByValue[value] > votesByValue[leader]){\r\n\t\t\tleader = value;\r\n\t\t\tchallenging_period_start_ts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unvote() external {\r\n\t\tif (!hasVote[msg.sender])\r\n\t\t\treturn;\r\n\t\tuint prev_choice = choices[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\t\t\r\n\t\tremoveVote(prev_choice);\r\n\t\tdelete choices[msg.sender];\r\n\t\tdelete hasVote[msg.sender];\r\n\t}\r\n\r\n\tfunction removeVote(uint value) internal {\r\n\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\r\n\t\tvotesByValueAddress[value][msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction commit() nonReentrant external {\r\n\t\trequire(leader != current_value, \"already equal to leader\");\r\n\t\tcheckChallengingPeriodExpiry();\r\n\t\tcurrent_value = leader;\r\n\t\tcommitCallback(leader);\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract VotedValueUintArray is VotedValue {\r\n\r\n\tfunction(uint[] memory) external validationCallback;\r\n\tfunction(uint[] memory) external commitCallback;\r\n\r\n\tuint[] public leader;\r\n\tuint[] public current_value;\r\n\r\n\tmapping(address => uint[]) public choices;\r\n\tmapping(bytes32 => uint) public votesByValue;\r\n\tmapping(bytes32 => mapping(address => uint)) public votesByValueAddress;\r\n\r\n\tconstructor() VotedValue(Governance(address(0))) {}\r\n\r\n\t// constructor(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) VotedValue(_governance) {\r\n\t// \tleader = initial_value;\r\n\t// \tcurrent_value = initial_value;\r\n\t// \tvalidationCallback = _validationCallback;\r\n\t// \tcommitCallback = _commitCallback;\r\n\t// }\r\n\r\n\tfunction init(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = _governance;\r\n\t\tleader = initial_value;\r\n\t\tcurrent_value = initial_value;\r\n\t\tvalidationCallback = _validationCallback;\r\n\t\tcommitCallback = _commitCallback;\r\n\t}\r\n\r\n\tfunction equal(uint[] memory a1, uint[] memory a2) public pure returns (bool) {\r\n\t\tif (a1.length != a2.length)\r\n\t\t\treturn false;\r\n\t\tfor (uint i = 0; i < a1.length; i++)\r\n\t\t\tif (a1[i] != a2[i])\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getKey(uint[] memory a) public pure returns (bytes32){\r\n\t\treturn keccak256(abi.encodePacked(a));\r\n\t}\r\n\r\n\tfunction vote(uint[] memory value) nonReentrant external {\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction voteAndDeposit(uint[] memory value, uint amount) nonReentrant payable external {\r\n\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction _vote(uint[] memory value) private {\r\n\t\tvalidationCallback(value);\r\n\t\tuint[] storage prev_choice = choices[msg.sender];\r\n\t\tbool hadVote = hasVote[msg.sender];\r\n\t\tif (equal(prev_choice, leader))\r\n\t\t\tcheckVoteChangeLock();\r\n\r\n\t\t// remove one's vote from the previous choice first\r\n\t\tif (hadVote)\r\n\t\t\tremoveVote(prev_choice);\r\n\r\n\t\t// then, add it to the new choice, if any\r\n\t\tbytes32 key = getKey(value);\r\n\t\tuint balance = governance.balances(msg.sender);\r\n\t\trequire(balance > 0, \"no balance\");\r\n\t\tvotesByValue[key] += balance;\r\n\t\tvotesByValueAddress[key][msg.sender] = balance;\r\n\t\tchoices[msg.sender] = value;\r\n\t\thasVote[msg.sender] = true;\r\n\r\n\t\t// check if the leader has just changed\r\n\t\tif (votesByValue[key] > votesByValue[getKey(leader)]){\r\n\t\t\tleader = value;\r\n\t\t\tchallenging_period_start_ts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unvote() external {\r\n\t\tif (!hasVote[msg.sender])\r\n\t\t\treturn;\r\n\t\tuint[] storage prev_choice = choices[msg.sender];\r\n\t\tif (equal(prev_choice, leader))\r\n\t\t\tcheckVoteChangeLock();\r\n\t\t\r\n\t\tremoveVote(prev_choice);\r\n\t\tdelete choices[msg.sender];\r\n\t\tdelete hasVote[msg.sender];\r\n\t}\r\n\r\n\tfunction removeVote(uint[] memory value) internal {\r\n\t\tbytes32 key = getKey(value);\r\n\t\tvotesByValue[key] -= votesByValueAddress[key][msg.sender];\r\n\t\tvotesByValueAddress[key][msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction commit() nonReentrant external {\r\n\t\trequire(!equal(leader, current_value), \"already equal to leader\");\r\n\t\tcheckChallengingPeriodExpiry();\r\n\t\tcurrent_value = leader;\r\n\t\tcommitCallback(leader);\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract VotedValueAddress is VotedValue {\r\n\r\n\tfunction(address) external validationCallback;\r\n\tfunction(address) external commitCallback;\r\n\r\n\taddress public leader;\r\n\taddress public current_value;\r\n\r\n\t// mapping(who => value)\r\n\tmapping(address => address) public choices;\r\n\r\n\t// mapping(value => votes)\r\n\tmapping(address => uint) public votesByValue;\r\n\r\n\t// mapping(value => mapping(who => votes))\r\n\tmapping(address => mapping(address => uint)) public votesByValueAddress;\r\n\r\n\tconstructor() VotedValue(Governance(address(0))) {}\r\n\r\n\t// constructor(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) VotedValue(_governance) {\r\n\t// \tleader = initial_value;\r\n\t// \tcurrent_value = initial_value;\r\n\t// \tvalidationCallback = _validationCallback;\r\n\t// \tcommitCallback = _commitCallback;\r\n\t// }\r\n\r\n\tfunction init(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = _governance;\r\n\t\tleader = initial_value;\r\n\t\tcurrent_value = initial_value;\r\n\t\tvalidationCallback = _validationCallback;\r\n\t\tcommitCallback = _commitCallback;\r\n\t}\r\n\r\n\tfunction vote(address value) nonReentrant external {\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction voteAndDeposit(address value, uint amount) nonReentrant payable external {\r\n\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction _vote(address value) private {\r\n\t\tvalidationCallback(value);\r\n\t\taddress prev_choice = choices[msg.sender];\r\n\t\tbool hadVote = hasVote[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\r\n\t\t// first, remove votes from the previous choice\r\n\t\tif (hadVote)\r\n\t\t\tremoveVote(prev_choice);\r\n\r\n\t\t// then, add them to the new choice\r\n\t\tuint balance = governance.balances(msg.sender);\r\n\t\trequire(balance > 0, \"no balance\");\r\n\t\tvotesByValue[value] += balance;\r\n\t\tvotesByValueAddress[value][msg.sender] = balance;\r\n\t\tchoices[msg.sender] = value;\r\n\t\thasVote[msg.sender] = true;\r\n\r\n\t\t// check if the leader has just changed\r\n\t\tif (votesByValue[value] > votesByValue[leader]){\r\n\t\t\tleader = value;\r\n\t\t\tchallenging_period_start_ts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unvote() external {\r\n\t\tif (!hasVote[msg.sender])\r\n\t\t\treturn;\r\n\t\taddress prev_choice = choices[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\t\t\r\n\t\tremoveVote(prev_choice);\r\n\t\tdelete choices[msg.sender];\r\n\t\tdelete hasVote[msg.sender];\r\n\t}\r\n\r\n\tfunction removeVote(address value) internal {\r\n\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\r\n\t\tvotesByValueAddress[value][msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction commit() nonReentrant external {\r\n\t\trequire(leader != current_value, \"already equal to leader\");\r\n\t\tcheckChallengingPeriodExpiry();\r\n\t\tcurrent_value = leader;\r\n\t\tcommitCallback(leader);\r\n\t}\r\n}\r\n\r\n\r\ncontract VotedValueFactory {\r\n\r\n\taddress public votedValueUintMaster;\r\n\taddress public votedValueUintArrayMaster;\r\n\taddress public votedValueAddressMaster;\r\n\r\n\tconstructor(address _votedValueUintMaster, address _votedValueUintArrayMaster, address _votedValueAddressMaster) {\r\n\t\tvotedValueUintMaster = _votedValueUintMaster;\r\n\t\tvotedValueUintArrayMaster = _votedValueUintArrayMaster;\r\n\t\tvotedValueAddressMaster = _votedValueAddressMaster;\r\n\t}\r\n\r\n\r\n\tfunction createVotedValueUint(Governance governance, uint initial_value, function(uint) external validationCallback, function(uint) external commitCallback) external returns (VotedValueUint) {\r\n\t\tVotedValueUint vv = VotedValueUint(Clones.clone(votedValueUintMaster));\r\n\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\r\n\t\treturn vv;\r\n\t}\r\n\r\n\tfunction createVotedValueUintArray(Governance governance, uint[] memory initial_value, function(uint[] memory) external validationCallback, function(uint[] memory) external commitCallback) external returns (VotedValueUintArray) {\r\n\t\tVotedValueUintArray vv = VotedValueUintArray(Clones.clone(votedValueUintArrayMaster));\r\n\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\r\n\t\treturn vv;\r\n\t}\r\n\r\n\tfunction createVotedValueAddress(Governance governance, address initial_value, function(address) external validationCallback, function(address) external commitCallback) external returns (VotedValueAddress) {\r\n\t\tVotedValueAddress vv = VotedValueAddress(Clones.clone(votedValueAddressMaster));\r\n\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\r\n\t\treturn vv;\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract GovernanceFactory {\r\n\r\n\taddress public governanceMaster;\r\n\r\n\tconstructor(address _governanceMaster) {\r\n\t\tgovernanceMaster = _governanceMaster;\r\n\t}\r\n\r\n\tfunction createGovernance(address governedContractAddress, address votingTokenAddress) external returns (Governance) {\r\n\t\tGovernance governance = Governance(Clones.clone(governanceMaster));\r\n\t\tgovernance.init(governedContractAddress, votingTokenAddress);\r\n\t\treturn governance;\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n// The purpose of the library is to separate some of the code out of the Export/Import contracts and keep their sizes under the 24KiB limit\r\n\r\n\r\nlibrary CounterstakeLibrary {\r\n\r\n\tenum Side {no, yes}\r\n\r\n\t// small values (bool, uint32, ...) are grouped together in order to be packed efficiently\r\n\tstruct Claim {\r\n\t\tuint amount;\r\n\t//\tint reward;\r\n\r\n\t\taddress payable recipient_address; // 20 bytes, 12 bytes left\r\n\t\tuint32 txts;\r\n\t\tuint32 ts;\r\n\t\t\r\n\t\taddress payable claimant_address;\r\n\t\tuint32 expiry_ts;\r\n\t\tuint16 period_number;\r\n\t\tSide current_outcome;\r\n\t\tbool is_large;\r\n\t\tbool withdrawn;\r\n\t\tbool finished;\r\n\t\t\r\n\t\tstring sender_address;\r\n\t//\tstring txid;\r\n\t\tstring data;\r\n\t\tuint yes_stake;\r\n\t\tuint no_stake;\r\n\t//\tuint challenging_target;\r\n\t}\r\n\r\n\tstruct Settings {\r\n\t\taddress tokenAddress;\r\n\t\tuint16 ratio100;// = 100;\r\n\t\tuint16 counterstake_coef100;// = 150;\r\n\t\tuint32 min_tx_age;\r\n\t\tuint min_stake;\r\n\t\tuint[] challenging_periods;// = [12 hours, 3 days, 1 weeks, 30 days];\r\n\t\tuint[] large_challenging_periods;// = [3 days, 1 weeks, 30 days];\r\n\t\tuint large_threshold;\r\n\t}\r\n\r\n\tevent NewClaim(uint indexed claim_num, address author_address, string sender_address, address recipient_address, string txid, uint32 txts, uint amount, int reward, uint stake, string data, uint32 expiry_ts);\r\n\tevent NewChallenge(uint indexed claim_num, address author_address, uint stake, Side outcome, Side current_outcome, uint yes_stake, uint no_stake, uint32 expiry_ts, uint challenging_target);\r\n\tevent FinishedClaim(uint indexed claim_num, Side outcome);\r\n\r\n\r\n\tstruct ClaimRequest {\r\n\t\tstring txid;\r\n\t\tuint32 txts;\r\n\t\tuint amount;\r\n\t\tint reward;\r\n\t\tuint stake;\r\n\t\tuint required_stake;\r\n\t\taddress payable recipient_address;\r\n\t\tstring sender_address;\r\n\t\tstring data;\r\n\t}\r\n\r\n\tfunction claim(\r\n\t\tSettings storage settings,\r\n\t\tmapping(string => uint) storage claim_nums,\r\n\t\tmapping(uint => Claim) storage claims,\r\n\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes,\r\n\t\tuint claim_num,\r\n\t\tClaimRequest memory req\r\n\t) external {\r\n\t\trequire(req.amount > 0, \"0 claim\");\r\n\t\trequire(req.stake >= req.required_stake, \"the stake is too small\");\r\n\t\trequire(block.timestamp >= req.txts + settings.min_tx_age, \"too early\");\r\n\t\tif (req.recipient_address == address(0))\r\n\t\t\treq.recipient_address = payable(msg.sender);\r\n\t\tif (req.reward < 0)\r\n\t\t\trequire(req.recipient_address == payable(msg.sender), \"the sender disallowed third-party claiming by setting a negative reward\");\r\n\t\tstring memory claim_id = getClaimId(req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.data);\r\n\t\trequire(claim_nums[claim_id] == 0, \"this transfer has already been claimed\");\r\n\t\tbool is_large = (settings.large_threshold > 0 && req.stake >= settings.large_threshold);\r\n\t\tuint32 expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, 0, is_large)); // might wrap\r\n\t\tclaim_nums[claim_id] = claim_num;\r\n\t//\tuint challenging_target = req.stake * settings.counterstake_coef100/100;\r\n\t\tclaims[claim_num] = Claim({\r\n\t\t\tamount: req.amount,\r\n\t\t//\treward: req.reward,\r\n\t\t\trecipient_address: req.recipient_address,\r\n\t\t\tclaimant_address: payable(msg.sender),\r\n\t\t\tsender_address: req.sender_address,\r\n\t\t//\ttxid: req.txid,\r\n\t\t\tdata: req.data,\r\n\t\t\tyes_stake: req.stake,\r\n\t\t\tno_stake: 0,\r\n\t\t\tcurrent_outcome: Side.yes,\r\n\t\t\tis_large: is_large,\r\n\t\t\tperiod_number: 0,\r\n\t\t\ttxts: req.txts,\r\n\t\t\tts: uint32(block.timestamp),\r\n\t\t\texpiry_ts: expiry_ts,\r\n\t\t//\tchallenging_target: req.stake * settings.counterstake_coef100/100,\r\n\t\t\twithdrawn: false,\r\n\t\t\tfinished: false\r\n\t\t});\r\n\t\tstakes[claim_num][Side.yes][msg.sender] = req.stake;\r\n\t\temit NewClaim(claim_num, msg.sender, req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.stake, req.data, expiry_ts);\r\n\t//\treturn claim_id;\r\n\t}\r\n\r\n\r\n\tfunction challenge(\r\n\t\tSettings storage settings, \r\n\t\tClaim storage c,\r\n\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \r\n\t\tuint claim_num, \r\n\t\tSide stake_on, \r\n\t\tuint stake\r\n\t) external {\r\n\t\trequire(block.timestamp < c.expiry_ts, \"the challenging period has expired\");\r\n\t\trequire(stake_on != c.current_outcome, \"this outcome is already current\");\r\n\t\tuint excess;\r\n\t\tuint challenging_target = (c.current_outcome == Side.yes ? c.yes_stake : c.no_stake) * settings.counterstake_coef100/100;\r\n\t\t{ // circumvent stack too deep\r\n\t\t\tuint stake_on_proposed_outcome = (stake_on == Side.yes ? c.yes_stake : c.no_stake) + stake;\r\n\t\t\tbool would_override_current_outcome = stake_on_proposed_outcome >= challenging_target;\r\n\t\t\texcess = would_override_current_outcome ? stake_on_proposed_outcome - challenging_target : 0;\r\n\t\t\tuint accepted_stake = stake - excess;\r\n\t\t\tif (stake_on == Side.yes)\r\n\t\t\t\tc.yes_stake += accepted_stake;\r\n\t\t\telse\r\n\t\t\t\tc.no_stake += accepted_stake;\r\n\t\t\tif (would_override_current_outcome){\r\n\t\t\t\tc.period_number++;\r\n\t\t\t\tc.current_outcome = stake_on;\r\n\t\t\t\tc.expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, c.period_number, c.is_large));\r\n\t\t\t\tchallenging_target = challenging_target * settings.counterstake_coef100/100;\r\n\t\t\t}\r\n\t\t\tstakes[claim_num][stake_on][msg.sender] += accepted_stake;\r\n\t\t}\r\n\t\temit NewChallenge(claim_num, msg.sender, stake, stake_on, c.current_outcome, c.yes_stake, c.no_stake, c.expiry_ts, challenging_target);\r\n\t\tif (excess > 0){\r\n\t\t\tif (settings.tokenAddress == address(0))\r\n\t\t\t\tpayable(msg.sender).transfer(excess);\r\n\t\t\telse\r\n\t\t\t\trequire(IERC20(settings.tokenAddress).transfer(msg.sender, excess), \"failed to transfer the token\");\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\tfunction finish(\r\n\t\tClaim storage c,\r\n\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \r\n\t\tuint claim_num, \r\n\t\taddress payable to_address\r\n\t) external \r\n\treturns (bool, bool, uint)\r\n\t{\r\n\t\trequire(block.timestamp > c.expiry_ts, \"challenging period is still ongoing\");\r\n\t\tif (to_address == address(0))\r\n\t\t\tto_address = payable(msg.sender);\r\n\t\t\r\n\t\tbool is_winning_claimant = (to_address == c.claimant_address && c.current_outcome == Side.yes);\r\n\t\trequire(!(is_winning_claimant && c.withdrawn), \"already withdrawn\");\r\n\t\tuint won_stake;\r\n\t\t{ // circumvent stack too deep\r\n\t\t\tuint my_stake = stakes[claim_num][c.current_outcome][to_address];\r\n\t\t\trequire(my_stake > 0 || is_winning_claimant, \"you are not the recipient and you didn't stake on the winning outcome or you have already withdrawn\");\r\n\t\t\tuint winning_stake = c.current_outcome == Side.yes ? c.yes_stake : c.no_stake;\r\n\t\t\tif (my_stake > 0)\r\n\t\t\t\twon_stake = (c.yes_stake + c.no_stake) * my_stake / winning_stake;\r\n\t\t}\r\n\t\tif (is_winning_claimant)\r\n\t\t\tc.withdrawn = true;\r\n\t\tbool finished;\r\n\t\tif (!c.finished){\r\n\t\t\tfinished = true;\r\n\t\t\tc.finished = true;\r\n\t\t//\tSide losing_outcome = outcome == Side.yes ? Side.no : Side.yes;\r\n\t\t//\tdelete stakes[claim_id][losing_outcome]; // can't purge the stakes that will never be claimed\r\n\t\t\temit FinishedClaim(claim_num, c.current_outcome);\r\n\t\t}\r\n\t\tdelete stakes[claim_num][c.current_outcome][to_address];\r\n\t\treturn (finished, is_winning_claimant, won_stake);\r\n\t}\r\n\r\n\r\n\r\n\tfunction getChallengingPeriod(Settings storage settings, uint16 period_number, bool bLarge) public view returns (uint) {\r\n\t\tuint[] storage periods = bLarge ? settings.large_challenging_periods : settings.challenging_periods;\r\n\t\tif (period_number > periods.length - 1)\r\n\t\t\tperiod_number = uint16(periods.length - 1);\r\n\t\treturn periods[period_number];\r\n\t}\r\n\r\n\tfunction validateChallengingPeriods(uint[] memory periods) pure external {\r\n\t\trequire(periods.length > 0, \"empty periods\");\r\n\t\tuint prev_period = 0;\r\n\t\tfor (uint i = 0; i < periods.length; i++) {\r\n\t\t\trequire(periods[i] < 3 * 365 days, \"some periods are longer than 3 years\");\r\n\t\t\trequire(periods[i] >= prev_period, \"subsequent periods cannot get shorter\");\r\n\t\t\tprev_period = periods[i];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getClaimId(string memory sender_address, address recipient_address, string memory txid, uint32 txts, uint amount, int reward, string memory data) public pure returns (string memory){\r\n\t\treturn string(abi.encodePacked(sender_address, '_', toAsciiString(recipient_address), '_', txid, '_', uint2str(txts), '_', uint2str(amount), '_', int2str(reward), '_', data));\r\n\t}\r\n\r\n\r\n\tfunction uint2str(uint256 _i) private pure returns (string memory) {\r\n\t\tif (_i == 0)\r\n\t\t\treturn \"0\";\r\n\t\tuint256 j = _i;\r\n\t\tuint256 length;\r\n\t\twhile (j != 0) {\r\n\t\t\tlength++;\r\n\t\t\tj /= 10;\r\n\t\t}\r\n\t\tbytes memory bstr = new bytes(length);\r\n\t\tuint256 k = length;\r\n\t\tj = _i;\r\n\t\twhile (j != 0) {\r\n\t\t\tbstr[--k] = bytes1(uint8(48 + j % 10));\r\n\t\t\tj /= 10;\r\n\t\t}\r\n\t\treturn string(bstr);\r\n\t}\r\n\r\n\tfunction int2str(int256 _i) private pure returns (string memory) {\r\n\t\trequire(_i < type(int).max, \"int too large\");\r\n\t\treturn _i >= 0 ? uint2str(uint(_i)) : string(abi.encodePacked('-', uint2str(uint(-_i))));\r\n\t}\r\n\r\n\tfunction toAsciiString(address x) private pure returns (string memory) {\r\n\t\tbytes memory s = new bytes(40);\r\n\t\tfor (uint i = 0; i < 20; i++) {\r\n\t\t\tbytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\r\n\t\t\tbytes1 hi = bytes1(uint8(b) / 16);\r\n\t\t\tbytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n\t\t\ts[2*i] = char(hi);\r\n\t\t\ts[2*i+1] = char(lo);            \r\n\t\t}\r\n\t\treturn string(s);\r\n\t}\r\n\r\n\tfunction char(bytes1 b) private pure returns (bytes1 c) {\r\n\t\tif (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\r\n\t\telse return bytes1(uint8(b) + 0x57);\r\n\t}\r\n\r\n\tfunction isContract(address _addr) public view returns (bool){\r\n\t\tuint32 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (size > 0);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\ninterface CounterstakeReceiver {\r\n\tfunction onReceivedFromClaim(uint claim_num, uint net_claimed_amount, uint won_stake, string memory sender_address, address claim_recipient_address, string memory data) external;\r\n}\r\n\r\nabstract contract Counterstake is ReentrancyGuard {\r\n\r\n\tevent NewClaim(uint indexed claim_num, address author_address, string sender_address, address recipient_address, string txid, uint32 txts, uint amount, int reward, uint stake, string data, uint32 expiry_ts);\r\n\tevent NewChallenge(uint indexed claim_num, address author_address, uint stake, CounterstakeLibrary.Side outcome, CounterstakeLibrary.Side current_outcome, uint yes_stake, uint no_stake, uint32 expiry_ts, uint challenging_target);\r\n\tevent FinishedClaim(uint indexed claim_num, CounterstakeLibrary.Side outcome);\r\n\r\n\tGovernance public governance;\r\n\tCounterstakeLibrary.Settings public settings;\r\n\r\n\r\n\tuint64 public last_claim_num;\r\n\tuint64[] public ongoing_claim_nums;\r\n\tmapping(uint => uint) public num2index;\r\n\r\n\tmapping(string => uint) public claim_nums;\r\n\tmapping(uint => CounterstakeLibrary.Claim) private claims;\r\n\tmapping(uint => mapping(CounterstakeLibrary.Side => mapping(address => uint))) public stakes;\r\n\r\n\tfunction getClaim(uint claim_num) external view returns (CounterstakeLibrary.Claim memory) {\r\n\t\treturn claims[claim_num];\r\n\t}\r\n\r\n\tfunction getClaim(string memory claim_id) external view returns (CounterstakeLibrary.Claim memory) {\r\n\t\treturn claims[claim_nums[claim_id]];\r\n\t}\r\n\r\n\tfunction getOngoingClaimNums() external view returns (uint64[] memory) {\r\n\t\treturn ongoing_claim_nums;\r\n\t}\r\n\r\n\r\n\tconstructor (address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods) {\r\n\t\tinitCounterstake(_tokenAddr, _counterstake_coef100, _ratio100, _large_threshold, _challenging_periods, _large_challenging_periods);\r\n\t}\r\n\r\n\tfunction initCounterstake(address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods) public {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tsettings = CounterstakeLibrary.Settings({\r\n\t\t\ttokenAddress: _tokenAddr,\r\n\t\t\tcounterstake_coef100: _counterstake_coef100 > 100 ? _counterstake_coef100 : 150,\r\n\t\t\tratio100: _ratio100 > 0 ? _ratio100 : 100,\r\n\t\t\tmin_stake: 0,\r\n\t\t\tmin_tx_age: 0,\r\n\t\t\tchallenging_periods: _challenging_periods,\r\n\t\t\tlarge_challenging_periods: _large_challenging_periods,\r\n\t\t\tlarge_threshold: _large_threshold\r\n\t\t});\r\n\t}\r\n\r\n\t/*\r\n\tmodifier onlyETH(){\r\n\t\trequire(settings.tokenAddress == address(0), \"ETH only\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyERC20(){\r\n\t\trequire(settings.tokenAddress != address(0), \"ERC20 only\");\r\n\t\t_;\r\n\t}*/\r\n\r\n\tmodifier onlyVotedValueContract(){\r\n\t\trequire(governance.addressBelongsToGovernance(msg.sender), \"not from voted value contract\");\r\n\t\t_;\r\n\t}\r\n\r\n\t// would be happy to call this from the constructor but unfortunately `this` is not set at that time yet\r\n\tfunction setupGovernance(GovernanceFactory governanceFactory, VotedValueFactory votedValueFactory) virtual public {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = governanceFactory.createGovernance(address(this), settings.tokenAddress);\r\n\r\n\t\tgovernance.addVotedValue(\"ratio100\", votedValueFactory.createVotedValueUint(governance, settings.ratio100, this.validateRatio, this.setRatio));\r\n\t\tgovernance.addVotedValue(\"counterstake_coef100\", votedValueFactory.createVotedValueUint(governance, settings.counterstake_coef100, this.validateCounterstakeCoef, this.setCounterstakeCoef));\r\n\t\tgovernance.addVotedValue(\"min_stake\", votedValueFactory.createVotedValueUint(governance, settings.min_stake, this.validateMinStake, this.setMinStake));\r\n\t\tgovernance.addVotedValue(\"min_tx_age\", votedValueFactory.createVotedValueUint(governance, settings.min_tx_age, this.validateMinTxAge, this.setMinTxAge));\r\n\t\tgovernance.addVotedValue(\"large_threshold\", votedValueFactory.createVotedValueUint(governance, settings.large_threshold, this.validateLargeThreshold, this.setLargeThreshold));\r\n\t\tgovernance.addVotedValue(\"challenging_periods\", votedValueFactory.createVotedValueUintArray(governance, settings.challenging_periods, this.validateChallengingPeriods, this.setChallengingPeriods));\r\n\t\tgovernance.addVotedValue(\"large_challenging_periods\", votedValueFactory.createVotedValueUintArray(governance, settings.large_challenging_periods, this.validateChallengingPeriods, this.setLargeChallengingPeriods));\r\n\t}\r\n\r\n\tfunction validateRatio(uint _ratio100) pure external {\r\n\t\trequire(_ratio100 > 0 && _ratio100 < 64000, \"bad ratio\");\r\n\t}\r\n\r\n\tfunction setRatio(uint _ratio100) onlyVotedValueContract external {\r\n\t\tsettings.ratio100 = uint16(_ratio100);\r\n\t}\r\n\r\n\t\r\n\tfunction validateCounterstakeCoef(uint _counterstake_coef100) pure external {\r\n\t\trequire(_counterstake_coef100 > 100 && _counterstake_coef100 < 64000, \"bad counterstake coef\");\r\n\t}\r\n\r\n\tfunction setCounterstakeCoef(uint _counterstake_coef100) onlyVotedValueContract external {\r\n\t\tsettings.counterstake_coef100 = uint16(_counterstake_coef100);\r\n\t}\r\n\r\n\t\r\n\tfunction validateMinStake(uint _min_stake) pure external {\r\n\t\t// anything goes\r\n\t}\r\n\r\n\tfunction setMinStake(uint _min_stake) onlyVotedValueContract external {\r\n\t\tsettings.min_stake = _min_stake;\r\n\t}\r\n\r\n\r\n\tfunction validateMinTxAge(uint _min_tx_age) pure external {\r\n\t\trequire(_min_tx_age < 4 weeks, \"min tx age too large\");\r\n\t}\r\n\r\n\tfunction setMinTxAge(uint _min_tx_age) onlyVotedValueContract external {\r\n\t\tsettings.min_tx_age = uint32(_min_tx_age);\r\n\t}\r\n\r\n\r\n\tfunction validateLargeThreshold(uint _large_threshold) pure external {\r\n\t\t// anything goes\r\n\t}\r\n\r\n\tfunction setLargeThreshold(uint _large_threshold) onlyVotedValueContract external {\r\n\t\tsettings.large_threshold = _large_threshold;\r\n\t}\r\n\r\n\r\n\tfunction validateChallengingPeriods(uint[] memory periods) pure external {\r\n\t\tCounterstakeLibrary.validateChallengingPeriods(periods);\r\n\t}\r\n\r\n\tfunction setChallengingPeriods(uint[] memory _challenging_periods) onlyVotedValueContract external {\r\n\t\tsettings.challenging_periods = _challenging_periods;\r\n\t}\r\n\r\n\tfunction setLargeChallengingPeriods(uint[] memory _large_challenging_periods) onlyVotedValueContract external {\r\n\t\tsettings.large_challenging_periods = _large_challenging_periods;\r\n\t}\r\n\r\n\r\n\tfunction getChallengingPeriod(uint16 period_number, bool bLarge) external view returns (uint) {\r\n\t\treturn CounterstakeLibrary.getChallengingPeriod(settings, period_number, bLarge);\r\n\t}\r\n\r\n\tfunction getRequiredStake(uint amount) public view virtual returns (uint);\r\n\r\n\tfunction getMissingStake(uint claim_num, CounterstakeLibrary.Side stake_on) external view returns (uint) {\r\n\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\r\n\t\trequire(c.yes_stake > 0, \"no such claim\");\r\n\t\tuint current_stake = (stake_on == CounterstakeLibrary.Side.yes) ? c.yes_stake : c.no_stake;\r\n\t\treturn (c.current_outcome == CounterstakeLibrary.Side.yes ? c.yes_stake : c.no_stake) * settings.counterstake_coef100/100 - current_stake;\r\n\t}\r\n\r\n\r\n\r\n\tfunction claim(string memory txid, uint32 txts, uint amount, int reward, uint stake, string memory sender_address, address payable recipient_address, string memory data) nonReentrant payable external {\r\n\t\tif (recipient_address == address(0))\r\n\t\t\trecipient_address = payable(msg.sender);\r\n\t\tbool bThirdPartyClaiming = (recipient_address != payable(msg.sender) && reward >= 0);\r\n\t\tuint paid_amount;\r\n\t\tif (bThirdPartyClaiming) {\r\n\t\t\trequire(amount > uint(reward), \"reward too large\");\r\n\t\t\tpaid_amount = amount - uint(reward);\r\n\t\t}\r\n\t\treceiveMoneyInClaim(stake, paid_amount);\r\n\t\tuint required_stake = getRequiredStake(amount);\r\n\t\tCounterstakeLibrary.ClaimRequest memory req = CounterstakeLibrary.ClaimRequest({\r\n\t\t\ttxid: txid,\r\n\t\t\ttxts: txts,\r\n\t\t\tamount: amount,\r\n\t\t\treward: reward,\r\n\t\t\tstake: stake,\r\n\t\t\trequired_stake: required_stake,\r\n\t\t\trecipient_address: recipient_address,\r\n\t\t\tsender_address: sender_address,\r\n\t\t\tdata: data\r\n\t\t});\r\n\t\tlast_claim_num++;\r\n\t\tongoing_claim_nums.push(last_claim_num);\r\n\t\tnum2index[last_claim_num] = ongoing_claim_nums.length - 1;\r\n\r\n\t\tCounterstakeLibrary.claim(settings, claim_nums, claims, stakes, last_claim_num, req);\r\n\t\t\r\n\t\tif (bThirdPartyClaiming){\r\n\t\t\tsendToClaimRecipient(recipient_address, paid_amount);\r\n\t\t\tnotifyPaymentRecipient(recipient_address, paid_amount, 0, last_claim_num);\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\tfunction challenge(string calldata claim_id, CounterstakeLibrary.Side stake_on, uint stake) payable external {\r\n\t\tchallenge(claim_nums[claim_id], stake_on, stake);\r\n\t}\r\n\r\n\tfunction challenge(uint claim_num, CounterstakeLibrary.Side stake_on, uint stake) nonReentrant payable public {\r\n\t\treceiveStakeAsset(stake);\r\n\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\r\n\t\trequire(c.amount > 0, \"no such claim\");\r\n\t\tCounterstakeLibrary.challenge(settings, c, stakes, claim_num, stake_on, stake);\r\n\t}\r\n\r\n\tfunction withdraw(string memory claim_id) external {\r\n\t\twithdraw(claim_nums[claim_id], payable(0));\r\n\t}\r\n\r\n\tfunction withdraw(uint claim_num) external {\r\n\t\twithdraw(claim_num, payable(0));\r\n\t}\r\n\r\n\tfunction withdraw(string memory claim_id, address payable to_address) external {\r\n\t\twithdraw(claim_nums[claim_id], to_address);\r\n\t}\r\n\r\n\tfunction withdraw(uint claim_num, address payable to_address) nonReentrant public {\r\n\t\tif (to_address == address(0))\r\n\t\t\tto_address = payable(msg.sender);\r\n\t\trequire(claim_num > 0, \"no such claim num\");\r\n\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\r\n\t\trequire(c.amount > 0, \"no such claim\");\r\n\r\n\t\t(bool finished, bool is_winning_claimant, uint won_stake) = CounterstakeLibrary.finish(c, stakes, claim_num, to_address);\r\n\t\t\r\n\t\tif (finished){\r\n\t\t\tuint index = num2index[claim_num];\r\n\t\t\tuint last_index = ongoing_claim_nums.length - 1;\r\n\t\t\tif (index != last_index){ // move the last element in place of our removed element\r\n\t\t\t\trequire(index < last_index, \"BUG index after last\");\r\n\t\t\t\tuint64 claim_num_of_last_element = ongoing_claim_nums[last_index];\r\n\t\t\t\tnum2index[claim_num_of_last_element] = index;\r\n\t\t\t\tongoing_claim_nums[index] = claim_num_of_last_element;\r\n\t\t\t}\r\n\t\t\tongoing_claim_nums.pop();\r\n\t\t\tdelete num2index[claim_num];\r\n\t\t}\r\n\r\n\t\tuint claimed_amount_to_be_paid = is_winning_claimant ? c.amount : 0;\r\n\t\tsendWithdrawals(to_address, claimed_amount_to_be_paid, won_stake);\r\n\t\tnotifyPaymentRecipient(to_address, claimed_amount_to_be_paid, won_stake, claim_num);\r\n\t}\r\n\r\n\tfunction notifyPaymentRecipient(address payable payment_recipient_address, uint net_claimed_amount, uint won_stake, uint claim_num) private {\r\n\t\tif (CounterstakeLibrary.isContract(payment_recipient_address)){\r\n\t\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\r\n\t\t//\tCounterstakeReceiver(payment_recipient_address).onReceivedFromClaim(claim_num, is_winning_claimant ? claimed_amount : 0, won_stake);\r\n\t\t\t(bool res, ) = payment_recipient_address.call(abi.encodeWithSignature(\"onReceivedFromClaim(uint256,uint256,uint256,string,address,string)\", claim_num, net_claimed_amount, won_stake, c.sender_address, c.recipient_address, c.data));\r\n\t\t\tif (!res){\r\n\t\t\t\t// ignore\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction receiveStakeAsset(uint stake_asset_amount) internal {\r\n\t\tif (settings.tokenAddress == address(0))\r\n\t\t\trequire(msg.value == stake_asset_amount, \"wrong amount received\");\r\n\t\telse {\r\n\t\t\trequire(msg.value == 0, \"don't send ETH\");\r\n\t\t\trequire(IERC20(settings.tokenAddress).transferFrom(msg.sender, address(this), stake_asset_amount), \"failed to pull the token\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sendWithdrawals(address payable to_address, uint claimed_amount_to_be_paid, uint won_stake) internal virtual;\r\n\t\r\n\tfunction sendToClaimRecipient(address payable to_address, uint paid_amount) internal virtual;\r\n\r\n\tfunction receiveMoneyInClaim(uint stake, uint paid_amount) internal virtual;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Export is Counterstake {\r\n\r\n\r\n\tevent NewExpatriation(address sender_address, uint amount, int reward, string foreign_address, string data);\r\n\r\n\tstring public foreign_network;\r\n\tstring public foreign_asset;\r\n\r\n\tconstructor (string memory _foreign_network, string memory _foreign_asset, address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods)\r\n\tCounterstake(_tokenAddr, _counterstake_coef100, _ratio100, _large_threshold, _challenging_periods, _large_challenging_periods)\r\n\t{\r\n\t\tforeign_network = _foreign_network;\r\n\t\tforeign_asset = _foreign_asset;\r\n\t}\r\n\r\n\tfunction initExport(string memory _foreign_network, string memory _foreign_asset) public\r\n\t{\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tforeign_network = _foreign_network;\r\n\t\tforeign_asset = _foreign_asset;\r\n\t}\r\n\r\n\r\n\tfunction transferToForeignChain(string memory foreign_address, string memory data, uint amount, int reward) payable nonReentrant external {\r\n\t\treceiveStakeAsset(amount);\r\n\t\tif (reward >= 0)\r\n\t\t\trequire(uint(reward) < amount, \"reward too big\");\r\n\t\temit NewExpatriation(msg.sender, amount, reward, foreign_address, data);\r\n\t}\r\n\r\n\r\n\tfunction getRequiredStake(uint amount) public view override returns (uint) {\r\n\t\treturn Math.max(amount * settings.ratio100 / 100, settings.min_stake);\r\n\t}\r\n\r\n\r\n\tfunction sendWithdrawals(address payable to_address, uint paid_claimed_amount, uint won_stake) internal override {\r\n\t\tuint total = won_stake + paid_claimed_amount;\r\n\t\tif (settings.tokenAddress == address(0)) {\r\n\t\t\tto_address.transfer(total);\r\n\t\t}\r\n\t\telse {\r\n\t\t\trequire(IERC20(settings.tokenAddress).transfer(to_address, total), \"failed to send tokens\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction receiveMoneyInClaim(uint stake, uint paid_amount) internal override {\r\n\t\treceiveStakeAsset(stake + paid_amount);\r\n\t}\r\n\r\n\tfunction sendToClaimRecipient(address payable to_address, uint paid_amount) internal override {\r\n\t\tif (settings.tokenAddress == address(0)) {\r\n\t\t\tto_address.transfer(paid_amount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\trequire(IERC20(settings.tokenAddress).transfer(to_address, paid_amount), \"failed to send tokens\");\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string public name;\r\n    string public symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The defaut value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) {\r\n        name = name_;\r\n        symbol = symbol_;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overloaded;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract ExportAssistant is ERC20, ReentrancyGuard, CounterstakeReceiver \r\n{\r\n\r\n\taddress public bridgeAddress;\r\n\taddress public tokenAddress;\r\n\taddress public managerAddress;\r\n\r\n\tuint16 public management_fee10000;\r\n\tuint16 public success_fee10000;\r\n\r\n\tuint8 public exponent;\r\n\t\r\n\tuint public ts;\r\n\tint public profit;\r\n\tuint public mf;\r\n\tuint public balance_in_work;\r\n\r\n\tmapping(uint => uint) public balances_in_work;\r\n\r\n\tGovernance public governance;\r\n\r\n\r\n\tevent NewClaimFor(uint claim_num, address for_address, string txid, uint32 txts, uint amount, int reward, uint stake);\r\n\tevent AssistantChallenge(uint claim_num, CounterstakeLibrary.Side outcome, uint stake);\r\n    event NewManager(address previousManager, address newManager);\r\n\r\n\r\n\tmodifier onlyETH(){\r\n\t\trequire(tokenAddress == address(0), \"ETH only\");\r\n\t\t_;\r\n\t}\r\n\r\n/*\tmodifier onlyERC20(){\r\n\t\trequire(tokenAddress != address(0), \"ERC20 only\");\r\n\t\t_;\r\n\t}*/\r\n\r\n\tmodifier onlyBridge(){\r\n\t\trequire(msg.sender == bridgeAddress, \"not from bridge\");\r\n\t\t_;\r\n\t}\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == managerAddress, \"caller is not the manager\");\r\n        _;\r\n    }\r\n\r\n\r\n\tconstructor(address bridgeAddr, address managerAddr, uint16 _management_fee10000, uint16 _success_fee10000, uint8 _exponent, string memory name, string memory symbol) ERC20(name, symbol) {\r\n\t\tinitExportAssistant(bridgeAddr, managerAddr, _management_fee10000, _success_fee10000, _exponent, name, symbol);\r\n\t}\r\n\r\n\tfunction initExportAssistant(address bridgeAddr, address managerAddr, uint16 _management_fee10000, uint16 _success_fee10000, uint8 _exponent, string memory _name, string memory _symbol) public {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n\t\tbridgeAddress = bridgeAddr;\r\n\t\tmanagement_fee10000 = _management_fee10000;\r\n\t\tsuccess_fee10000 = _success_fee10000;\r\n\t\trequire(_exponent == 1 || _exponent == 2 || _exponent == 4, \"only exponents 1, 2 and 4 are supported\");\r\n\t\texponent = _exponent;\r\n\t\tts = block.timestamp;\r\n\t\t(address tokenAddr, , , , , ) = Export(bridgeAddr).settings();\r\n\t\ttokenAddress = tokenAddr;\r\n\t\tif (tokenAddr != address(0))\r\n\t\t\tIERC20(tokenAddr).approve(bridgeAddr, type(uint).max);\r\n\t\tmanagerAddress = (managerAddr != address(0)) ? managerAddr : msg.sender;\r\n\t}\r\n\r\n\r\n\tfunction getGrossBalance() internal view returns (uint) {\r\n\t\tuint bal = (tokenAddress == address(0)) ? address(this).balance : IERC20(tokenAddress).balanceOf(address(this));\r\n\t\treturn bal + balance_in_work;\r\n\t}\r\n\r\n\tfunction updateMFAndGetBalances(uint just_received_amount, bool update) internal returns (uint gross_balance, int net_balance) {\r\n\t\tgross_balance = getGrossBalance() - just_received_amount;\r\n\t\tuint new_mf = mf + gross_balance * management_fee10000 * (block.timestamp - ts)/(360*24*3600)/1e4;\r\n\t\tnet_balance = int(gross_balance) - int(new_mf) - max(profit * int16(success_fee10000)/1e4, 0);\r\n\t\t// to save gas, we don't update mf when the balance doesn't change\r\n\t\tif (update) {\r\n\t\t\tmf = new_mf;\r\n\t\t\tts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// reentrancy is probably not a risk unless a malicious token makes a reentrant call from its balanceOf, so nonReentrant can be removed to save 10K gas\r\n\tfunction claim(string memory txid, uint32 txts, uint amount, int reward, string memory sender_address, address payable recipient_address, string memory data) onlyManager nonReentrant external {\r\n\t\trequire(reward >= 0, \"negative reward\");\r\n\t\tuint claim_num = Export(bridgeAddress).last_claim_num() + 1;\r\n\t\tuint required_stake = Export(bridgeAddress).getRequiredStake(amount);\r\n\t\tuint paid_amount = amount - uint(reward);\r\n\t\tuint total = required_stake + paid_amount;\r\n\t\t{ // stack too deep\r\n\t\t\t(, int net_balance) = updateMFAndGetBalances(0, false);\r\n\t\t\trequire(total < uint(type(int).max), \"total too large\");\r\n\t\t\trequire(net_balance > 0, \"no net balance\");\r\n\t\t\trequire(total <= uint(net_balance), \"not enough balance\");\r\n\t\t\tbalances_in_work[claim_num] = total;\r\n\t\t\tbalance_in_work += total;\r\n\t\t}\r\n\r\n\t\temit NewClaimFor(claim_num, recipient_address, txid, txts, amount, reward, required_stake);\r\n\r\n\t\tExport(bridgeAddress).claim{value: tokenAddress == address(0) ? total : 0}(txid, txts, amount, reward, required_stake, sender_address, recipient_address, data);\r\n\t}\r\n\r\n\t// like in claim() above, nonReentrant is probably unnecessary\r\n\tfunction challenge(uint claim_num, CounterstakeLibrary.Side stake_on, uint stake) onlyManager nonReentrant external {\r\n\t\t(, int net_balance) = updateMFAndGetBalances(0, false);\r\n\t\trequire(net_balance > 0, \"no net balance\");\r\n\r\n\t\tuint missing_stake = Export(bridgeAddress).getMissingStake(claim_num, stake_on);\r\n\t\tif (stake == 0 || stake > missing_stake) // send the stake without excess as we can't account for it\r\n\t\t\tstake = missing_stake;\r\n\r\n\t\trequire(stake <= uint(net_balance), \"not enough balance\");\r\n\t\tExport(bridgeAddress).challenge{value: tokenAddress == address(0) ? stake : 0}(claim_num, stake_on, stake);\r\n\t\tbalances_in_work[claim_num] += stake;\r\n\t\tbalance_in_work += stake;\r\n\t\temit AssistantChallenge(claim_num, stake_on, stake);\r\n\t}\r\n\r\n\treceive() external payable onlyETH {\r\n\t\t// silently receive Ether from claims\r\n\t}\r\n\r\n\tfunction onReceivedFromClaim(uint claim_num, uint claimed_amount, uint won_stake, string memory, address, string memory) onlyBridge override external {\r\n\t\tuint total = claimed_amount + won_stake;\r\n\t\tupdateMFAndGetBalances(total, true); // total is already added to our balance\r\n\r\n\t\tuint invested = balances_in_work[claim_num];\r\n\t\trequire(invested > 0, \"BUG: I didn't stake in this claim?\");\r\n\r\n\t\tif (total >= invested){\r\n\t\t\tuint this_profit = total - invested;\r\n\t\t\trequire(this_profit < uint(type(int).max), \"this_profit too large\");\r\n\t\t\tprofit += int(this_profit);\r\n\t\t}\r\n\t\telse { // avoid negative values\r\n\t\t\tuint loss = invested - total;\r\n\t\t\trequire(loss < uint(type(int).max), \"loss too large\");\r\n\t\t\tprofit -= int(loss);\r\n\t\t}\r\n\r\n\t\tbalance_in_work -= invested;\r\n\t\tdelete balances_in_work[claim_num];\r\n\t}\r\n\r\n\t// Record a loss, called by anybody.\r\n\t// Should be called only if I staked on the losing side only.\r\n\t// If I staked on the winning side too, the above function should be called.\r\n\tfunction recordLoss(uint claim_num) nonReentrant external {\r\n\t\tupdateMFAndGetBalances(0, true);\r\n\r\n\t\tuint invested = balances_in_work[claim_num];\r\n\t\trequire(invested > 0, \"this claim is already accounted for\");\r\n\t\t\r\n\t\tCounterstakeLibrary.Claim memory c = Export(bridgeAddress).getClaim(claim_num);\r\n\t\trequire(c.amount > 0, \"no such claim\");\r\n\t\trequire(block.timestamp > c.expiry_ts, \"not expired yet\");\r\n\t\tCounterstakeLibrary.Side opposite_outcome = c.current_outcome == CounterstakeLibrary.Side.yes ? CounterstakeLibrary.Side.no : CounterstakeLibrary.Side.yes;\r\n\t\t\r\n\t\tuint my_winning_stake = Export(bridgeAddress).stakes(claim_num, c.current_outcome, address(this));\r\n\t\trequire(my_winning_stake == 0, \"have a winning stake in this claim\");\r\n\t\t\r\n\t\tuint my_losing_stake = Export(bridgeAddress).stakes(claim_num, opposite_outcome, address(this));\r\n\t\trequire(my_losing_stake > 0, \"no losing stake in this claim\");\r\n\t\trequire(invested >= my_losing_stake, \"lost more than invested?\");\r\n\r\n\t\trequire(invested < uint(type(int).max), \"loss too large\");\r\n\t\tprofit -= int(invested);\r\n\r\n\t\tbalance_in_work -= invested;\r\n\t\tdelete balances_in_work[claim_num];\r\n\t}\r\n\r\n\r\n\t// share issue/redeem functions\r\n\r\n\tfunction buyShares(uint stake_asset_amount) payable nonReentrant external {\r\n\t\tif (tokenAddress == address(0))\r\n\t\t\trequire(msg.value == stake_asset_amount, \"wrong amount received\");\r\n\t\telse {\r\n\t\t\trequire(msg.value == 0, \"don't send ETH\");\r\n\t\t\trequire(IERC20(tokenAddress).transferFrom(msg.sender, address(this), stake_asset_amount), \"failed to pull to buy shares\");\r\n\t\t}\r\n\t\t(uint gross_balance, int net_balance) = updateMFAndGetBalances(stake_asset_amount, true);\r\n\t\trequire((gross_balance == 0) == (totalSupply() == 0), \"bad init state\");\r\n\t\tuint shares_amount;\r\n\t\tif (totalSupply() == 0)\r\n\t\t\tshares_amount = stake_asset_amount / 10**(18 - decimals());\r\n\t\telse {\r\n\t\t\trequire(net_balance > 0, \"no net balance\");\r\n\t\t\tuint new_shares_supply = totalSupply() * getShares(uint(net_balance) + stake_asset_amount) / getShares(uint(net_balance));\r\n\t\t\tshares_amount = new_shares_supply - totalSupply();\r\n\t\t}\r\n\t\t_mint(msg.sender, shares_amount);\r\n\r\n\t\t// this should overflow now, not when we try to redeem. We won't see the error message, will revert while trying to evaluate the expression\r\n\t\trequire((gross_balance + stake_asset_amount) * totalSupply()**exponent > 0, \"too many shares, would overflow\");\r\n\t}\r\n\r\n\tfunction redeemShares(uint shares_amount) nonReentrant external {\r\n\t\tuint old_shares_supply = totalSupply();\r\n\r\n\t\t_burn(msg.sender, shares_amount);\r\n\t\t(, int net_balance) = updateMFAndGetBalances(0, true);\r\n\t\trequire(net_balance > 0, \"negative net balance\");\r\n\t\trequire(uint(net_balance) > balance_in_work, \"negative risk-free net balance\");\r\n\r\n\t\tuint stake_asset_amount = (uint(net_balance) - balance_in_work) * (old_shares_supply**exponent - (old_shares_supply - shares_amount)**exponent) / old_shares_supply**exponent;\r\n\t\tpayStakeTokens(msg.sender, stake_asset_amount);\r\n\t}\r\n\r\n\r\n\t// manager functions\r\n\r\n\tfunction withdrawManagementFee() onlyManager nonReentrant external {\r\n\t\tupdateMFAndGetBalances(0, true);\r\n\t\tpayStakeTokens(msg.sender, mf);\r\n\t\tmf = 0;\r\n\t}\r\n\r\n\tfunction withdrawSuccessFee() onlyManager nonReentrant external {\r\n\t\tupdateMFAndGetBalances(0, true);\r\n\t\trequire(profit > 0, \"no profit yet\");\r\n\t\tuint sf = uint(profit) * success_fee10000/1e4;\r\n\t\tpayStakeTokens(msg.sender, sf);\r\n\t\tprofit = 0;\r\n\t}\r\n\r\n\t// zero address is allowed\r\n    function assignNewManager(address newManager) onlyManager external {\r\n\t\temit NewManager(managerAddress, newManager);\r\n        managerAddress = newManager;\r\n    }\r\n\r\n\r\n\t// governance functions\r\n\r\n\tmodifier onlyVotedValueContract(){\r\n\t\trequire(governance.addressBelongsToGovernance(msg.sender), \"not from voted value contract\");\r\n\t\t_;\r\n\t}\r\n\r\n\t// would be happy to call this from the constructor but unfortunately `this` is not set at that time yet\r\n\tfunction setupGovernance(GovernanceFactory governanceFactory, VotedValueFactory ) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = governanceFactory.createGovernance(address(this), address(this));\r\n\r\n\t}\r\n\r\n\r\n\r\n\t// helper functions\r\n\r\n\tfunction payStakeTokens(address to, uint amount) internal {\r\n\t\tif (tokenAddress == address(0))\r\n\t\t\tpayable(to).transfer(amount);\r\n\t\telse\r\n\t\t\trequire(IERC20(tokenAddress).transfer(to, amount), \"failed to transfer\");\r\n\t}\r\n\r\n\tfunction getShares(uint balance) view internal returns (uint) {\r\n\t\tif (exponent == 1)\r\n\t\t\treturn balance;\r\n\t\tif (exponent == 2)\r\n\t\t\treturn sqrt(balance);\r\n\t\tif (exponent == 4)\r\n\t\t\treturn sqrt(sqrt(balance));\r\n\t\trevert(\"bad exponent\");\r\n\t}\r\n\r\n\t// for large exponents, we need more room to **exponent without overflow\r\n\tfunction decimals() public view override returns (uint8) {\r\n\t\treturn exponent > 2 ? 9 : 18;\r\n\t}\r\n\r\n\tfunction max(int a, int b) internal pure returns (int) {\r\n\t\treturn a > b ? a : b;\r\n\t}\r\n\r\n\t// babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n\tfunction sqrt(uint y) internal pure returns (uint z) {\r\n\t\tif (y > 3) {\r\n\t\t\tz = y;\r\n\t\t\tuint x = y / 2 + 1;\r\n\t\t\twhile (x < z) {\r\n\t\t\t\tz = x;\r\n\t\t\t\tx = (y / x + x) / 2;\r\n\t\t\t}\r\n\t\t} else if (y != 0) {\r\n\t\t\tz = 1;\r\n\t\t}\r\n\t}\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridgeAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"managerAddr\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_management_fee10000\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_success_fee10000\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_exponent\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"outcome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"AssistantChallenge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"for_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"txid\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"txts\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"reward\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"NewClaimFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"NewManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"assignNewManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balance_in_work\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balances_in_work\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stake_asset_amount\",\"type\":\"uint256\"}],\"name\":\"buyShares\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"stake_on\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"challenge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"txid\",\"type\":\"string\"},{\"internalType\":\"uint32\",\"name\":\"txts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"reward\",\"type\":\"int256\"},{\"internalType\":\"string\",\"name\":\"sender_address\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"recipient_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exponent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract Governance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridgeAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"managerAddr\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_management_fee10000\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_success_fee10000\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_exponent\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"initExportAssistant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management_fee10000\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"won_stake\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"onReceivedFromClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profit\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"}],\"name\":\"recordLoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares_amount\",\"type\":\"uint256\"}],\"name\":\"redeemShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract GovernanceFactory\",\"name\":\"governanceFactory\",\"type\":\"address\"},{\"internalType\":\"contract VotedValueFactory\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"setupGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"success_fee10000\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawManagementFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawSuccessFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ExportAssistant","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009bdd066682b9020041e7505874427179f6d095ff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000007d0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000194578706f727420617373697374616e742074656d706c6174650000000000000000000000000000000000000000000000000000000000000000000000000000044558415300000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://910a7a6b5e1b9a0fb93577d5607cb653b8e0be345ccd0b93613e47332331e02c"}]}