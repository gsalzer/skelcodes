{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library\\u0027s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"},\"ERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    constructor() public {\\n        _registerInterface(\\n            ERC1155Receiver(0).onERC1155Received.selector ^\\n            ERC1155Receiver(0).onERC1155BatchReceived.selector\\n        );\\n    }\\n}\\n\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it\\u0027s supported.\\n     */\\n    mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"},\"IERC1155Preset.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Preset {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller\\u0027s tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``\\u0027s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``\\u0027s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\\n     *\\n     * See {ERC1155-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to, uint256 id, uint256 amount, bytes memory data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\\n     */\\n    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external;\\n\\n    function getOwnerIdByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    function getOwnerIdIndex(address owner, uint256 id) external view returns (uint256);\\n}\\n\"},\"IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"PoolV4.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StrongPoolInterface.sol\\\";\\nimport \\\"./rewards.sol\\\";\\n\\ncontract PoolV4 {\\n  event Mined(address indexed miner, uint256 amount);\\n  event Unmined(address indexed miner, uint256 amount);\\n  event Claimed(address indexed miner, uint256 reward);\\n\\n  using SafeMath for uint256;\\n\\n  bool public initDone;\\n  address public admin;\\n  address public pendingAdmin;\\n  address public superAdmin;\\n  address public pendingSuperAdmin;\\n  address public parameterAdmin;\\n  address payable public feeCollector;\\n\\n  IERC20 public token;\\n  IERC20 public strongToken;\\n  StrongPoolInterface public strongPool;\\n\\n  mapping(address =\\u003e uint256) public minerBalance;\\n  uint256 public totalBalance;\\n  mapping(address =\\u003e uint256) public minerBlockLastClaimedOn;\\n\\n  uint256 public rewardBalance;\\n\\n  uint256 public rewardPerBlockNumerator;\\n  uint256 public rewardPerBlockDenominator;\\n\\n  uint256 public miningFeeNumerator;\\n  uint256 public miningFeeDenominator;\\n\\n  uint256 public unminingFeeNumerator;\\n  uint256 public unminingFeeDenominator;\\n\\n  uint256 public claimingFeeNumerator;\\n  uint256 public claimingFeeDenominator;\\n\\n  uint256 public claimingFeeInWei;\\n\\n  uint256 public rewardPerBlockNumeratorNew;\\n  uint256 public rewardPerBlockDenominatorNew;\\n  uint256 public rewardPerBlockNewEffectiveBlock;\\n\\n  function init(\\n    address strongTokenAddress,\\n    address tokenAddress,\\n    address strongPoolAddress,\\n    address adminAddress,\\n    address superAdminAddress,\\n    uint256 rewardPerBlockNumeratorValue,\\n    uint256 rewardPerBlockDenominatorValue,\\n    uint256 miningFeeNumeratorValue,\\n    uint256 miningFeeDenominatorValue,\\n    uint256 unminingFeeNumeratorValue,\\n    uint256 unminingFeeDenominatorValue,\\n    uint256 claimingFeeNumeratorValue,\\n    uint256 claimingFeeDenominatorValue\\n  ) public {\\n    require(!initDone, \\\"init done\\\");\\n    strongToken = IERC20(strongTokenAddress);\\n    token = IERC20(tokenAddress);\\n    strongPool = StrongPoolInterface(strongPoolAddress);\\n    admin = adminAddress;\\n    superAdmin = superAdminAddress;\\n    rewardPerBlockNumerator = rewardPerBlockNumeratorValue;\\n    rewardPerBlockDenominator = rewardPerBlockDenominatorValue;\\n    miningFeeNumerator = miningFeeNumeratorValue;\\n    miningFeeDenominator = miningFeeDenominatorValue;\\n    unminingFeeNumerator = unminingFeeNumeratorValue;\\n    unminingFeeDenominator = unminingFeeDenominatorValue;\\n    claimingFeeNumerator = claimingFeeNumeratorValue;\\n    claimingFeeDenominator = claimingFeeDenominatorValue;\\n    initDone = true;\\n  }\\n\\n  // ADMIN\\n  // *************************************************************************************\\n  function updateParameterAdmin(address newParameterAdmin) public {\\n    require(newParameterAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin);\\n    parameterAdmin = newParameterAdmin;\\n  }\\n\\n  function setPendingAdmin(address newPendingAdmin) public {\\n    require(newPendingAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == admin, \\\"not admin\\\");\\n    pendingAdmin = newPendingAdmin;\\n  }\\n\\n  function acceptAdmin() public {\\n    require(msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingAdmin\\\");\\n    admin = pendingAdmin;\\n    pendingAdmin = address(0);\\n  }\\n\\n  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\\n    require(newPendingSuperAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin, \\\"not superAdmin\\\");\\n    pendingSuperAdmin = newPendingSuperAdmin;\\n  }\\n\\n  function acceptSuperAdmin() public {\\n    require(msg.sender == pendingSuperAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingSuperAdmin\\\");\\n    superAdmin = pendingSuperAdmin;\\n    pendingSuperAdmin = address(0);\\n  }\\n\\n  // REWARD\\n  // *************************************************************************************\\n  function updateRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    rewardPerBlockNumerator = numerator;\\n    rewardPerBlockDenominator = denominator;\\n  }\\n\\n  function deposit(uint256 amount) public {\\n    require(msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    rewardBalance = rewardBalance.add(amount);\\n  }\\n\\n  function withdraw(address destination, uint256 amount) public {\\n    require(msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    require(rewardBalance \\u003e= amount, \\\"not enough\\\");\\n    strongToken.transfer(destination, amount);\\n    rewardBalance = rewardBalance.sub(amount);\\n  }\\n\\n  // FEES\\n  // *************************************************************************************\\n  function updateFeeCollector(address payable newFeeCollector) public {\\n    require(newFeeCollector != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin);\\n    feeCollector = newFeeCollector;\\n  }\\n\\n  function updateMiningFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    miningFeeNumerator = numerator;\\n    miningFeeDenominator = denominator;\\n  }\\n\\n  function updateUnminingFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    unminingFeeNumerator = numerator;\\n    unminingFeeDenominator = denominator;\\n  }\\n\\n  function updateClaimingFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    claimingFeeNumerator = numerator;\\n    claimingFeeDenominator = denominator;\\n  }\\n\\n  // CORE\\n  // *************************************************************************************\\n  function mine(uint256 amount) public payable {\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    uint256 fee = amount.mul(miningFeeNumerator).div(miningFeeDenominator);\\n    require(msg.value == fee, \\\"invalid fee\\\");\\n    feeCollector.transfer(msg.value);\\n    if (block.number \\u003e minerBlockLastClaimedOn[msg.sender]) {\\n      uint256 reward = getReward(msg.sender);\\n      if (reward \\u003e 0) {\\n        rewardBalance = rewardBalance.sub(reward);\\n        strongToken.approve(address(strongPool), reward);\\n        strongPool.mineFor(msg.sender, reward);\\n        minerBlockLastClaimedOn[msg.sender] = block.number;\\n      }\\n    }\\n    token.transferFrom(msg.sender, address(this), amount);\\n    minerBalance[msg.sender] = minerBalance[msg.sender].add(amount);\\n    totalBalance = totalBalance.add(amount);\\n    if (minerBlockLastClaimedOn[msg.sender] == 0) {\\n      minerBlockLastClaimedOn[msg.sender] = block.number;\\n    }\\n    emit Mined(msg.sender, amount);\\n  }\\n\\n  function unmine(uint256 amount) public payable {\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    uint256 fee = amount.mul(unminingFeeNumerator).div(unminingFeeDenominator);\\n    require(msg.value == fee, \\\"invalid fee\\\");\\n    require(minerBalance[msg.sender] \\u003e= amount, \\\"not enough\\\");\\n    feeCollector.transfer(msg.value);\\n    if (block.number \\u003e minerBlockLastClaimedOn[msg.sender]) {\\n      uint256 reward = getReward(msg.sender);\\n      if (reward \\u003e 0) {\\n        rewardBalance = rewardBalance.sub(reward);\\n        strongToken.approve(address(strongPool), reward);\\n        strongPool.mineFor(msg.sender, reward);\\n        minerBlockLastClaimedOn[msg.sender] = block.number;\\n      }\\n    }\\n    minerBalance[msg.sender] = minerBalance[msg.sender].sub(amount);\\n    totalBalance = totalBalance.sub(amount);\\n    token.transfer(msg.sender, amount);\\n    if (minerBalance[msg.sender] == 0) {\\n      minerBlockLastClaimedOn[msg.sender] = 0;\\n    }\\n    emit Unmined(msg.sender, amount);\\n  }\\n\\n  function claim(uint256 blockNumber) public payable {\\n    require(blockNumber \\u003c= block.number, \\\"invalid block number\\\");\\n    require(minerBlockLastClaimedOn[msg.sender] != 0, \\\"error\\\");\\n    require(blockNumber \\u003e minerBlockLastClaimedOn[msg.sender], \\\"too soon\\\");\\n    uint256 reward = getRewardByBlock(msg.sender, blockNumber);\\n    require(reward \\u003e 0, \\\"no reward\\\");\\n    uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n    require(msg.value == fee, \\\"invalid fee\\\");\\n    feeCollector.transfer(msg.value);\\n    strongToken.approve(address(strongPool), reward);\\n    strongPool.mineFor(msg.sender, reward);\\n    rewardBalance = rewardBalance.sub(reward);\\n    minerBlockLastClaimedOn[msg.sender] = blockNumber;\\n    emit Claimed(msg.sender, reward);\\n  }\\n\\n  function getReward(address miner) public view returns (uint256) {\\n    return getRewardByBlock(miner, block.number);\\n  }\\n\\n  function getRewardByBlock(address miner, uint256 blockNumber) public view returns (uint256) {\\n    uint256 blockLastClaimedOn = minerBlockLastClaimedOn[miner];\\n\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (blockLastClaimedOn == 0) return 0;\\n    if (blockNumber \\u003c blockLastClaimedOn) return 0;\\n    if (totalBalance == 0) return 0;\\n\\n    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, blockNumber);\\n    uint256 rewardOld = rewardPerBlockDenominator \\u003e 0 ? rewardBlocks[0].mul(rewardPerBlockNumerator).div(rewardPerBlockDenominator) : 0;\\n    uint256 rewardNew = rewardPerBlockDenominatorNew \\u003e 0 ? rewardBlocks[1].mul(rewardPerBlockNumeratorNew).div(rewardPerBlockDenominatorNew) : 0;\\n\\n    return rewardOld.add(rewardNew).mul(minerBalance[miner]).div(totalBalance);\\n  }\\n\\n  function updateRewardPerBlockNew(\\n    uint256 numerator,\\n    uint256 denominator,\\n    uint256 effectiveBlock\\n  ) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    rewardPerBlockNumeratorNew = numerator;\\n    rewardPerBlockDenominatorNew = denominator;\\n    rewardPerBlockNewEffectiveBlock = effectiveBlock != 0 ? effectiveBlock : block.number;\\n  }\\n}\\n\"},\"rewards.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary rewards {\\n\\n    using SafeMath for uint256;\\n\\n    function blocks(uint256 lastClaimedOnBlock, uint256 newRewardBlock, uint256 blockNumber) internal pure returns (uint256[2] memory) {\\n        if (lastClaimedOnBlock \\u003e= blockNumber) return [uint256(0), uint256(0)];\\n\\n        if (blockNumber \\u003c= newRewardBlock || newRewardBlock == 0) {\\n            return [blockNumber.sub(lastClaimedOnBlock), uint256(0)];\\n        }\\n        else if (lastClaimedOnBlock \\u003e= newRewardBlock) {\\n            return [uint256(0), blockNumber.sub(lastClaimedOnBlock)];\\n        }\\n        else {\\n            return [newRewardBlock.sub(lastClaimedOnBlock), blockNumber.sub(newRewardBlock)];\\n        }\\n    }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"ServiceInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface ServiceInterface {\\n  function claimingFeeNumerator() external view returns(uint256);\\n\\n  function claimingFeeDenominator() external view returns(uint256);\\n\\n  function doesNodeExist(address entity, uint128 nodeId) external view returns (bool);\\n\\n  function getNodeId(address entity, uint128 nodeId) external view returns (bytes memory);\\n\\n  function getReward(address entity, uint128 nodeId) external view returns (uint256);\\n\\n  function getRewardByBlock(address entity, uint128 nodeId, uint256 blockNumber) external view returns (uint256);\\n\\n  function getTraunch(address entity) external view returns (uint256);\\n\\n  function isEntityActive(address entity) external view returns (bool);\\n\\n  function claim(uint128 nodeId, uint256 blockNumber, bool toStrongPool) external payable;\\n}\\n\"},\"ServiceInterfaceV10.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface ServiceInterfaceV10 {\\n  function traunch(address) external view returns(uint256);\\n\\n  function claimingFeeNumerator() external view returns(uint256);\\n\\n  function claimingFeeDenominator() external view returns(uint256);\\n\\n  function doesNodeExist(address entity, uint128 nodeId) external view returns (bool);\\n\\n  function getNodeId(address entity, uint128 nodeId) external view returns (bytes memory);\\n\\n  function getReward(address entity, uint128 nodeId) external view returns (uint256);\\n\\n  function getRewardByBlock(address entity, uint128 nodeId, uint256 blockNumber) external view returns (uint256);\\n\\n  function isEntityActive(address entity) external view returns (bool);\\n\\n  function claim(uint128 nodeId, uint256 blockNumber, bool toStrongPool) external payable;\\n}\\n\"},\"ServiceV10.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StrongPoolInterface.sol\\\";\\nimport \\\"./IERC1155Preset.sol\\\";\\nimport \\\"./StrongNFTBonusInterface.sol\\\";\\nimport \\\"./rewards.sol\\\";\\n\\ncontract ServiceV10 {\\n  event Requested(address indexed miner);\\n  event Claimed(address indexed miner, uint256 reward);\\n\\n  using SafeMath for uint256;\\n  bool public initDone;\\n  address public admin;\\n  address public pendingAdmin;\\n  address public superAdmin;\\n  address public pendingSuperAdmin;\\n  address public serviceAdmin;\\n  address public parameterAdmin;\\n  address payable public feeCollector;\\n\\n  IERC20 public strongToken;\\n  StrongPoolInterface public strongPool;\\n\\n  uint256 public rewardPerBlockNumerator;\\n  uint256 public rewardPerBlockDenominator;\\n\\n  uint256 public naasRewardPerBlockNumerator;\\n  uint256 public naasRewardPerBlockDenominator;\\n\\n  uint256 public claimingFeeNumerator;\\n  uint256 public claimingFeeDenominator;\\n\\n  uint256 public requestingFeeInWei;\\n\\n  uint256 public strongFeeInWei;\\n\\n  uint256 public recurringFeeInWei;\\n  uint256 public recurringNaaSFeeInWei;\\n  uint256 public recurringPaymentCycleInBlocks;\\n\\n  uint256 public rewardBalance;\\n\\n  mapping(address =\\u003e uint256) public entityBlockLastClaimedOn;\\n\\n  address[] public entities;\\n  mapping(address =\\u003e uint256) public entityIndex;\\n  mapping(address =\\u003e bool) public entityActive;\\n  mapping(address =\\u003e bool) public requestPending;\\n  mapping(address =\\u003e bool) public entityIsNaaS;\\n  mapping(address =\\u003e uint256) public paidOnBlock;\\n  uint256 public activeEntities;\\n\\n  string public desciption;\\n\\n  uint256 public claimingFeeInWei;\\n\\n  uint256 public naasRequestingFeeInWei;\\n\\n  uint256 public naasStrongFeeInWei;\\n\\n  bool public removedTokens;\\n\\n  mapping(address =\\u003e uint256) public traunch;\\n\\n  uint256 public currentTraunch;\\n\\n  mapping(bytes =\\u003e bool) public entityNodeIsActive;\\n  mapping(bytes =\\u003e bool) public entityNodeIsBYON;\\n  mapping(bytes =\\u003e uint256) public entityNodeTraunch;\\n  mapping(bytes =\\u003e uint256) public entityNodePaidOnBlock;\\n  mapping(bytes =\\u003e uint256) public entityNodeClaimedOnBlock;\\n  mapping(address =\\u003e uint128) public entityNodeCount;\\n\\n  event Paid(address indexed entity, uint128 nodeId, bool isBYON, bool isRenewal, uint256 upToBlockNumber);\\n  event Migrated(address indexed from, address indexed to, uint128 fromNodeId, uint128 toNodeId, bool isBYON);\\n\\n  uint256 public rewardPerBlockNumeratorNew;\\n  uint256 public rewardPerBlockDenominatorNew;\\n  uint256 public naasRewardPerBlockNumeratorNew;\\n  uint256 public naasRewardPerBlockDenominatorNew;\\n  uint256 public rewardPerBlockNewEffectiveBlock;\\n\\n  StrongNFTBonusInterface public strongNFTBonus;\\n\\n  function init(\\n    address strongTokenAddress,\\n    address strongPoolAddress,\\n    address adminAddress,\\n    address superAdminAddress,\\n    uint256 rewardPerBlockNumeratorValue,\\n    uint256 rewardPerBlockDenominatorValue,\\n    uint256 naasRewardPerBlockNumeratorValue,\\n    uint256 naasRewardPerBlockDenominatorValue,\\n    uint256 requestingFeeInWeiValue,\\n    uint256 strongFeeInWeiValue,\\n    uint256 recurringFeeInWeiValue,\\n    uint256 recurringNaaSFeeInWeiValue,\\n    uint256 recurringPaymentCycleInBlocksValue,\\n    uint256 claimingFeeNumeratorValue,\\n    uint256 claimingFeeDenominatorValue,\\n    string memory desc\\n  ) public {\\n    require(!initDone, \\\"init done\\\");\\n    strongToken = IERC20(strongTokenAddress);\\n    strongPool = StrongPoolInterface(strongPoolAddress);\\n    admin = adminAddress;\\n    superAdmin = superAdminAddress;\\n    rewardPerBlockNumerator = rewardPerBlockNumeratorValue;\\n    rewardPerBlockDenominator = rewardPerBlockDenominatorValue;\\n    naasRewardPerBlockNumerator = naasRewardPerBlockNumeratorValue;\\n    naasRewardPerBlockDenominator = naasRewardPerBlockDenominatorValue;\\n    requestingFeeInWei = requestingFeeInWeiValue;\\n    strongFeeInWei = strongFeeInWeiValue;\\n    recurringFeeInWei = recurringFeeInWeiValue;\\n    recurringNaaSFeeInWei = recurringNaaSFeeInWeiValue;\\n    claimingFeeNumerator = claimingFeeNumeratorValue;\\n    claimingFeeDenominator = claimingFeeDenominatorValue;\\n    recurringPaymentCycleInBlocks = recurringPaymentCycleInBlocksValue;\\n    desciption = desc;\\n    initDone = true;\\n  }\\n\\n  // ADMIN\\n  // *************************************************************************************\\n\\n  function updateServiceAdmin(address newServiceAdmin) public {\\n    require(msg.sender == superAdmin);\\n    serviceAdmin = newServiceAdmin;\\n  }\\n\\n  function updateParameterAdmin(address newParameterAdmin) public {\\n    require(newParameterAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin);\\n    parameterAdmin = newParameterAdmin;\\n  }\\n\\n  function updateFeeCollector(address payable newFeeCollector) public {\\n    require(newFeeCollector != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin);\\n    feeCollector = newFeeCollector;\\n  }\\n\\n  function setPendingAdmin(address newPendingAdmin) public {\\n    require(msg.sender == admin, \\\"not admin\\\");\\n    pendingAdmin = newPendingAdmin;\\n  }\\n\\n  function acceptAdmin() public {\\n    require(msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingAdmin\\\");\\n    admin = pendingAdmin;\\n    pendingAdmin = address(0);\\n  }\\n\\n  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\\n    require(msg.sender == superAdmin, \\\"not superAdmin\\\");\\n    pendingSuperAdmin = newPendingSuperAdmin;\\n  }\\n\\n  function acceptSuperAdmin() public {\\n    require(msg.sender == pendingSuperAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingSuperAdmin\\\");\\n    superAdmin = pendingSuperAdmin;\\n    pendingSuperAdmin = address(0);\\n  }\\n\\n  // ENTITIES\\n  // *************************************************************************************\\n\\n  function getEntities() public view returns (address[] memory) {\\n    return entities;\\n  }\\n\\n  function isEntityActive(address entity) public view returns (bool) {\\n    return entityActive[entity];\\n  }\\n\\n  // TRAUNCH\\n  // *************************************************************************************\\n\\n  function updateCurrentTraunch(uint256 value) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    currentTraunch = value;\\n  }\\n\\n  // REWARD\\n  // *************************************************************************************\\n\\n  function updateRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    rewardPerBlockNumerator = numerator;\\n    rewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateNaaSRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    naasRewardPerBlockNumerator = numerator;\\n    naasRewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateRewardPerBlockNew(\\n    uint256 numerator,\\n    uint256 denominator,\\n    uint256 numeratorNass,\\n    uint256 denominatorNass,\\n    uint256 effectiveBlock\\n  ) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    rewardPerBlockNumeratorNew = numerator;\\n    rewardPerBlockDenominatorNew = denominator;\\n    naasRewardPerBlockNumeratorNew = numeratorNass;\\n    naasRewardPerBlockDenominatorNew = denominatorNass;\\n    rewardPerBlockNewEffectiveBlock = effectiveBlock != 0 ? effectiveBlock : block.number;\\n  }\\n\\n  function deposit(uint256 amount) public {\\n    require(msg.sender == superAdmin, \\\"not admin\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    rewardBalance = rewardBalance.add(amount);\\n  }\\n\\n  function withdraw(address destination, uint256 amount) public {\\n    require(msg.sender == superAdmin, \\\"not admin\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    require(rewardBalance \\u003e= amount, \\\"not enough\\\");\\n    strongToken.transfer(destination, amount);\\n    rewardBalance = rewardBalance.sub(amount);\\n  }\\n\\n  // FEES\\n  // *************************************************************************************\\n\\n  function updateRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    requestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    strongFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    naasRequestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    naasStrongFeeInWei = feeInWei;\\n  }\\n\\n  function updateClaimingFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    claimingFeeNumerator = numerator;\\n    claimingFeeDenominator = denominator;\\n  }\\n\\n  function updateRecurringFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    recurringFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringNaaSFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    recurringNaaSFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringPaymentCycleInBlocks(uint256 blocks) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    require(blocks \\u003e 0, \\\"zero\\\");\\n    recurringPaymentCycleInBlocks = blocks;\\n  }\\n\\n  // CORE\\n  // *************************************************************************************\\n\\n  function requestAccess(bool isNaaS) public payable {\\n    uint256 rFee;\\n    uint256 sFee;\\n\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    uint128 nodeId = entityNodeCount[msg.sender] + 1;\\n    bytes memory id = getNodeId(msg.sender, nodeId);\\n\\n    if (isNaaS) {\\n      rFee = naasRequestingFeeInWei;\\n      sFee = naasStrongFeeInWei;\\n      activeEntities = activeEntities.add(1);\\n    } else {\\n      rFee = requestingFeeInWei;\\n      sFee = strongFeeInWei;\\n      entityNodeIsBYON[id] = true;\\n    }\\n\\n    require(msg.value == rFee, \\\"invalid fee\\\");\\n\\n    entityNodePaidOnBlock[id] = block.number;\\n    entityNodeTraunch[id] = currentTraunch;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] + 1;\\n\\n    feeCollector.transfer(msg.value);\\n    strongToken.transferFrom(msg.sender, address(this), sFee);\\n    strongToken.transfer(feeCollector, sFee);\\n\\n    emit Paid(msg.sender, nodeId, entityNodeIsBYON[id], false, entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks));\\n  }\\n\\n  function setEntityActiveStatus(address entity, bool status) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    uint256 index = entityIndex[entity];\\n    require(entities[index] == entity, \\\"invalid entity\\\");\\n    require(entityActive[entity] != status, \\\"already set\\\");\\n    entityActive[entity] = status;\\n    if (status) {\\n      activeEntities = activeEntities.add(1);\\n      entityBlockLastClaimedOn[entity] = block.number;\\n    } else {\\n      activeEntities = activeEntities.sub(1);\\n      entityBlockLastClaimedOn[entity] = 0;\\n    }\\n  }\\n\\n  function payFee(uint128 nodeId) public payable {\\n    address sender = msg.sender == address(this) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    bool isExpired = block.number \\u003e blockLastPaidOn.add(recurringPaymentCycleInBlocks).add(recurringPaymentCycleInBlocks);\\n\\n    require(doesNodeExist(sender, nodeId), \\\"doesnt exist\\\");\\n    require(isExpired == false || msg.sender == address(this), \\\"too late\\\");\\n\\n    if (isExpired) {\\n      return;\\n    }\\n\\n    if (entityNodeIsBYON[id]) {\\n      require(msg.value == recurringFeeInWei, \\\"invalid fee\\\");\\n    } else {\\n      require(msg.value == recurringNaaSFeeInWei, \\\"invalid fee\\\");\\n    }\\n\\n    feeCollector.transfer(msg.value);\\n    entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\\n\\n    emit Paid(sender, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\\n  }\\n\\n  function getReward(address entity, uint128 nodeId) public view returns (uint256) {\\n    return getRewardByBlock(entity, nodeId, block.number);\\n  }\\n\\n  function getRewardByBlock(address entity, uint128 nodeId, uint256 blockNumber) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (hasLegacyNode(entity)) {\\n      return getRewardByBlockLegacy(entity, blockNumber);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (blockLastClaimedOn == 0) return 0;\\n    if (blockNumber \\u003c blockLastClaimedOn) return 0;\\n    if (activeEntities == 0) return 0;\\n    if (entityNodeIsBYON[id] \\u0026\\u0026 !entityNodeIsActive[id]) return 0;\\n\\n    uint256 rewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumerator : naasRewardPerBlockNumerator;\\n    uint256 rewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominator : naasRewardPerBlockDenominator;\\n    uint256 newRewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumeratorNew : naasRewardPerBlockNumeratorNew;\\n    uint256 newRewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominatorNew : naasRewardPerBlockDenominatorNew;\\n\\n    uint256 bonus = address(strongNFTBonus) != address(0)\\n    ? strongNFTBonus.getBonus(entity, nodeId, blockLastClaimedOn, blockNumber)\\n    : 0;\\n\\n    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, blockNumber);\\n    uint256 rewardOld = rewardDenominator \\u003e 0 ? rewardBlocks[0].mul(rewardNumerator).div(rewardDenominator) : 0;\\n    uint256 rewardNew = newRewardDenominator \\u003e 0 ? rewardBlocks[1].mul(newRewardNumerator).div(newRewardDenominator) : 0;\\n\\n    return rewardOld.add(rewardNew).add(bonus);\\n  }\\n\\n  function getRewardByBlockLegacy(address entity, uint256 blockNumber) public view returns (uint256) {\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (entityBlockLastClaimedOn[entity] == 0) return 0;\\n    if (blockNumber \\u003c entityBlockLastClaimedOn[entity]) return 0;\\n    if (activeEntities == 0) return 0;\\n    uint256 blockResult = blockNumber.sub(entityBlockLastClaimedOn[entity]);\\n    uint256 rewardNumerator;\\n    uint256 rewardDenominator;\\n    if (entityIsNaaS[entity]) {\\n      rewardNumerator = naasRewardPerBlockNumerator;\\n      rewardDenominator = naasRewardPerBlockDenominator;\\n    } else {\\n      rewardNumerator = rewardPerBlockNumerator;\\n      rewardDenominator = rewardPerBlockDenominator;\\n    }\\n    uint256 rewardPerBlockResult = blockResult.mul(rewardNumerator).div(rewardDenominator);\\n\\n    return rewardPerBlockResult;\\n  }\\n\\n  function claim(uint128 nodeId, uint256 blockNumber, bool toStrongPool) public payable {\\n    address sender = msg.sender == address(this) || msg.sender == address(strongNFTBonus) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n\\n    require(blockLastClaimedOn != 0, \\\"never claimed\\\");\\n    require(blockNumber \\u003c= block.number, \\\"invalid block\\\");\\n    require(blockNumber \\u003e blockLastClaimedOn, \\\"too soon\\\");\\n    require(!entityNodeIsBYON[id] || entityNodeIsActive[id], \\\"not active\\\");\\n\\n    if (\\n      (!entityNodeIsBYON[id] \\u0026\\u0026 recurringNaaSFeeInWei != 0) || (entityNodeIsBYON[id] \\u0026\\u0026 recurringFeeInWei != 0)\\n    ) {\\n      require(blockNumber \\u003c blockLastPaidOn.add(recurringPaymentCycleInBlocks), \\\"pay fee\\\");\\n    }\\n\\n    uint256 reward = getRewardByBlock(sender, nodeId, blockNumber);\\n    require(reward \\u003e 0, \\\"no reward\\\");\\n\\n    uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n    require(msg.value \\u003e= fee, \\\"invalid fee\\\");\\n\\n    feeCollector.transfer(msg.value);\\n\\n    if (toStrongPool) {\\n      strongToken.approve(address(strongPool), reward);\\n      strongPool.mineFor(sender, reward);\\n    } else {\\n      strongToken.transfer(sender, reward);\\n    }\\n\\n    rewardBalance = rewardBalance.sub(reward);\\n    entityNodeClaimedOnBlock[id] = blockNumber;\\n    emit Claimed(sender, reward);\\n  }\\n\\n  function getRewardAll(address entity, uint256 blockNumber) public view returns (uint256) {\\n    uint256 rewardsAll = 0;\\n\\n    for (uint128 i = 1; i \\u003c= entityNodeCount[entity]; i++) {\\n      rewardsAll = rewardsAll.add(getRewardByBlock(entity, i, blockNumber \\u003e 0 ? blockNumber : block.number));\\n    }\\n\\n    return rewardsAll;\\n  }\\n\\n  function doesNodeExist(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id] \\u003e 0;\\n  }\\n\\n  function getNodeId(address entity, uint128 nodeId) public view returns (bytes memory) {\\n    uint128 id = nodeId != 0 ? nodeId : entityNodeCount[entity] + 1;\\n    return abi.encodePacked(entity, id);\\n  }\\n\\n  function getNodePaidOn(address entity, uint128 nodeId) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id];\\n  }\\n\\n  function getNodeFee(address entity, uint128 nodeId) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\\n  }\\n\\n  function isNodeActive(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsActive[id] || !entityNodeIsBYON[id];\\n  }\\n\\n  function isNodeBYON(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsBYON[id];\\n  }\\n\\n  function hasLegacyNode(address entity) public view returns (bool) {\\n    return entityActive[entity] \\u0026\\u0026 entityNodeCount[entity] == 0;\\n  }\\n\\n  function approveBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = true;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    activeEntities = activeEntities.add(1);\\n  }\\n\\n  function suspendBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = false;\\n    activeEntities = activeEntities.sub(1);\\n  }\\n\\n  function setNodeIsActive(address entity, uint128 nodeId, bool isActive) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (isActive \\u0026\\u0026 !entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.add(1);\\n      entityNodeClaimedOnBlock[id] = block.number;\\n    }\\n\\n    if (!isActive \\u0026\\u0026 entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.sub(1);\\n    }\\n\\n    entityNodeIsActive[id] = isActive;\\n  }\\n\\n  function setNodeIsNaaS(address entity, uint128 nodeId, bool isNaaS) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    entityNodeIsBYON[id] = !isNaaS;\\n  }\\n\\n  function migrateLegacyNode(address entity) private {\\n    bytes memory id = getNodeId(entity, 1);\\n    entityNodeClaimedOnBlock[id] = entityBlockLastClaimedOn[entity];\\n    entityNodePaidOnBlock[id] = paidOnBlock[entity];\\n    entityNodeTraunch[id] = traunch[entity];\\n    entityNodeIsBYON[id] = !entityIsNaaS[entity];\\n    if (entityNodeIsBYON[id]) {\\n      entityNodeIsActive[id] = true;\\n    }\\n    entityNodeCount[msg.sender] = 1;\\n  }\\n\\n  function migrateNode(uint128 nodeId, address to) public {\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    if (hasLegacyNode(to)) {\\n      migrateLegacyNode(to);\\n    }\\n\\n    require(doesNodeExist(msg.sender, nodeId), \\\"doesnt exist\\\");\\n\\n    uint128 toNodeId = entityNodeCount[to] + 1;\\n    bytes memory fromId = getNodeId(msg.sender, nodeId);\\n    bytes memory toId = getNodeId(to, toNodeId);\\n\\n    // move node to another address\\n    entityNodeIsActive[toId] = entityNodeIsActive[fromId];\\n    entityNodeIsBYON[toId] = entityNodeIsBYON[fromId];\\n    entityNodePaidOnBlock[toId] = entityNodePaidOnBlock[fromId];\\n    entityNodeClaimedOnBlock[toId] = entityNodeClaimedOnBlock[fromId];\\n    entityNodeTraunch[toId] = entityNodeTraunch[fromId];\\n    entityNodeCount[to] = entityNodeCount[to] + 1;\\n\\n    // deactivate node\\n    entityNodeIsActive[fromId] = false;\\n    entityNodePaidOnBlock[fromId] = 0;\\n    entityNodeClaimedOnBlock[fromId] = 0;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] - 1;\\n\\n    emit Migrated(msg.sender, to, nodeId, toNodeId, entityNodeIsBYON[fromId]);\\n  }\\n\\n  function claimAll(uint256 blockNumber, bool toStrongPool) public payable {\\n    for (uint16 i = 1; i \\u003c= entityNodeCount[msg.sender]; i++) {\\n      uint256 reward = getRewardByBlock(msg.sender, i, blockNumber);\\n      uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n      this.claim{value : fee}(i, blockNumber, toStrongPool);\\n    }\\n  }\\n\\n  function payAll() public payable {\\n    for (uint16 i = 1; i \\u003c= entityNodeCount[msg.sender]; i++) {\\n      bytes memory id = getNodeId(msg.sender, i);\\n      uint256 fee = entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\\n      this.payFee{value : fee}(i);\\n    }\\n  }\\n\\n  function addNFTBonusContract(address _contract) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    strongNFTBonus = StrongNFTBonusInterface(_contract);\\n  }\\n}\\n\"},\"ServiceV11.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StrongPoolInterface.sol\\\";\\nimport \\\"./IERC1155Preset.sol\\\";\\nimport \\\"./StrongNFTBonusInterface.sol\\\";\\nimport \\\"./rewards.sol\\\";\\n\\ncontract ServiceV11 {\\n  event Requested(address indexed miner);\\n  event Claimed(address indexed miner, uint256 reward);\\n\\n  using SafeMath for uint256;\\n  bool public initDone;\\n  address public admin;\\n  address public pendingAdmin;\\n  address public superAdmin;\\n  address public pendingSuperAdmin;\\n  address public serviceAdmin;\\n  address public parameterAdmin;\\n  address payable public feeCollector;\\n\\n  IERC20 public strongToken;\\n  StrongPoolInterface public strongPool;\\n\\n  uint256 public rewardPerBlockNumerator;\\n  uint256 public rewardPerBlockDenominator;\\n\\n  uint256 public naasRewardPerBlockNumerator;\\n  uint256 public naasRewardPerBlockDenominator;\\n\\n  uint256 public claimingFeeNumerator;\\n  uint256 public claimingFeeDenominator;\\n\\n  uint256 public requestingFeeInWei;\\n\\n  uint256 public strongFeeInWei;\\n\\n  uint256 public recurringFeeInWei;\\n  uint256 public recurringNaaSFeeInWei;\\n  uint256 public recurringPaymentCycleInBlocks;\\n\\n  uint256 public rewardBalance;\\n\\n  mapping(address =\\u003e uint256) public entityBlockLastClaimedOn;\\n\\n  address[] public entities;\\n  mapping(address =\\u003e uint256) public entityIndex;\\n  mapping(address =\\u003e bool) public entityActive;\\n  mapping(address =\\u003e bool) public requestPending;\\n  mapping(address =\\u003e bool) public entityIsNaaS;\\n  mapping(address =\\u003e uint256) public paidOnBlock;\\n  uint256 public activeEntities;\\n\\n  string public desciption;\\n\\n  uint256 public claimingFeeInWei;\\n\\n  uint256 public naasRequestingFeeInWei;\\n\\n  uint256 public naasStrongFeeInWei;\\n\\n  bool public removedTokens;\\n\\n  mapping(address =\\u003e uint256) public traunch;\\n\\n  uint256 public currentTraunch;\\n\\n  mapping(bytes =\\u003e bool) public entityNodeIsActive;\\n  mapping(bytes =\\u003e bool) public entityNodeIsBYON;\\n  mapping(bytes =\\u003e uint256) public entityNodeTraunch;\\n  mapping(bytes =\\u003e uint256) public entityNodePaidOnBlock;\\n  mapping(bytes =\\u003e uint256) public entityNodeClaimedOnBlock;\\n  mapping(address =\\u003e uint128) public entityNodeCount;\\n\\n  event Paid(address indexed entity, uint128 nodeId, bool isBYON, bool isRenewal, uint256 upToBlockNumber);\\n  event Migrated(address indexed from, address indexed to, uint128 fromNodeId, uint128 toNodeId, bool isBYON);\\n\\n  uint256 public rewardPerBlockNumeratorNew;\\n  uint256 public rewardPerBlockDenominatorNew;\\n  uint256 public naasRewardPerBlockNumeratorNew;\\n  uint256 public naasRewardPerBlockDenominatorNew;\\n  uint256 public rewardPerBlockNewEffectiveBlock;\\n\\n  StrongNFTBonusInterface public strongNFTBonus;\\n\\n  uint256 public gracePeriodInBlocks;\\n\\n  function init(\\n    address strongTokenAddress,\\n    address strongPoolAddress,\\n    address adminAddress,\\n    address superAdminAddress,\\n    uint256 rewardPerBlockNumeratorValue,\\n    uint256 rewardPerBlockDenominatorValue,\\n    uint256 naasRewardPerBlockNumeratorValue,\\n    uint256 naasRewardPerBlockDenominatorValue,\\n    uint256 requestingFeeInWeiValue,\\n    uint256 strongFeeInWeiValue,\\n    uint256 recurringFeeInWeiValue,\\n    uint256 recurringNaaSFeeInWeiValue,\\n    uint256 recurringPaymentCycleInBlocksValue,\\n    uint256 claimingFeeNumeratorValue,\\n    uint256 claimingFeeDenominatorValue,\\n    string memory desc\\n  ) public {\\n    require(!initDone, \\\"init done\\\");\\n    strongToken = IERC20(strongTokenAddress);\\n    strongPool = StrongPoolInterface(strongPoolAddress);\\n    admin = adminAddress;\\n    superAdmin = superAdminAddress;\\n    rewardPerBlockNumerator = rewardPerBlockNumeratorValue;\\n    rewardPerBlockDenominator = rewardPerBlockDenominatorValue;\\n    naasRewardPerBlockNumerator = naasRewardPerBlockNumeratorValue;\\n    naasRewardPerBlockDenominator = naasRewardPerBlockDenominatorValue;\\n    requestingFeeInWei = requestingFeeInWeiValue;\\n    strongFeeInWei = strongFeeInWeiValue;\\n    recurringFeeInWei = recurringFeeInWeiValue;\\n    recurringNaaSFeeInWei = recurringNaaSFeeInWeiValue;\\n    claimingFeeNumerator = claimingFeeNumeratorValue;\\n    claimingFeeDenominator = claimingFeeDenominatorValue;\\n    recurringPaymentCycleInBlocks = recurringPaymentCycleInBlocksValue;\\n    desciption = desc;\\n    initDone = true;\\n  }\\n\\n  // ADMIN\\n  // *************************************************************************************\\n\\n  function updateServiceAdmin(address newServiceAdmin) public {\\n    require(msg.sender == superAdmin);\\n    serviceAdmin = newServiceAdmin;\\n  }\\n\\n  function updateParameterAdmin(address newParameterAdmin) public {\\n    require(newParameterAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin);\\n    parameterAdmin = newParameterAdmin;\\n  }\\n\\n  function updateFeeCollector(address payable newFeeCollector) public {\\n    require(newFeeCollector != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin);\\n    feeCollector = newFeeCollector;\\n  }\\n\\n  function setPendingAdmin(address newPendingAdmin) public {\\n    require(msg.sender == admin, \\\"not admin\\\");\\n    pendingAdmin = newPendingAdmin;\\n  }\\n\\n  function acceptAdmin() public {\\n    require(msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingAdmin\\\");\\n    admin = pendingAdmin;\\n    pendingAdmin = address(0);\\n  }\\n\\n  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\\n    require(msg.sender == superAdmin, \\\"not superAdmin\\\");\\n    pendingSuperAdmin = newPendingSuperAdmin;\\n  }\\n\\n  function acceptSuperAdmin() public {\\n    require(msg.sender == pendingSuperAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingSuperAdmin\\\");\\n    superAdmin = pendingSuperAdmin;\\n    pendingSuperAdmin = address(0);\\n  }\\n\\n  // ENTITIES\\n  // *************************************************************************************\\n\\n  function isEntityActive(address entity) public view returns (bool) {\\n    return entityActive[entity] || (doesNodeExist(entity, 1) \\u0026\\u0026 !hasNodeExpired(entity, 1));\\n  }\\n\\n  // REWARD\\n  // *************************************************************************************\\n\\n  function updateRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    rewardPerBlockNumerator = numerator;\\n    rewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateNaaSRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    naasRewardPerBlockNumerator = numerator;\\n    naasRewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateRewardPerBlockNew(\\n    uint256 numerator,\\n    uint256 denominator,\\n    uint256 numeratorNass,\\n    uint256 denominatorNass,\\n    uint256 effectiveBlock\\n  ) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    rewardPerBlockNumeratorNew = numerator;\\n    rewardPerBlockDenominatorNew = denominator;\\n    naasRewardPerBlockNumeratorNew = numeratorNass;\\n    naasRewardPerBlockDenominatorNew = denominatorNass;\\n    rewardPerBlockNewEffectiveBlock = effectiveBlock != 0 ? effectiveBlock : block.number;\\n  }\\n\\n  function deposit(uint256 amount) public {\\n    require(msg.sender == superAdmin, \\\"not admin\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    rewardBalance = rewardBalance.add(amount);\\n  }\\n\\n  function withdraw(address destination, uint256 amount) public {\\n    require(msg.sender == superAdmin, \\\"not admin\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    require(rewardBalance \\u003e= amount, \\\"not enough\\\");\\n    strongToken.transfer(destination, amount);\\n    rewardBalance = rewardBalance.sub(amount);\\n  }\\n\\n  // FEES\\n  // *************************************************************************************\\n\\n  function updateRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    requestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    strongFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    naasRequestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    naasStrongFeeInWei = feeInWei;\\n  }\\n\\n  function updateClaimingFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    claimingFeeNumerator = numerator;\\n    claimingFeeDenominator = denominator;\\n  }\\n\\n  function updateRecurringFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    recurringFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringNaaSFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    recurringNaaSFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringPaymentCycleInBlocks(uint256 blocks) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    require(blocks \\u003e 0, \\\"zero\\\");\\n    recurringPaymentCycleInBlocks = blocks;\\n  }\\n\\n  function updateGracePeriodInBlocks(uint256 blocks) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    require(blocks \\u003e 0, \\\"zero\\\");\\n    gracePeriodInBlocks = blocks;\\n  }\\n\\n  // CORE\\n  // *************************************************************************************\\n\\n  function requestAccess(bool isNaaS) public payable {\\n    uint256 rFee;\\n    uint256 sFee;\\n\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    uint128 nodeId = entityNodeCount[msg.sender] + 1;\\n    bytes memory id = getNodeId(msg.sender, nodeId);\\n\\n    if (isNaaS) {\\n      rFee = naasRequestingFeeInWei;\\n      sFee = naasStrongFeeInWei;\\n      activeEntities = activeEntities.add(1);\\n    } else {\\n      rFee = requestingFeeInWei;\\n      sFee = strongFeeInWei;\\n      entityNodeIsBYON[id] = true;\\n    }\\n\\n    require(msg.value == rFee, \\\"invalid fee\\\");\\n\\n    entityNodePaidOnBlock[id] = block.number;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] + 1;\\n\\n    feeCollector.transfer(msg.value);\\n    strongToken.transferFrom(msg.sender, address(this), sFee);\\n    strongToken.transfer(feeCollector, sFee);\\n\\n    emit Paid(msg.sender, nodeId, entityNodeIsBYON[id], false, entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks));\\n  }\\n\\n  function setEntityActiveStatus(address entity, bool status) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    uint256 index = entityIndex[entity];\\n    require(entities[index] == entity, \\\"invalid entity\\\");\\n    require(entityActive[entity] != status, \\\"already set\\\");\\n    entityActive[entity] = status;\\n    if (status) {\\n      activeEntities = activeEntities.add(1);\\n      entityBlockLastClaimedOn[entity] = block.number;\\n    } else {\\n      activeEntities = activeEntities.sub(1);\\n      entityBlockLastClaimedOn[entity] = 0;\\n    }\\n  }\\n\\n  function payFee(uint128 nodeId) public payable {\\n    address sender = msg.sender == address(this) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    bool isExpired = hasNodeExpired(msg.sender, nodeId);\\n\\n    require(doesNodeExist(sender, nodeId), \\\"doesnt exist\\\");\\n    require(isExpired == false || msg.sender == address(this), \\\"too late\\\");\\n\\n    if (isExpired) {\\n      return;\\n    }\\n\\n    if (entityNodeIsBYON[id]) {\\n      require(msg.value == recurringFeeInWei, \\\"invalid fee\\\");\\n    } else {\\n      require(msg.value == recurringNaaSFeeInWei, \\\"invalid fee\\\");\\n    }\\n\\n    feeCollector.transfer(msg.value);\\n    entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\\n\\n    emit Paid(sender, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\\n  }\\n\\n  function getReward(address entity, uint128 nodeId) public view returns (uint256) {\\n    return getRewardByBlock(entity, nodeId, block.number);\\n  }\\n\\n  function getRewardByBlock(address entity, uint128 nodeId, uint256 blockNumber) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (hasLegacyNode(entity)) {\\n      return getRewardByBlockLegacy(entity, blockNumber);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (blockLastClaimedOn == 0) return 0;\\n    if (blockNumber \\u003c blockLastClaimedOn) return 0;\\n    if (activeEntities == 0) return 0;\\n    if (entityNodeIsBYON[id] \\u0026\\u0026 !entityNodeIsActive[id]) return 0;\\n\\n    uint256 rewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumerator : naasRewardPerBlockNumerator;\\n    uint256 rewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominator : naasRewardPerBlockDenominator;\\n    uint256 newRewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumeratorNew : naasRewardPerBlockNumeratorNew;\\n    uint256 newRewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominatorNew : naasRewardPerBlockDenominatorNew;\\n\\n    uint256 bonus = address(strongNFTBonus) != address(0)\\n    ? strongNFTBonus.getBonus(entity, nodeId, blockLastClaimedOn, blockNumber)\\n    : 0;\\n\\n    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, blockNumber);\\n    uint256 rewardOld = rewardDenominator \\u003e 0 ? rewardBlocks[0].mul(rewardNumerator).div(rewardDenominator) : 0;\\n    uint256 rewardNew = newRewardDenominator \\u003e 0 ? rewardBlocks[1].mul(newRewardNumerator).div(newRewardDenominator) : 0;\\n\\n    return rewardOld.add(rewardNew).add(bonus);\\n  }\\n\\n  function getRewardByBlockLegacy(address entity, uint256 blockNumber) public view returns (uint256) {\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (entityBlockLastClaimedOn[entity] == 0) return 0;\\n    if (blockNumber \\u003c entityBlockLastClaimedOn[entity]) return 0;\\n    if (activeEntities == 0) return 0;\\n    uint256 blockResult = blockNumber.sub(entityBlockLastClaimedOn[entity]);\\n    uint256 rewardNumerator;\\n    uint256 rewardDenominator;\\n    if (entityIsNaaS[entity]) {\\n      rewardNumerator = naasRewardPerBlockNumerator;\\n      rewardDenominator = naasRewardPerBlockDenominator;\\n    } else {\\n      rewardNumerator = rewardPerBlockNumerator;\\n      rewardDenominator = rewardPerBlockDenominator;\\n    }\\n    uint256 rewardPerBlockResult = blockResult.mul(rewardNumerator).div(rewardDenominator);\\n\\n    return rewardPerBlockResult;\\n  }\\n\\n  function claim(uint128 nodeId, uint256 blockNumber, bool toStrongPool) public payable {\\n    address sender = msg.sender == address(this) || msg.sender == address(strongNFTBonus) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n\\n    require(blockLastClaimedOn != 0, \\\"never claimed\\\");\\n    require(blockNumber \\u003c= block.number, \\\"invalid block\\\");\\n    require(blockNumber \\u003e blockLastClaimedOn, \\\"too soon\\\");\\n    require(!entityNodeIsBYON[id] || entityNodeIsActive[id], \\\"not active\\\");\\n\\n    if (\\n      (!entityNodeIsBYON[id] \\u0026\\u0026 recurringNaaSFeeInWei != 0) || (entityNodeIsBYON[id] \\u0026\\u0026 recurringFeeInWei != 0)\\n    ) {\\n      require(blockNumber \\u003c blockLastPaidOn.add(recurringPaymentCycleInBlocks), \\\"pay fee\\\");\\n    }\\n\\n    uint256 reward = getRewardByBlock(sender, nodeId, blockNumber);\\n    require(reward \\u003e 0, \\\"no reward\\\");\\n\\n    uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n    require(msg.value \\u003e= fee, \\\"invalid fee\\\");\\n\\n    feeCollector.transfer(msg.value);\\n\\n    if (toStrongPool) {\\n      strongToken.approve(address(strongPool), reward);\\n      strongPool.mineFor(sender, reward);\\n    } else {\\n      strongToken.transfer(sender, reward);\\n    }\\n\\n    rewardBalance = rewardBalance.sub(reward);\\n    entityNodeClaimedOnBlock[id] = blockNumber;\\n    emit Claimed(sender, reward);\\n  }\\n\\n  function getRewardAll(address entity, uint256 blockNumber) public view returns (uint256) {\\n    uint256 rewardsAll = 0;\\n\\n    for (uint128 i = 1; i \\u003c= entityNodeCount[entity]; i++) {\\n      rewardsAll = rewardsAll.add(getRewardByBlock(entity, i, blockNumber \\u003e 0 ? blockNumber : block.number));\\n    }\\n\\n    return rewardsAll;\\n  }\\n\\n  function doesNodeExist(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id] \\u003e 0;\\n  }\\n\\n  function hasNodeExpired(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n    return block.number \\u003e blockLastPaidOn.add(recurringPaymentCycleInBlocks).add(gracePeriodInBlocks);\\n  }\\n\\n  function getNodeId(address entity, uint128 nodeId) public view returns (bytes memory) {\\n    uint128 id = nodeId != 0 ? nodeId : entityNodeCount[entity] + 1;\\n    return abi.encodePacked(entity, id);\\n  }\\n\\n  function getNodePaidOn(address entity, uint128 nodeId) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id];\\n  }\\n\\n  function getNodeFee(address entity, uint128 nodeId) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\\n  }\\n\\n  function isNodeActive(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsActive[id] || !entityNodeIsBYON[id];\\n  }\\n\\n  function isNodeBYON(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsBYON[id];\\n  }\\n\\n  function hasLegacyNode(address entity) public view returns (bool) {\\n    return entityActive[entity] \\u0026\\u0026 entityNodeCount[entity] == 0;\\n  }\\n\\n  function approveBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = true;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    activeEntities = activeEntities.add(1);\\n  }\\n\\n  function suspendBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = false;\\n    activeEntities = activeEntities.sub(1);\\n  }\\n\\n  function setNodeIsActive(address entity, uint128 nodeId, bool isActive) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (isActive \\u0026\\u0026 !entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.add(1);\\n      entityNodeClaimedOnBlock[id] = block.number;\\n    }\\n\\n    if (!isActive \\u0026\\u0026 entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.sub(1);\\n    }\\n\\n    entityNodeIsActive[id] = isActive;\\n  }\\n\\n  function setNodeIsNaaS(address entity, uint128 nodeId, bool isNaaS) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    entityNodeIsBYON[id] = !isNaaS;\\n  }\\n\\n  function migrateLegacyNode(address entity) private {\\n    bytes memory id = getNodeId(entity, 1);\\n    entityNodeClaimedOnBlock[id] = entityBlockLastClaimedOn[entity];\\n    entityNodePaidOnBlock[id] = paidOnBlock[entity];\\n    entityNodeIsBYON[id] = !entityIsNaaS[entity];\\n    if (entityNodeIsBYON[id]) {\\n      entityNodeIsActive[id] = true;\\n    }\\n    entityNodeCount[msg.sender] = 1;\\n  }\\n\\n  function migrateNode(uint128 nodeId, address to) public {\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    if (hasLegacyNode(to)) {\\n      migrateLegacyNode(to);\\n    }\\n\\n    require(doesNodeExist(msg.sender, nodeId), \\\"doesnt exist\\\");\\n\\n    uint128 toNodeId = entityNodeCount[to] + 1;\\n    bytes memory fromId = getNodeId(msg.sender, nodeId);\\n    bytes memory toId = getNodeId(to, toNodeId);\\n\\n    // move node to another address\\n    entityNodeIsActive[toId] = entityNodeIsActive[fromId];\\n    entityNodeIsBYON[toId] = entityNodeIsBYON[fromId];\\n    entityNodePaidOnBlock[toId] = entityNodePaidOnBlock[fromId];\\n    entityNodeClaimedOnBlock[toId] = entityNodeClaimedOnBlock[fromId];\\n    entityNodeCount[to] = entityNodeCount[to] + 1;\\n\\n    // deactivate node\\n    entityNodeIsActive[fromId] = false;\\n    entityNodePaidOnBlock[fromId] = 0;\\n    entityNodeClaimedOnBlock[fromId] = 0;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] - 1;\\n\\n    emit Migrated(msg.sender, to, nodeId, toNodeId, entityNodeIsBYON[fromId]);\\n  }\\n\\n  function claimAll(uint256 blockNumber, bool toStrongPool) public payable {\\n    for (uint16 i = 1; i \\u003c= entityNodeCount[msg.sender]; i++) {\\n      uint256 reward = getRewardByBlock(msg.sender, i, blockNumber);\\n      uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n      this.claim{value : fee}(i, blockNumber, toStrongPool);\\n    }\\n  }\\n\\n  function payAll() public payable {\\n    for (uint16 i = 1; i \\u003c= entityNodeCount[msg.sender]; i++) {\\n      bytes memory id = getNodeId(msg.sender, i);\\n      uint256 fee = entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\\n      this.payFee{value : fee}(i);\\n    }\\n  }\\n\\n  function addNFTBonusContract(address _contract) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    strongNFTBonus = StrongNFTBonusInterface(_contract);\\n  }\\n}\\n\"},\"ServiceV12.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StrongPoolInterface.sol\\\";\\nimport \\\"./IERC1155Preset.sol\\\";\\nimport \\\"./StrongNFTBonusInterface.sol\\\";\\nimport \\\"./rewards.sol\\\";\\n\\ncontract ServiceV12 {\\n  event Requested(address indexed miner);\\n  event Claimed(address indexed miner, uint256 reward);\\n\\n  using SafeMath for uint256;\\n  bool public initDone;\\n  address public admin;\\n  address public pendingAdmin;\\n  address public superAdmin;\\n  address public pendingSuperAdmin;\\n  address public serviceAdmin;\\n  address public parameterAdmin;\\n  address payable public feeCollector;\\n\\n  IERC20 public strongToken;\\n  StrongPoolInterface public strongPool;\\n\\n  uint256 public rewardPerBlockNumerator;\\n  uint256 public rewardPerBlockDenominator;\\n\\n  uint256 public naasRewardPerBlockNumerator;\\n  uint256 public naasRewardPerBlockDenominator;\\n\\n  uint256 public claimingFeeNumerator;\\n  uint256 public claimingFeeDenominator;\\n\\n  uint256 public requestingFeeInWei;\\n\\n  uint256 public strongFeeInWei;\\n\\n  uint256 public recurringFeeInWei;\\n  uint256 public recurringNaaSFeeInWei;\\n  uint256 public recurringPaymentCycleInBlocks;\\n\\n  uint256 public rewardBalance;\\n\\n  mapping(address =\\u003e uint256) public entityBlockLastClaimedOn;\\n\\n  address[] public entities;\\n  mapping(address =\\u003e uint256) public entityIndex;\\n  mapping(address =\\u003e bool) public entityActive;\\n  mapping(address =\\u003e bool) public requestPending;\\n  mapping(address =\\u003e bool) public entityIsNaaS;\\n  mapping(address =\\u003e uint256) public paidOnBlock;\\n  uint256 public activeEntities;\\n\\n  string public desciption;\\n\\n  uint256 public claimingFeeInWei;\\n\\n  uint256 public naasRequestingFeeInWei;\\n\\n  uint256 public naasStrongFeeInWei;\\n\\n  bool public removedTokens;\\n\\n  mapping(address =\\u003e uint256) public traunch;\\n\\n  uint256 public currentTraunch;\\n\\n  mapping(bytes =\\u003e bool) public entityNodeIsActive;\\n  mapping(bytes =\\u003e bool) public entityNodeIsBYON;\\n  mapping(bytes =\\u003e uint256) public entityNodeTraunch;\\n  mapping(bytes =\\u003e uint256) public entityNodePaidOnBlock;\\n  mapping(bytes =\\u003e uint256) public entityNodeClaimedOnBlock;\\n  mapping(address =\\u003e uint128) public entityNodeCount;\\n\\n  event Paid(address indexed entity, uint128 nodeId, bool isBYON, bool isRenewal, uint256 upToBlockNumber);\\n  event Migrated(address indexed from, address indexed to, uint128 fromNodeId, uint128 toNodeId, bool isBYON);\\n\\n  uint256 public rewardPerBlockNumeratorNew;\\n  uint256 public rewardPerBlockDenominatorNew;\\n  uint256 public naasRewardPerBlockNumeratorNew;\\n  uint256 public naasRewardPerBlockDenominatorNew;\\n  uint256 public rewardPerBlockNewEffectiveBlock;\\n\\n  StrongNFTBonusInterface public strongNFTBonus;\\n\\n  uint256 public gracePeriodInBlocks;\\n\\n  function init(\\n    address strongTokenAddress,\\n    address strongPoolAddress,\\n    address adminAddress,\\n    address superAdminAddress,\\n    uint256 rewardPerBlockNumeratorValue,\\n    uint256 rewardPerBlockDenominatorValue,\\n    uint256 naasRewardPerBlockNumeratorValue,\\n    uint256 naasRewardPerBlockDenominatorValue,\\n    uint256 requestingFeeInWeiValue,\\n    uint256 strongFeeInWeiValue,\\n    uint256 recurringFeeInWeiValue,\\n    uint256 recurringNaaSFeeInWeiValue,\\n    uint256 recurringPaymentCycleInBlocksValue,\\n    uint256 claimingFeeNumeratorValue,\\n    uint256 claimingFeeDenominatorValue,\\n    string memory desc\\n  ) public {\\n    require(!initDone, \\\"init done\\\");\\n    strongToken = IERC20(strongTokenAddress);\\n    strongPool = StrongPoolInterface(strongPoolAddress);\\n    admin = adminAddress;\\n    superAdmin = superAdminAddress;\\n    rewardPerBlockNumerator = rewardPerBlockNumeratorValue;\\n    rewardPerBlockDenominator = rewardPerBlockDenominatorValue;\\n    naasRewardPerBlockNumerator = naasRewardPerBlockNumeratorValue;\\n    naasRewardPerBlockDenominator = naasRewardPerBlockDenominatorValue;\\n    requestingFeeInWei = requestingFeeInWeiValue;\\n    strongFeeInWei = strongFeeInWeiValue;\\n    recurringFeeInWei = recurringFeeInWeiValue;\\n    recurringNaaSFeeInWei = recurringNaaSFeeInWeiValue;\\n    claimingFeeNumerator = claimingFeeNumeratorValue;\\n    claimingFeeDenominator = claimingFeeDenominatorValue;\\n    recurringPaymentCycleInBlocks = recurringPaymentCycleInBlocksValue;\\n    desciption = desc;\\n    initDone = true;\\n  }\\n\\n  function updateServiceAdmin(address newServiceAdmin) public {\\n    require(msg.sender == superAdmin);\\n    serviceAdmin = newServiceAdmin;\\n  }\\n\\n  function updateParameterAdmin(address newParameterAdmin) public {\\n    require(newParameterAdmin != address(0));\\n    require(msg.sender == superAdmin);\\n    parameterAdmin = newParameterAdmin;\\n  }\\n\\n  function updateFeeCollector(address payable newFeeCollector) public {\\n    require(newFeeCollector != address(0));\\n    require(msg.sender == superAdmin);\\n    feeCollector = newFeeCollector;\\n  }\\n\\n  function setPendingAdmin(address newPendingAdmin) public {\\n    require(msg.sender == admin);\\n    pendingAdmin = newPendingAdmin;\\n  }\\n\\n  function acceptAdmin() public {\\n    require(msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingAdmin\\\");\\n    admin = pendingAdmin;\\n    pendingAdmin = address(0);\\n  }\\n\\n  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\\n    require(msg.sender == superAdmin, \\\"not superAdmin\\\");\\n    pendingSuperAdmin = newPendingSuperAdmin;\\n  }\\n\\n  function acceptSuperAdmin() public {\\n    require(msg.sender == pendingSuperAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingSuperAdmin\\\");\\n    superAdmin = pendingSuperAdmin;\\n    pendingSuperAdmin = address(0);\\n  }\\n\\n  function isEntityActive(address entity) public view returns (bool) {\\n    return entityActive[entity] || (doesNodeExist(entity, 1) \\u0026\\u0026 !hasNodeExpired(entity, 1));\\n  }\\n\\n  function updateRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(denominator != 0);\\n    rewardPerBlockNumerator = numerator;\\n    rewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateNaaSRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(denominator != 0);\\n    naasRewardPerBlockNumerator = numerator;\\n    naasRewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateRewardPerBlockNew(\\n    uint256 numerator,\\n    uint256 denominator,\\n    uint256 numeratorNass,\\n    uint256 denominatorNass,\\n    uint256 effectiveBlock\\n  ) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n\\n    rewardPerBlockNumeratorNew = numerator;\\n    rewardPerBlockDenominatorNew = denominator;\\n    naasRewardPerBlockNumeratorNew = numeratorNass;\\n    naasRewardPerBlockDenominatorNew = denominatorNass;\\n    rewardPerBlockNewEffectiveBlock = effectiveBlock != 0 ? effectiveBlock : block.number;\\n  }\\n\\n  function deposit(uint256 amount) public {\\n    require(msg.sender == superAdmin);\\n    require(amount \\u003e 0);\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    rewardBalance = rewardBalance.add(amount);\\n  }\\n\\n  function withdraw(address destination, uint256 amount) public {\\n    require(msg.sender == superAdmin);\\n    require(amount \\u003e 0);\\n    require(rewardBalance \\u003e= amount, \\\"not enough\\\");\\n    strongToken.transfer(destination, amount);\\n    rewardBalance = rewardBalance.sub(amount);\\n  }\\n\\n  function updateRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    requestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    strongFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    naasRequestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    naasStrongFeeInWei = feeInWei;\\n  }\\n\\n  function updateClaimingFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(denominator != 0);\\n    claimingFeeNumerator = numerator;\\n    claimingFeeDenominator = denominator;\\n  }\\n\\n  function updateRecurringFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    recurringFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringNaaSFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    recurringNaaSFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringPaymentCycleInBlocks(uint256 blocks) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(blocks \\u003e 0);\\n    recurringPaymentCycleInBlocks = blocks;\\n  }\\n\\n  function updateGracePeriodInBlocks(uint256 blocks) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(blocks \\u003e 0);\\n    gracePeriodInBlocks = blocks;\\n  }\\n\\n  function requestAccess(bool isNaaS) public payable {\\n    uint256 rFee;\\n    uint256 sFee;\\n\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    uint128 nodeId = entityNodeCount[msg.sender] + 1;\\n    bytes memory id = getNodeId(msg.sender, nodeId);\\n\\n    if (isNaaS) {\\n      rFee = naasRequestingFeeInWei;\\n      sFee = naasStrongFeeInWei;\\n      activeEntities = activeEntities.add(1);\\n    } else {\\n      rFee = requestingFeeInWei;\\n      sFee = strongFeeInWei;\\n      entityNodeIsBYON[id] = true;\\n    }\\n\\n    require(msg.value == rFee, \\\"invalid fee\\\");\\n\\n    entityNodePaidOnBlock[id] = block.number;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] + 1;\\n\\n    feeCollector.transfer(msg.value);\\n    strongToken.transferFrom(msg.sender, address(this), sFee);\\n    strongToken.transfer(feeCollector, sFee);\\n\\n    emit Paid(msg.sender, nodeId, entityNodeIsBYON[id], false, entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks));\\n  }\\n\\n  function setEntityActiveStatus(address entity, bool status) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n    uint256 index = entityIndex[entity];\\n    require(entities[index] == entity, \\\"invalid entity\\\");\\n    require(entityActive[entity] != status, \\\"already set\\\");\\n    entityActive[entity] = status;\\n    if (status) {\\n      activeEntities = activeEntities.add(1);\\n      entityBlockLastClaimedOn[entity] = block.number;\\n    } else {\\n      activeEntities = activeEntities.sub(1);\\n      entityBlockLastClaimedOn[entity] = 0;\\n    }\\n  }\\n\\n  function payFee(uint128 nodeId) public payable {\\n    address sender = msg.sender == address(this) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    bool isExpired = hasNodeExpired(sender, nodeId);\\n\\n    require(doesNodeExist(sender, nodeId), \\\"doesnt exist\\\");\\n    require(isExpired == false || msg.sender == address(this), \\\"too late\\\");\\n\\n    if (isExpired) {\\n      return;\\n    }\\n\\n    if (entityNodeIsBYON[id]) {\\n      require(msg.value == recurringFeeInWei, \\\"invalid fee\\\");\\n    } else {\\n      require(msg.value == recurringNaaSFeeInWei, \\\"invalid fee\\\");\\n    }\\n\\n    feeCollector.transfer(msg.value);\\n    entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\\n\\n    emit Paid(sender, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\\n  }\\n\\n  function getReward(address entity, uint128 nodeId) public view returns (uint256) {\\n    return getRewardByBlock(entity, nodeId, block.number);\\n  }\\n\\n  function getRewardByBlock(address entity, uint128 nodeId, uint256 blockNumber) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (hasLegacyNode(entity)) {\\n      return getRewardByBlockLegacy(entity, blockNumber);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (blockLastClaimedOn == 0) return 0;\\n    if (blockNumber \\u003c blockLastClaimedOn) return 0;\\n    if (activeEntities == 0) return 0;\\n    if (entityNodeIsBYON[id] \\u0026\\u0026 !entityNodeIsActive[id]) return 0;\\n\\n    uint256 rewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumerator : naasRewardPerBlockNumerator;\\n    uint256 rewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominator : naasRewardPerBlockDenominator;\\n    uint256 newRewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumeratorNew : naasRewardPerBlockNumeratorNew;\\n    uint256 newRewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominatorNew : naasRewardPerBlockDenominatorNew;\\n\\n    uint256 bonus = address(strongNFTBonus) != address(0)\\n    ? strongNFTBonus.getBonus(entity, nodeId, blockLastClaimedOn, blockNumber)\\n    : 0;\\n\\n    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, blockNumber);\\n    uint256 rewardOld = rewardDenominator \\u003e 0 ? rewardBlocks[0].mul(rewardNumerator).div(rewardDenominator) : 0;\\n    uint256 rewardNew = newRewardDenominator \\u003e 0 ? rewardBlocks[1].mul(newRewardNumerator).div(newRewardDenominator) : 0;\\n\\n    return rewardOld.add(rewardNew).add(bonus);\\n  }\\n\\n  function getRewardByBlockLegacy(address entity, uint256 blockNumber) public view returns (uint256) {\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (entityBlockLastClaimedOn[entity] == 0) return 0;\\n    if (blockNumber \\u003c entityBlockLastClaimedOn[entity]) return 0;\\n    if (activeEntities == 0) return 0;\\n    uint256 blockResult = blockNumber.sub(entityBlockLastClaimedOn[entity]);\\n    uint256 rewardNumerator;\\n    uint256 rewardDenominator;\\n    if (entityIsNaaS[entity]) {\\n      rewardNumerator = naasRewardPerBlockNumerator;\\n      rewardDenominator = naasRewardPerBlockDenominator;\\n    } else {\\n      rewardNumerator = rewardPerBlockNumerator;\\n      rewardDenominator = rewardPerBlockDenominator;\\n    }\\n    uint256 rewardPerBlockResult = blockResult.mul(rewardNumerator).div(rewardDenominator);\\n\\n    return rewardPerBlockResult;\\n  }\\n\\n  function claim(uint128 nodeId, uint256 blockNumber, bool toStrongPool) public payable {\\n    address sender = msg.sender == address(this) || msg.sender == address(strongNFTBonus) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n\\n    require(blockLastClaimedOn != 0, \\\"never claimed\\\");\\n    require(blockNumber \\u003c= block.number, \\\"invalid block\\\");\\n    require(blockNumber \\u003e blockLastClaimedOn, \\\"too soon\\\");\\n    require(!entityNodeIsBYON[id] || entityNodeIsActive[id], \\\"not active\\\");\\n\\n    if (\\n      (!entityNodeIsBYON[id] \\u0026\\u0026 recurringNaaSFeeInWei != 0) || (entityNodeIsBYON[id] \\u0026\\u0026 recurringFeeInWei != 0)\\n    ) {\\n      require(blockNumber \\u003c blockLastPaidOn.add(recurringPaymentCycleInBlocks), \\\"pay fee\\\");\\n    }\\n\\n    uint256 reward = getRewardByBlock(sender, nodeId, blockNumber);\\n    require(reward \\u003e 0, \\\"no reward\\\");\\n\\n    uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n    require(msg.value \\u003e= fee, \\\"invalid fee\\\");\\n\\n    feeCollector.transfer(msg.value);\\n\\n    if (toStrongPool) {\\n      strongToken.approve(address(strongPool), reward);\\n      strongPool.mineFor(sender, reward);\\n    } else {\\n      strongToken.transfer(sender, reward);\\n    }\\n\\n    rewardBalance = rewardBalance.sub(reward);\\n    entityNodeClaimedOnBlock[id] = blockNumber;\\n    emit Claimed(sender, reward);\\n  }\\n\\n  function getRewardAll(address entity, uint256 blockNumber) public view returns (uint256) {\\n    uint256 rewardsAll = 0;\\n\\n    for (uint128 i = 1; i \\u003c= entityNodeCount[entity]; i++) {\\n      rewardsAll = rewardsAll.add(getRewardByBlock(entity, i, blockNumber \\u003e 0 ? blockNumber : block.number));\\n    }\\n\\n    return rewardsAll;\\n  }\\n\\n  function doesNodeExist(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id] \\u003e 0;\\n  }\\n\\n  function hasNodeExpired(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n    return block.number \\u003e blockLastPaidOn.add(recurringPaymentCycleInBlocks).add(gracePeriodInBlocks);\\n  }\\n\\n  function getNodeId(address entity, uint128 nodeId) public view returns (bytes memory) {\\n    uint128 id = nodeId != 0 ? nodeId : entityNodeCount[entity] + 1;\\n    return abi.encodePacked(entity, id);\\n  }\\n\\n  function getNodePaidOn(address entity, uint128 nodeId) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id];\\n  }\\n\\n  function getNodeFee(address entity, uint128 nodeId) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\\n  }\\n\\n  function isNodeActive(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsActive[id] || !entityNodeIsBYON[id];\\n  }\\n\\n  function isNodeBYON(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsBYON[id];\\n  }\\n\\n  function hasLegacyNode(address entity) public view returns (bool) {\\n    return entityActive[entity] \\u0026\\u0026 entityNodeCount[entity] == 0;\\n  }\\n\\n  function approveBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = true;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    activeEntities = activeEntities.add(1);\\n  }\\n\\n  function suspendBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = false;\\n    activeEntities = activeEntities.sub(1);\\n  }\\n\\n  function setNodeIsActive(address entity, uint128 nodeId, bool isActive) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (isActive \\u0026\\u0026 !entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.add(1);\\n      entityNodeClaimedOnBlock[id] = block.number;\\n    }\\n\\n    if (!isActive \\u0026\\u0026 entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.sub(1);\\n    }\\n\\n    entityNodeIsActive[id] = isActive;\\n  }\\n\\n  function setNodeIsNaaS(address entity, uint128 nodeId, bool isNaaS) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    entityNodeIsBYON[id] = !isNaaS;\\n  }\\n\\n  function migrateLegacyNode(address entity) private {\\n    bytes memory id = getNodeId(entity, 1);\\n    entityNodeClaimedOnBlock[id] = entityBlockLastClaimedOn[entity];\\n    entityNodePaidOnBlock[id] = paidOnBlock[entity];\\n    entityNodeIsBYON[id] = !entityIsNaaS[entity];\\n    if (entityNodeIsBYON[id]) {\\n      entityNodeIsActive[id] = true;\\n    }\\n    entityNodeCount[msg.sender] = 1;\\n  }\\n\\n  function migrateNode(uint128 nodeId, address to) public {\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    if (hasLegacyNode(to)) {\\n      migrateLegacyNode(to);\\n    }\\n\\n    require(doesNodeExist(msg.sender, nodeId), \\\"doesnt exist\\\");\\n\\n    uint128 toNodeId = entityNodeCount[to] + 1;\\n    bytes memory fromId = getNodeId(msg.sender, nodeId);\\n    bytes memory toId = getNodeId(to, toNodeId);\\n\\n    // move node to another address\\n    entityNodeIsActive[toId] = entityNodeIsActive[fromId];\\n    entityNodeIsBYON[toId] = entityNodeIsBYON[fromId];\\n    entityNodePaidOnBlock[toId] = entityNodePaidOnBlock[fromId];\\n    entityNodeClaimedOnBlock[toId] = entityNodeClaimedOnBlock[fromId];\\n    entityNodeCount[to] = entityNodeCount[to] + 1;\\n\\n    // deactivate node\\n    entityNodeIsActive[fromId] = false;\\n    entityNodePaidOnBlock[fromId] = 0;\\n    entityNodeClaimedOnBlock[fromId] = 0;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] - 1;\\n\\n    emit Migrated(msg.sender, to, nodeId, toNodeId, entityNodeIsBYON[fromId]);\\n  }\\n\\n  function claimAll(uint256 blockNumber, bool toStrongPool) public payable {\\n    for (uint16 i = 1; i \\u003c= entityNodeCount[msg.sender]; i++) {\\n      uint256 reward = getRewardByBlock(msg.sender, i, blockNumber);\\n      uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n      this.claim{value : fee}(i, blockNumber, toStrongPool);\\n    }\\n  }\\n\\n  function payAll() public payable {\\n    for (uint16 i = 1; i \\u003c= entityNodeCount[msg.sender]; i++) {\\n      bytes memory id = getNodeId(msg.sender, i);\\n      uint256 fee = entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\\n      this.payFee{value : fee}(i);\\n    }\\n  }\\n\\n  function addNFTBonusContract(address _contract) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    strongNFTBonus = StrongNFTBonusInterface(_contract);\\n  }\\n\\n  function payFeeAdmin(address entity, uint128[] memory nodes) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    for (uint256 i = 0; i \\u003c nodes.length; i++) {\\n      uint128 nodeId = nodes[i];\\n      bytes memory id = getNodeId(entity, nodeId);\\n      entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\\n\\n      emit Paid(entity, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\\n    }\\n  }\\n\\n}\\n\"},\"ServiceV13.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StrongPoolInterface.sol\\\";\\nimport \\\"./IERC1155Preset.sol\\\";\\nimport \\\"./StrongNFTBonusInterface.sol\\\";\\nimport \\\"./rewards.sol\\\";\\n\\ncontract ServiceV13 {\\n  event Requested(address indexed miner);\\n  event Claimed(address indexed miner, uint256 reward);\\n\\n  using SafeMath for uint256;\\n  bool public initDone;\\n  address public admin;\\n  address public pendingAdmin;\\n  address public superAdmin;\\n  address public pendingSuperAdmin;\\n  address public serviceAdmin;\\n  address public parameterAdmin;\\n  address payable public feeCollector;\\n\\n  IERC20 public strongToken;\\n  StrongPoolInterface public strongPool;\\n\\n  uint256 public rewardPerBlockNumerator;\\n  uint256 public rewardPerBlockDenominator;\\n\\n  uint256 public naasRewardPerBlockNumerator;\\n  uint256 public naasRewardPerBlockDenominator;\\n\\n  uint256 public claimingFeeNumerator;\\n  uint256 public claimingFeeDenominator;\\n\\n  uint256 public requestingFeeInWei;\\n\\n  uint256 public strongFeeInWei;\\n\\n  uint256 public recurringFeeInWei;\\n  uint256 public recurringNaaSFeeInWei;\\n  uint256 public recurringPaymentCycleInBlocks;\\n\\n  uint256 public rewardBalance;\\n\\n  mapping(address =\\u003e uint256) public entityBlockLastClaimedOn;\\n\\n  address[] public entities;\\n  mapping(address =\\u003e uint256) public entityIndex;\\n  mapping(address =\\u003e bool) public entityActive;\\n  mapping(address =\\u003e bool) public requestPending;\\n  mapping(address =\\u003e bool) public entityIsNaaS;\\n  mapping(address =\\u003e uint256) public paidOnBlock;\\n  uint256 public activeEntities;\\n\\n  string public desciption;\\n\\n  uint256 public claimingFeeInWei;\\n\\n  uint256 public naasRequestingFeeInWei;\\n\\n  uint256 public naasStrongFeeInWei;\\n\\n  bool public removedTokens;\\n\\n  mapping(address =\\u003e uint256) public traunch;\\n\\n  uint256 public currentTraunch;\\n\\n  mapping(bytes =\\u003e bool) public entityNodeIsActive;\\n  mapping(bytes =\\u003e bool) public entityNodeIsBYON;\\n  mapping(bytes =\\u003e uint256) public entityNodeTraunch;\\n  mapping(bytes =\\u003e uint256) public entityNodePaidOnBlock;\\n  mapping(bytes =\\u003e uint256) public entityNodeClaimedOnBlock;\\n  mapping(address =\\u003e uint128) public entityNodeCount;\\n\\n  event Paid(address indexed entity, uint128 nodeId, bool isBYON, bool isRenewal, uint256 upToBlockNumber);\\n  event Migrated(address indexed from, address indexed to, uint128 fromNodeId, uint128 toNodeId, bool isBYON);\\n\\n  uint256 public rewardPerBlockNumeratorNew;\\n  uint256 public rewardPerBlockDenominatorNew;\\n  uint256 public naasRewardPerBlockNumeratorNew;\\n  uint256 public naasRewardPerBlockDenominatorNew;\\n  uint256 public rewardPerBlockNewEffectiveBlock;\\n\\n  StrongNFTBonusInterface public strongNFTBonus;\\n\\n  uint256 public gracePeriodInBlocks;\\n\\n  uint128 public maxNodes;\\n  uint256 public maxPaymentPeriods;\\n\\n  function init(\\n    address strongTokenAddress,\\n    address strongPoolAddress,\\n    address adminAddress,\\n    address superAdminAddress,\\n    uint256 rewardPerBlockNumeratorValue,\\n    uint256 rewardPerBlockDenominatorValue,\\n    uint256 naasRewardPerBlockNumeratorValue,\\n    uint256 naasRewardPerBlockDenominatorValue,\\n    uint256 requestingFeeInWeiValue,\\n    uint256 strongFeeInWeiValue,\\n    uint256 recurringFeeInWeiValue,\\n    uint256 recurringNaaSFeeInWeiValue,\\n    uint256 recurringPaymentCycleInBlocksValue,\\n    uint256 claimingFeeNumeratorValue,\\n    uint256 claimingFeeDenominatorValue,\\n    string memory desc\\n  ) public {\\n    require(!initDone, \\\"init done\\\");\\n    strongToken = IERC20(strongTokenAddress);\\n    strongPool = StrongPoolInterface(strongPoolAddress);\\n    admin = adminAddress;\\n    superAdmin = superAdminAddress;\\n    rewardPerBlockNumerator = rewardPerBlockNumeratorValue;\\n    rewardPerBlockDenominator = rewardPerBlockDenominatorValue;\\n    naasRewardPerBlockNumerator = naasRewardPerBlockNumeratorValue;\\n    naasRewardPerBlockDenominator = naasRewardPerBlockDenominatorValue;\\n    requestingFeeInWei = requestingFeeInWeiValue;\\n    strongFeeInWei = strongFeeInWeiValue;\\n    recurringFeeInWei = recurringFeeInWeiValue;\\n    recurringNaaSFeeInWei = recurringNaaSFeeInWeiValue;\\n    claimingFeeNumerator = claimingFeeNumeratorValue;\\n    claimingFeeDenominator = claimingFeeDenominatorValue;\\n    recurringPaymentCycleInBlocks = recurringPaymentCycleInBlocksValue;\\n    desciption = desc;\\n    initDone = true;\\n  }\\n\\n  function updateServiceAdmin(address newServiceAdmin) public {\\n    require(msg.sender == superAdmin);\\n    serviceAdmin = newServiceAdmin;\\n  }\\n\\n  function updateParameterAdmin(address newParameterAdmin) public {\\n    require(newParameterAdmin != address(0));\\n    require(msg.sender == superAdmin);\\n    parameterAdmin = newParameterAdmin;\\n  }\\n\\n  function updateFeeCollector(address payable newFeeCollector) public {\\n    require(newFeeCollector != address(0));\\n    require(msg.sender == superAdmin);\\n    feeCollector = newFeeCollector;\\n  }\\n\\n  function setPendingAdmin(address newPendingAdmin) public {\\n    require(msg.sender == admin);\\n    pendingAdmin = newPendingAdmin;\\n  }\\n\\n  function acceptAdmin() public {\\n    require(msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingAdmin\\\");\\n    admin = pendingAdmin;\\n    pendingAdmin = address(0);\\n  }\\n\\n  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\\n    require(msg.sender == superAdmin, \\\"not superAdmin\\\");\\n    pendingSuperAdmin = newPendingSuperAdmin;\\n  }\\n\\n  function acceptSuperAdmin() public {\\n    require(msg.sender == pendingSuperAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingSuperAdmin\\\");\\n    superAdmin = pendingSuperAdmin;\\n    pendingSuperAdmin = address(0);\\n  }\\n\\n  function isEntityActive(address entity) public view returns (bool) {\\n    return entityActive[entity] || (doesNodeExist(entity, 1) \\u0026\\u0026 !hasNodeExpired(entity, 1));\\n  }\\n\\n  function updateRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(denominator != 0);\\n    rewardPerBlockNumerator = numerator;\\n    rewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateNaaSRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(denominator != 0);\\n    naasRewardPerBlockNumerator = numerator;\\n    naasRewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateRewardPerBlockNew(\\n    uint256 numerator,\\n    uint256 denominator,\\n    uint256 numeratorNass,\\n    uint256 denominatorNass,\\n    uint256 effectiveBlock\\n  ) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n\\n    rewardPerBlockNumeratorNew = numerator;\\n    rewardPerBlockDenominatorNew = denominator;\\n    naasRewardPerBlockNumeratorNew = numeratorNass;\\n    naasRewardPerBlockDenominatorNew = denominatorNass;\\n    rewardPerBlockNewEffectiveBlock = effectiveBlock != 0 ? effectiveBlock : block.number;\\n  }\\n\\n  function deposit(uint256 amount) public {\\n    require(msg.sender == superAdmin);\\n    require(amount \\u003e 0);\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    rewardBalance = rewardBalance.add(amount);\\n  }\\n\\n  function withdraw(address destination, uint256 amount) public {\\n    require(msg.sender == superAdmin);\\n    require(amount \\u003e 0);\\n    require(rewardBalance \\u003e= amount, \\\"not enough\\\");\\n    strongToken.transfer(destination, amount);\\n    rewardBalance = rewardBalance.sub(amount);\\n  }\\n\\n  function updateRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    requestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    strongFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    naasRequestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    naasStrongFeeInWei = feeInWei;\\n  }\\n\\n  function updateClaimingFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(denominator != 0);\\n    claimingFeeNumerator = numerator;\\n    claimingFeeDenominator = denominator;\\n  }\\n\\n  function updateRecurringFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    recurringFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringNaaSFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    recurringNaaSFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringPaymentCycleInBlocks(uint256 blocks) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(blocks \\u003e 0);\\n    recurringPaymentCycleInBlocks = blocks;\\n  }\\n\\n  function updateGracePeriodInBlocks(uint256 blocks) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(blocks \\u003e 0);\\n    gracePeriodInBlocks = blocks;\\n  }\\n\\n  function requestAccess(bool isNaaS) public payable {\\n    require(entityNodeCount[msg.sender] \\u003c maxNodes, \\\"limit reached\\\");\\n\\n    uint256 rFee;\\n    uint256 sFee;\\n\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    uint128 nodeId = entityNodeCount[msg.sender] + 1;\\n    bytes memory id = getNodeId(msg.sender, nodeId);\\n\\n    if (isNaaS) {\\n      rFee = naasRequestingFeeInWei;\\n      sFee = naasStrongFeeInWei;\\n      activeEntities = activeEntities.add(1);\\n    } else {\\n      rFee = requestingFeeInWei;\\n      sFee = strongFeeInWei;\\n      entityNodeIsBYON[id] = true;\\n    }\\n\\n    require(msg.value == rFee, \\\"invalid fee\\\");\\n\\n    entityNodePaidOnBlock[id] = block.number;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] + 1;\\n\\n    feeCollector.transfer(msg.value);\\n    strongToken.transferFrom(msg.sender, address(this), sFee);\\n    strongToken.transfer(feeCollector, sFee);\\n\\n    emit Paid(msg.sender, nodeId, entityNodeIsBYON[id], false, entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks));\\n  }\\n\\n  function setEntityActiveStatus(address entity, bool status) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n    uint256 index = entityIndex[entity];\\n    require(entities[index] == entity, \\\"invalid entity\\\");\\n    require(entityActive[entity] != status, \\\"already set\\\");\\n    entityActive[entity] = status;\\n    if (status) {\\n      activeEntities = activeEntities.add(1);\\n      entityBlockLastClaimedOn[entity] = block.number;\\n    } else {\\n      activeEntities = activeEntities.sub(1);\\n      entityBlockLastClaimedOn[entity] = 0;\\n    }\\n  }\\n\\n  function payFee(uint128 nodeId) public payable {\\n    address sender = msg.sender == address(this) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    require(doesNodeExist(sender, nodeId), \\\"doesnt exist\\\");\\n    require(hasNodeExpired(sender, nodeId) == false, \\\"too late\\\");\\n    require(hasMaxPayments(sender, nodeId) == false, \\\"too soon\\\");\\n\\n    if (entityNodeIsBYON[id]) {\\n      require(msg.value == recurringFeeInWei, \\\"invalid fee\\\");\\n    } else {\\n      require(msg.value == recurringNaaSFeeInWei, \\\"invalid fee\\\");\\n    }\\n\\n    feeCollector.transfer(msg.value);\\n    entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\\n\\n    emit Paid(sender, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\\n  }\\n\\n  function getReward(address entity, uint128 nodeId) public view returns (uint256) {\\n    return getRewardByBlock(entity, nodeId, block.number);\\n  }\\n\\n  function getRewardByBlock(address entity, uint128 nodeId, uint256 blockNumber) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (hasLegacyNode(entity)) {\\n      return getRewardByBlockLegacy(entity, blockNumber);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (blockLastClaimedOn == 0) return 0;\\n    if (blockNumber \\u003c blockLastClaimedOn) return 0;\\n    if (activeEntities == 0) return 0;\\n    if (entityNodeIsBYON[id] \\u0026\\u0026 !entityNodeIsActive[id]) return 0;\\n\\n    uint256 rewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumerator : naasRewardPerBlockNumerator;\\n    uint256 rewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominator : naasRewardPerBlockDenominator;\\n    uint256 newRewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumeratorNew : naasRewardPerBlockNumeratorNew;\\n    uint256 newRewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominatorNew : naasRewardPerBlockDenominatorNew;\\n\\n    uint256 bonus = address(strongNFTBonus) != address(0)\\n    ? strongNFTBonus.getBonus(entity, nodeId, blockLastClaimedOn, blockNumber)\\n    : 0;\\n\\n    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, blockNumber);\\n    uint256 rewardOld = rewardDenominator \\u003e 0 ? rewardBlocks[0].mul(rewardNumerator).div(rewardDenominator) : 0;\\n    uint256 rewardNew = newRewardDenominator \\u003e 0 ? rewardBlocks[1].mul(newRewardNumerator).div(newRewardDenominator) : 0;\\n\\n    return rewardOld.add(rewardNew).add(bonus);\\n  }\\n\\n  function getRewardByBlockLegacy(address entity, uint256 blockNumber) public view returns (uint256) {\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (entityBlockLastClaimedOn[entity] == 0) return 0;\\n    if (blockNumber \\u003c entityBlockLastClaimedOn[entity]) return 0;\\n    if (activeEntities == 0) return 0;\\n    uint256 blockResult = blockNumber.sub(entityBlockLastClaimedOn[entity]);\\n    uint256 rewardNumerator;\\n    uint256 rewardDenominator;\\n    if (entityIsNaaS[entity]) {\\n      rewardNumerator = naasRewardPerBlockNumerator;\\n      rewardDenominator = naasRewardPerBlockDenominator;\\n    } else {\\n      rewardNumerator = rewardPerBlockNumerator;\\n      rewardDenominator = rewardPerBlockDenominator;\\n    }\\n    uint256 rewardPerBlockResult = blockResult.mul(rewardNumerator).div(rewardDenominator);\\n\\n    return rewardPerBlockResult;\\n  }\\n\\n  function claim(uint128 nodeId, uint256 blockNumber, bool toStrongPool) public payable {\\n    address sender = msg.sender == address(this) || msg.sender == address(strongNFTBonus) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n\\n    require(blockLastClaimedOn != 0, \\\"never claimed\\\");\\n    require(blockNumber \\u003c= block.number, \\\"invalid block\\\");\\n    require(blockNumber \\u003e blockLastClaimedOn, \\\"too soon\\\");\\n    require(!entityNodeIsBYON[id] || entityNodeIsActive[id], \\\"not active\\\");\\n\\n    if (\\n      (!entityNodeIsBYON[id] \\u0026\\u0026 recurringNaaSFeeInWei != 0) || (entityNodeIsBYON[id] \\u0026\\u0026 recurringFeeInWei != 0)\\n    ) {\\n      require(blockNumber \\u003c blockLastPaidOn.add(recurringPaymentCycleInBlocks), \\\"pay fee\\\");\\n    }\\n\\n    uint256 reward = getRewardByBlock(sender, nodeId, blockNumber);\\n    require(reward \\u003e 0, \\\"no reward\\\");\\n\\n    uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n    require(msg.value \\u003e= fee, \\\"invalid fee\\\");\\n\\n    feeCollector.transfer(msg.value);\\n\\n    if (toStrongPool) {\\n      strongToken.approve(address(strongPool), reward);\\n      strongPool.mineFor(sender, reward);\\n    } else {\\n      strongToken.transfer(sender, reward);\\n    }\\n\\n    rewardBalance = rewardBalance.sub(reward);\\n    entityNodeClaimedOnBlock[id] = blockNumber;\\n    emit Claimed(sender, reward);\\n  }\\n\\n  function getRewardAll(address entity, uint256 blockNumber) public view returns (uint256) {\\n    uint256 rewardsAll = 0;\\n\\n    for (uint128 i = 1; i \\u003c= entityNodeCount[entity]; i++) {\\n      rewardsAll = rewardsAll.add(getRewardByBlock(entity, i, blockNumber \\u003e 0 ? blockNumber : block.number));\\n    }\\n\\n    return rewardsAll;\\n  }\\n\\n  function canBePaid(address entity, uint128 nodeId) public view returns (bool) {\\n    return !isNodeBYON(entity, nodeId) \\u0026\\u0026 !hasNodeExpired(entity, nodeId) \\u0026\\u0026 !hasMaxPayments(entity, nodeId);\\n  }\\n\\n  function doesNodeExist(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id] \\u003e 0;\\n  }\\n\\n  function hasNodeExpired(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n    return block.number \\u003e blockLastPaidOn.add(recurringPaymentCycleInBlocks).add(gracePeriodInBlocks);\\n  }\\n\\n  function hasMaxPayments(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n    uint256 limit = block.number.add(recurringPaymentCycleInBlocks.mul(maxPaymentPeriods));\\n\\n    return blockLastPaidOn.add(recurringPaymentCycleInBlocks) \\u003e= limit;\\n  }\\n\\n  function getNodeId(address entity, uint128 nodeId) public view returns (bytes memory) {\\n    uint128 id = nodeId != 0 ? nodeId : entityNodeCount[entity] + 1;\\n    return abi.encodePacked(entity, id);\\n  }\\n\\n  function getNodePaidOn(address entity, uint128 nodeId) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id];\\n  }\\n\\n  function isNodeActive(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsActive[id] || !entityNodeIsBYON[id];\\n  }\\n\\n  function isNodeBYON(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsBYON[id];\\n  }\\n\\n  function hasLegacyNode(address entity) public view returns (bool) {\\n    return entityActive[entity] \\u0026\\u0026 entityNodeCount[entity] == 0;\\n  }\\n\\n  function approveBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = true;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    activeEntities = activeEntities.add(1);\\n  }\\n\\n  function suspendBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = false;\\n    activeEntities = activeEntities.sub(1);\\n  }\\n\\n  function setNodeIsActive(address entity, uint128 nodeId, bool isActive) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (isActive \\u0026\\u0026 !entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.add(1);\\n      entityNodeClaimedOnBlock[id] = block.number;\\n    }\\n\\n    if (!isActive \\u0026\\u0026 entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.sub(1);\\n    }\\n\\n    entityNodeIsActive[id] = isActive;\\n  }\\n\\n  function setNodeIsNaaS(address entity, uint128 nodeId, bool isNaaS) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    entityNodeIsBYON[id] = !isNaaS;\\n  }\\n\\n  function migrateLegacyNode(address entity) private {\\n    bytes memory id = getNodeId(entity, 1);\\n    entityNodeClaimedOnBlock[id] = entityBlockLastClaimedOn[entity];\\n    entityNodePaidOnBlock[id] = paidOnBlock[entity];\\n    entityNodeIsBYON[id] = !entityIsNaaS[entity];\\n    if (entityNodeIsBYON[id]) {\\n      entityNodeIsActive[id] = true;\\n    }\\n    entityNodeCount[msg.sender] = 1;\\n  }\\n\\n  function migrateNode(uint128 nodeId, address to) public {\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    if (hasLegacyNode(to)) {\\n      migrateLegacyNode(to);\\n    }\\n\\n    require(doesNodeExist(msg.sender, nodeId), \\\"doesnt exist\\\");\\n\\n    uint128 toNodeId = entityNodeCount[to] + 1;\\n    bytes memory fromId = getNodeId(msg.sender, nodeId);\\n    bytes memory toId = getNodeId(to, toNodeId);\\n\\n    // move node to another address\\n    entityNodeIsActive[toId] = entityNodeIsActive[fromId];\\n    entityNodeIsBYON[toId] = entityNodeIsBYON[fromId];\\n    entityNodePaidOnBlock[toId] = entityNodePaidOnBlock[fromId];\\n    entityNodeClaimedOnBlock[toId] = entityNodeClaimedOnBlock[fromId];\\n    entityNodeCount[to] = entityNodeCount[to] + 1;\\n\\n    // deactivate node\\n    entityNodeIsActive[fromId] = false;\\n    entityNodePaidOnBlock[fromId] = 0;\\n    entityNodeClaimedOnBlock[fromId] = 0;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] - 1;\\n\\n    emit Migrated(msg.sender, to, nodeId, toNodeId, entityNodeIsBYON[fromId]);\\n  }\\n\\n  function claimAll(uint256 blockNumber, bool toStrongPool) public payable {\\n    for (uint16 i = 1; i \\u003c= entityNodeCount[msg.sender]; i++) {\\n      uint256 reward = getRewardByBlock(msg.sender, i, blockNumber);\\n      uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n      this.claim{value : fee}(i, blockNumber, toStrongPool);\\n    }\\n  }\\n\\n  function payAll(uint256 nodeCount) public payable {\\n    require(nodeCount \\u003e 0, \\\"invalid value\\\");\\n    require(msg.value == recurringNaaSFeeInWei.mul(nodeCount), \\\"invalid fee\\\");\\n\\n    for (uint16 nodeId = 1; nodeId \\u003c= entityNodeCount[msg.sender]; nodeId++) {\\n      if (!canBePaid(msg.sender, nodeId)) {\\n        continue;\\n      }\\n\\n      this.payFee{value : recurringNaaSFeeInWei}(nodeId);\\n      nodeCount = nodeCount.sub(1);\\n    }\\n\\n    require(nodeCount == 0, \\\"invalid count\\\");\\n  }\\n\\n  function addNFTBonusContract(address _contract) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    strongNFTBonus = StrongNFTBonusInterface(_contract);\\n  }\\n\\n  function payFeeAdmin(address entity, uint128[] memory nodes) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    for (uint256 i = 0; i \\u003c nodes.length; i++) {\\n      uint128 nodeId = nodes[i];\\n      bytes memory id = getNodeId(entity, nodeId);\\n      entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\\n\\n      emit Paid(entity, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\\n    }\\n  }\\n\\n  function updateLimits(uint128 _maxNodes, uint256 _maxPaymentPeriods) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n\\n    maxNodes = _maxNodes;\\n    maxPaymentPeriods = _maxPaymentPeriods;\\n  }\\n}\\n\"},\"ServiceV14.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StrongPoolInterface.sol\\\";\\nimport \\\"./IERC1155Preset.sol\\\";\\nimport \\\"./StrongNFTBonusInterface.sol\\\";\\nimport \\\"./rewards.sol\\\";\\n\\ncontract ServiceV14 {\\n  event Requested(address indexed miner);\\n  event Claimed(address indexed miner, uint256 reward);\\n\\n  using SafeMath for uint256;\\n  bool public initDone;\\n  address public admin;\\n  address public pendingAdmin;\\n  address public superAdmin;\\n  address public pendingSuperAdmin;\\n  address public serviceAdmin;\\n  address public parameterAdmin;\\n  address payable public feeCollector;\\n\\n  IERC20 public strongToken;\\n  StrongPoolInterface public strongPool;\\n\\n  uint256 public rewardPerBlockNumerator;\\n  uint256 public rewardPerBlockDenominator;\\n\\n  uint256 public naasRewardPerBlockNumerator;\\n  uint256 public naasRewardPerBlockDenominator;\\n\\n  uint256 public claimingFeeNumerator;\\n  uint256 public claimingFeeDenominator;\\n\\n  uint256 public requestingFeeInWei;\\n\\n  uint256 public strongFeeInWei;\\n\\n  uint256 public recurringFeeInWei;\\n  uint256 public recurringNaaSFeeInWei;\\n  uint256 public recurringPaymentCycleInBlocks;\\n\\n  uint256 public rewardBalance;\\n\\n  mapping(address =\\u003e uint256) public entityBlockLastClaimedOn;\\n\\n  address[] public entities;\\n  mapping(address =\\u003e uint256) public entityIndex;\\n  mapping(address =\\u003e bool) public entityActive;\\n  mapping(address =\\u003e bool) public requestPending;\\n  mapping(address =\\u003e bool) public entityIsNaaS;\\n  mapping(address =\\u003e uint256) public paidOnBlock;\\n  uint256 public activeEntities;\\n\\n  string public desciption;\\n\\n  uint256 public claimingFeeInWei;\\n\\n  uint256 public naasRequestingFeeInWei;\\n\\n  uint256 public naasStrongFeeInWei;\\n\\n  bool public removedTokens;\\n\\n  mapping(address =\\u003e uint256) public traunch;\\n\\n  uint256 public currentTraunch;\\n\\n  mapping(bytes =\\u003e bool) public entityNodeIsActive;\\n  mapping(bytes =\\u003e bool) public entityNodeIsBYON;\\n  mapping(bytes =\\u003e uint256) public entityNodeTraunch;\\n  mapping(bytes =\\u003e uint256) public entityNodePaidOnBlock;\\n  mapping(bytes =\\u003e uint256) public entityNodeClaimedOnBlock;\\n  mapping(address =\\u003e uint128) public entityNodeCount;\\n\\n  event Paid(address indexed entity, uint128 nodeId, bool isBYON, bool isRenewal, uint256 upToBlockNumber);\\n  event Migrated(address indexed from, address indexed to, uint128 fromNodeId, uint128 toNodeId, bool isBYON);\\n\\n  uint256 public rewardPerBlockNumeratorNew;\\n  uint256 public rewardPerBlockDenominatorNew;\\n  uint256 public naasRewardPerBlockNumeratorNew;\\n  uint256 public naasRewardPerBlockDenominatorNew;\\n  uint256 public rewardPerBlockNewEffectiveBlock;\\n\\n  StrongNFTBonusInterface public strongNFTBonus;\\n\\n  uint256 public gracePeriodInBlocks;\\n\\n  uint128 public maxNodes;\\n  uint256 public maxPaymentPeriods;\\n\\n  function init(\\n    address strongTokenAddress,\\n    address strongPoolAddress,\\n    address adminAddress,\\n    address superAdminAddress,\\n    uint256 rewardPerBlockNumeratorValue,\\n    uint256 rewardPerBlockDenominatorValue,\\n    uint256 naasRewardPerBlockNumeratorValue,\\n    uint256 naasRewardPerBlockDenominatorValue,\\n    uint256 requestingFeeInWeiValue,\\n    uint256 strongFeeInWeiValue,\\n    uint256 recurringFeeInWeiValue,\\n    uint256 recurringNaaSFeeInWeiValue,\\n    uint256 recurringPaymentCycleInBlocksValue,\\n    uint256 claimingFeeNumeratorValue,\\n    uint256 claimingFeeDenominatorValue,\\n    string memory desc\\n  ) public {\\n    require(!initDone, \\\"init done\\\");\\n    strongToken = IERC20(strongTokenAddress);\\n    strongPool = StrongPoolInterface(strongPoolAddress);\\n    admin = adminAddress;\\n    superAdmin = superAdminAddress;\\n    rewardPerBlockNumerator = rewardPerBlockNumeratorValue;\\n    rewardPerBlockDenominator = rewardPerBlockDenominatorValue;\\n    naasRewardPerBlockNumerator = naasRewardPerBlockNumeratorValue;\\n    naasRewardPerBlockDenominator = naasRewardPerBlockDenominatorValue;\\n    requestingFeeInWei = requestingFeeInWeiValue;\\n    strongFeeInWei = strongFeeInWeiValue;\\n    recurringFeeInWei = recurringFeeInWeiValue;\\n    recurringNaaSFeeInWei = recurringNaaSFeeInWeiValue;\\n    claimingFeeNumerator = claimingFeeNumeratorValue;\\n    claimingFeeDenominator = claimingFeeDenominatorValue;\\n    recurringPaymentCycleInBlocks = recurringPaymentCycleInBlocksValue;\\n    desciption = desc;\\n    initDone = true;\\n  }\\n\\n  function updateServiceAdmin(address newServiceAdmin) public {\\n    require(msg.sender == superAdmin);\\n    serviceAdmin = newServiceAdmin;\\n  }\\n\\n  function updateParameterAdmin(address newParameterAdmin) public {\\n    require(newParameterAdmin != address(0));\\n    require(msg.sender == superAdmin);\\n    parameterAdmin = newParameterAdmin;\\n  }\\n\\n  function updateFeeCollector(address payable newFeeCollector) public {\\n    require(newFeeCollector != address(0));\\n    require(msg.sender == superAdmin);\\n    feeCollector = newFeeCollector;\\n  }\\n\\n  function setPendingAdmin(address newPendingAdmin) public {\\n    require(msg.sender == admin);\\n    pendingAdmin = newPendingAdmin;\\n  }\\n\\n  function acceptAdmin() public {\\n    require(msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingAdmin\\\");\\n    admin = pendingAdmin;\\n    pendingAdmin = address(0);\\n  }\\n\\n  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\\n    require(msg.sender == superAdmin, \\\"not superAdmin\\\");\\n    pendingSuperAdmin = newPendingSuperAdmin;\\n  }\\n\\n  function acceptSuperAdmin() public {\\n    require(msg.sender == pendingSuperAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingSuperAdmin\\\");\\n    superAdmin = pendingSuperAdmin;\\n    pendingSuperAdmin = address(0);\\n  }\\n\\n  function isEntityActive(address entity) public view returns (bool) {\\n    return entityActive[entity] || (doesNodeExist(entity, 1) \\u0026\\u0026 !hasNodeExpired(entity, 1));\\n  }\\n\\n  function updateRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(denominator != 0);\\n    rewardPerBlockNumerator = numerator;\\n    rewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateNaaSRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(denominator != 0);\\n    naasRewardPerBlockNumerator = numerator;\\n    naasRewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateRewardPerBlockNew(\\n    uint256 numerator,\\n    uint256 denominator,\\n    uint256 numeratorNass,\\n    uint256 denominatorNass,\\n    uint256 effectiveBlock\\n  ) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n\\n    rewardPerBlockNumeratorNew = numerator;\\n    rewardPerBlockDenominatorNew = denominator;\\n    naasRewardPerBlockNumeratorNew = numeratorNass;\\n    naasRewardPerBlockDenominatorNew = denominatorNass;\\n    rewardPerBlockNewEffectiveBlock = effectiveBlock != 0 ? effectiveBlock : block.number;\\n  }\\n\\n  function deposit(uint256 amount) public {\\n    require(msg.sender == superAdmin);\\n    require(amount \\u003e 0);\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    rewardBalance = rewardBalance.add(amount);\\n  }\\n\\n  function withdraw(address destination, uint256 amount) public {\\n    require(msg.sender == superAdmin);\\n    require(amount \\u003e 0);\\n    require(rewardBalance \\u003e= amount, \\\"not enough\\\");\\n    strongToken.transfer(destination, amount);\\n    rewardBalance = rewardBalance.sub(amount);\\n  }\\n\\n  function updateRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    requestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    strongFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    naasRequestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    naasStrongFeeInWei = feeInWei;\\n  }\\n\\n  function updateClaimingFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(denominator != 0);\\n    claimingFeeNumerator = numerator;\\n    claimingFeeDenominator = denominator;\\n  }\\n\\n  function updateRecurringFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    recurringFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringNaaSFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    recurringNaaSFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringPaymentCycleInBlocks(uint256 blocks) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(blocks \\u003e 0);\\n    recurringPaymentCycleInBlocks = blocks;\\n  }\\n\\n  function updateGracePeriodInBlocks(uint256 blocks) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n    require(blocks \\u003e 0);\\n    gracePeriodInBlocks = blocks;\\n  }\\n\\n  function requestAccess(bool isNaaS) public payable {\\n    require(entityNodeCount[msg.sender] \\u003c maxNodes, \\\"limit reached\\\");\\n\\n    uint256 rFee;\\n    uint256 sFee;\\n\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    uint128 nodeId = entityNodeCount[msg.sender] + 1;\\n    bytes memory id = getNodeId(msg.sender, nodeId);\\n\\n    if (isNaaS) {\\n      rFee = naasRequestingFeeInWei;\\n      sFee = naasStrongFeeInWei;\\n      activeEntities = activeEntities.add(1);\\n    } else {\\n      rFee = requestingFeeInWei;\\n      sFee = strongFeeInWei;\\n      entityNodeIsBYON[id] = true;\\n    }\\n\\n    require(msg.value == rFee, \\\"invalid fee\\\");\\n\\n    entityNodePaidOnBlock[id] = block.number;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] + 1;\\n\\n    feeCollector.transfer(msg.value);\\n    strongToken.transferFrom(msg.sender, address(this), sFee);\\n    strongToken.transfer(feeCollector, sFee);\\n\\n    emit Paid(msg.sender, nodeId, entityNodeIsBYON[id], false, entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks));\\n  }\\n\\n  function setEntityActiveStatus(address entity, bool status) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n    uint256 index = entityIndex[entity];\\n    require(entities[index] == entity, \\\"invalid entity\\\");\\n    require(entityActive[entity] != status, \\\"already set\\\");\\n    entityActive[entity] = status;\\n    if (status) {\\n      activeEntities = activeEntities.add(1);\\n      entityBlockLastClaimedOn[entity] = block.number;\\n    } else {\\n      activeEntities = activeEntities.sub(1);\\n      entityBlockLastClaimedOn[entity] = 0;\\n    }\\n  }\\n\\n  function payFee(uint128 nodeId) public payable {\\n    address sender = msg.sender == address(this) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    require(doesNodeExist(sender, nodeId), \\\"doesnt exist\\\");\\n    require(hasNodeExpired(sender, nodeId) == false, \\\"too late\\\");\\n    require(hasMaxPayments(sender, nodeId) == false, \\\"too soon\\\");\\n\\n    if (entityNodeIsBYON[id]) {\\n      require(msg.value == recurringFeeInWei, \\\"invalid fee\\\");\\n    } else {\\n      require(msg.value == recurringNaaSFeeInWei, \\\"invalid fee\\\");\\n    }\\n\\n    feeCollector.transfer(msg.value);\\n    entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\\n\\n    emit Paid(sender, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\\n  }\\n\\n  function getReward(address entity, uint128 nodeId) public view returns (uint256) {\\n    return getRewardByBlock(entity, nodeId, block.number);\\n  }\\n\\n  function getRewardByBlock(address entity, uint128 nodeId, uint256 blockNumber) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (hasLegacyNode(entity)) {\\n      return getRewardByBlockLegacy(entity, blockNumber);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (blockLastClaimedOn == 0) return 0;\\n    if (blockNumber \\u003c blockLastClaimedOn) return 0;\\n    if (activeEntities == 0) return 0;\\n    if (entityNodeIsBYON[id] \\u0026\\u0026 !entityNodeIsActive[id]) return 0;\\n\\n    uint256 rewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumerator : naasRewardPerBlockNumerator;\\n    uint256 rewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominator : naasRewardPerBlockDenominator;\\n    uint256 newRewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumeratorNew : naasRewardPerBlockNumeratorNew;\\n    uint256 newRewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominatorNew : naasRewardPerBlockDenominatorNew;\\n\\n    uint256 bonus = address(strongNFTBonus) != address(0)\\n    ? strongNFTBonus.getBonus(entity, nodeId, blockLastClaimedOn, blockNumber)\\n    : 0;\\n\\n    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, blockNumber);\\n    uint256 rewardOld = rewardDenominator \\u003e 0 ? rewardBlocks[0].mul(rewardNumerator).div(rewardDenominator) : 0;\\n    uint256 rewardNew = newRewardDenominator \\u003e 0 ? rewardBlocks[1].mul(newRewardNumerator).div(newRewardDenominator) : 0;\\n\\n    return rewardOld.add(rewardNew).add(bonus);\\n  }\\n\\n  function getRewardByBlockLegacy(address entity, uint256 blockNumber) public view returns (uint256) {\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (entityBlockLastClaimedOn[entity] == 0) return 0;\\n    if (blockNumber \\u003c entityBlockLastClaimedOn[entity]) return 0;\\n    if (activeEntities == 0) return 0;\\n    uint256 blockResult = blockNumber.sub(entityBlockLastClaimedOn[entity]);\\n    uint256 rewardNumerator;\\n    uint256 rewardDenominator;\\n    if (entityIsNaaS[entity]) {\\n      rewardNumerator = naasRewardPerBlockNumerator;\\n      rewardDenominator = naasRewardPerBlockDenominator;\\n    } else {\\n      rewardNumerator = rewardPerBlockNumerator;\\n      rewardDenominator = rewardPerBlockDenominator;\\n    }\\n    uint256 rewardPerBlockResult = blockResult.mul(rewardNumerator).div(rewardDenominator);\\n\\n    return rewardPerBlockResult;\\n  }\\n\\n  function claim(uint128 nodeId, uint256 blockNumber, bool toStrongPool) public payable returns (bool) {\\n    address sender = msg.sender == address(this) || msg.sender == address(strongNFTBonus) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n\\n    require(blockLastClaimedOn != 0, \\\"never claimed\\\");\\n    require(blockNumber \\u003c= block.number, \\\"invalid block\\\");\\n    require(blockNumber \\u003e blockLastClaimedOn, \\\"too soon\\\");\\n    require(!entityNodeIsBYON[id] || entityNodeIsActive[id], \\\"not active\\\");\\n\\n    if (\\n      (!entityNodeIsBYON[id] \\u0026\\u0026 recurringNaaSFeeInWei != 0) || (entityNodeIsBYON[id] \\u0026\\u0026 recurringFeeInWei != 0)\\n    ) {\\n      require(blockNumber \\u003c blockLastPaidOn.add(recurringPaymentCycleInBlocks), \\\"pay fee\\\");\\n    }\\n\\n    uint256 reward = getRewardByBlock(sender, nodeId, blockNumber);\\n    require(reward \\u003e 0, \\\"no reward\\\");\\n\\n    uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n    require(msg.value \\u003e= fee, \\\"invalid fee\\\");\\n\\n    feeCollector.transfer(msg.value);\\n\\n    if (toStrongPool) {\\n      strongToken.approve(address(strongPool), reward);\\n      strongPool.mineFor(sender, reward);\\n    } else {\\n      strongToken.transfer(sender, reward);\\n    }\\n\\n    rewardBalance = rewardBalance.sub(reward);\\n    entityNodeClaimedOnBlock[id] = blockNumber;\\n    emit Claimed(sender, reward);\\n\\n    return true;\\n  }\\n\\n  function getRewardAll(address entity, uint256 blockNumber) public view returns (uint256) {\\n    uint256 rewardsAll = 0;\\n\\n    for (uint128 i = 1; i \\u003c= entityNodeCount[entity]; i++) {\\n      rewardsAll = rewardsAll.add(getRewardByBlock(entity, i, blockNumber \\u003e 0 ? blockNumber : block.number));\\n    }\\n\\n    return rewardsAll;\\n  }\\n\\n  function canBePaid(address entity, uint128 nodeId) public view returns (bool) {\\n    return !isNodeBYON(entity, nodeId) \\u0026\\u0026 !hasNodeExpired(entity, nodeId) \\u0026\\u0026 !hasMaxPayments(entity, nodeId);\\n  }\\n\\n  function doesNodeExist(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id] \\u003e 0;\\n  }\\n\\n  function hasNodeExpired(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n    return block.number \\u003e blockLastPaidOn.add(recurringPaymentCycleInBlocks).add(gracePeriodInBlocks);\\n  }\\n\\n  function hasMaxPayments(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n    uint256 limit = block.number.add(recurringPaymentCycleInBlocks.mul(maxPaymentPeriods));\\n\\n    return blockLastPaidOn.add(recurringPaymentCycleInBlocks) \\u003e= limit;\\n  }\\n\\n  function getNodeId(address entity, uint128 nodeId) public view returns (bytes memory) {\\n    uint128 id = nodeId != 0 ? nodeId : entityNodeCount[entity] + 1;\\n    return abi.encodePacked(entity, id);\\n  }\\n\\n  function getNodePaidOn(address entity, uint128 nodeId) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id];\\n  }\\n\\n  function isNodeActive(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsActive[id] || !entityNodeIsBYON[id];\\n  }\\n\\n  function isNodeBYON(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsBYON[id];\\n  }\\n\\n  function hasLegacyNode(address entity) public view returns (bool) {\\n    return entityActive[entity] \\u0026\\u0026 entityNodeCount[entity] == 0;\\n  }\\n\\n  function approveBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = true;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    activeEntities = activeEntities.add(1);\\n  }\\n\\n  function suspendBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = false;\\n    activeEntities = activeEntities.sub(1);\\n  }\\n\\n  function setNodeIsActive(address entity, uint128 nodeId, bool isActive) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (isActive \\u0026\\u0026 !entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.add(1);\\n      entityNodeClaimedOnBlock[id] = block.number;\\n    }\\n\\n    if (!isActive \\u0026\\u0026 entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.sub(1);\\n    }\\n\\n    entityNodeIsActive[id] = isActive;\\n  }\\n\\n  function setNodeIsNaaS(address entity, uint128 nodeId, bool isNaaS) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    entityNodeIsBYON[id] = !isNaaS;\\n  }\\n\\n  function migrateLegacyNode(address entity) private {\\n    bytes memory id = getNodeId(entity, 1);\\n    entityNodeClaimedOnBlock[id] = entityBlockLastClaimedOn[entity];\\n    entityNodePaidOnBlock[id] = paidOnBlock[entity];\\n    entityNodeIsBYON[id] = !entityIsNaaS[entity];\\n    if (entityNodeIsBYON[id]) {\\n      entityNodeIsActive[id] = true;\\n    }\\n    entityNodeCount[msg.sender] = 1;\\n  }\\n\\n  function migrateNode(uint128 nodeId, address to) public {\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    if (hasLegacyNode(to)) {\\n      migrateLegacyNode(to);\\n    }\\n\\n    require(doesNodeExist(msg.sender, nodeId), \\\"doesnt exist\\\");\\n\\n    uint128 toNodeId = entityNodeCount[to] + 1;\\n    bytes memory fromId = getNodeId(msg.sender, nodeId);\\n    bytes memory toId = getNodeId(to, toNodeId);\\n\\n    // move node to another address\\n    entityNodeIsActive[toId] = entityNodeIsActive[fromId];\\n    entityNodeIsBYON[toId] = entityNodeIsBYON[fromId];\\n    entityNodePaidOnBlock[toId] = entityNodePaidOnBlock[fromId];\\n    entityNodeClaimedOnBlock[toId] = entityNodeClaimedOnBlock[fromId];\\n    entityNodeCount[to] = entityNodeCount[to] + 1;\\n\\n    // deactivate node\\n    entityNodeIsActive[fromId] = false;\\n    entityNodePaidOnBlock[fromId] = 0;\\n    entityNodeClaimedOnBlock[fromId] = 0;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] - 1;\\n\\n    emit Migrated(msg.sender, to, nodeId, toNodeId, entityNodeIsBYON[fromId]);\\n  }\\n\\n  function claimAll(uint256 blockNumber, bool toStrongPool) public payable {\\n    uint256 value = msg.value;\\n    for (uint16 i = 1; i \\u003c= entityNodeCount[msg.sender]; i++) {\\n      uint256 reward = getRewardByBlock(msg.sender, i, blockNumber);\\n      uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n      require(value \\u003e= fee, \\\"invalid fee\\\");\\n      require(this.claim{value : fee}(i, blockNumber, toStrongPool), \\\"claim failed\\\");\\n      value = value.sub(fee);\\n    }\\n  }\\n\\n  function payAll(uint256 nodeCount) public payable {\\n    require(nodeCount \\u003e 0, \\\"invalid value\\\");\\n    require(msg.value == recurringNaaSFeeInWei.mul(nodeCount), \\\"invalid fee\\\");\\n\\n    for (uint16 nodeId = 1; nodeId \\u003c= entityNodeCount[msg.sender]; nodeId++) {\\n      if (!canBePaid(msg.sender, nodeId)) {\\n        continue;\\n      }\\n\\n      this.payFee{value : recurringNaaSFeeInWei}(nodeId);\\n      nodeCount = nodeCount.sub(1);\\n    }\\n\\n    require(nodeCount == 0, \\\"invalid count\\\");\\n  }\\n\\n  function addNFTBonusContract(address _contract) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    strongNFTBonus = StrongNFTBonusInterface(_contract);\\n  }\\n\\n  function payFeeAdmin(address entity, uint128[] memory nodes) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\\n\\n    for (uint256 i = 0; i \\u003c nodes.length; i++) {\\n      uint128 nodeId = nodes[i];\\n      bytes memory id = getNodeId(entity, nodeId);\\n      entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\\n\\n      emit Paid(entity, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\\n    }\\n  }\\n\\n  function updateLimits(uint128 _maxNodes, uint256 _maxPaymentPeriods) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\\n\\n    maxNodes = _maxNodes;\\n    maxPaymentPeriods = _maxPaymentPeriods;\\n  }\\n}\\n\"},\"ServiceV9.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StrongPoolInterface.sol\\\";\\n\\ncontract ServiceV9 {\\n  event Requested(address indexed miner);\\n  event Claimed(address indexed miner, uint256 reward);\\n\\n  using SafeMath for uint256;\\n  bool public initDone;\\n  address public admin;\\n  address public pendingAdmin;\\n  address public superAdmin;\\n  address public pendingSuperAdmin;\\n  address public serviceAdmin;\\n  address public parameterAdmin;\\n  address payable public feeCollector;\\n\\n  IERC20 public strongToken;\\n  StrongPoolInterface public strongPool;\\n\\n  uint256 public rewardPerBlockNumerator;\\n  uint256 public rewardPerBlockDenominator;\\n\\n  uint256 public naasRewardPerBlockNumerator;\\n  uint256 public naasRewardPerBlockDenominator;\\n\\n  uint256 public claimingFeeNumerator;\\n  uint256 public claimingFeeDenominator;\\n\\n  uint256 public requestingFeeInWei;\\n\\n  uint256 public strongFeeInWei;\\n\\n  uint256 public recurringFeeInWei;\\n  uint256 public recurringNaaSFeeInWei;\\n  uint256 public recurringPaymentCycleInBlocks;\\n\\n  uint256 public rewardBalance;\\n\\n  mapping(address =\\u003e uint256) public entityBlockLastClaimedOn;\\n\\n  address[] public entities;\\n  mapping(address =\\u003e uint256) public entityIndex;\\n  mapping(address =\\u003e bool) public entityActive;\\n  mapping(address =\\u003e bool) public requestPending;\\n  mapping(address =\\u003e bool) public entityIsNaaS;\\n  mapping(address =\\u003e uint256) public paidOnBlock;\\n  uint256 public activeEntities;\\n\\n  string public desciption;\\n\\n  uint256 public claimingFeeInWei;\\n\\n  uint256 public naasRequestingFeeInWei;\\n\\n  uint256 public naasStrongFeeInWei;\\n\\n  bool public removedTokens;\\n\\n  mapping(address =\\u003e uint256) public traunch;\\n\\n  uint256 public currentTraunch;\\n\\n  mapping(bytes =\\u003e bool) public entityNodeIsActive;\\n  mapping(bytes =\\u003e bool) public entityNodeIsBYON;\\n  mapping(bytes =\\u003e uint256) public entityNodeTraunch;\\n  mapping(bytes =\\u003e uint256) public entityNodePaidOnBlock;\\n  mapping(bytes =\\u003e uint256) public entityNodeClaimedOnBlock;\\n  mapping(address =\\u003e uint128) public entityNodeCount;\\n\\n  event Paid(address indexed entity, uint128 nodeId, bool isBYON, bool isRenewal, uint256 upToBlockNumber);\\n  event Migrated(address indexed from, address indexed to, uint128 fromNodeId, uint128 toNodeId, bool isBYON);\\n\\n  function init(\\n    address strongTokenAddress,\\n    address strongPoolAddress,\\n    address adminAddress,\\n    address superAdminAddress,\\n    uint256 rewardPerBlockNumeratorValue,\\n    uint256 rewardPerBlockDenominatorValue,\\n    uint256 naasRewardPerBlockNumeratorValue,\\n    uint256 naasRewardPerBlockDenominatorValue,\\n    uint256 requestingFeeInWeiValue,\\n    uint256 strongFeeInWeiValue,\\n    uint256 recurringFeeInWeiValue,\\n    uint256 recurringNaaSFeeInWeiValue,\\n    uint256 recurringPaymentCycleInBlocksValue,\\n    uint256 claimingFeeNumeratorValue,\\n    uint256 claimingFeeDenominatorValue,\\n    string memory desc\\n  ) public {\\n    require(!initDone, \\u0027init done\\u0027);\\n    strongToken = IERC20(strongTokenAddress);\\n    strongPool = StrongPoolInterface(strongPoolAddress);\\n    admin = adminAddress;\\n    superAdmin = superAdminAddress;\\n    rewardPerBlockNumerator = rewardPerBlockNumeratorValue;\\n    rewardPerBlockDenominator = rewardPerBlockDenominatorValue;\\n    naasRewardPerBlockNumerator = naasRewardPerBlockNumeratorValue;\\n    naasRewardPerBlockDenominator = naasRewardPerBlockDenominatorValue;\\n    requestingFeeInWei = requestingFeeInWeiValue;\\n    strongFeeInWei = strongFeeInWeiValue;\\n    recurringFeeInWei = recurringFeeInWeiValue;\\n    recurringNaaSFeeInWei = recurringNaaSFeeInWeiValue;\\n    claimingFeeNumerator = claimingFeeNumeratorValue;\\n    claimingFeeDenominator = claimingFeeDenominatorValue;\\n    recurringPaymentCycleInBlocks = recurringPaymentCycleInBlocksValue;\\n    desciption = desc;\\n    initDone = true;\\n  }\\n\\n  // ADMIN\\n  // *************************************************************************************\\n\\n  function updateServiceAdmin(address newServiceAdmin) public {\\n    require(msg.sender == superAdmin);\\n    serviceAdmin = newServiceAdmin;\\n  }\\n\\n  function updateParameterAdmin(address newParameterAdmin) public {\\n    require(newParameterAdmin != address(0), \\u0027zero\\u0027);\\n    require(msg.sender == superAdmin);\\n    parameterAdmin = newParameterAdmin;\\n  }\\n\\n  function updateFeeCollector(address payable newFeeCollector) public {\\n    require(newFeeCollector != address(0), \\u0027zero\\u0027);\\n    require(msg.sender == superAdmin);\\n    feeCollector = newFeeCollector;\\n  }\\n\\n  function setPendingAdmin(address newPendingAdmin) public {\\n    require(msg.sender == admin, \\u0027not admin\\u0027);\\n    pendingAdmin = newPendingAdmin;\\n  }\\n\\n  function acceptAdmin() public {\\n    require(msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0), \\u0027not pendingAdmin\\u0027);\\n    admin = pendingAdmin;\\n    pendingAdmin = address(0);\\n  }\\n\\n  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\\n    require(msg.sender == superAdmin, \\u0027not superAdmin\\u0027);\\n    pendingSuperAdmin = newPendingSuperAdmin;\\n  }\\n\\n  function acceptSuperAdmin() public {\\n    require(msg.sender == pendingSuperAdmin \\u0026\\u0026 msg.sender != address(0), \\u0027not pendingSuperAdmin\\u0027);\\n    superAdmin = pendingSuperAdmin;\\n    pendingSuperAdmin = address(0);\\n  }\\n\\n  // ENTITIES\\n  // *************************************************************************************\\n\\n  function getEntities() public view returns (address[] memory) {\\n    return entities;\\n  }\\n\\n  function isEntityActive(address entity) public view returns (bool) {\\n    return entityActive[entity];\\n  }\\n\\n  // TRAUNCH\\n  // *************************************************************************************\\n\\n  function updateCurrentTraunch(uint256 value) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    currentTraunch = value;\\n  }\\n\\n  function getTraunch(address entity) public view returns (uint256) {\\n    return traunch[entity];\\n  }\\n\\n  // REWARD\\n  // *************************************************************************************\\n\\n  function updateRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    require(denominator != 0, \\u0027invalid value\\u0027);\\n    rewardPerBlockNumerator = numerator;\\n    rewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateNaaSRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    require(denominator != 0, \\u0027invalid value\\u0027);\\n    naasRewardPerBlockNumerator = numerator;\\n    naasRewardPerBlockDenominator = denominator;\\n  }\\n\\n  function deposit(uint256 amount) public {\\n    require(msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    require(amount \\u003e 0, \\u0027zero\\u0027);\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    rewardBalance = rewardBalance.add(amount);\\n  }\\n\\n  function withdraw(address destination, uint256 amount) public {\\n    require(msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    require(amount \\u003e 0, \\u0027zero\\u0027);\\n    require(rewardBalance \\u003e= amount, \\u0027not enough\\u0027);\\n    strongToken.transfer(destination, amount);\\n    rewardBalance = rewardBalance.sub(amount);\\n  }\\n\\n  function removeTokens() public {\\n    require(!removedTokens, \\u0027already removed\\u0027);\\n    require(msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    // removing 2500 STRONG tokens sent in this tx: 0xe27640beda32a5e49aad3b6692790b9d380ed25da0cf8dca7fd5f3258efa600a\\n    strongToken.transfer(superAdmin, 2500000000000000000000);\\n    removedTokens = true;\\n  }\\n\\n  // FEES\\n  // *************************************************************************************\\n\\n  function updateRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    requestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    strongFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasRequestingFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    naasRequestingFeeInWei = feeInWei;\\n  }\\n\\n  function updateNaasStrongFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    naasStrongFeeInWei = feeInWei;\\n  }\\n\\n  function updateClaimingFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    require(denominator != 0, \\u0027invalid value\\u0027);\\n    claimingFeeNumerator = numerator;\\n    claimingFeeDenominator = denominator;\\n  }\\n\\n  function updateRecurringFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    recurringFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringNaaSFee(uint256 feeInWei) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    recurringNaaSFeeInWei = feeInWei;\\n  }\\n\\n  function updateRecurringPaymentCycleInBlocks(uint256 blocks) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\u0027not an admin\\u0027);\\n    require(blocks \\u003e 0, \\u0027zero\\u0027);\\n    recurringPaymentCycleInBlocks = blocks;\\n  }\\n\\n  // CORE\\n  // *************************************************************************************\\n\\n  function requestAccess(bool isNaaS) public payable {\\n    uint256 rFee;\\n    uint256 sFee;\\n\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    uint128 nodeId = entityNodeCount[msg.sender] + 1;\\n    bytes memory id = getNodeId(msg.sender, nodeId);\\n\\n    if (isNaaS) {\\n      rFee = naasRequestingFeeInWei;\\n      sFee = naasStrongFeeInWei;\\n      activeEntities = activeEntities.add(1);\\n    } else {\\n      rFee = requestingFeeInWei;\\n      sFee = strongFeeInWei;\\n      entityNodeIsBYON[id] = true;\\n    }\\n\\n    require(msg.value == rFee, \\u0027invalid fee\\u0027);\\n\\n    entityNodePaidOnBlock[id] = block.number;\\n    entityNodeTraunch[id] = currentTraunch;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] + 1;\\n\\n    feeCollector.transfer(msg.value);\\n    strongToken.transferFrom(msg.sender, address(this), sFee);\\n    strongToken.transfer(feeCollector, sFee);\\n\\n    emit Paid(msg.sender, nodeId, entityNodeIsBYON[id], false, entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks));\\n  }\\n\\n  function setEntityActiveStatus(address entity, bool status) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\u0027not admin\\u0027);\\n    uint256 index = entityIndex[entity];\\n    require(entities[index] == entity, \\u0027invalid entity\\u0027);\\n    require(entityActive[entity] != status, \\u0027already set\\u0027);\\n    entityActive[entity] = status;\\n    if (status) {\\n      activeEntities = activeEntities.add(1);\\n      entityBlockLastClaimedOn[entity] = block.number;\\n    } else {\\n      activeEntities = activeEntities.sub(1);\\n      entityBlockLastClaimedOn[entity] = 0;\\n    }\\n  }\\n\\n  function setTraunch(address entity, uint256 value) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\u0027not admin\\u0027);\\n\\n    traunch[entity] = value;\\n  }\\n\\n  function payFee(uint128 nodeId) public payable {\\n    address sender = msg.sender == address(this) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    require(doesNodeExist(sender, nodeId), \\u0027doesnt exist\\u0027);\\n\\n    if (entityNodeIsBYON[id]) {\\n      require(msg.value == recurringFeeInWei, \\u0027invalid fee\\u0027);\\n    } else {\\n      require(msg.value == recurringNaaSFeeInWei, \\u0027invalid fee\\u0027);\\n    }\\n\\n    feeCollector.transfer(msg.value);\\n    entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\\n\\n    emit Paid(sender, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\\n  }\\n\\n  function getReward(address entity, uint128 nodeId) public view returns (uint256) {\\n    return getRewardByBlock(entity, nodeId, block.number);\\n  }\\n\\n  function getRewardByBlock(address entity, uint128 nodeId, uint256 blockNumber) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (hasLegacyNode(entity)) {\\n      return getRewardByBlockLegacy(entity, blockNumber);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (blockLastClaimedOn == 0) return 0;\\n    if (blockNumber \\u003c blockLastClaimedOn) return 0;\\n    if (activeEntities == 0) return 0;\\n    if (entityNodeIsBYON[id] \\u0026\\u0026 !entityNodeIsActive[id]) return 0;\\n\\n    uint256 blockResult = blockNumber.sub(blockLastClaimedOn);\\n    uint256 rewardNumerator;\\n    uint256 rewardDenominator;\\n\\n    if (entityNodeIsBYON[id]) {\\n      rewardNumerator = rewardPerBlockNumerator;\\n      rewardDenominator = rewardPerBlockDenominator;\\n    } else {\\n      rewardNumerator = naasRewardPerBlockNumerator;\\n      rewardDenominator = naasRewardPerBlockDenominator;\\n    }\\n\\n    uint256 rewardPerBlockResult = blockResult.mul(rewardNumerator).div(rewardDenominator);\\n\\n    return rewardPerBlockResult;\\n  }\\n\\n  function getRewardByBlockLegacy(address entity, uint256 blockNumber) public view returns (uint256) {\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (entityBlockLastClaimedOn[entity] == 0) return 0;\\n    if (blockNumber \\u003c entityBlockLastClaimedOn[entity]) return 0;\\n    if (activeEntities == 0) return 0;\\n    uint256 blockResult = blockNumber.sub(entityBlockLastClaimedOn[entity]);\\n    uint256 rewardNumerator;\\n    uint256 rewardDenominator;\\n    if (entityIsNaaS[entity]) {\\n      rewardNumerator = naasRewardPerBlockNumerator;\\n      rewardDenominator = naasRewardPerBlockDenominator;\\n    } else {\\n      rewardNumerator = rewardPerBlockNumerator;\\n      rewardDenominator = rewardPerBlockDenominator;\\n    }\\n    uint256 rewardPerBlockResult = blockResult.mul(rewardNumerator).div(rewardDenominator);\\n\\n    return rewardPerBlockResult;\\n  }\\n\\n  function claim(uint128 nodeId, uint256 blockNumber, bool toStrongPool) public payable {\\n    address sender = msg.sender == address(this) ? tx.origin : msg.sender;\\n    bytes memory id = getNodeId(sender, nodeId);\\n\\n    if (hasLegacyNode(sender)) {\\n      migrateLegacyNode(sender);\\n    }\\n\\n    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\\n    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\\n\\n    require(blockLastClaimedOn != 0, \\u0027never claimed\\u0027);\\n    require(blockNumber \\u003c= block.number, \\u0027invalid block\\u0027);\\n    require(blockNumber \\u003e blockLastClaimedOn, \\u0027too soon\\u0027);\\n    require(!entityNodeIsBYON[id] || entityNodeIsActive[id], \\u0027not active\\u0027);\\n\\n    if (\\n      (!entityNodeIsBYON[id] \\u0026\\u0026 recurringNaaSFeeInWei != 0) || (entityNodeIsBYON[id] \\u0026\\u0026 recurringFeeInWei != 0)\\n    ) {\\n      require(blockNumber \\u003c blockLastPaidOn.add(recurringPaymentCycleInBlocks), \\u0027pay fee\\u0027);\\n    }\\n\\n    uint256 reward = getRewardByBlock(sender, nodeId, blockNumber);\\n    require(reward \\u003e 0, \\u0027no reward\\u0027);\\n\\n    uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n    require(msg.value \\u003e= fee, \\u0027invalid fee\\u0027);\\n\\n    feeCollector.transfer(msg.value);\\n\\n    if (toStrongPool) {\\n      strongToken.approve(address(strongPool), reward);\\n      strongPool.mineFor(sender, reward);\\n    } else {\\n      strongToken.transfer(sender, reward);\\n    }\\n\\n    rewardBalance = rewardBalance.sub(reward);\\n    entityNodeClaimedOnBlock[id] = blockNumber;\\n    emit Claimed(sender, reward);\\n  }\\n\\n  function getRewardAll(address entity, uint256 blockNumber) public view returns (uint256) {\\n    uint256 rewardsAll = 0;\\n\\n    for (uint128 i = 1; i \\u003c= entityNodeCount[entity]; i++) {\\n      rewardsAll = rewardsAll.add(getRewardByBlock(entity, i, blockNumber \\u003e 0 ? blockNumber : block.number));\\n    }\\n\\n    return rewardsAll;\\n  }\\n\\n  function doesNodeExist(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id] \\u003e 0;\\n  }\\n\\n  function getNodeId(address entity, uint128 nodeId) public view returns (bytes memory) {\\n    uint128 id = nodeId != 0 ? nodeId : entityNodeCount[entity] + 1;\\n    return abi.encodePacked(entity, id);\\n  }\\n\\n  function getNodePaidOn(address entity, uint128 nodeId) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodePaidOnBlock[id];\\n  }\\n\\n  function getNodeFee(address entity, uint128 nodeId) public view returns (uint256) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\\n  }\\n\\n  function isNodeActive(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsActive[id] || !entityNodeIsBYON[id];\\n  }\\n\\n  function isNodeBYON(address entity, uint128 nodeId) public view returns (bool) {\\n    bytes memory id = getNodeId(entity, nodeId);\\n    return entityNodeIsBYON[id];\\n  }\\n\\n  function hasLegacyNode(address entity) public view returns (bool) {\\n    return entityActive[entity] \\u0026\\u0026 entityNodeCount[entity] == 0;\\n  }\\n\\n  function approveBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\u0027not admin\\u0027);\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = true;\\n    entityNodeClaimedOnBlock[id] = block.number;\\n    activeEntities = activeEntities.add(1);\\n  }\\n\\n  function suspendBYONNode(address entity, uint128 nodeId) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\u0027not admin\\u0027);\\n\\n    bytes memory id = getNodeId(entity, nodeId);\\n    entityNodeIsActive[id] = false;\\n    activeEntities = activeEntities.sub(1);\\n  }\\n\\n  function setNodeIsActive(address entity, uint128 nodeId, bool isActive) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\u0027not admin\\u0027);\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    if (isActive \\u0026\\u0026 !entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.add(1);\\n      entityNodeClaimedOnBlock[id] = block.number;\\n    }\\n\\n    if (!isActive \\u0026\\u0026 entityNodeIsActive[id]) {\\n      activeEntities = activeEntities.sub(1);\\n    }\\n\\n    entityNodeIsActive[id] = isActive;\\n  }\\n\\n  function setNodeIsNaaS(address entity, uint128 nodeId, bool isNaaS) public {\\n    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, \\u0027not admin\\u0027);\\n    bytes memory id = getNodeId(entity, nodeId);\\n\\n    entityNodeIsBYON[id] = !isNaaS;\\n  }\\n\\n  function migrateLegacyNode(address entity) private {\\n    bytes memory id = getNodeId(entity, 1);\\n    entityNodeClaimedOnBlock[id] = entityBlockLastClaimedOn[entity];\\n    entityNodePaidOnBlock[id] = paidOnBlock[entity];\\n    entityNodeTraunch[id] = traunch[entity];\\n    entityNodeIsBYON[id] = !entityIsNaaS[entity];\\n    if (entityNodeIsBYON[id]) {\\n      entityNodeIsActive[id] = true;\\n    }\\n    entityNodeCount[msg.sender] = 1;\\n  }\\n\\n  function migrateNode(uint128 nodeId, address to) public {\\n    if (hasLegacyNode(msg.sender)) {\\n      migrateLegacyNode(msg.sender);\\n    }\\n\\n    if (hasLegacyNode(to)) {\\n      migrateLegacyNode(to);\\n    }\\n\\n    require(doesNodeExist(msg.sender, nodeId), \\u0027doesnt exist\\u0027);\\n\\n    uint128 toNodeId = entityNodeCount[to] + 1;\\n    bytes memory fromId = getNodeId(msg.sender, nodeId);\\n    bytes memory toId = getNodeId(to, toNodeId);\\n\\n    // move node to another address\\n    entityNodeIsActive[toId] = entityNodeIsActive[fromId];\\n    entityNodeIsBYON[toId] = entityNodeIsBYON[fromId];\\n    entityNodePaidOnBlock[toId] = entityNodePaidOnBlock[fromId];\\n    entityNodeClaimedOnBlock[toId] = entityNodeClaimedOnBlock[fromId];\\n    entityNodeTraunch[toId] = entityNodeTraunch[fromId];\\n    entityNodeCount[to] = entityNodeCount[to] + 1;\\n\\n    // deactivate node\\n    entityNodeIsActive[fromId] = false;\\n    entityNodePaidOnBlock[fromId] = 0;\\n    entityNodeClaimedOnBlock[fromId] = 0;\\n    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] - 1;\\n\\n    emit Migrated(msg.sender, to, nodeId, toNodeId, entityNodeIsBYON[fromId]);\\n  }\\n\\n  function claimAll(uint256 blockNumber, bool toStrongPool) public payable {\\n    for (uint16 i = 1; i \\u003c= entityNodeCount[msg.sender]; i++) {\\n      uint256 reward = getRewardByBlock(msg.sender, i, blockNumber);\\n      uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n      this.claim{ value: fee }(i, blockNumber, toStrongPool);\\n    }\\n  }\\n\\n  function payAll() public payable {\\n    for (uint16 i = 1; i \\u003c= entityNodeCount[msg.sender]; i++) {\\n      bytes memory id = getNodeId(msg.sender, i);\\n      uint256 fee = entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\\n      this.payFee{ value: fee }(i);\\n    }\\n  }\\n}\\n\"},\"StrongNFTBonus.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.6.8;\\n\\nimport \\\"./ServiceInterface.sol\\\";\\nimport \\\"./IERC1155Preset.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Context.sol\\\";\\n\\ncontract StrongNFTBonus is Context {\\n\\n  using SafeMath for uint256;\\n\\n  event Staked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\\n  event Unstaked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\\n\\n  ServiceInterface public service;\\n  IERC1155Preset public nft;\\n\\n  bool public initDone;\\n\\n  address public serviceAdmin;\\n  address public superAdmin;\\n\\n  string[] public nftBonusNames;\\n  mapping(string =\\u003e uint256) public nftBonusLowerBound;\\n  mapping(string =\\u003e uint256) public nftBonusUpperBound;\\n  mapping(string =\\u003e uint256) public nftBonusValue;\\n\\n  mapping(uint256 =\\u003e uint256) public nftIdStakedForNodeId;\\n  mapping(address =\\u003e mapping(uint128 =\\u003e uint256)) public entityNodeStakedNftId;\\n  mapping(address =\\u003e mapping(uint128 =\\u003e uint256)) public entityNodeStakedNftBlock;\\n\\n  function init(address serviceContract, address nftContract, address serviceAdminAddress, address superAdminAddress) public {\\n    require(initDone == false, \\\"init done\\\");\\n\\n    serviceAdmin = serviceAdminAddress;\\n    superAdmin = superAdminAddress;\\n    service = ServiceInterface(serviceContract);\\n    nft = IERC1155Preset(nftContract);\\n    initDone = true;\\n  }\\n\\n  function isNftStaked(uint256 _tokenId) public view returns (bool) {\\n    return nftIdStakedForNodeId[_tokenId] != 0;\\n  }\\n\\n  function getNftStakedForNodeId(uint256 _tokenId) public view returns (uint256) {\\n    return nftIdStakedForNodeId[_tokenId];\\n  }\\n\\n  function getStakedNftId(address _entity, uint128 _nodeId) public view returns (uint256) {\\n    return entityNodeStakedNftId[_entity][_nodeId];\\n  }\\n\\n  function getStakedNftBlock(address _entity, uint128 _nodeId) public view returns (uint256) {\\n    return entityNodeStakedNftBlock[_entity][_nodeId];\\n  }\\n\\n  function getBonus(address _entity, uint128 _nodeId, uint256 _fromBlock, uint256 _toBlock) public view returns (uint256) {\\n    uint256 nftId = entityNodeStakedNftId[_entity][_nodeId];\\n\\n    if (nftId == 0) return 0;\\n    if (nftId \\u003c nftBonusLowerBound[\\\"BRONZE\\\"]) return 0;\\n    if (nftId \\u003e nftBonusUpperBound[\\\"BRONZE\\\"]) return 0;\\n    if (nft.balanceOf(_entity, nftId) == 0) return 0;\\n    if (_fromBlock \\u003e= _toBlock) return 0;\\n\\n    uint256 stakedAtBlock = entityNodeStakedNftBlock[_entity][_nodeId];\\n\\n    if (stakedAtBlock == 0) return 0;\\n\\n    uint256 startFromBlock = stakedAtBlock \\u003e _fromBlock ? stakedAtBlock : _fromBlock;\\n\\n    if (startFromBlock \\u003e= _toBlock) return 0;\\n\\n    return _toBlock.sub(startFromBlock).mul(nftBonusValue[\\\"BRONZE\\\"]);\\n  }\\n\\n  function stakeNFT(uint256 _tokenId, uint128 _nodeId) public payable {\\n    require(nft.balanceOf(_msgSender(), _tokenId) != 0, \\\"not enough\\\");\\n    require(_tokenId \\u003e= nftBonusLowerBound[\\\"BRONZE\\\"] \\u0026\\u0026 _tokenId \\u003c= nftBonusUpperBound[\\\"BRONZE\\\"], \\\"not eligible\\\");\\n    require(nftIdStakedForNodeId[_tokenId] == 0, \\\"already staked\\\");\\n    require(service.doesNodeExist(_msgSender(), _nodeId), \\\"node doesnt exist\\\");\\n\\n    nftIdStakedForNodeId[_tokenId] = _nodeId;\\n    entityNodeStakedNftId[_msgSender()][_nodeId] = _tokenId;\\n    entityNodeStakedNftBlock[_msgSender()][_nodeId] = block.number;\\n\\n    emit Staked(msg.sender, _tokenId, _nodeId, block.number);\\n  }\\n\\n  function unStakeNFT(uint256 _tokenId, uint128 _nodeId, uint256 _blockNumber) public payable {\\n    require(nft.balanceOf(_msgSender(), _tokenId) != 0, \\\"not enough\\\");\\n    require(nftIdStakedForNodeId[_tokenId] == _nodeId, \\\"not this node\\\");\\n\\n    service.claim{value : msg.value}(_nodeId, _blockNumber, false);\\n\\n    nftIdStakedForNodeId[_tokenId] = 0;\\n    entityNodeStakedNftId[_msgSender()][_nodeId] = 0;\\n    entityNodeStakedNftBlock[_msgSender()][_nodeId] = 0;\\n\\n    emit Unstaked(msg.sender, _tokenId, _nodeId, _blockNumber);\\n  }\\n\\n  function updateBonus(string memory _name, uint256 _lowerBound, uint256 _upperBound, uint256 _value) public {\\n    require(msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    bool alreadyExit = false;\\n    for (uint i = 0; i \\u003c nftBonusNames.length; i++) {\\n      if (keccak256(abi.encode(nftBonusNames[i])) == keccak256(abi.encode(_name))) {\\n        alreadyExit = true;\\n      }\\n    }\\n\\n    if (!alreadyExit) {\\n      nftBonusNames.push(_name);\\n    }\\n\\n    nftBonusLowerBound[_name] = _lowerBound;\\n    nftBonusUpperBound[_name] = _upperBound;\\n    nftBonusValue[_name] = _value;\\n  }\\n\\n  function updateContracts(address serviceContract, address nftContract) public {\\n    require(msg.sender == superAdmin, \\\"not admin\\\");\\n    service = ServiceInterface(serviceContract);\\n    nft = IERC1155Preset(nftContract);\\n  }\\n\\n  function updateServiceAdmin(address newServiceAdmin) public {\\n    require(msg.sender == superAdmin, \\\"not admin\\\");\\n    serviceAdmin = newServiceAdmin;\\n  }\\n}\\n\"},\"StrongNFTBonusDeprecated.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.6.8;\\n\\nimport \\\"./ServiceInterface.sol\\\";\\nimport \\\"./IERC1155Preset.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Context.sol\\\";\\n\\ncontract StrongNFTBonusDeprecated is Context {\\n\\n  using SafeMath for uint256;\\n\\n  event Staked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\\n  event Unstaked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\\n\\n  ServiceInterface public service;\\n  IERC1155Preset public nft;\\n\\n  bool public initDone;\\n\\n  address public serviceAdmin;\\n  address public superAdmin;\\n\\n  string[] public nftBonusNames;\\n  mapping(string =\\u003e uint256) public nftBonusLowerBound;\\n  mapping(string =\\u003e uint256) public nftBonusUpperBound;\\n  mapping(string =\\u003e uint256) public nftBonusValue;\\n\\n  mapping(uint256 =\\u003e uint256) public nftIdStakedForNodeId;\\n  mapping(address =\\u003e mapping(uint128 =\\u003e uint256)) public entityNodeStakedNftId;\\n  mapping(address =\\u003e mapping(uint128 =\\u003e uint256)) public entityNodeStakedNftBlock;\\n\\n  bool public disabled;\\n\\n  function init(address serviceContract, address nftContract, address serviceAdminAddress, address superAdminAddress) public {\\n    require(initDone == false, \\\"init done\\\");\\n\\n    serviceAdmin = serviceAdminAddress;\\n    superAdmin = superAdminAddress;\\n    service = ServiceInterface(serviceContract);\\n    nft = IERC1155Preset(nftContract);\\n    initDone = true;\\n  }\\n\\n  function isNftStaked(uint256 _tokenId) public view returns (bool) {\\n    return nftIdStakedForNodeId[_tokenId] != 0;\\n  }\\n\\n  function getNftStakedForNodeId(uint256 _tokenId) public view returns (uint256) {\\n    return nftIdStakedForNodeId[_tokenId];\\n  }\\n\\n  function getStakedNftId(address _entity, uint128 _nodeId) public view returns (uint256) {\\n    return entityNodeStakedNftId[_entity][_nodeId];\\n  }\\n\\n  function getStakedNftBlock(address _entity, uint128 _nodeId) public view returns (uint256) {\\n    return entityNodeStakedNftBlock[_entity][_nodeId];\\n  }\\n\\n  function getBonus(address _entity, uint128 _nodeId, uint256 _fromBlock, uint256 _toBlock) public view returns (uint256) {\\n    uint256 nftId = entityNodeStakedNftId[_entity][_nodeId];\\n\\n    if (nftId == 0) return 0;\\n    if (nftIdStakedForNodeId[nftId] == 0) return 0;\\n    if (nftId \\u003c nftBonusLowerBound[\\\"BRONZE\\\"]) return 0;\\n    if (nftId \\u003e nftBonusUpperBound[\\\"BRONZE\\\"]) return 0;\\n    if (nft.balanceOf(_entity, nftId) == 0) return 0;\\n    if (_fromBlock \\u003e= _toBlock) return 0;\\n\\n    uint256 stakedAtBlock = entityNodeStakedNftBlock[_entity][_nodeId];\\n\\n    if (stakedAtBlock == 0) return 0;\\n\\n    uint256 startFromBlock = stakedAtBlock \\u003e _fromBlock ? stakedAtBlock : _fromBlock;\\n\\n    if (startFromBlock \\u003e= _toBlock) return 0;\\n\\n    return _toBlock.sub(startFromBlock).mul(nftBonusValue[\\\"BRONZE\\\"]);\\n  }\\n\\n  function stakeNFT(uint256 _tokenId, uint128 _nodeId) public payable {\\n    require(disabled == false, \\\"disabled\\\");\\n    require(nft.balanceOf(_msgSender(), _tokenId) != 0, \\\"not enough\\\");\\n    require(_tokenId \\u003e= nftBonusLowerBound[\\\"BRONZE\\\"] \\u0026\\u0026 _tokenId \\u003c= nftBonusUpperBound[\\\"BRONZE\\\"], \\\"not eligible\\\");\\n    require(nftIdStakedForNodeId[_tokenId] == 0, \\\"already staked\\\");\\n    require(service.doesNodeExist(_msgSender(), _nodeId), \\\"node doesnt exist\\\");\\n\\n    nftIdStakedForNodeId[_tokenId] = _nodeId;\\n    entityNodeStakedNftId[_msgSender()][_nodeId] = _tokenId;\\n    entityNodeStakedNftBlock[_msgSender()][_nodeId] = block.number;\\n\\n    emit Staked(msg.sender, _tokenId, _nodeId, block.number);\\n  }\\n\\n  function unStakeNFT(uint256 _tokenId, uint256 _blockNumber) public {\\n    uint128 nodeId = uint128(nftIdStakedForNodeId[_tokenId]);\\n\\n    require(entityNodeStakedNftId[_msgSender()][nodeId] != 0, \\\"not staked\\\");\\n\\n    nftIdStakedForNodeId[_tokenId] = 0;\\n    entityNodeStakedNftId[_msgSender()][nodeId] = 0;\\n    entityNodeStakedNftBlock[_msgSender()][nodeId] = 0;\\n\\n    emit Unstaked(msg.sender, _tokenId, nodeId, _blockNumber);\\n  }\\n\\n  function unStakeNFTAdmin(address _entity, uint256 _tokenId, uint256 _blockNumber) public {\\n    require(msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    uint128 nodeId = uint128(nftIdStakedForNodeId[_tokenId]);\\n\\n    nftIdStakedForNodeId[_tokenId] = 0;\\n    entityNodeStakedNftId[_entity][nodeId] = 0;\\n\\n    emit Unstaked(_entity, _tokenId, nodeId, _blockNumber);\\n  }\\n\\n  function updateBonus(string memory _name, uint256 _lowerBound, uint256 _upperBound, uint256 _value) public {\\n    require(msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    bool alreadyExit = false;\\n    for (uint i = 0; i \\u003c nftBonusNames.length; i++) {\\n      if (keccak256(abi.encode(nftBonusNames[i])) == keccak256(abi.encode(_name))) {\\n        alreadyExit = true;\\n      }\\n    }\\n\\n    if (!alreadyExit) {\\n      nftBonusNames.push(_name);\\n    }\\n\\n    nftBonusLowerBound[_name] = _lowerBound;\\n    nftBonusUpperBound[_name] = _upperBound;\\n    nftBonusValue[_name] = _value;\\n  }\\n\\n  function updateContracts(address serviceContract, address nftContract) public {\\n    require(msg.sender == superAdmin, \\\"not admin\\\");\\n    service = ServiceInterface(serviceContract);\\n    nft = IERC1155Preset(nftContract);\\n  }\\n\\n  function updateServiceAdmin(address newServiceAdmin) public {\\n    require(msg.sender == superAdmin, \\\"not admin\\\");\\n    serviceAdmin = newServiceAdmin;\\n  }\\n\\n  function updateDisabled(bool _disabled) public {\\n    require(msg.sender == serviceAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n    disabled = _disabled;\\n  }\\n}\\n\"},\"StrongNFTBonusInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface StrongNFTBonusInterface {\\n  function getBonus(address _entity, uint128 _nodeId, uint256 _fromBlock, uint256 _toBlock) external view returns (uint256);\\n}\\n\"},\"StrongNFTBonusLegacyInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface StrongNFTBonusLegacyInterface {\\n  function getBonus(address _entity, uint128 _nodeId, uint256 _fromBlock, uint256 _toBlock) external view returns (uint256);\\n\\n  function getStakedNftId(address _entity, uint128 _nodeId) external view returns (uint256);\\n\\n  function isNftStaked(uint256 _nftId) external view returns (bool);\\n}\\n\"},\"StrongNFTBonusV2.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.6.12;\\n\\nimport \\\"./ServiceInterface.sol\\\";\\nimport \\\"./IERC1155Preset.sol\\\";\\nimport \\\"./StrongNFTBonusLegacyInterface.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\ncontract StrongNFTBonusV2 is Context {\\n\\n  using SafeMath for uint256;\\n\\n  event Staked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\\n  event Unstaked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\\n\\n  ServiceInterface public CService;\\n  IERC1155Preset public CERC1155;\\n  StrongNFTBonusLegacyInterface public CStrongNFTBonus;\\n\\n  bool public initDone;\\n\\n  address public serviceAdmin;\\n  address public superAdmin;\\n\\n  string[] public nftBonusNames;\\n  mapping(string =\\u003e uint256) public nftBonusLowerBound;\\n  mapping(string =\\u003e uint256) public nftBonusUpperBound;\\n  mapping(string =\\u003e uint256) public nftBonusValue;\\n  mapping(string =\\u003e uint256) public nftBonusEffectiveBlock;\\n\\n  mapping(uint256 =\\u003e address) public nftIdStakedToEntity;\\n  mapping(uint256 =\\u003e uint128) public nftIdStakedToNodeId;\\n  mapping(uint256 =\\u003e uint256) public nftIdStakedAtBlock;\\n  mapping(address =\\u003e mapping(uint128 =\\u003e uint256)) public entityNodeStakedNftId;\\n\\n  mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n  function init(address serviceContract, address nftContract, address strongNFTBonusContract, address serviceAdminAddress, address superAdminAddress) public {\\n    require(initDone == false, \\\"init done\\\");\\n\\n    _registerInterface(0x01ffc9a7);\\n    _registerInterface(\\n      ERC1155Receiver(0).onERC1155Received.selector ^\\n      ERC1155Receiver(0).onERC1155BatchReceived.selector\\n    );\\n\\n    serviceAdmin = serviceAdminAddress;\\n    superAdmin = superAdminAddress;\\n    CService = ServiceInterface(serviceContract);\\n    CERC1155 = IERC1155Preset(nftContract);\\n    CStrongNFTBonus = StrongNFTBonusLegacyInterface(strongNFTBonusContract);\\n    initDone = true;\\n  }\\n\\n  //\\n  // Getters\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function isNftStaked(uint256 _nftId) public view returns (bool) {\\n    return nftIdStakedToNodeId[_nftId] != 0;\\n  }\\n\\n  function isNftStakedLegacy(uint256 _nftId) public view returns (bool) {\\n    return CStrongNFTBonus.isNftStaked(_nftId);\\n  }\\n\\n  function getStakedNftId(address _entity, uint128 _nodeId) public view returns (uint256) {\\n    uint256 stakedNftId = entityNodeStakedNftId[_entity][_nodeId];\\n    uint256 stakedNftIdLegacy = CStrongNFTBonus.getStakedNftId(_entity, _nodeId);\\n    return stakedNftId != 0 ? stakedNftId : stakedNftIdLegacy;\\n  }\\n\\n  function getBonus(address _entity, uint128 _nodeId, uint256 _fromBlock, uint256 _toBlock) public view returns (uint256) {\\n    string memory bonusName = \\\"BRONZE\\\";\\n    uint256 nftId = getStakedNftId(_entity, _nodeId);\\n    uint256 stakedAtBlock = nftIdStakedAtBlock[nftId];\\n    uint256 effectiveBlock = nftBonusEffectiveBlock[bonusName];\\n    uint256 startFromBlock = stakedAtBlock \\u003e _fromBlock ? stakedAtBlock : _fromBlock;\\n    if (startFromBlock \\u003c effectiveBlock) {\\n      startFromBlock = effectiveBlock;\\n    }\\n\\n    if (stakedAtBlock == 0 \\u0026\\u0026 keccak256(abi.encode(bonusName)) == keccak256(abi.encode(\\\"BRONZE\\\"))) {\\n      return CStrongNFTBonus.getBonus(_entity, _nodeId, startFromBlock, _toBlock);\\n    }\\n\\n    if (nftId == 0) return 0;\\n    if (stakedAtBlock == 0) return 0;\\n    if (effectiveBlock == 0) return 0;\\n    if (startFromBlock \\u003e= _toBlock) return 0;\\n    if (nftId \\u003c nftBonusLowerBound[bonusName]) return 0;\\n    if (nftId \\u003e nftBonusUpperBound[bonusName]) return 0;\\n    if (CERC1155.balanceOf(address(this), nftId) == 0) return 0;\\n\\n    return _toBlock.sub(startFromBlock).mul(nftBonusValue[bonusName]);\\n  }\\n\\n  //\\n  // Staking\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function stakeNFT(uint256 _nftId, uint128 _nodeId) public payable {\\n    require(CERC1155.balanceOf(_msgSender(), _nftId) != 0, \\\"not enough\\\");\\n    require(entityNodeStakedNftId[_msgSender()][_nodeId] == 0, \\\"already staked\\\");\\n    require(_nftId \\u003e= nftBonusLowerBound[\\\"BRONZE\\\"] \\u0026\\u0026 _nftId \\u003c= nftBonusUpperBound[\\\"BRONZE\\\"], \\\"not eligible\\\");\\n    require(CService.doesNodeExist(_msgSender(), _nodeId), \\\"node doesnt exist\\\");\\n\\n    entityNodeStakedNftId[_msgSender()][_nodeId] = _nftId;\\n    nftIdStakedToEntity[_nftId] = _msgSender();\\n    nftIdStakedToNodeId[_nftId] = _nodeId;\\n    nftIdStakedAtBlock[_nftId] = block.number;\\n\\n    CERC1155.safeTransferFrom(_msgSender(), address(this), _nftId, 1, bytes(\\\"\\\"));\\n\\n    emit Staked(_msgSender(), _nftId, _nodeId, block.number);\\n  }\\n\\n  function unStakeNFT(uint256 _nftId, uint256 _blockNumber) public payable {\\n    require(nftIdStakedToEntity[_nftId] != address(0), \\\"not staked\\\");\\n    require(nftIdStakedToEntity[_nftId] == _msgSender(), \\\"not staker\\\");\\n\\n    uint128 nodeId = nftIdStakedToNodeId[_nftId];\\n\\n    CService.claim{value : msg.value}(nodeId, _blockNumber, false);\\n\\n    entityNodeStakedNftId[_msgSender()][nodeId] = 0;\\n    nftIdStakedToEntity[_nftId] = address(0);\\n    nftIdStakedToNodeId[_nftId] = 0;\\n\\n    CERC1155.safeTransferFrom(address(this), _msgSender(), _nftId, 1, bytes(\\\"\\\"));\\n\\n    emit Unstaked(_msgSender(), _nftId, nodeId, _blockNumber);\\n  }\\n\\n  //\\n  // Admin\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function updateBonus(string memory _name, uint256 _lowerBound, uint256 _upperBound, uint256 _value, uint256 _block) public {\\n    require(_msgSender() == serviceAdmin || _msgSender() == superAdmin, \\\"not admin\\\");\\n\\n    bool alreadyExist = false;\\n    for (uint i = 0; i \\u003c nftBonusNames.length; i++) {\\n      if (keccak256(abi.encode(nftBonusNames[i])) == keccak256(abi.encode(_name))) {\\n        alreadyExist = true;\\n      }\\n    }\\n\\n    if (!alreadyExist) {\\n      nftBonusNames.push(_name);\\n    }\\n\\n    nftBonusLowerBound[_name] = _lowerBound;\\n    nftBonusUpperBound[_name] = _upperBound;\\n    nftBonusValue[_name] = _value;\\n    nftBonusEffectiveBlock[_name] = _block != 0 ? _block : block.number;\\n  }\\n\\n  function updateContracts(address serviceContract, address nftContract) public {\\n    require(_msgSender() == superAdmin, \\\"not admin\\\");\\n    CService = ServiceInterface(serviceContract);\\n    CERC1155 = IERC1155Preset(nftContract);\\n  }\\n\\n  function updateServiceAdmin(address newServiceAdmin) public {\\n    require(_msgSender() == superAdmin, \\\"not admin\\\");\\n    serviceAdmin = newServiceAdmin;\\n  }\\n\\n  //\\n  // ERC1155 support\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\\n    return this.onERC1155Received.selector;\\n  }\\n\\n  function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual returns (bytes4) {\\n    return this.onERC1155BatchReceived.selector;\\n  }\\n\\n  function supportsInterface(bytes4 interfaceId) public view returns (bool) {\\n    return _supportedInterfaces[interfaceId];\\n  }\\n\\n  function _registerInterface(bytes4 interfaceId) internal virtual {\\n    require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n    _supportedInterfaces[interfaceId] = true;\\n  }\\n}\\n\"},\"StrongNFTBonusV5.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ServiceInterface.sol\\\";\\nimport \\\"./IERC1155Preset.sol\\\";\\nimport \\\"./StrongNFTBonusLegacyInterface.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\ncontract StrongNFTBonusV5 is Context {\\n\\n  using SafeMath for uint256;\\n\\n  event Staked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\\n  event Unstaked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\\n\\n  ServiceInterface public CService;\\n  IERC1155Preset public CERC1155;\\n  StrongNFTBonusLegacyInterface public CStrongNFTBonus;\\n\\n  bool public initDone;\\n\\n  address public serviceAdmin;\\n  address public superAdmin;\\n\\n  string[] public nftBonusNames;\\n  mapping(string =\\u003e uint256) public nftBonusLowerBound;\\n  mapping(string =\\u003e uint256) public nftBonusUpperBound;\\n  mapping(string =\\u003e uint256) public nftBonusValue;\\n  mapping(string =\\u003e uint256) public nftBonusEffectiveBlock;\\n\\n  mapping(uint256 =\\u003e address) public nftIdStakedToEntity;\\n  mapping(uint256 =\\u003e uint128) public nftIdStakedToNodeId;\\n  mapping(uint256 =\\u003e uint256) public nftIdStakedAtBlock;\\n  mapping(address =\\u003e mapping(uint128 =\\u003e uint256)) public entityNodeStakedNftId;\\n\\n  mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n  mapping(string =\\u003e uint8) public nftBonusNodesLimit;\\n  mapping(uint256 =\\u003e uint8) public nftIdStakedToNodesCount;\\n  mapping(uint128 =\\u003e uint256) public nodeIdStakedAtBlock;\\n  mapping(address =\\u003e uint256[]) public entityStakedNftIds;\\n\\n  mapping(address =\\u003e mapping(uint128 =\\u003e uint256)) public entityNodeStakedAtBlock;\\n\\n  function init(address serviceContract, address nftContract, address strongNFTBonusContract, address serviceAdminAddress, address superAdminAddress) public {\\n    require(initDone == false, \\\"init done\\\");\\n\\n    _registerInterface(0x01ffc9a7);\\n    _registerInterface(\\n      ERC1155Receiver(0).onERC1155Received.selector ^\\n      ERC1155Receiver(0).onERC1155BatchReceived.selector\\n    );\\n\\n    serviceAdmin = serviceAdminAddress;\\n    superAdmin = superAdminAddress;\\n    CService = ServiceInterface(serviceContract);\\n    CERC1155 = IERC1155Preset(nftContract);\\n    CStrongNFTBonus = StrongNFTBonusLegacyInterface(strongNFTBonusContract);\\n    initDone = true;\\n  }\\n\\n  //\\n  // Getters\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function isNftStaked(uint256 _nftId) public view returns (bool) {\\n    return nftIdStakedToNodeId[_nftId] != 0 || nftIdStakedToNodesCount[_nftId] \\u003e 0;\\n  }\\n\\n  function isNftStakedLegacy(uint256 _nftId) public view returns (bool) {\\n    return CStrongNFTBonus.isNftStaked(_nftId);\\n  }\\n\\n  function getStakedNftId(address _entity, uint128 _nodeId) public view returns (uint256) {\\n    uint256 stakedNftId = entityNodeStakedNftId[_entity][_nodeId];\\n    uint256 stakedNftIdLegacy = CStrongNFTBonus.getStakedNftId(_entity, _nodeId);\\n    return stakedNftId != 0 ? stakedNftId : stakedNftIdLegacy;\\n  }\\n\\n  function getStakedNftIds(address _entity) public view returns (uint256[] memory) {\\n    return entityStakedNftIds[_entity];\\n  }\\n\\n  function getNftBonusNames() public view returns (string[] memory) {\\n    return nftBonusNames;\\n  }\\n\\n  function getNftNodesLeft(uint256 _nftId) public view returns (uint256) {\\n    return nftBonusNodesLimit[getNftBonusName(_nftId)] - nftIdStakedToNodesCount[_nftId];\\n  }\\n\\n  function getNftBonusName(uint256 _nftId) public view returns (string memory) {\\n    for (uint8 i = 0; i \\u003c nftBonusNames.length; i++) {\\n      if (_nftId \\u003e= nftBonusLowerBound[nftBonusNames[i]] \\u0026\\u0026 _nftId \\u003c= nftBonusUpperBound[nftBonusNames[i]]) {\\n        return nftBonusNames[i];\\n      }\\n    }\\n\\n    return \\\"\\\";\\n  }\\n\\n  function getBonus(address _entity, uint128 _nodeId, uint256 _fromBlock, uint256 _toBlock) public view returns (uint256) {\\n    uint256 nftId = getStakedNftId(_entity, _nodeId);\\n    string memory bonusName = getNftBonusName(nftId);\\n    if (keccak256(abi.encode(bonusName)) == keccak256(abi.encode(\\\"\\\"))) return 0;\\n\\n    uint256 stakedAtBlock = entityNodeStakedAtBlock[_entity][_nodeId] \\u003e 0\\n    ? entityNodeStakedAtBlock[_entity][_nodeId] : nftIdStakedAtBlock[nftId];\\n    uint256 effectiveBlock = nftBonusEffectiveBlock[bonusName];\\n    uint256 startFromBlock = stakedAtBlock \\u003e _fromBlock ? stakedAtBlock : _fromBlock;\\n    if (startFromBlock \\u003c effectiveBlock) {\\n      startFromBlock = effectiveBlock;\\n    }\\n\\n    if (stakedAtBlock == 0 \\u0026\\u0026 keccak256(abi.encode(bonusName)) == keccak256(abi.encode(\\\"BRONZE\\\"))) {\\n      return CStrongNFTBonus.getBonus(_entity, _nodeId, startFromBlock, _toBlock);\\n    }\\n\\n    if (nftId == 0) return 0;\\n    if (stakedAtBlock == 0) return 0;\\n    if (effectiveBlock == 0) return 0;\\n    if (startFromBlock \\u003e= _toBlock) return 0;\\n    if (CERC1155.balanceOf(address(this), nftId) == 0) return 0;\\n\\n    return _toBlock.sub(startFromBlock).mul(nftBonusValue[bonusName]);\\n  }\\n\\n  //\\n  // Staking\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function stakeNFT(uint256 _nftId, uint128 _nodeId) public payable {\\n    string memory bonusName = getNftBonusName(_nftId);\\n    require(keccak256(abi.encode(bonusName)) != keccak256(abi.encode(\\\"\\\")), \\\"not eligible\\\");\\n    require(CERC1155.balanceOf(_msgSender(), _nftId) != 0\\n      || (CERC1155.balanceOf(address(this), _nftId) != 0 \\u0026\\u0026 nftIdStakedToEntity[_nftId] == _msgSender()), \\\"not enough\\\");\\n    require(nftIdStakedToNodesCount[_nftId] \\u003c nftBonusNodesLimit[bonusName], \\\"over limit\\\");\\n    require(entityNodeStakedNftId[_msgSender()][_nodeId] == 0, \\\"already staked\\\");\\n    require(CService.doesNodeExist(_msgSender(), _nodeId), \\\"node doesnt exist\\\");\\n\\n    entityNodeStakedNftId[_msgSender()][_nodeId] = _nftId;\\n    nftIdStakedToEntity[_nftId] = _msgSender();\\n    entityNodeStakedAtBlock[_msgSender()][_nodeId] = block.number;\\n    nftIdStakedToNodesCount[_nftId] += 1;\\n\\n    bool alreadyExists = false;\\n    for (uint8 i = 0; i \\u003c entityStakedNftIds[_msgSender()].length; i++) {\\n      if (entityStakedNftIds[_msgSender()][i] == _nftId) {\\n        alreadyExists = true;\\n        break;\\n      }\\n    }\\n    if (!alreadyExists) {\\n      entityStakedNftIds[_msgSender()].push(_nftId);\\n    }\\n\\n    if (CERC1155.balanceOf(address(this), _nftId) == 0) {\\n      CERC1155.safeTransferFrom(_msgSender(), address(this), _nftId, 1, bytes(\\\"\\\"));\\n    }\\n\\n    emit Staked(_msgSender(), _nftId, _nodeId, block.number);\\n  }\\n\\n  function unStakeNFT(uint256 _nftId, uint128 _nodeId, uint256 _blockNumber) public payable {\\n    require(entityNodeStakedNftId[_msgSender()][_nodeId] == _nftId, \\\"wrong node\\\");\\n    require(nftIdStakedToEntity[_nftId] != address(0), \\\"not staked\\\");\\n    require(nftIdStakedToEntity[_nftId] == _msgSender(), \\\"not staker\\\");\\n\\n    CService.claim{value : msg.value}(_nodeId, _blockNumber, false);\\n\\n    entityNodeStakedNftId[_msgSender()][_nodeId] = 0;\\n    nftIdStakedToNodeId[_nftId] = 0;\\n\\n    if (nftIdStakedToNodesCount[_nftId] \\u003e 0) {\\n      nftIdStakedToNodesCount[_nftId] -= 1;\\n    }\\n\\n    if (nftIdStakedToNodesCount[_nftId] == 0) {\\n      nftIdStakedToEntity[_nftId] = address(0);\\n\\n      uint256 index;\\n      bool exists = false;\\n      for (uint8 i = 0; i \\u003c entityStakedNftIds[_msgSender()].length; i++) {\\n        if (entityStakedNftIds[_msgSender()][i] == _nftId) {\\n          exists = true;\\n          index = i;\\n          break;\\n        }\\n      }\\n      if (exists) {\\n        _deleteIndex(entityStakedNftIds[_msgSender()], index);\\n      }\\n\\n      CERC1155.safeTransferFrom(address(this), _msgSender(), _nftId, 1, bytes(\\\"\\\"));\\n    }\\n\\n    emit Unstaked(_msgSender(), _nftId, _nodeId, _blockNumber);\\n  }\\n\\n  //\\n  // Admin\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function updateBonus(string memory _name, uint256 _lowerBound, uint256 _upperBound, uint256 _value, uint256 _block, uint8 _nodesLimit) public {\\n    require(_msgSender() == serviceAdmin || _msgSender() == superAdmin, \\\"not admin\\\");\\n\\n    bool alreadyExists = false;\\n    for (uint8 i = 0; i \\u003c nftBonusNames.length; i++) {\\n      if (keccak256(abi.encode(nftBonusNames[i])) == keccak256(abi.encode(_name))) {\\n        alreadyExists = true;\\n      }\\n    }\\n\\n    if (!alreadyExists) {\\n      nftBonusNames.push(_name);\\n    }\\n\\n    nftBonusLowerBound[_name] = _lowerBound;\\n    nftBonusUpperBound[_name] = _upperBound;\\n    nftBonusValue[_name] = _value;\\n    nftBonusEffectiveBlock[_name] = _block != 0 ? _block : block.number;\\n    nftBonusNodesLimit[_name] = _nodesLimit;\\n  }\\n\\n  function updateContracts(address serviceContract, address nftContract) public {\\n    require(_msgSender() == superAdmin, \\\"not admin\\\");\\n    CService = ServiceInterface(serviceContract);\\n    CERC1155 = IERC1155Preset(nftContract);\\n  }\\n\\n  function updateServiceAdmin(address newServiceAdmin) public {\\n    require(_msgSender() == superAdmin, \\\"not admin\\\");\\n    serviceAdmin = newServiceAdmin;\\n  }\\n\\n  function updateEntityNodeStakedAtBlock(address _entity, uint128 _nodeId, uint256 _block) public {\\n    require(_msgSender() == serviceAdmin || _msgSender() == superAdmin, \\\"not admin\\\");\\n\\n    entityNodeStakedAtBlock[_entity][_nodeId] = _block;\\n  }\\n\\n  //\\n  // ERC1155 support\\n  // -------------------------------------------------------------------------------------------------------------------\\n\\n  function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\\n    return this.onERC1155Received.selector;\\n  }\\n\\n  function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual returns (bytes4) {\\n    return this.onERC1155BatchReceived.selector;\\n  }\\n\\n  function supportsInterface(bytes4 interfaceId) public view returns (bool) {\\n    return _supportedInterfaces[interfaceId];\\n  }\\n\\n  function _registerInterface(bytes4 interfaceId) internal virtual {\\n    require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n    _supportedInterfaces[interfaceId] = true;\\n  }\\n\\n  function _deleteIndex(uint256[] storage array, uint256 index) internal {\\n    uint256 lastIndex = array.length.sub(1);\\n    uint256 lastEntry = array[lastIndex];\\n    if (index == lastIndex) {\\n      array.pop();\\n    } else {\\n      array[index] = lastEntry;\\n      array.pop();\\n    }\\n  }\\n}\\n\"},\"StrongNFTClaimerInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface StrongNFTClaimerInterface {\\n  function tokenNameAddressClaimed(string memory, address) external view returns(bool);\\n}\\n\"},\"StrongPoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface StrongPoolInterface {\\n  function mineFor(address miner, uint256 amount) external;\\n}\\n\"},\"StrongPoolV4.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./VoteInterface.sol\\\";\\nimport \\\"./rewards.sol\\\";\\n\\ncontract StrongPoolV4 {\\n  event MinedFor(address indexed miner, uint256 amount);\\n  event Mined(address indexed miner, uint256 amount);\\n  event MinedForVotesOnly(address indexed miner, uint256 amount);\\n  event UnminedForVotesOnly(address indexed miner, uint256 amount);\\n  event Unmined(address indexed miner, uint256 amount);\\n  event Claimed(address indexed miner, uint256 reward);\\n\\n  using SafeMath for uint256;\\n\\n  bool public initDone;\\n  address public admin;\\n  address public pendingAdmin;\\n  address public superAdmin;\\n  address public pendingSuperAdmin;\\n  address public parameterAdmin;\\n  address payable public feeCollector;\\n\\n  IERC20 public strongToken;\\n  VoteInterface public vote;\\n\\n  mapping(address =\\u003e uint256) public minerBalance;\\n  uint256 public totalBalance;\\n  mapping(address =\\u003e uint256) public minerBlockLastClaimedOn;\\n\\n  mapping(address =\\u003e uint256) public minerVotes;\\n\\n  uint256 public rewardBalance;\\n\\n  uint256 public rewardPerBlockNumerator;\\n  uint256 public rewardPerBlockDenominator;\\n\\n  uint256 public miningFeeNumerator;\\n  uint256 public miningFeeDenominator;\\n\\n  uint256 public unminingFeeNumerator;\\n  uint256 public unminingFeeDenominator;\\n\\n  uint256 public claimingFeeNumerator;\\n  uint256 public claimingFeeDenominator;\\n\\n  mapping(address =\\u003e uint256) public inboundContractIndex;\\n  address[] public inboundContracts;\\n  mapping(address =\\u003e bool) public inboundContractTrusted;\\n\\n  uint256 public claimingFeeInWei;\\n\\n  bool public removedTokens;\\n\\n  uint256 public rewardPerBlockNumeratorNew;\\n  uint256 public rewardPerBlockDenominatorNew;\\n  uint256 public rewardPerBlockNewEffectiveBlock;\\n\\n  function init(\\n    address voteAddress,\\n    address strongTokenAddress,\\n    address adminAddress,\\n    address superAdminAddress,\\n    uint256 rewardPerBlockNumeratorValue,\\n    uint256 rewardPerBlockDenominatorValue,\\n    uint256 miningFeeNumeratorValue,\\n    uint256 miningFeeDenominatorValue,\\n    uint256 unminingFeeNumeratorValue,\\n    uint256 unminingFeeDenominatorValue,\\n    uint256 claimingFeeNumeratorValue,\\n    uint256 claimingFeeDenominatorValue\\n  ) public {\\n    require(!initDone, \\\"init done\\\");\\n    vote = VoteInterface(voteAddress);\\n    strongToken = IERC20(strongTokenAddress);\\n    admin = adminAddress;\\n    superAdmin = superAdminAddress;\\n    rewardPerBlockNumerator = rewardPerBlockNumeratorValue;\\n    rewardPerBlockDenominator = rewardPerBlockDenominatorValue;\\n    miningFeeNumerator = miningFeeNumeratorValue;\\n    miningFeeDenominator = miningFeeDenominatorValue;\\n    unminingFeeNumerator = unminingFeeNumeratorValue;\\n    unminingFeeDenominator = unminingFeeDenominatorValue;\\n    claimingFeeNumerator = claimingFeeNumeratorValue;\\n    claimingFeeDenominator = claimingFeeDenominatorValue;\\n    initDone = true;\\n  }\\n\\n  // ADMIN\\n  // *************************************************************************************\\n  function updateParameterAdmin(address newParameterAdmin) public {\\n    require(newParameterAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin);\\n    parameterAdmin = newParameterAdmin;\\n  }\\n\\n  function updateFeeCollector(address payable newFeeCollector) public {\\n    require(newFeeCollector != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin);\\n    feeCollector = newFeeCollector;\\n  }\\n\\n  function setPendingAdmin(address newPendingAdmin) public {\\n    require(newPendingAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == admin, \\\"not admin\\\");\\n    pendingAdmin = newPendingAdmin;\\n  }\\n\\n  function acceptAdmin() public {\\n    require(msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingAdmin\\\");\\n    admin = pendingAdmin;\\n    pendingAdmin = address(0);\\n  }\\n\\n  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\\n    require(newPendingSuperAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin, \\\"not superAdmin\\\");\\n    pendingSuperAdmin = newPendingSuperAdmin;\\n  }\\n\\n  function acceptSuperAdmin() public {\\n    require(msg.sender == pendingSuperAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingSuperAdmin\\\");\\n    superAdmin = pendingSuperAdmin;\\n    pendingSuperAdmin = address(0);\\n  }\\n\\n  // INBOUND CONTRACTS\\n  // *************************************************************************************\\n  function addInboundContract(address contr) public {\\n    require(contr != address(0), \\\"zero\\\");\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    if (inboundContracts.length != 0) {\\n      uint256 index = inboundContractIndex[contr];\\n      require(inboundContracts[index] != contr, \\\"exists\\\");\\n    }\\n    uint256 len = inboundContracts.length;\\n    inboundContractIndex[contr] = len;\\n    inboundContractTrusted[contr] = true;\\n    inboundContracts.push(contr);\\n  }\\n\\n  function inboundContractTrustStatus(address contr, bool trustStatus) public {\\n    require(contr != address(0), \\\"zero\\\");\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    uint256 index = inboundContractIndex[contr];\\n    require(inboundContracts[index] == contr, \\\"not exists\\\");\\n    inboundContractTrusted[contr] = trustStatus;\\n  }\\n\\n  // REWARD\\n  // *************************************************************************************\\n  function updateRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    rewardPerBlockNumerator = numerator;\\n    rewardPerBlockDenominator = denominator;\\n  }\\n\\n  function deposit(uint256 amount) public {\\n    require(msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    rewardBalance = rewardBalance.add(amount);\\n  }\\n\\n  function withdraw(address destination, uint256 amount) public {\\n    require(msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    require(rewardBalance \\u003e= amount, \\\"not enough\\\");\\n    strongToken.transfer(destination, amount);\\n    rewardBalance = rewardBalance.sub(amount);\\n  }\\n\\n  // FEES\\n  // *************************************************************************************\\n  function updateMiningFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    miningFeeNumerator = numerator;\\n    miningFeeDenominator = denominator;\\n  }\\n\\n  function updateUnminingFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    unminingFeeNumerator = numerator;\\n    unminingFeeDenominator = denominator;\\n  }\\n\\n  function updateClaimingFee(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    claimingFeeNumerator = numerator;\\n    claimingFeeDenominator = denominator;\\n  }\\n\\n  // CORE\\n  // *************************************************************************************\\n  function mineForVotesOnly(uint256 amount) public {\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    minerVotes[msg.sender] = minerVotes[msg.sender].add(amount);\\n    vote.updateVotes(msg.sender, amount, true);\\n    emit MinedForVotesOnly(msg.sender, amount);\\n  }\\n\\n  function unmineForVotesOnly(uint256 amount) public {\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    require(minerVotes[msg.sender] \\u003e= amount, \\\"not enough\\\");\\n    minerVotes[msg.sender] = minerVotes[msg.sender].sub(amount);\\n    vote.updateVotes(msg.sender, amount, false);\\n    strongToken.transfer(msg.sender, amount);\\n    emit UnminedForVotesOnly(msg.sender, amount);\\n  }\\n\\n  function mineFor(address miner, uint256 amount) public {\\n    require(inboundContractTrusted[msg.sender], \\\"not trusted\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    minerBalance[miner] = minerBalance[miner].add(amount);\\n    totalBalance = totalBalance.add(amount);\\n    if (minerBlockLastClaimedOn[miner] == 0) {\\n      minerBlockLastClaimedOn[miner] = block.number;\\n    }\\n    vote.updateVotes(miner, amount, true);\\n    emit MinedFor(miner, amount);\\n  }\\n\\n  function mine(uint256 amount) public payable {\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    uint256 fee = amount.mul(miningFeeNumerator).div(miningFeeDenominator);\\n    require(msg.value == fee, \\\"invalid fee\\\");\\n    feeCollector.transfer(msg.value);\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    if (block.number \\u003e minerBlockLastClaimedOn[msg.sender]) {\\n      uint256 reward = getReward(msg.sender);\\n      if (reward \\u003e 0) {\\n        minerBalance[msg.sender] = minerBalance[msg.sender].add(reward);\\n        totalBalance = totalBalance.add(reward);\\n        rewardBalance = rewardBalance.sub(reward);\\n        vote.updateVotes(msg.sender, reward, true);\\n        minerBlockLastClaimedOn[msg.sender] = block.number;\\n      }\\n    }\\n    minerBalance[msg.sender] = minerBalance[msg.sender].add(amount);\\n    totalBalance = totalBalance.add(amount);\\n    if (minerBlockLastClaimedOn[msg.sender] == 0) {\\n      minerBlockLastClaimedOn[msg.sender] = block.number;\\n    }\\n    vote.updateVotes(msg.sender, amount, true);\\n    emit Mined(msg.sender, amount);\\n  }\\n\\n  function unmine(uint256 amount) public payable {\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    uint256 fee = amount.mul(unminingFeeNumerator).div(unminingFeeDenominator);\\n    require(msg.value == fee, \\\"invalid fee\\\");\\n    require(minerBalance[msg.sender] \\u003e= amount, \\\"not enough\\\");\\n    feeCollector.transfer(msg.value);\\n    bool unmineAll = (amount == minerBalance[msg.sender]);\\n    if (block.number \\u003e minerBlockLastClaimedOn[msg.sender]) {\\n      uint256 reward = getReward(msg.sender);\\n      if (reward \\u003e 0) {\\n        minerBalance[msg.sender] = minerBalance[msg.sender].add(reward);\\n        totalBalance = totalBalance.add(reward);\\n        rewardBalance = rewardBalance.sub(reward);\\n        vote.updateVotes(msg.sender, reward, true);\\n        minerBlockLastClaimedOn[msg.sender] = block.number;\\n      }\\n    }\\n    uint256 amountToUnmine = unmineAll ? minerBalance[msg.sender] : amount;\\n    minerBalance[msg.sender] = minerBalance[msg.sender].sub(amountToUnmine);\\n    totalBalance = totalBalance.sub(amountToUnmine);\\n    strongToken.transfer(msg.sender, amountToUnmine);\\n    vote.updateVotes(msg.sender, amountToUnmine, false);\\n    if (minerBalance[msg.sender] == 0) {\\n      minerBlockLastClaimedOn[msg.sender] = 0;\\n    }\\n    emit Unmined(msg.sender, amountToUnmine);\\n  }\\n\\n  function claim(uint256 blockNumber) public payable {\\n    require(blockNumber \\u003c= block.number, \\\"invalid block number\\\");\\n    require(minerBlockLastClaimedOn[msg.sender] != 0, \\\"error\\\");\\n    require(blockNumber \\u003e minerBlockLastClaimedOn[msg.sender], \\\"too soon\\\");\\n    uint256 reward = getRewardByBlock(msg.sender, blockNumber);\\n    require(reward \\u003e 0, \\\"no reward\\\");\\n    uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\\n    require(msg.value == fee, \\\"invalid fee\\\");\\n    feeCollector.transfer(msg.value);\\n    minerBalance[msg.sender] = minerBalance[msg.sender].add(reward);\\n    totalBalance = totalBalance.add(reward);\\n    rewardBalance = rewardBalance.sub(reward);\\n    minerBlockLastClaimedOn[msg.sender] = blockNumber;\\n    vote.updateVotes(msg.sender, reward, true);\\n    emit Claimed(msg.sender, reward);\\n  }\\n\\n  function getReward(address miner) public view returns (uint256) {\\n    return getRewardByBlock(miner, block.number);\\n  }\\n\\n  function getRewardByBlock(address miner, uint256 blockNumber) public view returns (uint256) {\\n    uint256 blockLastClaimedOn = minerBlockLastClaimedOn[miner];\\n\\n    if (blockNumber \\u003e block.number) return 0;\\n    if (blockLastClaimedOn == 0) return 0;\\n    if (blockNumber \\u003c blockLastClaimedOn) return 0;\\n    if (totalBalance == 0) return 0;\\n\\n    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, blockNumber);\\n    uint256 rewardOld = rewardPerBlockDenominator \\u003e 0 ? rewardBlocks[0].mul(rewardPerBlockNumerator).div(rewardPerBlockDenominator) : 0;\\n    uint256 rewardNew = rewardPerBlockDenominatorNew \\u003e 0 ? rewardBlocks[1].mul(rewardPerBlockNumeratorNew).div(rewardPerBlockDenominatorNew) : 0;\\n\\n    return rewardOld.add(rewardNew).mul(minerBalance[miner]).div(totalBalance);\\n  }\\n\\n  function updateRewardPerBlockNew(\\n    uint256 numerator,\\n    uint256 denominator,\\n    uint256 effectiveBlock\\n  ) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    rewardPerBlockNumeratorNew = numerator;\\n    rewardPerBlockDenominatorNew = denominator;\\n    rewardPerBlockNewEffectiveBlock = effectiveBlock != 0 ? effectiveBlock : block.number;\\n  }\\n}\\n\"},\"VoteInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface VoteInterface {\\n  function getPriorProposalVotes(address account, uint256 blockNumber) external view returns (uint96);\\n\\n  function updateVotes(\\n    address voter,\\n    uint256 rawAmount,\\n    bool adding\\n  ) external;\\n}\\n\"},\"VoteV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./StrongPoolInterface.sol\\\";\\nimport \\\"./ServiceInterface.sol\\\";\\nimport \\\"./rewards.sol\\\";\\n\\ncontract VoteV3 {\\n  event Voted(address indexed voter, address indexed service, address indexed entity, uint256 amount);\\n  event RecalledVote(address indexed voter, address indexed service, address indexed entity, uint256 amount);\\n  event Claimed(address indexed claimer, uint256 amount);\\n  event VotesAdded(address indexed miner, uint256 amount);\\n  event VotesSubtracted(address indexed miner, uint256 amount);\\n  event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\\n\\n  using SafeMath for uint256;\\n\\n  StrongPoolInterface public strongPool;\\n  IERC20 public strongToken;\\n\\n  bool public initDone;\\n  address public admin;\\n  address public pendingAdmin;\\n  address public superAdmin;\\n  address public pendingSuperAdmin;\\n  address public parameterAdmin;\\n\\n  uint256 public rewardBalance;\\n\\n  uint256 public voterRewardPerBlockNumerator;\\n  uint256 public voterRewardPerBlockDenominator;\\n  uint256 public entityRewardPerBlockNumerator;\\n  uint256 public entityRewardPerBlockDenominator;\\n\\n  mapping(address =\\u003e uint96) public balances;\\n  mapping(address =\\u003e address) public delegates;\\n\\n  mapping(address =\\u003e mapping(uint32 =\\u003e uint32)) public checkpointsFromBlock;\\n  mapping(address =\\u003e mapping(uint32 =\\u003e uint96)) public checkpointsVotes;\\n  mapping(address =\\u003e uint32) public numCheckpoints;\\n\\n  mapping(address =\\u003e uint256) public voterVotesOut;\\n  uint256 public totalVotesOut;\\n\\n  mapping(address =\\u003e uint256) public serviceVotes;\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) public serviceEntityVotes;\\n  mapping(address =\\u003e mapping(address =\\u003e mapping(address =\\u003e uint256))) public voterServiceEntityVotes;\\n\\n  mapping(address =\\u003e address[]) public voterServices;\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) public voterServiceIndex;\\n\\n  mapping(address =\\u003e mapping(address =\\u003e address[])) public voterServiceEntities;\\n  mapping(address =\\u003e mapping(address =\\u003e mapping(address =\\u003e uint256))) public voterServiceEntityIndex;\\n\\n  mapping(address =\\u003e uint256) public voterBlockLastClaimedOn;\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) public serviceEntityBlockLastClaimedOn;\\n\\n  address[] public serviceContracts;\\n  mapping(address =\\u003e uint256) public serviceContractIndex;\\n  mapping(address =\\u003e bool) public serviceContractActive;\\n\\n  uint256 public voterRewardPerBlockNumeratorNew;\\n  uint256 public voterRewardPerBlockDenominatorNew;\\n  uint256 public entityRewardPerBlockNumeratorNew;\\n  uint256 public entityRewardPerBlockDenominatorNew;\\n  uint256 public rewardPerBlockNewEffectiveBlock;\\n\\n  function init(\\n    address strongTokenAddress,\\n    address strongPoolAddress,\\n    address adminAddress,\\n    address superAdminAddress,\\n    uint256 voterRewardPerBlockNumeratorValue,\\n    uint256 voterRewardPerBlockDenominatorValue,\\n    uint256 entityRewardPerBlockNumeratorValue,\\n    uint256 entityRewardPerBlockDenominatorValue\\n  ) public {\\n    require(!initDone, \\\"init done\\\");\\n    strongToken = IERC20(strongTokenAddress);\\n    strongPool = StrongPoolInterface(strongPoolAddress);\\n    admin = adminAddress;\\n    superAdmin = superAdminAddress;\\n    voterRewardPerBlockNumerator = voterRewardPerBlockNumeratorValue;\\n    voterRewardPerBlockDenominator = voterRewardPerBlockDenominatorValue;\\n    entityRewardPerBlockNumerator = entityRewardPerBlockNumeratorValue;\\n    entityRewardPerBlockDenominator = entityRewardPerBlockDenominatorValue;\\n    initDone = true;\\n  }\\n\\n  // ADMIN\\n  // *************************************************************************************\\n  function updateParameterAdmin(address newParameterAdmin) public {\\n    require(newParameterAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin);\\n    parameterAdmin = newParameterAdmin;\\n  }\\n\\n  function setPendingAdmin(address newPendingAdmin) public {\\n    require(newPendingAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == admin, \\\"not admin\\\");\\n    pendingAdmin = newPendingAdmin;\\n  }\\n\\n  function acceptAdmin() public {\\n    require(msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingAdmin\\\");\\n    admin = pendingAdmin;\\n    pendingAdmin = address(0);\\n  }\\n\\n  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\\n    require(newPendingSuperAdmin != address(0), \\\"zero\\\");\\n    require(msg.sender == superAdmin, \\\"not superAdmin\\\");\\n    pendingSuperAdmin = newPendingSuperAdmin;\\n  }\\n\\n  function acceptSuperAdmin() public {\\n    require(msg.sender == pendingSuperAdmin \\u0026\\u0026 msg.sender != address(0), \\\"not pendingSuperAdmin\\\");\\n    superAdmin = pendingSuperAdmin;\\n    pendingSuperAdmin = address(0);\\n  }\\n\\n  // SERVICE CONTRACTS\\n  // *************************************************************************************\\n  function addServiceContract(address contr) public {\\n    require(contr != address(0), \\\"zero\\\");\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    if (serviceContracts.length != 0) {\\n      uint256 index = serviceContractIndex[contr];\\n      require(serviceContracts[index] != contr, \\\"exists\\\");\\n    }\\n    uint256 len = serviceContracts.length;\\n    serviceContractIndex[contr] = len;\\n    serviceContractActive[contr] = true;\\n    serviceContracts.push(contr);\\n  }\\n\\n  function updateServiceContractActiveStatus(address contr, bool activeStatus) public {\\n    require(contr != address(0), \\\"zero\\\");\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(serviceContracts.length \\u003e 0, \\\"zero\\\");\\n    uint256 index = serviceContractIndex[contr];\\n    require(serviceContracts[index] == contr, \\\"not exists\\\");\\n    serviceContractActive[contr] = activeStatus;\\n  }\\n\\n  function getServiceContracts() public view returns (address[] memory) {\\n    return serviceContracts;\\n  }\\n\\n  // REWARD\\n  // *************************************************************************************\\n  function updateVoterRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    voterRewardPerBlockNumerator = numerator;\\n    voterRewardPerBlockDenominator = denominator;\\n  }\\n\\n  function updateEntityRewardPerBlock(uint256 numerator, uint256 denominator) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(denominator != 0, \\\"invalid value\\\");\\n    entityRewardPerBlockNumerator = numerator;\\n    entityRewardPerBlockDenominator = denominator;\\n  }\\n\\n  function deposit(uint256 amount) public {\\n    require(msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    strongToken.transferFrom(msg.sender, address(this), amount);\\n    rewardBalance = rewardBalance.add(amount);\\n  }\\n\\n  function withdraw(address destination, uint256 amount) public {\\n    require(msg.sender == superAdmin, \\\"not an admin\\\");\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    require(rewardBalance \\u003e= amount, \\\"not enough\\\");\\n    strongToken.transfer(destination, amount);\\n    rewardBalance = rewardBalance.sub(amount);\\n  }\\n\\n  // CORE\\n  // *************************************************************************************\\n  function getVoterServices(address voter) public view returns (address[] memory) {\\n    return voterServices[voter];\\n  }\\n\\n  function getVoterServiceEntities(address voter, address service) public view returns (address[] memory) {\\n    return voterServiceEntities[voter][service];\\n  }\\n\\n  function getVoterReward(address voter) public view returns (uint256) {\\n    uint256 blockLastClaimedOn = voterBlockLastClaimedOn[voter];\\n\\n    if (totalVotesOut == 0) return 0;\\n    if (blockLastClaimedOn == 0) return 0;\\n\\n    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, block.number);\\n    uint256 rewardOld = voterRewardPerBlockNumerator \\u003e 0 ? rewardBlocks[0].mul(voterRewardPerBlockNumerator).div(voterRewardPerBlockDenominator) : 0;\\n    uint256 rewardNew = voterRewardPerBlockNumeratorNew \\u003e 0 ? rewardBlocks[1].mul(voterRewardPerBlockNumeratorNew).div(voterRewardPerBlockDenominatorNew) : 0;\\n\\n    return rewardOld.add(rewardNew).mul(voterVotesOut[voter]).div(totalVotesOut);\\n  }\\n\\n  function getEntityReward(address service, address entity) public view returns (uint256) {\\n    uint256 blockLastClaimedOn = serviceEntityBlockLastClaimedOn[service][entity];\\n\\n    if (serviceVotes[service] == 0) return 0;\\n    if (blockLastClaimedOn == 0) return 0;\\n\\n    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, block.number);\\n    uint256 rewardOld = entityRewardPerBlockNumerator \\u003e 0 ? rewardBlocks[0].mul(entityRewardPerBlockNumerator).div(entityRewardPerBlockDenominator) : 0;\\n    uint256 rewardNew = entityRewardPerBlockNumeratorNew \\u003e 0 ? rewardBlocks[1].mul(entityRewardPerBlockNumeratorNew).div(entityRewardPerBlockDenominatorNew) : 0;\\n\\n    return rewardOld.add(rewardNew).mul(serviceEntityVotes[service][entity]).div(serviceVotes[service]);\\n  }\\n\\n  function vote(\\n    address service,\\n    address entity,\\n    uint256 amount\\n  ) public {\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    require(uint256(_getAvailableServiceEntityVotes(msg.sender)) \\u003e= amount, \\\"not enough\\\");\\n    require(serviceContractActive[service], \\\"service not active\\\");\\n    require(ServiceInterface(service).isEntityActive(entity), \\\"entity not active\\\");\\n\\n    uint256 serviceIndex = voterServiceIndex[msg.sender][service];\\n    if (voterServices[msg.sender].length == 0 || voterServices[msg.sender][serviceIndex] != service) {\\n      uint256 len = voterServices[msg.sender].length;\\n      voterServiceIndex[msg.sender][service] = len;\\n      voterServices[msg.sender].push(service);\\n    }\\n\\n    uint256 entityIndex = voterServiceEntityIndex[msg.sender][service][entity];\\n    if (\\n      voterServiceEntities[msg.sender][service].length == 0 ||\\n      voterServiceEntities[msg.sender][service][entityIndex] != entity\\n    ) {\\n      uint256 len = voterServiceEntities[msg.sender][service].length;\\n      voterServiceEntityIndex[msg.sender][service][entity] = len;\\n      voterServiceEntities[msg.sender][service].push(entity);\\n    }\\n\\n    if (block.number \\u003e voterBlockLastClaimedOn[msg.sender]) {\\n      uint256 reward = getVoterReward(msg.sender);\\n      if (reward \\u003e 0) {\\n        rewardBalance = rewardBalance.sub(reward);\\n        strongToken.approve(address(strongPool), reward);\\n        strongPool.mineFor(msg.sender, reward);\\n        voterBlockLastClaimedOn[msg.sender] = block.number;\\n      }\\n    }\\n\\n    if (block.number \\u003e serviceEntityBlockLastClaimedOn[service][entity]) {\\n      uint256 reward = getEntityReward(service, entity);\\n      if (reward \\u003e 0) {\\n        rewardBalance = rewardBalance.sub(reward);\\n        strongToken.approve(address(strongPool), reward);\\n        strongPool.mineFor(entity, reward);\\n        serviceEntityBlockLastClaimedOn[service][entity] = block.number;\\n      }\\n    }\\n\\n    serviceVotes[service] = serviceVotes[service].add(amount);\\n    serviceEntityVotes[service][entity] = serviceEntityVotes[service][entity].add(amount);\\n    voterServiceEntityVotes[msg.sender][service][entity] = voterServiceEntityVotes[msg.sender][service][entity].add(\\n      amount\\n    );\\n\\n    voterVotesOut[msg.sender] = voterVotesOut[msg.sender].add(amount);\\n    totalVotesOut = totalVotesOut.add(amount);\\n\\n    if (voterBlockLastClaimedOn[msg.sender] == 0) {\\n      voterBlockLastClaimedOn[msg.sender] = block.number;\\n    }\\n\\n    if (serviceEntityBlockLastClaimedOn[service][entity] == 0) {\\n      serviceEntityBlockLastClaimedOn[service][entity] = block.number;\\n    }\\n\\n    emit Voted(msg.sender, service, entity, amount);\\n  }\\n\\n  function recallVote(\\n    address service,\\n    address entity,\\n    uint256 amount\\n  ) public {\\n    require(amount \\u003e 0, \\\"zero\\\");\\n    require(voterServiceEntityVotes[msg.sender][service][entity] \\u003e= amount, \\\"not enough\\\");\\n\\n    if (block.number \\u003e voterBlockLastClaimedOn[msg.sender]) {\\n      uint256 reward = getVoterReward(msg.sender);\\n      if (reward \\u003e 0) {\\n        rewardBalance = rewardBalance.sub(reward);\\n        strongToken.approve(address(strongPool), reward);\\n        strongPool.mineFor(msg.sender, reward);\\n        voterBlockLastClaimedOn[msg.sender] = block.number;\\n      }\\n    }\\n\\n    if (block.number \\u003e serviceEntityBlockLastClaimedOn[service][entity]) {\\n      uint256 reward = getEntityReward(service, entity);\\n      if (reward \\u003e 0) {\\n        rewardBalance = rewardBalance.sub(reward);\\n        strongToken.approve(address(strongPool), reward);\\n        strongPool.mineFor(entity, reward);\\n        serviceEntityBlockLastClaimedOn[service][entity] = block.number;\\n      }\\n    }\\n\\n    serviceVotes[service] = serviceVotes[service].sub(amount);\\n    serviceEntityVotes[service][entity] = serviceEntityVotes[service][entity].sub(amount);\\n    voterServiceEntityVotes[msg.sender][service][entity] = voterServiceEntityVotes[msg.sender][service][entity].sub(\\n      amount\\n    );\\n\\n    voterVotesOut[msg.sender] = voterVotesOut[msg.sender].sub(amount);\\n    totalVotesOut = totalVotesOut.sub(amount);\\n\\n    if (voterVotesOut[msg.sender] == 0) {\\n      voterBlockLastClaimedOn[msg.sender] = 0;\\n    }\\n\\n    if (serviceEntityVotes[service][entity] == 0) {\\n      serviceEntityBlockLastClaimedOn[service][entity] = 0;\\n    }\\n    emit RecalledVote(msg.sender, service, entity, amount);\\n  }\\n\\n  function voterClaim() public {\\n    require(voterBlockLastClaimedOn[msg.sender] != 0, \\\"error\\\");\\n    require(block.number \\u003e voterBlockLastClaimedOn[msg.sender], \\\"too soon\\\");\\n    uint256 reward = getVoterReward(msg.sender);\\n    require(reward \\u003e 0, \\\"no reward\\\");\\n    rewardBalance = rewardBalance.sub(reward);\\n    strongToken.approve(address(strongPool), reward);\\n    strongPool.mineFor(msg.sender, reward);\\n    voterBlockLastClaimedOn[msg.sender] = block.number;\\n    emit Claimed(msg.sender, reward);\\n  }\\n\\n  function entityClaim(address service) public {\\n    require(serviceEntityBlockLastClaimedOn[service][msg.sender] != 0, \\\"error\\\");\\n    require(block.number \\u003e serviceEntityBlockLastClaimedOn[service][msg.sender], \\\"too soon\\\");\\n    require(ServiceInterface(service).isEntityActive(msg.sender), \\\"not active\\\");\\n    uint256 reward = getEntityReward(service, msg.sender);\\n    require(reward \\u003e 0, \\\"no reward\\\");\\n    rewardBalance = rewardBalance.sub(reward);\\n    strongToken.approve(address(strongPool), reward);\\n    strongPool.mineFor(msg.sender, reward);\\n    serviceEntityBlockLastClaimedOn[service][msg.sender] = block.number;\\n    emit Claimed(msg.sender, reward);\\n  }\\n\\n  function updateVotes(\\n    address voter,\\n    uint256 rawAmount,\\n    bool adding\\n  ) public {\\n    require(msg.sender == address(strongPool), \\\"not strongPool\\\");\\n    uint96 amount = _safe96(rawAmount, \\\"amount exceeds 96 bits\\\");\\n    if (adding) {\\n      _addVotes(voter, amount);\\n    } else {\\n      require(_getAvailableServiceEntityVotes(voter) \\u003e= amount, \\\"recall votes\\\");\\n      _subVotes(voter, amount);\\n    }\\n  }\\n\\n  function getCurrentProposalVotes(address account) external view returns (uint96) {\\n    return _getCurrentProposalVotes(account);\\n  }\\n\\n  function getPriorProposalVotes(address account, uint256 blockNumber) external view returns (uint96) {\\n    require(blockNumber \\u003c block.number, \\\"not yet determined\\\");\\n    uint32 nCheckpoints = numCheckpoints[account];\\n    if (nCheckpoints == 0) {\\n      return 0;\\n    }\\n    if (checkpointsFromBlock[account][nCheckpoints - 1] \\u003c= blockNumber) {\\n      return checkpointsVotes[account][nCheckpoints - 1];\\n    }\\n    if (checkpointsFromBlock[account][0] \\u003e blockNumber) {\\n      return 0;\\n    }\\n    uint32 lower = 0;\\n    uint32 upper = nCheckpoints - 1;\\n    while (upper \\u003e lower) {\\n      uint32 center = upper - (upper - lower) / 2;\\n      uint32 fromBlock = checkpointsFromBlock[account][center];\\n      uint96 votes = checkpointsVotes[account][center];\\n      if (fromBlock == blockNumber) {\\n        return votes;\\n      } else if (fromBlock \\u003c blockNumber) {\\n        lower = center;\\n      } else {\\n        upper = center - 1;\\n      }\\n    }\\n    return checkpointsVotes[account][lower];\\n  }\\n\\n  function getAvailableServiceEntityVotes(address account) public view returns (uint96) {\\n    return _getAvailableServiceEntityVotes(account);\\n  }\\n\\n  // SUPPORT\\n  // *************************************************************************************\\n  function _addVotes(address voter, uint96 amount) internal {\\n    require(voter != address(0), \\\"zero address\\\");\\n    balances[voter] = _add96(balances[voter], amount, \\\"vote amount overflows\\\");\\n    _addDelegates(voter, amount);\\n    emit VotesAdded(voter, amount);\\n  }\\n\\n  function _subVotes(address voter, uint96 amount) internal {\\n    balances[voter] = _sub96(balances[voter], amount, \\\"vote amount exceeds balance\\\");\\n    _subtractDelegates(voter, amount);\\n    emit VotesSubtracted(voter, amount);\\n  }\\n\\n  function _addDelegates(address miner, uint96 amount) internal {\\n    if (delegates[miner] == address(0)) {\\n      delegates[miner] = miner;\\n    }\\n    address currentDelegate = delegates[miner];\\n    _moveDelegates(address(0), currentDelegate, amount);\\n  }\\n\\n  function _subtractDelegates(address miner, uint96 amount) internal {\\n    address currentDelegate = delegates[miner];\\n    _moveDelegates(currentDelegate, address(0), amount);\\n  }\\n\\n  function _moveDelegates(\\n    address srcRep,\\n    address dstRep,\\n    uint96 amount\\n  ) internal {\\n    if (srcRep != dstRep \\u0026\\u0026 amount \\u003e 0) {\\n      if (srcRep != address(0)) {\\n        uint32 srcRepNum = numCheckpoints[srcRep];\\n        uint96 srcRepOld = srcRepNum \\u003e 0 ? checkpointsVotes[srcRep][srcRepNum - 1] : 0;\\n        uint96 srcRepNew = _sub96(srcRepOld, amount, \\\"vote amount underflows\\\");\\n        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n      }\\n      if (dstRep != address(0)) {\\n        uint32 dstRepNum = numCheckpoints[dstRep];\\n        uint96 dstRepOld = dstRepNum \\u003e 0 ? checkpointsVotes[dstRep][dstRepNum - 1] : 0;\\n        uint96 dstRepNew = _add96(dstRepOld, amount, \\\"vote amount overflows\\\");\\n        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n      }\\n    }\\n  }\\n\\n  function _writeCheckpoint(\\n    address delegatee,\\n    uint32 nCheckpoints,\\n    uint96 oldVotes,\\n    uint96 newVotes\\n  ) internal {\\n    uint32 blockNumber = _safe32(block.number, \\\"block number exceeds 32 bits\\\");\\n    if (nCheckpoints \\u003e 0 \\u0026\\u0026 checkpointsFromBlock[delegatee][nCheckpoints - 1] == blockNumber) {\\n      checkpointsVotes[delegatee][nCheckpoints - 1] = newVotes;\\n    } else {\\n      checkpointsFromBlock[delegatee][nCheckpoints] = blockNumber;\\n      checkpointsVotes[delegatee][nCheckpoints] = newVotes;\\n      numCheckpoints[delegatee] = nCheckpoints + 1;\\n    }\\n\\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n  }\\n\\n  function _safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\n    require(n \\u003c 2**32, errorMessage);\\n    return uint32(n);\\n  }\\n\\n  function _safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\\n    require(n \\u003c 2**96, errorMessage);\\n    return uint96(n);\\n  }\\n\\n  function _add96(\\n    uint96 a,\\n    uint96 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint96) {\\n    uint96 c = a + b;\\n    require(c \\u003e= a, errorMessage);\\n    return c;\\n  }\\n\\n  function _sub96(\\n    uint96 a,\\n    uint96 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint96) {\\n    require(b \\u003c= a, errorMessage);\\n    return a - b;\\n  }\\n\\n  function _getCurrentProposalVotes(address account) internal view returns (uint96) {\\n    uint32 nCheckpoints = numCheckpoints[account];\\n    return nCheckpoints \\u003e 0 ? checkpointsVotes[account][nCheckpoints - 1] : 0;\\n  }\\n\\n  function _getAvailableServiceEntityVotes(address account) internal view returns (uint96) {\\n    uint96 proposalVotes = _getCurrentProposalVotes(account);\\n    return proposalVotes == 0 ? 0 : proposalVotes - _safe96(voterVotesOut[account], \\\"voterVotesOut exceeds 96 bits\\\");\\n  }\\n\\n  function updateRewardPerBlockNew(\\n    uint256 numeratorVoter,\\n    uint256 denominatorVoter,\\n    uint256 numeratorEntity,\\n    uint256 denominatorEntity,\\n    uint256 effectiveBlock\\n  ) public {\\n    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, \\\"not admin\\\");\\n\\n    voterRewardPerBlockNumeratorNew = numeratorVoter;\\n    voterRewardPerBlockDenominatorNew = denominatorVoter;\\n    entityRewardPerBlockNumeratorNew = numeratorEntity;\\n    entityRewardPerBlockDenominatorNew = denominatorEntity;\\n    rewardPerBlockNewEffectiveBlock = effectiveBlock != 0 ? effectiveBlock : block.number;\\n  }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"nodeId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"nodeId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CERC1155\",\"outputs\":[{\"internalType\":\"contract IERC1155Preset\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CService\",\"outputs\":[{\"internalType\":\"contract ServiceInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CStrongNFTBonus\",\"outputs\":[{\"internalType\":\"contract StrongNFTBonusLegacyInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"entityNodeStakedAtBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"entityNodeStakedNftId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entityStakedNftIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_nodeId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"_fromBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toBlock\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getNftBonusName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNftBonusNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getNftNodesLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_nodeId\",\"type\":\"uint128\"}],\"name\":\"getStakedNftId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"}],\"name\":\"getStakedNftIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"serviceContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strongNFTBonusContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"serviceAdminAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"superAdminAddress\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initDone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"isNftStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"isNftStakedLegacy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"nftBonusEffectiveBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"nftBonusLowerBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftBonusNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"nftBonusNodesLimit\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"nftBonusUpperBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"nftBonusValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftIdStakedAtBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftIdStakedToEntity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftIdStakedToNodeId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftIdStakedToNodesCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"nodeIdStakedAtBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_nodeId\",\"type\":\"uint128\"}],\"name\":\"stakeNFT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_nodeId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"unStakeNFT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_lowerBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_upperBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_nodesLimit\",\"type\":\"uint8\"}],\"name\":\"updateBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"serviceContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"}],\"name\":\"updateContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_nodeId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"updateEntityNodeStakedAtBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newServiceAdmin\",\"type\":\"address\"}],\"name\":\"updateServiceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StrongNFTBonusV5","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f14f65abb113125a408e9270fe4e05f3e325aca40f81e7a4dbe455b50753871c"}]}