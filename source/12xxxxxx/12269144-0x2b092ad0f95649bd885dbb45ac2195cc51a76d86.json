{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.11\r\n\r\n\"\"\"\r\n@title Unagii GuardErc20\r\n@author stakewith.us\r\n@license AGPL-3.0-or-later\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20 \r\n\r\ninterface Erc20Vault:\r\n    def token() -> address: view\r\n    def deposit(_amount: uint256): nonpayable\r\n    def withdraw(_shares: uint256, _min: uint256): nonpayable\r\n\r\nevent SetPause:\r\n    paused: bool\r\n\r\nevent SetWhitelist:\r\n    addr: indexed(address)\r\n    approved: bool\r\n\r\nevent Deposit:\r\n    sender: indexed(address)\r\n    amount: uint256\r\n\r\nevent Withdraw:\r\n    sender: indexed(address)\r\n    amount: uint256\r\n\r\nadmin: public(address)\r\nnextAdmin: public(address)\r\npaused: public(bool)\r\nvault: public(address)\r\ntoken: public(address)\r\nwhitelist: public(HashMap[address, bool])\r\n\r\nlastBlock: public(HashMap[address, uint256])\r\n\r\n@external\r\ndef __init__(_vault: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _vault Address of ERC20 vault\r\n    \"\"\"\r\n    self.admin = msg.sender\r\n\r\n    self.vault = _vault\r\n    self.token = Erc20Vault(_vault).token()\r\n\r\n    # deposit\r\n    ERC20(self.token).approve(self.vault, MAX_UINT256)\r\n    # withdraw\r\n    ERC20(self.vault).approve(self.vault, MAX_UINT256)\r\n\r\n@external\r\ndef setNextAdmin(_nextAdmin: address):\r\n    \"\"\"\r\n    @notice Set next admin\r\n    @param _nextAdmin Address of next admin\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"!admin\"\r\n    # allow next admin = zero address\r\n    self.nextAdmin = _nextAdmin\r\n\r\n@external\r\ndef claimAdmin():\r\n    \"\"\"\r\n    @notice Claim admin\r\n    @dev Only `nextAdmin` can claim admin \r\n    \"\"\"\r\n    assert msg.sender == self.nextAdmin, \"!next admin\"\r\n    self.admin = msg.sender\r\n    self.nextAdmin = ZERO_ADDRESS\r\n\r\n@external\r\ndef setPause(_paused: bool):\r\n    \"\"\"\r\n    @notice Pause / unpause contract\r\n    @param _paused Boolean flag\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"!admin\"\r\n    self.paused = _paused\r\n    log SetPause(_paused)\r\n\r\n@external\r\ndef setWhitelist(_addr: address, _approved: bool):\r\n    \"\"\"\r\n    @notice Approve or revoke an address to call deposit and withdraw\r\n    @param _approved Boolean flag\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"!admin\"\r\n    self.whitelist[_addr] = _approved\r\n    log SetWhitelist(_addr, _approved)\r\n\r\n@internal\r\ndef _safeTransfer(_token: address, _to: address, _amount: uint256):\r\n    \"\"\"\r\n    @dev \"safeTransfer\" which works for ERC20s which return bool or not\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS, \"to = 0 address\"\r\n\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(_to, bytes32),\r\n            convert(_amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"transfer failed\"  \r\n\r\n@internal\r\ndef _safeTransferFrom(_token: address, _from: address, _to: address, _amount: uint256):\r\n    \"\"\"\r\n    @dev \"safeTransferFrom\" which works for ERC20s which return bool or not\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS, \"to = 0 address\"\r\n\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transferFrom(address,address,uint256)\"),\r\n            convert(_from, bytes32),\r\n            convert(_to, bytes32),\r\n            convert(_amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"transfer from failed\"  \r\n\r\n@nonreentrant(\"lock\")\r\n@external\r\ndef deposit(_amount: uint256, _min: uint256):\r\n    \"\"\"\r\n    @notice Deposit `token` into `vault`\r\n    @param _amount Amount of `token` to deposit\r\n    @param _min Minimum shares expected to return from Unagii vault\r\n    @dev Transfers Unagii vault shares back to caller\r\n    @dev Protects against flash loan attacks by preventing EOA to\r\n         deposit and withdraw in the same block\r\n    \"\"\"\r\n    assert not self.paused, \"paused\"\r\n    assert self.whitelist[msg.sender], \"!whitelist\"\r\n\r\n    assert block.number > self.lastBlock[tx.origin], \"no flash\"\r\n    # track EOA\r\n    # tracking EOA prevents the following flash loan\r\n    # 1. contract A calls deposit\r\n    # 2. contract A transfers shares to contract B\r\n    # 3. contract B calls withdraw\r\n    self.lastBlock[tx.origin] = block.number\r\n    \r\n    self._safeTransferFrom(self.token, msg.sender, self, _amount)\r\n\r\n    # cache, saves about 2000 gas\r\n    _vault: address = self.vault\r\n\r\n    sharesBefore: uint256 = ERC20(_vault).balanceOf(self)\r\n    # if token has fee on transfer, this function will fail\r\n    Erc20Vault(_vault).deposit(_amount)\r\n    sharesAfter: uint256 = ERC20(_vault).balanceOf(self)\r\n\r\n    sharesDiff: uint256 = sharesAfter - sharesBefore\r\n\r\n    assert sharesDiff >= _min, \"shares < min\"\r\n\r\n    # Vault returns bool, so no need to use _safeTransfer\r\n    ERC20(_vault).transfer(msg.sender, sharesDiff)\r\n\r\n    log Deposit(msg.sender, _amount)\r\n\r\n@nonreentrant(\"lock\")\r\n@external\r\ndef withdraw(_shares: uint256, _min: uint256):\r\n    \"\"\"\r\n    @notice Withdraw `token` from `vault`\r\n    @param _shares Amount of Unagii vault shares to burn\r\n    @param _min Minimum token expected to return from Unagii vault\r\n    @dev Transfers `token` back to caller\r\n    @dev Protects against flash loan attacks by preventing EOA to\r\n         deposit and withdraw in the same block\r\n    \"\"\"\r\n    # allow withdraw even if paused = true\r\n    assert self.whitelist[msg.sender], \"!whitelist\"\r\n\r\n    assert block.number > self.lastBlock[tx.origin], \"no flash\"\r\n    # track EOA\r\n    self.lastBlock[tx.origin] = block.number\r\n\r\n    # cache, saves about 1000 gas\r\n    _vault: address = self.vault\r\n    _token: address = self.token\r\n\r\n    # Vault returns bool, so no need to use _safeTransferFrom\r\n    ERC20(_vault).transferFrom(msg.sender, self, _shares)\r\n\r\n    balBefore: uint256 = ERC20(_token).balanceOf(self)\r\n    Erc20Vault(_vault).withdraw(_shares, _min)\r\n    balAfter: uint256 = ERC20(_token).balanceOf(self)\r\n\r\n    diff: uint256 = balAfter - balBefore\r\n\r\n    self._safeTransfer(_token, msg.sender, diff)\r\n\r\n    log Withdraw(msg.sender, diff)\r\n\r\n@external\r\ndef sweep(_token: address):\r\n    \"\"\"\r\n    @notice Allow admin to claim dust and tokens that were accidentally sent\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"!admin\"\r\n    bal: uint256 = ERC20(_token).balanceOf(self)\r\n    ERC20(_token).transfer(self.admin, bal)","ABI":"[{\"name\":\"SetPause\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetWhitelist\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\",\"indexed\":true},{\"name\":\"approved\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setNextAdmin\",\"inputs\":[{\"name\":\"_nextAdmin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":36274},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claimAdmin\",\"inputs\":[],\"outputs\":[],\"gas\":56206},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setPause\",\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":37681},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setWhitelist\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":38307},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_min\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":106231},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_shares\",\"type\":\"uint256\"},{\"name\":\"_min\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":105209},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[],\"gas\":3554},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1298},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nextAdmin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1328},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1358},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vault\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1388},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1418},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"whitelist\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1663},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lastBlock\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1693}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.11","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000167e3254a9298ebf29f67e0ae0326d2018c9bc44","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":""}]}