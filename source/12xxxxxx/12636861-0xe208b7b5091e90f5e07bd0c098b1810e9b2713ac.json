{"status":"1","message":"OK","result":[{"SourceCode":"{\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor(){\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n    \\n    function _setOwner(address newOwner) internal {\\n        owner = newOwner;\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n\\n\"},\"XIVBettingFixed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./XIVInterface.sol\\\";\\n\\ncontract XIVBettingFixed is Ownable,ReentrancyGuard{\\n    \\n    using SafeMath for uint256;\\n    uint256 constant secondsInADay=24 hours;\\n    \\n    uint256 public stakeOffset;\\n    bool isValued=false;\\n    address public databaseContractAddress=0x09eD6f016178cF5Aed0bda43A7131B775042a3c6;\\n    \\n    \\n     function betFixed(uint256 amountOfXIV, uint16 typeOfBet, address _betContractAddress, uint256 betSlabeIndex) external nonReentrant{\\n        /* 0-\\u003e defi fixed, 1-\\u003e defi flexible, 2-\\u003e defi index fixed, 3-\\u003e defi index flexible, \\n        * 4-\\u003e chain coin fixed, 5-\\u003e chain coin flexible, 6-\\u003e chain index fixed, 7-\\u003e chain index flexible\\n        * 8-\\u003e NFT fixed, 9-\\u003e NFT flexible, 10-\\u003e NFT index fixed, 11-\\u003e NFT index flexible\\n        */\\n        require(typeOfBet==0 || typeOfBet==2 || typeOfBet==4 || typeOfBet==6 || typeOfBet==8 || typeOfBet==10,\\\"Invalid bet Type\\\");\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        require(!dContract.getExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress),\\\"you can\\u0027t place bet using these values.\\\");\\n        Token tokenObj = Token(dContract.getXIVTokenContractAddress());\\n        require((dContract.getBetFactorLP()).mul(dContract.getTokenStakedAmount())\\u003e=\\n                        ((tokenObj.balanceOf(databaseContractAddress)).sub(dContract.getTokenStakedAmount())).add(amountOfXIV),\\n                        \\\"Staking Vaults Have EXCEEDED CAPACITY. Please Check Back in 24hrs?\\\");\\n        require(amountOfXIV\\u003e=dContract.getMinStakeXIVAmount() \\u0026\\u0026 amountOfXIV\\u003c=dContract.getMaxStakeXIVAmount(),\\\"Please enter amount in the specified range\\\");\\n        uint256 _currentPrice;   \\n        XIVDatabaseLib.FixedInfo memory fixInfo;\\n        uint256 _coinType;\\n        if(typeOfBet==0 || typeOfBet==2){\\n            _coinType=1;\\n        }else if(typeOfBet==4 || typeOfBet==6){\\n            _coinType=2;\\n        }else if(typeOfBet==8 || typeOfBet==10){\\n            _coinType=3;\\n        }\\n        if(typeOfBet==0 || typeOfBet==4 || typeOfBet==8){\\n            require(dContract.getFixedDefiCoinArray().length\\u003ebetSlabeIndex,\\\"Day does not exists.\\\");\\n            require(dContract.getFixedMapping(_betContractAddress,_coinType).status,\\\"The currency is currently disabled.\\\");\\n            OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\\n           _currentPrice=uint256(oWObject.getPrice(dContract.getFixedMapping(_betContractAddress,_coinType).currencySymbol, dContract.getFixedMapping(_betContractAddress,_coinType).oracleType));\\n            fixInfo=dContract.getFixedDefiCoinArray()[betSlabeIndex];\\n        }else{\\n            //index Fixed \\n            require(dContract.getFixedDefiIndexArray().length\\u003ebetSlabeIndex,\\\"Day does not exists.\\\");\\n            _currentPrice=uint256(calculateIndexValueForFixedInternal(dContract.getBetId(),_coinType));\\n            fixInfo=dContract.getFixedDefiIndexArray()[betSlabeIndex];\\n        }\\n        require(checkTimeForBet(fixInfo.daysCount),\\\"Staking time closed for the selected day\\\");\\n        \\n         XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\\n                id:uint128(dContract.getBetId()),\\n                principalAmount:amountOfXIV,\\n                amount:amountOfXIV,\\n                userAddress:msg.sender,\\n                contractAddress:typeOfBet==2?address(0):_betContractAddress,\\n                betType:typeOfBet,\\n                currentPrice:_currentPrice,\\n                betTimePeriod:(uint256(fixInfo.daysCount)).mul(1 days),\\n                checkpointPercent:fixInfo.upDownPercentage,\\n                rewardFactor:fixInfo.rewardFactor,\\n                riskFactor:fixInfo.riskFactor,\\n                timestamp:block.timestamp,\\n                coinType:_coinType,\\n                status:0\\n            });\\n            dContract.updateBetArray(binfo);\\n        dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\\n        if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\\n            dContract.addUserAddressUsedForBetting(msg.sender);\\n        }\\n        dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\\n        dContract.updateBetId(dContract.getBetId().add(1));\\n        uint256 betEndTime=(((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay))).add(secondsInADay.div(2)).add(binfo.betTimePeriod).sub(1));\\n        dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\\n        \\n        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),msg.sender,databaseContractAddress,amountOfXIV);\\n        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(amountOfXIV));\\n        dContract.updateExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress,true);\\n    }\\n    function checkTimeForBet(uint256 _days) public view returns(bool){\\n        uint256 currentTime=block.timestamp;\\n        uint256 utcNoon=((currentTime.div(secondsInADay)).mul(secondsInADay)).add(secondsInADay.div(2));\\n        if(_days==1){\\n            if(((utcNoon).add(4 hours))\\u003ecurrentTime \\u0026\\u0026 utcNoon\\u003ccurrentTime){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }else if(_days==3){\\n            if(((utcNoon).add(12 hours))\\u003ecurrentTime \\u0026\\u0026 utcNoon\\u003ccurrentTime){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    function calculateIndexValueForFixedInternal(uint256 _betId,uint256 coinType) internal returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap;\\n        for(uint256 i=0;i\\u003cdContract.getAllIndexContractAddressArray(coinType).length;i++){\\n            Token tObj=Token(dContract.getAllIndexContractAddressArray(coinType)[i]);\\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getIndexMapping(dContract.getAllIndexContractAddressArray(coinType)[i],coinType);\\n            if(iCObj.status){\\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\\n                dContract.updateBetIndexArray(_betId,iCObj);\\n            }\\n        }\\n        XIVDatabaseLib.BetPriceHistory memory bPHObj=XIVDatabaseLib.BetPriceHistory({\\n            baseIndexValue:uint128(dContract.getBetBaseIndexValue(coinType)==0?10**11:dContract.getBetBaseIndexValue(coinType)),\\n            actualIndexValue:uint128(totalMarketcap)\\n        });\\n        dContract.updateBetPriceHistoryMapping(_betId,bPHObj);\\n        if(dContract.getBetBaseIndexValue(coinType)==0){\\n            dContract.updateBetBaseIndexValue(10**11,coinType);\\n        }else{\\n            if(totalMarketcap\\u003edContract.getBetActualIndexValue(coinType)){\\n                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue(coinType).add((\\n                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue(coinType)))\\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue(coinType))),coinType);\\n            }else if(totalMarketcap\\u003cdContract.getBetActualIndexValue(coinType)){\\n                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue(coinType).sub((\\n                                                     (dContract.getBetActualIndexValue(coinType).sub(totalMarketcap))\\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue(coinType))),coinType);\\n            }\\n        }\\n        dContract.updateBetActualIndexValue(totalMarketcap,coinType);\\n        return totalMarketcap;\\n    }\\n    function updateStatus(uint256[] memory offerIds) external nonReentrant{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\\n          for(uint256 i=0;i\\u003cofferIds.length;i++){ \\n            XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[offerIds[i]];\\n            if(bObject.status==0){\\n                uint256 sevenDaysTime=(((((bObject.timestamp).div(secondsInADay)).mul(secondsInADay))).add(secondsInADay.div(2)).add(bObject.betTimePeriod).sub(1));\\n                if(block.timestamp\\u003e=sevenDaysTime){\\n                    if(!isValued){\\n                        stakeOffset=stakeOffset.add(dContract.getTokenStakedAmount());\\n                        isValued=true;\\n                    }\\n                     if(bObject.betType==0 || bObject.betType==1 || bObject.betType==4 || bObject.betType==5 || bObject.betType==8 || bObject.betType==9){\\n                        // defi fixed\\n                        string memory tempSymbol;\\n                        uint256 tempOracle;\\n                        if(bObject.betType==0 || bObject.betType==4 || bObject.betType==8){\\n                            tempSymbol=dContract.getFixedMapping(bObject.contractAddress,bObject.coinType).currencySymbol;\\n                            tempOracle=dContract.getFixedMapping(bObject.contractAddress,bObject.coinType).oracleType;\\n                        }else{\\n                            tempSymbol=dContract.getFlexibleMapping(bObject.contractAddress,bObject.coinType).currencySymbol;\\n                            tempOracle=dContract.getFlexibleMapping(bObject.contractAddress,bObject.coinType).oracleType;\\n                        }\\n                        uint256 currentprice=uint256(oWObject.getPrice(tempSymbol, tempOracle));\\n                       \\n                        if(currentprice\\u003cbObject.currentPrice){\\n                            uint16 percentageValue=uint16(((bObject.currentPrice.sub(currentprice)).mul(10**4))\\n                                                    .div(bObject.currentPrice));\\n                            if(percentageValue\\u003e=bObject.checkpointPercent){\\n                                updateXIVForStakers(offerIds[i], true);\\n                            }else{\\n                                updateXIVForStakers(offerIds[i], false);\\n                            }\\n                        }else{\\n                            updateXIVForStakers(offerIds[i], false);\\n                        }\\n                    }else{\\n                        //index  \\n                      updateXIVForStakersIndex(offerIds[i]);\\n                        \\n                    }\\n                }\\n            }\\n        }\\n    }\\n    function getUserStakedAddressCount() public view returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        return dContract.getUserStakedAddress().length;\\n    }\\n    \\n    function incentiveStakers(uint256 pageNo, uint256 pageSize) external nonReentrant{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 pageStart=pageNo.mul(pageSize);\\n        uint256 pageSizeValue=(pageSize.mul(pageNo.add(1)));\\n        if(getUserStakedAddressCount()\\u003cpageSizeValue){\\n            pageSizeValue=getUserStakedAddressCount();\\n        }\\n        for(uint256 i=pageStart;i\\u003cpageSizeValue;i++){\\n            address userAddress=dContract.getUserStakedAddress()[i];\\n            uint256 updatedAmount;\\n            if(stakeOffset\\u003e0){\\n                updatedAmount=(((dContract.getTokensStaked(userAddress).mul(10**4).mul(stakeOffset))\\n                                    .div(dContract.getTokenStakedAmount().mul(10**4))));\\n            }else{\\n                updatedAmount=dContract.getTokensStaked(userAddress);\\n            }\\n            \\n            dContract.updateTokensStaked(userAddress,updatedAmount);\\n        }\\n        if(getUserStakedAddressCount()\\u003cpageSizeValue || getUserStakedAddressCount()==pageSizeValue){\\n            if(stakeOffset\\u003e0){\\n                dContract.updateTokenStakedAmount(stakeOffset);\\n            }else{\\n                dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount());\\n            }\\n            stakeOffset=0;\\n            isValued=false;\\n        }\\n    }\\n    function updateXIVForStakers(uint256 index, bool isWon) internal{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        if(isWon){\\n            bObject.status=1;\\n            uint256 rewardAmount=(uint256(bObject.rewardFactor).mul(bObject.amount)).div(10**4);\\n            stakeOffset=stakeOffset.sub(rewardAmount);\\n            bObject.amount=bObject.amount.add(rewardAmount);\\n            dContract.updateBetArrayIndex(bObject,index);\\n        }else{\\n            bObject.status=2;\\n            uint256 riskAmount=(uint256(bObject.riskFactor).mul(bObject.amount)).div(10**4);\\n            stakeOffset=stakeOffset.add(riskAmount);\\n            bObject.amount=bObject.amount.sub(riskAmount);\\n            dContract.updateBetArrayIndex(bObject,index);\\n        }\\n        dContract.updateExistingBetCheckMapping(bObject.userAddress,bObject.betType,bObject.contractAddress,false);\\n    }\\n    \\n    function getCalculateIndexValue(uint256 index) public view returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap;\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        for(uint256 i=0;i\\u003cdContract.getBetIndexArray(bObject.id).length;i++){\\n            Token tObj=Token(dContract.getBetIndexArray(bObject.id)[i].contractAddress);\\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getIndexMapping(dContract.getBetIndexArray(bObject.id)[i].contractAddress,bObject.coinType);\\n            if(iCObj.status){\\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\\n            }\\n        }\\n        return totalMarketcap;\\n    }\\n    \\n    function updateXIVForStakersIndex(uint256 index) internal{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap=getCalculateIndexValue(index);\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        if(dContract.getBetPriceHistoryMapping(bObject.id).actualIndexValue\\u003etotalMarketcap){\\n             uint16 percentageValue=uint16(((uint256(dContract.getBetPriceHistoryMapping(bObject.id).actualIndexValue)\\n                                                .sub(totalMarketcap)\\n                                                .mul(10**4)).div(dContract.getBetPriceHistoryMapping(bObject.id).actualIndexValue)));\\n            if(percentageValue\\u003e=bObject.checkpointPercent){\\n                updateXIVForStakers(index, true);\\n            }else{\\n                updateXIVForStakers(index, false);\\n            }\\n        }else{\\n            updateXIVForStakers(index, false);\\n        }\\n    }\\n    function marketCapValue(XIVDatabaseLib.IndexCoin memory iCObj,Token tObj) internal view returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\\n         if((keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked(\\\"ETH\\\"))) || (keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked(\\\"BTC\\\")))){\\n            return ((((oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\\n                                    /*    .mul(iCObj.contributionPercentage)*/)\\n                                        .div(10**2)));\\n        }else{\\n            return (((tObj.totalSupply().mul(oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\\n                                /*.mul(iCObj.contributionPercentage)*/)\\n                                .div((10**tObj.decimals()).mul(10**2))));\\n        }\\n    }\\n    \\n    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\\n        databaseContractAddress=_databaseContractAddress;\\n    }\\n}\\n\\n\"},\"XIVDatabaseLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nlibrary XIVDatabaseLib{\\n    // deficoin struct for deficoinmappings..\\n    struct DefiCoin{\\n        uint16 oracleType;\\n        bool status;\\n        string currencySymbol;\\n    }\\n    struct TimePeriod{\\n        bool status;\\n        uint64 _days;\\n    }\\n     struct FlexibleInfo{\\n        uint128 id;\\n        uint16 upDownPercentage; //10**2\\n        uint16 riskFactor;       //10**2\\n        uint16 rewardFactor;     //10**2\\n        bool status;\\n    }\\n    struct FixedInfo{\\n        uint128 id;\\n        uint64 daysCount;// integer value\\n        uint16 upDownPercentage; //10**2\\n        uint16 riskFactor;       //10**2\\n        uint16 rewardFactor;     //10**2\\n        bool status;\\n    }\\n    struct IndexCoin{\\n        uint16 oracleType;\\n        address contractAddress;\\n        bool status;\\n        string currencySymbol;\\n        uint256 contributionPercentage; //10**2\\n    }\\n    struct BetPriceHistory{\\n        uint128 baseIndexValue;\\n        uint128 actualIndexValue;\\n    }\\n    struct LPLockedInfo{\\n        uint256 lockedTimeStamp;\\n        uint256 amountLocked;\\n    }\\n    struct BetInfo{\\n        uint256 coinType;\\n        uint256 principalAmount;\\n        uint256 currentPrice;\\n        uint256 timestamp;\\n        uint256 betTimePeriod;\\n        uint256 amount;\\n        address userAddress;\\n        address contractAddress;\\n        uint128 id;\\n        uint16 betType; //\\n        uint16 checkpointPercent;\\n        uint16 rewardFactor;\\n        uint16 riskFactor;\\n        uint16 status; // 0-\\u003ebet active, 1-\\u003ebet won, 2-\\u003ebet lost, 3-\\u003e withdraw before result\\n    }\\n}\\n\\n\"},\"XIVInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./XIVDatabaseLib.sol\\\";\\n\\ninterface Token{\\n    function decimals() external view returns(uint256);\\n    function symbol() external view returns(string memory);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n}\\n\\n\\ninterface OracleWrapper{\\n    function getPrice(string calldata currencySymbol,uint256 oracleType) external view returns (uint256);\\n}\\ninterface DatabaseContract{\\n    function transferTokens(address contractAddress,address userAddress,uint256 amount) external;\\n    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external;\\n    function getTokensStaked(address userAddress) external view returns(uint256);\\n    function updateTokensStaked(address userAddress, uint256 amount) external;\\n    function getTokenStakedAmount() external view returns(uint256);\\n    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external;\\n    function getBetId() external view returns(uint256);\\n    function updateBetId(uint256 _userBetId) external;\\n    function updateBetArray(XIVDatabaseLib.BetInfo memory bObject) external;\\n    function getBetArray() external view returns(XIVDatabaseLib.BetInfo[] memory);\\n    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256);\\n    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external;\\n    function updateUserStakedAddress(address _address) external;\\n    function updateUserStakedAddress(address[] memory _userStakedAddress) external;\\n    function getUserStakedAddress() external view returns(address[] memory);\\n    function getFixedMapping(address _betContractAddress, uint256 coinType) external view returns(XIVDatabaseLib.DefiCoin memory);\\n    function getFlexibleMapping(address _betContractAddress, uint256 coinType) external view returns(XIVDatabaseLib.DefiCoin memory);\\n    function getFlexibleDefiCoinArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\\n    function getFlexibleIndexArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\\n    function updateBetArrayIndex(XIVDatabaseLib.BetInfo memory bObject, uint256 index) external;\\n    function updateBetIndexArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\\n    function updateBetBaseIndexValue(uint256 _betBaseIndexValue, uint256 coinType) external;\\n    function getBetBaseIndexValue(uint256 coinType) external view returns(uint256);\\n    function updateBetPriceHistoryMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\\n    function updateBetActualIndexValue(uint256 _betActualIndexValue, uint256 coinType) external;\\n    function getBetActualIndexValue(uint256 coinType) external view returns(uint256);\\n    function getBetIndexArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\\n    function getBetPriceHistoryMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\\n    function getXIVTokenContractAddress() external view returns(address);\\n    function getAllIndexContractAddressArray(uint256 coinType) external view returns(address[] memory);\\n    function getIndexMapping(address _ContractAddress, uint256 coinType) external view returns(XIVDatabaseLib.IndexCoin memory);\\n    \\n    function getOracleWrapperContractAddress() external view returns(address);\\n    function getPlentyOneDayPercentage() external view returns(uint256);\\n    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256);\\n    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256);\\n    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory);\\n    function updateBetAddressesArray(address userAddress, uint256 _betId) external;\\n    function addUserAddressUsedForBetting(address userAddress) external;\\n    function getUserAddressUsedForBetting() external view returns(address[] memory);\\n    function getFixedDefiCoinArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\\n    function getFixedDefiIndexArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\\n    function getMaxStakeXIVAmount() external view returns(uint256);\\n    function getMinStakeXIVAmount() external view returns(uint256);\\n    function getBetFactorLP() external view returns(uint256);\\n    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external;\\n    function getActualAmountStakedByUser(address userAddress) external view returns(uint256);\\n    function isDaysAvailable(uint256 _days) external view returns(bool);\\n    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external;\\n    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool);\\n    function updateTotalTransactions(uint256 _totalTransactions) external;\\n    function getTotalTransactions() external view returns(uint256);\\n    function getFlexibleDefiCoinTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\\n    function getFlexibleIndexTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\\n    function getMinLPvalue() external view returns(uint256);\\n    function getLockingPeriodForLPMapping(address userAddress) external view returns(XIVDatabaseLib.LPLockedInfo memory);\\n    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external;\\n    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external;\\n    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external ;\\n    function updateIsStakeMapping(address userAddress,bool isStake) external;\\n    function getIsStakeMapping(address userAddress) external view returns(bool);\\n    function getAdminAddress() external view returns(address);\\n    function getMaxLPLimit() external view returns(uint256);\\n    \\n}\\n\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOfXIV\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"typeOfBet\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_betContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"betSlabeIndex\",\"type\":\"uint256\"}],\"name\":\"betFixed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"checkTimeForBet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"databaseContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getCalculateIndexValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserStakedAddressCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pageNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"incentiveStakers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_databaseContractAddress\",\"type\":\"address\"}],\"name\":\"updateDatabaseAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"offerIds\",\"type\":\"uint256[]\"}],\"name\":\"updateStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"XIVBettingFixed","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://17dcd9e1b85d75174b69ed4ee75c049352428fea6f1bd7203fbac36b81955162"}]}