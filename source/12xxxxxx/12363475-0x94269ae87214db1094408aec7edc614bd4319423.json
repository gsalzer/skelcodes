{"status":"1","message":"OK","result":[{"SourceCode":"{\"BasicToken.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\n\\nimport \\u0027./ERC20Basic.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances. \\n */\\ncontract BasicToken is ERC20Basic {\\n  using SafeMath for uint256;\\n\\n  mapping(address =\\u003e uint256) balances;\\n\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint256 _value) public returns (bool) {\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    emit Transfer(msg.sender, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of. \\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\\n    return balances[_owner];\\n  }\\n\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\n\\nimport \\u0027./ERC20Basic.sol\\u0027;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public constant returns (uint256);\\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\\n  function approve(address spender, uint256 value) public returns (bool);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"ERC20Basic.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/179\\n */\\ncontract ERC20Basic {\\n  uint256 public totalSupply;\\n  function balanceOf(address who) public constant returns (uint256);\\n  function transfer(address to, uint256 value) public returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"},\"FavorExchangeToken.sol\":{\"content\":\"/**\\n * \\n * \\n ________                                             ________                      __                                                      ________         __                           \\n/        |                                           /        |                    /  |                                                    /        |       /  |                          \\n$$$$$$$$/______   __     __  ______    ______        $$$$$$$$/  __    __   _______ $$ |____    ______   _______    ______    ______        $$$$$$$$/______  $$ |   __   ______   _______  \\n$$ |__  /      \\\\ /  \\\\   /  |/      \\\\  /      \\\\       $$ |__    /  \\\\  /  | /       |$$      \\\\  /      \\\\ /       \\\\  /      \\\\  /      \\\\          $$ | /      \\\\ $$ |  /  | /      \\\\ /       \\\\ \\n$$    | $$$$$$  |$$  \\\\ /$$//$$$$$$  |/$$$$$$  |      $$    |   $$  \\\\/$$/ /$$$$$$$/ $$$$$$$  | $$$$$$  |$$$$$$$  |/$$$$$$  |/$$$$$$  |         $$ |/$$$$$$  |$$ |_/$$/ /$$$$$$  |$$$$$$$  |\\n$$$$$/  /    $$ | $$  /$$/ $$ |  $$ |$$ |  $$/       $$$$$/     $$  $$\\u003c  $$ |      $$ |  $$ | /    $$ |$$ |  $$ |$$ |  $$ |$$    $$ |         $$ |$$ |  $$ |$$   $$\\u003c  $$    $$ |$$ |  $$ |\\n$$ |   /$$$$$$$ |  $$ $$/  $$ \\\\__$$ |$$ |            $$ |_____  /$$$$  \\\\ $$ \\\\_____ $$ |  $$ |/$$$$$$$ |$$ |  $$ |$$ \\\\__$$ |$$$$$$$$/          $$ |$$ \\\\__$$ |$$$$$$  \\\\ $$$$$$$$/ $$ |  $$ |\\n$$ |   $$    $$ |   $$$/   $$    $$/ $$ |            $$       |/$$/ $$  |$$       |$$ |  $$ |$$    $$ |$$ |  $$ |$$    $$ |$$       |         $$ |$$    $$/ $$ | $$  |$$       |$$ |  $$ |\\n$$/     $$$$$$$/     $/     $$$$$$/  $$/             $$$$$$$$/ $$/   $$/  $$$$$$$/ $$/   $$/  $$$$$$$/ $$/   $$/  $$$$$$$ | $$$$$$$/          $$/  $$$$$$/  $$/   $$/  $$$$$$$/ $$/   $$/ \\n                                                                                                                 /  \\\\__$$ |                                                               \\n                                                                                                                 $$    $$/                                                                \\n                                                                                                                  $$$$$$/                                                                 \\n                                                                                        εɖɖίε રεĢĢίε ĵΘε\\n *\\n */\\n\\n\\npragma solidity ^0.4.26;\\n\\nimport \\\"./UpgradeableToken.sol\\\";\\nimport \\\"./ReleasableToken.sol\\\";\\nimport \\\"./MintableToken.sol\\\";\\n\\n\\n/**\\n *\\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\\n *\\n * - The token transfer() is disabled until the crowdsale is over\\n * - The token contract gives an opt-in upgrade path to a new contract\\n * - The same token can be part of several crowdsales through approve() mechanism\\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\\n *\\n */\\n\\n\\n/**\\n *\\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\\n *\\n * - The token transfer() is disabled until the crowdsale is over\\n * - The token contract gives an opt-in upgrade path to a new contract\\n * - The same token can be part of several crowdsales through approve() mechanism\\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\\n *\\n */\\ncontract FavorExchangeToken is ReleasableToken, MintableToken, UpgradeableToken {\\n\\n  /** Name and symbol were updated. */\\n  event UpdatedTokenInformation(string newName, string newSymbol);\\n  event DonationReceived(address donatee, uint256 amount);\\n\\n  string public name;\\n\\n  string public symbol;\\n\\n  uint public decimals;\\n\\n  /**\\n   * Construct the token.\\n   *\\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\\n   *\\n   * @param _name Token name\\n   * @param _symbol Token symbol - should be all caps\\n   * @param _initialSupply How many tokens we start with\\n   * @param _decimals Number of decimal places\\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\\n   * @param _favorMasterWallet Wallet tokens will be minted to and ownership of token must be set to this wallet\\n   */\\n  constructor(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, address _favorMasterWallet) public\\n    UpgradeableToken(msg.sender) {\\n\\n    // Create any address, can be transferred\\n    // to team multisig via changeOwner(),\\n    // also remember to call setUpgradeMaster()\\n    owner = msg.sender;\\n    \\n    name = _name;\\n    symbol = _symbol;\\n\\n    totalSupply = _initialSupply;\\n\\n    decimals = _decimals;\\n\\n    // Create initially all balance on the team multisig\\n    balances[_favorMasterWallet] = totalSupply;\\n\\n    if(totalSupply \\u003e 0) {\\n      emit Minted(_favorMasterWallet, totalSupply);\\n    }\\n\\n    // No more new supply allowed after the token creation\\n    if(!_mintable) {\\n      mintingFinished = true;\\n      if(totalSupply == 0) {\\n        revert(); // Cannot create a token without supply and no minting\\n      }\\n    }\\n  }\\n\\n  /**\\n   * When token is released to be transferable, enforce no new tokens can be created.\\n   */\\n  function releaseTokenTransfer() public onlyReleaseAgent {\\n    mintingFinished = true;\\n    super.releaseTokenTransfer();\\n  }\\n\\n  /**\\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\\n   */\\n  function canUpgrade() public view   returns(bool) {\\n    return released \\u0026\\u0026 super.canUpgrade();\\n  }\\n \\n  function donate() public payable {\\n    if(msg.value\\u003e0){\\n      emit DonationReceived(msg.sender, msg.value);\\n    }\\n    \\n  }\\n  /**\\n   * Owner can update token information here.\\n   *\\n   * It is often useful to conceal the actual token association, until\\n   * the token operations, like central issuance or reissuance have been completed.\\n   *\\n   * This function allows the token owner to rename the token after the operations\\n   * have been completed and then point the audience to use the token contract.\\n   */\\n  function setTokenInformation(string _name, string _symbol) public onlyOwner {\\n    name = _name;\\n    symbol = _symbol;\\n\\n    emit UpdatedTokenInformation(name, symbol);\\n  }\\n\\n}\\n\"},\"MintableToken.sol\":{\"content\":\"/**\\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\\n *\\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\\n */\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./StandardTokenExt.sol\\\";\\nimport \\\"./SafeMathLib.sol\\\";\\n\\npragma solidity ^0.4.6;\\n\\n/**\\n * A token that can increase its supply by another contract.\\n *\\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\\n *\\n */\\ncontract MintableToken is StandardTokenExt {\\n\\n  using SafeMathLib for uint;\\n\\n  bool public mintingFinished = false;\\n\\n  /** List of agents that are allowed to create new tokens */\\n  mapping (address =\\u003e bool) public mintAgents;\\n\\n  event MintingAgentChanged(address addr, bool state);\\n  event Minted(address receiver, uint amount);\\n\\n  /**\\n   * Create new tokens and allocate them to an address..\\n   *\\n   * Only callably by a crowdsale contract (mint agent).\\n   */\\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\\n    totalSupply = totalSupply.plus(amount);\\n    balances[receiver] = balances[receiver].plus(amount);\\n\\n    // This will make the mint transaction apper in EtherScan.io\\n    // We can remove this after there is a standardized minting event\\n    emit Transfer(0, receiver, amount);\\n  }\\n\\n  /**\\n   * Owner can allow a crowdsale contract to mint new tokens.\\n   */\\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\\n    mintAgents[addr] = state;\\n    emit MintingAgentChanged(addr, state);\\n  }\\n\\n  modifier onlyMintAgent() {\\n    // Only crowdsale contracts are allowed to mint new tokens\\n    if(!mintAgents[msg.sender]) {\\n        revert();\\n    }\\n    _;\\n  }\\n\\n  /** Make sure we are not done yet. */\\n  modifier canMint() {\\n    if(mintingFinished) revert();\\n    _;\\n  }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(owner, newOwner);\\n    owner = newOwner;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipRenounced(owner);\\n    owner = address(0);\\n  }\\n}\\n\"},\"Recoverable.sol\":{\"content\":\"/**\\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\\n *\\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\\n */\\n\\npragma solidity ^0.4.12;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC20Basic.sol\\\";\\n\\ncontract Recoverable is Ownable {\\n\\n  /// @dev Empty constructor (for now)\\n  constructor() public {\\n  }\\n\\n  /// @dev This will be invoked by the owner, when owner wants to rescue tokens\\n  /// @param token Token which will we rescue to the owner from the contract\\n  function recoverTokens(ERC20Basic token) onlyOwner public {\\n    token.transfer(owner, tokensToBeReturned(token));\\n  }\\n\\n  /// @dev Interface function, can be overwritten by the superclass\\n  /// @param token Token which balance we will check and return\\n  /// @return The amount of tokens (in smallest denominator) the contract owns\\n  function tokensToBeReturned(ERC20Basic token) public view returns (uint) {\\n    return token.balanceOf(this);\\n  }\\n}\\n\"},\"ReleasableToken.sol\":{\"content\":\"/**\\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\\n *\\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\\n */\\n\\npragma solidity ^0.4.8;\\n\\nimport \\\"./StandardTokenExt.sol\\\";\\n\\n\\n/**\\n * Define interface for releasing the token transfer after a successful crowdsale.\\n */\\ncontract ReleasableToken is StandardTokenExt {\\n\\n  /* The finalizer contract that allows unlift the transfer limits on this token */\\n  address public releaseAgent;\\n\\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\\n  bool public released = false;\\n\\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\\n  mapping (address =\\u003e bool) public transferAgents;\\n\\n  /**\\n   * Limit token transfer until the crowdsale is over.\\n   *\\n   */\\n  modifier canTransfer(address _sender) {\\n\\n    if(!released) {\\n        if(!transferAgents[_sender]) {\\n            revert();\\n        }\\n    }\\n\\n    _;\\n  }\\n\\n  /**\\n   * Set the contract that can call release and make the token transferable.\\n   *\\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\\n   */\\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\\n\\n    // We don\\u0027t do interface check here as we might want to a normal wallet address to act as a release agent\\n    releaseAgent = addr;\\n  }\\n\\n  /**\\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\\n   */\\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\\n    transferAgents[addr] = state;\\n  }\\n\\n  /**\\n   * One way function to release the tokens to the wild.\\n   *\\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\\n   */\\n  function releaseTokenTransfer() public onlyReleaseAgent {\\n    released = true;\\n  }\\n\\n  /** The function can be called only before or after the tokens have been releasesd */\\n  modifier inReleaseState(bool releaseState) {\\n    if(releaseState != released) {\\n        revert();\\n    }\\n    _;\\n  }\\n\\n  /** The function can be called only by a whitelisted release agent. */\\n  modifier onlyReleaseAgent() {\\n    if(msg.sender != releaseAgent) {\\n        revert();\\n    }\\n    _;\\n  }\\n\\n  function transfer(address _to, uint _value) public canTransfer(msg.sender) returns (bool success) {\\n    // Call StandardToken.transfer()\\n   return super.transfer(_to, _value);\\n  }\\n\\n  function transferFrom(address _from, address _to, uint _value) public canTransfer(_from) returns (bool success) {\\n    // Call StandardToken.transferForm()\\n    return super.transferFrom(_from, _to, _value);\\n  }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"},\"SafeMathLib.sol\":{\"content\":\"/**\\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\\n *\\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\\n */\\n\\npragma solidity ^0.4.6;\\n\\n/**\\n * Safe unsigned safe math.\\n *\\n * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\\n *\\n * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\\n *\\n * Maintained here until merged to mainline zeppelin-solidity.\\n *\\n */\\nlibrary SafeMathLib {\\n\\n  function times(uint a, uint b) internal pure returns (uint) {\\n    uint c = a * b;\\n    assert(a == 0 || c / a == b);\\n    return c;\\n  }\\n\\n  function minus(uint a, uint b) internal pure returns (uint) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  function plus(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c\\u003e=a);\\n    return c;\\n  }\\n\\n}\\n\"},\"StandardToken.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\n\\nimport \\u0027./BasicToken.sol\\u0027;\\nimport \\u0027./ERC20.sol\\u0027;\\n\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * @dev https://github.com/ethereum/EIPs/issues/20\\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken {\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\n\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint256 the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\n    uint256 _allowance = allowed[_from][msg.sender];\\n\\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\\n    // require (_value \\u003c= _allowance);\\n\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint256 _value) public returns (bool) {\\n\\n    // To change the approve amount you first have to reduce the addresses`\\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\\n    //  already 0 to mitigate the race condition described here:\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\\n\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return A uint256 specifing the amount of tokens still available for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n\\n}\\n\"},\"StandardTokenExt.sol\":{\"content\":\"/**\\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\\n *\\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\\n */\\n\\npragma solidity ^0.4.14;\\n\\nimport \\\"./StandardToken.sol\\\";\\nimport \\\"./Recoverable.sol\\\";\\n\\n\\n/**\\n * Standard EIP-20 token with an interface marker.\\n *\\n * @notice Interface marker is used by crowdsale contracts to validate that addresses point a good token contract.\\n *\\n */\\ncontract StandardTokenExt is StandardToken, Recoverable {\\n\\n  /* Interface declaration */\\n  function isToken() public pure returns (bool weAre) {\\n    return true;\\n  }\\n}\\n\"},\"UpgradeableToken.sol\":{\"content\":\"/**\\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\\n *\\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\\n */\\n\\npragma solidity ^0.4.8;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./StandardTokenExt.sol\\\";\\nimport \\\"./UpgradeAgent.sol\\\";\\n\\n/**\\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\\n *\\n * First envisioned by Golem and Lunyr projects.\\n */\\ncontract UpgradeableToken is StandardTokenExt {\\n\\n  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\\n  address public upgradeMaster;\\n\\n  /** The next contract where the tokens will be migrated. */\\n  UpgradeAgent public upgradeAgent;\\n\\n  /** How many tokens we have upgraded by now. */\\n  uint256 public totalUpgraded;\\n\\n  /**\\n   * Upgrade states.\\n   *\\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\\n   * - WaitingForAgent: Token allows upgrade, but we don\\u0027t have a new agent yet\\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\\n   *\\n   */\\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\\n\\n  /**\\n   * Somebody has upgraded some of his tokens.\\n   */\\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\\n\\n  /**\\n   * New upgrade agent available.\\n   */\\n  event UpgradeAgentSet(address agent);\\n\\n  /**\\n   * Do not allow construction without upgrade master set.\\n   */\\n  constructor(address _upgradeMaster) public {\\n    upgradeMaster = _upgradeMaster;\\n  }\\n\\n  /**\\n   * Allow the token holder to upgrade some of their tokens to a new contract.\\n   */\\n  function upgrade(uint256 value) public {\\n\\n      UpgradeState state = getUpgradeState();\\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\\n        // Called in a bad state\\n        revert();\\n      }\\n\\n      // Validate input value.\\n      if (value == 0) revert();\\n\\n      balances[msg.sender] = balances[msg.sender].sub(value);\\n\\n      // Take tokens out from circulation\\n      totalSupply = totalSupply.sub(value);\\n      totalUpgraded = totalUpgraded.add(value);\\n\\n      // Upgrade agent reissues the tokens\\n      upgradeAgent.upgradeFrom(msg.sender, value);\\n      emit Upgrade(msg.sender, upgradeAgent, value);\\n  }\\n\\n  /**\\n   * Set an upgrade agent that handles\\n   */\\n  function setUpgradeAgent(address agent) external {\\n\\n      if(!canUpgrade()) {\\n        // The token is not yet in a state that we could think upgrading\\n        revert();\\n      }\\n\\n      if (agent == 0x0) revert();\\n      // Only a master can designate the next agent\\n      if (msg.sender != upgradeMaster) revert();\\n      // Upgrade has already begun for an agent\\n      if (getUpgradeState() == UpgradeState.Upgrading) revert();\\n\\n      upgradeAgent = UpgradeAgent(agent);\\n\\n      // Bad interface\\n      if(!upgradeAgent.isUpgradeAgent()) revert();\\n      // Make sure that token supplies match in source and target\\n      if (upgradeAgent.originalSupply() != totalSupply) revert();\\n\\n      emit UpgradeAgentSet(upgradeAgent);\\n  }\\n\\n  /**\\n   * Get the state of the token upgrade.\\n   */\\n  function getUpgradeState() public constant returns(UpgradeState) {\\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\\n    else return UpgradeState.Upgrading;\\n  }\\n\\n  /**\\n   * Change the upgrade master.\\n   *\\n   * This allows us to set a new owner for the upgrade mechanism.\\n   */\\n  function setUpgradeMaster(address master) public {\\n      if (master == 0x0) revert();\\n      if (msg.sender != upgradeMaster) revert();\\n      upgradeMaster = master;\\n  }\\n\\n  /**\\n   * Child contract can enable to provide the condition when the upgrade can begun.\\n   */\\n  function canUpgrade() public view  returns(bool) {\\n     return true;\\n  }\\n\\n}\\n\"},\"UpgradeAgent.sol\":{\"content\":\"/**\\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\\n *\\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\\n */\\n\\npragma solidity ^0.4.6;\\n\\n/**\\n * Upgrade agent interface inspired by Lunyr.\\n *\\n * Upgrade agent transfers tokens to a new contract.\\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\\n */\\ncontract UpgradeAgent {\\n\\n  uint public originalSupply;\\n\\n  /** Interface marker */\\n  function isUpgradeAgent() public pure returns (bool) {\\n    return true;\\n  }\\n\\n  function upgradeFrom(address _from, uint256 _value) public;\\n\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setTransferAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setReleaseAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setMintAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setTokenInformation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUpgradeState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"released\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokensToBeReturned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isToken\",\"outputs\":[{\"name\":\"weAre\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint256\"},{\"name\":\"_mintable\",\"type\":\"bool\"},{\"name\":\"_favorMasterWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"UpdatedTokenInformation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"donatee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonationReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"MintingAgentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"FavorExchangeToken","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000026c62ad77dc602dae000000000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f6fa2a0fa387f7ef9592f97a38b558c461682e8000000000000000000000000000000000000000000000000000000000000001a4661766f722045786368616e676520546f6b656e20284645582900000000000000000000000000000000000000000000000000000000000000000000000000034645580000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9978f7cea5f96898c055e8f9ed4c270fdc4d0407f1c336c2287a98e674f1139a"}]}