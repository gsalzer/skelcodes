{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/libs/RollupUtils.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\npragma experimental ABIEncoderV2;\\n\\nimport { Types } from \\\"./Types.sol\\\";\\n\\nlibrary RollupUtils {\\n    // ---------- Account Related Utils -------------------\\n    function PDALeafToHash(Types.PDALeaf memory _PDA_Leaf)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(_PDA_Leaf.pubkey));\\n    }\\n\\n    // returns a new User Account with updated balance\\n    function UpdateBalanceInAccount(\\n        Types.UserAccount memory original_account,\\n        uint256 new_balance\\n    ) public pure returns (Types.UserAccount memory updated_account) {\\n        original_account.balance = new_balance;\\n        return original_account;\\n    }\\n\\n    function BalanceFromAccount(Types.UserAccount memory account)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return account.balance;\\n    }\\n\\n    // AccountFromBytes decodes the bytes to account\\n    function AccountFromBytes(bytes memory accountBytes)\\n        public\\n        pure\\n        returns (\\n            uint256 ID,\\n            uint256 balance,\\n            uint256 nonce,\\n            uint256 tokenType\\n        )\\n    {\\n        return abi.decode(accountBytes, (uint256, uint256, uint256, uint256));\\n    }\\n\\n    //\\n    // BytesFromAccount and BytesFromAccountDeconstructed do the same thing i.e encode account to bytes\\n    //\\n    function BytesFromAccount(Types.UserAccount memory account)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory data = abi.encodePacked(\\n            account.ID,\\n            account.balance,\\n            account.nonce,\\n            account.tokenType\\n        );\\n\\n        return data;\\n    }\\n\\n    function BytesFromAccountDeconstructed(\\n        uint256 ID,\\n        uint256 balance,\\n        uint256 nonce,\\n        uint256 tokenType\\n    ) public pure returns (bytes memory) {\\n        return abi.encodePacked(ID, balance, nonce, tokenType);\\n    }\\n\\n    //\\n    // HashFromAccount and getAccountHash do the same thing i.e hash account\\n    //\\n    function getAccountHash(\\n        uint256 id,\\n        uint256 balance,\\n        uint256 nonce,\\n        uint256 tokenType\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                BytesFromAccountDeconstructed(id, balance, nonce, tokenType)\\n            );\\n    }\\n\\n    function HashFromAccount(Types.UserAccount memory account)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                BytesFromAccountDeconstructed(\\n                    account.ID,\\n                    account.balance,\\n                    account.nonce,\\n                    account.tokenType\\n                )\\n            );\\n    }\\n\\n    // ---------- Tx Related Utils -------------------\\n    function CompressTx(Types.Transaction memory _tx)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encode(_tx.fromIndex, _tx.toIndex, _tx.amount, _tx.signature);\\n    }\\n\\n    function DecompressTx(bytes memory txBytes)\\n        public\\n        pure\\n        returns (\\n            uint256 from,\\n            uint256 to,\\n            uint256 nonce,\\n            bytes memory sig\\n        )\\n    {\\n        return abi.decode(txBytes, (uint256, uint256, uint256, bytes));\\n    }\\n\\n    function CompressTxWithMessage(bytes memory message, bytes memory sig)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        Types.Transaction memory _tx = TxFromBytes(message);\\n        return abi.encode(_tx.fromIndex, _tx.toIndex, _tx.amount, sig);\\n    }\\n\\n    // Decoding transaction from bytes\\n    function TxFromBytesDeconstructed(bytes memory txBytes)\\n        public\\n        pure\\n        returns (\\n            uint256 from,\\n            uint256 to,\\n            uint256 tokenType,\\n            uint256 nonce,\\n            uint256 txType,\\n            uint256 amount\\n        )\\n    {\\n        return\\n            abi.decode(\\n                txBytes,\\n                (uint256, uint256, uint256, uint256, uint256, uint256)\\n            );\\n    }\\n\\n    function TxFromBytes(bytes memory txBytes)\\n        public\\n        pure\\n        returns (Types.Transaction memory)\\n    {\\n        Types.Transaction memory transaction;\\n        (\\n            transaction.fromIndex,\\n            transaction.toIndex,\\n            transaction.tokenType,\\n            transaction.nonce,\\n            transaction.txType,\\n            transaction.amount\\n        ) = abi.decode(\\n            txBytes,\\n            (uint256, uint256, uint256, uint256, uint256, uint256)\\n        );\\n        return transaction;\\n    }\\n\\n    //\\n    // BytesFromTx and BytesFromTxDeconstructed do the same thing i.e encode transaction to bytes\\n    //\\n    function BytesFromTx(Types.Transaction memory _tx)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodePacked(\\n                _tx.fromIndex,\\n                _tx.toIndex,\\n                _tx.tokenType,\\n                _tx.nonce,\\n                _tx.txType,\\n                _tx.amount\\n            );\\n    }\\n\\n    function BytesFromTxDeconstructed(\\n        uint256 from,\\n        uint256 to,\\n        uint256 tokenType,\\n        uint256 nonce,\\n        uint256 txType,\\n        uint256 amount\\n    ) public pure returns (bytes memory) {\\n        return abi.encodePacked(from, to, tokenType, nonce, txType, amount);\\n    }\\n\\n    //\\n    // HashFromTx and getTxSignBytes do the same thing i.e get the tx data to be signed\\n    //\\n    function HashFromTx(Types.Transaction memory _tx)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                BytesFromTxDeconstructed(\\n                    _tx.fromIndex,\\n                    _tx.toIndex,\\n                    _tx.tokenType,\\n                    _tx.nonce,\\n                    _tx.txType,\\n                    _tx.amount\\n                )\\n            );\\n    }\\n\\n    function getTxSignBytes(\\n        uint256 fromIndex,\\n        uint256 toIndex,\\n        uint256 tokenType,\\n        uint256 txType,\\n        uint256 nonce,\\n        uint256 amount\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                BytesFromTxDeconstructed(\\n                    fromIndex,\\n                    toIndex,\\n                    tokenType,\\n                    nonce,\\n                    txType,\\n                    amount\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the address from the pubkey\\n     * @param pub is the pubkey\\n     * @return Returns the address that has been calculated from the pubkey\\n     */\\n    function calculateAddress(bytes memory pub)\\n        public\\n        pure\\n        returns (address addr)\\n    {\\n        bytes32 hash = keccak256(pub);\\n        assembly {\\n            mstore(0, hash)\\n            addr := mload(0)\\n        }\\n    }\\n\\n    function GetGenesisLeaves() public view returns (bytes32[2] memory leaves) {\\n        Types.UserAccount memory account1 = Types.UserAccount({\\n            ID: 0,\\n            tokenType: 0,\\n            balance: 0,\\n            nonce: 0\\n        });\\n        Types.UserAccount memory account2 = Types.UserAccount({\\n            ID: 1,\\n            tokenType: 0,\\n            balance: 0,\\n            nonce: 0\\n        });\\n        leaves[0] = HashFromAccount(account1);\\n        leaves[1] = HashFromAccount(account2);\\n    }\\n\\n    function GetGenesisDataBlocks()\\n        public\\n        view\\n        returns (bytes[2] memory dataBlocks)\\n    {\\n        Types.UserAccount memory account1 = Types.UserAccount({\\n            ID: 0,\\n            tokenType: 0,\\n            balance: 0,\\n            nonce: 0\\n        });\\n        Types.UserAccount memory account2 = Types.UserAccount({\\n            ID: 1,\\n            tokenType: 0,\\n            balance: 0,\\n            nonce: 0\\n        });\\n        dataBlocks[0] = BytesFromAccount(account1);\\n        dataBlocks[1] = BytesFromAccount(account2);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/Types.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.15;\\n\\n/**\\n * @title DataTypes\\n */\\nlibrary Types {\\n    // We define Usage for a batch or for a tx\\n    // to check if the usage of a batch and all txs in it are the same\\n    enum Usage {\\n        Genesis, // The Genesis type is only applicable to batch but not tx\\n        Transfer,\\n        Deposit\\n    }\\n    // PDALeaf represents the leaf in\\n    // Pubkey DataAvailability Tree\\n    struct PDALeaf {\\n        bytes pubkey;\\n    }\\n\\n    // Batch represents the batch submitted periodically to the ethereum chain\\n    struct Batch {\\n        bytes32 stateRoot;\\n        bytes32 accountRoot;\\n        bytes32 depositTree;\\n        address committer;\\n        bytes32 txRoot;\\n        uint256 stakeCommitted;\\n        uint256 finalisesOn;\\n        uint256 timestamp;\\n        Usage batchType;\\n    }\\n\\n    // Transaction represents how each transaction looks like for\\n    // this rollup chain\\n    struct Transaction {\\n        uint256 fromIndex;\\n        uint256 toIndex;\\n        uint256 tokenType;\\n        uint256 nonce;\\n        uint256 txType;\\n        uint256 amount;\\n        bytes signature;\\n    }\\n\\n    // AccountInclusionProof consists of the following fields\\n    // 1. Path to the account leaf from root in the balances tree\\n    // 2. Actual data stored in the leaf\\n    struct AccountInclusionProof {\\n        uint256 pathToAccount;\\n        UserAccount account;\\n    }\\n\\n    struct TranasctionInclusionProof {\\n        uint256 pathToTx;\\n        Transaction data;\\n    }\\n\\n    struct PDAInclusionProof {\\n        uint256 pathToPubkey;\\n        PDALeaf pubkey_leaf;\\n    }\\n\\n    // UserAccount contains the actual data stored in the leaf of balance tree\\n    struct UserAccount {\\n        // ID is the path to the pubkey in the PDA tree\\n        uint256 ID;\\n        uint256 tokenType;\\n        uint256 balance;\\n        uint256 nonce;\\n    }\\n\\n    struct AccountMerkleProof {\\n        AccountInclusionProof accountIP;\\n        bytes32[] siblings;\\n    }\\n\\n    struct AccountProofs {\\n        AccountMerkleProof from;\\n        AccountMerkleProof to;\\n    }\\n\\n    struct BatchValidationProofs {\\n        AccountProofs[] accountProofs;\\n        PDAMerkleProof[] pdaProof;\\n    }\\n\\n    struct TransactionMerkleProof {\\n        TranasctionInclusionProof _tx;\\n        bytes32[] siblings;\\n    }\\n\\n    struct PDAMerkleProof {\\n        PDAInclusionProof _pda;\\n        bytes32[] siblings;\\n    }\\n\\n    enum ErrorCode {\\n        NoError,\\n        InvalidTokenAddress,\\n        InvalidTokenAmount,\\n        NotEnoughTokenBalance,\\n        BadFromTokenType,\\n        BadToTokenType\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"accountBytes\",\"type\":\"bytes\"}],\"name\":\"AccountFromBytes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"}],\"name\":\"BalanceFromAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"}],\"name\":\"BytesFromAccount\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"BytesFromAccountDeconstructed\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Transaction\",\"name\":\"_tx\",\"type\":\"tuple\"}],\"name\":\"BytesFromTx\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BytesFromTxDeconstructed\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Transaction\",\"name\":\"_tx\",\"type\":\"tuple\"}],\"name\":\"CompressTx\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"CompressTxWithMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txBytes\",\"type\":\"bytes\"}],\"name\":\"DecompressTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetGenesisDataBlocks\",\"outputs\":[{\"internalType\":\"bytes[2]\",\"name\":\"dataBlocks\",\"type\":\"bytes[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetGenesisLeaves\",\"outputs\":[{\"internalType\":\"bytes32[2]\",\"name\":\"leaves\",\"type\":\"bytes32[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"account\",\"type\":\"tuple\"}],\"name\":\"HashFromAccount\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Transaction\",\"name\":\"_tx\",\"type\":\"tuple\"}],\"name\":\"HashFromTx\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.PDALeaf\",\"name\":\"_PDA_Leaf\",\"type\":\"tuple\"}],\"name\":\"PDALeafToHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txBytes\",\"type\":\"bytes\"}],\"name\":\"TxFromBytes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.Transaction\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"txBytes\",\"type\":\"bytes\"}],\"name\":\"TxFromBytesDeconstructed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"original_account\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"new_balance\",\"type\":\"uint256\"}],\"name\":\"UpdateBalanceInAccount\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.UserAccount\",\"name\":\"updated_account\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"pub\",\"type\":\"bytes\"}],\"name\":\"calculateAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getAccountHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTxSignBytes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"RollupUtils","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}