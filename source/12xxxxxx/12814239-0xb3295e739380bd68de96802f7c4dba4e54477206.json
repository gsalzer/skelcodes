{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/YVaultAssetProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// WARNING: This has been validated for yearn vaults up to version 0.2.11.\\n// Using this code with any later version can be unsafe.\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IYearnVault.sol\\\";\\nimport \\\"./WrappedPosition.sol\\\";\\n\\n/// @author Element Finance\\n/// @title Yearn Vault v1 Asset Proxy\\ncontract YVaultAssetProxy is WrappedPosition {\\n    IYearnVault public immutable vault;\\n    uint8 public immutable vaultDecimals;\\n\\n    // This contract allows deposits to a reserve which can\\n    // be used to short circuit the deposit process and save gas\\n\\n    // The following mapping tracks those non-transferable deposits\\n    mapping(address => uint256) public reserveBalances;\\n    // These variables store the token balances of this contract and\\n    // should be packed by solidity into a single slot.\\n    uint128 public reserveUnderlying;\\n    uint128 public reserveShares;\\n    // This is the total amount of reserve deposits\\n    uint256 public reserveSupply;\\n\\n    /// @notice Constructs this contract and stores needed data\\n    /// @param vault_ The yearn v2 vault\\n    /// @param _token The underlying token.\\n    ///               This token should revert in the event of a transfer failure.\\n    /// @param _name The name of the token created\\n    /// @param _symbol The symbol of the token created\\n    constructor(\\n        address vault_,\\n        IERC20 _token,\\n        string memory _name,\\n        string memory _symbol\\n    ) WrappedPosition(_token, _name, _symbol) {\\n        vault = IYearnVault(vault_);\\n        _token.approve(vault_, type(uint256).max);\\n        uint8 localVaultDecimals = IERC20(vault_).decimals();\\n        vaultDecimals = localVaultDecimals;\\n        require(\\n            uint8(_token.decimals()) == localVaultDecimals,\\n            \\\"Inconsistent decimals\\\"\\n        );\\n        // We check that this is a compatible yearn version\\n        _versionCheck(IYearnVault(vault_));\\n    }\\n\\n    /// @notice An override-able version checking function, reverts if the vault has the wrong version\\n    /// @param _vault The yearn vault address\\n    /// @dev This function can be overridden by an inheriting upgrade contract\\n    function _versionCheck(IYearnVault _vault) internal virtual view {\\n        string memory apiVersion = _vault.apiVersion();\\n        require(\\n            _stringEq(apiVersion, \\\"0.3.0\\\") ||\\n                _stringEq(apiVersion, \\\"0.3.1\\\") ||\\n                _stringEq(apiVersion, \\\"0.3.2\\\") ||\\n                _stringEq(apiVersion, \\\"0.3.3\\\") ||\\n                _stringEq(apiVersion, \\\"0.3.4\\\") ||\\n                _stringEq(apiVersion, \\\"0.3.5\\\"),\\n            \\\"Unsupported Version\\\"\\n        );\\n    }\\n\\n    /// @notice checks if two strings are equal\\n    /// @param s1 string one\\n    /// @param s2 string two\\n    /// @return bool whether they are equal\\n    function _stringEq(string memory s1, string memory s2)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        bytes32 h1 = keccak256(abi.encodePacked(s1));\\n        bytes32 h2 = keccak256(abi.encodePacked(s2));\\n        return (h1 == h2);\\n    }\\n\\n    /// @notice This function allows a user to deposit to the reserve\\n    ///      Note - there's no incentive to do so. You could earn some\\n    ///      interest but less interest than yearn. All deposits use\\n    ///      the underlying token.\\n    /// @param _amount The amount of underlying to deposit\\n    function reserveDeposit(uint256 _amount) external {\\n        // Transfer from user, note variable 'token' is the immutable\\n        // inherited from the abstract WrappedPosition contract.\\n        token.transferFrom(msg.sender, address(this), _amount);\\n        // Load the reserves\\n        (uint256 localUnderlying, uint256 localShares) = _getReserves();\\n        // Calculate the total reserve value\\n        uint256 totalValue = localUnderlying;\\n        totalValue += _yearnDepositConverter(localShares, true);\\n        // If this is the first deposit we need different logic\\n        uint256 localReserveSupply = reserveSupply;\\n        uint256 mintAmount;\\n        if (localReserveSupply == 0) {\\n            // If this is the first mint the tokens are exactly the supplied underlying\\n            mintAmount = _amount;\\n        } else {\\n            // Otherwise we mint the proportion that this increases the value held by this contract\\n            mintAmount = (localReserveSupply * _amount) / totalValue;\\n        }\\n\\n        // This hack means that the contract will never have zero balance of underlying\\n        // which levels the gas expenditure of the transfer to this contract. Permanently locks\\n        // the smallest possible unit of the underlying.\\n        if (localUnderlying == 0 && localShares == 0) {\\n            _amount -= 1;\\n        }\\n        // Set the reserves that this contract has more underlying\\n        _setReserves(localUnderlying + _amount, localShares);\\n        // Note that the sender has deposited and increase reserveSupply\\n        reserveBalances[msg.sender] += mintAmount;\\n        reserveSupply = localReserveSupply + mintAmount;\\n    }\\n\\n    /// @notice This function allows a holder of reserve balance to withdraw their share\\n    /// @param _amount The number of reserve shares to withdraw\\n    function reserveWithdraw(uint256 _amount) external {\\n        // Remove 'amount' from the balances of the sender. Because this is 8.0 it will revert on underflow\\n        reserveBalances[msg.sender] -= _amount;\\n        // We load the reserves\\n        (uint256 localUnderlying, uint256 localShares) = _getReserves();\\n        uint256 localReserveSupply = reserveSupply;\\n        // Then we calculate the proportion of the shares to redeem\\n        uint256 userShares = (localShares * _amount) / localReserveSupply;\\n        // First we withdraw the proportion of shares tokens belonging to the caller\\n        uint256 freedUnderlying = vault.withdraw(userShares, address(this), 0);\\n        // We calculate the amount of underlying to send\\n        uint256 userUnderlying = (localUnderlying * _amount) /\\n            localReserveSupply;\\n\\n        // We then store the updated reserve amounts\\n        _setReserves(\\n            localUnderlying - userUnderlying,\\n            localShares - userShares\\n        );\\n        // We note a reduction in local supply\\n        reserveSupply = localReserveSupply - _amount;\\n\\n        // We send the redemption underlying to the caller\\n        // Note 'token' is an immutable from shares\\n        token.transfer(msg.sender, freedUnderlying + userUnderlying);\\n    }\\n\\n    /// @notice Makes the actual deposit into the yearn vault\\n    ///         Tries to use the local balances before depositing\\n    /// @return Tuple (the shares minted, amount underlying used)\\n    function _deposit() internal override returns (uint256, uint256) {\\n        //Load reserves\\n        (uint256 localUnderlying, uint256 localShares) = _getReserves();\\n        // Get the amount deposited\\n        uint256 amount = token.balanceOf(address(this)) - localUnderlying;\\n        // fixing for the fact there's an extra underlying\\n        if (localUnderlying != 0 || localShares != 0) {\\n            amount -= 1;\\n        }\\n        // Calculate the amount of shares the amount deposited is worth\\n        uint256 neededShares = _yearnDepositConverter(amount, false);\\n\\n        // If we have enough in local reserves we don't call out for deposits\\n        if (localShares > neededShares) {\\n            // We set the reserves\\n            _setReserves(localUnderlying + amount, localShares - neededShares);\\n            // And then we short circuit execution and return\\n            return (neededShares, amount);\\n        }\\n        // Deposit and get the shares that were minted to this\\n        uint256 shares = vault.deposit(localUnderlying + amount, address(this));\\n\\n        // calculate the user share\\n        uint256 userShare = (amount * shares) / (localUnderlying + amount);\\n\\n        // We set the reserves\\n        _setReserves(0, localShares + shares - userShare);\\n        // Return the amount of shares the user has produced, and the amount used for it.\\n        return (userShare, amount);\\n    }\\n\\n    /// @notice Withdraw the number of shares and will short circuit if it can\\n    /// @param _shares The number of shares to withdraw\\n    /// @param _destination The address to send the output funds\\n    /// @param _underlyingPerShare The possibly precomputed underlying per share\\n    function _withdraw(\\n        uint256 _shares,\\n        address _destination,\\n        uint256 _underlyingPerShare\\n    ) internal override returns (uint256) {\\n        // If we do not have it we load the price per share\\n        if (_underlyingPerShare == 0) {\\n            _underlyingPerShare = _pricePerShare();\\n        }\\n        // We load the reserves\\n        (uint256 localUnderlying, uint256 localShares) = _getReserves();\\n        // Calculate the amount of shares the amount deposited is worth\\n        uint256 needed = (_shares * _pricePerShare()) / (10**vaultDecimals);\\n        // If we have enough underlying we don't have to actually withdraw\\n        if (needed < localUnderlying) {\\n            // We set the reserves to be the new reserves\\n            _setReserves(localUnderlying - needed, localShares + _shares);\\n            // Then transfer needed underlying to the destination\\n            // 'token' is an immutable in WrappedPosition\\n            token.transfer(_destination, needed);\\n            // Short circuit and return\\n            return (needed);\\n        }\\n        // If we don't have enough local reserves we do the actual withdraw\\n        // Withdraws shares from the vault. Max loss is set at 100% as\\n        // the minimum output value is enforced by the calling\\n        // function in the WrappedPosition contract.\\n        uint256 amountReceived = vault.withdraw(\\n            _shares + localShares,\\n            address(this),\\n            10000\\n        );\\n\\n        // calculate the user share\\n        uint256 userShare = (_shares * amountReceived) /\\n            (localShares + _shares);\\n\\n        _setReserves(localUnderlying + amountReceived - userShare, 0);\\n        // Transfer the underlying to the destination 'token' is an immutable in WrappedPosition\\n        token.transfer(_destination, userShare);\\n        // Return the amount of underlying\\n        return userShare;\\n    }\\n\\n    /// @notice Get the underlying amount of tokens per shares given\\n    /// @param _amount The amount of shares you want to know the value of\\n    /// @return Value of shares in underlying token\\n    function _underlying(uint256 _amount)\\n        internal\\n        override\\n        view\\n        returns (uint256)\\n    {\\n        return (_amount * _pricePerShare()) / (10**vaultDecimals);\\n    }\\n\\n    /// @notice Get the price per share in the vault\\n    /// @return The price per share in units of underlying;\\n    function _pricePerShare() internal view returns (uint256) {\\n        return vault.pricePerShare();\\n    }\\n\\n    /// @notice Function to reset approvals for the proxy\\n    function approve() external {\\n        token.approve(address(vault), 0);\\n        token.approve(address(vault), type(uint256).max);\\n    }\\n\\n    /// @notice Helper to get the reserves with one sload\\n    /// @return Tuple (reserve underlying, reserve shares)\\n    function _getReserves() internal view returns (uint256, uint256) {\\n        return (uint256(reserveUnderlying), uint256(reserveShares));\\n    }\\n\\n    /// @notice Helper to set reserves using one sstore\\n    /// @param _newReserveUnderlying The new reserve of underlying\\n    /// @param _newReserveShares The new reserve of wrapped position shares\\n    function _setReserves(\\n        uint256 _newReserveUnderlying,\\n        uint256 _newReserveShares\\n    ) internal {\\n        reserveUnderlying = uint128(_newReserveUnderlying);\\n        reserveShares = uint128(_newReserveShares);\\n    }\\n\\n    /// @notice Converts an input of shares to it's output of underlying or an input\\n    ///      of underlying to an output of shares, using yearn 's deposit pricing\\n    /// @param amount the amount of input, shares if 'sharesIn == true' underlying if not\\n    /// @param sharesIn true to convert from yearn shares to underlying, false to convert from\\n    ///                 underlying to yearn shares\\n    /// @dev WARNING - In yearn 0.3.1 - 0.3.5 this is an exact match for deposit logic\\n    ///                but not withdraw logic in versions 0.3.2-0.3.5. In versions 0.4.0+\\n    ///                it is not a match for yearn deposit ratios.\\n    /// @return The converted output of either underlying or yearn shares\\n    function _yearnDepositConverter(uint256 amount, bool sharesIn)\\n        internal\\n        virtual\\n        view\\n        returns (uint256)\\n    {\\n        // Load the yearn total supply and assets\\n        uint256 yearnTotalSupply = vault.totalSupply();\\n        uint256 yearnTotalAssets = vault.totalAssets();\\n        // If we are converted shares to underlying\\n        if (sharesIn) {\\n            // then we get the fraction of yearn shares this is and multiply by assets\\n            return (yearnTotalAssets * amount) / yearnTotalSupply;\\n        } else {\\n            // otherwise we figure out the faction of yearn assets this is and see how\\n            // many assets we get out.\\n            return (yearnTotalSupply * amount) / yearnTotalAssets;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\\n    function decimals() external view returns (uint8);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IYearnVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IYearnVault is IERC20 {\\n    function deposit(uint256, address) external returns (uint256);\\n\\n    function withdraw(\\n        uint256,\\n        address,\\n        uint256\\n    ) external returns (uint256);\\n\\n    // Returns the amount of underlying per each unit [1e18] of yearn shares\\n    function pricePerShare() external view returns (uint256);\\n\\n    function governance() external view returns (address);\\n\\n    function setDepositLimit(uint256) external;\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function totalAssets() external view returns (uint256);\\n\\n    function apiVersion() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/WrappedPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./interfaces/IWrappedPosition.sol\\\";\\n\\nimport \\\"./libraries/ERC20Permit.sol\\\";\\n\\n/// @author Element Finance\\n/// @title Wrapped Position Core\\nabstract contract WrappedPosition is ERC20Permit, IWrappedPosition {\\n    IERC20 public immutable override token;\\n\\n    /// @notice Constructs this contract\\n    /// @param _token The underlying token.\\n    ///               This token should revert in the event of a transfer failure.\\n    /// @param _name the name of this contract\\n    /// @param _symbol the symbol for this contract\\n    constructor(\\n        IERC20 _token,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20Permit(_name, _symbol) {\\n        token = _token;\\n        // We set our decimals to be the same as the underlying\\n        _setupDecimals(_token.decimals());\\n    }\\n\\n    /// We expect that the following logic will be present in an integration implementation\\n    /// which inherits from this contract\\n\\n    /// @dev Makes the actual deposit into the 'vault'\\n    /// @return Tuple (shares minted, amount underlying used)\\n    function _deposit() internal virtual returns (uint256, uint256);\\n\\n    /// @dev Makes the actual withdraw from the 'vault'\\n    /// @return returns the amount produced\\n    function _withdraw(\\n        uint256,\\n        address,\\n        uint256\\n    ) internal virtual returns (uint256);\\n\\n    /// @dev Converts between an internal balance representation\\n    ///      and underlying tokens.\\n    /// @return The amount of underlying the input is worth\\n    function _underlying(uint256) internal virtual view returns (uint256);\\n\\n    /// @notice Get the underlying balance of an address\\n    /// @param _who The address to query\\n    /// @return The underlying token balance of the address\\n    function balanceOfUnderlying(address _who)\\n        external\\n        override\\n        view\\n        returns (uint256)\\n    {\\n        return _underlying(balanceOf[_who]);\\n    }\\n\\n    /// @notice Returns the amount of the underlying asset a certain amount of shares is worth\\n    /// @param _shares Shares to calculate underlying value for\\n    /// @return The value of underlying assets for the given shares\\n    function getSharesToUnderlying(uint256 _shares)\\n        external\\n        override\\n        view\\n        returns (uint256)\\n    {\\n        return _underlying(_shares);\\n    }\\n\\n    /// @notice Entry point to deposit tokens into the Wrapped Position contract\\n    ///         Transfers tokens on behalf of caller so the caller must set\\n    ///         allowance on the contract prior to call.\\n    /// @param _amount The amount of underlying tokens to deposit\\n    /// @param _destination The address to mint to\\n    /// @return Returns the number of Wrapped Position tokens minted\\n    function deposit(address _destination, uint256 _amount)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        // Send tokens to the proxy\\n        token.transferFrom(msg.sender, address(this), _amount);\\n        // Calls our internal deposit function\\n        (uint256 shares, ) = _deposit();\\n        // Mint them internal ERC20 tokens corresponding to the deposit\\n        _mint(_destination, shares);\\n        return shares;\\n    }\\n\\n    /// @notice Entry point to deposit tokens into the Wrapped Position contract\\n    ///         Assumes the tokens were transferred before this was called\\n    /// @param _destination the destination of this deposit\\n    /// @return Returns (WP tokens minted, used underlying,\\n    ///                  senders WP balance before mint)\\n    /// @dev WARNING - The call which funds this method MUST be in the same transaction\\n    //                 as the call to this method or you risk loss of funds\\n    function prefundedDeposit(address _destination)\\n        external\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Calls our internal deposit function\\n        (uint256 shares, uint256 usedUnderlying) = _deposit();\\n\\n        uint256 balanceBefore = balanceOf[_destination];\\n\\n        // Mint them internal ERC20 tokens corresponding to the deposit\\n        _mint(_destination, shares);\\n        return (shares, usedUnderlying, balanceBefore);\\n    }\\n\\n    /// @notice Exit point to withdraw tokens from the Wrapped Position contract\\n    /// @param _destination The address which is credited with tokens\\n    /// @param _shares The amount of shares the user is burning to withdraw underlying\\n    /// @param _minUnderlying The min output the caller expects\\n    /// @return The amount of underlying transferred to the destination\\n    function withdraw(\\n        address _destination,\\n        uint256 _shares,\\n        uint256 _minUnderlying\\n    ) public override returns (uint256) {\\n        return _positionWithdraw(_destination, _shares, _minUnderlying, 0);\\n    }\\n\\n    /// @notice This function burns enough tokens from the sender to send _amount\\n    ///          of underlying to the _destination.\\n    /// @param _destination The address to send the output to\\n    /// @param _amount The amount of underlying to try to redeem for\\n    /// @param _minUnderlying The minium underlying to receive\\n    /// @return The amount of underlying released, and shares used\\n    function withdrawUnderlying(\\n        address _destination,\\n        uint256 _amount,\\n        uint256 _minUnderlying\\n    ) external override returns (uint256, uint256) {\\n        // First we load the number of underlying per unit of Wrapped Position token\\n        uint256 oneUnit = 10**decimals;\\n        uint256 underlyingPerShare = _underlying(oneUnit);\\n        // Then we calculate the number of shares we need\\n        uint256 shares = (_amount * oneUnit) / underlyingPerShare;\\n        // Using this we call the normal withdraw function\\n        uint256 underlyingReceived = _positionWithdraw(\\n            _destination,\\n            shares,\\n            _minUnderlying,\\n            underlyingPerShare\\n        );\\n        return (underlyingReceived, shares);\\n    }\\n\\n    /// @notice This internal function allows the caller to provide a precomputed 'underlyingPerShare'\\n    ///         so that we can avoid calling it again in the internal function\\n    /// @param _destination The destination to send the output to\\n    /// @param _shares The number of shares to withdraw\\n    /// @param _minUnderlying The min amount of output to produce\\n    /// @param _underlyingPerShare The precomputed shares per underlying\\n    /// @return The amount of underlying released\\n    function _positionWithdraw(\\n        address _destination,\\n        uint256 _shares,\\n        uint256 _minUnderlying,\\n        uint256 _underlyingPerShare\\n    ) internal returns (uint256) {\\n        // Burn users shares\\n        _burn(msg.sender, _shares);\\n\\n        // Withdraw that many shares from the vault\\n        uint256 withdrawAmount = _withdraw(\\n            _shares,\\n            _destination,\\n            _underlyingPerShare\\n        );\\n\\n        // We revert if this call doesn't produce enough underlying\\n        // This security feature is useful in some edge cases\\n        require(withdrawAmount >= _minUnderlying, \\\"Not enough underlying\\\");\\n        return withdrawAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWrappedPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWrappedPosition is IERC20Permit {\\n    function token() external view returns (IERC20);\\n\\n    function balanceOfUnderlying(address who) external view returns (uint256);\\n\\n    function getSharesToUnderlying(uint256 shares)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function deposit(address sender, uint256 amount) external returns (uint256);\\n\\n    function withdraw(\\n        address sender,\\n        uint256 _shares,\\n        uint256 _minUnderlying\\n    ) external returns (uint256);\\n\\n    function withdrawUnderlying(\\n        address _destination,\\n        uint256 _amount,\\n        uint256 _minUnderlying\\n    ) external returns (uint256, uint256);\\n\\n    function prefundedDeposit(address _destination)\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\n\\n// This default erc20 library is designed for max efficiency and security.\\n// WARNING: By default it does not include totalSupply which breaks the ERC20 standard\\n//          to use a fully standard compliant ERC20 use 'ERC20PermitWithSupply\\\"\\nabstract contract ERC20Permit is IERC20Permit {\\n    // --- ERC20 Data ---\\n    // The name of the erc20 token\\n    string public name;\\n    // The symbol of the erc20 token\\n    string public override symbol;\\n    // The decimals of the erc20 token, should default to 18 for new tokens\\n    uint8 public override decimals;\\n\\n    // A mapping which tracks user token balances\\n    mapping(address => uint256) public override balanceOf;\\n    // A mapping which tracks which addresses a user allows to move their tokens\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n    // A mapping which tracks the permit signature nonces for users\\n    mapping(address => uint256) public override nonces;\\n\\n    // --- EIP712 niceties ---\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 public override DOMAIN_SEPARATOR;\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32\\n        public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @notice Initializes the erc20 contract\\n    /// @param name_ the value 'name' will be set to\\n    /// @param symbol_ the value 'symbol' will be set to\\n    /// @dev decimals default to 18 and must be reset by an inheriting contract for\\n    ///      non standard decimal values\\n    constructor(string memory name_, string memory symbol_) {\\n        // Set the state variables\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = 18;\\n\\n        // By setting these addresses to 0 attempting to execute a transfer to\\n        // either of them will revert. This is a gas efficient way to prevent\\n        // a common user mistake where they transfer to the token address.\\n        // These values are not considered 'real' tokens and so are not included\\n        // in 'total supply' which only contains minted tokens.\\n        balanceOf[address(0)] = type(uint256).max;\\n        balanceOf[address(this)] = type(uint256).max;\\n\\n        // Optional extra state manipulation\\n        _extraConstruction();\\n\\n        // Computes the EIP 712 domain separator which prevents user signed messages for\\n        // this contract to be replayed in other contracts.\\n        // https://eips.ethereum.org/EIPS/eip-712\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @notice An optional override function to execute and change state before immutable assignment\\n    function _extraConstruction() internal virtual {}\\n\\n    // --- Token ---\\n    /// @notice Allows a token owner to send tokens to another address\\n    /// @param recipient The address which will be credited with the tokens\\n    /// @param amount The amount user token to send\\n    /// @return returns true on success, reverts on failure so cannot return false.\\n    /// @dev transfers to this contract address or 0 will fail\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        // We forward this call to 'transferFrom'\\n        return transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    /// @notice Transfers an amount of erc20 from a spender to a receipt\\n    /// @param spender The source of the ERC20 tokens\\n    /// @param recipient The destination of the ERC20 tokens\\n    /// @param amount the number of tokens to send\\n    /// @return returns true on success and reverts on failure\\n    /// @dev will fail transfers which send funds to this contract or 0\\n    function transferFrom(\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        // Load balance and allowance\\n        uint256 balance = balanceOf[spender];\\n        require(balance >= amount, \\\"ERC20: insufficient-balance\\\");\\n        // We potentially have to change allowances\\n        if (spender != msg.sender) {\\n            // Loading the allowance in the if block prevents vanilla transfers\\n            // from paying for the sload.\\n            uint256 allowed = allowance[spender][msg.sender];\\n            // If the allowance is max we do not reduce it\\n            // Note - This means that max allowances will be more gas efficient\\n            // by not requiring a sstore on 'transferFrom'\\n            if (allowed != type(uint256).max) {\\n                require(allowed >= amount, \\\"ERC20: insufficient-allowance\\\");\\n                allowance[spender][msg.sender] = allowed - amount;\\n            }\\n        }\\n        // Update the balances\\n        balanceOf[spender] = balance - amount;\\n        // Note - In the constructor we initialize the 'balanceOf' of address 0 and\\n        //        the token address to uint256.max and so in 8.0 transfers to those\\n        //        addresses revert on this step.\\n        balanceOf[recipient] = balanceOf[recipient] + amount;\\n        // Emit the needed event\\n        emit Transfer(spender, recipient, amount);\\n        // Return that this call succeeded\\n        return true;\\n    }\\n\\n    /// @notice This internal minting function allows inheriting contracts\\n    ///         to mint tokens in the way they wish.\\n    /// @param account the address which will receive the token.\\n    /// @param amount the amount of token which they will receive\\n    /// @dev This function is virtual so that it can be overridden, if you\\n    ///      are reviewing this contract for security you should ensure to\\n    ///      check for overrides\\n    function _mint(address account, uint256 amount) internal virtual {\\n        // Add tokens to the account\\n        balanceOf[account] = balanceOf[account] + amount;\\n        // Emit an event to track the minting\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /// @notice This internal burning function allows inheriting contracts to\\n    ///         burn tokens in the way they see fit.\\n    /// @param account the account to remove tokens from\\n    /// @param amount  the amount of tokens to remove\\n    /// @dev This function is virtual so that it can be overridden, if you\\n    ///      are reviewing this contract for security you should ensure to\\n    ///      check for overrides\\n    function _burn(address account, uint256 amount) internal virtual {\\n        // Reduce the balance of the account\\n        balanceOf[account] = balanceOf[account] - amount;\\n        // Emit an event tracking transfers\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /// @notice This function allows a user to approve an account which can transfer\\n    ///         tokens on their behalf.\\n    /// @param account The account which will be approve to transfer tokens\\n    /// @param amount The approval amount, if set to uint256.max the allowance does not go down on transfers.\\n    /// @return returns true for compatibility with the ERC20 standard\\n    function approve(address account, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        // Set the senders allowance for account to amount\\n        allowance[msg.sender][account] = amount;\\n        // Emit an event to track approvals\\n        emit Approval(msg.sender, account, amount);\\n        return true;\\n    }\\n\\n    /// @notice This function allows a caller who is not the owner of an account to execute the functionality of 'approve' with the owners signature.\\n    /// @param owner the owner of the account which is having the new approval set\\n    /// @param spender the address which will be allowed to spend owner's tokens\\n    /// @param value the new allowance value\\n    /// @param deadline the timestamp which the signature must be submitted by to be valid\\n    /// @param v Extra ECDSA data which allows public key recovery from signature assumed to be 27 or 28\\n    /// @param r The r component of the ECDSA signature\\n    /// @param s The s component of the ECDSA signature\\n    /// @dev The signature for this function follows EIP 712 standard and should be generated with the\\n    ///      eth_signTypedData JSON RPC call instead of the eth_sign JSON RPC call. If using out of date\\n    ///      parity signing libraries the v component may need to be adjusted. Also it is very rare but possible\\n    ///      for v to be other values, those values are not supported.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        // The EIP 712 digest for this function\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner],\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        // Require that the owner is not zero\\n        require(owner != address(0), \\\"ERC20: invalid-address-0\\\");\\n        // Require that we have a valid signature from the owner\\n        require(owner == ecrecover(digest, v, r, s), \\\"ERC20: invalid-permit\\\");\\n        // Require that the signature is not expired\\n        require(\\n            deadline == 0 || block.timestamp <= deadline,\\n            \\\"ERC20: permit-expired\\\"\\n        );\\n        // Format the signature to the default format\\n        require(\\n            uint256(s) <=\\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ERC20: invalid signature 's' value\\\"\\n        );\\n        // Increment the signature nonce to prevent replay\\n        nonces[owner]++;\\n        // Set the allowance to the new value\\n        allowance[owner][spender] = value;\\n        // Emit an approval event to be able to track this happening\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /// @notice Internal function which allows inheriting contract to set custom decimals\\n    /// @param decimals_ the new decimal value\\n    function _setupDecimals(uint8 decimals_) internal {\\n        // Set the decimals\\n        decimals = decimals_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// Forked from openzepplin\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 7500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"getSharesToUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"prefundedDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reserveBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"reserveDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveShares\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveUnderlying\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"reserveWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IYearnVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minUnderlying\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minUnderlying\",\"type\":\"uint256\"}],\"name\":\"withdrawUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"YVaultAssetProxy","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"7500","ConstructorArguments":"000000000000000000000000dcd90c7f6324cfa40d7169ef80b12031770b432500000000000000000000000006325440d014e39736583c165c2963ba99faf14e000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012656c656d656e7420797663727653544554480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a7976637276535445544800000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}