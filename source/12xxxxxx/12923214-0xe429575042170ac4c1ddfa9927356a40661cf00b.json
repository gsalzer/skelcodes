{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC1820Registry {\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\r\n    function setManager(address _addr, address _newManager) external;\r\n    function getManager(address _addr) public view returns (address);\r\n}\r\n\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC1820Client {\r\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC1820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\ncontract ERC1820Implementer {\r\n  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\r\n\r\n  mapping(bytes32 => bool) internal _interfaceHashes;\r\n\r\n  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\r\n    external\r\n    view\r\n    returns(bytes32)\r\n  {\r\n    if(_interfaceHashes[interfaceHash]) {\r\n      return ERC1820_ACCEPT_MAGIC;\r\n    } else {\r\n      return \"\";\r\n    }\r\n  }\r\n\r\n  function _setInterface(string memory interfaceLabel) internal {\r\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n/**\r\n * @title MinterRole\r\n * @dev Minters are responsible for minting new tokens.\r\n */\r\ncontract MinterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () internal {\r\n        _addMinter(msg.sender);\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function removeMinter(address account) public onlyMinter {\r\n        _removeMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(msg.sender);\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400 security token standard\r\n * @dev See https://github.com/SecurityTokenStandard/EIP-Spec/blob/master/eip/eip-1400.md\r\n */\r\ninterface IERC1400 /*is IERC20*/ { // Interfaces can currently not inherit interfaces, but IERC1400 shall include IERC20\r\n\r\n  // ****************** Document Management *******************\r\n  function getDocument(bytes32 name) external view returns (string memory, bytes32);\r\n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\r\n\r\n  // ******************* Token Information ********************\r\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256);\r\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory);\r\n\r\n  // *********************** Transfers ************************\r\n  function transferWithData(address to, uint256 value, bytes calldata data) external;\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external;\r\n\r\n  // *************** Partition Token Transfers ****************\r\n  function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32);\r\n  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\r\n\r\n  // ****************** Controller Operation ******************\r\n  function isControllable() external view returns (bool);\r\n  // function controllerTransfer(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorTransferByPartition\"\r\n  // function controllerRedeem(address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorRedeemByPartition\"\r\n\r\n  // ****************** Operator Management *******************\r\n  function authorizeOperator(address operator) external;\r\n  function revokeOperator(address operator) external;\r\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external;\r\n  function revokeOperatorByPartition(bytes32 partition, address operator) external;\r\n\r\n  // ****************** Operator Information ******************\r\n  function isOperator(address operator, address tokenHolder) external view returns (bool);\r\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool);\r\n\r\n  // ********************* Token Issuance *********************\r\n  function isIssuable() external view returns (bool);\r\n  function issue(address tokenHolder, uint256 value, bytes calldata data) external;\r\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external;\r\n\r\n  // ******************** Token Redemption ********************\r\n  function redeem(uint256 value, bytes calldata data) external;\r\n  function redeemFrom(address tokenHolder, uint256 value, bytes calldata data) external;\r\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external;\r\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData) external;\r\n\r\n  // ******************* Transfer Validity ********************\r\n  // We use different transfer validity functions because those described in the interface don't allow to verify the certificate's validity.\r\n  // Indeed, verifying the ecrtificate's validity requires to keeps the function's arguments in the exact same order as the transfer function.\r\n  //\r\n  // function canTransfer(address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\r\n  // function canTransferFrom(address from, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\r\n  // function canTransferByPartition(address from, address to, bytes32 partition, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32);    \r\n\r\n  // ******************* Controller Events ********************\r\n  // We don't use this event as we don't use \"controllerTransfer\"\r\n  //   event ControllerTransfer(\r\n  //       address controller,\r\n  //       address indexed from,\r\n  //       address indexed to,\r\n  //       uint256 value,\r\n  //       bytes data,\r\n  //       bytes operatorData\r\n  //   );\r\n  //\r\n  // We don't use this event as we don't use \"controllerRedeem\"\r\n  //   event ControllerRedemption(\r\n  //       address controller,\r\n  //       address indexed tokenHolder,\r\n  //       uint256 value,\r\n  //       bytes data,\r\n  //       bytes operatorData\r\n  //   );\r\n\r\n  // ******************** Document Events *********************\r\n  event Document(bytes32 indexed name, string uri, bytes32 documentHash);\r\n\r\n  // ******************** Transfer Events *********************\r\n  event TransferByPartition(\r\n      bytes32 indexed fromPartition,\r\n      address operator,\r\n      address indexed from,\r\n      address indexed to,\r\n      uint256 value,\r\n      bytes data,\r\n      bytes operatorData\r\n  );\r\n\r\n  event ChangedPartition(\r\n      bytes32 indexed fromPartition,\r\n      bytes32 indexed toPartition,\r\n      uint256 value\r\n  );\r\n\r\n  // ******************** Operator Events *********************\r\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n  event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n  // ************** Issuance / Redemption Events **************\r\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data);\r\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data);\r\n  event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n  event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes operatorData);\r\n\r\n}\r\n\r\n/**\r\n * Reason codes - ERC-1066\r\n *\r\n * To improve the token holder experience, canTransfer MUST return a reason byte code\r\n * on success or failure based on the ERC-1066 application-specific status codes specified below.\r\n * An implementation can also return arbitrary data as a bytes32 to provide additional\r\n * information not captured by the reason code.\r\n * \r\n * Code\tReason\r\n * 0x50\ttransfer failure\r\n * 0x51\ttransfer success\r\n * 0x52\tinsufficient balance\r\n * 0x53\tinsufficient allowance\r\n * 0x54\ttransfers halted (contract paused)\r\n * 0x55\tfunds locked (lockup period)\r\n * 0x56\tinvalid sender\r\n * 0x57\tinvalid receiver\r\n * 0x58\tinvalid operator (transfer agent)\r\n * 0x59\t\r\n * 0x5a\t\r\n * 0x5b\t\r\n * 0x5a\t\r\n * 0x5b\t\r\n * 0x5c\t\r\n * 0x5d\t\r\n * 0x5e\t\r\n * 0x5f\ttoken meta or info\r\n *\r\n * These codes are being discussed at: https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283/24\r\n */\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensValidator\r\n * @dev ERC1400TokensValidator interface\r\n */\r\ninterface IERC1400TokensValidator {\r\n\r\n  function canValidate(\r\n    address token,\r\n    bytes calldata payload,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensToValidate(\r\n    bytes calldata payload,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensChecker\r\n * @dev IERC1400TokensChecker interface\r\n */\r\ninterface IERC1400TokensChecker {\r\n\r\n  // function canTransfer(\r\n  //   bytes calldata payload,\r\n  //   address operator,\r\n  //   address from,\r\n  //   address to,\r\n  //   uint256 value,\r\n  //   bytes calldata data,\r\n  //   bytes calldata operatorData\r\n  // ) external view returns (byte, bytes32);\r\n\r\n  function canTransferByPartition(\r\n    bytes calldata payload,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n    ) external view returns (byte, bytes32, bytes32);\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensSender\r\n * @dev ERC1400TokensSender interface\r\n */\r\ninterface IERC1400TokensSender {\r\n\r\n  function canTransfer(\r\n    bytes calldata payload,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensToTransfer(\r\n    bytes calldata payload,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensRecipient\r\n * @dev ERC1400TokensRecipient interface\r\n */\r\ninterface IERC1400TokensRecipient {\r\n\r\n  function canReceive(\r\n    bytes calldata payload,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensReceived(\r\n    bytes calldata payload,\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Extensions\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1400\r\n * @dev ERC1400 logic\r\n */\r\ncontract ERC1400 is IERC20, IERC1400, Ownable, ERC1820Client, ERC1820Implementer, MinterRole {\r\n  using SafeMath for uint256;\r\n\r\n  // Token\r\n  string constant internal ERC1400_INTERFACE_NAME = \"ERC1400Token\";\r\n  string constant internal ERC20_INTERFACE_NAME = \"ERC20Token\";\r\n\r\n  // Token extensions\r\n  string constant internal ERC1400_TOKENS_CHECKER = \"ERC1400TokensChecker\";\r\n  string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\r\n\r\n  // User extensions\r\n  string constant internal ERC1400_TOKENS_SENDER = \"ERC1400TokensSender\";\r\n  string constant internal ERC1400_TOKENS_RECIPIENT = \"ERC1400TokensRecipient\";\r\n\r\n  /************************************* Token description ****************************************/\r\n  string internal _name;\r\n  string internal _symbol;\r\n  uint256 internal _granularity;\r\n  uint256 internal _totalSupply;\r\n  bool internal _migrated;\r\n  /************************************************************************************************/\r\n\r\n\r\n  /**************************************** Token behaviours **************************************/\r\n  // Indicate whether the token can still be controlled by operators or not anymore.\r\n  bool internal _isControllable;\r\n\r\n  // Indicate whether the token can still be issued by the issuer or not anymore.\r\n  bool internal _isIssuable;\r\n  /************************************************************************************************/\r\n\r\n\r\n  /********************************** ERC20 Token mappings ****************************************/\r\n  // Mapping from tokenHolder to balance.\r\n  mapping(address => uint256) internal _balances;\r\n\r\n  // Mapping from (tokenHolder, spender) to allowed value.\r\n  mapping (address => mapping (address => uint256)) internal _allowed;\r\n  /************************************************************************************************/\r\n\r\n\r\n  /**************************************** Documents *********************************************/\r\n  struct Doc {\r\n    string docURI;\r\n    bytes32 docHash;\r\n  }\r\n  // Mapping for token URIs.\r\n  mapping(bytes32 => Doc) internal _documents;\r\n  /************************************************************************************************/\r\n\r\n\r\n  /*********************************** Partitions  mappings ***************************************/\r\n  // List of partitions.\r\n  bytes32[] internal _totalPartitions;\r\n\r\n  // Mapping from partition to their index.\r\n  mapping (bytes32 => uint256) internal _indexOfTotalPartitions;\r\n\r\n  // Mapping from partition to global balance of corresponding partition.\r\n  mapping (bytes32 => uint256) internal _totalSupplyByPartition;\r\n\r\n  // Mapping from tokenHolder to their partitions.\r\n  mapping (address => bytes32[]) internal _partitionsOf;\r\n\r\n  // Mapping from (tokenHolder, partition) to their index.\r\n  mapping (address => mapping (bytes32 => uint256)) internal _indexOfPartitionsOf;\r\n\r\n  // Mapping from (tokenHolder, partition) to balance of corresponding partition.\r\n  mapping (address => mapping (bytes32 => uint256)) internal _balanceOfByPartition;\r\n\r\n  // List of token default partitions (for ERC20 compatibility).\r\n  bytes32[] internal _defaultPartitions;\r\n  /************************************************************************************************/\r\n\r\n\r\n  /********************************* Global operators mappings ************************************/\r\n  // Mapping from (operator, tokenHolder) to authorized status. [TOKEN-HOLDER-SPECIFIC]\r\n  mapping(address => mapping(address => bool)) internal _authorizedOperator;\r\n\r\n  // Array of controllers. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\r\n  address[] internal _controllers;\r\n\r\n  // Mapping from operator to controller status. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping(address => bool) internal _isController;\r\n  /************************************************************************************************/\r\n\r\n\r\n  /******************************** Partition operators mappings **********************************/\r\n  // Mapping from (partition, tokenHolder, spender) to allowed value. [TOKEN-HOLDER-SPECIFIC]\r\n  mapping(bytes32 => mapping (address => mapping (address => uint256))) internal _allowedByPartition;\r\n\r\n  // Mapping from (tokenHolder, partition, operator) to 'approved for partition' status. [TOKEN-HOLDER-SPECIFIC]\r\n  mapping (address => mapping (bytes32 => mapping (address => bool))) internal _authorizedOperatorByPartition;\r\n\r\n  // Mapping from partition to controllers for the partition. [NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping (bytes32 => address[]) internal _controllersByPartition;\r\n\r\n  // Mapping from (partition, operator) to PartitionController status. [NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping (bytes32 => mapping (address => bool)) internal _isControllerByPartition;\r\n  /************************************************************************************************/\r\n\r\n\r\n  /***************************************** Modifiers ********************************************/\r\n  /**\r\n   * @dev Modifier to verify if token is issuable.\r\n   */\r\n  modifier isIssuableToken() {\r\n    require(_isIssuable, \"55\"); // 0x55\tfunds locked (lockup period)\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not migrated.\r\n   */\r\n  modifier isNotMigratedToken() {\r\n      require(!_migrated, \"54\"); // 0x54\ttransfers halted (contract paused)\r\n      _;\r\n  }\r\n  /**\r\n   * @dev Modifier to verifiy if sender is a minter.\r\n   */\r\n  modifier onlyMinter() {\r\n      require(isMinter(msg.sender) || isOwner());\r\n      _;\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /**************************** Events (additional - not mandatory) *******************************/\r\n  event ApprovalByPartition(bytes32 indexed partition, address indexed owner, address indexed spender, uint256 value);\r\n  /************************************************************************************************/\r\n\r\n\r\n  /**\r\n   * @dev Initialize ERC1400 + register the contract implementation in ERC1820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param defaultPartitions Partitions chosen by default, when partition is\r\n   * not specified, like the case ERC20 tranfers.\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    bytes32[] memory defaultPartitions\r\n  )\r\n    public\r\n  {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _totalSupply = 0;\r\n    require(granularity >= 1); // Constructor Blocked - Token granularity can not be lower than 1\r\n    _granularity = granularity;\r\n\r\n    _setControllers(controllers);\r\n\r\n    _defaultPartitions = defaultPartitions;\r\n\r\n    _isControllable = true;\r\n    _isIssuable = true;\r\n\r\n    // Register contract in ERC1820 registry\r\n    ERC1820Client.setInterfaceImplementation(ERC1400_INTERFACE_NAME, address(this));\r\n    ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, address(this));\r\n\r\n    // Indicate token verifies ERC1400 and ERC20 interfaces\r\n    ERC1820Implementer._setInterface(ERC1400_INTERFACE_NAME); // For migration\r\n    ERC1820Implementer._setInterface(ERC20_INTERFACE_NAME); // For migration\r\n  }\r\n\r\n\r\n  /************************************************************************************************/\r\n  /****************************** EXTERNAL FUNCTIONS (ERC20 INTERFACE) ****************************/\r\n  /************************************************************************************************/\r\n\r\n\r\n  /**\r\n   * @dev Get the total number of issued tokens.\r\n   * @return Total supply of tokens currently in circulation.\r\n   */\r\n  function totalSupply() external view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n  /**\r\n   * @dev Get the balance of the account with address 'tokenHolder'.\r\n   * @param tokenHolder Address for which the balance is returned.\r\n   * @return Amount of token held by 'tokenHolder' in the token contract.\r\n   */\r\n  function balanceOf(address tokenHolder) external view returns (uint256) {\r\n    return _balances[tokenHolder];\r\n  }\r\n  /**\r\n   * @dev Transfer token for a specified address.\r\n   * @param to The address to transfer to.\r\n   * @param value The value to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function transfer(address to, uint256 value) external returns (bool) {\r\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, \"\");\r\n    return true;\r\n  }\r\n  /**\r\n   * @dev Check the value of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the value of tokens still available for the spender.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256) {\r\n    return _allowed[owner][spender];\r\n  }\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function approve(address spender, uint256 value) external returns (bool) {\r\n    require(spender != address(0), \"56\"); // 0x56\tinvalid sender\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n  /**\r\n   * @dev Transfer tokens from one address to another.\r\n   * @param from The address which you want to transfer tokens from.\r\n   * @param to The address which you want to transfer to.\r\n   * @param value The amount of tokens to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool) {\r\n    require( _isOperator(msg.sender, from)\r\n      || (value <= _allowed[from][msg.sender]), \"53\"); // 0x53\tinsufficient allowance\r\n\r\n    if(_allowed[from][msg.sender] >= value) {\r\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    } else {\r\n      _allowed[from][msg.sender] = 0;\r\n    }\r\n\r\n    _transferByDefaultPartitions(msg.sender, from, to, value, \"\");\r\n    return true;\r\n  }\r\n\r\n\r\n  /************************************************************************************************/\r\n  /****************************** EXTERNAL FUNCTIONS (ERC1400 INTERFACE) **************************/\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************* Document Management **************************************/\r\n  /**\r\n   * @dev Access a document associated with the token.\r\n   * @param name Short name (represented as a bytes32) associated to the document.\r\n   * @return Requested document + document hash.\r\n   */\r\n  function getDocument(bytes32 name) external view returns (string memory, bytes32) {\r\n    require(bytes(_documents[name].docURI).length != 0); // Action Blocked - Empty document\r\n    return (\r\n      _documents[name].docURI,\r\n      _documents[name].docHash\r\n    );\r\n  }\r\n  /**\r\n   * @dev Associate a document with the token.\r\n   * @param name Short name (represented as a bytes32) associated to the document.\r\n   * @param uri Document content.\r\n   * @param documentHash Hash of the document [optional parameter].\r\n   */\r\n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external {\r\n    require(_isController[msg.sender]);\r\n    _documents[name] = Doc({\r\n      docURI: uri,\r\n      docHash: documentHash\r\n    });\r\n    emit Document(name, uri, documentHash);\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************** Token Information ***************************************/\r\n  /**\r\n   * @dev Get balance of a tokenholder for a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which the balance is returned.\r\n   * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\r\n   */\r\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256) {\r\n    return _balanceOfByPartition[tokenHolder][partition];\r\n  }\r\n  /**\r\n   * @dev Get partitions index of a tokenholder.\r\n   * @param tokenHolder Address for which the partitions index are returned.\r\n   * @return Array of partitions index of 'tokenHolder'.\r\n   */\r\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory) {\r\n    return _partitionsOf[tokenHolder];\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /****************************************** Transfers *******************************************/\r\n  /**\r\n   * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder.\r\n   */\r\n  function transferWithData(address to, uint256 value, bytes calldata data) external {\r\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, data);\r\n  }\r\n  /**\r\n   * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\r\n   * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from').\r\n   */\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external {\r\n    require(_isOperator(msg.sender, from), \"58\"); // 0x58\tinvalid operator (transfer agent)\r\n\r\n    _transferByDefaultPartitions(msg.sender, from, to, value, data);\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /********************************** Partition Token Transfers ***********************************/\r\n  /**\r\n   * @dev Transfer tokens from a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder.\r\n   * @return Destination partition.\r\n   */\r\n  function transferByPartition(\r\n    bytes32 partition,\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  )\r\n    external\r\n    returns (bytes32)\r\n  {\r\n    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, \"\");\r\n  }\r\n  /**\r\n   * @dev Transfer tokens from a specific partition through an operator.\r\n   * @param partition Name of the partition.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator.\r\n   * @return Destination partition.\r\n   */\r\n  function operatorTransferByPartition(\r\n    bytes32 partition,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  )\r\n    external\r\n    returns (bytes32)\r\n  {\r\n    require(_isOperatorForPartition(partition, msg.sender, from)\r\n      || (value <= _allowedByPartition[partition][from][msg.sender]), \"53\"); // 0x53\tinsufficient allowance\r\n\r\n    if(_allowedByPartition[partition][from][msg.sender] >= value) {\r\n      _allowedByPartition[partition][from][msg.sender] = _allowedByPartition[partition][from][msg.sender].sub(value);\r\n    } else {\r\n      _allowedByPartition[partition][from][msg.sender] = 0;\r\n    }\r\n\r\n    return _transferByPartition(partition, msg.sender, from, to, value, data, operatorData);\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************* Controller Operation *************************************/\r\n  /**\r\n   * @dev Know if the token can be controlled by operators.\r\n   * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\r\n   * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\r\n   */\r\n  function isControllable() external view returns (bool) {\r\n    return _isControllable;\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************* Operator Management **************************************/\r\n  /**\r\n   * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\r\n   * and redeem tokens on its behalf.\r\n   * @param operator Address to set as an operator for 'msg.sender'.\r\n   */\r\n  function authorizeOperator(address operator) external {\r\n    require(operator != msg.sender);\r\n    _authorizedOperator[operator][msg.sender] = true;\r\n    emit AuthorizedOperator(operator, msg.sender);\r\n  }\r\n  /**\r\n   * @dev Remove the right of the operator address to be an operator for 'msg.sender'\r\n   * and to transfer and redeem tokens on its behalf.\r\n   * @param operator Address to rescind as an operator for 'msg.sender'.\r\n   */\r\n  function revokeOperator(address operator) external {\r\n    require(operator != msg.sender);\r\n    _authorizedOperator[operator][msg.sender] = false;\r\n    emit RevokedOperator(operator, msg.sender);\r\n  }\r\n  /**\r\n   * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address to set as an operator for 'msg.sender'.\r\n   */\r\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external {\r\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = true;\r\n    emit AuthorizedOperatorByPartition(partition, operator, msg.sender);\r\n  }\r\n  /**\r\n   * @dev Remove the right of the operator address to be an operator on a given\r\n   * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\r\n   */\r\n  function revokeOperatorByPartition(bytes32 partition, address operator) external {\r\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = false;\r\n    emit RevokedOperatorByPartition(partition, operator, msg.sender);\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************* Operator Information *************************************/\r\n  /**\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\r\n   * @param operator Address which may be an operator of tokenHolder.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator.\r\n   * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\r\n   */\r\n  function isOperator(address operator, address tokenHolder) external view returns (bool) {\r\n    return _isOperator(operator, tokenHolder);\r\n  }\r\n  /**\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\r\n   * address for the given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\r\n   */\r\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool) {\r\n    return _isOperatorForPartition(partition, operator, tokenHolder);\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /**************************************** Token Issuance ****************************************/\r\n  /**\r\n   * @dev Know if new tokens can be issued in the future.\r\n   * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\r\n   */\r\n  function isIssuable() external view returns (bool) {\r\n    return _isIssuable;\r\n  }\r\n  /**\r\n   * @dev Issue tokens from default partition.\r\n   * @param tokenHolder Address for which we want to issue tokens.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, by the issuer.\r\n   */\r\n  function issue(address tokenHolder, uint256 value, bytes calldata data)\r\n    external\r\n    onlyMinter\r\n    isIssuableToken\r\n  {\r\n    require(_defaultPartitions.length != 0, \"55\"); // 0x55\tfunds locked (lockup period)\r\n\r\n    _issueByPartition(_defaultPartitions[0], msg.sender, tokenHolder, value, data);\r\n  }\r\n  /**\r\n   * @dev Issue tokens from a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which we want to issue tokens.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, by the issuer.\r\n   */\r\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data)\r\n    external\r\n    onlyMinter\r\n    isIssuableToken\r\n  {\r\n    _issueByPartition(partition, msg.sender, tokenHolder, value, data);\r\n  }\r\n  /************************************************************************************************/\r\n  \r\n\r\n  /*************************************** Token Redemption ***************************************/\r\n  /**\r\n   * @dev Redeem the amount of tokens from the address 'msg.sender'.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption, by the token holder.\r\n   */\r\n  function redeem(uint256 value, bytes calldata data)\r\n    external\r\n  {\r\n    _redeemByDefaultPartitions(msg.sender, msg.sender, value, data);\r\n  }\r\n  /**\r\n   * @dev Redeem the amount of tokens on behalf of the address from.\r\n   * @param from Token holder whose tokens will be redeemed (or address(0) to set from to msg.sender).\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   */\r\n  function redeemFrom(address from, uint256 value, bytes calldata data)\r\n    external\r\n  {\r\n    require(_isOperator(msg.sender, from), \"58\"); // 0x58\tinvalid operator (transfer agent)\r\n\r\n    _redeemByDefaultPartitions(msg.sender, from, value, data);\r\n  }\r\n  /**\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens redeemed.\r\n   * @param data Information attached to the redemption, by the redeemer.\r\n   */\r\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data)\r\n    external\r\n  {\r\n    _redeemByPartition(partition, msg.sender, msg.sender, value, data, \"\");\r\n  }\r\n  /**\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which we want to redeem tokens.\r\n   * @param value Number of tokens redeemed\r\n   * @param operatorData Information attached to the redemption, by the operator.\r\n   */\r\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData)\r\n    external\r\n  {\r\n    require(_isOperatorForPartition(partition, msg.sender, tokenHolder), \"58\"); // 0x58\tinvalid operator (transfer agent)\r\n\r\n    _redeemByPartition(partition, msg.sender, tokenHolder, value, \"\", operatorData);\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************************************************************************/\r\n  /************************ EXTERNAL FUNCTIONS (ADDITIONAL - NOT MANDATORY) ***********************/\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************ Token description *****************************************/\r\n  /**\r\n   * @dev Get the name of the token, e.g., \"MyToken\".\r\n   * @return Name of the token.\r\n   */\r\n  function name() external view returns(string memory) {\r\n    return _name;\r\n  }\r\n  /**\r\n   * @dev Get the symbol of the token, e.g., \"MYT\".\r\n   * @return Symbol of the token.\r\n   */\r\n  function symbol() external view returns(string memory) {\r\n    return _symbol;\r\n  }\r\n  /**\r\n   * @dev Get the number of decimals of the token.\r\n   * @return The number of decimals of the token. For retrocompatibility, decimals are forced to 18 in ERC1400.\r\n   */\r\n  function decimals() external pure returns(uint8) {\r\n    return uint8(18);\r\n  }\r\n  /**\r\n   * @dev Get the smallest part of the token thatâ€™s not divisible.\r\n   * @return The smallest non-divisible part of the token.\r\n   */\r\n  function granularity() external view returns(uint256) {\r\n    return _granularity;\r\n  }\r\n  /**\r\n   * @dev Get list of existing partitions.\r\n   * @return Array of all exisiting partitions.\r\n   */\r\n  function totalPartitions() external view returns (bytes32[] memory) {\r\n    return _totalPartitions;\r\n  }\r\n  /**\r\n   * @dev Get the total number of issued tokens for a given partition.\r\n   * @param partition Name of the partition.\r\n   * @return Total supply of tokens currently in circulation, for a given partition.\r\n   */\r\n  function totalSupplyByPartition(bytes32 partition) external view returns (uint256) {\r\n    return _totalSupplyByPartition[partition];\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /**************************************** Token behaviours **************************************/\r\n  /**\r\n   * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\r\n   * Once set to false, '_isControllable' can never be set to 'true' again.\r\n   */\r\n  function renounceControl() external onlyOwner {\r\n    _isControllable = false;\r\n  }\r\n  /**\r\n   * @dev Definitely renounce the possibility to issue new tokens.\r\n   * Once set to false, '_isIssuable' can never be set to 'true' again.\r\n   */\r\n  function renounceIssuance() external onlyOwner {\r\n    _isIssuable = false;\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************ Token controllers *****************************************/\r\n  /**\r\n   * @dev Get the list of controllers as defined by the token contract.\r\n   * @return List of addresses of all the controllers.\r\n   */\r\n  function controllers() external view returns (address[] memory) {\r\n    return _controllers;\r\n  }\r\n  /**\r\n   * @dev Get controllers for a given partition.\r\n   * @param partition Name of the partition.\r\n   * @return Array of controllers for partition.\r\n   */\r\n  function controllersByPartition(bytes32 partition) external view returns (address[] memory) {\r\n    return _controllersByPartition[partition];\r\n  }\r\n  /**\r\n   * @dev Set list of token controllers.\r\n   * @param operators Controller addresses.\r\n   */\r\n  function setControllers(address[] calldata operators) external onlyOwner {\r\n    _setControllers(operators);\r\n  }\r\n  /**\r\n   * @dev Set list of token partition controllers.\r\n   * @param partition Name of the partition.\r\n   * @param operators Controller addresses.\r\n   */\r\n   function setPartitionControllers(bytes32 partition, address[] calldata operators) external onlyOwner {\r\n     _setPartitionControllers(partition, operators);\r\n   }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /********************************* Token default partitions *************************************/\r\n  /**\r\n   * @dev Get default partitions to transfer from.\r\n   * Function used for ERC20 retrocompatibility.\r\n   * For example, a security token may return the bytes32(\"unrestricted\").\r\n   * @return Array of default partitions.\r\n   */\r\n  function getDefaultPartitions() external view returns (bytes32[] memory) {\r\n    return _defaultPartitions;\r\n  }\r\n  /**\r\n   * @dev Set default partitions to transfer from.\r\n   * Function used for ERC20 retrocompatibility.\r\n   * @param partitions partitions to use by default when not specified.\r\n   */\r\n  function setDefaultPartitions(bytes32[] calldata partitions) external onlyOwner {\r\n    _defaultPartitions = partitions;\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /******************************** Partition Token Allowances ************************************/\r\n  /**\r\n   * @dev Check the value of tokens that an owner allowed to a spender.\r\n   * @param partition Name of the partition.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the value of tokens still available for the spender.\r\n   */\r\n  function allowanceByPartition(bytes32 partition, address owner, address spender) external view returns (uint256) {\r\n    return _allowedByPartition[partition][owner][spender];\r\n  }\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\r\n   * @param partition Name of the partition.\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function approveByPartition(bytes32 partition, address spender, uint256 value) external returns (bool) {\r\n    require(spender != address(0), \"56\"); // 0x56\tinvalid sender\r\n    _allowedByPartition[partition][msg.sender][spender] = value;\r\n    emit ApprovalByPartition(partition, msg.sender, spender, value);\r\n    return true;\r\n  }\r\n  /************************************************************************************************/\r\n\r\n  \r\n  /************************************** Token extension *****************************************/\r\n  /**\r\n   * @dev Set token extension contract address.\r\n   * The extension contract can for example verify \"ERC1400TokensValidator\" or \"ERC1400TokensChecker\" interfaces.\r\n   * If the extension is an \"ERC1400TokensValidator\", it will be called everytime a transfer is executed.\r\n   * @param extension Address of the extension contract.\r\n   * @param interfaceLabel Interface label of extension contract.\r\n   * @param removeOldExtensionRoles If set to 'true', the roles of the old extension(minter, controller) will be removed extension.\r\n   * @param addMinterRoleForExtension If set to 'true', the extension contract will be added as minter.\r\n   * @param addControllerRoleForExtension If set to 'true', the extension contract will be added as controller.\r\n   */\r\n  function setTokenExtension(address extension, string calldata interfaceLabel, bool removeOldExtensionRoles, bool addMinterRoleForExtension, bool addControllerRoleForExtension) external onlyOwner {\r\n    _setTokenExtension(extension, interfaceLabel, removeOldExtensionRoles, addMinterRoleForExtension, addControllerRoleForExtension);\r\n  }\r\n  /************************************************************************************************/\r\n\r\n  /************************************* Token migration ******************************************/\r\n  /**\r\n   * @dev Migrate contract.\r\n   *\r\n   * ===> CAUTION: DEFINITIVE ACTION\r\n   * \r\n   * This function shall be called once a new version of the smart contract has been created.\r\n   * Once this function is called:\r\n   *  - The address of the new smart contract is set in ERC1820 registry\r\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\r\n   *\r\n   * @param newContractAddress Address of the new version of the smart contract.\r\n   * @param definitive If set to 'true' the contract is turned off definitely.\r\n   */\r\n  function migrate(address newContractAddress, bool definitive) external onlyOwner {\r\n    _migrate(newContractAddress, definitive);\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************************************************************************/\r\n  /************************************* INTERNAL FUNCTIONS ***************************************/\r\n  /************************************************************************************************/\r\n\r\n\r\n  /**************************************** Token Transfers ***************************************/\r\n  /**\r\n   * @dev Perform the transfer of tokens.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n  function _transferWithData(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n    isNotMigratedToken\r\n  {\r\n    require(_isMultiple(value), \"50\"); // 0x50\ttransfer failure\r\n    require(to != address(0), \"57\"); // 0x57\tinvalid receiver\r\n    require(_balances[from] >= value, \"52\"); // 0x52\tinsufficient balance\r\n  \r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n\r\n    emit Transfer(from, to, value); // ERC20 retrocompatibility \r\n  }\r\n  /**\r\n   * @dev Transfer tokens from a specific partition.\r\n   * @param fromPartition Partition of the tokens to transfer.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator (if any).\r\n   * @return Destination partition.\r\n   */\r\n  function _transferByPartition(\r\n    bytes32 fromPartition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n    returns (bytes32)\r\n  {\r\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"52\"); // 0x52\tinsufficient balance\r\n\r\n    bytes32 toPartition = fromPartition;\r\n\r\n    if(operatorData.length != 0 && data.length >= 64) {\r\n      toPartition = _getDestinationPartition(fromPartition, data);\r\n    }\r\n\r\n    _callSenderExtension(fromPartition, operator, from, to, value, data, operatorData);\r\n    _callTokenExtension(fromPartition, operator, from, to, value, data, operatorData);\r\n\r\n    _removeTokenFromPartition(from, fromPartition, value);\r\n    _transferWithData(from, to, value);\r\n    _addTokenToPartition(to, toPartition, value);\r\n\r\n    _callRecipientExtension(toPartition, operator, from, to, value, data, operatorData);\r\n\r\n    emit TransferByPartition(fromPartition, operator, from, to, value, data, operatorData);\r\n\r\n    if(toPartition != fromPartition) {\r\n      emit ChangedPartition(fromPartition, toPartition, value);\r\n    }\r\n\r\n    return toPartition;\r\n  }\r\n  /**\r\n   * @dev Transfer tokens from default partitions.\r\n   * Function used for ERC20 retrocompatibility.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from') [CAN CONTAIN THE DESTINATION PARTITION].\r\n   */\r\n  function _transferByDefaultPartitions(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data\r\n  )\r\n    internal\r\n  {\r\n    require(_defaultPartitions.length != 0, \"55\"); // // 0x55\tfunds locked (lockup period)\r\n\r\n    uint256 _remainingValue = value;\r\n    uint256 _localBalance;\r\n\r\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\r\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\r\n      if(_remainingValue <= _localBalance) {\r\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _remainingValue, data, \"\");\r\n        _remainingValue = 0;\r\n        break;\r\n      } else if (_localBalance != 0) {\r\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _localBalance, data, \"\");\r\n        _remainingValue = _remainingValue - _localBalance;\r\n      }\r\n    }\r\n\r\n    require(_remainingValue == 0, \"52\"); // 0x52\tinsufficient balance\r\n  }\r\n  /**\r\n   * @dev Retrieve the destination partition from the 'data' field.\r\n   * By convention, a partition change is requested ONLY when 'data' starts\r\n   * with the flag: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n   * When the flag is detected, the destination tranche is extracted from the\r\n   * 32 bytes following the flag.\r\n   * @param fromPartition Partition of the tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @return Destination partition.\r\n   */\r\n  function _getDestinationPartition(bytes32 fromPartition, bytes memory data) internal pure returns(bytes32 toPartition) {\r\n    bytes32 changePartitionFlag = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    bytes32 flag;\r\n    assembly {\r\n      flag := mload(add(data, 32))\r\n    }\r\n    if(flag == changePartitionFlag) {\r\n      assembly {\r\n        toPartition := mload(add(data, 64))\r\n      }\r\n    } else {\r\n      toPartition = fromPartition;\r\n    }\r\n  }\r\n  /**\r\n   * @dev Remove a token from a specific partition.\r\n   * @param from Token holder.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n  function _removeTokenFromPartition(address from, bytes32 partition, uint256 value) internal {\r\n    _balanceOfByPartition[from][partition] = _balanceOfByPartition[from][partition].sub(value);\r\n    _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].sub(value);\r\n\r\n    // If the total supply is zero, finds and deletes the partition.\r\n    if(_totalSupplyByPartition[partition] == 0) {\r\n      uint256 index1 = _indexOfTotalPartitions[partition];\r\n      require(index1 > 0, \"50\"); // 0x50\ttransfer failure\r\n\r\n      // move the last item into the index being vacated\r\n      bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\r\n      _totalPartitions[index1 - 1] = lastValue; // adjust for 1-based indexing\r\n      _indexOfTotalPartitions[lastValue] = index1;\r\n\r\n      _totalPartitions.length -= 1;\r\n      _indexOfTotalPartitions[partition] = 0;\r\n    }\r\n\r\n    // If the balance of the TokenHolder's partition is zero, finds and deletes the partition.\r\n    if(_balanceOfByPartition[from][partition] == 0) {\r\n      uint256 index2 = _indexOfPartitionsOf[from][partition];\r\n      require(index2 > 0, \"50\"); // 0x50\ttransfer failure\r\n\r\n      // move the last item into the index being vacated\r\n      bytes32 lastValue = _partitionsOf[from][_partitionsOf[from].length - 1];\r\n      _partitionsOf[from][index2 - 1] = lastValue;  // adjust for 1-based indexing\r\n      _indexOfPartitionsOf[from][lastValue] = index2;\r\n\r\n      _partitionsOf[from].length -= 1;\r\n      _indexOfPartitionsOf[from][partition] = 0;\r\n    }\r\n  }\r\n  /**\r\n   * @dev Add a token to a specific partition.\r\n   * @param to Token recipient.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n  function _addTokenToPartition(address to, bytes32 partition, uint256 value) internal {\r\n    if(value != 0) {\r\n      if (_indexOfPartitionsOf[to][partition] == 0) {\r\n        _partitionsOf[to].push(partition);\r\n        _indexOfPartitionsOf[to][partition] = _partitionsOf[to].length;\r\n      }\r\n      _balanceOfByPartition[to][partition] = _balanceOfByPartition[to][partition].add(value);\r\n\r\n      if (_indexOfTotalPartitions[partition] == 0) {\r\n        _totalPartitions.push(partition);\r\n        _indexOfTotalPartitions[partition] = _totalPartitions.length;\r\n      }\r\n      _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].add(value);\r\n    }\r\n  }\r\n  /**\r\n   * @dev Check if 'value' is multiple of the granularity.\r\n   * @param value The quantity that want's to be checked.\r\n   * @return 'true' if 'value' is a multiple of the granularity.\r\n   */\r\n  function _isMultiple(uint256 value) internal view returns(bool) {\r\n    return(value.div(_granularity).mul(_granularity) == value);\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /****************************************** Hooks ***********************************************/\r\n  /**\r\n   * @dev Check for 'ERC1400TokensSender' user extension in ERC1820 registry and call it.\r\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\r\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\r\n   * @param from Token holder.\r\n   * @param to Token recipient for a transfer and 0x for a redemption.\r\n   * @param value Number of tokens the token holder balance is decreased by.\r\n   * @param data Extra information.\r\n   * @param operatorData Extra information, attached by the operator (if any).\r\n   */\r\n  function _callSenderExtension(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    address senderImplementation;\r\n    senderImplementation = interfaceAddr(from, ERC1400_TOKENS_SENDER);\r\n    if (senderImplementation != address(0)) {\r\n      IERC1400TokensSender(senderImplementation).tokensToTransfer(msg.data, partition, operator, from, to, value, data, operatorData);\r\n    }\r\n  }\r\n  /**\r\n   * @dev Check for 'ERC1400TokensValidator' token extension in ERC1820 registry and call it.\r\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\r\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\r\n   * @param from Token holder.\r\n   * @param to Token recipient for a transfer and 0x for a redemption.\r\n   * @param value Number of tokens the token holder balance is decreased by.\r\n   * @param data Extra information.\r\n   * @param operatorData Extra information, attached by the operator (if any).\r\n   */\r\n  function _callTokenExtension(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    address validatorImplementation;\r\n    validatorImplementation = interfaceAddr(address(this), ERC1400_TOKENS_VALIDATOR);\r\n    if (validatorImplementation != address(0)) {\r\n      IERC1400TokensValidator(validatorImplementation).tokensToValidate(msg.data, partition, operator, from, to, value, data, operatorData);\r\n    }\r\n  }\r\n  /**\r\n   * @dev Check for 'ERC1400TokensRecipient' user extension in ERC1820 registry and call it.\r\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\r\n   * @param operator Address which triggered the balance increase (through transfer or issuance).\r\n   * @param from Token holder for a transfer and 0x for an issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens the recipient balance is increased by.\r\n   * @param data Extra information, intended for the token holder ('from').\r\n   * @param operatorData Extra information attached by the operator (if any).\r\n   */\r\n  function _callRecipientExtension(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    address recipientImplementation;\r\n    recipientImplementation = interfaceAddr(to, ERC1400_TOKENS_RECIPIENT);\r\n\r\n    if (recipientImplementation != address(0)) {\r\n      IERC1400TokensRecipient(recipientImplementation).tokensReceived(msg.data, partition, operator, from, to, value, data, operatorData);\r\n    }\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************* Operator Information *************************************/\r\n  /**\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\r\n   * @param operator Address which may be an operator of 'tokenHolder'.\r\n   * @param tokenHolder Address of a token holder which may have the 'operator' address as an operator.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' and 'false' otherwise.\r\n   */\r\n  function _isOperator(address operator, address tokenHolder) internal view returns (bool) {\r\n    return (operator == tokenHolder\r\n      || _authorizedOperator[operator][tokenHolder]\r\n      || (_isControllable && _isController[operator])\r\n    );\r\n  }\r\n  /**\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\r\n   * address for the given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\r\n   */\r\n   function _isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) internal view returns (bool) {\r\n     return (_isOperator(operator, tokenHolder)\r\n       || _authorizedOperatorByPartition[tokenHolder][partition][operator]\r\n       || (_isControllable && _isControllerByPartition[partition][operator])\r\n     );\r\n   }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /**************************************** Token Issuance ****************************************/\r\n  /**\r\n   * @dev Perform the issuance of tokens.\r\n   * @param operator Address which triggered the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, and intended for the recipient (to).\r\n   */\r\n  function _issue(address operator, address to, uint256 value, bytes memory data)\r\n    internal\r\n    isNotMigratedToken  \r\n  {\r\n    require(_isMultiple(value), \"50\"); // 0x50\ttransfer failure\r\n    require(to != address(0), \"57\"); // 0x57\tinvalid receiver\r\n\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[to] = _balances[to].add(value);\r\n\r\n    emit Issued(operator, to, value, data);\r\n    emit Transfer(address(0), to, value); // ERC20 retrocompatibility\r\n  }\r\n  /**\r\n   * @dev Issue tokens from a specific partition.\r\n   * @param toPartition Name of the partition.\r\n   * @param operator The address performing the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to issue.\r\n   * @param data Information attached to the issuance.\r\n   */\r\n  function _issueByPartition(\r\n    bytes32 toPartition,\r\n    address operator,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data\r\n  )\r\n    internal\r\n  {\r\n    _callTokenExtension(toPartition, operator, address(0), to, value, data, \"\");\r\n\r\n    _issue(operator, to, value, data);\r\n    _addTokenToPartition(to, toPartition, value);\r\n\r\n    _callRecipientExtension(toPartition, operator, address(0), to, value, data, \"\");\r\n\r\n    emit IssuedByPartition(toPartition, operator, to, value, data, \"\");\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /*************************************** Token Redemption ***************************************/\r\n  /**\r\n   * @dev Perform the token redemption.\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   */\r\n  function _redeem(address operator, address from, uint256 value, bytes memory data)\r\n    internal\r\n    isNotMigratedToken\r\n  {\r\n    require(_isMultiple(value), \"50\"); // 0x50\ttransfer failure\r\n    require(from != address(0), \"56\"); // 0x56\tinvalid sender\r\n    require(_balances[from] >= value, \"52\"); // 0x52\tinsufficient balance\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _totalSupply = _totalSupply.sub(value);\r\n\r\n    emit Redeemed(operator, from, value, data);\r\n    emit Transfer(from, address(0), value);  // ERC20 retrocompatibility\r\n  }\r\n  /**\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param fromPartition Name of the partition.\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n  function _redeemByPartition(\r\n    bytes32 fromPartition,\r\n    address operator,\r\n    address from,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"52\"); // 0x52\tinsufficient balance\r\n\r\n    _callSenderExtension(fromPartition, operator, from, address(0), value, data, operatorData);\r\n    _callTokenExtension(fromPartition, operator, from, address(0), value, data, operatorData);\r\n\r\n    _removeTokenFromPartition(from, fromPartition, value);\r\n    _redeem(operator, from, value, data);\r\n\r\n    emit RedeemedByPartition(fromPartition, operator, from, value, operatorData);\r\n  }\r\n  /**\r\n   * @dev Redeem tokens from a default partitions.\r\n   * @param operator The address performing the redeem.\r\n   * @param from Token holder.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   */\r\n  function _redeemByDefaultPartitions(\r\n    address operator,\r\n    address from,\r\n    uint256 value,\r\n    bytes memory data\r\n  )\r\n    internal\r\n  {\r\n    require(_defaultPartitions.length != 0, \"55\"); // 0x55\tfunds locked (lockup period)\r\n\r\n    uint256 _remainingValue = value;\r\n    uint256 _localBalance;\r\n\r\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\r\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\r\n      if(_remainingValue <= _localBalance) {\r\n        _redeemByPartition(_defaultPartitions[i], operator, from, _remainingValue, data, \"\");\r\n        _remainingValue = 0;\r\n        break;\r\n      } else {\r\n        _redeemByPartition(_defaultPartitions[i], operator, from, _localBalance, data, \"\");\r\n        _remainingValue = _remainingValue - _localBalance;\r\n      }\r\n    }\r\n\r\n    require(_remainingValue == 0, \"52\"); // 0x52\tinsufficient balance\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************** Transfer Validity ***************************************/\r\n  /**\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param payload Payload of the initial transaction.\r\n   * @param partition Name of the partition.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator (if any).\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n  function _canTransfer(bytes memory payload, bytes32 partition, address operator, address from, address to, uint256 value, bytes memory data, bytes memory operatorData)\r\n    internal\r\n    view\r\n    returns (byte, bytes32, bytes32)\r\n  {\r\n    address checksImplementation = interfaceAddr(address(this), ERC1400_TOKENS_CHECKER);\r\n\r\n    if((checksImplementation != address(0))) {\r\n      return IERC1400TokensChecker(checksImplementation).canTransferByPartition(payload, partition, operator, from, to, value, data, operatorData);\r\n    }\r\n    else {\r\n      return(hex\"00\", \"\", partition);\r\n    }\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************************************************************************/\r\n  /************************ INTERNAL FUNCTIONS (ADDITIONAL - NOT MANDATORY) ***********************/\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************ Token controllers *****************************************/\r\n  /**\r\n   * @dev Set list of token controllers.\r\n   * @param operators Controller addresses.\r\n   */\r\n  function _setControllers(address[] memory operators) internal {\r\n    for (uint i = 0; i<_controllers.length; i++){\r\n      _isController[_controllers[i]] = false;\r\n    }\r\n    for (uint j = 0; j<operators.length; j++){\r\n      _isController[operators[j]] = true;\r\n    }\r\n    _controllers = operators;\r\n  }\r\n  /**\r\n   * @dev Set list of token partition controllers.\r\n   * @param partition Name of the partition.\r\n   * @param operators Controller addresses.\r\n   */\r\n   function _setPartitionControllers(bytes32 partition, address[] memory operators) internal {\r\n     for (uint i = 0; i<_controllersByPartition[partition].length; i++){\r\n       _isControllerByPartition[partition][_controllersByPartition[partition][i]] = false;\r\n     }\r\n     for (uint j = 0; j<operators.length; j++){\r\n       _isControllerByPartition[partition][operators[j]] = true;\r\n     }\r\n     _controllersByPartition[partition] = operators;\r\n   }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************** Token extension *****************************************/\r\n  /**\r\n   * @dev Set token extension contract address.\r\n   * The extension contract can for example verify \"ERC1400TokensValidator\" or \"ERC1400TokensChecker\" interfaces.\r\n   * If the extension is an \"ERC1400TokensValidator\", it will be called everytime a transfer is executed.\r\n   * @param extension Address of the extension contract.\r\n   * @param interfaceLabel Interface label of extension contract.\r\n   * @param removeOldExtensionRoles If set to 'true', the roles of the old extension(minter, controller) will be removed extension.\r\n   * @param addMinterRoleForExtension If set to 'true', the extension contract will be added as minter.\r\n   * @param addControllerRoleForExtension If set to 'true', the extension contract will be added as controller.\r\n   */\r\n  function _setTokenExtension(address extension, string memory interfaceLabel, bool removeOldExtensionRoles, bool addMinterRoleForExtension, bool addControllerRoleForExtension) internal {\r\n    address oldExtension = interfaceAddr(address(this), interfaceLabel);\r\n\r\n    if (oldExtension != address(0) && removeOldExtensionRoles) {\r\n      if(isMinter(oldExtension)) {\r\n        _removeMinter(oldExtension);\r\n      }\r\n      _isController[oldExtension] = false;\r\n    }\r\n\r\n    ERC1820Client.setInterfaceImplementation(interfaceLabel, extension);\r\n    if(addMinterRoleForExtension && !isMinter(extension)) {\r\n      _addMinter(extension);\r\n    }\r\n    if (addControllerRoleForExtension) {\r\n      _isController[extension] = true;\r\n    }\r\n  }\r\n  /************************************************************************************************/\r\n\r\n\r\n  /************************************* Token migration ******************************************/\r\n  /**\r\n   * @dev Migrate contract.\r\n   *\r\n   * ===> CAUTION: DEFINITIVE ACTION\r\n   * \r\n   * This function shall be called once a new version of the smart contract has been created.\r\n   * Once this function is called:\r\n   *  - The address of the new smart contract is set in ERC1820 registry\r\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\r\n   *\r\n   * @param newContractAddress Address of the new version of the smart contract.\r\n   * @param definitive If set to 'true' the contract is turned off definitely.\r\n   */\r\n  function _migrate(address newContractAddress, bool definitive) internal {\r\n    ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, newContractAddress);\r\n    ERC1820Client.setInterfaceImplementation(ERC1400_INTERFACE_NAME, newContractAddress);\r\n    if(definitive) {\r\n      _migrated = true;\r\n    }\r\n  }\r\n  /************************************************************************************************/\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice Interface to the extension types\r\n */\r\ninterface IExtensionTypes {\r\n  enum CertificateValidation {\r\n    None,\r\n    NonceBased,\r\n    SaltBased\r\n  }\r\n}\r\n\r\n/**\r\n * @notice Interface to the extension contract\r\n */\r\ncontract Extension is IExtensionTypes {\r\n  function registerTokenSetup(\r\n    address token,\r\n    CertificateValidation certificateActivated,\r\n    bool allowlistActivated,\r\n    bool blocklistActivated,\r\n    bool granularityByPartitionActivated,\r\n    bool holdsActivated,\r\n    address[] calldata operators\r\n  ) external;\r\n\r\n  function addCertificateSigner(\r\n    address token,\r\n    address account\r\n  ) external;\r\n}\r\n\r\n\r\n/**\r\n * @title ERC1400HoldableCertificateNonceToken\r\n * @dev Holdable ERC1400 with nonce-based certificate controller logic\r\n */\r\ncontract ERC1400HoldableCertificateToken is ERC1400, IExtensionTypes {\r\n\r\n  string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\r\n\r\n  /**\r\n   * @dev Initialize ERC1400 + initialize certificate controller.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param defaultPartitions Partitions chosen by default, when partition is\r\n   * not specified, like the case ERC20 tranfers.\r\n   * @param extension Address of token extension.\r\n   * @param newOwner Address whom contract ownership shall be transferred to.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   * @param certificateActivated If set to 'true', the certificate controller\r\n   * is activated at contract creation.\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    bytes32[] memory defaultPartitions,\r\n    address extension,\r\n    address newOwner,\r\n    address certificateSigner,\r\n    CertificateValidation certificateActivated\r\n  )\r\n    public\r\n    ERC1400(name, symbol, granularity, controllers, defaultPartitions)\r\n  {\r\n    if(extension != address(0)) {\r\n      Extension(extension).registerTokenSetup(\r\n        address(this), // token\r\n        certificateActivated, // certificateActivated\r\n        true, // allowlistActivated\r\n        true, // blocklistActivated\r\n        true, // granularityByPartitionActivated\r\n        true, // holdsActivated\r\n        controllers // token controllers\r\n      );\r\n\r\n      if(certificateSigner != address(0)) {\r\n        Extension(extension).addCertificateSigner(address(this), certificateSigner);\r\n      }\r\n\r\n      _setTokenExtension(extension, ERC1400_TOKENS_VALIDATOR, true, true, true);\r\n    }\r\n\r\n    if(newOwner != address(0)) {\r\n      _transferOwnership(newOwner);\r\n    }\r\n  }\r\n\r\n  /************************************** Transfer Validity ***************************************/\r\n  /**\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n  function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data)\r\n    external\r\n    view\r\n    returns (byte, bytes32, bytes32)\r\n  {\r\n    return ERC1400._canTransfer(\r\n      _replaceFunctionSelector(this.transferByPartition.selector, msg.data), // 0xf3d490db: 4 first bytes of keccak256(transferByPartition(bytes32,address,uint256,bytes))\r\n      partition,\r\n      msg.sender,\r\n      msg.sender,\r\n      to,\r\n      value,\r\n      data,\r\n      \"\"\r\n    );\r\n  }\r\n  /**\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n  function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    view\r\n    returns (byte, bytes32, bytes32)\r\n  {\r\n    return ERC1400._canTransfer(\r\n      _replaceFunctionSelector(this.operatorTransferByPartition.selector, msg.data), // 0x8c0dee9c: 4 first bytes of keccak256(operatorTransferByPartition(bytes32,address,address,uint256,bytes,bytes))\r\n      partition,\r\n      msg.sender,\r\n      from,\r\n      to,\r\n      value,\r\n      data,\r\n      operatorData\r\n    );\r\n  }\r\n  /**\r\n   * @dev Replace function selector\r\n   * @param functionSig Replacement function selector.\r\n   * @param payload Payload, where function selector needs to be replaced.\r\n   */\r\n  function _replaceFunctionSelector(bytes4 functionSig, bytes memory payload) internal pure returns(bytes memory) {\r\n    bytes memory updatedPayload = new bytes(payload.length);\r\n    for (uint i = 0; i<4; i++){\r\n      updatedPayload[i] = functionSig[i];\r\n    }\r\n    for (uint j = 4; j<payload.length; j++){\r\n      updatedPayload[j] = payload[j];\r\n    }\r\n    return updatedPayload;\r\n  }\r\n  /************************************************************************************************/\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"granularity\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"controllers\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"defaultPartitions\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"certificateSigner\",\"type\":\"address\"},{\"internalType\":\"enum IExtensionTypes.CertificateValidation\",\"name\":\"certificateActivated\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ApprovalByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"toPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangedPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"Document\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"IssuedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"RedeemedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferByPartition\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowanceByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveByPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperatorByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOfByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"canOperatorTransferByPartition\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"canTransferByPartition\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"controllersByPartition\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultPartitions\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"getDocument\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isControllable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIssuable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorForPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issueByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newContractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"definitive\",\"type\":\"bool\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorRedeemByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorTransferByPartition\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"partitionsOf\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceControl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceIssuance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperatorByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setControllers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"partitions\",\"type\":\"bytes32[]\"}],\"name\":\"setDefaultPartitions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"setDocument\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setPartitionControllers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"interfaceLabel\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"removeOldExtensionRoles\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"addMinterRoleForExtension\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"addControllerRoleForExtension\",\"type\":\"bool\"}],\"name\":\"setTokenExtension\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPartitions\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"totalSupplyByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferByPartition\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferFromWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC1400HoldableCertificateToken","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000fa30aff9a0d7a976a469593f1e3143ff8218a79a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000134941444f57522053656375726520546f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000349415800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000fa30aff9a0d7a976a469593f1e3143ff8218a79a0000000000000000000000008dade032ed02bac831a9069071fcb45b19b843cf00000000000000000000000000000000000000000000000000000000000000027265737472696374656400000000000000000000000000000000000000000000756e726573747269637465640000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"bzzr://ea11a1177597c60f3ea059bd77b4d5d4aabcb1aec3f226a0ecd1b96eec45cebd"}]}