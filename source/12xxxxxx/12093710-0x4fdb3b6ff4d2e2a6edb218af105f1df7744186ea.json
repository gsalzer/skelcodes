{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/VaultFactory.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./libs/@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./IDerivativeSpecification.sol\\\";\\nimport \\\"./registries/IAddressRegistry.sol\\\";\\nimport \\\"./IVaultBuilder.sol\\\";\\nimport \\\"./IPausableVault.sol\\\";\\n\\n/// @title Vault Factory implementation contract\\n/// @notice Creates new vaults and registers them in internal storage\\ncontract VaultFactory is OwnableUpgradeSafe {\\n    address[] internal _vaults;\\n\\n    IAddressRegistry public derivativeSpecificationRegistry;\\n    IAddressRegistry public oracleRegistry;\\n    IAddressRegistry public collateralTokenRegistry;\\n    IAddressRegistry public collateralSplitRegistry;\\n    address public tokenBuilder;\\n    address public feeLogger;\\n\\n    /// @notice protocol fee multiplied by 10 ^ 12\\n    uint256 public protocolFee;\\n    /// @notice protocol fee receiving wallet\\n    address public feeWallet;\\n    /// @notice author above limit fee multiplied by 10 ^ 12\\n    uint256 public authorFeeLimit;\\n\\n    IVaultBuilder public vaultBuilder;\\n    IAddressRegistry public oracleIteratorRegistry;\\n\\n    /// @notice redeem function can only be called after the end of the Live period + delay\\n    uint256 public settlementDelay;\\n\\n    event VaultCreated(\\n        bytes32 indexed derivativeSymbol,\\n        address vault,\\n        address specification\\n    );\\n\\n    /// @notice Initializes vault factory contract storage\\n    /// @dev Used only once when vault factory is created for the first time\\n    function initialize(\\n        address _derivativeSpecificationRegistry,\\n        address _oracleRegistry,\\n        address _oracleIteratorRegistry,\\n        address _collateralTokenRegistry,\\n        address _collateralSplitRegistry,\\n        address _tokenBuilder,\\n        address _feeLogger,\\n        uint256 _protocolFee,\\n        address _feeWallet,\\n        uint256 _authorFeeLimit,\\n        address _vaultBuilder,\\n        uint256 _settlementDelay\\n    ) external initializer {\\n        __Ownable_init();\\n\\n        setDerivativeSpecificationRegistry(_derivativeSpecificationRegistry);\\n        setOracleRegistry(_oracleRegistry);\\n        setOracleIteratorRegistry(_oracleIteratorRegistry);\\n        setCollateralTokenRegistry(_collateralTokenRegistry);\\n        setCollateralSplitRegistry(_collateralSplitRegistry);\\n\\n        setTokenBuilder(_tokenBuilder);\\n        setFeeLogger(_feeLogger);\\n        setVaultBuilder(_vaultBuilder);\\n\\n        setSettlementDelay(_settlementDelay);\\n\\n        protocolFee = _protocolFee;\\n        authorFeeLimit = _authorFeeLimit;\\n\\n        require(_feeWallet != address(0), \\\"Fee wallet\\\");\\n        feeWallet = _feeWallet;\\n    }\\n\\n    /// @notice Creates a new vault based on derivative specification symbol and initialization timestamp\\n    /// @dev Initialization timestamp allows to target a specific start time for Live period\\n    /// @param _derivativeSymbolHash a symbol hash which resolves to the derivative specification\\n    /// @param _liveTime vault live timestamp\\n    function createVault(bytes32 _derivativeSymbolHash, uint256 _liveTime)\\n        external\\n    {\\n        IDerivativeSpecification derivativeSpecification =\\n            IDerivativeSpecification(\\n                derivativeSpecificationRegistry.get(_derivativeSymbolHash)\\n            );\\n        require(\\n            address(derivativeSpecification) != address(0),\\n            \\\"Specification is absent\\\"\\n        );\\n\\n        address collateralToken =\\n            collateralTokenRegistry.get(\\n                derivativeSpecification.collateralTokenSymbol()\\n            );\\n        address collateralSplit =\\n            collateralSplitRegistry.get(\\n                derivativeSpecification.collateralSplitSymbol()\\n            );\\n\\n        address[] memory oracles;\\n        address[] memory oracleIterators;\\n        (oracles, oracleIterators) = getOraclesAndIterators(\\n            derivativeSpecification\\n        );\\n\\n        require(_liveTime > 0, \\\"Zero live time\\\");\\n\\n        address vault =\\n            vaultBuilder.buildVault(\\n                _liveTime,\\n                protocolFee,\\n                feeWallet,\\n                address(derivativeSpecification),\\n                collateralToken,\\n                oracles,\\n                oracleIterators,\\n                collateralSplit,\\n                tokenBuilder,\\n                feeLogger,\\n                authorFeeLimit,\\n                settlementDelay\\n            );\\n        emit VaultCreated(\\n            _derivativeSymbolHash,\\n            vault,\\n            address(derivativeSpecification)\\n        );\\n        _vaults.push(vault);\\n    }\\n\\n    function getOraclesAndIterators(\\n        IDerivativeSpecification _derivativeSpecification\\n    )\\n        internal\\n        returns (address[] memory _oracles, address[] memory _oracleIterators)\\n    {\\n        bytes32[] memory oracleSymbols =\\n            _derivativeSpecification.oracleSymbols();\\n        bytes32[] memory oracleIteratorSymbols =\\n            _derivativeSpecification.oracleIteratorSymbols();\\n        require(\\n            oracleSymbols.length == oracleIteratorSymbols.length,\\n            \\\"Oracles and iterators length\\\"\\n        );\\n\\n        _oracles = new address[](oracleSymbols.length);\\n        _oracleIterators = new address[](oracleIteratorSymbols.length);\\n        for (uint256 i = 0; i < oracleSymbols.length; i++) {\\n            address oracle = oracleRegistry.get(oracleSymbols[i]);\\n            require(address(oracle) != address(0), \\\"Oracle is absent\\\");\\n            _oracles[i] = oracle;\\n\\n            address oracleIterator =\\n                oracleIteratorRegistry.get(oracleIteratorSymbols[i]);\\n            require(\\n                address(oracleIterator) != address(0),\\n                \\\"OracleIterator is absent\\\"\\n            );\\n            _oracleIterators[i] = oracleIterator;\\n        }\\n    }\\n\\n    function setProtocolFee(uint256 _protocolFee) external onlyOwner {\\n        protocolFee = _protocolFee;\\n    }\\n\\n    function setAuthorFeeLimit(uint256 _authorFeeLimit) external onlyOwner {\\n        authorFeeLimit = _authorFeeLimit;\\n    }\\n\\n    function setTokenBuilder(address _tokenBuilder) public onlyOwner {\\n        require(_tokenBuilder != address(0), \\\"Token builder\\\");\\n        tokenBuilder = _tokenBuilder;\\n    }\\n\\n    function setFeeLogger(address _feeLogger) public onlyOwner {\\n        require(_feeLogger != address(0), \\\"Fee logger\\\");\\n        feeLogger = _feeLogger;\\n    }\\n\\n    function setVaultBuilder(address _vaultBuilder) public onlyOwner {\\n        require(_vaultBuilder != address(0), \\\"Vault builder\\\");\\n        vaultBuilder = IVaultBuilder(_vaultBuilder);\\n    }\\n\\n    function setSettlementDelay(uint256 _settlementDelay) public onlyOwner {\\n        settlementDelay = _settlementDelay;\\n    }\\n\\n    function setDerivativeSpecificationRegistry(\\n        address _derivativeSpecificationRegistry\\n    ) public onlyOwner {\\n        require(\\n            _derivativeSpecificationRegistry != address(0),\\n            \\\"Derivative specification registry\\\"\\n        );\\n        derivativeSpecificationRegistry = IAddressRegistry(\\n            _derivativeSpecificationRegistry\\n        );\\n    }\\n\\n    function setOracleRegistry(address _oracleRegistry) public onlyOwner {\\n        require(_oracleRegistry != address(0), \\\"Oracle registry\\\");\\n        oracleRegistry = IAddressRegistry(_oracleRegistry);\\n    }\\n\\n    function setOracleIteratorRegistry(address _oracleIteratorRegistry)\\n        public\\n        onlyOwner\\n    {\\n        require(\\n            _oracleIteratorRegistry != address(0),\\n            \\\"Oracle iterator registry\\\"\\n        );\\n        oracleIteratorRegistry = IAddressRegistry(_oracleIteratorRegistry);\\n    }\\n\\n    function setCollateralTokenRegistry(address _collateralTokenRegistry)\\n        public\\n        onlyOwner\\n    {\\n        require(\\n            _collateralTokenRegistry != address(0),\\n            \\\"Collateral token registry\\\"\\n        );\\n        collateralTokenRegistry = IAddressRegistry(_collateralTokenRegistry);\\n    }\\n\\n    function setCollateralSplitRegistry(address _collateralSplitRegistry)\\n        public\\n        onlyOwner\\n    {\\n        require(\\n            _collateralSplitRegistry != address(0),\\n            \\\"Collateral split registry\\\"\\n        );\\n        collateralSplitRegistry = IAddressRegistry(_collateralSplitRegistry);\\n    }\\n\\n    function pauseVault(address _vault) public onlyOwner {\\n        IPausableVault(_vault).pause();\\n    }\\n\\n    function unpauseVault(address _vault) public onlyOwner {\\n        IPausableVault(_vault).unpause();\\n    }\\n\\n    function setDerivativeSpecification(address _value) external {\\n        derivativeSpecificationRegistry.set(_value);\\n    }\\n\\n    function setOracle(address _value) external {\\n        oracleRegistry.set(_value);\\n    }\\n\\n    function setOracleIterator(address _value) external {\\n        oracleIteratorRegistry.set(_value);\\n    }\\n\\n    function setCollateralToken(address _value) external {\\n        collateralTokenRegistry.set(_value);\\n    }\\n\\n    function setCollateralSplit(address _value) external {\\n        collateralSplitRegistry.set(_value);\\n    }\\n\\n    /// @notice Returns vault based on internal index\\n    /// @param _index internal vault index\\n    /// @return vault address\\n    function getVault(uint256 _index) external view returns (address) {\\n        return _vaults[_index];\\n    }\\n\\n    /// @notice Get last created vault index\\n    /// @return last created vault index\\n    function getLastVaultIndex() external view returns (uint256) {\\n        return _vaults.length - 1;\\n    }\\n\\n    /// @notice Get all previously created vaults\\n    /// @return all previously created vaults\\n    function getAllVaults() external view returns (address[] memory) {\\n        return _vaults;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/libs/@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/IDerivativeSpecification.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\n/// @title Derivative Specification interface\\n/// @notice Immutable collection of derivative attributes\\n/// @dev Created by the derivative's author and published to the DerivativeSpecificationRegistry\\ninterface IDerivativeSpecification {\\n    /// @notice Proof of a derivative specification\\n    /// @dev Verifies that contract is a derivative specification\\n    /// @return true if contract is a derivative specification\\n    function isDerivativeSpecification() external pure returns (bool);\\n\\n    /// @notice Set of oracles that are relied upon to measure changes in the state of the world\\n    /// between the start and the end of the Live period\\n    /// @dev Should be resolved through OracleRegistry contract\\n    /// @return oracle symbols\\n    function oracleSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Algorithm that, for the type of oracle used by the derivative,\\n    /// finds the value closest to a given timestamp\\n    /// @dev Should be resolved through OracleIteratorRegistry contract\\n    /// @return oracle iterator symbols\\n    function oracleIteratorSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Type of collateral that users submit to mint the derivative\\n    /// @dev Should be resolved through CollateralTokenRegistry contract\\n    /// @return collateral token symbol\\n    function collateralTokenSymbol() external view returns (bytes32);\\n\\n    /// @notice Mapping from the change in the underlying variable (as defined by the oracle)\\n    /// and the initial collateral split to the final collateral split\\n    /// @dev Should be resolved through CollateralSplitRegistry contract\\n    /// @return collateral split symbol\\n    function collateralSplitSymbol() external view returns (bytes32);\\n\\n    /// @notice Lifecycle parameter that define the length of the derivative's Live period.\\n    /// @dev Set in seconds\\n    /// @return live period value\\n    function livePeriod() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of primary asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of primary asset\\n    /// @return primary nominal value\\n    function primaryNominalValue() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of complement asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of complement asset\\n    /// @return complement nominal value\\n    function complementNominalValue() external view returns (uint256);\\n\\n    /// @notice Minting fee rate due to the author of the derivative specification.\\n    /// @dev Percentage fee multiplied by 10 ^ 12\\n    /// @return author fee\\n    function authorFee() external view returns (uint256);\\n\\n    /// @notice Symbol of the derivative\\n    /// @dev Should be resolved through DerivativeSpecificationRegistry contract\\n    /// @return derivative specification symbol\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Return optional long name of the derivative\\n    /// @dev Isn't used directly in the protocol\\n    /// @return long name\\n    function name() external view returns (string memory);\\n\\n    /// @notice Optional URI to the derivative specs\\n    /// @dev Isn't used directly in the protocol\\n    /// @return URI to the derivative specs\\n    function baseURI() external view returns (string memory);\\n\\n    /// @notice Derivative spec author\\n    /// @dev Used to set and receive author's fee\\n    /// @return address of the author\\n    function author() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/registries/IAddressRegistry.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IAddressRegistry {\\n    function get(bytes32 _key) external view returns (address);\\n\\n    function set(address _value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IVaultBuilder.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IVaultBuilder {\\n    function buildVault(\\n        uint256 _liveTime,\\n        uint256 _protocolFee,\\n        address _feeWallet,\\n        address _derivativeSpecification,\\n        address _collateralToken,\\n        address[] calldata _oracles,\\n        address[] calldata _oracleIterators,\\n        address _collateralSplit,\\n        address _tokenBuilder,\\n        address _feeLogger,\\n        uint256 _authorFeeLimit,\\n        uint256 _settlementDelay\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/IPausableVault.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IPausableVault {\\n    function pause() external;\\n\\n    function unpause() external;\\n}\\n\"\r\n    },\r\n    \"contracts/libs/@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\nimport \\\"../Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract ContextUpgradeSafe is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {}\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/libs/@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private initializing;\\n\\n    /**\\n     * @dev Modifier to use in the initializer function of a contract.\\n     */\\n    modifier initializer() {\\n        require(\\n            initializing || isConstructor() || !initialized,\\n            \\\"Contract instance has already been initialized\\\"\\n        );\\n\\n        bool isTopLevelCall = !initializing;\\n        if (isTopLevelCall) {\\n            initializing = true;\\n            initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        address self = address(this);\\n        uint256 cs;\\n        assembly {\\n            cs := extcodesize(self)\\n        }\\n        return cs == 0;\\n    }\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"derivativeSymbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"specification\",\"type\":\"address\"}],\"name\":\"VaultCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authorFeeLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralSplitRegistry\",\"outputs\":[{\"internalType\":\"contract IAddressRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralTokenRegistry\",\"outputs\":[{\"internalType\":\"contract IAddressRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_derivativeSymbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_liveTime\",\"type\":\"uint256\"}],\"name\":\"createVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"derivativeSpecificationRegistry\",\"outputs\":[{\"internalType\":\"contract IAddressRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLogger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastVaultIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_derivativeSpecificationRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracleRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracleIteratorRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralTokenRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralSplitRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenBuilder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeLogger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_authorFeeLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_vaultBuilder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_settlementDelay\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleIteratorRegistry\",\"outputs\":[{\"internalType\":\"contract IAddressRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleRegistry\",\"outputs\":[{\"internalType\":\"contract IAddressRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"pauseVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_authorFeeLimit\",\"type\":\"uint256\"}],\"name\":\"setAuthorFeeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"setCollateralSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralSplitRegistry\",\"type\":\"address\"}],\"name\":\"setCollateralSplitRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"setCollateralToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralTokenRegistry\",\"type\":\"address\"}],\"name\":\"setCollateralTokenRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"setDerivativeSpecification\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_derivativeSpecificationRegistry\",\"type\":\"address\"}],\"name\":\"setDerivativeSpecificationRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeLogger\",\"type\":\"address\"}],\"name\":\"setFeeLogger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"setOracleIterator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleIteratorRegistry\",\"type\":\"address\"}],\"name\":\"setOracleIteratorRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleRegistry\",\"type\":\"address\"}],\"name\":\"setOracleRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"}],\"name\":\"setProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_settlementDelay\",\"type\":\"uint256\"}],\"name\":\"setSettlementDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenBuilder\",\"type\":\"address\"}],\"name\":\"setTokenBuilder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultBuilder\",\"type\":\"address\"}],\"name\":\"setVaultBuilder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenBuilder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"unpauseVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultBuilder\",\"outputs\":[{\"internalType\":\"contract IVaultBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VaultFactory","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}