{"status":"1","message":"OK","result":[{"SourceCode":"// File contracts/interface/IVerifyAttestation.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n/* Retort contract for handling offer commitment and 'transmogrification' of NFTs */\r\n/* AlphaWallet 2021 */\r\n\r\npragma solidity ^0.8.4;\r\n\r\nstruct ERC721Token { \r\n        address erc721;\r\n        uint256 tokenId;\r\n        bytes auth; // authorisation; null if underlying contract doesn't support it\r\n}\r\n\r\ninterface IVerifyAttestation {\r\n    function verifyNFTAttestation(bytes memory attestation, address attestorAddress, address sender) external pure returns(ERC721Token[] memory tokens, string memory identifier, address payable subject, bool isValid);\r\n    function verifyNFTAttestation(bytes memory attestation) external pure returns(ERC721Token[] memory tokens, string memory identifier, address payable subject, address attestorAddress);\r\n    function getNFTAttestationTimestamp(bytes memory attestation) external pure returns(string memory startTime, string memory endTime);\r\n    function checkAttestationValidity(bytes memory nftAttestation, ERC721Token[] memory commitmentNFTs,\r\n        string memory commitmentIdentifier, address attestorAddress, address sender) external pure returns(bool passedVerification, address payable subjectAddress);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/cryptography/ECDSA.sol@v4.1.0\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n        } else if (signature.length == 64) {\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                let vs := mload(add(signature, 0x40))\r\n                r := mload(add(signature, 0x20))\r\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\r\n                v := add(shr(255, vs), 27)\r\n            }\r\n        } else {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        return recover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Typed Data, created from a\r\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n     * to the one signed with the\r\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n     * JSON-RPC method as part of EIP-712.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/VerifyAttestation.sol\r\n\r\n\r\n/* Attestation decode and validation */\r\n/* AlphaWallet 2021 */\r\n\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\ncontract VerifyAttestation is IVerifyAttestation {\r\n    address payable owner;\r\n\r\n    constructor()\r\n    {\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    struct Length {\r\n        uint decodeIndex;\r\n        uint length;\r\n    }\r\n\r\n    function verifyPublicAttestation(bytes memory attestation, uint256 nIndex) public pure returns(address payable subject, string memory identifier, address attestorAddress)\r\n    {\r\n        bytes memory attestationData;\r\n        bytes memory preHash;\r\n\r\n        uint256 decodeIndex = 0;\r\n        uint256 length = 0;\r\n\r\n        /*\r\n        Attestation structure:\r\n            Length, Length\r\n            - Version,\r\n            - Serial,\r\n            - Signature type,\r\n            - Issuer Sequence,\r\n            - Validity Time period Start, finish\r\n        */\r\n        \r\n        (length, nIndex) = decodeLength(attestation, nIndex+1); //nIndex is start of prehash\r\n        \r\n        (length, decodeIndex) = decodeLength(attestation, nIndex+1); // length of prehash is decodeIndex (result) - nIndex\r\n\r\n        //obtain pre-hash\r\n        preHash = copyDataBlock(attestation, nIndex, (decodeIndex + length) - nIndex);\r\n\r\n        nIndex = (decodeIndex + length); //set pointer to read data after the pre-hash block\r\n\r\n        (length, decodeIndex) = decodeLength(preHash, 1); //read pre-hash header\r\n\r\n        (length, decodeIndex) = decodeLength(preHash, decodeIndex + 1); // Version\r\n\r\n        (length, decodeIndex) = decodeLength(preHash, decodeIndex + 1 + length); // Serial\r\n\r\n        (length, decodeIndex) = decodeLength(preHash, decodeIndex + 1 + length); // Signature type (9) 1.2.840.10045.2.1\r\n\r\n        (length, decodeIndex) = decodeLength(preHash, decodeIndex + 1 + length); // Issuer Sequence (14) [[2.5.4.3, ALX]]], (Issuer: CN=ALX)\r\n\r\n        (length, attestationData, decodeIndex) = decodeElement(preHash, decodeIndex + length); // Validity Time (34) (Start, End) 32303231303331343030303835315A, 32303231303331343031303835315A\r\n        \r\n        (length, decodeIndex) = decodeLength(preHash, decodeIndex + 1); \r\n        (length, attestationData, decodeIndex) = decodeElementOffset(preHash, decodeIndex, 15); //Twitter ID\r\n        \r\n        identifier = copyStringBlock(attestationData);\r\n\r\n        (length, decodeIndex) = decodeLength(preHash, decodeIndex + 1);\r\n        (length, decodeIndex) = decodeLength(preHash, decodeIndex + 1);\r\n        \r\n        (length, attestationData, decodeIndex) = decodeElementOffset(preHash, decodeIndex + length, 2); // public key\r\n        \r\n        subject = payable(publicKeyToAddress(attestationData));\r\n\r\n        (length, attestationData, nIndex) = decodeElement(attestation, nIndex); // Signature algorithm ID (9) 1.2.840.10045.2.1\r\n\r\n        (length, attestationData, nIndex) = decodeElementOffset(attestation, nIndex, 1); // Signature (72) : #0348003045022100F1862F9616B43C1F1550156341407AFB11EEC8B8BB60A513B346516DBC4F1F3202204E1B19196B97E4AECD6AE7E701BF968F72130959A01FCE83197B485A6AD2C7EA\r\n\r\n        //return attestorPass && subjectPass && identifierPass;\r\n        attestorAddress = recoverSigner(keccak256(preHash), attestationData);\r\n    }\r\n    \r\n    function getTokenInformation(bytes memory attestation, uint256 nIndex) public pure returns(ERC721Token[] memory tokens)\r\n    {\r\n        //currently format only handles one token\r\n        uint256 length = 0;\r\n        bytes memory tokenData;\r\n        \r\n        (length, nIndex) = decodeLength(attestation, nIndex+1); //move past overall size (312) ([4])\r\n        (length, nIndex) = decodeLength(attestation, nIndex+1); //move past attestation size (281)   \r\n        nIndex += length;\r\n        \r\n        (length, nIndex) = decodeLength(attestation, nIndex+1);\r\n        \r\n        uint256 tokenCount = length / 25;\r\n        \r\n        tokens = new ERC721Token[](tokenCount);\r\n        address tokenAddr;\r\n        \r\n        for (uint256 index = 0; index < tokenCount; index++)\r\n        {\r\n            (length, tokenData, nIndex) = decodeElement(attestation, nIndex+2);\r\n            //to address\r\n            bytes memory scratch = new bytes(32);\r\n            assembly { \r\n                mstore(add(scratch, 44), mload(add(tokenData, 0x20))) //load address data to final bytes160 of scratch\r\n                tokenAddr := mload(add(scratch, 0x20))                //directly convert to address\r\n                mstore(add(scratch, 32), 0x00) //blank scratch for use as auth placeholder\r\n            }\r\n        \r\n            (length, tokenData, nIndex) = decodeElement(attestation, nIndex);\r\n            tokens[index] = ERC721Token(tokenAddr, bytesToUint(tokenData), scratch);\r\n        }\r\n    }\r\n\r\n    // Leave this function public as a utility function to check attestation against commitmentmentId\r\n    // The check takes into account the NFTs signed by the SignedNFTAttestation vs those stored in the commitment\r\n    function checkAttestationValidity(bytes memory nftAttestation, ERC721Token[] memory commitmentNFTs,\r\n        string memory commitmentIdentifier, address attestorAddress, address sender) public override pure returns(bool passedVerification, address payable subjectAddress)\r\n    {\r\n        ERC721Token[] memory attestationNFTs;\r\n        string memory attestationIdentifier;\r\n        (attestationNFTs, attestationIdentifier, subjectAddress, passedVerification)\r\n                = verifyNFTAttestation(nftAttestation, attestorAddress, sender);\r\n                \r\n        passedVerification = passedVerification && \r\n                checkValidity(attestationNFTs, commitmentNFTs, commitmentIdentifier, attestationIdentifier);\r\n    }\r\n\r\n    // Check that the attestion tokens match the commitment tokens \r\n    // And that the identifier in the attestation matches the identifier in the commitment \r\n    function checkValidity(ERC721Token[] memory attestationNFTs, ERC721Token[] memory commitmentNFTs, string memory commitIdentifier, \r\n        string memory attestationIdentifier) internal pure returns(bool)\r\n    {\r\n        //check that the tokens in the attestation match those in the commitment\r\n        if (attestationNFTs.length != commitmentNFTs.length)\r\n        {\r\n            return false;\r\n        }\r\n        else \r\n        {\r\n            //check each token. NB Tokens must be in same order in original commitment package as in attestation package\r\n            for (uint256 index = 0; index < attestationNFTs.length; index++)\r\n            {\r\n                if (attestationNFTs[index].erc721 != commitmentNFTs[index].erc721\r\n                    || attestationNFTs[index].tokenId != commitmentNFTs[index].tokenId)\r\n                {\r\n                    return false;\r\n                }    \r\n            }\r\n            \r\n            //now check identifiers match if attestation is still passing\r\n            return checkIdentifier(attestationIdentifier, commitIdentifier);\r\n        }\r\n    }\r\n\r\n    // In production we need to match the full string, as the second part of the attestation is the unique ID\r\n    function checkIdentifier(string memory attestationId, string memory checkId) internal pure returns(bool)\r\n    {\r\n        return (keccak256(abi.encodePacked((attestationId))) == \r\n                    keccak256(abi.encodePacked((checkId))));\r\n    }\r\n\r\n    function messageWithPrefix(bytes memory preHash) public pure returns (bytes32 hash)\r\n    {\r\n        uint256 dataLength;\r\n        uint256 length = 3;\r\n        assembly {\r\n            dataLength := mload(preHash)\r\n            if gt(dataLength, 999) { length := 4 }\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint256 k = length;\r\n        uint256 j = dataLength;\r\n        while (j != 0)\r\n        {\r\n            bstr[--k] = bytes1(uint8(48 + j % 10));\r\n            j /= 10;\r\n        }\r\n        \r\n        bytes memory str = abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", bstr, preHash);\r\n        hash = keccak256(str);\r\n    }\r\n\r\n    function getNFTAttestationTimestamp(bytes memory attestation) public override pure returns(string memory startTime, string memory endTime) \r\n    {\r\n        uint256 length = 0;\r\n        uint256 nIndex = 0;\r\n        bytes memory timeData;\r\n\r\n        (length, nIndex) = decodeLength(attestation, nIndex+1); //move past overall size\r\n        (length, nIndex) = decodeLength(attestation, nIndex+1); //move past token wrapper size  \r\n\r\n        //now into PublicAttestation\r\n        (length, nIndex) = decodeLength(attestation, nIndex+1); //nIndex is start of prehash\r\n        \r\n        (length, nIndex) = decodeLength(attestation, nIndex+1); // length of prehash is decodeIndex (result) - nIndex\r\n\r\n        (length, nIndex) = decodeLength(attestation, nIndex + 1); // Version\r\n\r\n        (length, nIndex) = decodeLength(attestation, nIndex + 1 + length); // Serial\r\n\r\n        (length, nIndex) = decodeLength(attestation, nIndex + 1 + length); // Signature type (9) 1.2.840.10045.2.1\r\n        \r\n        //startTime = nIndex;\r\n\r\n        (length, nIndex) = decodeLength(attestation, nIndex + 1 + length); // Issuer Sequence (14) [[2.5.4.3, ALX]]], (Issuer: CN=ALX)\r\n        \r\n        (length, nIndex) = decodeLength(attestation, nIndex + 1 + length); // Time sequence header\r\n        \r\n        (length, timeData, nIndex) = decodeElement(attestation, nIndex);\r\n        startTime = copyStringBlock(timeData);\r\n        (length, timeData, nIndex) = decodeElement(attestation, nIndex);\r\n        endTime = copyStringBlock(timeData);\r\n    }\r\n\r\n    function verifyNFTAttestation(bytes memory attestation) public override pure returns(ERC721Token[] memory tokens, string memory identifier, address payable subject, address attestorAddress)\r\n    {\r\n        bool isValid;\r\n        (tokens, identifier, subject, attestorAddress, isValid) = verifyNFTAttestation(attestation, address(0));\r\n\r\n        if (!isValid)\r\n        {\r\n            identifier = \"\";\r\n            subject = payable(address(0));\r\n            attestorAddress = address(0);\r\n        }\r\n    }\r\n    \r\n    function verifyNFTAttestation(bytes memory attestation, address attestorAddress, address sender) public override pure returns(ERC721Token[] memory tokens, string memory identifier, address payable subject, bool isValid)\r\n    {\r\n        address receivedAttestorAddress;\r\n        (tokens, identifier, subject, receivedAttestorAddress, isValid) = verifyNFTAttestation(attestation, sender);\r\n        \r\n        isValid = isValid && (receivedAttestorAddress == attestorAddress);\r\n    }\r\n    \r\n    function verifyNFTAttestation(bytes memory attestation, address sender) public pure returns(ERC721Token[] memory tokens, string memory identifier, address payable subject, address attestorAddress, bool isValid)\r\n    {\r\n        bytes memory signatureData;\r\n        uint256 nIndex = 1;\r\n        uint256 length = 0;\r\n        uint256 preHashStart = 0;\r\n        uint256 preHashLength = 0;\r\n\r\n        (length, nIndex) = decodeLength(attestation, nIndex); //move past overall size (395)\r\n        preHashStart = nIndex;\r\n        tokens = getTokenInformation(attestation, nIndex); // handle tokenData  \r\n        (length, nIndex) = decodeLength(attestation, nIndex+1); //move past token wrapper size   (312)\r\n        preHashLength = length + (nIndex - preHashStart);\r\n        (subject, identifier, attestorAddress) = verifyPublicAttestation(attestation, nIndex); //pull out subject, identifier and check attesting signature\r\n        \r\n        //If the sender is the NFT subject, then no need to check the wrapping signature, the intention is signed from transaction\r\n        if (subject != sender)\r\n        {\r\n            //check wrapping signature equals subject signature\r\n            nIndex += length;\r\n            (length, nIndex) = decodeLength(attestation, nIndex+1); //move past the signature type\r\n            (length, signatureData, nIndex) = decodeElementOffset(attestation, nIndex+length, 1); //extract signature\r\n            bytes memory preHash = copyDataBlock(attestation, preHashStart, preHashLength);\r\n            //check SignedNFTAddress\r\n            isValid = (recoverSigner(messageWithPrefix(preHash), signatureData) == subject); //Note we sign with SignPersonal\r\n        }\r\n        else\r\n        {\r\n            isValid = true;\r\n        }\r\n    }\r\n    \r\n    function publicKeyToAddress(bytes memory publicKey) pure internal returns(address)\r\n    {\r\n        return address(uint160(uint256(keccak256(publicKey))));\r\n    }\r\n\r\n    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns(address signer)\r\n    {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\r\n\r\n        return ECDSA.recover(hash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(bytes memory sig)\r\n        internal pure returns (bytes32 r, bytes32 s, uint8 v)\r\n    {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n\r\n        // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n        // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n        // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n    }\r\n    \r\n    //Truncates if input is greater than 32 bytes; we only handle 32 byte values.\r\n    function bytesToUint(bytes memory b) internal pure returns (uint256 conv)\r\n    {\r\n        if (b.length < 0x20) //if b is less than 32 bytes we need to pad to get correct value\r\n        {\r\n            bytes memory b2 = new bytes(32);\r\n            uint startCopy = 0x20 + 0x20 - b.length;\r\n            assembly\r\n            {\r\n                let bcc := add(b, 0x20)         // pointer to start of b's data\r\n                let bbc := add(b2, startCopy)   // pointer to where we want to start writing to b2's data\r\n                mstore(bbc, mload(bcc))         // store\r\n                conv := mload(add(b2, 32))\r\n            }\r\n        }\r\n        else\r\n        {\r\n            assembly\r\n            {\r\n                conv := mload(add(b, 32))\r\n            }\r\n        }\r\n    }\r\n\r\n    function decodeDERData(bytes memory byteCode, uint dIndex) internal pure returns(bytes memory data, uint256 index, uint256 length)\r\n    {\r\n        return decodeDERData(byteCode, dIndex, 0);\r\n    }\r\n\r\n    function copyDataBlock(bytes memory byteCode, uint dIndex, uint length) internal pure returns(bytes memory data)\r\n    {\r\n        uint256 blank = 0;\r\n        uint256 index = dIndex;\r\n\r\n        uint dStart = 0x20 + index;\r\n        uint cycles = length / 0x20;\r\n        uint requiredAlloc = length;\r\n\r\n        if (length % 0x20 > 0) //optimise copying the final part of the bytes - remove the looping\r\n        {\r\n            cycles++;\r\n            requiredAlloc += 0x20; //expand memory to allow end blank\r\n        }\r\n\r\n        data = new bytes(requiredAlloc);\r\n\r\n        assembly {\r\n            let mc := add(data, 0x20) //offset into bytes we're writing into\r\n            let cycle := 0\r\n\r\n            for\r\n            {\r\n                let cc := add(byteCode, dStart)\r\n            } lt(cycle, cycles) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n                cycle := add(cycle, 0x01)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n        }\r\n\r\n        //finally blank final bytes and shrink size\r\n        if (length % 0x20 > 0)\r\n        {\r\n            uint offsetStart = 0x20 + length;\r\n            assembly\r\n            {\r\n                let mc := add(data, offsetStart)\r\n                mstore(mc, mload(add(blank, 0x20)))\r\n            //now shrink the memory back\r\n                mstore(data, length)\r\n            }\r\n        }\r\n    }\r\n    \r\n    function copyStringBlock(bytes memory byteCode) internal pure returns(string memory stringData)\r\n    {\r\n        uint256 blank = 0; //blank 32 byte value\r\n        uint256 length = byteCode.length;\r\n\r\n        uint cycles = byteCode.length / 0x20;\r\n        uint requiredAlloc = length;\r\n\r\n        if (length % 0x20 > 0) //optimise copying the final part of the bytes - to avoid looping with single byte writes\r\n        {\r\n            cycles++;\r\n            requiredAlloc += 0x20; //expand memory to allow end blank, so we don't smack the next stack entry\r\n        }\r\n\r\n        stringData = new string(requiredAlloc);\r\n\r\n        //copy data in 32 byte blocks\r\n        assembly {\r\n            let cycle := 0\r\n\r\n            for\r\n            {\r\n                let mc := add(stringData, 0x20) //pointer into bytes we're writing to\r\n                let cc := add(byteCode, 0x20)   //pointer to where we're reading from\r\n            } lt(cycle, cycles) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n                cycle := add(cycle, 0x01)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n        }\r\n\r\n        //finally blank final bytes and shrink size (part of the optimisation to avoid looping adding blank bytes1)\r\n        if (length % 0x20 > 0)\r\n        {\r\n            uint offsetStart = 0x20 + length;\r\n            assembly\r\n            {\r\n                let mc := add(stringData, offsetStart)\r\n                mstore(mc, mload(add(blank, 0x20)))\r\n                //now shrink the memory back so the returned object is the correct size\r\n                mstore(stringData, length)\r\n            }\r\n        }\r\n    }\r\n\r\n    function decodeDERData(bytes memory byteCode, uint dIndex, uint offset) internal pure returns(bytes memory data, uint256 index, uint256 length)\r\n    {\r\n        index = dIndex + 1;\r\n\r\n        (length, index) = decodeLength(byteCode, index);\r\n        \r\n        if (offset <= length)\r\n        {\r\n            uint requiredLength = length - offset;\r\n            uint dStart = index + offset;\r\n\r\n            data = copyDataBlock(byteCode, dStart, requiredLength);\r\n        }\r\n        else\r\n        {\r\n            data = bytes(\"\");\r\n        }\r\n\r\n        index += length;\r\n    }\r\n\r\n    function decodeElement(bytes memory byteCode, uint decodeIndex) internal pure returns(uint256 length, bytes memory content, uint256 newIndex)\r\n    {\r\n        (content, newIndex, length) = decodeDERData(byteCode, decodeIndex);\r\n    }\r\n\r\n    function decodeElementOffset(bytes memory byteCode, uint decodeIndex, uint offset) internal pure returns(uint256 length, bytes memory content, uint256 newIndex)\r\n    {\r\n        (content, newIndex, length) = decodeDERData(byteCode, decodeIndex, offset);\r\n    }\r\n\r\n    function decodeLength(bytes memory byteCode, uint decodeIndex) internal pure returns(uint256 length, uint256 newIndex)\r\n    {\r\n        uint codeLength = 1;\r\n        length = 0;\r\n        newIndex = decodeIndex;\r\n\r\n        if ((byteCode[newIndex] & 0x80) == 0x80)\r\n        {\r\n            codeLength = uint8((byteCode[newIndex++] & 0x7f));\r\n        }\r\n\r\n        for (uint i = 0; i < codeLength; i++)\r\n        {\r\n            length |= uint(uint8(byteCode[newIndex++] & 0xFF)) << ((codeLength - i - 1) * 8);\r\n        }\r\n    }\r\n\r\n    function decodeIA5String(bytes memory byteCode, uint256[] memory objCodes, uint objCodeIndex, uint decodeIndex) internal pure returns(Status memory)\r\n    {\r\n        uint length = uint8(byteCode[decodeIndex++]);\r\n        bytes32 store = 0;\r\n        for (uint j = 0; j < length; j++) store |= bytes32(byteCode[decodeIndex++] & 0xFF) >> (j * 8);\r\n        objCodes[objCodeIndex++] = uint256(store);\r\n        Status memory retVal;\r\n        retVal.decodeIndex = decodeIndex;\r\n        retVal.objCodeIndex = objCodeIndex;\r\n\r\n        return retVal;\r\n    }\r\n    \r\n    function mapTo256BitInteger(bytes memory input) internal pure returns(uint256 res)\r\n    {\r\n        bytes32 idHash = keccak256(input);\r\n        res = uint256(idHash);\r\n    }\r\n    \r\n    struct Status {\r\n        uint decodeIndex;\r\n        uint objCodeIndex;\r\n    }\r\n\r\n    function endContract() public payable\r\n    {\r\n        if(msg.sender == owner)\r\n        {\r\n            selfdestruct(owner);\r\n        }\r\n        else revert();\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"nftAttestation\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"auth\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC721Token[]\",\"name\":\"commitmentNFTs\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"commitmentIdentifier\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"attestorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"checkAttestationValidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"passedVerification\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"subjectAddress\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"attestation\",\"type\":\"bytes\"}],\"name\":\"getNFTAttestationTimestamp\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"startTime\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"endTime\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"attestation\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nIndex\",\"type\":\"uint256\"}],\"name\":\"getTokenInformation\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"auth\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC721Token[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"preHash\",\"type\":\"bytes\"}],\"name\":\"messageWithPrefix\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"attestation\",\"type\":\"bytes\"}],\"name\":\"verifyNFTAttestation\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"auth\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC721Token[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"identifier\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"attestorAddress\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"attestation\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"attestorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"verifyNFTAttestation\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"auth\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC721Token[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"identifier\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"attestation\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"verifyNFTAttestation\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"auth\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC721Token[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"identifier\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"attestorAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"attestation\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nIndex\",\"type\":\"uint256\"}],\"name\":\"verifyPublicAttestation\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"identifier\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"attestorAddress\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"VerifyAttestation","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://75fc6ee2fbf92fea1ac9b2eec1bdd572e54f3e2f1539f7d6640d59244ca4f187"}]}