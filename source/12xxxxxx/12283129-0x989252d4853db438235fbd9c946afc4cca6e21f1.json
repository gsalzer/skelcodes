{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.2.0 https://hardhat.org\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.0.0\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/IQLF.sol\r\n\r\n\r\n/**\r\n * @author          Yisi Liu\r\n * @contact         yisiliu@gmail.com\r\n * @author_time     01/06/2021\r\n**/\r\n\r\npragma solidity >= 0.8.0;\r\n\r\nabstract contract IQLF is IERC165 {\r\n    /**\r\n     * @dev Returns if the given address is qualified, implemented on demand.\r\n     */\r\n    function ifQualified (address account) virtual external view returns (bool);\r\n\r\n    /**\r\n     * @dev Logs if the given address is qualified, implemented on demand.\r\n     */\r\n    function logQualified (address account, uint256 ito_start_time) virtual external returns (bool);\r\n\r\n    /**\r\n     * @dev Ensure that custom contract implements `ifQualified` amd `logQualified` correctly.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) virtual external override pure returns (bool) {\r\n        return interfaceId == this.supportsInterface.selector || \r\n            interfaceId == (this.ifQualified.selector ^ this.logQualified.selector);\r\n    }\r\n\r\n    /**\r\n     * @dev Emit when `ifQualified` is called to decide if the given `address`\r\n     * is `qualified` according to the preset rule by the contract creator and \r\n     * the current block `number` and the current block `timestamp`.\r\n     */\r\n    event Qualification(address account, bool qualified, uint256 blockNumber, uint256 timestamp);\r\n}\r\n\r\n\r\n// File contracts/qualification.sol\r\n\r\n\r\n/**\r\n * @author          Yisi Liu\r\n * @contact         yisiliu@gmail.com\r\n * @author_time     01/06/2021\r\n**/\r\n\r\npragma solidity >= 0.8.0;\r\n\r\ncontract QLF is IQLF {\r\n    string private name;\r\n    uint256 private creation_time;\r\n    uint256 start_time;\r\n    address creator;\r\n    mapping(address => bool) black_list;\r\n\r\n    modifier creatorOnly {\r\n        require(msg.sender == creator, \"Not Authorized\");\r\n        _;\r\n    }\r\n\r\n    constructor (string memory _name, uint256 _start_time) {\r\n        name = _name;\r\n        creation_time = block.timestamp;\r\n        start_time = _start_time;\r\n        creator = msg.sender;\r\n    }\r\n\r\n    function get_name() public view returns (string memory) {\r\n        return name;\r\n    }\r\n\r\n    function get_creation_time() public view returns (uint256) {\r\n        return creation_time;\r\n    }\r\n\r\n    function get_start_time() public view returns (uint256) {\r\n        return start_time;\r\n    }\r\n\r\n    function set_start_time(uint256 _start_time) public creatorOnly {\r\n        start_time = _start_time;\r\n    }\r\n\r\n    function ifQualified(address) public pure override returns (bool qualified) {\r\n        qualified = true;\r\n    } \r\n\r\n    function logQualified(address account, uint256 ito_start_time) public override returns (bool qualified) {\r\n        if (start_time > block.timestamp || ito_start_time > block.timestamp) {\r\n            black_list[address(msg.sender)] = true;\r\n            return false;\r\n        }\r\n        if (black_list[msg.sender]) {\r\n            return false;\r\n        }\r\n        emit Qualification(account, true, block.number, block.timestamp);\r\n        return true;\r\n    } \r\n\r\n    function supportsInterface(bytes4 interfaceId) external override pure returns (bool) {\r\n        return interfaceId == this.supportsInterface.selector || \r\n            interfaceId == (this.ifQualified.selector ^ this.logQualified.selector) ||\r\n            interfaceId == this.get_start_time.selector;\r\n    }    \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_start_time\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"qualified\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Qualification\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"get_creation_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_start_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ifQualified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"qualified\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ito_start_time\",\"type\":\"uint256\"}],\"name\":\"logQualified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"qualified\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start_time\",\"type\":\"uint256\"}],\"name\":\"set_start_time\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"QLF","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000744454641554c5400000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9900e0e967b6d7ae740e339416f52c286c09c35433b67fa662e7fca21a763a11"}]}