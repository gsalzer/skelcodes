{"status":"1","message":"OK","result":[{"SourceCode":"{\"FactRegistry.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"IQueryableFactRegistry.sol\\\";\\n\\ncontract FactRegistry is IQueryableFactRegistry {\\n    // Mapping: fact hash -\\u003e true.\\n    mapping (bytes32 =\\u003e bool) private verifiedFact;\\n\\n    // Indicates whether the Fact Registry has at least one fact registered.\\n    bool anyFactRegistered;\\n\\n    /*\\n      Checks if a fact has been verified.\\n    */\\n    function isValid(bytes32 fact)\\n        external view override\\n        returns(bool)\\n    {\\n        return _factCheck(fact);\\n    }\\n\\n\\n    /*\\n      This is an internal method to check if the fact is already registered.\\n      In current implementation of FactRegistry it\\u0027s identical to isValid().\\n      But the check is against the local fact registry,\\n      So for a derived referral fact registry, it\\u0027s not the same.\\n    */\\n    function _factCheck(bytes32 fact)\\n        internal view\\n        returns(bool)\\n    {\\n        return verifiedFact[fact];\\n    }\\n\\n    function registerFact(\\n        bytes32 factHash\\n        )\\n        internal\\n    {\\n        // This function stores the fact hash in the mapping.\\n        verifiedFact[factHash] = true;\\n\\n        // Mark first time off.\\n        if (!anyFactRegistered) {\\n            anyFactRegistered = true;\\n        }\\n    }\\n\\n    /*\\n      Indicates whether at least one fact was registered.\\n    */\\n    function hasRegisteredFact()\\n        external view override\\n        returns(bool)\\n    {\\n        return anyFactRegistered;\\n    }\\n\\n}\\n\"},\"Identity.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\ninterface Identity {\\n\\n    /*\\n      Allows a caller, typically another contract,\\n      to ensure that the provided address is of the expected type and version.\\n    */\\n    function identify()\\n        external pure\\n        returns(string memory);\\n}\\n\"},\"IFactRegistry.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\n/*\\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\\n  business logic of the contract flow.\\n\\n  A fact registry holds a hash table of verified \\\"facts\\\" which are represented by a hash of claims\\n  that the registry hash check and found valid. This table may be queried by accessing the\\n  isValid() function of the registry with a given hash.\\n\\n  In addition, each fact registry exposes a registry specific function for submitting new claims\\n  together with their proofs. The information submitted varies from one registry to the other\\n  depending of the type of fact requiring verification.\\n\\n  For further reading on the Fact Registry design pattern see this\\n  `StarkWare blog post \\u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\\u003e`_.\\n*/\\ninterface IFactRegistry {\\n    /*\\n      Returns true if the given fact was previously registered in the contract.\\n    */\\n    function isValid(bytes32 fact)\\n        external view\\n        returns(bool);\\n}\\n\"},\"IQueryableFactRegistry.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"IFactRegistry.sol\\\";\\n\\n/*\\n  Extends the IFactRegistry interface with a query method that indicates\\n  whether the fact registry has successfully registered any fact or is still empty of such facts.\\n*/\\ninterface IQueryableFactRegistry is IFactRegistry {\\n\\n    /*\\n      Returns true if at least one fact has been registered.\\n    */\\n    function hasRegisteredFact()\\n        external view\\n        returns(bool);\\n\\n}\\n\"},\"MessageRegistry.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"Identity.sol\\\";\\nimport \\\"FactRegistry.sol\\\";\\n\\ncontract MessageRegistry is FactRegistry, Identity {\\n    event LogMsgRegistered(address from, address to, bytes32 msgHash);\\n\\n    function identify() external pure virtual override returns (string memory) {\\n        return \\\"StarkWare_MessageRegistry_2021_1\\\";\\n    }\\n\\n    // NOLINTNEXTLINE: external-function.\\n    function registerMessage(address to, bytes32 messageHash) public {\\n        bytes32 messageFact = keccak256(abi.encodePacked(msg.sender, to, messageHash));\\n        registerFact(messageFact);\\n        emit LogMsgRegistered(msg.sender, to, messageHash);\\n    }\\n\\n    function isMessageRegistered(\\n        address from,\\n        address to,\\n        bytes32 messageHash\\n    ) external view returns (bool) {\\n        bytes32 messageFact = keccak256(abi.encodePacked(from, to, messageHash));\\n        return _factCheck(messageFact);\\n    }\\n}\\n\"},\"OrderRegistry.sol\":{\"content\":\"/*\\n  Copyright 2019-2021 StarkWare Industries Ltd.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n  You may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n  https://www.starkware.co/open-source-license/\\n\\n  Unless required by applicable law or agreed to in writing,\\n  software distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions\\n  and limitations under the License.\\n*/\\n// SPDX-License-Identifier: Apache-2.0.\\npragma solidity ^0.6.11;\\n\\nimport \\\"MessageRegistry.sol\\\";\\n\\ncontract OrderRegistry is MessageRegistry {\\n    event LogL1LimitOrderRegistered(\\n        address userAddress,\\n        address exchangeAddress,\\n        uint256 tokenIdSell,\\n        uint256 tokenIdBuy,\\n        uint256 tokenIdFee,\\n        uint256 amountSell,\\n        uint256 amountBuy,\\n        uint256 amountFee,\\n        uint256 vaultIdSell,\\n        uint256 vaultIdBuy,\\n        uint256 vaultIdFee,\\n        uint256 nonce,\\n        uint256 expirationTimestamp\\n    );\\n\\n    uint256 constant MASK_32 = 0xFFFFFFFF;\\n    uint256 constant MASK_64 = 0xFFFFFFFFFFFFFFFF;\\n    uint256 constant LIMIT_ORDER_TYPE = 0x3;\\n\\n    function identify() external pure override returns (string memory) {\\n        return \\\"StarkWare_OrderRegistry_2021_1\\\";\\n    }\\n\\n    function calcL1LimitOrderHash(\\n        uint256 tokenIdSell,\\n        uint256 tokenIdBuy,\\n        uint256 tokenIdFee,\\n        uint256 amountSell,\\n        uint256 amountBuy,\\n        uint256 amountFee,\\n        uint256 vaultIdSell,\\n        uint256 vaultIdBuy,\\n        uint256 vaultIdFee,\\n        uint256 nonce,\\n        uint256 expirationTimestamp\\n    ) public pure returns (bytes32) {\\n        uint256 packed_word0 = amountSell \\u0026 MASK_64;\\n        packed_word0 = (packed_word0 \\u003c\\u003c 64) + (amountBuy \\u0026 MASK_64);\\n        packed_word0 = (packed_word0 \\u003c\\u003c 64) + (amountFee \\u0026 MASK_64);\\n        packed_word0 = (packed_word0 \\u003c\\u003c 32) + (nonce \\u0026 MASK_32);\\n\\n        uint256 packed_word1 = LIMIT_ORDER_TYPE;\\n        packed_word1 = (packed_word1 \\u003c\\u003c 64) + (vaultIdFee \\u0026 MASK_64);\\n        packed_word1 = (packed_word1 \\u003c\\u003c 64) + (vaultIdSell \\u0026 MASK_64);\\n        packed_word1 = (packed_word1 \\u003c\\u003c 64) + (vaultIdBuy \\u0026 MASK_64);\\n        packed_word1 = (packed_word1 \\u003c\\u003c 32) + (expirationTimestamp \\u0026 MASK_32);\\n        packed_word1 = packed_word1 \\u003c\\u003c 17;\\n\\n        return\\n            keccak256(\\n                abi.encode(\\n                    [\\n                        bytes32(tokenIdSell),\\n                        bytes32(tokenIdBuy),\\n                        bytes32(tokenIdFee),\\n                        bytes32(packed_word0),\\n                        bytes32(packed_word1)\\n                    ]\\n                )\\n            );\\n    }\\n\\n    function registerLimitOrder(\\n        address exchangeAddress,\\n        uint256 tokenIdSell,\\n        uint256 tokenIdBuy,\\n        uint256 tokenIdFee,\\n        uint256 amountSell,\\n        uint256 amountBuy,\\n        uint256 amountFee,\\n        uint256 vaultIdSell,\\n        uint256 vaultIdBuy,\\n        uint256 vaultIdFee,\\n        uint256 nonce,\\n        uint256 expirationTimestamp\\n    ) external {\\n        bytes32 orderHash =\\n            calcL1LimitOrderHash(\\n                tokenIdSell,\\n                tokenIdBuy,\\n                tokenIdFee,\\n                amountSell,\\n                amountBuy,\\n                amountFee,\\n                vaultIdSell,\\n                vaultIdBuy,\\n                vaultIdFee,\\n                nonce,\\n                expirationTimestamp\\n            );\\n        registerMessage(exchangeAddress, orderHash);\\n\\n        emit LogL1LimitOrderRegistered(\\n            msg.sender,\\n            exchangeAddress,\\n            tokenIdSell,\\n            tokenIdBuy,\\n            tokenIdFee,\\n            amountSell,\\n            amountBuy,\\n            amountFee,\\n            vaultIdSell,\\n            vaultIdBuy,\\n            vaultIdFee,\\n            nonce,\\n            expirationTimestamp\\n        );\\n    }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIdSell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIdBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIdFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultIdSell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultIdBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultIdFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"name\":\"LogL1LimitOrderRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"LogMsgRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"name\":\"calcL1LimitOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasRegisteredFact\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identify\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"}],\"name\":\"isMessageRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"fact\",\"type\":\"bytes32\"}],\"name\":\"isValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultIdFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"name\":\"registerLimitOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"}],\"name\":\"registerMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OrderRegistry","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://532ee28269b98a2274be6a8e0030b5908b816ed289891bd28a251b7d7fef9938"}]}