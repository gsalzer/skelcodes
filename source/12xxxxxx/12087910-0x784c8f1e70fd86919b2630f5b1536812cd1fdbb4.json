{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.1;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint balance);\r\n    function transfer(address to, uint amount) external returns (bool);\r\n    \r\n    function allowance(address account, address from) external view returns (uint256);\r\n    function approve(address from, uint amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint amount) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed account, address indexed from, uint amount);\r\n}\r\n\r\ncontract TokenWraper {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    IERC20 public _token = IERC20(0x847287E3586dD4Fe7217a050580DdCDC83c73470);\r\n\r\n    uint256 private _totalSupply;\r\n    mapping(address => uint256) private _balances;\r\n\r\n    function totalSupply() public view returns(uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns(uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function _save(uint256 amount) internal {\r\n        _token.transferFrom(msg.sender, address(this), amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\r\n    }\r\n\r\n    function _withdraw(uint256 amount) internal {\r\n        _token.transfer(msg.sender, amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\r\n    }\r\n\r\n    function _removeReward(address founder, uint256 amount) internal {\r\n        _token.transfer(msg.sender, amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[founder] = _balances[founder].sub(amount);\r\n    }\r\n}\r\n\r\ncontract Saving is TokenWraper {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    address public founder;\r\n    uint256 public timeLock = 3 days; // return unix epoch\r\n    uint256 public yearly = 365 days;\r\n    uint256 public percentRewardYearly; // % yearly\r\n    mapping(address => uint256) private savedAmount;\r\n    mapping(address => uint256) private savedTimestamp;\r\n    mapping(address => uint256) public claimRewardAmount;\r\n    mapping(address => uint256) public lockedUntil;\r\n    \r\n    IERC20 public token = IERC20(0x847287E3586dD4Fe7217a050580DdCDC83c73470);\r\n    \r\n    event Saved(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event RewardPaid(address indexed user, uint256 reward);\r\n    \r\n    modifier isFounder() {\r\n        require(msg.sender == founder);\r\n        _;\r\n    }\r\n    \r\n    constructor(uint256 _percentRewardYearly) {\r\n        percentRewardYearly = _percentRewardYearly;\r\n        founder = msg.sender;\r\n    }\r\n    \r\n    function setNewFounder(address newAddress) public isFounder {\r\n        founder = newAddress;\r\n    }\r\n    \r\n    function setPercentRewardYearly(uint256 _percent) public isFounder {\r\n        percentRewardYearly = _percent;\r\n    }\r\n\r\n    function changeOwnership(address _account) public {\r\n        founder = _account;\r\n    }\r\n    \r\n    function rewardBalance() public view returns(uint256) {\r\n        return balanceOf(founder);\r\n    }\r\n    \r\n    function _rewardEarnedPerSecond(address account) public view returns(uint256) {\r\n        if(account == founder) {\r\n            return 0;\r\n        }\r\n        uint256 _savedAmount = savedAmount[account];\r\n        uint256 _expectedRewardYearly = _savedAmount.mul(percentRewardYearly);\r\n        _expectedRewardYearly = _expectedRewardYearly.div(100);\r\n        uint256 _reward = _expectedRewardYearly.div(yearly);\r\n        return _reward;\r\n    }\r\n    \r\n    function rewardEarned(address account) public view returns(uint256) {\r\n        uint256 _currentTime = block.timestamp;\r\n        uint256 _rangeTime = _currentTime.sub(savedTimestamp[account]);\r\n        uint256 _rewardEarned;\r\n        if(_rangeTime >= timeLock) {\r\n            _rewardEarned = _rewardEarnedPerSecond(account).mul(timeLock);\r\n        }else {\r\n            _rewardEarned = _rewardEarnedPerSecond(account).mul(_rangeTime);\r\n        }\r\n        if(claimRewardAmount[account] != 0) {\r\n            _rewardEarned = _rewardEarned.sub(claimRewardAmount[account]);\r\n        }\r\n        return _rewardEarned;\r\n    }\r\n    \r\n    function save(uint256 _amount) public {\r\n        require(_amount > 0, \"Cannot save 0\");\r\n        super._save(_amount);\r\n        uint256 _currentTime = block.timestamp;\r\n        savedAmount[msg.sender] = _amount;\r\n        claimRewardAmount[msg.sender] = 0;\r\n        savedTimestamp[msg.sender] = _currentTime;\r\n        lockedUntil[msg.sender] = _currentTime.add(timeLock);\r\n        emit Saved(msg.sender, _amount);\r\n    }\r\n    \r\n    function withdraw(uint256 _amount) public {\r\n        require(msg.sender != founder, \"Founder not allowed to withdraw\");\r\n        require(lockedUntil[msg.sender] > 0, \"No user found.\");\r\n        require(lockedUntil[msg.sender] < block.timestamp, \"Not unlocked yet.\");\r\n        require(_amount > 0, \"Cannot withdraw 0\");\r\n        super._withdraw(_amount);\r\n        emit Withdrawn(msg.sender, _amount);\r\n    }\r\n    \r\n    function getReward() public {\r\n        uint256 _rewardEarned = rewardEarned(msg.sender);\r\n        require(_rewardEarned > 0, \"Doesn't have a reward.\");\r\n        require(rewardBalance() > _rewardEarned, \"Reward balance not enough.\");\r\n        super._removeReward(founder, _rewardEarned);\r\n        claimRewardAmount[msg.sender] = claimRewardAmount[msg.sender].add(_rewardEarned);\r\n        if(lockedUntil[msg.sender] < block.timestamp) {\r\n            savedAmount[msg.sender] = 0;\r\n            claimRewardAmount[msg.sender] = 0;\r\n        }\r\n        emit RewardPaid(msg.sender, _rewardEarned);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentRewardYearly\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Saved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_rewardEarnedPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"founder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentRewardYearly\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewardEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"save\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setNewFounder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"setPercentRewardYearly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearly\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Saving","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000005","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a25d371e05ca50b0698183633e767ee092c2bd5c5cb04e26391184ad937e754f"}]}