{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\ninterface ERC20Interface {\r\n    function totalSupply() external returns (uint256);\r\n    function balanceOf(address tokenOwner) external returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) external returns (bool success);\r\n    function approve(address spender, uint256 tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\r\n}\r\n\r\ncontract PegNetBridgePool {\r\n    ERC20Interface tokenOfPegNet;\r\n\r\n    ERC20Interface tokenOfpUSD;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens, string tokenType);\r\n\r\n    address public owner = msg.sender;\r\n\r\n    mapping(uint256 => bool) usedNonces;\r\n\r\n    function getBridgeAmount(uint256 amount, uint256 nonce, bytes memory signature, uint256 tokenType) public {\r\n        require(!usedNonces[nonce], \"Nonce is duplicated\");\r\n        require(tokenType == 1 || tokenType == 2, \"Unsupported token\");\r\n\r\n        // this recreates the message that was signed on the client\r\n        bytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, tokenType, this)));\r\n\r\n        require(recoverSigner(message, signature) == owner, \"Signature is not matched\");\r\n\r\n        if (tokenType == 1) { // PegNet Token\r\n            require(tokenOfPegNet.balanceOf(address(this)) >= amount, \"No enough PegNet tokens in BridgePool\");\r\n\r\n            tokenOfPegNet.transfer(msg.sender, amount);\r\n\r\n            emit Transfer(owner, msg.sender, amount, \"PegNet\");\r\n\r\n        } else if (tokenType == 2) { // pUSD Token\r\n            require(tokenOfpUSD.balanceOf(address(this)) >= amount, \"No enough pUSD tokens in BridgePool\");\r\n\r\n            tokenOfpUSD.transfer(msg.sender, amount);\r\n\r\n            emit Transfer(owner, msg.sender, amount, \"pUSD\");\r\n        }\r\n\r\n        usedNonces[nonce] = true;\r\n    }\r\n\r\n    /// destroy the contract and reclaim the leftover funds.\r\n    function shutdown() public onlyOwner {\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n\r\n    /// signature methods.\r\n    function splitSignature(bytes memory sig)\r\n    internal\r\n    pure\r\n    returns (uint8 v, bytes32 r, bytes32 s)\r\n    {\r\n        require(sig.length == 65);\r\n\r\n        assembly {\r\n        // first 32 bytes, after the length prefix.\r\n            r := mload(add(sig, 32))\r\n        // second 32 bytes.\r\n            s := mload(add(sig, 64))\r\n        // final byte (first byte of the next 32 bytes).\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        return (v, r, s);\r\n    }\r\n\r\n    function recoverSigner(bytes32 message, bytes memory sig)\r\n    internal\r\n    pure\r\n    returns (address)\r\n    {\r\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\r\n\r\n        return ecrecover(message, v, r, s);\r\n    }\r\n\r\n    /// builds a prefixed hash to mimic the behavior of eth_sign.\r\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setPegNetToken(address _tokenPegNetAddr, address _tokenPUsdAddr) public onlyOwner {\r\n        tokenOfPegNet = ERC20Interface(_tokenPegNetAddr);\r\n        tokenOfpUSD = ERC20Interface(_tokenPUsdAddr);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenType\",\"type\":\"string\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getBridgeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenPegNetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenPUsdAddr\",\"type\":\"address\"}],\"name\":\"setPegNetToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PegNetBridgePool","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://93ddd24b295eedb70481eb952e2ed0307551c9686bc68aa6406ccb179ed3194c"}]}