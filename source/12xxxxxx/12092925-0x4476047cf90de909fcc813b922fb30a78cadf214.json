{"status":"1","message":"OK","result":[{"SourceCode":"{\"BlobDefinition.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\nimport \\u0027./LibAddress.sol\\u0027;\\nimport \\u0027./LibInteger.sol\\u0027;\\n\\n/**\\n * @title BlobDefinition \\n * @dev HBD token contract adhering to ERC721 standard\\n */\\ncontract BlobDefinition\\n{\\n    using LibAddress for address;\\n    using LibInteger for uint;\\n\\n    event Transfer(address indexed from, address indexed to, uint indexed id);\\n    event Approval(address indexed owner, address indexed approved, uint indexed id);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev The admin of the contract\\n     */\\n    address payable private _admin;\\n\\n    /**\\n     * @dev The total minted tokens\\n     */\\n    uint private _supply;\\n\\n    /**\\n     * @dev The base url of token info page\\n     */\\n    string private _base_uri;\\n\\n    /**\\n     * @dev Permitted addresses to carry out special functions\\n     */\\n    mapping (address =\\u003e bool) private _permissions;\\n\\n    /**\\n     * @dev Number of tokens held by an address\\n     */\\n    mapping (address =\\u003e uint) private _token_balances;\\n\\n    /**\\n     * @dev Owners of each token\\n     */\\n    mapping (uint =\\u003e address) private _token_owners;\\n\\n    /**\\n     * @dev Approved third party addresses for each token\\n     */\\n    mapping (uint =\\u003e address) private _token_approvals;\\n\\n    /**\\n     * @dev Approved third party addresses to manage all tokens belonging to some address\\n     */\\n    mapping (address =\\u003e mapping (address =\\u003e bool)) private _token_operators;\\n\\n    /**\\n     * @dev The name of token\\n     */\\n    string private constant _name = \\\"Hash Blob Definition\\\";\\n\\n    /**\\n     * @dev The symbol of token\\n     */\\n    string private constant _symbol = \\\"HBD\\\";\\n\\n    /**\\n     * Maximum number of tokens to be minted\\n     */\\n    uint private constant _max_supply = 16384;\\n\\n    /**\\n     * @dev Initialise the contract\\n     */\\n    constructor () public\\n    {\\n        //The contract creator becomes the admin\\n        _admin = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the admin of contract\\n     */\\n    modifier onlyAdmin()\\n    {\\n        require(msg.sender == _admin);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the permitted addresses\\n     */\\n    modifier onlyPermitted()\\n    {\\n        require(_permissions[msg.sender]);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Give or revoke permission of accounts\\n     * @param account The address to change permission\\n     * @param permission True if the permission should be granted, false if it should be revoked\\n     */\\n    function permit(address account, bool permission) public onlyAdmin\\n    {\\n        _permissions[account] = permission;\\n    }\\n\\n    /**\\n     * @dev Withdraw from the balance of this contract\\n     * @param amount The amount to be withdrawn, if zero is provided the whole balance will be withdrawn\\n     */\\n    function clean(uint amount) public onlyAdmin\\n    {\\n        if (amount == 0){\\n            _admin.transfer(address(this).balance);\\n        } else {\\n            _admin.transfer(amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the base uri\\n     * @param uri The base uri\\n     */\\n    function base(string memory uri) public onlyAdmin\\n    {\\n        _base_uri = uri;\\n    }\\n\\n    /**\\n     * @dev Move token from one account to another\\n     * @param from The token sender address\\n     * @param to The recipient address\\n     * @param id The token id to transfer\\n     */\\n    function transferFrom(address from, address to, uint id) public\\n    {\\n        //The token must exist\\n        require(_isExist(id));\\n\\n        //Caller must be approved or the owner of token\\n        require(_isApprovedOrOwner(msg.sender, id));\\n\\n        //Do the transfer\\n        _send(from, to, id, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Safely move token from one account to another\\n     * @param from The token sender address\\n     * @param to The recipient address\\n     * @param id The token id to transfer\\n     */\\n    function safeTransferFrom(address from, address to, uint id) public\\n    {\\n        //The token must exist\\n        require(_isExist(id));\\n\\n        //Caller must be approved or the owner of token\\n        require(_isApprovedOrOwner(msg.sender, id));\\n\\n        //Do the transfer\\n        _send(from, to, id, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Safely move token from one account to another\\n     * @param from The token sender address\\n     * @param to The recipient address\\n     * @param id The token id to transfer\\n     * @param data Additional extra data\\n     */\\n    function safeTransferFrom(address from, address to, uint id, bytes memory data) public\\n    {\\n        //The token must exist\\n        require(_isExist(id));\\n\\n        //Caller must be approved or the owner of token\\n        require(_isApprovedOrOwner(msg.sender, id));\\n\\n        //Do the transfer\\n        _send(from, to, id, data);\\n    }\\n\\n    /**\\n     * @dev Allow a third party to transfer caller\\u0027s token\\n     * @param to The address to allow\\n     * @param id The token id to allow transfer\\n     */\\n    function approve(address to, uint id) public\\n    {\\n        //The token must exist\\n        require(_isExist(id));\\n\\n        //No need to approve the owner\\n        address owner = ownerOf(id);\\n        require(to != owner);\\n\\n        //Caller must be the owner of token or an approved operator\\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\\n        \\n        //Grant approval\\n        _token_approvals[id] = to;\\n\\n        //Emit events\\n        emit Approval(owner, to, id);\\n    }\\n\\n    /**\\n     * @dev Grant or revoke approval for a third party to transfer all of caller\\u0027s tokens\\n     * @param to The address to grant or revoke\\n     * @param approved Grant or revoke approval\\n     */\\n    function setApprovalForAll(address to, bool approved) public\\n    {\\n        //Cannot set own settings\\n        require(to != msg.sender);\\n\\n        //Grant or revoke approval\\n        _token_operators[msg.sender][to] = approved;\\n\\n        //Emit events\\n        emit ApprovalForAll(msg.sender, to, approved);\\n    }\\n\\n    /**\\n     * @dev Mint tokens\\n     * @param to The owner of token\\n     */\\n    function mint(address to) public onlyPermitted returns (uint)\\n    {\\n        //No point of minting to zero address\\n        require(!to.isOriginAddress());\\n\\n        //Must not exceed the maximum available tokens to be minted\\n        require(_supply \\u003c _max_supply);\\n\\n        //Mint the token\\n        uint id = _supply.add(1);\\n        _token_owners[id] = to;\\n        _token_balances[to] = _token_balances[to].add(1);\\n\\n        //Increment supply\\n        _supply = id;\\n\\n        //Emit events\\n        emit Transfer(address(0), to, id);\\n\\n        return id;\\n    }\\n\\n    /**\\n     * @dev Enable tokens\\n     * @param to The owner of token\\n     * @param id The token id to enable\\n     */\\n    function enable(address to, uint id) public onlyPermitted\\n    {\\n        //Must be a valid id\\n        require(id \\u003e 0);\\n\\n        //No point of minting to zero address\\n        require(!to.isOriginAddress());\\n\\n        //Token does not already exists\\n        require(!_isExist(id));\\n\\n        //Enable the token\\n        _token_owners[id] = to;\\n        _token_balances[to] = _token_balances[to].add(1);\\n\\n        //Emit events\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    /**\\n     * @dev Burn tokens\\n     * @param owner The owner of token\\n     * @param id The token id to burn\\n     */\\n    function disable(address owner, uint id) public onlyPermitted\\n    {\\n        //Token must exist\\n        require(_isExist(id));\\n\\n        //Token must be owned by sent in address\\n        require(ownerOf(id) == owner);\\n\\n        //Disable the token\\n        _token_approvals[id] = address(0);\\n        _token_balances[owner] = _token_balances[owner].sub(1);\\n        _token_owners[id] = address(0);\\n\\n        //Emit events\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /**\\n     * @dev Safely move token from one account to another\\n     * @param from The token sender address\\n     * @param to The recipient address\\n     * @param id The token id to transfer\\n     */\\n    function move(address from, address to, uint id) public onlyPermitted\\n    {\\n        //The token must exist\\n        require(_isExist(id));\\n\\n        //Do the transfer\\n        _send(from, to, id, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Get the approved address for a token\\n     * @param id The token id\\n     * @return address The approved address\\n     */\\n    function getApproved(uint id) public view returns (address)\\n    {\\n        return _token_approvals[id];\\n    }\\n\\n    /**\\n     * @dev Check whether the provided operator is approved to manage owner\\u0027s tokens\\n     * @param owner The token owner address\\n     * @param operator The operator address to check against\\n     * @return bool True if the operator is approved, otherwise false\\n     */\\n    function isApprovedForAll(address owner, address operator) public view returns (bool)\\n    {\\n        return _token_operators[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Get number of tokens belonging to an account\\n     * @param account The address of account to check\\n     * @return uint The tokens balance\\n     */\\n    function balanceOf(address account) public view returns (uint)\\n    {\\n        return _token_balances[account];\\n    }\\n\\n    /**\\n     * @dev Get the owner of a token\\n     * @param id The id of token\\n     * @return address The owner of token\\n     */\\n    function ownerOf(uint id) public view returns (address)\\n    {\\n        return _token_owners[id];\\n    }\\n\\n    /**\\n     * @dev Get the url of token info page\\n     * @param id The id of token\\n     * @return string The url of token info page\\n     */\\n    function tokenURI(uint id) public view returns (string memory)\\n    {\\n        if(_isExist(id)) {\\n            return string(abi.encodePacked(_base_uri, id.toString()));\\n        } else {\\n            return \\\"\\\";\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the total number of tokens in existance\\n     * @return uint Number of tokens\\n     */\\n    function totalSupply() public view returns (uint)\\n    {\\n        return _supply;\\n    }\\n\\n    /**\\n     * @dev Get the maximum number of tokens minted\\n     * @return uint Maximum number of tokens\\n     */\\n    function maxSupply() public pure returns (uint)\\n    {\\n        return _max_supply;\\n    }\\n\\n    /**\\n     * @dev Get name of token\\n     * @return string The name\\n     */\\n    function name() public pure returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Get symbol of token\\n     * @return string The symbol\\n     */\\n    function symbol() public pure returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Check whether the provided address is permitted\\n     * @param account The address to check\\n     * @return bool True if the address is permitted, otherwise false\\n     */\\n    function isPermitted(address account) public view returns (bool)\\n    {\\n        return _permissions[account];\\n    }\\n\\n    /**\\n     * @dev Check whether the token exists\\n     * @param id The id of token\\n     * @return bool True if the token exists, otherwise false\\n     */\\n    function _isExist(uint id) private view returns (bool)\\n    {\\n        return ownerOf(id) != address(0);\\n    }\\n\\n    /**\\n     * @dev Check whether the provided address is the owner of token or a approved address\\n     * @param spender The address to check\\n     * @param id The id of token\\n     * @return bool True if the provided address is the owner of token or a approved address, otherwise false\\n     */\\n    function _isApprovedOrOwner(address spender, uint id) private view returns (bool)\\n    {\\n        address owner = ownerOf(id);\\n        return (spender == owner || getApproved(id) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one account to another\\n     * @param from The token owner\\n     * @param to The token receiver\\n     * @param id The token id to transfer\\n     * @param data Additional data to add to the transaction\\n     */\\n    function _send(address from, address to, uint id, bytes memory data) private\\n    {\\n        //The token must be owned by the provided address\\n        require(ownerOf(id) == from);\\n\\n        //No point of transferring to zero address\\n        require(!to.isOriginAddress());\\n\\n        //Do nothing with the data\\n        delete data;\\n\\n        //Clear approvals\\n        _token_approvals[id] = address(0);\\n\\n        //Reduce the balance from owner\\n        _token_balances[from] = _token_balances[from].sub(1);\\n\\n        //Increase the balance of receiver\\n        _token_balances[to] = _token_balances[to].add(1);\\n\\n        //Set the new owner\\n        _token_owners[id] = to;\\n\\n        //Emit events\\n        emit Transfer(from, to, id);\\n    }\\n}\"},\"BlobFormation.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\nimport \\u0027./LibInteger.sol\\u0027;\\n\\n/**\\n * @title BlobFormation \\n * @dev HBF token contract adhering to ERC20 standard\\n */\\ncontract BlobFormation\\n{\\n    using LibInteger for uint;\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n\\n    /**\\n     * @dev The admin of the contract\\n     */\\n    address payable private _admin;\\n\\n    /**\\n     * @dev The current supply of token\\n     */\\n    uint private _supply;\\n\\n    /**\\n     * @dev Permitted addresses to carry out special functions\\n     */\\n    mapping (address =\\u003e bool) private _permissions;\\n\\n    /**\\n     * @dev Number of tokens held by an address\\n     */\\n    mapping (address =\\u003e uint) private _token_balances;\\n\\n    /**\\n     * @dev Approved allowances for third party addresses\\n     */\\n    mapping (address =\\u003e mapping(address =\\u003e uint)) private _token_allowances;\\n\\n    /**\\n     * Number of decimals in base currency\\n     */\\n    uint private constant _decimals = 18;\\n\\n    /**\\n     * @dev The Maximum supply of token\\n     */\\n    uint private constant _max_supply = 400000 * 10**_decimals;\\n\\n    /**\\n     * @dev The name of token\\n     */\\n    string private constant _name = \\\"Hash Blob Formation\\\";\\n\\n    /**\\n     * @dev The symbol of token\\n     */\\n    string private constant _symbol = \\\"HBF\\\";\\n\\n    /**\\n     * @dev Initialise the contract\\n     */\\n    constructor() public\\n    {\\n        //The contract creator becomes the admin\\n        _admin = msg.sender;\\n\\n        //Mint max supply and send it to the admin\\n        _supply = _max_supply;\\n        _token_balances[_admin] = _supply;\\n        emit Transfer(address(0), _admin, _supply);\\n    }\\n\\n    /**\\n     * @dev Allow access only for the admin of contract\\n     */\\n    modifier onlyAdmin()\\n    {\\n        require(msg.sender == _admin);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the permitted addresses\\n     */\\n    modifier onlyPermitted()\\n    {\\n        require(_permissions[msg.sender]);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Give or revoke permission of accounts\\n     * @param account The address to change permission\\n     * @param permission True if the permission should be granted, false if it should be revoked\\n     */\\n    function permit(address account, bool permission) public onlyAdmin\\n    {\\n        _permissions[account] = permission;\\n    }\\n\\n    /**\\n     * @dev Withdraw from the balance of this contract\\n     * @param amount The amount to be withdrawn, if zero is provided the whole balance will be withdrawn\\n     */\\n    function clean(uint amount) public onlyAdmin\\n    {\\n        if (amount == 0){\\n            _admin.transfer(address(this).balance);\\n        } else {\\n            _admin.transfer(amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Moves tokens from the caller\\u0027s account to someone else\\n     * @param to The recipient address\\n     * @param value The number of tokens to send\\n     */\\n    function transfer(address to, uint value) public\\n    {\\n        _send(msg.sender, to, value);\\n    }\\n\\n    /**\\n     * @dev Sets amount of tokens spender is allowed to transfer from caller\\u0027s tokens\\n     * @param spender The spender to allow\\n     * @param value The number of tokens to allow\\n     */\\n    function approve(address spender, uint value) public\\n    {\\n        _token_allowances[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n    }\\n\\n    /**\\n     * @dev Moves tokens using the allowance mechanism\\n     * @param from The owner of tokens\\n     * @param to The recipient address\\n     * @param value The number of tokens to send\\n     */\\n    function transferFrom(address from, address to, uint value) public\\n    {\\n        _token_allowances[from][msg.sender] = _token_allowances[from][msg.sender].sub(value);\\n        _send(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Burn tokens forever\\n     * @param from The owner of tokens\\n     * @param value The number of tokens to be burned\\n     */\\n    function burn(address from, uint value) public onlyPermitted\\n    {\\n        //Must set number of tokens that needs to be burned\\n        require(value \\u003e 0);\\n\\n        //The total supply must be greater than the tokens that needs to be burned\\n        require(_supply \\u003e= value);\\n\\n        //The owner must have enough tokens available\\n        require(_token_balances[from] \\u003e= value);\\n\\n        //Reduce supply\\n        _supply = _supply.sub(value);\\n\\n        //Reduce owner\\u0027s balance\\n        _token_balances[from] = _token_balances[from].sub(value);\\n\\n        //Emit events and return\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Get the total number of tokens in existance\\n     * @return uint Number of tokens\\n     */\\n    function totalSupply() public view returns (uint)\\n    {\\n        return _supply;\\n    }\\n\\n    /**\\n     * @dev Get the maximum number of tokens minted\\n     * @return uint Maximum number of tokens\\n     */\\n    function maxSupply() public pure returns (uint)\\n    {\\n        return _max_supply;\\n    }\\n\\n    /**\\n     * @dev Get the total number of tokens spender is allowed to spend out of owner\\u0027s tokens\\n     * @param owner The tokens owner\\n     * @param spender The allowed spender\\n     * @return uint Number of tokens allowed to spend\\n     */\\n    function allowance(address owner, address spender) public view returns (uint)\\n    {\\n        return _token_allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Get number of tokens belonging to an account\\n     * @param account The address of account to check\\n     * @return uint The tokens balance\\n     */\\n    function balanceOf(address account) public view returns (uint)\\n    {\\n        return _token_balances[account];\\n    }\\n\\n    /**\\n     * @dev Get name of token\\n     * @return string The name\\n     */\\n    function name() public pure returns (string memory)\\n    {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Get symbol of token\\n     * @return string The symbol\\n     */\\n    function symbol() public pure returns (string memory)\\n    {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Get number of decimals of token\\n     * @return uint The decimals count\\n     */\\n    function decimals() public pure returns (uint)\\n    {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev Check whether the provided address is permitted\\n     * @param account The address to check\\n     * @return bool True if the address is permitted, otherwise false\\n     */\\n    function isPermitted(address account) public view returns (bool)\\n    {\\n        return _permissions[account];\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one account to another\\n     * @param from The token owner\\n     * @param to The token receiver\\n     * @param value The number of tokens to transfer\\n     */\\n    function _send(address from, address to, uint value) private\\n    {\\n        //Reduce the balance from owner\\n        _token_balances[from] = _token_balances[from].sub(value);\\n\\n        //Increase the balance of receiver\\n        _token_balances[to] = _token_balances[to].add(value);\\n\\n        //Emit events\\n        emit Transfer(from, to, value);\\n    }\\n}\"},\"BlobManager.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\nimport \\u0027./LibInteger.sol\\u0027;\\nimport \\u0027./LibBlob.sol\\u0027;\\nimport \\u0027./InterfaceProduce.sol\\u0027;\\nimport \\u0027./BlobDefinition.sol\\u0027;\\nimport \\u0027./BlobFormation.sol\\u0027;\\nimport \\u0027./BlobStorage.sol\\u0027;\\n\\n/**\\n * @title BlobManager \\n * @dev Manage the core functionalities of blobs\\n */\\ncontract BlobManager\\n{\\n    using LibInteger for uint;\\n\\n    BlobDefinition private _definition;\\n    BlobFormation private _formation;\\n    BlobStorage private _storage;\\n    InterfaceProduce private _producer;\\n\\n    event Log(address indexed account, uint indexed blob, string action, uint data1, uint data2);\\n\\n    /**\\n     * @dev The admin of the contract\\n     */\\n    address payable private _admin;\\n\\n    /**\\n     * @dev The address of the definition token contract\\n     */\\n    address private _definition_contract;\\n    \\n    /**\\n     * @dev The address of the formation token contract\\n     */\\n    address private _formation_contract;\\n\\n    /**\\n     * @dev The address of the blob storage contract\\n     */\\n    address private _storage_contract;\\n\\n    /**\\n     * @dev The address of the blob producer contract\\n     */\\n    address private _producer_contract;\\n\\n    /**\\n     * Number of tokens per minting segment\\n     */\\n    uint private constant _tokens_per_segment = 2048;\\n\\n    /**\\n     * Starting price of minting\\n     */\\n    uint private constant _minting_starting_price = 10**17;\\n\\n    /**\\n     * Minting price increment per segment\\n     */\\n    uint private constant _minting_price_increment = 10**17;\\n\\n    /**\\n     * Formation grant multiplier when minting\\n     */\\n    uint private constant _minting_grant_multiplier = 10**18;\\n\\n    /**\\n     * The formation tokens charged for merging, splitting and renaming\\n     */\\n    uint private constant _transformation_token_fee = 10**18;\\n\\n    /**\\n     * The minimum transformation fee charged if payed by native currency\\n     */\\n    uint private constant _transformation_native_fee_min = 40 * 10**15;\\n\\n    /**\\n     * The transformation fee increment per segment\\n     */\\n    uint private constant _transformation_native_fee_increment = 10**15;\\n\\n    /**\\n     * The transformation fee increment gap\\n     */\\n    uint private constant _transformation_native_fee_gap = 2500 * 10**18;\\n\\n    /**\\n     * The original minter selling fee percentage\\n     */\\n    uint private constant _minter_selling_fee_percentage = 2;\\n\\n    /**\\n     * @dev Initialise the contract\\n     */\\n    constructor() public\\n    {\\n        //The contract creator becomes the admin\\n        _admin = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the admin of contract\\n     */\\n    modifier onlyAdmin()\\n    {\\n        require(msg.sender == _admin);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Withdraw from the balance of this contract\\n     * @param amount The amount to be withdrawn, if zero is provided the whole balance will be withdrawn\\n     */\\n    function clean(uint amount) public onlyAdmin\\n    {\\n        if (amount == 0){\\n            _admin.transfer(address(this).balance);\\n        } else {\\n            _admin.transfer(amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraw formation tokens of this contract\\n     * @param amount The amount to be withdrawn, if zero is provided the whole formation token balance will be withdrawn\\n     */\\n    function empty(uint amount) public onlyAdmin\\n    {\\n        if (amount == 0){\\n            _formation.transfer(_admin, _formation.balanceOf(address(this)));\\n        } else {\\n            _formation.transfer(_admin, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Update definition contract reference\\n     * @param account The address of contract\\n     */\\n    function setDefinition(address account) public onlyAdmin\\n    {\\n        _definition_contract = account;\\n        _definition = BlobDefinition(account);\\n    }\\n\\n    /**\\n     * @dev Update formation contract reference\\n     * @param account The address of contract\\n     */\\n    function setFormation(address account) public onlyAdmin\\n    {\\n        _formation_contract = account;\\n        _formation = BlobFormation(account);\\n    }\\n\\n    /**\\n     * @dev Update storage contract reference\\n     * @param account The address of contract\\n     */\\n    function setStorage(address account) public onlyAdmin\\n    {\\n        _storage_contract = account;\\n        _storage = BlobStorage(account);\\n    }\\n\\n    /**\\n     * @dev Update producer contract reference\\n     * @param account The address of contract\\n     */\\n    function setProducer(address account) public onlyAdmin\\n    {\\n        _producer_contract = account;\\n        _producer = InterfaceProduce(account);\\n    }\\n\\n    /**\\n     * @dev Mint new blobs\\n     */\\n    function mint() public payable\\n    {        \\n        //Must pay for minting\\n        require(msg.value \\u003e 0);\\n\\n        //Get currently minted tokens\\n        uint minted = _definition.totalSupply();\\n\\n        //Must pay the price\\n        require(_calcSegmentPrice(minted) == msg.value);\\n\\n        //Grant formation tokens\\n        _formation.transfer(msg.sender, _calcSegmentGrant(minted));\\n\\n        //Mint the token\\n        uint id = _definition.mint(msg.sender);\\n\\n        //Save metadata\\n        _storage.incrementMetadata(id, _producer.init(id));\\n\\n        //Save original minter\\n        _storage.setMinter(id, msg.sender);\\n\\n        //Transfer fee\\n        _admin.transfer(msg.value.mul(90).div(100));\\n\\n        //Emit events\\n        emit Log(msg.sender, id, \\\"mint\\\", msg.value, 0);\\n    }\\n\\n    /**\\n     * @dev Merge two blobs\\n     * @param father The father blob id\\n     * @param mother The mother blob id\\n     */\\n    function merge(uint father, uint mother, uint[] memory params) public payable\\n    {\\n        //The parents must be owned by the sender\\n        require(msg.sender == _definition.ownerOf(father));\\n        require(msg.sender == _definition.ownerOf(mother));\\n\\n        //The parents must not be the same\\n        require(father != mother);\\n\\n        //Blobs must not be currently listed\\n        require(_storage.getListing(father) == 0);\\n        require(_storage.getListing(mother) == 0);\\n\\n        //Parameters should be valid\\n        require(params.length == 6);\\n        for (uint i = 0; i \\u003c 6; i++) {\\n            require(params[i] == father || params[i] == mother);\\n        }\\n\\n        //Read metadata of parents\\n        LibBlob.Metadata memory father_metadata = LibBlob.uintToMetadata(_storage.getLatestMetadata(father));\\n        LibBlob.Metadata memory mother_metadata = LibBlob.uintToMetadata(_storage.getLatestMetadata(mother));\\n\\n        //Both father and mother should be in same level\\n        require(father_metadata.level == mother_metadata.level);\\n\\n        //Cannot merge further after reaching level six\\n        require(father_metadata.level \\u003c 6 \\u0026\\u0026 mother_metadata.level \\u003c 6);\\n\\n        //Setup partners\\n        father_metadata.partner = mother;\\n        mother_metadata.partner = father;\\n\\n        //Merging increases the level of blob\\n        father_metadata.level = father_metadata.level.add(1);\\n        mother_metadata.level = mother_metadata.level.add(1);\\n\\n        //Setting up father parameters\\n        father_metadata.param1 = (params[0] == father) ? father_metadata.param1 : mother_metadata.param1;\\n        father_metadata.param2 = (params[1] == father) ? father_metadata.param2 : mother_metadata.param2;\\n        father_metadata.param3 = (params[2] == father) ? father_metadata.param3 : mother_metadata.param3;\\n        father_metadata.param4 = (params[3] == father) ? father_metadata.param4 : mother_metadata.param4;\\n        father_metadata.param5 = (params[4] == father) ? father_metadata.param5 : mother_metadata.param5;\\n        father_metadata.param6 = (params[5] == father) ? father_metadata.param6 : mother_metadata.param6;\\n\\n        //Setting up mother parameters\\n        mother_metadata.param1 = (params[0] == father) ? father_metadata.param1 : mother_metadata.param1;\\n        mother_metadata.param2 = (params[1] == father) ? father_metadata.param2 : mother_metadata.param2;\\n        mother_metadata.param3 = (params[2] == father) ? father_metadata.param3 : mother_metadata.param3;\\n        mother_metadata.param4 = (params[3] == father) ? father_metadata.param4 : mother_metadata.param4;\\n        mother_metadata.param5 = (params[4] == father) ? father_metadata.param5 : mother_metadata.param5;\\n        mother_metadata.param6 = (params[5] == father) ? father_metadata.param6 : mother_metadata.param6;\\n\\n        //Charge for the action\\n        if (msg.value \\u003e 0) {\\n            require(msg.value == _calcTransformationNativeFee());\\n        } else {\\n            _formation.burn(msg.sender, _transformation_token_fee);\\n        }\\n\\n        //Update metadata\\n        _storage.incrementMetadata(father, LibBlob.metadataToUint(father_metadata));\\n        _storage.incrementMetadata(mother, LibBlob.metadataToUint(mother_metadata));\\n\\n        //Only father survives after merging\\n        _definition.disable(msg.sender, mother);\\n    \\n        //Emit events\\n        emit Log(msg.sender, father, \\\"merge\\\", msg.value, mother);\\n    }\\n\\n    /**\\n     * @dev Split a blob back to its parents\\n     * @param id The id of blob\\n     */\\n    function split(uint id) public payable\\n    {\\n        //Blob must be owned by the sender\\n        require(msg.sender == _definition.ownerOf(id));\\n\\n        //Blob must not be currently listed\\n        require(_storage.getListing(id) == 0);\\n\\n        //Read metadata\\n        LibBlob.Metadata memory metadata = LibBlob.uintToMetadata(_storage.getLatestMetadata(id));\\n\\n        //Cannot split further after reaching level one\\n        require(metadata.level \\u003e 1);\\n\\n        //Charge for the action\\n        if (msg.value \\u003e 0) {\\n            require(msg.value == _calcTransformationNativeFee());\\n        } else {\\n            _formation.burn(msg.sender, _transformation_token_fee);\\n        }\\n\\n        //Summon the partner\\n        _definition.enable(msg.sender, metadata.partner);\\n\\n        //Restore metadata\\n        _storage.decrementMetadata(id);\\n        _storage.decrementMetadata(metadata.partner);\\n            \\n        //Emit events\\n        emit Log(msg.sender, id, \\\"split\\\", msg.value, metadata.partner);\\n    }\\n\\n    /**\\n     * @dev Rename a blob\\n     * @param id The id of blob\\n     * @param chars The name to be set\\n     */\\n    function rename(uint id, uint[] memory chars) public payable\\n    {\\n        //Characters should be valid\\n        require(chars.length == 8);\\n        for (uint i = 0; i \\u003c 8; i++) {\\n            require(chars[i] \\u003e= 0 \\u0026\\u0026 chars[i] \\u003c= 62);\\n        }\\n\\n        //Building name\\n        LibBlob.Name memory name_params;\\n        name_params.char1 = chars[0];\\n        name_params.char2 = chars[1];\\n        name_params.char3 = chars[2];\\n        name_params.char4 = chars[3];\\n        name_params.char5 = chars[4];\\n        name_params.char6 = chars[5];\\n        name_params.char7 = chars[6];\\n        name_params.char8 = chars[7];\\n        uint name = LibBlob.nameToUint(name_params);\\n\\n        //Get current name\\n        uint current = _storage.getName(id);\\n\\n        //The new name must be different from current name\\n        require(name != current);\\n\\n        //The new name must be unique\\n        require(!_storage.isReserved(name));\\n\\n        //The token must be owned by the sender\\n        require(msg.sender == _definition.ownerOf(id));\\n\\n        //Blob must not be currently listed\\n        require(_storage.getListing(id) == 0);\\n\\n        //Charge for the action\\n        if (msg.value \\u003e 0) {\\n            require(msg.value == _calcTransformationNativeFee());\\n        } else {\\n            _formation.burn(msg.sender, _transformation_token_fee);\\n        }\\n        \\n        //Release the previously reserved name\\n        if (current \\u003e 0) {\\n            _storage.setReservation(current, false);\\n        }\\n\\n        //Set new name\\n        _storage.setReservation(name, true);\\n        _storage.setName(id, name);\\n\\n        //Emit events\\n        emit Log(msg.sender, id, \\\"rename\\\", msg.value, name);\\n    }\\n\\n    /**\\n     * @dev List blob for selling\\n     * @param id The id of blob\\n     * @param price The selling price\\n     */\\n    function list(uint id, uint price) public\\n    {\\n        //The price needs to be set\\n        require(price \\u003e 0);\\n\\n        //Blob must be owned by the sender\\n        require(msg.sender == _definition.ownerOf(id));\\n\\n        //Set selling price\\n        _storage.setListing(id, price); \\n\\n        //Emit events\\n        emit Log(msg.sender, id, \\\"list\\\", price, 0);\\n    }\\n\\n    /**\\n     * @dev Withdraw blob from selling\\n     * @param id The id of blob\\n     */\\n    function withdraw(uint id) public\\n    {\\n        //Blob must be owned by the sender\\n        require(msg.sender == _definition.ownerOf(id));\\n\\n        //Blob must be currently listed\\n        require(_storage.getListing(id) \\u003e 0);\\n\\n        //Reset selling price\\n        _storage.setListing(id, 0); \\n\\n        //Emit events\\n        emit Log(msg.sender, id, \\\"withdraw\\\", 0, 0);           \\n    }\\n\\n    /**\\n     * @dev Buy a listed blob\\n     * @param id The id of blob\\n     */\\n    function buy(uint id) public payable\\n    {\\n        uint price = _storage.getListing(id);\\n        uint minter_share = price.mul(_minter_selling_fee_percentage).div(100);\\n        uint seller_share = price.sub(minter_share);\\n        address payable seller = address(uint160(_definition.ownerOf(id)));\\n\\n        //Blob must not be owned by the sender\\n        require(msg.sender != seller);\\n\\n        //Blob must be currently listed\\n        require(price \\u003e 0);\\n\\n        //Must send the buying amount\\n        require(msg.value == price);\\n\\n        //Settle payments\\n        seller.transfer(seller_share);\\n        _storage.getMinter(id).transfer(minter_share);\\n\\n        //Reset selling price\\n        _storage.setListing(id, 0); \\n\\n        //Transfer ownership\\n        _definition.move(seller, msg.sender, id);\\n\\n        //Emit events\\n        emit Log(msg.sender, id, \\\"buy\\\", price, 0);           \\n    }\\n\\n    /**\\n     * @dev Get common details of the system\\n     * @return The details\\n     */\\n    function getSystemDetails() public view returns (uint[8] memory)\\n    {\\n        uint minted = _definition.totalSupply();\\n\\n        return [\\n            _calcSegmentId(minted),\\n            _calcSegmentPrice(minted),\\n            _calcSegmentGrant(minted),\\n            _calcTransformationNativeFee(),\\n            _formation.maxSupply(),\\n            _formation.totalSupply(),\\n            _definition.maxSupply(),\\n            _definition.totalSupply()\\n        ];\\n    }\\n\\n    /**\\n     * @dev Get account related details of the system\\n     * @param account The account to get details about\\n     * @return The details\\n     */\\n    function getAccountDetails(address account) public view returns (uint[2] memory)\\n    {\\n        return [\\n            _definition.balanceOf(account),\\n            _formation.balanceOf(account)\\n        ];\\n    }\\n\\n    /**\\n     * @dev Get blob details\\n     * @return The details\\n     */\\n    function getBlobDetails(uint id) public view returns (uint[] memory, uint[] memory, uint[] memory, uint, address, address)\\n    {\\n        return (\\n            getBlobLatestMetadataDetails(id),\\n            getBlobPreviousMetadataDetails(id),\\n            getBlobNameDetails(id),\\n            _storage.getListing(id),\\n            _storage.getMinter(id),\\n            _definition.ownerOf(id)\\n        );\\n    }\\n\\n    /**\\n     * @dev Get blob latest metadata details\\n     * @return The details\\n     */\\n    function getBlobLatestMetadataDetails(uint id) public view returns (uint[] memory)\\n    {\\n        LibBlob.Metadata memory latest_metadata = LibBlob.uintToMetadata(_storage.getLatestMetadata(id));\\n        uint[] memory latest_metadata_params = new uint[](8);\\n        latest_metadata_params[0] = latest_metadata.partner;\\n        latest_metadata_params[1] = latest_metadata.level;\\n        latest_metadata_params[2] = latest_metadata.param1;\\n        latest_metadata_params[3] = latest_metadata.param2;\\n        latest_metadata_params[4] = latest_metadata.param3;\\n        latest_metadata_params[5] = latest_metadata.param4;\\n        latest_metadata_params[6] = latest_metadata.param5;\\n        latest_metadata_params[7] = latest_metadata.param6;\\n\\n        return latest_metadata_params;\\n    }\\n\\n    /**\\n     * @dev Get blob previous metadata details\\n     * @return The details\\n     */\\n    function getBlobPreviousMetadataDetails(uint id) public view returns (uint[] memory)\\n    {\\n        LibBlob.Metadata memory previous_metadata = LibBlob.uintToMetadata(_storage.getPreviousMetadata(id));\\n        uint[] memory previous_metadata_params = new uint[](8);\\n        previous_metadata_params[0] = previous_metadata.partner;\\n        previous_metadata_params[1] = previous_metadata.level;\\n        previous_metadata_params[2] = previous_metadata.param1;\\n        previous_metadata_params[3] = previous_metadata.param2;\\n        previous_metadata_params[4] = previous_metadata.param3;\\n        previous_metadata_params[5] = previous_metadata.param4;\\n        previous_metadata_params[6] = previous_metadata.param5;\\n        previous_metadata_params[7] = previous_metadata.param6;\\n\\n        return previous_metadata_params;\\n    }\\n\\n    /**\\n     * @dev Get blob name details\\n     * @return The details\\n     */\\n    function getBlobNameDetails(uint id) public view returns (uint[] memory)\\n    {\\n        LibBlob.Name memory name = LibBlob.uintToName(_storage.getName(id));\\n        uint[] memory name_params = new uint[](8);\\n        name_params[0] = name.char1;\\n        name_params[1] = name.char2;\\n        name_params[2] = name.char3;\\n        name_params[3] = name.char4;\\n        name_params[4] = name.char5;\\n        name_params[5] = name.char6;\\n        name_params[6] = name.char7;\\n        name_params[7] = name.char8;\\n\\n        return name_params;\\n    }\\n\\n    /**\\n     * @dev Calculates the current mining segment id\\n     * @param minted The number of tokens minted so far\\n     * @return uint The current mining segment id\\n     */\\n    function _calcSegmentId(uint minted) private pure returns (uint)\\n    {\\n        return minted.div(_tokens_per_segment);\\n    }\\n\\n    /**\\n     * @dev Calculates the current mining segment price\\n     * @param minted The number of tokens minted so far\\n     * @return uint The current mining segment price\\n     */\\n    function _calcSegmentPrice(uint minted) private pure returns (uint)\\n    {\\n        return _minting_starting_price.add(_calcSegmentId(minted).mul(_minting_price_increment));\\n    }\\n\\n    /**\\n     * @dev Calculates the current mining segment formation tokens grant\\n     * @param minted The number of tokens minted so far\\n     * @return uint The current mining segment formation tokens grant\\n     */\\n    function _calcSegmentGrant(uint minted) private pure returns (uint)\\n    {\\n        uint multiplier = _calcSegmentId(minted).add(2);\\n        return _minting_grant_multiplier.mul(multiplier.mul(multiplier.add(1))).div(2);\\n    }\\n\\n    /**\\n     * @dev Calculates the native fee that should be payed for transformation\\n     * @return uint The current transformation native fee\\n     */\\n    function _calcTransformationNativeFee() private view returns (uint)\\n    {\\n        uint burnt_supply = _formation.maxSupply().sub(_formation.totalSupply());\\n        uint transformation_segment = burnt_supply.div(_transformation_native_fee_gap);\\n\\n        return _transformation_native_fee_min.add(transformation_segment.mul(_transformation_native_fee_increment));\\n    }\\n}\"},\"BlobStorage.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\nimport \\u0027./LibInteger.sol\\u0027;\\nimport \\u0027./LibBlob.sol\\u0027;\\n\\n/**\\n * @title BlobStorage \\n * @dev Store core details about the blobs permanently\\n */\\ncontract BlobStorage\\n{\\n    using LibInteger for uint;\\n\\n    /**\\n     * @dev The admin of the contract\\n     */\\n    address payable private _admin;\\n\\n    /**\\n     * @dev Permitted addresses to carry out storage functions\\n     */\\n    mapping (address =\\u003e bool) private _permissions;\\n\\n    /**\\n     * @dev Names of tokens\\n     */\\n    mapping (uint =\\u003e uint) private _names;\\n\\n    /**\\n     * @dev Listing prices of tokens\\n     */\\n    mapping (uint =\\u003e uint) private _listings;\\n\\n    /**\\n     * @dev Original minters of tokens\\n     */\\n    mapping (uint =\\u003e address payable) private _minters;\\n\\n    /**\\n     * @dev Names currently reserved\\n     */\\n    mapping (uint =\\u003e bool) private _reservations;\\n\\n    /**\\n     * @dev The metadata of blobs\\n     */\\n    mapping (uint =\\u003e uint[]) private _metadata;\\n\\n    /**\\n     * @dev Initialise the contract\\n     */\\n    constructor() public\\n    {\\n        //The contract creator becomes the admin\\n        _admin = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the admin of contract\\n     */\\n    modifier onlyAdmin()\\n    {\\n        require(msg.sender == _admin);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allow access only for the permitted addresses\\n     */\\n    modifier onlyPermitted()\\n    {\\n        require(_permissions[msg.sender]);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Give or revoke permission of accounts\\n     * @param account The address to change permission\\n     * @param permission True if the permission should be granted, false if it should be revoked\\n     */\\n    function permit(address account, bool permission) public onlyAdmin\\n    {\\n        _permissions[account] = permission;\\n    }\\n\\n    /**\\n     * @dev Withdraw from the balance of this contract\\n     * @param amount The amount to be withdrawn, if zero is provided the whole balance will be withdrawn\\n     */\\n    function clean(uint amount) public onlyAdmin\\n    {\\n        if (amount == 0){\\n            _admin.transfer(address(this).balance);\\n        } else {\\n            _admin.transfer(amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the name of token\\n     * @param id The id of token\\n     * @param value The value to be set\\n     */\\n    function setName(uint id, uint value) public onlyPermitted\\n    {\\n        _names[id] = value;\\n    }\\n\\n    /**\\n     * @dev Set the listing price of token\\n     * @param id The id of token\\n     * @param value The value to be set\\n     */\\n    function setListing(uint id, uint value) public onlyPermitted\\n    {\\n        _listings[id] = value;\\n    }\\n\\n    /**\\n     * @dev Set the original minter of token\\n     * @param id The id of token\\n     * @param value The value to be set\\n     */\\n    function setMinter(uint id, address payable value) public onlyPermitted\\n    {\\n        _minters[id] = value;\\n    }\\n\\n    /**\\n     * @dev Set whether the name is reserved\\n     * @param name The name\\n     * @param value True if the name is reserved, otherwise false\\n     */\\n    function setReservation(uint name, bool value) public onlyPermitted\\n    {\\n        _reservations[name] = value;\\n    }\\n\\n    /**\\n     * @dev Add a new version of metadata to the token\\n     * @param id The token id\\n     * @param value The value to be set\\n     */\\n    function incrementMetadata(uint id, uint value) public onlyPermitted\\n    {\\n        _metadata[id].push(value);\\n    }\\n\\n    /**\\n     * @dev Remove the latest version of metadata from token\\n     * @param id The token id\\n     */\\n    function decrementMetadata(uint id) public onlyPermitted\\n    {\\n        _metadata[id].length = _metadata[id].length.sub(1);\\n    }\\n\\n    /**\\n     * @dev Get name of token\\n     * @param id The id of token\\n     * @return string The name\\n     */\\n    function getName(uint id) public view returns (uint)\\n    {\\n        return _names[id];\\n    }\\n\\n    /**\\n     * @dev Get listing price of token\\n     * @param id The id of token\\n     * @return uint The listing price\\n     */\\n    function getListing(uint id) public view returns (uint)\\n    {\\n        return _listings[id];\\n    }\\n\\n    /**\\n     * @dev Get original minter of token\\n     * @param id The id of token\\n     * @return uint The original minter\\n     */\\n    function getMinter(uint id) public view returns (address payable)\\n    {\\n        return _minters[id];\\n    }\\n\\n    /**\\n     * @dev Check whether the provided name is reserved\\n     * @param name The name to check\\n     * @return bool True if the name is reserved, otherwise false\\n     */\\n    function isReserved(uint name) public view returns (bool)\\n    {\\n        return _reservations[name];\\n    }\\n\\n    /**\\n     * @dev Check whether the provided address is permitted\\n     * @param account The address to check\\n     * @return bool True if the address is permitted, otherwise false\\n     */\\n    function isPermitted(address account) public view returns (bool)\\n    {\\n        return _permissions[account];\\n    }\\n\\n    /**\\n     * @dev Get latest version of metadata of token\\n     * @param id The id of token\\n     * @return uint The metadata value\\n     */\\n    function getLatestMetadata(uint id) public view returns (uint)\\n    {\\n        if (_metadata[id].length \\u003e 0) {\\n            return _metadata[id][_metadata[id].length.sub(1)];\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Get previous version of metadata of token\\n     * @param id The id of token\\n     * @return uint The metadata value\\n     */\\n    function getPreviousMetadata(uint id) public view returns (uint)\\n    {\\n        if (_metadata[id].length \\u003e 1) {\\n            return _metadata[id][_metadata[id].length.sub(2)];\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\"},\"InterfaceProduce.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\n/**\\n * @title InterfaceProduce \\n * @dev Blob producer interface\\n */\\ninterface InterfaceProduce\\n{\\n    /**\\n     * @dev Initialise metadata\\n     * @param id The blob id\\n     * @return uint The generated metadata\\n     */\\n    function init(uint id) external view returns (uint);\\n}\\n\"},\"LibAddress.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\n/**\\n * @title LibAddress \\n * @dev Address related utility functions\\n */\\nlibrary LibAddress\\n{\\n    /**\\n     * @dev Check whether the given address is zero address\\n     * @param account The address to check against\\n     * @return bool True if the given address is zero address\\n     */\\n    function isOriginAddress(address account) internal pure returns (bool)\\n    {\\n        return (account == address(0));\\n    }\\n}\\n\"},\"LibBlob.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\n/**\\n * @title LibBlob\\n * @dev Blob related utility functions\\n */\\nlibrary LibBlob\\n{\\n    struct Metadata\\n    {\\n        uint partner;\\n        uint level;\\n        uint param1;\\n        uint param2;\\n        uint param3;\\n        uint param4;\\n        uint param5;\\n        uint param6;\\n    }\\n\\n    struct Name\\n    {\\n        uint char1;\\n        uint char2;\\n        uint char3;\\n        uint char4;\\n        uint char5;\\n        uint char6;\\n        uint char7;\\n        uint char8;\\n    }\\n\\n    /**\\n     * @dev Convert metadata to a single integer\\n     * @param metadata The metadata to be converted\\n     * @return uint The integer representing the metadata\\n     */\\n    function metadataToUint(Metadata memory metadata) internal pure returns (uint)\\n    {\\n        uint params = uint(metadata.partner);\\n        params |= metadata.level\\u003c\\u003c32;\\n        params |= metadata.param1\\u003c\\u003c64;\\n        params |= metadata.param2\\u003c\\u003c96;\\n        params |= metadata.param3\\u003c\\u003c128;\\n        params |= metadata.param4\\u003c\\u003c160;\\n        params |= metadata.param5\\u003c\\u003c192;\\n        params |= metadata.param6\\u003c\\u003c224;\\n\\n        return params;\\n    }\\n\\n    /**\\n     * @dev Convert given integer to a metadata object\\n     * @param params The integer to be converted\\n     * @return Metadata The metadata represented by the integer\\n     */\\n    function uintToMetadata(uint params) internal pure returns (Metadata memory)\\n    {\\n        Metadata memory metadata;\\n\\n        metadata.partner = uint(uint32(params));\\n        metadata.level = uint(uint32(params\\u003e\\u003e32));\\n        metadata.param1 = uint(uint32(params\\u003e\\u003e64));\\n        metadata.param2 = uint(uint32(params\\u003e\\u003e96));\\n        metadata.param3 = uint(uint32(params\\u003e\\u003e128));\\n        metadata.param4 = uint(uint32(params\\u003e\\u003e160));\\n        metadata.param5 = uint(uint32(params\\u003e\\u003e192));\\n        metadata.param6 = uint(uint32(params\\u003e\\u003e224));\\n\\n        return metadata;\\n    }\\n\\n    /**\\n     * @dev Convert name to a single integer\\n     * @param name The name to be converted\\n     * @return uint The integer representing the name\\n     */\\n    function nameToUint(Name memory name) internal pure returns (uint)\\n    {\\n        uint params = uint(name.char1);\\n        params |= name.char2\\u003c\\u003c32;\\n        params |= name.char3\\u003c\\u003c64;\\n        params |= name.char4\\u003c\\u003c96;\\n        params |= name.char5\\u003c\\u003c128;\\n        params |= name.char6\\u003c\\u003c160;\\n        params |= name.char7\\u003c\\u003c192;\\n        params |= name.char8\\u003c\\u003c224;\\n\\n        return params;\\n    }\\n\\n    /**\\n     * @dev Convert given integer to a name object\\n     * @param params The integer to be converted\\n     * @return Name The name represented by the integer\\n     */\\n    function uintToName(uint params) internal pure returns (Name memory)\\n    {\\n        Name memory name;\\n\\n        name.char1 = uint(uint32(params));\\n        name.char2 = uint(uint32(params\\u003e\\u003e32));\\n        name.char3 = uint(uint32(params\\u003e\\u003e64));\\n        name.char4 = uint(uint32(params\\u003e\\u003e96));\\n        name.char5 = uint(uint32(params\\u003e\\u003e128));\\n        name.char6 = uint(uint32(params\\u003e\\u003e160));\\n        name.char7 = uint(uint32(params\\u003e\\u003e192));\\n        name.char8 = uint(uint32(params\\u003e\\u003e224));\\n\\n        return name;\\n    }\\n}\\n\"},\"LibInteger.sol\":{\"content\":\"pragma solidity 0.5.10;\\n\\n/**\\n * @title LibInteger \\n * @dev Integer related utility functions\\n */\\nlibrary LibInteger\\n{    \\n    /**\\n     * @dev Safely multiply, revert on overflow\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function mul(uint a, uint b) internal pure returns (uint)\\n    {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely divide, revert if divisor is zero\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function div(uint a, uint b) internal pure returns (uint)\\n    {\\n        require(b \\u003e 0, \\\"\\\");\\n        uint c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely substract, revert if answer is negative\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function sub(uint a, uint b) internal pure returns (uint)\\n    {\\n        require(b \\u003c= a, \\\"\\\");\\n        uint c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Safely add, revert if overflow\\n     * @param a The first number\\n     * @param b The second number\\n     * @return uint The answer\\n    */\\n    function add(uint a, uint b) internal pure returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Convert number to string\\n     * @param value The number to convert\\n     * @return string The string representation\\n    */\\n    function toString(uint value) internal pure returns (string memory)\\n    {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n\\n        uint temp = value;\\n        uint digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n        uint index = digits - 1;\\n        \\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        \\n        return string(buffer);\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBlobLatestMetadataDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setProducer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setDefinition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"list\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBlobDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"clean\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"chars\",\"type\":\"uint256[]\"}],\"name\":\"rename\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBlobNameDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSystemDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setFormation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBlobPreviousMetadataDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"father\",\"type\":\"uint256\"},{\"name\":\"mother\",\"type\":\"uint256\"},{\"name\":\"params\",\"type\":\"uint256[]\"}],\"name\":\"merge\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"split\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"empty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"blob\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"data1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data2\",\"type\":\"uint256\"}],\"name\":\"Log\",\"type\":\"event\"}]","ContractName":"BlobManager","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://0e9d51b8a0fa75a60049e39ec82649a54c5674ea43057973d8c57ceaaf1a9d5b"}]}