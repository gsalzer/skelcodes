{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BeyondFactories.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol';\\nimport './Factories/FactoryStorage.sol';\\nimport './Factories/IFactoryConsumer.sol';\\n\\ncontract BeyondFactories is OwnableUpgradeable, PausableUpgradeable, FactoryStorage {\\n\\tusing EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\\n\\n\\t// emitted when a factory is created\\n\\tevent FactoryCreated(uint256 indexed id, address indexed creator, string metadata);\\n\\n\\t// emitted when factories are updated (active, paused, price, metadata...)\\n\\tevent FactoriesUpdate(uint256[] factoryIds);\\n\\n\\t// emitted when a factory has reached its max supply\\n\\tevent FactoryOut(uint256 indexed id);\\n\\n\\t// emitted when a donation recipient is created or modified\\n\\tevent DonationRecipientsUpdate(uint256[] ids);\\n\\n\\t// emitted when configuration changed\\n\\tevent ConfigurationUpdate();\\n\\n\\t// emitted when a tokenId is minted from a factory\\n\\tevent MintFromFactory(\\n\\t\\tuint256 indexed factoryId,\\n\\t\\taddress indexed minter,\\n\\t\\tuint256 createdIndex, // index in factory\\n\\t\\taddress registry,\\n\\t\\tuint256 tokenId,\\n\\t\\tbytes32 data,\\n\\t\\tstring seed,\\n\\t\\tuint256 price\\n\\t);\\n\\n\\t/**\\n\\t * @dev initialize function\\n\\t */\\n\\tfunction initialize(\\n\\t\\taddress payable platformBeneficiary,\\n\\t\\tuint16 platformFee,\\n\\t\\tuint16 donationMinimum,\\n\\t\\tbool restricted,\\n\\t\\tbool defaultActive,\\n\\t\\tbool canEditPlatformFees,\\n\\t\\taddress ownedBy\\n\\t) public initializer {\\n\\t\\t__Ownable_init();\\n\\t\\t__Pausable_init();\\n\\n\\t\\tcontractConfiguration.platformBeneficiary = platformBeneficiary;\\n\\t\\tcontractConfiguration.platformFee = platformFee;\\n\\t\\tcontractConfiguration.donationMinimum = donationMinimum;\\n\\t\\tcontractConfiguration.canEditPlatformFees = canEditPlatformFees;\\n\\n\\t\\t// defines if factory are active by defualt or not\\n\\t\\tcontractConfiguration.defaultFactoryActivation = defaultActive;\\n\\n\\t\\t// if the factory is restricted\\n\\t\\tcontractConfiguration.restricted = restricted;\\n\\n\\t\\tif (address(0) != ownedBy) {\\n\\t\\t\\ttransferOwnership(ownedBy);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev called by creators or admin to register a new factory\\n\\t *\\n\\t * @param factoryType - if unique (erc721) or edition (erc1155)\\n\\t * @param creator - the factory creator, is used when contract is restricted\\n\\t * @param paused - if the factory starts paused\\n\\t * @param price - factory price, in wei\\n\\t * @param maxSupply - times this factory can be used; 0 = inifinity\\n\\t * @param withSeed - if the factory needs a seed when creating\\n\\t * @param metadata - factory metadata uri - ipfs uri most of the time\\n\\t */\\n\\tfunction registerFactory(\\n\\t\\tFactoryType factoryType, // if erc721 or erc1155\\n\\t\\taddress creator,\\n\\t\\tbool paused, // if the factory start paused\\n\\t\\tuint256 price, // factory price, in wei\\n\\t\\tuint256 maxSupply, // max times this factory can be used; 0 = inifinity\\n\\t\\tbool withSeed, // if the factory needs a seed when creating\\n\\t\\tstring memory metadata,\\n\\t\\tuint256 royaltyValue,\\n\\t\\taddress consumer\\n\\t) external {\\n\\t\\trequire(bytes(metadata).length > 0, 'Need metadata URI');\\n\\t\\tContractConfiguration memory _configuration = contractConfiguration;\\n\\t\\trequire(!_configuration.restricted || owner() == _msgSender(), 'Restricted.');\\n\\n\\t\\t// Restricted contracts only allow OPERATORS to mint\\n\\t\\tif (creator == address(0)) {\\n\\t\\t\\tcreator = msg.sender;\\n\\t\\t}\\n\\n\\t\\t// if no consumer given, take one of the default\\n\\t\\tif (consumer == address(0)) {\\n\\t\\t\\tif (factoryType == FactoryType.Unique) {\\n\\t\\t\\t\\tconsumer = _configuration.uniqueConsumer;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconsumer = _configuration.editionsConsumer;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tuint256 factoryId = factoriesCount + 1;\\n\\t\\tfactories[factoryId] = Factory({\\n\\t\\t\\tfactoryType: factoryType,\\n\\t\\t\\tcreator: creator,\\n\\t\\t\\tactive: _configuration.defaultFactoryActivation,\\n\\t\\t\\tpaused: paused,\\n\\t\\t\\tprice: price,\\n\\t\\t\\tmaxSupply: maxSupply,\\n\\t\\t\\twithSeed: withSeed,\\n\\t\\t\\troyaltyValue: royaltyValue,\\n\\t\\t\\tmetadata: metadata,\\n\\t\\t\\tcreated: 0,\\n\\t\\t\\tconsumer: consumer,\\n\\t\\t\\tdonationId: 0,\\n\\t\\t\\tdonationAmount: _configuration.donationMinimum\\n\\t\\t});\\n\\t\\tfactoriesCount = factoryId;\\n\\n\\t\\temit FactoryCreated(factoryId, creator, metadata);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Function to mint a token without any seed\\n\\t *\\n\\t * @param factoryId id of the factory to mint from\\n\\t * @param amount - amount to mint; only for Editions factories\\n\\t * @param to - address to mint to, if address(0), msg.sender\\n\\t * @param swapContract - address of the contract if this is a swap\\n\\t * @param swapTokenId - id of the token if it's a swap\\n\\t */\\n\\tfunction mintFrom(\\n\\t\\tuint256 factoryId,\\n\\t\\tuint256 amount,\\n\\t\\taddress to,\\n\\t\\taddress swapContract,\\n\\t\\tuint256 swapTokenId\\n\\t) external payable {\\n\\t\\t_mintFromFactory(factoryId, '', '', amount, to, swapContract, swapTokenId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Function to mint a token from a factory with a 32 bytes hex string as has\\n\\t *\\n\\t * @param factoryId id of the factory to mint from\\n\\t * @param seed The hash used to create the seed\\n\\t * @param amount - amount to mint; only for Editions factories\\n\\t * @param to - address to mint to, if address(0), msg.sender\\n\\t * @param swapContract - address of the contract if this is a swap\\n\\t * @param swapTokenId - id of the token if it's a swap\\n\\t *\\n\\t * Seed will be used to create, off-chain, the token unique seed with the function:\\n\\t * tokenSeed = sha3(blockHash, factoryId, createdIndex, minter, registry, tokenId, seed)\\n\\t *\\n\\t * There is as much chance of collision than there is on creating a duplicate\\n\\t * of an ethereum private key, which is low enough to not go to crazy length in\\n\\t * order to try to stop the \\\"almost impossible\\\"\\n\\t *\\n\\t * I thought about using a commit/reveal (revealed at the time of nft metadata creation)\\n\\t * But this could break the token generation if, for example, the reveal was lost (db problem)\\n\\t * between the function call and the reveal.\\n\\t *\\n\\t *\\n\\t * All in all, using the blockhash in the seed makes this as secure as \\\"on-chain pseudo rng\\\".\\n\\t *\\n\\t * Also with this method, all informations to recreate the token can always be retrieved from the events.\\n\\t */\\n\\tfunction mintWithHash(\\n\\t\\tuint256 factoryId,\\n\\t\\tbytes32 seed,\\n\\t\\tuint256 amount,\\n\\t\\taddress to,\\n\\t\\taddress swapContract,\\n\\t\\tuint256 swapTokenId\\n\\t) external payable {\\n\\t\\trequire(seed != 0x0, 'Invalid seed');\\n\\t\\t_mintFromFactory(factoryId, seed, '', amount, to, swapContract, swapTokenId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Function to mint a token from a factory with a known seed\\n\\t *\\n\\t * This known seed can either be:\\n\\t * - a user inputed seed\\n\\t * - the JSON string of the factory properties. Allowing for future reconstruction of nft metadata if needed\\n\\t *\\n\\t * @param factoryId id of the factory to mint from\\n\\t * @param seed The seed used to mint\\n\\t * @param amount - amount to mint; only for Editions factories\\n\\t * @param to - address to mint to, if address(0), msg.sender\\n\\t * @param swapContract - address of the contract if this is a swap\\n\\t * @param swapTokenId - id of the token if it's a swap\\n\\t */\\n\\tfunction mintWithOpenSeed(\\n\\t\\tuint256 factoryId,\\n\\t\\tstring memory seed,\\n\\t\\tuint256 amount,\\n\\t\\taddress to,\\n\\t\\taddress swapContract,\\n\\t\\tuint256 swapTokenId\\n\\t) external payable {\\n\\t\\trequire(bytes(seed).length > 0, 'Invalid seed');\\n\\t\\t_mintFromFactory(\\n\\t\\t\\tfactoryId,\\n\\t\\t\\tkeccak256(abi.encodePacked(seed)),\\n\\t\\t\\tseed,\\n\\t\\t\\tamount,\\n\\t\\t\\tto,\\n\\t\\t\\tswapContract,\\n\\t\\t\\tswapTokenId\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev allows a creator to pause / unpause the use of their Factory\\n\\t */\\n\\tfunction setFactoryPause(uint256 factoryId, bool isPaused) external {\\n\\t\\tFactory storage factory = factories[factoryId];\\n\\t\\trequire(msg.sender == factory.creator, 'Not factory creator');\\n\\t\\tfactory.paused = isPaused;\\n\\n\\t\\temit FactoriesUpdate(_asSingletonArray(factoryId));\\n\\t}\\n\\n\\t/**\\n\\t * @dev allows a creator to update the price of their factory\\n\\t */\\n\\tfunction setFactoryPrice(uint256 factoryId, uint256 price) external {\\n\\t\\tFactory storage factory = factories[factoryId];\\n\\t\\trequire(msg.sender == factory.creator, 'Not factory creator');\\n\\t\\tfactory.price = price;\\n\\n\\t\\temit FactoriesUpdate(_asSingletonArray(factoryId));\\n\\t}\\n\\n\\t/**\\n\\t * @dev allows a creator to define a swappable factory\\n\\t */\\n\\tfunction setFactorySwap(\\n\\t\\tuint256 factoryId,\\n\\t\\taddress swapContract,\\n\\t\\tuint256 swapTokenId,\\n\\t\\tbool fixedId\\n\\t) external {\\n\\t\\tFactory storage factory = factories[factoryId];\\n\\t\\trequire(msg.sender == factory.creator, 'Not factory creator');\\n\\t\\tif (swapContract == address(0)) {\\n\\t\\t\\tdelete factorySwap[factoryId];\\n\\t\\t} else {\\n\\t\\t\\tfactorySwap[factoryId] = TokenSwap({\\n\\t\\t\\t\\tis1155: IERC1155Upgradeable(swapContract).supportsInterface(0xd9b67a26),\\n\\t\\t\\t\\tfixedId: fixedId,\\n\\t\\t\\t\\tswapContract: swapContract,\\n\\t\\t\\t\\tswapTokenId: swapTokenId\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\temit FactoriesUpdate(_asSingletonArray(factoryId));\\n\\t}\\n\\n\\t/**\\n\\t * @dev allows a creator to define to which orga they want to donate if not automatic\\n\\t * and how much (minimum 2.50, taken from the BeyondNFT 10%)\\n\\t *\\n\\t * Be careful when using this:\\n\\t * - if donationId is 0, then the donation will be automatic\\n\\t * if you want to set a specific donation id, always use id + 1\\n\\t */\\n\\tfunction setFactoryDonation(\\n\\t\\tuint256 factoryId,\\n\\t\\tuint256 donationId,\\n\\t\\tuint16 donationAmount\\n\\t) external {\\n\\t\\tFactory storage factory = factories[factoryId];\\n\\t\\trequire(msg.sender == factory.creator, 'Not factory creator');\\n\\n\\t\\t// if 0, set automatic;\\n\\t\\tfactory.donationId = donationId;\\n\\n\\t\\t// 2.50 is the minimum that can be set\\n\\t\\t// those 2.50 are taken from BeyondNFT share of 10%\\n\\t\\tif (donationAmount >= contractConfiguration.donationMinimum) {\\n\\t\\t\\tfactory.donationAmount = donationAmount;\\n\\t\\t}\\n\\n\\t\\temit FactoriesUpdate(_asSingletonArray(factoryId));\\n\\t}\\n\\n\\t/**\\n\\t * @dev allows to activate and deactivate factories\\n\\t *\\n\\t * Because BeyondNFT is an open platform with no curation prior factory creation\\n\\t * This can only be called by BeyondNFT administrators, if there is any abuse with a factory\\n\\t */\\n\\tfunction setFactoryActiveBatch(uint256[] memory factoryIds, bool[] memory areActive)\\n\\t\\texternal\\n\\t\\tonlyOwner\\n\\t{\\n\\t\\tfor (uint256 i; i < factoryIds.length; i++) {\\n\\t\\t\\tFactory storage factory = factories[factoryIds[i]];\\n\\t\\t\\trequire(address(0) != factory.creator, 'Factory not found');\\n\\n\\t\\t\\tfactory.active = areActive[i];\\n\\t\\t}\\n\\t\\temit FactoriesUpdate(factoryIds);\\n\\t}\\n\\n\\t/**\\n\\t * @dev allows to set a factory consumer\\n\\t */\\n\\tfunction setFactoryConsumerBatch(uint256[] memory factoryIds, address[] memory consumers)\\n\\t\\texternal\\n\\t\\tonlyOwner\\n\\t{\\n\\t\\tfor (uint256 i; i < factoryIds.length; i++) {\\n\\t\\t\\tFactory storage factory = factories[factoryIds[i]];\\n\\t\\t\\trequire(address(0) != factory.creator, 'Factory not found');\\n\\n\\t\\t\\tfactory.consumer = consumers[i];\\n\\t\\t}\\n\\t\\temit FactoriesUpdate(factoryIds);\\n\\t}\\n\\n\\t/**\\n\\t * @dev adds Donation recipients\\n\\t */\\n\\tfunction addDonationRecipientsBatch(\\n\\t\\taddress[] memory recipients,\\n\\t\\tstring[] memory names,\\n\\t\\tbool[] memory autos\\n\\t) external onlyOwner {\\n\\t\\tDonationRecipient[] storage donationRecipients_ = donationRecipients;\\n\\t\\tEnumerableSetUpgradeable.UintSet storage autoDonations_ = autoDonations;\\n\\t\\tuint256[] memory ids = new uint256[](recipients.length);\\n\\t\\tfor (uint256 i; i < recipients.length; i++) {\\n\\t\\t\\trequire(bytes(names[i]).length > 0, 'Invalid name');\\n\\t\\t\\tdonationRecipients_.push(\\n\\t\\t\\t\\tDonationRecipient({\\n\\t\\t\\t\\t\\tautoDonation: autos[i],\\n\\t\\t\\t\\t\\trecipient: recipients[i],\\n\\t\\t\\t\\t\\tname: names[i]\\n\\t\\t\\t\\t})\\n\\t\\t\\t);\\n\\t\\t\\tids[i] = donationRecipients_.length - 1;\\n\\t\\t\\tif (autos[i]) {\\n\\t\\t\\t\\tautoDonations_.add(ids[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\temit DonationRecipientsUpdate(ids);\\n\\t}\\n\\n\\t/**\\n\\t * @dev modify Donation recipients\\n\\t */\\n\\tfunction setDonationRecipientBatch(\\n\\t\\tuint256[] memory ids,\\n\\t\\taddress[] memory recipients,\\n\\t\\tstring[] memory names,\\n\\t\\tbool[] memory autos\\n\\t) external onlyOwner {\\n\\t\\tDonationRecipient[] storage donationRecipients_ = donationRecipients;\\n\\t\\tEnumerableSetUpgradeable.UintSet storage autoDonations_ = autoDonations;\\n\\t\\tfor (uint256 i; i < recipients.length; i++) {\\n\\t\\t\\tif (address(0) != recipients[i]) {\\n\\t\\t\\t\\tdonationRecipients_[ids[i]].recipient = recipients[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (bytes(names[i]).length > 0) {\\n\\t\\t\\t\\tdonationRecipients_[ids[i]].name = names[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\tdonationRecipients_[ids[i]].autoDonation = autos[i];\\n\\t\\t\\tif (autos[i]) {\\n\\t\\t\\t\\tautoDonations_.add(ids[i]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tautoDonations_.remove(ids[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\temit DonationRecipientsUpdate(ids);\\n\\t}\\n\\n\\t/**\\n\\t * @dev allows to update a factory metadata\\n\\t *\\n\\t * This can only be used by admins in very specific cases when a critical bug is found\\n\\t */\\n\\tfunction setFactoryMetadata(uint256 factoryId, string memory metadata) external onlyOwner {\\n\\t\\tFactory storage factory = factories[factoryId];\\n\\t\\trequire(address(0) != factory.creator, 'Factory not found');\\n\\t\\tfactory.metadata = metadata;\\n\\n\\t\\temit FactoriesUpdate(_asSingletonArray(factoryId));\\n\\t}\\n\\n\\tfunction setPlatformFee(uint16 fee) external onlyOwner {\\n\\t\\trequire(contractConfiguration.canEditPlatformFees == true, \\\"Can't edit platform fees\\\");\\n\\t\\trequire(fee <= 10000, 'Fees too high');\\n\\t\\tcontractConfiguration.platformFee = fee;\\n\\t\\temit ConfigurationUpdate();\\n\\t}\\n\\n\\tfunction setPlatformBeneficiary(address payable beneficiary) external onlyOwner {\\n\\t\\trequire(contractConfiguration.canEditPlatformFees == true, \\\"Can't edit platform fees\\\");\\n\\t\\trequire(address(beneficiary) != address(0), 'Invalid beneficiary');\\n\\t\\tcontractConfiguration.platformBeneficiary = beneficiary;\\n\\t\\temit ConfigurationUpdate();\\n\\t}\\n\\n\\tfunction setDefaultFactoryActivation(bool isDefaultActive) external onlyOwner {\\n\\t\\tcontractConfiguration.defaultFactoryActivation = isDefaultActive;\\n\\t\\temit ConfigurationUpdate();\\n\\t}\\n\\n\\tfunction setRestricted(bool restricted) external onlyOwner {\\n\\t\\tcontractConfiguration.restricted = restricted;\\n\\t\\temit ConfigurationUpdate();\\n\\t}\\n\\n\\tfunction setFactoriesConsumers(address unique, address editions) external onlyOwner {\\n\\t\\tif (address(0) != unique) {\\n\\t\\t\\tcontractConfiguration.uniqueConsumer = unique;\\n\\t\\t}\\n\\n\\t\\tif (address(0) != editions) {\\n\\t\\t\\tcontractConfiguration.editionsConsumer = editions;\\n\\t\\t}\\n\\n\\t\\temit ConfigurationUpdate();\\n\\t}\\n\\n\\t/**\\n\\t * @dev Pauses all token creation.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must have the `DEFAULT_ADMIN_ROLE`.\\n\\t */\\n\\tfunction pause() public virtual onlyOwner {\\n\\t\\t_pause();\\n\\t}\\n\\n\\t/**\\n\\t * @dev Unpauses all token creation.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must have the `DEFAULT_ADMIN_ROLE`.\\n\\t */\\n\\tfunction unpause() public virtual onlyOwner {\\n\\t\\t_unpause();\\n\\t}\\n\\n\\t/**\\n\\t * @dev This function does the minting process.\\n\\t * It checkes that the factory exists, and if there is a seed, that it wasn't already\\n\\t * used for it.\\n\\t *\\n\\t * Depending on the factory type, it will call the right contract to mint the token\\n\\t * to msg.sender\\n\\t *\\n\\t * Requirements:\\n\\t * - contract musn't be paused\\n\\t * - If there is a seed, it must not have been used for this Factory\\n\\t */\\n\\tfunction _mintFromFactory(\\n\\t\\tuint256 factoryId,\\n\\t\\tbytes32 seed,\\n\\t\\tstring memory openSeed,\\n\\t\\tuint256 amount,\\n\\t\\taddress to,\\n\\t\\taddress swapContract,\\n\\t\\tuint256 swapTokenId\\n\\t) internal whenNotPaused {\\n\\t\\trequire(amount >= 1, 'Amount is zero');\\n\\n\\t\\tFactory storage factory = factories[factoryId];\\n\\n\\t\\trequire(factory.active && !factory.paused, 'Factory inactive or not found');\\n\\t\\trequire(\\n\\t\\t\\tfactory.maxSupply == 0 || factory.created < factory.maxSupply,\\n\\t\\t\\t'Factory max supply reached'\\n\\t\\t);\\n\\n\\t\\t// if the factory requires a seed (user seed, random seed)\\n\\t\\tif (factory.withSeed) {\\n\\t\\t\\t// verify that the seed is not empty and that it was never used before\\n\\t\\t\\t// for this factory\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tseed != 0x0 && factoriesSeed[factoryId][seed] == false,\\n\\t\\t\\t\\t'Invalid seed or already taken'\\n\\t\\t\\t);\\n\\t\\t\\tfactoriesSeed[factoryId][seed] = true;\\n\\t\\t}\\n\\n\\t\\tfactory.created++;\\n\\n\\t\\taddress consumer = _doPayment(factoryId, factory, swapContract, swapTokenId);\\n\\n\\t\\t// if people mint to another address\\n\\t\\tif (to == address(0)) {\\n\\t\\t\\tto = msg.sender;\\n\\t\\t}\\n\\n\\t\\tuint256 tokenId =\\n\\t\\t\\tIFactoryConsumer(consumer).mint(\\n\\t\\t\\t\\tto,\\n\\t\\t\\t\\tfactoryId,\\n\\t\\t\\t\\tamount,\\n\\t\\t\\t\\tfactory.creator,\\n\\t\\t\\t\\tfactory.royaltyValue\\n\\t\\t\\t);\\n\\n\\t\\t// emit minting from factory event with data and seed\\n\\t\\temit MintFromFactory(\\n\\t\\t\\tfactoryId,\\n\\t\\t\\tto,\\n\\t\\t\\tfactory.created,\\n\\t\\t\\tconsumer,\\n\\t\\t\\ttokenId,\\n\\t\\t\\tseed,\\n\\t\\t\\topenSeed,\\n\\t\\t\\tmsg.value\\n\\t\\t);\\n\\n\\t\\tif (factory.created == factory.maxSupply) {\\n\\t\\t\\temit FactoryOut(factoryId);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _doPayment(\\n\\t\\tuint256 factoryId,\\n\\t\\tFactory storage factory,\\n\\t\\taddress swapContract,\\n\\t\\tuint256 swapTokenId\\n\\t) internal returns (address) {\\n\\t\\tContractConfiguration memory contractConfiguration_ = contractConfiguration;\\n\\t\\t// try swap\\n\\t\\tif (swapContract != address(0)) {\\n\\t\\t\\tTokenSwap memory swap = factorySwap[factoryId];\\n\\n\\t\\t\\t// verify that the swap asked is the right one\\n\\t\\t\\trequire(\\n\\t\\t\\t\\t// contract match\\n\\t\\t\\t\\tswap.swapContract == swapContract &&\\n\\t\\t\\t\\t\\t// and either ANY idea id works, either the given ID is the right one\\n\\t\\t\\t\\t\\t(!swap.fixedId || swap.swapTokenId == swapTokenId),\\n\\t\\t\\t\\t'Invalid swap'\\n\\t\\t\\t);\\n\\t\\t\\trequire(msg.value == 0, 'No value allowed when swapping');\\n\\n\\t\\t\\t// checking if ERC1155 or ERC721\\n\\t\\t\\t// and burn the tokenId\\n\\t\\t\\t// using 0xdead address to be sure it works with contracts\\n\\t\\t\\t// that have no burn function\\n\\t\\t\\t//\\n\\t\\t\\t// those functions calls should revert if there is a problem when transfering\\n\\t\\t\\tif (swap.is1155) {\\n\\t\\t\\t\\tIERC1155Upgradeable(swapContract).safeTransferFrom(\\n\\t\\t\\t\\t\\tmsg.sender,\\n\\t\\t\\t\\t\\taddress(0xdEaD),\\n\\t\\t\\t\\t\\tswapTokenId,\\n\\t\\t\\t\\t\\t1,\\n\\t\\t\\t\\t\\t''\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tIERC721Upgradeable(swapContract).transferFrom(\\n\\t\\t\\t\\t\\tmsg.sender,\\n\\t\\t\\t\\t\\taddress(0xdEaD),\\n\\t\\t\\t\\t\\tswapTokenId\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t} else if (factory.price > 0) {\\n\\t\\t\\trequire(msg.value == factory.price, 'Wrong value sent');\\n\\n\\t\\t\\tuint256 platformFee = (msg.value * uint256(contractConfiguration_.platformFee)) / 10000;\\n\\n\\t\\t\\tDonationRecipient[] memory donationRecipients_ = donationRecipients;\\n\\t\\t\\tuint256 donation;\\n\\t\\t\\tif (donationRecipients_.length > 0) {\\n\\t\\t\\t\\tdonation = (msg.value * uint256(factory.donationAmount)) / 10000;\\n\\n\\t\\t\\t\\t// send fees to platform\\n\\t\\t\\t\\tcontractConfiguration_.platformBeneficiary.transfer(platformFee);\\n\\n\\t\\t\\t\\tif (factory.donationId > 0) {\\n\\t\\t\\t\\t\\tpayable(donationRecipients_[factory.donationId - 1].recipient).transfer(\\n\\t\\t\\t\\t\\t\\tdonation\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// send to current cursor\\n\\t\\t\\t\\t\\tEnumerableSetUpgradeable.UintSet storage autoDonations_ = autoDonations;\\n\\n\\t\\t\\t\\t\\tpayable(donationRecipients_[autoDonations_.at(donationCursor)].recipient)\\n\\t\\t\\t\\t\\t\\t.transfer(donation);\\n\\t\\t\\t\\t\\tdonationCursor = (donationCursor + 1) % autoDonations_.length();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// send rest to creator\\n\\t\\t\\tpayable(factory.creator).transfer(msg.value - platformFee - donation);\\n\\t\\t}\\n\\n\\t\\tif (factory.consumer != address(0)) {\\n\\t\\t\\treturn factory.consumer;\\n\\t\\t}\\n\\n\\t\\treturn\\n\\t\\t\\tfactory.factoryType == FactoryType.Multiple\\n\\t\\t\\t\\t? contractConfiguration_.editionsConsumer\\n\\t\\t\\t\\t: contractConfiguration_.uniqueConsumer;\\n\\t}\\n\\n\\tfunction _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n\\t\\tuint256[] memory array = new uint256[](1);\\n\\t\\tarray[0] = element;\\n\\n\\t\\treturn array;\\n\\t}\\n\\n\\t/**\\n\\t * @dev do not accept value sent directly to contract\\n\\t */\\n\\treceive() external payable {\\n\\t\\trevert('No value accepted');\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/Factories/FactoryStorage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol';\\n\\ncontract FactoryStorage {\\n\\tenum FactoryType {Unique, Multiple}\\n\\n\\tstruct DonationRecipient {\\n\\t\\tbool autoDonation;\\n\\t\\taddress recipient;\\n\\t\\tstring name;\\n\\t}\\n\\n\\tstruct TokenSwap {\\n\\t\\tbool is1155;\\n\\t\\tbool fixedId;\\n\\t\\taddress swapContract;\\n\\t\\tuint256 swapTokenId;\\n\\t}\\n\\n\\tstruct Factory {\\n\\t\\t// factory type\\n\\t\\tFactoryType factoryType;\\n\\t\\t// factory creator\\n\\t\\taddress creator;\\n\\t\\t// if factory is active or not\\n\\t\\t// this is changed by beyondNFT admins if abuse with factories\\n\\t\\tbool active;\\n\\t\\t// if factory is paused or not <- this is changed by creator\\n\\t\\tbool paused;\\n\\t\\t// if the factory requires a seed\\n\\t\\tbool withSeed;\\n\\t\\t// the contract this factory mint with\\n\\t\\taddress consumer;\\n\\t\\t// donation amount, 2.5% (250) is the minimum amount\\n\\t\\tuint16 donationAmount;\\n\\t\\t// id of the donation recipient for this factory\\n\\t\\t// this id must be id + 1, so 0 can be considered as automatic\\n\\t\\tuint256 donationId;\\n\\t\\t// price to mint\\n\\t\\tuint256 price;\\n\\t\\t// how many were minted already\\n\\t\\tuint256 created;\\n\\t\\t// 0 if infinite\\n\\t\\tuint256 maxSupply;\\n\\t\\t// royalties\\n\\t\\tuint256 royaltyValue;\\n\\t\\t// The factory metadata uri, contains all informations about where to find code, properties etc...\\n\\t\\t// this is the base that will be used to create NFTs\\n\\t\\tstring metadata;\\n\\t}\\n\\n\\tstruct ContractConfiguration {\\n\\t\\tbool restricted;\\n\\t\\tbool defaultFactoryActivation;\\n\\t\\taddress uniqueConsumer;\\n\\t\\taddress editionsConsumer;\\n\\t\\tbool canEditPlatformFees;\\n\\t\\tuint16 platformFee;\\n\\t\\tuint16 donationMinimum;\\n\\t\\taddress payable platformBeneficiary;\\n\\t}\\n\\n\\tContractConfiguration public contractConfiguration;\\n\\n\\tuint256 public factoriesCount;\\n\\n\\t// the factories\\n\\tmapping(uint256 => Factory) public factories;\\n\\n\\t// some factories allow to swap other contracts token again one from the factory\\n\\tmapping(uint256 => TokenSwap) public factorySwap;\\n\\n\\t// the seeds already used by each factories\\n\\t// not in the struct as it complicated things\\n\\tmapping(uint256 => mapping(bytes32 => bool)) public factoriesSeed;\\n\\n\\tDonationRecipient[] public donationRecipients;\\n\\n\\tuint256 donationCursor;\\n\\tEnumerableSetUpgradeable.UintSet internal autoDonations;\\n}\\n\"\r\n    },\r\n    \"contracts/Factories/IFactoryConsumer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IFactoryConsumer {\\n\\tfunction mint(\\n\\t\\taddress creator,\\n\\t\\tuint256 factoryId,\\n\\t\\tuint256 amount,\\n\\t\\taddress royaltyRecipient,\\n\\t\\tuint256 royaltyValue\\n\\t) external returns (uint256);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[],\"name\":\"ConfigurationUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"DonationRecipientsUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"factoryIds\",\"type\":\"uint256[]\"}],\"name\":\"FactoriesUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"FactoryCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"FactoryOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"factoryId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createdIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"data\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"seed\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"MintFromFactory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"},{\"internalType\":\"bool[]\",\"name\":\"autos\",\"type\":\"bool[]\"}],\"name\":\"addDonationRecipientsBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractConfiguration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"restricted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"defaultFactoryActivation\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"uniqueConsumer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"editionsConsumer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"canEditPlatformFees\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"platformFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"donationMinimum\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"platformBeneficiary\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donationRecipients\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"autoDonation\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"factories\",\"outputs\":[{\"internalType\":\"enum FactoryStorage.FactoryType\",\"name\":\"factoryType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withSeed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"donationAmount\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"donationId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"created\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltyValue\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factoriesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"factoriesSeed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"factorySwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"is1155\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"fixedId\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"swapContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"platformBeneficiary\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"platformFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"donationMinimum\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"restricted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"defaultActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canEditPlatformFees\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"ownedBy\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"factoryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapTokenId\",\"type\":\"uint256\"}],\"name\":\"mintFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"factoryId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapTokenId\",\"type\":\"uint256\"}],\"name\":\"mintWithHash\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"factoryId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"seed\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapTokenId\",\"type\":\"uint256\"}],\"name\":\"mintWithOpenSeed\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FactoryStorage.FactoryType\",\"name\":\"factoryType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withSeed\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"royaltyValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"registerFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isDefaultActive\",\"type\":\"bool\"}],\"name\":\"setDefaultFactoryActivation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"},{\"internalType\":\"bool[]\",\"name\":\"autos\",\"type\":\"bool[]\"}],\"name\":\"setDonationRecipientBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unique\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"editions\",\"type\":\"address\"}],\"name\":\"setFactoriesConsumers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"factoryIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"areActive\",\"type\":\"bool[]\"}],\"name\":\"setFactoryActiveBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"factoryIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"consumers\",\"type\":\"address[]\"}],\"name\":\"setFactoryConsumerBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"factoryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"donationId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"donationAmount\",\"type\":\"uint16\"}],\"name\":\"setFactoryDonation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"factoryId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"setFactoryMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"factoryId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"setFactoryPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"factoryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setFactoryPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"factoryId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fixedId\",\"type\":\"bool\"}],\"name\":\"setFactorySwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"setPlatformBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"}],\"name\":\"setPlatformFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"restricted\",\"type\":\"bool\"}],\"name\":\"setRestricted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BeyondFactories","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}