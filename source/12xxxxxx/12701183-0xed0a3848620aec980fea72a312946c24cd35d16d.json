{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.2;\r\n\r\ninterface IERC20Token {\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n}\r\n\r\ninterface IERC721 {\r\n\r\n    function setPaymentDate(uint256 _asset) external;\r\n    function getTokenDetails(uint256 index) external view returns (uint128 lastvalue, uint32 aType, uint32 customDetails, uint32 lastTx, uint32 lastPayment);\r\n    function polkaCitizens() external view returns(uint256 _citizens);\r\n    function assetsByType(uint256 _assetType) external view returns (uint64 maxAmount, uint64 mintedAmount, uint128 baseValue);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n   \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n   \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    \r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n   \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n  \r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ncontract PolkaProfitContract is Ownable {\r\n    \r\n    event Payment(address indexed _from, uint256 _amount, uint8 _network);\r\n    \r\n    bool public paused;\r\n\r\n    struct paymentByType {\r\n        uint256 weeklyPayment;\r\n        uint256 variantFactor; \r\n        uint256 basePriceFactor;\r\n    }\r\n    \r\n    struct Claim {\r\n        address account;\r\n        uint8 dNetwork;  // 1= Ethereum   2= BSC\r\n        uint256 assetId;\r\n        uint256 amount;\r\n        uint256 date;\r\n    }\r\n    \r\n    Claim[] public payments;\r\n    \r\n    mapping (address => bool) public blackListed;\r\n    mapping (uint256 => paymentByType) public paymentAmount;\r\n    address public nftAddress = 0x57E9a39aE8eC404C08f88740A9e6E306f50c937f;\r\n    address public tokenAddress = 0xaA8330FB2B4D5D07ABFE7A72262752a8505C6B37;\r\n    address payable public walletAddress;\r\n    uint256 public gasFee = 1000000000000000;\r\n    \r\n\r\n    uint256 wUnit = 1 weeks;\r\n    \r\n    constructor() {\r\n        fillPayments(1,    60000000000000000000, 10, 15000000000000);\r\n        fillPayments(2,   135000000000000000000, 10, 30000000000000);\r\n        fillPayments(3,   375000000000000000000, 10, 75000000000000);\r\n        fillPayments(4,   550000000000000000000, 10, 100000000000000);\r\n        fillPayments(5,   937500000000000000000, 10, 150000000000000);\r\n        fillPayments(6,  8250000000000000000000, 10, 750000000000000);\r\n        fillPayments(7,  6500000000000000000000, 10, 655000000000000);\r\n        fillPayments(8,  3000000000000000000000, 20, 400000000000000);\r\n        fillPayments(9, 10800000000000000000000, 50, 900000000000000);\r\n        fillPayments(10, 5225000000000000000000, 30, 550000000000000);\r\n        fillPayments(11,13125000000000000000000, 20, 1050000000000000);\r\n        fillPayments(12, 4500000000000000000000, 10, 500000000000000);\r\n        fillPayments(13, 1500000000000000000000, 10, 225000000000000);\r\n        fillPayments(14, 2100000000000000000000, 15, 300000000000000);\r\n        fillPayments(15, 3750000000000000000000, 10, 450000000000000);\r\n        \r\n        walletAddress = payable(0xeA50CE6EBb1a5E4A8F90Bfb35A2fb3c3F0C673ec);\r\n\r\n    }\r\n    \r\n    function fillPayments(uint256 _assetId, uint256 _weeklyPayment, uint256 _variantFactor, uint256 _basePriceFactor) private {\r\n        paymentAmount[_assetId].weeklyPayment = _weeklyPayment;\r\n        paymentAmount[_assetId].variantFactor = _variantFactor;\r\n        paymentAmount[_assetId].basePriceFactor = _basePriceFactor;\r\n    }\r\n    \r\n    function profitsPayment(uint256 _assetId) public returns (bool success) {\r\n        require(paused == false, \"Contract is paused\");\r\n        IERC721 nft = IERC721(nftAddress);\r\n        address assetOwner = nft.ownerOf(_assetId);\r\n        require(assetOwner == msg.sender, \"Only asset owner can claim profits\");\r\n        require(blackListed[assetOwner] == false, \"This address cannot claim profits\");\r\n        (uint256 totalPayment, ) = calcProfit(_assetId);\r\n        require (totalPayment > 0, \"You need to wait at least 1 week to claim\");\r\n        nft.setPaymentDate(_assetId);\r\n        IERC20Token token = IERC20Token(tokenAddress);\r\n        require(token.transferFrom(walletAddress, assetOwner, totalPayment), \"ERC20 transfer fail\");\r\n        Claim memory thisclaim = Claim(msg.sender, 1,  _assetId, totalPayment, block.timestamp);\r\n        payments.push(thisclaim);\r\n        emit Payment(msg.sender, totalPayment, 1);\r\n        return true;\r\n    }\r\n    \r\n    function profitsPaymentBSC(uint256 _assetId) public payable  returns (bool success) {\r\n        require(paused == false, \"Contract is paused\");\r\n        require(msg.value >= gasFee, \"Gas fee too low\");\r\n        IERC721 nft = IERC721(nftAddress);\r\n        address assetOwner = nft.ownerOf(_assetId);\r\n        require(assetOwner == msg.sender, \"Only asset owner can claim profits\");\r\n        require(blackListed[assetOwner] == false, \"This address cannot claim profits\");\r\n        (uint256 totalPayment, ) = calcProfit(_assetId);\r\n        require (totalPayment > 0, \"You need to wait at least 1 week to claim\");\r\n        nft.setPaymentDate(_assetId);\r\n        Address.sendValue(walletAddress, msg.value);\r\n        Claim memory thisclaim = Claim(msg.sender, 2, _assetId, totalPayment, block.timestamp);\r\n        payments.push(thisclaim);\r\n        emit Payment(msg.sender, totalPayment, 2);\r\n        return true;\r\n    }\r\n    \r\n    function calcProfit(uint256 _assetId) public view returns (uint256 _profit, uint256 _lastPayment) {\r\n        IERC721 nft = IERC721(nftAddress);\r\n        ( , uint32 assetType,, uint32 lastTransfer, uint32 lastPayment ) = nft.getTokenDetails(_assetId);\r\n        uint256 cTime = block.timestamp - lastTransfer;\r\n        uint256 dTime = 0;\r\n        if (lastTransfer < lastPayment) {\r\n            dTime = lastPayment - lastTransfer;\r\n        }\r\n        if ((cTime) < wUnit) { \r\n            return (0, lastTransfer);\r\n        } else {\r\n             uint256 weekCount;  \r\n            if (dTime == 0) {\r\n                weekCount = ((cTime)/(wUnit));\r\n            } else {\r\n                weekCount = ((cTime)/(wUnit)) - (dTime)/(wUnit);\r\n            }\r\n            if (weekCount < 1) {\r\n                return (0, lastPayment);\r\n            } else {\r\n                uint256 daysCount = weekCount * 7; //  \r\n                uint256 variantCount;\r\n                if (assetType == 8 || assetType == 15) {\r\n                    variantCount = countTaxis();\r\n                } else {\r\n                    variantCount = nft.polkaCitizens();\r\n                }\r\n                uint256 totalPayment;\r\n                paymentByType memory thisPayment = paymentAmount[uint256(assetType)];\r\n                uint256 dailyProfit = ((thisPayment.basePriceFactor*(variantCount*thisPayment.variantFactor))/30)*daysCount;\r\n                totalPayment = ((weekCount * thisPayment.weeklyPayment) + dailyProfit);\r\n                return (totalPayment, lastPayment);  \r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    function calcTotalEarnings(uint256 _assetId) public view returns (uint256 _profit, uint256 _lastPayment) {\r\n        IERC721 nft = IERC721(nftAddress);\r\n        ( , uint32 assetType,, uint32 lastTransfer, ) = nft.getTokenDetails(_assetId);\r\n        uint256 timeFrame = block.timestamp - lastTransfer;\r\n        if (timeFrame < wUnit) {  \r\n            return (0, lastTransfer);\r\n        } else {\r\n            uint256 weekCount = timeFrame/(wUnit); \r\n            uint256 daysCount = weekCount * 7;  \r\n            uint256 variantCount;\r\n            if (assetType == 8 || assetType == 15) {\r\n                variantCount = countTaxis();\r\n            } else {\r\n                variantCount = nft.polkaCitizens();\r\n            }\r\n            uint256 totalPayment;\r\n            paymentByType memory thisPayment = paymentAmount[uint256(assetType)];\r\n            uint256 dailyProfit = ((thisPayment.basePriceFactor*(variantCount*thisPayment.variantFactor))/30)*daysCount;\r\n            totalPayment = ((weekCount * thisPayment.weeklyPayment) + dailyProfit);\r\n            return (totalPayment, lastTransfer);    \r\n        }\r\n\r\n    }\r\n    \r\n\r\n    function countTaxis() private view returns (uint256 taxis) {\r\n        uint256 taxiCount = 0;\r\n        uint64 assetMinted;\r\n        IERC721 nft = IERC721(nftAddress);\r\n        (, assetMinted,) = nft.assetsByType(1);\r\n        taxiCount += uint256(assetMinted);\r\n        (, assetMinted,) = nft.assetsByType(2);\r\n        taxiCount += uint256(assetMinted);\r\n        (, assetMinted,) = nft.assetsByType(3);\r\n        taxiCount += uint256(assetMinted);\r\n        (, assetMinted,) = nft.assetsByType(4);\r\n        taxiCount += assetMinted;\r\n        (, assetMinted,) = nft.assetsByType(5);\r\n        taxiCount += uint256(assetMinted);\r\n        return taxiCount;\r\n    }\r\n\r\n    \r\n    function pauseContract(bool _paused) public onlyOwner {\r\n        paused = _paused;\r\n    }\r\n    \r\n    function blackList(address _wallet, bool _blacklist) public onlyOwner {\r\n        blackListed[_wallet] = _blacklist;\r\n    }\r\n\r\n    function paymentCount() public view returns (uint256 _paymentCount) {\r\n        return payments.length;\r\n    }\r\n    \r\n    function paymentDetail(uint256 _paymentIndex) public view returns (address _to, uint8 _network, uint256 assetId, uint256 _amount, uint256 _date) {\r\n        Claim memory thisPayment = payments[_paymentIndex];\r\n        return (thisPayment.account, thisPayment.dNetwork, thisPayment.assetId, thisPayment.amount, thisPayment.date);\r\n    }\r\n    \r\n    function setGasFee(uint256 _gasFee) public onlyOwner {\r\n        gasFee = _gasFee;\r\n    }\r\n    \r\n    function setWalletAddress(address _wallet) public onlyOwner {\r\n        walletAddress = payable(_wallet);\r\n    }\r\n    \r\n    \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_network\",\"type\":\"uint8\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_blacklist\",\"type\":\"bool\"}],\"name\":\"blackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"calcProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastPayment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"calcTotalEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastPayment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paymentAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weeklyPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variantFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePriceFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_paymentCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_paymentIndex\",\"type\":\"uint256\"}],\"name\":\"paymentDetail\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_network\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"dNetwork\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"profitsPayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"profitsPaymentBSC\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasFee\",\"type\":\"uint256\"}],\"name\":\"setGasFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PolkaProfitContract","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f5c48aa898ae2e1903ec7a0325c870e1e9383843b8e770a5494e9de58fecb56e"}]}