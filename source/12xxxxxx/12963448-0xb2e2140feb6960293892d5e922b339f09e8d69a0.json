{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"HashSale.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\n\\r\\ncontract HashSale is Ownable {\\r\\n\\taddress public hashTokenAddress;\\r\\n\\taddress payable paymentAddress;\\r\\n\\taddress kycSigner;\\r\\n\\tuint public endTime;\\r\\n\\tuint public stageAmount;\\r\\n\\tuint public minPayAmount;\\r\\n\\tuint public tokensSold = 0;\\r\\n\\tuint public tokensWithdrawn = 0;\\r\\n\\tuint public discountThreshold;\\r\\n\\tuint8 public discount = 25;\\r\\n\\tuint8 public currentStage = 0;\\r\\n\\tbool isFinished = false;\\r\\n\\tuint public constant HASH_TOKEN_DECIMALS = 18;\\r\\n\\tstring public constant AGREEMENT = \\\"I confirm I am not a citizen, national, resident (tax or otherwise) or holder of a green card of the USA and have never been a citizen, national, resident (tax or otherwise) or holder of a green card of the USA in the past.\\\";\\r\\n\\tstring constant AGREEMENT_LENGTH = \\\"223\\\";\\r\\n\\r\\n    struct Stage {\\r\\n        uint tokenPrice;\\r\\n        uint tokensSold;\\r\\n    }\\r\\n\\tstruct Sale {\\r\\n\\t    address customerAddress;\\r\\n\\t\\tuint payAmount;\\r\\n\\t\\tuint tokenAmount;\\r\\n\\t\\tbytes agreementSignature;\\r\\n\\t\\tuint16 referral;\\r\\n\\t\\tbool tokensWithdrawn;\\r\\n\\t}\\r\\n\\r\\n\\tStage[] public stages;\\r\\n\\tSale[] public sales;\\r\\n\\r\\n\\tevent NewSale(uint indexed saleId, address indexed customerAddress, uint16 indexed referral, uint payAmount, uint tokenAmount, uint8 stage, uint stageSales, bool isSaleFinished);\\r\\n\\tevent TokensWithdrawn(address indexed customerAddress, uint tokenAmount);\\r\\n\\tevent StageSwitch(uint8 previousStage, uint8 newStage, bool isSaleFinished);\\r\\n\\r\\n\\tconstructor(\\r\\n\\t    address _hashTokenAddress, address payable _paymentAddress, address _kycSigner, uint _endTime,\\r\\n\\t    uint _stageAmount, uint _minPayAmount, uint _discountThreshold,\\r\\n\\t    uint _tokenPrice1, uint _tokenPrice2, uint _tokenPrice3, uint _tokenPrice4, uint _tokenPrice5\\r\\n    ) {\\r\\n        hashTokenAddress = _hashTokenAddress;\\r\\n        paymentAddress = _paymentAddress;\\r\\n        endTime = _endTime;\\r\\n        stageAmount = _stageAmount * (10 ** HASH_TOKEN_DECIMALS);\\r\\n        minPayAmount = _minPayAmount;\\r\\n        kycSigner = _kycSigner;\\r\\n        discountThreshold = _discountThreshold;\\r\\n        stages.push(Stage(_tokenPrice1, 0));\\r\\n        stages.push(Stage(_tokenPrice2, 0));\\r\\n\\t\\tstages.push(Stage(_tokenPrice3, 0));\\r\\n\\t\\tstages.push(Stage(_tokenPrice4, 0));\\r\\n\\t\\tstages.push(Stage(_tokenPrice5, 0));\\r\\n    }\\r\\n\\r\\n    function changeKycSigner(address _kycSigner) public onlyOwner {\\r\\n        require(_kycSigner != address(0), \\\"Incorrect address\\\");\\r\\n        kycSigner = _kycSigner;\\r\\n    }\\r\\n\\r\\n    function changeMinPayAmount(uint _minPayAmount) public onlyOwner {\\r\\n        minPayAmount = _minPayAmount;\\r\\n    }\\r\\n\\r\\n    function changeDiscount(uint8 _discount) public onlyOwner {\\r\\n        discount = _discount;\\r\\n    }\\r\\n\\r\\n    function changeDiscountThreshold(uint _discountThreshold) public onlyOwner {\\r\\n        discountThreshold = _discountThreshold;\\r\\n    }\\r\\n\\r\\n    function switchStage(uint8 _stage) public onlyOwner {\\r\\n        require(!isSaleFinished(), \\\"The sale is over\\\");\\r\\n        uint8 previousStage = currentStage;\\r\\n        _switchStage(_stage);\\r\\n        emit StageSwitch(previousStage, currentStage, isFinished);\\r\\n    }\\r\\n\\r\\n    function withdrawRemainingTokens(uint _tokenAmount) public onlyOwner {\\r\\n        require(_tokenAmount \\u003e 0, \\\"Nothing to withdraw\\\");\\r\\n        require(_tokenAmount \\u003c= _getHashBalance(), \\\"Not enough HASH tokens to withdraw\\\");\\r\\n        TransferHelper.safeTransfer(hashTokenAddress, msg.sender, _tokenAmount);\\r\\n    }\\r\\n\\r\\n\\tfunction buyTokens(bytes calldata _agreementSignature, uint16 _referral) payable public {\\r\\n\\t    require(!isSaleFinished(), \\\"The sale is over\\\");\\r\\n\\t    require(msg.value \\u003e= minPayAmount, \\\"Amount must be greater than the minimal value\\\");\\r\\n\\t\\trequire (_verifySign(_agreementSignature, msg.sender), \\\"Incorrect agreement signature\\\");\\r\\n\\t\\tuint etherAmount = msg.value;\\r\\n\\t\\tif (etherAmount \\u003e= discountThreshold) {\\r\\n\\t\\t    etherAmount = etherAmount * 100 / (100 - discount);\\r\\n\\t\\t}\\r\\n\\t\\tuint tokenAmount = 0;\\r\\n\\t\\tfor (uint8 i = currentStage; i \\u003c stages.length \\u0026\\u0026 etherAmount \\u003e 0; i++) {\\r\\n\\t\\t    uint buyAmount = _calculateTokenAmount(etherAmount, i);\\r\\n\\t\\t    uint thisStageAmount = stageAmount - stages[i].tokensSold;\\r\\n\\t\\t    if (buyAmount \\u003e= thisStageAmount) {\\r\\n\\t\\t        tokenAmount += thisStageAmount;\\r\\n\\t\\t        etherAmount -= _calculateEtherAmount(thisStageAmount, i);\\r\\n\\t\\t        stages[i].tokensSold = stageAmount;\\r\\n\\t\\t        _switchStage(currentStage + 1);\\r\\n\\t\\t    } else {\\r\\n\\t\\t        tokenAmount += buyAmount;\\r\\n\\t\\t        etherAmount = 0;\\r\\n\\t\\t        stages[i].tokensSold += buyAmount;\\r\\n\\t\\t    }\\r\\n\\t\\t}\\r\\n\\t\\trequire(etherAmount == 0, \\\"Not enough HASH tokens to buy\\\");\\r\\n\\t\\trequire(tokenAmount \\u003e 0, \\\"Amount must be greater than 0\\\");\\r\\n\\t\\ttokensSold += tokenAmount;\\r\\n\\t\\tpaymentAddress.transfer(msg.value);\\r\\n\\t\\tuint saleId = sales.length;\\r\\n\\t\\tsales.push(Sale(msg.sender, msg.value, tokenAmount, _agreementSignature, _referral, false));\\r\\n\\t\\temit NewSale(saleId, msg.sender, _referral, msg.value, tokenAmount, currentStage, stages[currentStage].tokensSold, isFinished);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getUnwithdrawnTokenAmount(address _customerAddress) public view returns (uint tokenAmount) {\\r\\n\\t    tokenAmount = 0;\\r\\n\\t    for (uint i = 0; i \\u003c sales.length; i++) {\\r\\n\\t\\t\\tif (sales[i].customerAddress == _customerAddress \\u0026\\u0026 sales[i].tokensWithdrawn == false) {\\r\\n\\t\\t\\t\\ttokenAmount += sales[i].tokenAmount;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction withdrawTokens(bytes calldata _kycSignature) public {\\r\\n\\t    require(isSaleFinished(), \\\"The withdrawal of HASH tokens is not yet available\\\");\\r\\n\\t    require(_verifyKycSign(_kycSignature, msg.sender), \\\"Incorrect KYC signature\\\");\\r\\n\\t    uint tokenAmount = 0;\\r\\n\\t    for (uint i = 0; i \\u003c sales.length; i++) {\\r\\n\\t\\t\\tif (sales[i].customerAddress == msg.sender \\u0026\\u0026 sales[i].tokensWithdrawn == false) {\\r\\n\\t\\t\\t\\ttokenAmount += sales[i].tokenAmount;\\r\\n\\t\\t\\t\\tsales[i].tokensWithdrawn = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\trequire(tokenAmount \\u003e 0, \\\"You have nothing to withdraw\\\");\\r\\n\\t\\ttokensWithdrawn += tokenAmount;\\r\\n        TransferHelper.safeTransfer(hashTokenAddress, msg.sender, tokenAmount);\\r\\n\\t\\temit TokensWithdrawn(msg.sender, tokenAmount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction isSaleFinished() public view returns (bool) {\\r\\n\\t    return isFinished || block.timestamp \\u003e endTime;\\r\\n\\t}\\r\\n\\r\\n\\tfunction calculateTokenAmount(uint etherAmount) public view returns(uint tokenAmount) {\\r\\n\\t    require(!isSaleFinished(), \\\"The sale is over\\\");\\r\\n\\t    require(etherAmount \\u003e= minPayAmount, \\\"Amount must be greater than the minimal value\\\");\\r\\n\\t    if (etherAmount \\u003e= discountThreshold) {\\r\\n            etherAmount = etherAmount * 100 / (100 - discount);\\r\\n        }\\r\\n\\t    for (uint8 i = currentStage; i \\u003c stages.length \\u0026\\u0026 etherAmount \\u003e 0; i++) {\\r\\n\\t\\t    uint buyAmount = _calculateTokenAmount(etherAmount, i);\\r\\n\\t\\t    uint thisStageAmount = stageAmount - stages[i].tokensSold;\\r\\n\\t\\t    if (buyAmount \\u003e= thisStageAmount) {\\r\\n\\t\\t        tokenAmount += thisStageAmount;\\r\\n\\t\\t        etherAmount -= _calculateEtherAmount(thisStageAmount, i);\\r\\n\\t\\t    } else {\\r\\n\\t\\t        tokenAmount += buyAmount;\\r\\n\\t\\t        etherAmount = 0;\\r\\n\\t\\t    }\\r\\n\\t\\t}\\r\\n\\t\\trequire(etherAmount == 0, \\\"Not enough HASH tokens to buy\\\");\\r\\n\\t}\\r\\n\\r\\n\\tfunction getMinAndMaxPayAmounts() public view returns(uint, uint) {\\r\\n\\t    uint maxPayAmount = 0;\\r\\n\\t    for (uint8 i = currentStage; i \\u003c stages.length \\u0026\\u0026 !isSaleFinished(); i++) {\\r\\n\\t\\t    uint thisStageAmount = stageAmount - stages[i].tokensSold;\\r\\n\\t\\t    maxPayAmount += _calculateEtherAmount(thisStageAmount, i);\\r\\n\\t\\t}\\r\\n\\t\\tif (maxPayAmount \\u003e= discountThreshold) {\\r\\n\\t\\t    uint maxPayAmountWithDiscount = maxPayAmount * (100 - discount) / 100;\\r\\n\\t\\t    if (maxPayAmountWithDiscount \\u003e= discountThreshold) {\\r\\n\\t\\t        maxPayAmount = maxPayAmountWithDiscount;\\r\\n\\t\\t    } else {\\r\\n\\t\\t        maxPayAmount = discountThreshold - 1;\\r\\n\\t\\t    }\\r\\n\\t\\t}\\r\\n\\t\\treturn (minPayAmount, maxPayAmount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _switchStage(uint8 _stage) private {\\r\\n\\t    require(_stage \\u003e currentStage, \\\"The next stage value must be more than the current one\\\");\\r\\n\\t    if (_stage \\u003e= stages.length) {\\r\\n\\t        isFinished = true;\\r\\n        } else {\\r\\n            currentStage = _stage;\\r\\n        }\\r\\n\\t}\\r\\n\\r\\n\\tfunction _calculateTokenAmount(uint etherAmount, uint8 stage) private view returns(uint tokenAmount) {\\r\\n\\t    tokenAmount = etherAmount * (10 ** HASH_TOKEN_DECIMALS) / stages[stage].tokenPrice;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _calculateEtherAmount(uint tokenAmount, uint8 stage) private view returns(uint etherAmount) {\\r\\n\\t    etherAmount = tokenAmount * stages[stage].tokenPrice / (10 ** HASH_TOKEN_DECIMALS);\\r\\n\\t}\\r\\n\\r\\n    function _getHashBalance() private returns(uint balance) {\\r\\n        (bool success, bytes memory data) = hashTokenAddress.call(\\r\\n            abi.encodeWithSelector(bytes4(keccak256(bytes(\\u0027balanceOf(address)\\u0027))), address(this))\\r\\n        );\\r\\n        require(success, \\\"Getting HASH balance failed\\\");\\r\\n        balance = abi.decode(data, (uint));\\r\\n    }\\r\\n\\r\\n\\tfunction _verifySign(bytes memory _sign, address _signer) pure private returns (bool) {\\r\\n        bytes32 hash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", AGREEMENT_LENGTH, AGREEMENT));\\r\\n        address[] memory signList = _recoverAddresses(hash, _sign);\\r\\n        return signList[0] == _signer;\\r\\n    }\\r\\n\\r\\n    function _verifyKycSign(bytes memory _sign, address _customerAddress) view private returns (bool) {\\r\\n        bytes32 hash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n20\\\", _customerAddress));\\r\\n        address[] memory signList = _recoverAddresses(hash, _sign);\\r\\n        return signList[0] == kycSigner;\\r\\n    }\\r\\n\\r\\n\\tfunction _recoverAddresses(bytes32 _hash, bytes memory _signatures) pure private returns (address[] memory addresses) {\\r\\n        uint8 v;\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint count = _countSignatures(_signatures);\\r\\n        addresses = new address[](count);\\r\\n        for (uint i = 0; i \\u003c count; i++) {\\r\\n            (v, r, s) = _parseSignature(_signatures, i);\\r\\n            addresses[i] = ecrecover(_hash, v, r, s);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\tfunction _parseSignature(bytes memory _signatures, uint _pos) pure private returns (uint8 v, bytes32 r, bytes32 s) {\\r\\n        uint offset = _pos * 65;\\r\\n        assembly {\\r\\n            r := mload(add(_signatures, add(32, offset)))\\r\\n            s := mload(add(_signatures, add(64, offset)))\\r\\n            v := and(mload(add(_signatures, add(65, offset))), 0xff)\\r\\n        }\\r\\n        if (v \\u003c 27) v += 27;\\r\\n        require(v == 27 || v == 28);\\r\\n    }\\r\\n\\r\\n    function _countSignatures(bytes memory _signatures) pure private returns (uint) {\\r\\n        return _signatures.length % 65 == 0 ? _signatures.length / 65 : 0;\\r\\n    }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity \\u003e=0.6.0;\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::safeApprove: approve failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::safeTransfer: transfer failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::transferFrom: transferFrom failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, \\u0027TransferHelper::safeTransferETH: ETH transfer failed\\u0027);\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hashTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_paymentAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_kycSigner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stageAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_discountThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPrice1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPrice2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPrice3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPrice4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPrice5\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"saleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"referral\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"stage\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stageSales\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSaleFinished\",\"type\":\"bool\"}],\"name\":\"NewSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"previousStage\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newStage\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSaleFinished\",\"type\":\"bool\"}],\"name\":\"StageSwitch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AGREEMENT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HASH_TOKEN_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_agreementSignature\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"_referral\",\"type\":\"uint16\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"calculateTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_discount\",\"type\":\"uint8\"}],\"name\":\"changeDiscount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_discountThreshold\",\"type\":\"uint256\"}],\"name\":\"changeDiscountThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kycSigner\",\"type\":\"address\"}],\"name\":\"changeKycSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPayAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinPayAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discountThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinAndMaxPayAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"getUnwithdrawnTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSaleFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPayAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sales\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"agreementSignature\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"referral\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"tokensWithdrawn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stageAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensSold\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"switchStage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawRemainingTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_kycSignature\",\"type\":\"bytes\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"HashSale","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000eb1112ac78d537853150e2a07e8b765e29d3f019000000000000000000000000a0d7c4d9b5e9153f52f0dadee30ad1ee14553d060000000000000000000000001ff6b1843666fe8370e5e66de7cbda0f3226d43c00000000000000000000000000000000000000000000000000000000618449d00000000000000000000000000000000000000000000000000000000000989680000000000000000000000000000000000000000000000000008e1bc9bf040000000000000000000000000000000000000000000000000001158e460913d00000000000000000000000000000000000000000000000000000000025e546dd9aaa00000000000000000000000000000000000000000000000000004bca8dbb3555000000000000000000000000000000000000000000000000000052ae6c120ba200000000000000000000000000000000000000000000000000005af3107a40000000000000000000000000000000000000000000000000000000650e124ef1c7","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://210d8c0305b24825a45cd7df53cc2afc64861409daa5f67d42875d705424127e"}]}