{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at BscScan.com on 2021-04-05\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2021-03-26\r\n*/\r\n\r\npragma solidity 0.5.9;\r\n\r\nlibrary Math {\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);//changes (a+b )/2\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address  payable  _owner;\r\n    address payable internal newOwner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n    modifier onlyOwner {\r\n        require(msg.sender == _owner);\r\n        _;\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n    function _transferOwnership(address payable _newOwner) internal {\r\n          newOwner = _newOwner;\r\n    }\r\n    //this flow is to prevent transferring ownership to wrong wallet by mistake\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ninterface Executor {\r\n    function execute(uint, uint, uint, uint) external;\r\n}\r\n\r\n\r\ncontract UnitiDex_Governance is Ownable  {\r\n    mapping(address=>bool) public owners;\r\n\r\n \r\n   \r\n\r\n    bool public breaker = false;\r\n    uint256 deadlineIndex = 0;\r\n    uint256 public MinTokenForVote=0;\r\n    address public RYIPToken=address(0);\r\n    uint256 public tokenFreezeDuration=86400;// default 1 day or 24 hours\r\n\r\n    //mapping(address=> mapping(uint256=> uint256)) public deadline;\r\n    \r\n     mapping(address => bool) public voters;\r\n\r\n    struct stake{\r\n        uint time;\r\n        uint amount;\r\n    }\r\n    mapping(address=>stake[]) public details;\r\n\r\n\r\n    function setBreaker(bool _breaker) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        breaker = _breaker;\r\n    }\r\n\r\n    mapping(address => uint) public voteLock;\r\n\r\n    struct Proposal {\r\n        uint id;\r\n        address proposer;\r\n        mapping(address => uint) forVotes;\r\n        mapping(address => uint) againstVotes;\r\n        uint totalForVotes;\r\n        uint totalAgainstVotes;\r\n        uint start; // block start;\r\n        uint end; // start + period\r\n        address executor;\r\n        string hash;\r\n        uint totalVotesAvailable;\r\n        uint quorum;\r\n        uint quorumRequired;\r\n        bool open;\r\n        uint categoryID;\r\n    }\r\n\r\n    mapping (uint => Proposal) public proposals;\r\n    uint public proposalCount=0;\r\n    uint public lock = 17280;\r\n    uint public minimum = 1e18;\r\n    uint public quorum = 2000;\r\n    bool public config = true;\r\n\r\n    address public governance;\r\n\r\n  constructor(uint256 _MinTokenForVote,address _RYIPToken) public{\r\n        //sending all the tokens to Owner\r\n        MinTokenForVote=_MinTokenForVote;\r\n        RYIPToken=_RYIPToken;\r\n    }\r\n\r\n\r\n    function setGovernance(address _governance) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        governance = _governance;\r\n    }\r\n\r\n    function setQuorum(uint _quorum) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        quorum = _quorum;\r\n    }\r\n\r\n    function setMinimum(uint _minimum) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        minimum = _minimum;\r\n    }\r\n\r\n    function setPeriod(uint _proposeId, uint _endtime) public returns(bool){\r\n        require(proposals[_proposeId].executor==msg.sender || owners[msg.sender]==true);\r\n        require(proposals[_proposeId].end!=0);\r\n\r\n         proposals[_proposeId].end=_endtime;\r\n         return true;\r\n    }\r\n\r\n    function setLock(uint _lock) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        lock = _lock;\r\n    }\r\n\r\n    function initialize(uint id) public {\r\n        require(config == true, \"!config\");\r\n        config = false;\r\n        proposalCount = id;\r\n        governance = 0xFEB4acf3df3cDEA7399794D0869ef76A6EfAff52;\r\n    }\r\n\r\n\r\n    event NewProposal(string _hash, uint id, address creator, uint start, uint duration, address executor, uint _categoryID);\r\n    event Vote(uint indexed id, address indexed voter, bool vote, uint weight);\r\n\r\n    function propose(address executor, string memory hash, uint _categoryID, uint _startTime, uint _endTime) public returns(bool){\r\n\r\n\r\n        if(_startTime==0)\r\n        {\r\n           _startTime=block.timestamp;\r\n        }\r\n\r\n         proposalCount=proposalCount+1;\r\n        proposals[proposalCount] = Proposal({\r\n            id: proposalCount,\r\n            proposer: msg.sender,\r\n            totalForVotes: 0,\r\n            totalAgainstVotes: 0,\r\n            start: _startTime,\r\n            end: _endTime,\r\n            executor: executor,\r\n            hash: hash,\r\n            totalVotesAvailable: totalVotes,\r\n            quorum: 0,\r\n            quorumRequired: quorum,\r\n            open: true,\r\n            categoryID: _categoryID\r\n        });\r\n\r\n        emit NewProposal(hash, proposalCount, msg.sender, _startTime, _endTime, executor, _categoryID);\r\n        return true;\r\n    }\r\n\r\n    event RemoveProposal(uint indexed id, address indexed remover, uint indexed time);\r\n\r\n\r\n    function removePropose(uint _proposeId) public returns(bool){\r\n        require(proposals[_proposeId].executor==msg.sender || owners[msg.sender]==true);\r\n        delete proposals[_proposeId];\r\n        emit RemoveProposal(_proposeId,msg.sender,block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    function execute(uint id) public {\r\n        (uint _for, uint _against, uint _quorum) = getStats(id);\r\n        require(proposals[id].quorumRequired < _quorum, \"!quorum\");\r\n        require(proposals[id].end < block.timestamp , \"!end\");\r\n        if (proposals[id].open == true) {\r\n            tallyVotes(id);\r\n        }\r\n        Executor(proposals[id].executor).execute(id, _for, _against, _quorum);\r\n    }\r\n\r\n    function getStats(uint id) public view returns (uint _for, uint _against, uint _quorum) {\r\n        _for = proposals[id].totalForVotes;\r\n        _against = proposals[id].totalAgainstVotes;\r\n        _quorum = proposals[id].quorum;\r\n    }\r\n\r\n    event ProposalFinished(uint indexed id, uint _for, uint _against, bool quorumReached);\r\n\r\n    function tallyVotes(uint id) public {\r\n        require(proposals[id].open == true, \"!open\");\r\n        require(proposals[id].end < block.timestamp, \"!end\");\r\n\r\n        (uint _for, uint _against,) = getStats(id);\r\n        bool _quorum = false;\r\n        if (proposals[id].quorum >= proposals[id].quorumRequired) {\r\n            _quorum = true;\r\n        }\r\n        proposals[id].open = false;\r\n        emit ProposalFinished(id, _for, _against, _quorum);\r\n    }\r\n\r\n    function votesOf(address voter) public view returns (uint) {\r\n        return votes[voter];\r\n    }\r\n    function checkVoted(uint id) public view returns(bool) {\r\n        if(proposals[id].forVotes[msg.sender]==1 || proposals[id].againstVotes[msg.sender]==1)\r\n        {\r\n          return true;\r\n        }\r\n        else\r\n        {\r\n          return false;\r\n        }\r\n    }\r\n    uint public totalVotes;\r\n    mapping(address => uint) public votes;\r\n    event RevokeVoter(address voter, uint votes, uint totalVotes);\r\n\r\n\r\n    function revoke() public {\r\n        require(voters[msg.sender] == true, \"!voter\");\r\n        voters[msg.sender] = false;\r\n        if (totalVotes < votes[msg.sender]) {\r\n            totalVotes = 0;\r\n        } else {\r\n            totalVotes = votes[msg.sender];\r\n        }\r\n        emit RevokeVoter(msg.sender, votes[msg.sender], totalVotes);\r\n        votes[msg.sender] = 0;\r\n    }\r\n\r\n\r\n    function voteFor(uint id) public returns(bool){\r\n        require(proposals[id].start < block.timestamp , \"<start\");\r\n        require(proposals[id].end > block.timestamp , \">end\");\r\n        require(proposals[id].forVotes[msg.sender]==0 && proposals[id].againstVotes[msg.sender]==0,\"Already Voted\");\r\n        //require(msg.value==500000,\"Invalid Amount\");\r\n       // require(_amount==MinTokenForVote,\"Invalid Amount\");\r\n        IERC20(RYIPToken).transferFrom(msg.sender,address(this),MinTokenForVote);\r\n        // freezeToken[msg.sender] += MinTokenForVote;\r\n        \r\n        proposals[id].forVotes[msg.sender] = 1;\r\n        proposals[id].totalVotesAvailable = totalVotes;\r\n        proposals[id].totalForVotes= proposals[id].totalForVotes + 1;\r\n\r\n        stake memory st=stake(now+tokenFreezeDuration,MinTokenForVote);\r\n\r\n        details[msg.sender].push(st);\r\n\r\n        emit Vote(id, msg.sender, true, 1);\r\n        return true;\r\n    }\r\n    function NumberOfVotes(address _add) public view returns(uint256){\r\n        return details[_add].length;\r\n    }\r\n    function voteAgainst(uint id) public returns(bool) {\r\n        require(proposals[id].start < block.timestamp , \"<start\");\r\n        require(proposals[id].end > block.timestamp , \">end\");\r\n        require(proposals[id].forVotes[msg.sender]==0 && proposals[id].againstVotes[msg.sender]==0,\"Already Voted\");\r\n       // require(_amount==MinTokenForVote,\"Invalid Amount\");\r\n        IERC20(RYIPToken).transferFrom(msg.sender,address(this),MinTokenForVote);\r\n        //freezeToken[msg.sender] += MinTokenForVote;\r\n        proposals[id].againstVotes[msg.sender] = 1;\r\n        proposals[id].totalVotesAvailable = totalVotes;\r\n        proposals[id].totalAgainstVotes= proposals[id].totalAgainstVotes + 1;\r\n\r\n\r\n        stake memory st=stake(now+tokenFreezeDuration,MinTokenForVote);\r\n        details[msg.sender].push(st);\r\n\r\n        emit Vote(id, msg.sender, false, 1);\r\n        return true;\r\n    }\r\n    function changeMinTokenForVote(uint256 _amount) public onlyOwner returns(bool){\r\n        require(_amount>0,\"invalid Amount\");\r\n        MinTokenForVote=_amount;\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n    function ClaimToken() public returns(bool) {\r\n        uint256 _tokenAmount= 0;\r\n        uint256 _tmpAmount =0;\r\n        uint256 _tmpDeadline =0;\r\n        \r\n        for (uint256 i=0;i<details[msg.sender].length;){\r\n            \r\n            if (now>details[msg.sender][i].time && details[msg.sender][i].amount>0){ // if deadline time is over.\r\n            \r\n                    //vreturn= vreturn.add(details[msg.sender][i].amount);\r\n                    _tokenAmount= _tokenAmount+details[msg.sender][i].amount;\r\n                    if (details[msg.sender].length>1) // if element is less than 2 no need to swap \r\n                        \r\n                        {\r\n\r\n                            // storing last index element in temp variable for swaping\r\n                            _tmpAmount = details[msg.sender][details[msg.sender].length-1].amount;\r\n                            _tmpDeadline = details[msg.sender][details[msg.sender].length-1].time;\r\n                    \r\n                            // storing current element on last index \r\n                            details[msg.sender][details[msg.sender].length-1].amount = details[msg.sender][i].amount;\r\n                            details[msg.sender][details[msg.sender].length-1].time = details[msg.sender][i].time;  \r\n                    \r\n                            //storing last index element on current index\r\n                    \r\n                            details[msg.sender][i].amount= _tmpAmount;\r\n                            details[msg.sender][i].time = _tmpDeadline;\r\n                        }\r\n                     // removing item on array\r\n                     details[msg.sender].pop();\r\n                        \r\n            }\r\n            \r\n            else{\r\n                \r\n                // it increment value only when array lenght is not decreasing\r\n                i++;\r\n            }\r\n        }\r\n        require(_tokenAmount>0,'invalid balance');\r\n        require(IERC20(RYIPToken).transfer(msg.sender,_tokenAmount),'transfer sending fail');\r\n        return true;\r\n\r\n    }\r\n    \r\n\r\n    function showFreezeToken(address _address) public view returns(uint256){\r\n         require(_address!=address(0),'invalid address');\r\n        uint256 vreturn=0;\r\n        //for (uint256 i=deadlineStarIndex[msg.sender];i<=deadlineLastIndex[msg.sender] ;i++){\r\n        for (uint256 i=0;i<details[_address].length ;i++){\r\n\r\n            if (now<details[_address][i].time && details[_address][i].amount>0){ // if deadline time is over.\r\n                    //vreturn= vreturn.add(details[msg.sender][i].amount);\r\n                    vreturn= vreturn+details[_address][i].amount;\r\n            }\r\n        }\r\n        return vreturn;\r\n\r\n    }\r\n\r\n\r\n    function showUnFreezeToken(address _address) public view  returns(uint256){\r\n       require(_address!=address(0),'invalid address');\r\n      uint256 vreturn=0;\r\n\r\n        //for (uint256 i=deadlineStarIndex[msg.sender];i<=deadlineLastIndex[msg.sender] ;i++){\r\n        for (uint256 i=0;i<details[_address].length ;i++){\r\n\r\n            if (now>details[_address][i].time && details[_address][i].amount>0){ // if deadline time is over.\r\n                    //vreturn= vreturn.add(details[msg.sender][i].amount);\r\n                    vreturn= vreturn+details[_address][i].amount;\r\n                    \r\n            }\r\n        }\r\n        return vreturn;\r\n    }\r\n    \r\n    \r\n\r\n\r\n    function changeTokenDuration (uint256 _timePeriod) public onlyOwner returns(bool){\r\n        tokenFreezeDuration= _timePeriod;\r\n        return true;\r\n    }\r\n\r\n    function changeToken(address _RYIPToken) public onlyOwner returns(bool){\r\n        RYIPToken=_RYIPToken;\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"proposer\",\"type\":\"address\"},{\"name\":\"totalForVotes\",\"type\":\"uint256\"},{\"name\":\"totalAgainstVotes\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"executor\",\"type\":\"address\"},{\"name\":\"hash\",\"type\":\"string\"},{\"name\":\"totalVotesAvailable\",\"type\":\"uint256\"},{\"name\":\"quorum\",\"type\":\"uint256\"},{\"name\":\"quorumRequired\",\"type\":\"uint256\"},{\"name\":\"open\",\"type\":\"bool\"},{\"name\":\"categoryID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposeId\",\"type\":\"uint256\"},{\"name\":\"_endtime\",\"type\":\"uint256\"}],\"name\":\"setPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposeId\",\"type\":\"uint256\"}],\"name\":\"removePropose\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"breaker\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimum\",\"type\":\"uint256\"}],\"name\":\"setMinimum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"executor\",\"type\":\"address\"},{\"name\":\"hash\",\"type\":\"string\"},{\"name\":\"_categoryID\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"propose\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFreezeDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"checkVoted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tallyVotes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_breaker\",\"type\":\"bool\"}],\"name\":\"setBreaker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_RYIPToken\",\"type\":\"address\"}],\"name\":\"changeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"voteAgainst\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MinTokenForVote\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"votesOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getStats\",\"outputs\":[{\"name\":\"_for\",\"type\":\"uint256\"},{\"name\":\"_against\",\"type\":\"uint256\"},{\"name\":\"_quorum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"showFreezeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"NumberOfVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"voteFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"showUnFreezeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RYIPToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"voters\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ClaimToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"changeMinTokenForVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quorum\",\"type\":\"uint256\"}],\"name\":\"setQuorum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"details\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lock\",\"type\":\"uint256\"}],\"name\":\"setLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timePeriod\",\"type\":\"uint256\"}],\"name\":\"changeTokenDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_MinTokenForVote\",\"type\":\"uint256\"},{\"name\":\"_RYIPToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_hash\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_categoryID\",\"type\":\"uint256\"}],\"name\":\"NewProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"vote\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"remover\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"RemoveProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_for\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_against\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quorumReached\",\"type\":\"bool\"}],\"name\":\"ProposalFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalVotes\",\"type\":\"uint256\"}],\"name\":\"RevokeVoter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"UnitiDex_Governance","CompilerVersion":"v0.5.9+commit.c68bc34e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000015af1d78b58c40000000000000000000000000000d78e5b24aae1bd03a488af642770e2abb986f9d5","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://023bceb09e1eb98effb57a095aafc80026fdb58936deb7c6c9f7ab5c82af84b4"}]}