{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DCATokenDescriptor/DCATokenDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.6;\\npragma abicoder v2;\\n\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\nimport '../interfaces/IDCAGlobalParameters.sol';\\nimport '../interfaces/IDCAPair.sol';\\nimport '../libraries/NFTDescriptor.sol';\\n\\n/// @title Describes NFT token positions\\n/// @notice Produces a string containing the data URI for a JSON metadata string\\ncontract DCATokenDescriptor is IDCATokenDescriptor {\\n  function tokenURI(IDCAPairPositionHandler _positionHandler, uint256 _tokenId) external view override returns (string memory) {\\n    IERC20Metadata _tokenA = _positionHandler.tokenA();\\n    IERC20Metadata _tokenB = _positionHandler.tokenB();\\n    IDCAGlobalParameters _globalParameters = _positionHandler.globalParameters();\\n    IDCAPairPositionHandler.UserPosition memory _userPosition = _positionHandler.userPosition(_tokenId);\\n\\n    return\\n      NFTDescriptor.constructTokenURI(\\n        NFTDescriptor.ConstructTokenURIParams({\\n          tokenId: _tokenId,\\n          pair: address(_positionHandler),\\n          tokenA: address(_tokenA),\\n          tokenB: address(_tokenB),\\n          tokenADecimals: _tokenA.decimals(),\\n          tokenBDecimals: _tokenB.decimals(),\\n          tokenASymbol: _tokenA.symbol(),\\n          tokenBSymbol: _tokenB.symbol(),\\n          swapInterval: _globalParameters.intervalDescription(_userPosition.swapInterval),\\n          swapsExecuted: _userPosition.swapsExecuted,\\n          swapped: _userPosition.swapped,\\n          swapsLeft: _userPosition.swapsLeft,\\n          remaining: _userPosition.remaining,\\n          rate: _userPosition.rate,\\n          fromA: _userPosition.from == _tokenA\\n        })\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDCAGlobalParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.6;\\n\\nimport './ITimeWeightedOracle.sol';\\nimport './IDCATokenDescriptor.sol';\\n\\n/// @title The interface for handling parameters the affect the whole DCA ecosystem\\n/// @notice This contract will manage configuration that affects all pairs, swappers, etc\\ninterface IDCAGlobalParameters {\\n  /// @notice A compilation of all parameters that affect a swap\\n  struct SwapParameters {\\n    // The address of the fee recipient\\n    address feeRecipient;\\n    // Whether swaps are paused or not\\n    bool isPaused;\\n    // The swap fee\\n    uint32 swapFee;\\n    // The oracle contract\\n    ITimeWeightedOracle oracle;\\n  }\\n\\n  /// @notice A compilation of all parameters that affect a loan\\n  struct LoanParameters {\\n    // The address of the fee recipient\\n    address feeRecipient;\\n    // Whether loans are paused or not\\n    bool isPaused;\\n    // The loan fee\\n    uint32 loanFee;\\n  }\\n\\n  /// @notice Emitted when a new fee recipient is set\\n  /// @param _feeRecipient The address of the new fee recipient\\n  event FeeRecipientSet(address _feeRecipient);\\n\\n  /// @notice Emitted when a new NFT descriptor is set\\n  /// @param _descriptor The new NFT descriptor contract\\n  event NFTDescriptorSet(IDCATokenDescriptor _descriptor);\\n\\n  /// @notice Emitted when a new oracle is set\\n  /// @param _oracle The new oracle contract\\n  event OracleSet(ITimeWeightedOracle _oracle);\\n\\n  /// @notice Emitted when a new swap fee is set\\n  /// @param _feeSet The new swap fee\\n  event SwapFeeSet(uint32 _feeSet);\\n\\n  /// @notice Emitted when a new loan fee is set\\n  /// @param _feeSet The new loan fee\\n  event LoanFeeSet(uint32 _feeSet);\\n\\n  /// @notice Emitted when new swap intervals are allowed\\n  /// @param _swapIntervals The new swap intervals\\n  /// @param _descriptions The descriptions for each swap interval\\n  event SwapIntervalsAllowed(uint32[] _swapIntervals, string[] _descriptions);\\n\\n  /// @notice Emitted when some swap intervals are no longer allowed\\n  /// @param _swapIntervals The swap intervals that are no longer allowed\\n  event SwapIntervalsForbidden(uint32[] _swapIntervals);\\n\\n  /// @notice Thrown when trying to set a fee higher than the maximum allowed\\n  error HighFee();\\n\\n  /// @notice Thrown when trying to support new swap intervals, but the amount of descriptions doesn't match\\n  error InvalidParams();\\n\\n  /// @notice Thrown when trying to support a new swap interval of value zero\\n  error ZeroInterval();\\n\\n  /// @notice Thrown when trying a description for a new swap interval is empty\\n  error EmptyDescription();\\n\\n  /// @notice Returns the address of the fee recipient\\n  /// @return _feeRecipient The address of the fee recipient\\n  function feeRecipient() external view returns (address _feeRecipient);\\n\\n  /// @notice Returns fee charged on swaps\\n  /// @return _swapFee The fee itself\\n  function swapFee() external view returns (uint32 _swapFee);\\n\\n  /// @notice Returns fee charged on loans\\n  /// @return _loanFee The fee itself\\n  function loanFee() external view returns (uint32 _loanFee);\\n\\n  /// @notice Returns the NFT descriptor contract\\n  /// @return _nftDescriptor The contract itself\\n  function nftDescriptor() external view returns (IDCATokenDescriptor _nftDescriptor);\\n\\n  /// @notice Returns the time-weighted oracle contract\\n  /// @return _oracle The contract itself\\n  function oracle() external view returns (ITimeWeightedOracle _oracle);\\n\\n  /// @notice Returns the precision used for fees\\n  /// @dev Cannot be modified\\n  /// @return _precision The precision used for fees\\n  // solhint-disable-next-line func-name-mixedcase\\n  function FEE_PRECISION() external view returns (uint24 _precision);\\n\\n  /// @notice Returns the max fee that can be set for either swap or loans\\n  /// @dev Cannot be modified\\n  /// @return _maxFee The maximum possible fee\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MAX_FEE() external view returns (uint32 _maxFee);\\n\\n  /// @notice Returns a list of all the allowed swap intervals\\n  /// @return _allowedSwapIntervals An array with all allowed swap intervals\\n  function allowedSwapIntervals() external view returns (uint32[] memory _allowedSwapIntervals);\\n\\n  /// @notice Returns the description for a given swap interval\\n  /// @return _description The swap interval's description\\n  function intervalDescription(uint32 _swapInterval) external view returns (string memory _description);\\n\\n  /// @notice Returns whether a swap interval is currently allowed\\n  /// @return _isAllowed Whether the given swap interval is currently allowed\\n  function isSwapIntervalAllowed(uint32 _swapInterval) external view returns (bool _isAllowed);\\n\\n  /// @notice Returns whether swaps and loans are currently paused\\n  /// @return _isPaused Whether swaps and loans are currently paused\\n  function paused() external view returns (bool _isPaused);\\n\\n  /// @notice Returns a compilation of all parameters that affect a swap\\n  /// @return _swapParameters All parameters that affect a swap\\n  function swapParameters() external view returns (SwapParameters memory _swapParameters);\\n\\n  /// @notice Returns a compilation of all parameters that affect a loan\\n  /// @return _loanParameters All parameters that affect a loan\\n  function loanParameters() external view returns (LoanParameters memory _loanParameters);\\n\\n  /// @notice Sets a new fee recipient address\\n  /// @dev Will revert with ZeroAddress if the zero address is passed\\n  /// @param _feeRecipient The new fee recipient address\\n  function setFeeRecipient(address _feeRecipient) external;\\n\\n  /// @notice Sets a new swap fee\\n  /// @dev Will rever with HighFee if the fee is higher than the maximum\\n  /// @param _fee The new swap fee\\n  function setSwapFee(uint32 _fee) external;\\n\\n  /// @notice Sets a new loan fee\\n  /// @dev Will rever with HighFee if the fee is higher than the maximum\\n  /// @param _fee The new loan fee\\n  function setLoanFee(uint32 _fee) external;\\n\\n  /// @notice Sets a new NFT descriptor\\n  /// @dev Will revert with ZeroAddress if the zero address is passed\\n  /// @param _descriptor The new descriptor contract\\n  function setNFTDescriptor(IDCATokenDescriptor _descriptor) external;\\n\\n  /// @notice Sets a new time-weighted oracle\\n  /// @dev Will revert with ZeroAddress if the zero address is passed\\n  /// @param _oracle The new oracle contract\\n  function setOracle(ITimeWeightedOracle _oracle) external;\\n\\n  /// @notice Adds new swap intervals to the allowed list\\n  /// @dev Will revert with:\\n  /// InvalidParams if the amount of swap intervals is different from the amount of descriptions passed\\n  /// ZeroInterval if any of the swap intervals is zero\\n  /// EmptyDescription if any of the descriptions is empty\\n  /// @param _swapIntervals The new swap intervals\\n  /// @param _descriptions Their descriptions\\n  function addSwapIntervalsToAllowedList(uint32[] calldata _swapIntervals, string[] calldata _descriptions) external;\\n\\n  /// @notice Removes some swap intervals from the allowed list\\n  /// @param _swapIntervals The swap intervals to remove\\n  function removeSwapIntervalsFromAllowedList(uint32[] calldata _swapIntervals) external;\\n\\n  /// @notice Pauses all swaps and loans\\n  function pause() external;\\n\\n  /// @notice Unpauses all swaps and loans\\n  function unpause() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDCAPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.6;\\n\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\nimport './IDCAGlobalParameters.sol';\\n\\n/// @title The interface for all state related queries\\n/// @notice These methods allow users to read the pair's current values\\ninterface IDCAPairParameters {\\n  /// @notice Returns the global parameters contract\\n  /// @dev Global parameters has information about swaps and pairs, like swap intervals, fees charged, etc.\\n  /// @return The Global Parameters contract\\n  function globalParameters() external view returns (IDCAGlobalParameters);\\n\\n  /// @notice Returns the token A contract\\n  /// @return The contract for token A\\n  function tokenA() external view returns (IERC20Metadata);\\n\\n  /// @notice Returns the token B contract\\n  /// @return The contract for token B\\n  function tokenB() external view returns (IERC20Metadata);\\n\\n  /// @notice Returns how much will the amount to swap differ from the previous swap\\n  /// @dev f.e. if the returned value is -100, then the amount to swap will be 100 less than the swap just before it\\n  /// @param _swapInterval The swap interval to check\\n  /// @param _from The 'from' token of the deposits\\n  /// @param _swap The swap number to check\\n  /// @return _delta How much will the amount to swap differ, when compared to the swap just before this one\\n  function swapAmountDelta(\\n    uint32 _swapInterval,\\n    address _from,\\n    uint32 _swap\\n  ) external view returns (int256 _delta);\\n\\n  /// @notice Returns if a certain swap interval is active or not\\n  /// @dev We consider a swap interval to be active if there is at least one active position on that interval\\n  /// @param _swapInterval The swap interval to check\\n  /// @return _isActive Whether the given swap interval is currently active\\n  function isSwapIntervalActive(uint32 _swapInterval) external view returns (bool _isActive);\\n\\n  /// @notice Returns the amount of swaps executed for a certain interval\\n  /// @param _swapInterval The swap interval to check\\n  /// @return _swaps The amount of swaps performed on the given interval\\n  function performedSwaps(uint32 _swapInterval) external view returns (uint32 _swaps);\\n}\\n\\n/// @title The interface for all position related matters in a DCA pair\\n/// @notice These methods allow users to create, modify and terminate their positions\\ninterface IDCAPairPositionHandler is IDCAPairParameters {\\n  /// @notice The position of a certain user\\n  struct UserPosition {\\n    // The token that the user deposited and will be swapped in exchange for \\\"to\\\"\\n    IERC20Metadata from;\\n    // The token that the user will get in exchange for their \\\"from\\\" tokens in each swap\\n    IERC20Metadata to;\\n    // How frequently the position's swaps should be executed\\n    uint32 swapInterval;\\n    // How many swaps were executed since deposit, last modification, or last withdraw\\n    uint32 swapsExecuted;\\n    // How many \\\"to\\\" tokens can currently be withdrawn\\n    uint256 swapped;\\n    // How many swaps left the position has to execute\\n    uint32 swapsLeft;\\n    // How many \\\"from\\\" tokens there are left to swap\\n    uint256 remaining;\\n    // How many \\\"from\\\" tokens need to be traded in each swap\\n    uint160 rate;\\n  }\\n\\n  /// @notice Emitted when a position is terminated\\n  /// @param _user The address of the user that terminated the position\\n  /// @param _dcaId The id of the position that was terminated\\n  /// @param _returnedUnswapped How many \\\"from\\\" tokens were returned to the caller\\n  /// @param _returnedSwapped How many \\\"to\\\" tokens were returned to the caller\\n  event Terminated(address indexed _user, uint256 _dcaId, uint256 _returnedUnswapped, uint256 _returnedSwapped);\\n\\n  /// @notice Emitted when a position is created\\n  /// @param _user The address of the user that created the position\\n  /// @param _dcaId The id of the position that was created\\n  /// @param _fromToken The address of the \\\"from\\\" token\\n  /// @param _rate How many \\\"from\\\" tokens need to be traded in each swap\\n  /// @param _startingSwap The number of the swap when the position will be executed for the first time\\n  /// @param _swapInterval How frequently the position's swaps should be executed\\n  /// @param _lastSwap The number of the swap when the position will be executed for the last time\\n  event Deposited(\\n    address indexed _user,\\n    uint256 _dcaId,\\n    address _fromToken,\\n    uint160 _rate,\\n    uint32 _startingSwap,\\n    uint32 _swapInterval,\\n    uint32 _lastSwap\\n  );\\n\\n  /// @notice Emitted when a user withdraws all swapped tokens from a position\\n  /// @param _user The address of the user that executed the withdraw\\n  /// @param _dcaId The id of the position that was affected\\n  /// @param _token The address of the withdrawn tokens. It's the same as the position's \\\"to\\\" token\\n  /// @param _amount The amount that was withdrawn\\n  event Withdrew(address indexed _user, uint256 _dcaId, address _token, uint256 _amount);\\n\\n  /// @notice Emitted when a user withdraws all swapped tokens from many positions\\n  /// @param _user The address of the user that executed the withdraw\\n  /// @param _dcaIds The ids of the positions that were affected\\n  /// @param _swappedTokenA The total amount that was withdrawn in token A\\n  /// @param _swappedTokenB The total amount that was withdrawn in token B\\n  event WithdrewMany(address indexed _user, uint256[] _dcaIds, uint256 _swappedTokenA, uint256 _swappedTokenB);\\n\\n  /// @notice Emitted when a position is modified\\n  /// @param _user The address of the user that modified the position\\n  /// @param _dcaId The id of the position that was modified\\n  /// @param _rate How many \\\"from\\\" tokens need to be traded in each swap\\n  /// @param _startingSwap The number of the swap when the position will be executed for the first time\\n  /// @param _lastSwap The number of the swap when the position will be executed for the last time\\n  event Modified(address indexed _user, uint256 _dcaId, uint160 _rate, uint32 _startingSwap, uint32 _lastSwap);\\n\\n  /// @notice Thrown when a user tries to create a position with a token that is neither token A nor token B\\n  error InvalidToken();\\n\\n  /// @notice Thrown when a user tries to create that a position with an unsupported swap interval\\n  error InvalidInterval();\\n\\n  /// @notice Thrown when a user tries operate on a position that doesn't exist (it might have been already terminated)\\n  error InvalidPosition();\\n\\n  /// @notice Thrown when a user tries operate on a position that they don't have access to\\n  error UnauthorizedCaller();\\n\\n  /// @notice Thrown when a user tries to create or modify a position by setting the rate to be zero\\n  error ZeroRate();\\n\\n  /// @notice Thrown when a user tries to create a position with zero swaps\\n  error ZeroSwaps();\\n\\n  /// @notice Thrown when a user tries to add zero funds to their position\\n  error ZeroAmount();\\n\\n  /// @notice Thrown when a user tries to modify the rate of a position that has already been completed\\n  error PositionCompleted();\\n\\n  /// @notice Thrown when a user tries to modify a position that has too much swapped balance. This error\\n  /// is thrown so that the user doesn't lose any funds. The error indicates that the user must perform a withdraw\\n  /// before modifying their position\\n  error MandatoryWithdraw();\\n\\n  /// @notice Returns a DCA position\\n  /// @param _dcaId The id of the position\\n  /// @return _position The position itself\\n  function userPosition(uint256 _dcaId) external view returns (UserPosition memory _position);\\n\\n  /// @notice Creates a new position\\n  /// @dev Will revert:\\n  /// With InvalidToken if _tokenAddress is neither token A nor token B\\n  /// With ZeroRate if _rate is zero\\n  /// With ZeroSwaps if _amountOfSwaps is zero\\n  /// With InvalidInterval if _swapInterval is not a valid swap interval\\n  /// @param _tokenAddress The address of the token that will be deposited\\n  /// @param _rate How many \\\"from\\\" tokens need to be traded in each swap\\n  /// @param _amountOfSwaps How many swaps to execute for this position\\n  /// @param _swapInterval How frequently the position's swaps should be executed\\n  /// @return _dcaId The id of the created position\\n  function deposit(\\n    address _tokenAddress,\\n    uint160 _rate,\\n    uint32 _amountOfSwaps,\\n    uint32 _swapInterval\\n  ) external returns (uint256 _dcaId);\\n\\n  /// @notice Withdraws all swapped tokens from a position\\n  /// @dev Will revert:\\n  /// With InvalidPosition if _dcaId is invalid\\n  /// With UnauthorizedCaller if the caller doesn't have access to the position\\n  /// @param _dcaId The position's id\\n  /// @return _swapped How much was withdrawn\\n  function withdrawSwapped(uint256 _dcaId) external returns (uint256 _swapped);\\n\\n  /// @notice Withdraws all swapped tokens from many positions\\n  /// @dev Will revert:\\n  /// With InvalidPosition if any of the ids in _dcaIds is invalid\\n  /// With UnauthorizedCaller if the caller doesn't have access to any of the positions in _dcaIds\\n  /// @param _dcaIds The positions' ids\\n  /// @return _swappedTokenA How much was withdrawn in token A\\n  /// @return _swappedTokenB How much was withdrawn in token B\\n  function withdrawSwappedMany(uint256[] calldata _dcaIds) external returns (uint256 _swappedTokenA, uint256 _swappedTokenB);\\n\\n  /// @notice Modifies the rate of a position. Could request more funds or return deposited funds\\n  /// depending on whether the new rate is greater than the previous one.\\n  /// @dev Will revert:\\n  /// With InvalidPosition if _dcaId is invalid\\n  /// With UnauthorizedCaller if the caller doesn't have access to the position\\n  /// With PositionCompleted if position has already been completed\\n  /// With ZeroRate if _newRate is zero\\n  /// With MandatoryWithdraw if the user must execute a withdraw before modifying their position\\n  /// @param _dcaId The position's id\\n  /// @param _newRate The new rate to set\\n  function modifyRate(uint256 _dcaId, uint160 _newRate) external;\\n\\n  /// @notice Modifies the amount of swaps of a position. Could request more funds or return\\n  /// deposited funds depending on whether the new amount of swaps is greater than the swaps left.\\n  /// @dev Will revert:\\n  /// With InvalidPosition if _dcaId is invalid\\n  /// With UnauthorizedCaller if the caller doesn't have access to the position\\n  /// With MandatoryWithdraw if the user must execute a withdraw before modifying their position\\n  /// @param _dcaId The position's id\\n  /// @param _newSwaps The new amount of swaps\\n  function modifySwaps(uint256 _dcaId, uint32 _newSwaps) external;\\n\\n  /// @notice Modifies both the rate and amount of swaps of a position. Could request more funds or return\\n  /// deposited funds depending on whether the new parameters require more or less than the the unswapped funds.\\n  /// @dev Will revert:\\n  /// With InvalidPosition if _dcaId is invalid\\n  /// With UnauthorizedCaller if the caller doesn't have access to the position\\n  /// With ZeroRate if _newRate is zero\\n  /// With MandatoryWithdraw if the user must execute a withdraw before modifying their position\\n  /// @param _dcaId The position's id\\n  /// @param _newRate The new rate to set\\n  /// @param _newSwaps The new amount of swaps\\n  function modifyRateAndSwaps(\\n    uint256 _dcaId,\\n    uint160 _newRate,\\n    uint32 _newSwaps\\n  ) external;\\n\\n  /// @notice Takes the unswapped balance, adds the new deposited funds and modifies the position so that\\n  /// it is executed in _newSwaps swaps\\n  /// @dev Will revert:\\n  /// With InvalidPosition if _dcaId is invalid\\n  /// With UnauthorizedCaller if the caller doesn't have access to the position\\n  /// With ZeroAmount if _amount is zero\\n  /// With ZeroSwaps if _newSwaps is zero\\n  /// With MandatoryWithdraw if the user must execute a withdraw before modifying their position\\n  /// @param _dcaId The position's id\\n  /// @param _amount Amounts of funds to add to the position\\n  /// @param _newSwaps The new amount of swaps\\n  function addFundsToPosition(\\n    uint256 _dcaId,\\n    uint256 _amount,\\n    uint32 _newSwaps\\n  ) external;\\n\\n  /// @notice Terminates the position and sends all unswapped and swapped balance to the caller\\n  /// @dev Will revert:\\n  /// With InvalidPosition if _dcaId is invalid\\n  /// With UnauthorizedCaller if the caller doesn't have access to the position\\n  /// @param _dcaId The position's id\\n  function terminate(uint256 _dcaId) external;\\n}\\n\\n/// @title The interface for all swap related matters in a DCA pair\\n/// @notice These methods allow users to get information about the next swap, and how to execute it\\ninterface IDCAPairSwapHandler {\\n  /// @notice Information about an available swap for a specific swap interval\\n  struct SwapInformation {\\n    // The affected swap interval\\n    uint32 interval;\\n    // The number of the swap that will be performed\\n    uint32 swapToPerform;\\n    // The amount of token A that needs swapping\\n    uint256 amountToSwapTokenA;\\n    // The amount of token B that needs swapping\\n    uint256 amountToSwapTokenB;\\n  }\\n\\n  /// @notice All information about the next swap\\n  struct NextSwapInformation {\\n    // All swaps that can be executed\\n    SwapInformation[] swapsToPerform;\\n    // How many entries of the swapsToPerform array are valid\\n    uint8 amountOfSwaps;\\n    // How much can be borrowed in token A during a flash swap\\n    uint256 availableToBorrowTokenA;\\n    // How much can be borrowed in token B during a flash swap\\n    uint256 availableToBorrowTokenB;\\n    // How much 10**decimals(tokenB) is when converted to token A\\n    uint256 ratePerUnitBToA;\\n    // How much 10**decimals(tokenA) is when converted to token B\\n    uint256 ratePerUnitAToB;\\n    // How much token A will be sent to the platform in terms of fee\\n    uint256 platformFeeTokenA;\\n    // How much token B will be sent to the platform in terms of fee\\n    uint256 platformFeeTokenB;\\n    // The amount of tokens that need to be provided by the swapper\\n    uint256 amountToBeProvidedBySwapper;\\n    // The amount of tokens that will be sent to the swapper optimistically\\n    uint256 amountToRewardSwapperWith;\\n    // The token that needs to be provided by the swapper\\n    IERC20Metadata tokenToBeProvidedBySwapper;\\n    // The token that will be sent to the swapper optimistically\\n    IERC20Metadata tokenToRewardSwapperWith;\\n  }\\n\\n  /// @notice Emitted when a swap is executed\\n  /// @param _sender The address of the user that initiated the swap\\n  /// @param _to The address that received the reward + loan\\n  /// @param _amountBorrowedTokenA How much was borrowed in token A\\n  /// @param _amountBorrowedTokenB How much was borrowed in token B\\n  /// @param _fee How much was charged as a swap fee to position owners\\n  /// @param _nextSwapInformation All information related to the swap\\n  event Swapped(\\n    address indexed _sender,\\n    address indexed _to,\\n    uint256 _amountBorrowedTokenA,\\n    uint256 _amountBorrowedTokenB,\\n    uint32 _fee,\\n    NextSwapInformation _nextSwapInformation\\n  );\\n\\n  /// @notice Thrown when trying to execute a swap, but none is available\\n  error NoSwapsToExecute();\\n\\n  /// @notice Returns when the next swap will be available for a given swap interval\\n  /// @param _swapInterval The swap interval to check\\n  /// @return _when The moment when the next swap will be available. Take into account that if the swap is already available, this result could\\n  /// be in the past\\n  function nextSwapAvailable(uint32 _swapInterval) external view returns (uint32 _when);\\n\\n  /// @notice Returns the amount of tokens that needed swapping in the last swap, for all positions in the given swap interval that were deposited in the given token\\n  /// @param _swapInterval The swap interval to check\\n  /// @param _from The address of the token that all positions used to deposit\\n  /// @return _amount The amount that needed swapping in the last swap\\n  function swapAmountAccumulator(uint32 _swapInterval, address _from) external view returns (uint256);\\n\\n  /// @notice Returns all information related to the next swap\\n  /// @return _nextSwapInformation The information about the next swap\\n  function getNextSwapInfo() external view returns (NextSwapInformation memory _nextSwapInformation);\\n\\n  /// @notice Executes a swap\\n  /// @dev This method assumes that the required amount has already been sent. Will revert with:\\n  /// Paused if swaps are paused by protocol\\n  /// NoSwapsToExecute if there are no swaps to execute\\n  /// LiquidityNotReturned if the required tokens were not sent before calling the function\\n  function swap() external;\\n\\n  /// @notice Executes a flash swap\\n  /// @dev Will revert with:\\n  /// Paused if swaps are paused by protocol\\n  /// NoSwapsToExecute if there are no swaps to execute\\n  /// InsufficientLiquidity if asked to borrow more than the actual reserves\\n  /// LiquidityNotReturned if the required tokens were not back during the callback\\n  /// @param _amountToBorrowTokenA How much to borrow in token A\\n  /// @param _amountToBorrowTokenB How much to borrow in token B\\n  /// @param _to Address to send the reward + the borrowed tokens\\n  /// @param _data Bytes to send to the caller during the callback. If this parameter is empty, the callback won't be executed\\n  function swap(\\n    uint256 _amountToBorrowTokenA,\\n    uint256 _amountToBorrowTokenB,\\n    address _to,\\n    bytes calldata _data\\n  ) external;\\n\\n  /// @notice Returns how many seconds left until the next swap is available\\n  /// @return _secondsUntilNextSwap The amount of seconds until next swap. Returns 0 if a swap can already be executed\\n  function secondsUntilNextSwap() external view returns (uint32 _secondsUntilNextSwap);\\n}\\n\\n/// @title The interface for all loan related matters in a DCA pair\\n/// @notice These methods allow users to ask how much is available for loans, and also to execute them\\ninterface IDCAPairLoanHandler {\\n  /// @notice Emitted when a flash loan is executed\\n  /// @param _sender The address of the user that initiated the loan\\n  /// @param _to The address that received the loan\\n  /// @param _amountBorrowedTokenA How much was borrowed in token A\\n  /// @param _amountBorrowedTokenB How much was borrowed in token B\\n  /// @param _loanFee How much was charged as a fee\\n  event Loaned(address indexed _sender, address indexed _to, uint256 _amountBorrowedTokenA, uint256 _amountBorrowedTokenB, uint32 _loanFee);\\n\\n  // @notice Thrown when trying to execute a flash loan but without actually asking for tokens\\n  error ZeroLoan();\\n\\n  /// @notice Returns the amount of tokens that can be asked for during a flash loan\\n  /// @return _amountToBorrowTokenA The amount of token A that is available for borrowing\\n  /// @return _amountToBorrowTokenB The amount of token B that is available for borrowing\\n  function availableToBorrow() external view returns (uint256 _amountToBorrowTokenA, uint256 _amountToBorrowTokenB);\\n\\n  /// @notice Executes a flash loan, sending the required amounts to the specified loan recipient\\n  /// @dev Will revert:\\n  /// With ZeroLoan if both _amountToBorrowTokenA & _amountToBorrowTokenB are 0\\n  /// With Paused if loans are paused by protocol\\n  /// With InsufficientLiquidity if asked for more that reserves\\n  /// @param _amountToBorrowTokenA The amount to borrow in token A\\n  /// @param _amountToBorrowTokenB The amount to borrow in token B\\n  /// @param _to Address that will receive the loan. This address should be a contract that implements IDCAPairLoanCallee\\n  /// @param _data Any data that should be passed through to the callback\\n  function loan(\\n    uint256 _amountToBorrowTokenA,\\n    uint256 _amountToBorrowTokenB,\\n    address _to,\\n    bytes calldata _data\\n  ) external;\\n}\\n\\ninterface IDCAPair is IDCAPairParameters, IDCAPairSwapHandler, IDCAPairPositionHandler, IDCAPairLoanHandler {}\\n\"\r\n    },\r\n    \"contracts/libraries/NFTDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport 'base64-sol/base64.sol';\\nimport './NFTSVG.sol';\\n\\n// Based on Uniswap's NFTDescriptor\\nlibrary NFTDescriptor {\\n  using Strings for uint256;\\n  using Strings for uint32;\\n\\n  struct ConstructTokenURIParams {\\n    address pair;\\n    address tokenA;\\n    address tokenB;\\n    uint8 tokenADecimals;\\n    uint8 tokenBDecimals;\\n    string tokenASymbol;\\n    string tokenBSymbol;\\n    string swapInterval;\\n    uint32 swapsExecuted;\\n    uint32 swapsLeft;\\n    uint256 tokenId;\\n    uint256 swapped;\\n    uint256 remaining;\\n    uint160 rate;\\n    bool fromA;\\n  }\\n\\n  function constructTokenURI(ConstructTokenURIParams memory _params) internal pure returns (string memory) {\\n    string memory _name = _generateName(_params);\\n\\n    string memory _description = _generateDescription(\\n      _params.tokenASymbol,\\n      _params.tokenBSymbol,\\n      addressToString(_params.pair),\\n      addressToString(_params.tokenA),\\n      addressToString(_params.tokenB),\\n      _params.swapInterval,\\n      _params.tokenId\\n    );\\n\\n    string memory _image = Base64.encode(bytes(_generateSVGImage(_params)));\\n\\n    return\\n      string(\\n        abi.encodePacked(\\n          'data:application/json;base64,',\\n          Base64.encode(\\n            bytes(\\n              abi.encodePacked(\\n                '{\\\"name\\\":\\\"',\\n                _name,\\n                '\\\", \\\"description\\\":\\\"',\\n                _description,\\n                '\\\", \\\"image\\\": \\\"',\\n                'data:image/svg+xml;base64,',\\n                _image,\\n                '\\\"}'\\n              )\\n            )\\n          )\\n        )\\n      );\\n  }\\n\\n  function _escapeQuotes(string memory _symbol) private pure returns (string memory) {\\n    bytes memory symbolBytes = bytes(_symbol);\\n    uint8 quotesCount = 0;\\n    for (uint8 i = 0; i < symbolBytes.length; i++) {\\n      if (symbolBytes[i] == '\\\"') {\\n        quotesCount++;\\n      }\\n    }\\n    if (quotesCount > 0) {\\n      bytes memory escapedBytes = new bytes(symbolBytes.length + (quotesCount));\\n      uint256 index;\\n      for (uint8 i = 0; i < symbolBytes.length; i++) {\\n        if (symbolBytes[i] == '\\\"') {\\n          escapedBytes[index++] = '\\\\\\\\';\\n        }\\n        escapedBytes[index++] = symbolBytes[i];\\n      }\\n      return string(escapedBytes);\\n    }\\n    return _symbol;\\n  }\\n\\n  function _generateDescription(\\n    string memory _tokenASymbol,\\n    string memory _tokenBSymbol,\\n    string memory _pairAddress,\\n    string memory _tokenAAddress,\\n    string memory _tokenBAddress,\\n    string memory _interval,\\n    uint256 _tokenId\\n  ) private pure returns (string memory) {\\n    string memory _part1 = string(\\n      abi.encodePacked(\\n        'This NFT represents a position in a Mean Finance DCA ',\\n        _escapeQuotes(_tokenASymbol),\\n        '-',\\n        _escapeQuotes(_tokenBSymbol),\\n        ' pair. ',\\n        'The owner of this NFT can modify or redeem the position.\\\\\\\\n',\\n        '\\\\\\\\nPair Address: ',\\n        _pairAddress,\\n        '\\\\\\\\n',\\n        _escapeQuotes(_tokenASymbol)\\n      )\\n    );\\n    string memory _part2 = string(\\n      abi.encodePacked(\\n        ' Address: ',\\n        _tokenAAddress,\\n        '\\\\\\\\n',\\n        _escapeQuotes(_tokenBSymbol),\\n        ' Address: ',\\n        _tokenBAddress,\\n        '\\\\\\\\nSwap interval: ',\\n        _interval,\\n        '\\\\\\\\nToken ID: ',\\n        _tokenId.toString(),\\n        '\\\\\\\\n\\\\\\\\n',\\n        unicode'⚠️ DISCLAIMER: Due diligence is imperative when assessing this NFT. Make sure token addresses match the expected tokens, as token symbols may be imitated.'\\n      )\\n    );\\n    return string(abi.encodePacked(_part1, _part2));\\n  }\\n\\n  function _generateName(ConstructTokenURIParams memory _params) private pure returns (string memory) {\\n    return\\n      string(\\n        abi.encodePacked(\\n          'Mean Finance DCA - ',\\n          _params.swapInterval,\\n          ' - ',\\n          _escapeQuotes(_params.tokenASymbol),\\n          '/',\\n          _escapeQuotes(_params.tokenBSymbol)\\n        )\\n      );\\n  }\\n\\n  struct DecimalStringParams {\\n    // significant figures of decimal\\n    uint256 sigfigs;\\n    // length of decimal string\\n    uint8 bufferLength;\\n    // ending index for significant figures (funtion works backwards when copying sigfigs)\\n    uint8 sigfigIndex;\\n    // index of decimal place (0 if no decimal)\\n    uint8 decimalIndex;\\n    // start index for trailing/leading 0's for very small/large numbers\\n    uint8 zerosStartIndex;\\n    // end index for trailing/leading 0's for very small/large numbers\\n    uint8 zerosEndIndex;\\n    // true if decimal number is less than one\\n    bool isLessThanOne;\\n  }\\n\\n  function _generateDecimalString(DecimalStringParams memory params) private pure returns (string memory) {\\n    bytes memory buffer = new bytes(params.bufferLength);\\n    if (params.isLessThanOne) {\\n      buffer[0] = '0';\\n      buffer[1] = '.';\\n    }\\n\\n    // add leading/trailing 0's\\n    for (uint256 zerosCursor = params.zerosStartIndex; zerosCursor < params.zerosEndIndex + 1; zerosCursor++) {\\n      buffer[zerosCursor] = bytes1(uint8(48));\\n    }\\n    // add sigfigs\\n    while (params.sigfigs > 0) {\\n      if (params.decimalIndex > 0 && params.sigfigIndex == params.decimalIndex) {\\n        buffer[params.sigfigIndex--] = '.';\\n      }\\n      uint8 charIndex = uint8(48 + (params.sigfigs % 10));\\n      buffer[params.sigfigIndex] = bytes1(charIndex);\\n      params.sigfigs /= 10;\\n      if (params.sigfigs > 0) {\\n        params.sigfigIndex--;\\n      }\\n    }\\n    return string(buffer);\\n  }\\n\\n  function _sigfigsRounded(uint256 value, uint8 digits) private pure returns (uint256, bool) {\\n    bool extraDigit;\\n    if (digits > 5) {\\n      value = value / (10**(digits - 5));\\n    }\\n    bool roundUp = value % 10 > 4;\\n    value = value / 10;\\n    if (roundUp) {\\n      value = value + 1;\\n    }\\n    // 99999 -> 100000 gives an extra sigfig\\n    if (value == 100000) {\\n      value /= 10;\\n      extraDigit = true;\\n    }\\n    return (value, extraDigit);\\n  }\\n\\n  function fixedPointToDecimalString(uint256 value, uint8 decimals) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return '0.0000';\\n    }\\n\\n    bool priceBelow1 = value < 10**decimals;\\n\\n    // get digit count\\n    uint256 temp = value;\\n    uint8 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    // don't count extra digit kept for rounding\\n    digits = digits - 1;\\n\\n    // address rounding\\n    (uint256 sigfigs, bool extraDigit) = _sigfigsRounded(value, digits);\\n    if (extraDigit) {\\n      digits++;\\n    }\\n\\n    DecimalStringParams memory params;\\n    if (priceBelow1) {\\n      // 7 bytes ( \\\"0.\\\" and 5 sigfigs) + leading 0's bytes\\n      params.bufferLength = uint8(digits >= 5 ? decimals - digits + 6 : decimals + 2);\\n      params.zerosStartIndex = 2;\\n      params.zerosEndIndex = uint8(decimals - digits + 1);\\n      params.sigfigIndex = uint8(params.bufferLength - 1);\\n    } else if (digits >= decimals + 4) {\\n      // no decimal in price string\\n      params.bufferLength = uint8(digits - decimals + 1);\\n      params.zerosStartIndex = 5;\\n      params.zerosEndIndex = uint8(params.bufferLength - 1);\\n      params.sigfigIndex = 4;\\n    } else {\\n      // 5 sigfigs surround decimal\\n      params.bufferLength = 6;\\n      params.sigfigIndex = 5;\\n      params.decimalIndex = uint8(digits - decimals + 1);\\n    }\\n    params.sigfigs = sigfigs;\\n    params.isLessThanOne = priceBelow1;\\n\\n    return _generateDecimalString(params);\\n  }\\n\\n  function addressToString(address _addr) internal pure returns (string memory) {\\n    bytes memory s = new bytes(40);\\n    for (uint256 i = 0; i < 20; i++) {\\n      bytes1 b = bytes1(uint8(uint256(uint160(_addr)) / (2**(8 * (19 - i)))));\\n      bytes1 hi = bytes1(uint8(b) / 16);\\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n      s[2 * i] = _char(hi);\\n      s[2 * i + 1] = _char(lo);\\n    }\\n    return string(abi.encodePacked('0x', string(s)));\\n  }\\n\\n  function _char(bytes1 b) private pure returns (bytes1 c) {\\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n    else return bytes1(uint8(b) + 0x57);\\n  }\\n\\n  function _generateSVGImage(ConstructTokenURIParams memory _params) private pure returns (string memory svg) {\\n    string memory _fromSymbol;\\n    string memory _toSymbol;\\n    uint8 _fromDecimals;\\n    uint8 _toDecimals;\\n    if (_params.fromA) {\\n      _fromSymbol = _escapeQuotes(_params.tokenASymbol);\\n      _fromDecimals = _params.tokenADecimals;\\n      _toSymbol = _escapeQuotes(_params.tokenBSymbol);\\n      _toDecimals = _params.tokenBDecimals;\\n    } else {\\n      _fromSymbol = _escapeQuotes(_params.tokenBSymbol);\\n      _fromDecimals = _params.tokenBDecimals;\\n      _toSymbol = _escapeQuotes(_params.tokenASymbol);\\n      _toDecimals = _params.tokenADecimals;\\n    }\\n    NFTSVG.SVGParams memory _svgParams = NFTSVG.SVGParams({\\n      tokenId: _params.tokenId,\\n      tokenA: addressToString(_params.tokenA),\\n      tokenB: addressToString(_params.tokenB),\\n      tokenASymbol: _escapeQuotes(_params.tokenASymbol),\\n      tokenBSymbol: _escapeQuotes(_params.tokenBSymbol),\\n      interval: _params.swapInterval,\\n      swapsExecuted: _params.swapsExecuted,\\n      swapsLeft: _params.swapsLeft,\\n      swapped: string(abi.encodePacked(fixedPointToDecimalString(_params.swapped, _toDecimals), ' ', _toSymbol)),\\n      averagePrice: string(\\n        abi.encodePacked(\\n          fixedPointToDecimalString(_params.swapsExecuted > 0 ? _params.swapped / _params.swapsExecuted : 0, _toDecimals),\\n          ' ',\\n          _toSymbol\\n        )\\n      ),\\n      remaining: string(abi.encodePacked(fixedPointToDecimalString(_params.remaining, _fromDecimals), ' ', _fromSymbol)),\\n      rate: string(abi.encodePacked(fixedPointToDecimalString(_params.rate, _fromDecimals), ' ', _fromSymbol))\\n    });\\n\\n    return NFTSVG.generateSVG(_svgParams);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITimeWeightedOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\\n\\n/// @title The interface for an oracle that provies TWAP quotes\\n/// @notice These methods allow users to add support for pairs, and then ask for quotes\\ninterface ITimeWeightedOracle {\\n  /// @notice Emitted when the oracle add supports for a new pair\\n  /// @param _tokenA One of the pair's tokens\\n  /// @param _tokenB The other of the pair's tokens\\n  event AddedSupportForPair(address _tokenA, address _tokenB);\\n\\n  /// @notice Returns whether this oracle can support this pair of tokens\\n  /// @dev _tokenA and _tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n  /// @param _tokenA One of the pair's tokens\\n  /// @param _tokenB The other of the pair's tokens\\n  /// @return _canSupport Whether the given pair of tokens can be supported by the oracle\\n  function canSupportPair(address _tokenA, address _tokenB) external view returns (bool _canSupport);\\n\\n  /// @notice Returns a quote, based on the given tokens and amount\\n  /// @param _tokenIn The token that will be provided\\n  /// @param _amountIn The amount that will be provided\\n  /// @param _tokenOut The token we would like to quote\\n  /// @return _amountOut How much _tokenOut will be returned in exchange for _amountIn amount of _tokenIn\\n  function quote(\\n    address _tokenIn,\\n    uint128 _amountIn,\\n    address _tokenOut\\n  ) external view returns (uint256 _amountOut);\\n\\n  /// @notice Add support for a given pair to the contract. This function will let the oracle take some actions to\\n  /// configure the pair for future quotes. Could be called more than one in order to let the oracle re-configure for a new context.\\n  /// @dev Will revert if pair cannot be supported. _tokenA and _tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n  /// @param _tokenA One of the pair's tokens\\n  /// @param _tokenB The other of the pair's tokens\\n  function addSupportForPair(address _tokenA, address _tokenB) external;\\n}\\n\\n/// @title An implementation of ITimeWeightedOracle that uses Uniswap V3 pool oracles\\n/// @notice This oracle will attempt to use all fee tiers of the same pair when calculating quotes\\ninterface IUniswapV3OracleAggregator is ITimeWeightedOracle {\\n  /// @notice Emitted when a new fee tier is added\\n  /// @return _feeTier The added fee tier\\n  event AddedFeeTier(uint24 _feeTier);\\n\\n  /// @notice Emitted when a new period is set\\n  /// @return _period The new period\\n  event PeriodChanged(uint32 _period);\\n\\n  /// @notice Returns the Uniswap V3 Factory\\n  /// @return _factory The Uniswap V3 Factory\\n  function factory() external view returns (IUniswapV3Factory _factory);\\n\\n  /// @notice Returns a list of all supported Uniswap V3 fee tiers\\n  /// @return _feeTiers An array of all supported fee tiers\\n  function supportedFeeTiers() external view returns (uint24[] memory _feeTiers);\\n\\n  /// @notice Returns a list of all Uniswap V3 pools used for a given pair\\n  /// @dev _tokenA and _tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n  /// @return _pools An array with all pools used for quoting the given pair\\n  function poolsUsedForPair(address _tokenA, address _tokenB) external view returns (address[] memory _pools);\\n\\n  /// @notice Returns the period used for the TWAP calculation\\n  /// @return _period The period used for the TWAP\\n  function period() external view returns (uint16 _period);\\n\\n  /// @notice Returns minimum possible period\\n  /// @dev Cannot be modified\\n  /// @return The minimum possible period\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MINIMUM_PERIOD() external view returns (uint16);\\n\\n  /// @notice Returns maximum possible period\\n  /// @dev Cannot be modified\\n  /// @return The maximum possible period\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MAXIMUM_PERIOD() external view returns (uint16);\\n\\n  /// @notice Returns the minimum liquidity that a pool needs to have in order to be used for a pair's quote\\n  /// @dev This check is only performed when adding support for a pair. If the pool's liquidity then\\n  /// goes below the threshold, then it will still be used for the quote calculation\\n  /// @return The minimum liquidity threshold\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MINIMUM_LIQUIDITY_THRESHOLD() external view returns (uint16);\\n\\n  /// @notice Adds support for a new Uniswap V3 fee tier\\n  /// @dev Will revert if the provided fee tier is not supported by Uniswap V3\\n  /// @param _feeTier The new fee tier\\n  function addFeeTier(uint24 _feeTier) external;\\n\\n  /// @notice Sets the period to be used for the TWAP calculation\\n  /// @dev Will revert it is lower than MINIMUM_PERIOD or greater than MAXIMUM_PERIOD\\n  /// WARNING: increasing the period could cause big problems, because Uniswap V3 pools might not support a TWAP so old.\\n  /// @param _period The new period\\n  function setPeriod(uint16 _period) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDCATokenDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.6;\\n\\nimport './IDCAPair.sol';\\n\\n/// @title The interface for generating a token's description\\n/// @notice Contracts that implement this interface must return a base64 JSON with the entire description\\ninterface IDCATokenDescriptor {\\n  /// @notice Generates a token's description, both the JSON and the image inside\\n  /// @param _positionHandler The pair where the position was created\\n  /// @param _tokenId The token/position id\\n  /// @return _description The position's description\\n  function tokenURI(IDCAPairPositionHandler _positionHandler, uint256 _tokenId) external view returns (string memory _description);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides a function for encoding some bytes in base64\\nlibrary Base64 {\\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n        \\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n            \\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n            \\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n            \\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n            \\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               dataPtr := add(dataPtr, 3)\\n               \\n               // read 3 bytes\\n               let input := mload(dataPtr)\\n               \\n               // write 4 characters\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n            }\\n            \\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/NFTSVG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.6;\\n\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\n/// @title NFTSVG\\n/// @notice Provides a function for generating an SVG associated with a DCA NFT. Based on Uniswap's NFTDescriptor. Background by bgjar.com\\nlibrary NFTSVG {\\n  using Strings for uint256;\\n  using Strings for uint32;\\n\\n  struct SVGParams {\\n    string tokenA;\\n    string tokenB;\\n    string tokenASymbol;\\n    string tokenBSymbol;\\n    string interval;\\n    uint32 swapsExecuted;\\n    uint32 swapsLeft;\\n    uint256 tokenId;\\n    string swapped;\\n    string averagePrice;\\n    string remaining;\\n    string rate;\\n  }\\n\\n  function generateSVG(SVGParams memory params) internal pure returns (string memory svg) {\\n    return\\n      string(\\n        abi.encodePacked(\\n          _generateSVGDefs(),\\n          _generateSVGBorderText(params.tokenA, params.tokenB, params.tokenASymbol, params.tokenBSymbol),\\n          _generateSVGCardMantle(params.tokenASymbol, params.tokenBSymbol, params.interval),\\n          _generageSVGProgressArea(params.swapsExecuted, params.swapsLeft),\\n          _generateSVGPositionData(params.tokenId, params.swapped, params.averagePrice, params.remaining, params.rate),\\n          '</svg>'\\n        )\\n      );\\n  }\\n\\n  function _generateSVGDefs() private pure returns (string memory svg) {\\n    svg = string(\\n      abi.encodePacked(\\n        '<svg width=\\\"290\\\" height=\\\"560\\\" viewBox=\\\"0 0 290 560\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">',\\n        '<defs><linearGradient x1=\\\"118.1%\\\" y1=\\\"10.5%\\\" x2=\\\"-18.1%\\\" y2=\\\"89.5%\\\" gradientUnits=\\\"userSpaceOnUse\\\" id=\\\"LinearGradient\\\"><stop stop-color=\\\"rgba(13, 5, 20, 1)\\\" offset=\\\"0\\\"></stop><stop stop-color=\\\"rgba(47, 19, 66, 1)\\\" offset=\\\"0.7\\\"></stop><stop stop-color=\\\"rgba(35, 17, 51, 1)\\\" offset=\\\"1\\\"></stop></linearGradient><clipPath id=\\\"corners\\\"><rect width=\\\"290\\\" height=\\\"560\\\" rx=\\\"40\\\" ry=\\\"40\\\" /></clipPath><path id=\\\"text-path-a\\\" d=\\\"M40 12 H250 A28 28 0 0 1 278 40 V520 A28 28 0 0 1 250 548 H40 A28 28 0 0 1 12 520 V40 A28 28 0 0 1 40 12 z\\\" /><mask id=\\\"none\\\" maskContentUnits=\\\"objectBoundingBox\\\"><rect width=\\\"1\\\" height=\\\"1\\\" fill=\\\"white\\\" /></mask><linearGradient id=\\\"grad-symbol\\\"><stop offset=\\\"0.8\\\" stop-color=\\\"white\\\" stop-opacity=\\\"1\\\" /><stop offset=\\\".95\\\" stop-color=\\\"white\\\" stop-opacity=\\\"0\\\" /></linearGradient><mask id=\\\"fade-symbol\\\" maskContentUnits=\\\"userSpaceOnUse\\\"><rect width=\\\"290px\\\" height=\\\"200px\\\" fill=\\\"url(#grad-symbol)\\\" /></mask></defs>',\\n        '<g clip-path=\\\"url(#corners)\\\">',\\n        '<rect width=\\\"290\\\" height=\\\"560\\\" x=\\\"0\\\" y=\\\"0\\\" fill=\\\"url(#LinearGradient)\\\"></rect>',\\n        '<path d=\\\"M290 0L248.61 0L290 61.48z\\\" fill=\\\"rgba(255, 255, 255, .1)\\\"></path>',\\n        '<path d=\\\"M248.61 0L290 61.48L290 189.35999999999999L200.75 0z\\\" fill=\\\"rgba(255, 255, 255, .075)\\\"></path>',\\n        '<path d=\\\"M200.75 0L290 189.35999999999999L290 294.91999999999996L112.52 0z\\\" fill=\\\"rgba(255, 255, 255, .05)\\\"></path>',\\n        '<path d=\\\"M112.51999999999998 0L290 294.91999999999996L290 357.79999999999995L32.78999999999998 0z\\\" fill=\\\"rgba(255, 255, 255, .025)\\\"></path>',\\n        '<path d=\\\"M0 560L40.27 560L0 402.35z\\\" fill=\\\"rgba(0, 0, 0, .1)\\\"></path>',\\n        '<path d=\\\"M0 402.35L40.27 560L137.96 560L0 221.89000000000001z\\\" fill=\\\"rgba(0, 0, 0, .075)\\\"></path>',\\n        '<path d=\\\"M0 221.89L137.96 560L153.85600000000002 560L0 183.92z\\\" fill=\\\"rgba(0, 0, 0, .05)\\\"></path>',\\n        '<path d=\\\"M0 183.91999999999996L153.85000000000002 560L156.66000000000003 560L0 151.61999999999995z\\\" fill=\\\"rgba(0, 0, 0, .025)\\\"></path>',\\n        '</g>'\\n      )\\n    );\\n  }\\n\\n  function _generateSVGBorderText(\\n    string memory _tokenA,\\n    string memory _tokenB,\\n    string memory _tokenASymbol,\\n    string memory _tokenBSymbol\\n  ) private pure returns (string memory svg) {\\n    string memory _tokenAText = string(abi.encodePacked(_tokenA, unicode' • ', _tokenASymbol));\\n    string memory _tokenBText = string(abi.encodePacked(_tokenB, unicode' • ', _tokenBSymbol));\\n    svg = string(\\n      abi.encodePacked(\\n        '<text text-rendering=\\\"optimizeSpeed\\\"><textPath startOffset=\\\"-100%\\\" fill=\\\"white\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-size=\\\"10px\\\" xlink:href=\\\"#text-path-a\\\">',\\n        _tokenAText,\\n        '<animate additive=\\\"sum\\\" attributeName=\\\"startOffset\\\" from=\\\"0%\\\" to=\\\"100%\\\" begin=\\\"0s\\\" dur=\\\"30s\\\" repeatCount=\\\"indefinite\\\" /></textPath><textPath startOffset=\\\"0%\\\" fill=\\\"white\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-size=\\\"10px\\\" xlink:href=\\\"#text-path-a\\\">',\\n        _tokenAText,\\n        '<animate additive=\\\"sum\\\" attributeName=\\\"startOffset\\\" from=\\\"0%\\\" to=\\\"100%\\\" begin=\\\"0s\\\" dur=\\\"30s\\\" repeatCount=\\\"indefinite\\\" /></textPath><textPath startOffset=\\\"50%\\\" fill=\\\"white\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-size=\\\"10px\\\" xlink:href=\\\"#text-path-a\\\">',\\n        _tokenBText,\\n        '<animate additive=\\\"sum\\\" attributeName=\\\"startOffset\\\" from=\\\"0%\\\" to=\\\"100%\\\" begin=\\\"0s\\\" dur=\\\"30s\\\" repeatCount=\\\"indefinite\\\" /></textPath><textPath startOffset=\\\"-50%\\\" fill=\\\"white\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-size=\\\"10px\\\" xlink:href=\\\"#text-path-a\\\">',\\n        _tokenBText,\\n        '<animate additive=\\\"sum\\\" attributeName=\\\"startOffset\\\" from=\\\"0%\\\" to=\\\"100%\\\" begin=\\\"0s\\\" dur=\\\"30s\\\" repeatCount=\\\"indefinite\\\" /></textPath></text>'\\n      )\\n    );\\n  }\\n\\n  function _generateSVGCardMantle(\\n    string memory _tokenASymbol,\\n    string memory _tokenBSymbol,\\n    string memory _interval\\n  ) private pure returns (string memory svg) {\\n    svg = string(\\n      abi.encodePacked(\\n        '<g mask=\\\"url(#fade-symbol)\\\">'\\n        '<rect fill=\\\"none\\\" x=\\\"0px\\\" y=\\\"0px\\\" width=\\\"290px\\\" height=\\\"200px\\\" />'\\n        '<text y=\\\"70px\\\" x=\\\"32px\\\" fill=\\\"white\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-weight=\\\"200\\\" font-size=\\\"35px\\\">',\\n        _tokenASymbol,\\n        '/',\\n        _tokenBSymbol,\\n        '</text>',\\n        '<text y=\\\"115px\\\" x=\\\"32px\\\" fill=\\\"white\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-weight=\\\"200\\\" font-size=\\\"28px\\\">',\\n        _interval,\\n        '</text>'\\n        '</g>'\\n      )\\n    );\\n  }\\n\\n  function _generageSVGProgressArea(uint32 _swapsExecuted, uint32 _swapsLeft) private pure returns (string memory svg) {\\n    uint256 _positionNow = 170 + ((314 - 170) / (_swapsExecuted + _swapsLeft)) * _swapsExecuted;\\n    svg = string(\\n      abi.encodePacked(\\n        '<rect x=\\\"16\\\" y=\\\"16\\\" width=\\\"258\\\" height=\\\"528\\\" rx=\\\"26\\\" ry=\\\"26\\\" fill=\\\"rgba(0,0,0,0)\\\" stroke=\\\"rgba(255,255,255,0.2)\\\" />',\\n        '<g mask=\\\"url(#none)\\\" style=\\\"transform:translate(80px,169px)\\\"><rect x=\\\"-16px\\\" y=\\\"-16px\\\" width=\\\"180px\\\" height=\\\"180px\\\" fill=\\\"none\\\" /><path d=\\\"M1 1 L1 145\\\" stroke=\\\"rgba(0,0,0,0.3)\\\" stroke-width=\\\"32px\\\" fill=\\\"none\\\" stroke-linecap=\\\"round\\\" /></g>',\\n        '<g mask=\\\"url(#none)\\\" style=\\\"transform:translate(80px,169px)\\\"><rect x=\\\"-16px\\\" y=\\\"-16px\\\" width=\\\"180px\\\" height=\\\"180px\\\" fill=\\\"none\\\" /><path d=\\\"M1 1 L1 145\\\" stroke=\\\"rgba(255,255,255,1)\\\" fill=\\\"none\\\" stroke-linecap=\\\"round\\\" /></g>',\\n        '<circle cx=\\\"81px\\\" cy=\\\"170px\\\" r=\\\"4px\\\" fill=\\\"#dddddd\\\" />',\\n        '<circle cx=\\\"81px\\\" cy=\\\"',\\n        _positionNow.toString(),\\n        'px\\\" r=\\\"5px\\\" fill=\\\"white\\\" />',\\n        '<circle cx=\\\"81px\\\" cy=\\\"314px\\\" r=\\\"4px\\\" fill=\\\"#dddddd\\\" /><text x=\\\"100px\\\" y=\\\"174px\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-size=\\\"12px\\\" fill=\\\"white\\\"><tspan fill=\\\"rgba(255,255,255,0.6)\\\">Executed*: </tspan>',\\n        _swapsExecuted.toString(),\\n        ' swaps</text><text x=\\\"40px\\\" y=\\\"',\\n        (_positionNow + 4).toString(),\\n        'px\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-size=\\\"12px\\\" fill=\\\"white\\\">Now</text><text x=\\\"100px\\\" y=\\\"318px\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-size=\\\"12px\\\" fill=\\\"white\\\"><tspan fill=\\\"rgba(255,255,255,0.6)\\\">Left: </tspan>',\\n        _swapsLeft.toString(),\\n        ' swaps</text>'\\n      )\\n    );\\n  }\\n\\n  function _generateSVGPositionData(\\n    uint256 _tokenId,\\n    string memory _swapped,\\n    string memory _averagePrice,\\n    string memory _remaining,\\n    string memory _rate\\n  ) private pure returns (string memory svg) {\\n    svg = string(\\n      abi.encodePacked(\\n        _generateData('Id', _tokenId.toString(), 364),\\n        _generateData('Swapped*', _swapped, 394),\\n        _generateData('Avg Price', _averagePrice, 424),\\n        _generateData('Remaining', _remaining, 454),\\n        _generateData('Rate', _rate, 484),\\n        '<g style=\\\"transform:translate(25px, 514px)\\\">',\\n        '<text x=\\\"12px\\\" y=\\\"17px\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-size=\\\"10px\\\" fill=\\\"white\\\">',\\n        '<tspan fill=\\\"rgba(255,255,255,0.8)\\\">* since start or last edit/withdraw</tspan>',\\n        '</text>',\\n        '</g>'\\n      )\\n    );\\n  }\\n\\n  function _generateData(\\n    string memory _title,\\n    string memory _data,\\n    uint256 _yCoord\\n  ) private pure returns (string memory svg) {\\n    uint256 _strLength = bytes(_title).length + bytes(_data).length + 2;\\n    svg = string(\\n      abi.encodePacked(\\n        '<g style=\\\"transform:translate(29px, ',\\n        _yCoord.toString(),\\n        'px)\\\">',\\n        '<rect width=\\\"',\\n        uint256(7 * (_strLength + 4)).toString(),\\n        'px\\\" height=\\\"26px\\\" rx=\\\"8px\\\" ry=\\\"8px\\\" fill=\\\"rgba(0,0,0,0.6)\\\" />',\\n        '<text x=\\\"12px\\\" y=\\\"17px\\\" font-family=\\\"\\\\'Courier New\\\\', monospace\\\" font-size=\\\"12px\\\" fill=\\\"white\\\">',\\n        '<tspan fill=\\\"rgba(255,255,255,0.6)\\\">',\\n        _title,\\n        ': </tspan>',\\n        _data,\\n        '</text>',\\n        '</g>'\\n      )\\n    );\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IDCAPairPositionHandler\",\"name\":\"_positionHandler\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DCATokenDescriptor","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}