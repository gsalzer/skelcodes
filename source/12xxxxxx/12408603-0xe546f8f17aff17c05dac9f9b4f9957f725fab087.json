{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @notice Wording below needs to properly represent the legal terms so has to be reviewed\\n/// @notice Comments have been written by the development team and may not represent the actual terms of the contract correctly\\n\\n/// @title Oiler Staking\\n/// @author oiler.network\\n/// @dev that staking contract is fully dependent on the provided reward token and the underlying LP token.\\n/**\\n * @notice Staking contract assumes there is a Staking Program going on until a specified Staking Program End Date.\\n * And there is an amount of Oiler tokens that is gonna be given away to incentivise participation in the Staking Program (called StakingFund).\\n * \\n * During this Program - users commit to lock tokens for some period of time, earning RewardPoints (if they don't unlock prematurely).\\n * RewardPoints multiplier grows linearly with the locking period length (see the formula in calculateStakingRewardPoints() function)\\n * \\n * After the end of the Staking Program - the amount of RewardPoints earned by each user is relatively compared to the total RewardPoints\\n * earned by all staking participants - and the OIL tokens from StakingFund are divided among them accordingly, by their RewardPoints proportions.\\n */\\ncontract Staking {\\n\\n  /**\\n   * @dev Saving gas by using lower-bit variables to fit the Stake struct into 256bits\\n   *\\n   * LP Tokens are calculated by this formula:\\n   * LP Tokens = sqrt(tokenAmount * e18 * usdcAmount * e6) =\\n   *           = sqrt(100 000 000 * usdcAmount * e24) =          // here 100 000 000 is totalSupply of OIL\\n   *           = sqrt(usdcAmount * e32) =\\n   *           = sqrt(usdcAmount) * e16\\n   * \\n   * Thus the maximum amount of USDC we can use to not overflow the maximum amount of uint72 (4722 e18) will be:\\n   *             sqrt(usdcAmount) * e16 < 4722 * e18\\n   *             sqrt(usdcAmount) < 472 200\\n   *             usdcAmount < 222 972 840 000\\n   * Which is over two hundred trillion dollars - the amount highly improbable at our Uniswap pool as for today\\n   *\\n   * tokenAmount is limited by LP tokens amount (4722e18 LPs for hundreds of trillions of dollars)   (Range: [0 - 4722 e18]          - uint72 (max 4722 e18))\\n   * lockingPeriodInBlocks is limited by Staking Program duration (around 700000 blocks)             (Range: [1 - 700000]            - uint24 (max 16 777 215))\\n   * startBlock is in a typical range of Mainnet, Testnets, local networks blocks range              (Range: [0 - 100 000 000]       - uint32 (max 4 294 967 295))\\n   * \\n   * expectedStakingRewardPoints is limited by:\\n   * LP tokens amount * lockingPeriodInBlocks * lockingPeriodInBlocks\\n   * which is:\\n   * uint72 * uint24 * uint24 = which gives us max uint120, but we use uint128 anyway                (Range: [0 - 1.33 e36]           - uint128 (max 340 e36))\\n   */\\n    struct Stake {\\n        uint72 tokenAmount;                   // Amount of tokens locked in a stake                                                             \\n        uint24 lockingPeriodInBlocks;         // Arbitrary lock period that will give you a reward                                    \\n        uint32 startBlock;                    // Start of the locking                                                                            \\n        uint128 expectedStakingRewardPoints;  // The amount of RewardPoints the stake will earn if not unlocked prematurely    \\n    }\\n    \\n    /// @notice Active stakes for each user\\n    mapping (address => Stake) public stakes;\\n\\n    /// @notice \\\"Reward points\\\" each user earned (would be relative to totalRewardPoints to get the percentage)\\n    mapping (address => uint256) public rewardPointsEarned;\\n    \\n    /// @notice Total \\\"reward points\\\" all users earned\\n    uint256 public totalRewardPoints;\\n    /// @notice Block when Staking Program ends          \\n    uint256 immutable public stakingProgramEndsBlock;\\n    /// @notice Amount of Staking Bonus Fund (500 000 OIL), Oiler funds must be here, approved and ready to be transferredFrom\\n    uint256 immutable public stakingFundAmount;\\n    \\n    /// @notice Uniswap pool that we accept LP tokens from\\n    IERC20 public poolToken;\\n    /// @notice Oiler token that will be given as a reward\\n    IERC20 immutable public oilerToken;\\n    \\n    /// @notice The amount of OIL tokens earned, granted to be released during vesting period \\n    mapping (address => uint256) public grantedTokens;\\n    /// @notice The amount of OIL tokens that were already released during vesting period\\n    mapping (address => uint256) public releasedTokens;\\n    \\n    /// @dev In blocks - should be around 100 days\\n    uint256 immutable public vestingDuration;\\n\\n    /// @dev Check if poolToken was initialized\\n    modifier poolTokenSet() {\\n        require(address(poolToken) != address(0x0), \\\"poolToken not set\\\");\\n        _;\\n    }\\n\\n    /// @dev Owner is used only in setPoolToken()\\n    address immutable public owner;\\n\\n    /// @dev Used only in setPoolToken()\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Can only be called by owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev before deploying the stakingFundAddress must have set allowances on behalf of that contract. The address can be predicted basing on the CREATE or CREATE2 opcode.\\n     * @param oilerToken_ - address of the token in which rewards will be payed off.\\n     * @param stakingDurationInBlocks_ - Number of blocks after which staking will end.\\n     * @param stakingFundAmount_ - Amount of tokens to be payed of as rewards.\\n     * @param vestingDuration_ - Number of blocks after which OIL tokens earned by staking will be released (duration of Vesting period).\\n     * @param owner_ - Owner of the contract (is used to initialize poolToken after it's available).\\n     */\\n    constructor(address oilerToken_, uint256 stakingDurationInBlocks_, uint256 stakingFundAmount_, uint256 vestingDuration_, address owner_) {\\n        require(owner_ != address(0x0), \\\"Owner address cannot be zero\\\");\\n        owner = owner_;\\n\\n        require(oilerToken_ != address(0x0), \\\"oilerToken address cannot be zero\\\");\\n        oilerToken = IERC20(oilerToken_);\\n        \\n        stakingProgramEndsBlock = block.number + stakingDurationInBlocks_;\\n        vestingDuration = vestingDuration_;\\n\\n        \\n        stakingFundAmount = stakingFundAmount_;\\n    }\\n\\n    /// @notice Initialize poolToken when OIL<>USDC Uniswap pool is available\\n    function setPoolToken(address poolToken_, address stakingFundAddress_) public onlyOwner {\\n        require(address(poolToken) == address(0x0), \\\"poolToken was already set\\\");\\n        require(poolToken_ != address(0x0), \\\"poolToken address cannot be zero\\\");\\n        poolToken = IERC20(poolToken_);\\n        // Transfer the Staking Bonus Funds from stakingFundAddress here\\n        require(IERC20(oilerToken).balanceOf(stakingFundAddress_) >= stakingFundAmount, \\\"StakingFund doesn't have enough OIL balance\\\");\\n        require(IERC20(oilerToken).allowance(stakingFundAddress_, address(this)) >= stakingFundAmount, \\\"StakingFund doesn't have enough allowance\\\");\\n        require(IERC20(oilerToken).transferFrom(stakingFundAddress_, address(this), stakingFundAmount), \\\"TransferFrom of OIL from StakingFund failed\\\");\\n    }\\n\\n    /**\\n     * @notice Calculates the RewardPoints user will earn for a given tokenAmount locked for a given period\\n     * @dev If any parameter is zero - it will fail, thus we save gas on \\\"requires\\\" by not checking in other places\\n     * @param tokenAmount_ - Amount of tokens to be stake.\\n     * @param lockingPeriodInBlocks_ - Lock duration defined in blocks.\\n     */\\n    function calculateStakingRewardPoints(uint72 tokenAmount_, uint24 lockingPeriodInBlocks_) public pure returns (uint128) {\\n        //\\n        //                         /                                   \\\\\\n        //  stakingRewardPoints = ( tokenAmount * lockingPeriodInBlocks )  *  lockingPeriodInBlocks\\n        //                         \\\\                                   /\\n        //\\n\\n        uint256 stakingRewardPoints = uint256(tokenAmount_) * uint256(lockingPeriodInBlocks_) * uint256(lockingPeriodInBlocks_);\\n        require(stakingRewardPoints > 0, \\\"Neither tokenAmount nor lockingPeriod couldn't be 0\\\");\\n        return uint128(stakingRewardPoints);\\n    }\\n\\n    /**\\n     * @notice Lock the LP tokens for a specified period of Blocks.\\n     * @notice Can only be called before Staking Program ends.\\n     * @notice And the locking period can't last longer than the end of Staking Program block.\\n     * @param tokenAmount_ - Amount of LP tokens to be locked.\\n     * @param lockingPeriodInBlocks_ - locking period duration defined in blocks.\\n     */\\n    function lockTokens(uint72 tokenAmount_, uint24 lockingPeriodInBlocks_) public poolTokenSet {\\n        // Here we don't check lockingPeriodInBlocks_ for being non-zero, cause its happening in calculateStakingRewardPoints() calculation\\n        require(block.number <= stakingProgramEndsBlock - lockingPeriodInBlocks_, \\\"Your lock period exceeds Staking Program duration\\\");\\n        require(stakes[msg.sender].tokenAmount == 0, \\\"Already staking\\\");\\n\\n        // This is a locking reward - will be earned only after the full lock period is over - otherwise not applicable\\n        uint128 expectedStakingRewardPoints = calculateStakingRewardPoints(tokenAmount_, lockingPeriodInBlocks_);\\n\\n        Stake memory stake = Stake(tokenAmount_, lockingPeriodInBlocks_, uint32(block.number), expectedStakingRewardPoints);\\n        stakes[msg.sender] = stake;\\n        \\n        // We add the rewards initially during locking of tokens, and subtract them later if unlocking is made prematurely\\n        // That prevents us from waiting for all users to unlock to distribute the rewards after Staking Program Ends\\n        totalRewardPoints += expectedStakingRewardPoints;\\n        rewardPointsEarned[msg.sender] += expectedStakingRewardPoints;\\n        \\n        // We transfer LP tokens from user to this contract, \\\"locking\\\" them\\n        // We don't check for allowances or balance cause it's done within the transferFrom() and would only raise gas costs\\n        require(poolToken.transferFrom(msg.sender, address(this), tokenAmount_), \\\"TransferFrom of poolTokens failed\\\");\\n\\n        emit StakeLocked(msg.sender, tokenAmount_, lockingPeriodInBlocks_, expectedStakingRewardPoints);\\n    }\\n\\n    /**\\n     * @notice Unlock the tokens and get the reward\\n     * @notice This can be called at any time, even after Staking Program end block\\n     */\\n    function unlockTokens() public poolTokenSet {\\n        Stake memory stake = stakes[msg.sender];\\n\\n        uint256 stakeAmount = stake.tokenAmount;\\n\\n        require(stakeAmount != 0, \\\"You don't have a stake to unlock\\\");\\n\\n        require(block.number > stake.startBlock, \\\"You can't withdraw the stake in the same block it was locked\\\");\\n\\n        // Check if the unlock is called prematurely - and subtract the reward if it is the case\\n        _punishEarlyWithdrawal(stake);\\n\\n        // Zero the Stake - to protect from double-unlocking and to be able to stake again\\n        delete stakes[msg.sender];\\n\\n        require(poolToken.transfer(msg.sender, stakeAmount), \\\"Pool token transfer failed\\\");\\n    }\\n    \\n    /**\\n     * @notice If the unlock is called prematurely - we subtract the bonus\\n     */\\n    function _punishEarlyWithdrawal(Stake memory stake_) internal {\\n        // As any of the locking periods can't be longer than Staking Program end block - this will automatically mean that if called after Staking Program end - all stakes locking periods are over\\n        // So no rewards can be manipulated after Staking Program ends\\n        if (block.number < (stake_.startBlock + stake_.lockingPeriodInBlocks)) { // lt - cause you can only withdraw at or after startBlock + lockPeriod\\n            rewardPointsEarned[msg.sender] -= stake_.expectedStakingRewardPoints;\\n            totalRewardPoints -= stake_.expectedStakingRewardPoints;\\n            emit StakeUnlockedPrematurely(msg.sender, stake_.tokenAmount, stake_.lockingPeriodInBlocks, block.number - stake_.startBlock);\\n        } else {\\n            emit StakeUnlocked(msg.sender, stake_.tokenAmount, stake_.lockingPeriodInBlocks, stake_.expectedStakingRewardPoints);\\n        }\\n    }\\n    \\n    /** \\n     * @notice This can only be called after the Staking Program ended\\n     * @dev Which means that all stakes lock periods are already over, and totalRewardPoints value isn't changing anymore - so we can now calculate the percentages of rewards\\n     */\\n    function getRewards() public {\\n        require(block.number > stakingProgramEndsBlock, \\\"You can only get Rewards after Staking Program ends\\\");\\n        require(stakes[msg.sender].tokenAmount == 0, \\\"You still have a stake locked - please unlock first, don't leave free money here\\\");\\n        require(rewardPointsEarned[msg.sender] > 0, \\\"You don't have any rewardPoints\\\");\\n        \\n        // The amount earned is calculated as:\\n        //\\n        //                                  user RewardPoints earned during Staking Program\\n        // amountEarned = stakingFund * -------------------------------------------------------\\n        //                                 total RewardPoints earned by everyone participated\\n        //\\n        // Division always rounds towards zero in solidity.\\n        // And because of this rounding somebody always misses the fractional part of their earnings and gets only integer amount.\\n        // Thus the worst thing that can happen is amountEarned becomes 0, and we check for that in _grantTokens()\\n        uint256 amountEarned = stakingFundAmount * rewardPointsEarned[msg.sender] / totalRewardPoints;\\n        rewardPointsEarned[msg.sender] = 0; // Zero rewardPoints of a user - so this function can be called only once per user\\n\\n        _grantTokens(msg.sender, amountEarned); // Grant OIL reward earned by user for future vesting during the Vesting period\\n    }\\n    \\n    //////////////////////////////////////////////////////\\n    //\\n    //     VESTING PART\\n    //\\n    //////////////////////////////////////////////////////\\n    \\n\\n    /**\\n     * @param recipient_ - Recipient of granted tokens\\n     * @param amountEarned_ - Amount of tokens earned to be granted\\n     */\\n    function _grantTokens(address recipient_, uint256 amountEarned_) internal {\\n        require(amountEarned_ > 0, \\\"You didn't earn any integer amount of wei\\\");\\n        require(recipient_ != address(0), \\\"TokenVesting: beneficiary is the zero address\\\");\\n        grantedTokens[recipient_] = amountEarned_;\\n        emit RewardGranted(recipient_, amountEarned_);\\n    }\\n    \\n    /// @notice Releases granted tokens\\n    function release() public {\\n        uint256 releasable = _releasableAmount(msg.sender);\\n        require(releasable > 0, \\\"Vesting release: no tokens are due\\\");\\n\\n        releasedTokens[msg.sender] += releasable;\\n        require(oilerToken.transfer(msg.sender, releasable), \\\"Reward oilers transfer failed\\\");\\n\\n        emit grantedTokensReleased(msg.sender, releasable);\\n    }\\n    \\n    /// @notice Releasable amount is what is available at a given time minus what was already withdrawn\\n    function _releasableAmount(address recipient_) internal view returns (uint256) {\\n        return _vestedAmount(recipient_) - releasedTokens[recipient_];\\n    }\\n    \\n    /**\\n     * @notice The output of this function gradually changes from [0.. to ..grantedAmount] while the vesting is going\\n     * @param recipient_ - vested tokens recipient\\n     * @return vested amount\\n     */\\n    function _vestedAmount(address recipient_) internal view returns (uint256) {\\n        if (block.number >= stakingProgramEndsBlock + vestingDuration) {\\n            // Return the full granted amount if Vesting Period is over\\n            return grantedTokens[recipient_];\\n        } else {\\n            // Return the proportional amount if Vesting Period is still going\\n            return grantedTokens[recipient_] * (block.number - stakingProgramEndsBlock) / vestingDuration;\\n        }\\n    }\\n    \\n    event StakeLocked(address recipient, uint256 tokenAmount, uint256 lockingPeriodInBlocks, uint256 expectedStakingRewardPoints);\\n    event StakeUnlockedPrematurely(address recipient, uint256 tokenAmount, uint256 lockingPeriodInBlocks, uint256 actualLockingPeriodInBlocks);\\n    event StakeUnlocked(address recipient, uint256 tokenAmount, uint256 lockingPeriodInBlocks, uint256 rewardPoints);\\n    event RewardGranted(address recipient, uint256 amountEarned);\\n    event grantedTokensReleased(address recipient, uint256 amount);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oilerToken_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingDurationInBlocks_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingFundAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingDuration_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountEarned\",\"type\":\"uint256\"}],\"name\":\"RewardGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockingPeriodInBlocks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expectedStakingRewardPoints\",\"type\":\"uint256\"}],\"name\":\"StakeLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockingPeriodInBlocks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPoints\",\"type\":\"uint256\"}],\"name\":\"StakeUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockingPeriodInBlocks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualLockingPeriodInBlocks\",\"type\":\"uint256\"}],\"name\":\"StakeUnlockedPrematurely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"grantedTokensReleased\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"tokenAmount_\",\"type\":\"uint72\"},{\"internalType\":\"uint24\",\"name\":\"lockingPeriodInBlocks_\",\"type\":\"uint24\"}],\"name\":\"calculateStakingRewardPoints\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"grantedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"tokenAmount_\",\"type\":\"uint72\"},{\"internalType\":\"uint24\",\"name\":\"lockingPeriodInBlocks_\",\"type\":\"uint24\"}],\"name\":\"lockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oilerToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"releasedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardPointsEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingFundAddress_\",\"type\":\"address\"}],\"name\":\"setPoolToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint72\",\"name\":\"tokenAmount\",\"type\":\"uint72\"},{\"internalType\":\"uint24\",\"name\":\"lockingPeriodInBlocks\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"startBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"expectedStakingRewardPoints\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingFundAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingProgramEndsBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000000275e1001e293c46cfe158b3702aade0b99f88a500000000000000000000000000000000000000000000000000000000000a12200000000000000000000000000000000000000000000069e10de76676d080000000000000000000000000000000000000000000000000000000000000000a1220000000000000000000000000a94db69502920a657f8685978e62d3e3b9762adf","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}