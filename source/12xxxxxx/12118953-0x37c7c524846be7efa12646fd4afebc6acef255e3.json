{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.4;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function abs(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a < b) {\r\n            return b - a;\r\n        }\r\n        return a - b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IFToken is IERC20 {\r\n    function mint(address user, uint256 amount) external returns (bytes memory);\r\n\r\n    function borrow(address borrower, uint256 borrowAmount)\r\n        external\r\n        returns (bytes memory);\r\n\r\n    function withdraw(\r\n        address payable withdrawer,\r\n        uint256 withdrawTokensIn,\r\n        uint256 withdrawAmountIn\r\n    ) external returns (uint256, bytes memory);\r\n\r\n    function underlying() external view returns (address);\r\n\r\n    function accrueInterest() external;\r\n\r\n    function getAccountState(address account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function MonitorEventCallback(\r\n        address who,\r\n        bytes32 funcName,\r\n        bytes calldata payload\r\n    ) external;\r\n\r\n    function exchangeRateCurrent() external view returns (uint256 exchangeRate);\r\n\r\n    function repay(address borrower, uint256 repayAmount)\r\n        external\r\n        returns (uint256, bytes memory);\r\n\r\n    function borrowBalanceStored(address account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function exchangeRateStored() external view returns (uint256 exchangeRate);\r\n\r\n    function liquidateBorrow(\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 repayAmount,\r\n        address fTokenCollateral\r\n    ) external returns (bytes memory);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint256);\r\n\r\n    function balanceOfUnderlying(address owner) external returns (uint256);\r\n\r\n    function _reduceReserves(uint256 reduceAmount) external;\r\n\r\n    function _addReservesFresh(uint256 addAmount) external;\r\n\r\n    function cancellingOut(address striker)\r\n        external\r\n        returns (bool strikeOk, bytes memory strikeLog);\r\n\r\n    function APR() external view returns (uint256);\r\n\r\n    function APY() external view returns (uint256);\r\n\r\n    function calcBalanceOfUnderlying(address owner)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function borrowSafeRatio() external view returns (uint256);\r\n\r\n    function tokenCash(address token, address account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getBorrowRate() external view returns (uint256);\r\n\r\n    function addTotalCash(uint256 _addAmount) external;\r\n\r\n    function subTotalCash(uint256 _subAmount) external;\r\n\r\n    function totalCash() external view returns (uint256);\r\n\r\n    function totalReserves() external view returns (uint256);\r\n\r\n    function totalBorrows() external view returns (uint256);\r\n}\r\n\r\ninterface IBankController {\r\n    function getCashPrior(address underlying) external view returns (uint256);\r\n\r\n    function getCashAfter(address underlying, uint256 msgValue)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getFTokeAddress(address underlying)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function transferToUser(\r\n        address token,\r\n        address payable user,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function transferIn(\r\n        address account,\r\n        address underlying,\r\n        uint256 amount\r\n    ) external payable;\r\n\r\n    function borrowCheck(\r\n        address account,\r\n        address underlying,\r\n        address fToken,\r\n        uint256 borrowAmount\r\n    ) external;\r\n\r\n    function repayCheck(address underlying) external;\r\n\r\n    function liquidateBorrowCheck(\r\n        address fTokenBorrowed,\r\n        address fTokenCollateral,\r\n        address borrower,\r\n        address liquidator,\r\n        uint256 repayAmount\r\n    ) external;\r\n\r\n    function liquidateTokens(\r\n        address fTokenBorrowed,\r\n        address fTokenCollateral,\r\n        uint256 actualRepayAmount\r\n    ) external view returns (uint256);\r\n\r\n    function withdrawCheck(\r\n        address fToken,\r\n        address withdrawer,\r\n        uint256 withdrawTokens\r\n    ) external view returns (uint256);\r\n\r\n    function transferCheck(\r\n        address fToken,\r\n        address src,\r\n        address dst,\r\n        uint256 transferTokens\r\n    ) external;\r\n\r\n    function marketsContains(address fToken) external view returns (bool);\r\n\r\n    function seizeCheck(address cTokenCollateral, address cTokenBorrowed)\r\n        external;\r\n\r\n    function mintCheck(\r\n        address underlying,\r\n        address minter,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function addReserves(address underlying, uint256 addAmount)\r\n        external\r\n        payable;\r\n\r\n    function reduceReserves(\r\n        address underlying,\r\n        address payable account,\r\n        uint256 reduceAmount\r\n    ) external;\r\n\r\n    function calcMaxBorrowAmount(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calcMaxWithdrawAmount(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calcMaxCashOutAmount(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calcMaxBorrowAmountWithRatio(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferEthGasCost() external view returns (uint256);\r\n\r\n    function isFTokenValid(address fToken) external view returns (bool);\r\n\r\n    function balance(address token) external view returns (uint256);\r\n\r\n    function flashloanFeeBips() external view returns (uint256);\r\n\r\n    function flashloanVault() external view returns (address);\r\n\r\n    function transferFlashloanAsset(\r\n        address token,\r\n        address payable user,\r\n        uint256 amount\r\n    ) external;\r\n}\r\n\r\nenum RewardType {\r\n    DefaultType,\r\n    Deposit,\r\n    Borrow,\r\n    Withdraw,\r\n    Repay,\r\n    Liquidation,\r\n    TokenIn,\r\n    TokenOut\r\n}\r\n\r\nlibrary EthAddressLib {\r\n    /**\r\n     * @dev returns the address used within the protocol to identify ETH\r\n     * @return the address assigned to ETH\r\n     */\r\n    function ethAddress() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\n\r\ncontract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private initializing;\r\n\r\n    /**\r\n     * @dev Modifier to use in the initializer function of a contract.\r\n     */\r\n    modifier initializer() {\r\n        require(\r\n            initializing || isConstructor() || !initialized,\r\n            \"Contract instance has already been initialized\"\r\n        );\r\n\r\n        bool isTopLevelCall = !initializing;\r\n        if (isTopLevelCall) {\r\n            initializing = true;\r\n            initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        assembly {\r\n            cs := extcodesize(self)\r\n        }\r\n        return cs == 0;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n/**\r\n * @title IFlashLoanReceiver interface\r\n * @notice Interface for the Aave fee IFlashLoanReceiver.\r\n * @author Aave\r\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\r\n */\r\ninterface IFlashLoanReceiver {\r\n    function executeOperation(\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata params\r\n    ) external;\r\n}\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract Bank is Initializable {\r\n    using SafeMath for uint256;\r\n\r\n    bool public paused;\r\n\r\n    address public mulSig;\r\n\r\n    //monitor event\r\n    event MonitorEvent(bytes32 indexed funcName, bytes payload);\r\n    event FlashLoan(\r\n        address indexed receiver,\r\n        address indexed token,\r\n        uint256 amount,\r\n        uint256 fee\r\n    );\r\n\r\n    modifier onlyFToken(address fToken) {\r\n        require(\r\n            controller.marketsContains(fToken) ||\r\n                msg.sender == address(controller),\r\n            \"only supported ftoken or controller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function MonitorEventCallback(bytes32 funcName, bytes calldata payload)\r\n        external\r\n        onlyFToken(msg.sender)\r\n    {\r\n        emit MonitorEvent(funcName, payload);\r\n    }\r\n\r\n    IBankController public controller;\r\n\r\n    address public admin;\r\n\r\n    address public proposedAdmin;\r\n    address public pauser;\r\n\r\n    bool private loaning;\r\n    modifier nonSelfLoan() {\r\n        require(!loaning, \"re-loaning\");\r\n        loaning = true;\r\n        _;\r\n        loaning = false;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin, \"OnlyAdmin\");\r\n        _;\r\n    }\r\n\r\n    modifier whenUnpaused {\r\n        require(!paused, \"System paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMulSig {\r\n        require(msg.sender == mulSig, \"require mulsig\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySelf {\r\n        require(msg.sender == address(this), \"require self\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPauser {\r\n        require(msg.sender == pauser, \"require pauser\");\r\n        _;\r\n    }\r\n\r\n    function initialize(address _controller, address _mulSig)\r\n        public\r\n        initializer\r\n    {\r\n        controller = IBankController(_controller);\r\n        mulSig = _mulSig;\r\n        paused = false;\r\n        admin = msg.sender;\r\n    }\r\n\r\n    function setController(address _controller) public onlyAdmin {\r\n        controller = IBankController(_controller);\r\n    }\r\n\r\n    function setPaused() public onlyPauser {\r\n        paused = true;\r\n    }\r\n\r\n    function setUnpaused() public onlyPauser {\r\n        paused = false;\r\n    }\r\n\r\n    function setPauser(address _pauser) public onlyAdmin {\r\n        pauser = _pauser;\r\n    }\r\n\r\n    function proposeNewAdmin(address admin_) external onlyMulSig {\r\n        proposedAdmin = admin_;\r\n    }\r\n\r\n    function claimAdministration() external {\r\n        require(msg.sender == proposedAdmin, \"Not proposed admin.\");\r\n        admin = proposedAdmin;\r\n        proposedAdmin = address(0);\r\n    }\r\n\r\n    function deposit(address token, uint256 amount)\r\n        public\r\n        payable\r\n        whenUnpaused\r\n    {\r\n        return this._deposit{value: msg.value}(token, amount, msg.sender);\r\n    }\r\n\r\n    function _deposit(\r\n        address token,\r\n        uint256 amount,\r\n        address account\r\n    ) external payable whenUnpaused onlySelf nonSelfLoan {\r\n        IFToken fToken = IFToken(controller.getFTokeAddress(token));\r\n        require(\r\n            controller.marketsContains(address(fToken)),\r\n            \"unsupported token\"\r\n        );\r\n\r\n        bytes memory flog = fToken.mint(account, amount);\r\n        controller.transferIn{value: msg.value}(account, token, amount);\r\n\r\n        fToken.addTotalCash(amount);\r\n\r\n        emit MonitorEvent(\"Deposit\", flog);\r\n    }\r\n\r\n    function borrow(address underlying, uint256 borrowAmount)\r\n        public\r\n        whenUnpaused\r\n        nonSelfLoan\r\n    {\r\n        IFToken fToken = IFToken(controller.getFTokeAddress(underlying));\r\n        require(\r\n            controller.marketsContains(address(fToken)),\r\n            \"unsupported token\"\r\n        );\r\n\r\n        bytes memory flog = fToken.borrow(msg.sender, borrowAmount);\r\n        emit MonitorEvent(\"Borrow\", flog);\r\n    }\r\n\r\n    function withdraw(address underlying, uint256 withdrawTokens)\r\n        public\r\n        whenUnpaused\r\n        nonSelfLoan\r\n        returns (uint256)\r\n    {\r\n        IFToken fToken = IFToken(controller.getFTokeAddress(underlying));\r\n        require(\r\n            controller.marketsContains(address(fToken)),\r\n            \"unsupported token\"\r\n        );\r\n\r\n        (uint256 amount, bytes memory flog) =\r\n            fToken.withdraw(msg.sender, withdrawTokens, 0);\r\n        emit MonitorEvent(\"Withdraw\", flog);\r\n        return amount;\r\n    }\r\n\r\n    function withdrawUnderlying(address underlying, uint256 withdrawAmount)\r\n        public\r\n        whenUnpaused\r\n        nonSelfLoan\r\n        returns (uint256)\r\n    {\r\n        IFToken fToken = IFToken(controller.getFTokeAddress(underlying));\r\n        require(\r\n            controller.marketsContains(address(fToken)),\r\n            \"unsupported token\"\r\n        );\r\n\r\n        (uint256 amount, bytes memory flog) =\r\n            fToken.withdraw(msg.sender, 0, withdrawAmount);\r\n        emit MonitorEvent(\"WithdrawUnderlying\", flog);\r\n        return amount;\r\n    }\r\n\r\n    function repay(address token, uint256 repayAmount)\r\n        public\r\n        payable\r\n        whenUnpaused\r\n        returns (uint256)\r\n    {\r\n        return this._repay{value: msg.value}(token, repayAmount, msg.sender);\r\n    }\r\n\r\n    function _repay(\r\n        address token,\r\n        uint256 repayAmount,\r\n        address account\r\n    ) public payable whenUnpaused onlySelf nonSelfLoan returns (uint256) {\r\n        IFToken fToken = IFToken(controller.getFTokeAddress(token));\r\n        require(\r\n            controller.marketsContains(address(fToken)),\r\n            \"unsupported token\"\r\n        );\r\n\r\n        (uint256 actualRepayAmount, bytes memory flog) =\r\n            fToken.repay(account, repayAmount);\r\n        controller.transferIn{value: msg.value}(\r\n            account,\r\n            token,\r\n            actualRepayAmount\r\n        );\r\n\r\n        fToken.addTotalCash(actualRepayAmount);\r\n\r\n        emit MonitorEvent(\"Repay\", flog);\r\n        return actualRepayAmount;\r\n    }\r\n\r\n    function liquidateBorrow(\r\n        address borrower,\r\n        address underlyingBorrow,\r\n        address underlyingCollateral,\r\n        uint256 repayAmount\r\n    ) public payable whenUnpaused nonSelfLoan {\r\n        require(msg.sender != borrower, \"Liquidator cannot be borrower\");\r\n        require(repayAmount > 0, \"Liquidate amount not valid\");\r\n\r\n        IFToken fTokenBorrow =\r\n            IFToken(controller.getFTokeAddress(underlyingBorrow));\r\n        IFToken fTokenCollateral =\r\n            IFToken(controller.getFTokeAddress(underlyingCollateral));\r\n        bytes memory flog =\r\n            fTokenBorrow.liquidateBorrow(\r\n                msg.sender,\r\n                borrower,\r\n                repayAmount,\r\n                address(fTokenCollateral)\r\n            );\r\n        controller.transferIn{value: msg.value}(\r\n            msg.sender,\r\n            underlyingBorrow,\r\n            repayAmount\r\n        );\r\n\r\n        fTokenBorrow.addTotalCash(repayAmount);\r\n\r\n        emit MonitorEvent(\"LiquidateBorrow\", flog);\r\n    }\r\n\r\n    function tokenIn(address token, uint256 amountIn)\r\n        public\r\n        payable\r\n        whenUnpaused\r\n    {\r\n        IFToken fToken = IFToken(controller.getFTokeAddress(token));\r\n        require(\r\n            controller.marketsContains(address(fToken)),\r\n            \"unsupported token\"\r\n        );\r\n\r\n        cancellingOut(token);\r\n        uint256 curBorrowBalance = fToken.borrowBalanceCurrent(msg.sender);\r\n        uint256 actualRepayAmount;\r\n\r\n        if (amountIn == uint256(-1)) {\r\n            require(curBorrowBalance > 0, \"no debt to repay\");\r\n            if (token != EthAddressLib.ethAddress()) {\r\n                require(\r\n                    msg.value == 0,\r\n                    \"msg.value should be 0 for ERC20 repay\"\r\n                );\r\n                actualRepayAmount = this._repay{value: 0}(\r\n                    token,\r\n                    amountIn,\r\n                    msg.sender\r\n                );\r\n            } else {\r\n                require(\r\n                    msg.value >= curBorrowBalance,\r\n                    \"msg.value need great or equal than current debt\"\r\n                );\r\n                actualRepayAmount = this._repay{value: curBorrowBalance}(\r\n                    token,\r\n                    amountIn,\r\n                    msg.sender\r\n                );\r\n                if (msg.value > actualRepayAmount) {\r\n                    (bool result, ) =\r\n                        msg.sender.call{\r\n                            value: msg.value.sub(actualRepayAmount),\r\n                            gas: controller.transferEthGasCost()\r\n                        }(\"\");\r\n                    require(result, \"Transfer of exceed ETH failed\");\r\n                }\r\n            }\r\n\r\n            emit MonitorEvent(\"TokenIn\", abi.encode(token, actualRepayAmount));\r\n        } else {\r\n            if (curBorrowBalance > 0) {\r\n                uint256 repayEthValue =\r\n                    SafeMath.min(curBorrowBalance, amountIn);\r\n                if (token != EthAddressLib.ethAddress()) {\r\n                    repayEthValue = 0;\r\n                }\r\n                actualRepayAmount = this._repay{value: repayEthValue}(\r\n                    token,\r\n                    SafeMath.min(curBorrowBalance, amountIn),\r\n                    msg.sender\r\n                );\r\n            }\r\n\r\n            if (actualRepayAmount < amountIn) {\r\n                uint256 exceedAmout = SafeMath.sub(amountIn, actualRepayAmount);\r\n                if (token != EthAddressLib.ethAddress()) {\r\n                    exceedAmout = 0;\r\n                }\r\n                this._deposit{value: exceedAmout}(\r\n                    token,\r\n                    SafeMath.sub(amountIn, actualRepayAmount),\r\n                    msg.sender\r\n                );\r\n            }\r\n\r\n            emit MonitorEvent(\"TokenIn\", abi.encode(token, amountIn));\r\n        }\r\n    }\r\n\r\n    function tokenOut(address token, uint256 amountOut) external whenUnpaused {\r\n        IFToken fToken = IFToken(controller.getFTokeAddress(token));\r\n        require(\r\n            controller.marketsContains(address(fToken)),\r\n            \"unsupported token\"\r\n        );\r\n\r\n        cancellingOut(token);\r\n\r\n        uint256 supplyAmount = 0;\r\n        if (amountOut == uint256(-1)) {\r\n            uint256 fBalance = fToken.balanceOf(msg.sender);\r\n            require(fBalance > 0, \"no asset to withdraw\");\r\n            supplyAmount = withdraw(token, fBalance);\r\n\r\n            emit MonitorEvent(\"TokenOut\", abi.encode(token, supplyAmount));\r\n        } else {\r\n            uint256 userSupplyBalance =\r\n                fToken.calcBalanceOfUnderlying(msg.sender);\r\n            if (userSupplyBalance > 0) {\r\n                if (userSupplyBalance < amountOut) {\r\n                    supplyAmount = withdraw(\r\n                        token,\r\n                        fToken.balanceOf(msg.sender)\r\n                    );\r\n                } else {\r\n                    supplyAmount = withdrawUnderlying(token, amountOut);\r\n                }\r\n            }\r\n\r\n            if (supplyAmount < amountOut) {\r\n                borrow(token, amountOut.sub(supplyAmount));\r\n            }\r\n\r\n            emit MonitorEvent(\"TokenOut\", abi.encode(token, amountOut));\r\n        }\r\n    }\r\n\r\n    function cancellingOut(address token) public whenUnpaused nonSelfLoan {\r\n        IFToken fToken = IFToken(controller.getFTokeAddress(token));\r\n        (bool strikeOk, bytes memory strikeLog) =\r\n            fToken.cancellingOut(msg.sender);\r\n        if (strikeOk) {\r\n            emit MonitorEvent(\"CancellingOut\", strikeLog);\r\n        }\r\n    }\r\n\r\n    function flashloan(\r\n        address receiver,\r\n        address token,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) public whenUnpaused nonSelfLoan {\r\n        uint256 balanceBefore = controller.balance(token);\r\n        require(\r\n            amount > 0 && amount <= balanceBefore,\r\n            \"insufficient flashloan liquidity\"\r\n        );\r\n\r\n        uint256 fee = amount.mul(controller.flashloanFeeBips()).div(10000);\r\n        address payable _receiver = address(uint160(receiver));\r\n\r\n        controller.transferFlashloanAsset(token, _receiver, amount);\r\n        IFlashLoanReceiver(_receiver).executeOperation(\r\n            token,\r\n            amount,\r\n            fee,\r\n            params\r\n        );\r\n\r\n        uint256 balanceAfter = controller.balance(token);\r\n        require(\r\n            balanceAfter >= balanceBefore.add(fee),\r\n            \"invalid flashloan payback amount\"\r\n        );\r\n\r\n        address payable vault = address(uint160(controller.flashloanVault()));\r\n        controller.transferFlashloanAsset(token, vault, fee);\r\n\r\n        emit FlashLoan(receiver, token, amount, fee);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FlashLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"funcName\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"MonitorEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"funcName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"MonitorEventCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_repay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"cancellingOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdministration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IBankController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"flashloan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mulSig\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingBorrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingCollateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"liquidateBorrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mulSig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"proposeNewAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pauser\",\"type\":\"address\"}],\"name\":\"setPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setUnpaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"tokenIn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"tokenOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTokens\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Bank","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"petersburg","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f5ac9385e1763a4573a8921868d6b235eb22303882547bf0442dc233db85bd2f"}]}