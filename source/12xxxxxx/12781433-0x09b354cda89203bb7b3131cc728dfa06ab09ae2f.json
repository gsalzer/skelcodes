{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/l1/L1GovernanceRelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n// @unsupported: ovm\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.7.6;\\n\\nimport {OVM_CrossDomainEnabled} from \\\"@eth-optimism/contracts/libraries/bridge/OVM_CrossDomainEnabled.sol\\\";\\n\\nimport \\\"../l2/L2GovernanceRelay.sol\\\";\\n\\n// Relay a message from L1 to L2GovernanceRelay\\n\\ncontract L1GovernanceRelay is OVM_CrossDomainEnabled {\\n    \\n  // --- Auth ---\\n  mapping (address => uint256) public wards;\\n  function rely(address usr) external auth {\\n    wards[usr] = 1;\\n    emit Rely(usr);\\n  }\\n  function deny(address usr) external auth {\\n    wards[usr] = 0;\\n    emit Deny(usr);\\n  }\\n  modifier auth {\\n    require(wards[msg.sender] == 1, \\\"L1GovernanceRelay/not-authorized\\\");\\n    _;\\n  }\\n\\n  address public immutable l2GovernanceRelay;\\n\\n  event Rely(address indexed usr);\\n  event Deny(address indexed usr);\\n\\n  constructor(\\n    address _l2GovernanceRelay,\\n    address _l1messenger \\n  )\\n    OVM_CrossDomainEnabled(_l1messenger)\\n  {\\n    wards[msg.sender] = 1;\\n    emit Rely(msg.sender);\\n\\n    l2GovernanceRelay = _l2GovernanceRelay;\\n  }\\n\\n  // Forward a call to be repeated on L2\\n  function relay(address target, bytes calldata targetData, uint32 l2gas) external auth {\\n    bytes memory data = abi.encodeWithSelector(\\n      L2GovernanceRelay.relay.selector,\\n      target,\\n      targetData\\n    );\\n\\n    sendCrossDomainMessage(\\n      l2GovernanceRelay,\\n      l2gas,\\n      data\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/libraries/bridge/OVM_CrossDomainEnabled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Interface Imports */\\nimport { iOVM_CrossDomainMessenger } from \\\"../../iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title OVM_CrossDomainEnabled\\n * @dev Helper contract for contracts performing cross-domain communications\\n *\\n * Compiler used: defined by inheriting contract\\n * Runtime target: defined by inheriting contract\\n */\\ncontract OVM_CrossDomainEnabled {\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    // Messenger contract used to send and recieve messages from the other domain.\\n    address public messenger;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\\n     */\\n    constructor(\\n        address _messenger\\n    ) {\\n        messenger = _messenger;\\n    }\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Enforces that the modified function is only callable by a specific cross-domain account.\\n     * @param _sourceDomainAccount The only account on the originating domain which is\\n     *  authenticated to call this function.\\n     */\\n    modifier onlyFromCrossDomainAccount(\\n        address _sourceDomainAccount\\n    ) {\\n        require(\\n            msg.sender == address(getCrossDomainMessenger()),\\n            \\\"OVM_XCHAIN: messenger contract unauthenticated\\\"\\n        );\\n\\n        require(\\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\\n            \\\"OVM_XCHAIN: wrong sender of cross-domain message\\\"\\n        );\\n\\n        _;\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\\n     * needs to override.\\n     * @return The address of the cross-domain messenger contract which should be used.\\n     */\\n    function getCrossDomainMessenger()\\n        internal\\n        virtual\\n        returns (\\n            iOVM_CrossDomainMessenger\\n        )\\n    {\\n        return iOVM_CrossDomainMessenger(messenger);\\n    }\\n\\n    /**\\n     * Sends a message to an account on another domain\\n     * @param _crossDomainTarget The intended recipient on the destination domain\\n     * @param _message The data to send to the target (usually calldata to a function with\\n     *  `onlyFromCrossDomainAccount()`)\\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\\n     */\\n    function sendCrossDomainMessage(\\n        address _crossDomainTarget,\\n        uint32 _gasLimit,\\n        bytes memory _message\\n    )\\n        internal\\n    {\\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/l2/L2GovernanceRelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.7.6;\\n\\nimport {OVM_CrossDomainEnabled} from \\\"@eth-optimism/contracts/libraries/bridge/OVM_CrossDomainEnabled.sol\\\";\\n\\n// Receive xchain message from L1 counterpart and execute given spell\\n\\ncontract L2GovernanceRelay is OVM_CrossDomainEnabled {\\n  \\n  address public immutable l1GovernanceRelay;\\n\\n  constructor(\\n    address _l2CrossDomainMessenger,\\n    address _l1GovernanceRelay\\n  )\\n    OVM_CrossDomainEnabled(_l2CrossDomainMessenger)\\n  {\\n    l1GovernanceRelay = _l1GovernanceRelay;\\n  }\\n\\n  /**\\n   * @dev Execute the call from L1.\\n   */\\n  function relay(address target, bytes calldata targetData)\\n    external\\n    onlyFromCrossDomainAccount(l1GovernanceRelay)\\n  {\\n    // Ensure no storage changes in the delegate call\\n    // Target address is trusted so this is mostly to avoid a human error\\n    // Note: we don't check l1GovernanceRelay because it's immutable\\n    address _messenger = messenger;\\n\\n    bool ok;\\n    (ok,) = target.delegatecall(targetData);\\n    require(ok, \\\"L2GovernanceRelay/delegatecall-error\\\");\\n\\n    require(_messenger == messenger, \\\"L2GovernanceRelay/illegal-storage-change\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title iOVM_CrossDomainMessenger\\n */\\ninterface iOVM_CrossDomainMessenger {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event SentMessage(bytes message);\\n    event RelayedMessage(bytes32 msgHash);\\n    event FailedRelayedMessage(bytes32 msgHash);\\n\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l2GovernanceRelay\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l1messenger\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2GovernanceRelay\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"targetData\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"l2gas\",\"type\":\"uint32\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"L1GovernanceRelay","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000010e6593cdda8c58a1d0f14c5164b376352a55f2f00000000000000000000000025ace71c97b33cc4729cf772ae268934f7ab5fa1","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}