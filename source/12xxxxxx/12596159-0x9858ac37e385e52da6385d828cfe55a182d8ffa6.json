{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.0 <0.8.0;\\n\\n/// @title Defines the functions used to interact with a yield source.  The Prize Pool inherits this contract.\\n/// @notice Prize Pools subclasses need to implement this interface so that yield can be generated.\\ninterface IYieldSource {\\n\\n  /// @notice Returns the ERC20 asset token used for deposits.\\n  /// @return The ERC20 asset token\\n  function depositToken() external view returns (address);\\n\\n  /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\\n  /// @return The underlying balance of asset tokens\\n  function balanceOfToken(address addr) external returns (uint256);\\n\\n  /// @notice Supplies tokens to the yield source.  Allows assets to be supplied on other user's behalf using the `to` param.\\n  /// @param amount The amount of `token()` to be supplied\\n  /// @param to The user whose balance will receive the tokens\\n  function supplyTokenTo(uint256 amount, address to) external;\\n\\n  /// @notice Redeems tokens from the yield source.\\n  /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\\n  /// @return The actual amount of tokens that were redeemed.\\n  function redeemToken(uint256 amount) external returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ISushi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\ninterface ISushi {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transferFrom(\\n        address from,\\n        address account,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function transfer(address account, uint256 amount) external returns (bool);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ISushiBar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.6.0 <0.7.0;\\n\\ninterface ISushiBar {\\n    function enter(uint256 _amount) external;\\n\\n    function leave(uint256 _share) external;\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/SushiYieldSource.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.6.12;\\n\\nimport { IYieldSource } from \\\"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./ISushiBar.sol\\\";\\nimport \\\"./ISushi.sol\\\";\\n\\n/// @title A pooltogether yield source for sushi token\\n/// @author Steffel Fenix\\ncontract SushiYieldSource is IYieldSource {\\n    \\n    using SafeMath for uint256;\\n    \\n    ISushiBar public immutable sushiBar;\\n    ISushi public immutable sushiAddr;\\n    \\n    mapping(address => uint256) public balances;\\n\\n    constructor(ISushiBar _sushiBar, ISushi _sushiAddr) public {\\n        sushiBar = _sushiBar;\\n        sushiAddr = _sushiAddr;\\n    }\\n\\n    /// @notice Returns the ERC20 asset token used for deposits.\\n    /// @return The ERC20 asset token\\n    function depositToken() public view override returns (address) {\\n        return address(sushiAddr);\\n    }\\n\\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\\n    /// @return The underlying balance of asset tokens\\n    function balanceOfToken(address addr) public override returns (uint256) {\\n        if (balances[addr] == 0) return 0;\\n\\n        uint256 totalShares = sushiBar.totalSupply();\\n        uint256 barSushiBalance = sushiAddr.balanceOf(address(sushiBar));\\n\\n        return balances[addr].mul(barSushiBalance).div(totalShares);       \\n    }\\n\\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\\n    /// @param amount The amount of `token()` to be supplied\\n    /// @param to The user whose balance will receive the tokens\\n    function supplyTokenTo(uint256 amount, address to) public override {\\n        sushiAddr.transferFrom(msg.sender, address(this), amount);\\n        sushiAddr.approve(address(sushiBar), amount);\\n\\n        ISushiBar bar = sushiBar;\\n        uint256 beforeBalance = bar.balanceOf(address(this));\\n        \\n        bar.enter(amount);\\n        \\n        uint256 afterBalance = bar.balanceOf(address(this));\\n        uint256 balanceDiff = afterBalance.sub(beforeBalance);\\n        \\n        balances[to] = balances[to].add(balanceDiff);\\n    }\\n\\n    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.\\n    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\\n    /// @dev The maxiumum that can be called for token() is calculated by balanceOfToken() above.\\n    /// @return The actual amount of tokens that were redeemed. This may be different from the amount passed due to the fractional math involved. \\n    function redeemToken(uint256 amount) public override returns (uint256) {\\n        ISushiBar bar = sushiBar;\\n        ISushi sushi = sushiAddr;\\n\\n        uint256 totalShares = bar.totalSupply();\\n        if(totalShares == 0) return 0; \\n\\n        uint256 barSushiBalance = sushi.balanceOf(address(bar));\\n        if(barSushiBalance == 0) return 0;\\n\\n        uint256 sushiBeforeBalance = sushi.balanceOf(address(this));\\n\\n        uint256 requiredShares = ((amount.mul(totalShares) + totalShares)).div(barSushiBalance);\\n        if(requiredShares == 0) return 0;\\n        \\n        uint256 requiredSharesBalance = requiredShares.sub(1);\\n        bar.leave(requiredSharesBalance);\\n\\n        uint256 sushiAfterBalance = sushi.balanceOf(address(this));\\n        \\n        uint256 sushiBalanceDiff = sushiAfterBalance.sub(sushiBeforeBalance);\\n\\n        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);\\n        sushi.transfer(msg.sender, sushiBalanceDiff);\\n        \\n        return (sushiBalanceDiff);\\n    }\\n\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ISushiBar\",\"name\":\"_sushiBar\",\"type\":\"address\"},{\"internalType\":\"contract ISushi\",\"name\":\"_sushiAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeemToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"supplyTokenTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiAddr\",\"outputs\":[{\"internalType\":\"contract ISushi\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiBar\",\"outputs\":[{\"internalType\":\"contract ISushiBar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SushiYieldSource","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008798249c2e607446efb7ad49ec89dd1865ff42720000000000000000000000006b3595068778dd592e39a122f4f5a5cf09c90fe2","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}