{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.0.11 https://hardhat.org\r\n\r\n// File contracts/interfaces/IStrategy.sol\r\n\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IStrategy {\r\n    /// @notice Send the assets to the Strategy and call skim to invest them.\r\n    /// @param amount The amount of tokens to invest.\r\n    function skim(uint256 amount) external;\r\n\r\n    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\r\n    /// @param balance The amount of tokens the caller thinks it has invested.\r\n    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\r\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\r\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\r\n\r\n    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\r\n    /// @dev The `actualAmount` should be very close to the amount.\r\n    /// The difference should NOT be used to report a loss. That's what harvest is for.\r\n    /// @param amount The requested amount the caller wants to withdraw.\r\n    /// @return actualAmount The real amount that is withdrawn.\r\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\r\n\r\n    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.\r\n    /// @param balance The amount of tokens the caller thinks it has invested.\r\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\r\n    function exit(uint256 balance) external returns (int256 amountAdded);\r\n}\r\n\r\n\r\n// File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.0\r\n\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\r\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\r\n// Edited by BoringCrypto\r\n\r\ncontract BoringOwnableData {\r\n    address public owner;\r\n    address public pendingOwner;\r\n}\r\n\r\ncontract BoringOwnable is BoringOwnableData {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice `owner` defaults to msg.sender on construction.\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\r\n    /// Can only be invoked by the current `owner`.\r\n    /// @param newOwner Address of the new owner.\r\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\r\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\r\n    function transferOwnership(\r\n        address newOwner,\r\n        bool direct,\r\n        bool renounce\r\n    ) public onlyOwner {\r\n        if (direct) {\r\n            // Checks\r\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\r\n\r\n            // Effects\r\n            emit OwnershipTransferred(owner, newOwner);\r\n            owner = newOwner;\r\n            pendingOwner = address(0);\r\n        } else {\r\n            // Effects\r\n            pendingOwner = newOwner;\r\n        }\r\n    }\r\n\r\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\r\n    function claimOwnership() public {\r\n        address _pendingOwner = pendingOwner;\r\n\r\n        // Checks\r\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\r\n\r\n        // Effects\r\n        emit OwnershipTransferred(owner, _pendingOwner);\r\n        owner = _pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /// @notice Only allows the `owner` to execute the function.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0\r\n\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n\r\n    function to64(uint256 a) internal pure returns (uint64 c) {\r\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\r\n        c = uint64(a);\r\n    }\r\n\r\n    function to32(uint256 a) internal pure returns (uint32 c) {\r\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\r\n        c = uint32(a);\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\r\nlibrary BoringMath128 {\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\r\nlibrary BoringMath64 {\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\r\nlibrary BoringMath32 {\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0\r\n\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0\r\n\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\nlibrary BoringERC20 {\r\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\r\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\r\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\r\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\r\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\r\n\r\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length >= 64) {\r\n            return abi.decode(data, (string));\r\n        } else if (data.length == 32) {\r\n            uint8 i = 0;\r\n            while(i < 32 && data[i] != 0) {\r\n                i++;\r\n            }\r\n            bytes memory bytesArray = new bytes(i);\r\n            for (i = 0; i < 32 && data[i] != 0; i++) {\r\n                bytesArray[i] = data[i];\r\n            }\r\n            return string(bytesArray);\r\n        } else {\r\n            return \"???\";\r\n        }\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (string) Token symbol.\r\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\r\n        return success ? returnDataToString(data) : \"???\";\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (string) Token name.\r\n    function safeName(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\r\n        return success ? returnDataToString(data) : \"???\";\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (uint8) Token decimals.\r\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param from Transfer tokens from.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/strategies/CompoundStrategy.sol\r\n\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n// solhint-disable avoid-low-level-calls\r\n// solhint-disable not-rely-on-time\r\n// solhint-disable no-empty-blocks\r\n// solhint-disable avoid-tx-origin\r\n\r\ninterface IFactory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IPair {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IcToken is IERC20 {\r\n    function mint(uint256 mintAmount) external returns (uint256);\r\n\r\n    function redeem(uint256 redeemTokens) external returns (uint256);\r\n\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n    function balanceOfUnderlying(address account) external returns (uint256);\r\n}\r\n\r\ncontract CompoundStrategy is IStrategy, BoringOwnable {\r\n    using BoringMath for uint256;\r\n    using BoringERC20 for IERC20;\r\n    using BoringERC20 for IcToken;\r\n\r\n    address public immutable bentobox;\r\n    IERC20 public immutable token;\r\n    IcToken public immutable cToken;\r\n    IERC20 public immutable compToken;\r\n    IERC20 public immutable weth;\r\n    IFactory public immutable factory;\r\n    bool public exited;\r\n\r\n    constructor(\r\n        address bentobox_,\r\n        IFactory factory_,\r\n        IERC20 token_,\r\n        IcToken cToken_,\r\n        IERC20 compToken_,\r\n        IERC20 weth_\r\n    ) public {\r\n        bentobox = bentobox_;\r\n        factory = factory_;\r\n        token = token_;\r\n        cToken = cToken_;\r\n        compToken = compToken_;\r\n        weth = weth_;\r\n\r\n        token_.approve(address(cToken_), type(uint256).max);\r\n    }\r\n\r\n    modifier onlyBentobox {\r\n        // Only the bentobox can call harvest on this strategy\r\n        require(msg.sender == bentobox, \"CompoundStrategy: only bento\");\r\n        require(!exited, \"CompoundStrategy: exited\");\r\n        _;\r\n    }\r\n\r\n    function _swapAll(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        address to\r\n    ) internal returns (uint256 amountOut) {\r\n        IPair pair = IPair(factory.getPair(address(fromToken), address(toToken)));\r\n        require(address(pair) != address(0), \"CompoundStrategy: Cannot convert\");\r\n\r\n        uint256 amountIn = fromToken.balanceOf(address(this));\r\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        IERC20(fromToken).safeTransfer(address(pair), amountIn);\r\n        if (fromToken < toToken) {\r\n            amountOut = amountIn.mul(997).mul(reserve1) / reserve0.mul(1000).add(amountInWithFee);\r\n            pair.swap(0, amountOut, to, new bytes(0));\r\n        } else {\r\n            amountOut = amountIn.mul(997).mul(reserve0) / reserve1.mul(1000).add(amountInWithFee);\r\n            pair.swap(amountOut, 0, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    // Send the assets to the Strategy and call skim to invest them\r\n    /// @inheritdoc IStrategy\r\n    function skim(uint256 amount) external override onlyBentobox {\r\n        require(cToken.mint(amount) == 0, \"CompoundStrategy: mint error\");\r\n    }\r\n\r\n    // Harvest any profits made converted to the asset and pass them to the caller\r\n    /// @inheritdoc IStrategy\r\n    function harvest(uint256 balance, address sender) external override onlyBentobox returns (int256 amountAdded) {\r\n        // To prevent anyone from using flash loans to 'steal' part of the profits, only EOA is allowed to call harvest\r\n        require(sender == tx.origin, \"CompoundStrategy: EOA only\");\r\n        // Get the amount of tokens that the cTokens currently represent\r\n        uint256 tokenBalance = cToken.balanceOfUnderlying(address(this));\r\n        // Convert enough cToken to take out the profit\r\n        // If the amount is negative due to rounding (near impossible), just revert. Should be positive soon enough.\r\n        require(cToken.redeemUnderlying(tokenBalance.sub(balance)) == 0, \"CompoundStrategy: profit fail\");\r\n\r\n        // Find out how much has been added (+ sitting on the contract from harvestCOMP)\r\n        uint256 amountAdded_ = token.balanceOf(address(this));\r\n        // Transfer the profit to the bentobox, the amountAdded at this point matches the amount transferred\r\n        token.safeTransfer(bentobox, amountAdded_);\r\n\r\n        return int256(amountAdded_);\r\n    }\r\n\r\n    function harvestCOMP(uint256 minAmount) public onlyOwner {\r\n        // To prevent flash loan sandwich attacks to 'steal' the profit, only the owner can harvest the COMP\r\n        // Swap all COMP to WETH\r\n        _swapAll(compToken, weth, address(this));\r\n        // Swap all WETH to token and leave it on the contract to be swept up in the next harvest\r\n        require(_swapAll(weth, token, address(this)) >= minAmount, \"CompoundStrategy: not enough\");\r\n    }\r\n\r\n    // Withdraw assets.\r\n    /// @inheritdoc IStrategy\r\n    function withdraw(uint256 amount) external override onlyBentobox returns (uint256 actualAmount) {\r\n        // Convert enough cToken to take out 'amount' tokens\r\n        require(cToken.redeemUnderlying(amount) == 0, \"CompoundStrategy: redeem fail\");\r\n\r\n        // Make sure we send and report the exact same amount of tokens by using balanceOf\r\n        actualAmount = token.balanceOf(address(this));\r\n        token.safeTransfer(bentobox, actualAmount);\r\n    }\r\n\r\n    // Withdraw all assets in the safest way possible. This shouldn't fail.\r\n    /// @inheritdoc IStrategy\r\n    function exit(uint256 balance) external override onlyBentobox returns (int256 amountAdded) {\r\n        // Get the amount of tokens that the cTokens currently represent\r\n        uint256 tokenBalance = cToken.balanceOfUnderlying(address(this));\r\n        // Get the actual token balance of the cToken contract\r\n        uint256 available = token.balanceOf(address(cToken));\r\n\r\n        // Check that the cToken contract has enough balance to pay out in full\r\n        if (tokenBalance <= available) {\r\n            // If there are more tokens available than our full position, take all based on cToken balance (continue if unsuccesful)\r\n            try cToken.redeem(cToken.balanceOf(address(this))) {} catch {}\r\n        } else {\r\n            // Otherwise redeem all available and take a loss on the missing amount (continue if unsuccesful)\r\n            try cToken.redeemUnderlying(available) {} catch {}\r\n        }\r\n\r\n        // Check balance of token on the contract\r\n        uint256 amount = token.balanceOf(address(this));\r\n        // Calculate tokens added (or lost)\r\n        amountAdded = int256(amount) - int256(balance);\r\n        // Transfer all tokens to bentobox\r\n        token.safeTransfer(bentobox, amount);\r\n        // Flag as exited, allowing the owner to manually deal with any amounts available later\r\n        exited = true;\r\n    }\r\n\r\n    function afterExit(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) public onlyOwner returns (bool success) {\r\n        // After exited, the owner can perform ANY call. This is to rescue any funds that didn't get released during exit or\r\n        // got earned afterwards due to vesting or airdrops, etc.\r\n        require(exited, \"CompoundStrategy: Not exited\");\r\n        (success, ) = to.call{value: value}(data);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bentobox_\",\"type\":\"address\"},{\"internalType\":\"contract IFactory\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"contract IcToken\",\"name\":\"cToken_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"compToken_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"weth_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"afterExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bentobox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"internalType\":\"contract IcToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"exit\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"amountAdded\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"harvest\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"amountAdded\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"harvestCOMP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"actualAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CompoundStrategy","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f5bce5077908a1b7370b9ae04adc565ebd643966000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac0000000000000000000000000d8775f648430679a709e98d2b0cb6250d2887ef0000000000000000000000006c8c6b02e7b2be14d4fa6022dfd6d75921d90e4e000000000000000000000000c00e94cb662c3520282e6f5717214004a7f26888000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fba71288910f734cf1da8df09e436943eb37bf7bee29e1ce101bb5e45a11df89"}]}