{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: TBD\r\npragma solidity =0.7.4;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface ICoinSwapERC20 is IERC20 {\r\n    event Swap(address indexed,uint192,uint192,address indexed); \r\n    event Sync(uint);\r\n    event Mint(address indexed sender, uint192);\r\n    event Burn(address indexed sender, uint192, address indexed to);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n\r\ninterface ICoinSwapCallee {\r\n    function coinswapCall(address sender, uint amount0,uint amount1, bytes calldata data) external;\r\n}\r\n\r\ncontract CoinSwapERC20 is ICoinSwapERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public constant override name = 'CoinSwap V1';\r\n    string public constant override symbol = 'CSWPLT';//CoinSwap Liquidity Token\r\n    uint8 public constant override decimals = 18;\r\n    uint  public override totalSupply;\r\n    mapping(address => uint) public override balanceOf;\r\n    mapping(address => mapping(address => uint)) public override allowance;\r\n\r\n    bytes32 public override DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public override nonces;\r\n\r\n    constructor() {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\r\n        require(deadline >= block.timestamp, 'CSWP:01');\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'CSWP:02');\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n\r\n\r\ncontract CoinSwapPair is CoinSwapERC20  {\r\n    using SafeMath for uint;\r\n    \r\n    address public  patron;\r\n    address public  factory;\r\n    address public  token0; // token0 < token1\r\n    address public  token1;\r\n    uint224 private reserve; //reserve0(96) | reserve1(96) | blockTimestampLast(32)\r\n    uint private unlocked = 1;\r\n    uint public  priceCumulative; //=Delta_y/Delta_x: 96-fractional bits; allows overflow\r\n    uint224 private circleData;\r\n  \r\n    modifier lock() {\r\n        require(unlocked == 1, 'CSWP:1');\r\n    \tunlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    \r\n    constructor() {factory = msg.sender; patron=tx.origin;}\r\n    function initialize(address _token0, address _token1, uint224 circle) external  {\r\n        //circle needs to in order of token0<token1\r\n        require(circleData == 0, 'CSWP:2');\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n        circleData = circle;  // validity of circle should be checked by CoinSwapFactory\r\n    }\r\n\r\n    function ICO(uint224 _circleData)  external  {\r\n        require( (tx.origin==patron) && (circleData >> 216) >0, 'CSWP:3');//to close ICO, set (circleData >> 216) = 0x00\r\n        circleData = _circleData;\r\n    }\r\n\r\n    function setPatron(address _patron)  external  {\r\n        require( (tx.origin==patron), 'CSWP:11');\r\n        patron = _patron;\r\n    }\r\n    \r\n    function getReserves() public  view returns (uint224 _reserve, uint224 _circleData) {\r\n        _reserve = reserve;\r\n        _circleData = circleData;\r\n    }\r\n    \r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'CSWP:6');\r\n    }\r\n\r\n    function revisemu(uint192 balance) private returns (uint56 _mu) {\r\n        require(balance>0, 'CSWP:4');\r\n    \tuint224 _circleData = circleData;\r\n        uint X = uint(balance>>96) *      uint16(_circleData >> 72)* uint56(_circleData >> 160);\r\n        uint Y = uint(uint96(balance)) *  uint16(_circleData >> 56)* uint56(_circleData >> 104);\r\n        uint XpY =  X + Y;\r\n        uint X2pY2 = (X*X) + (Y*Y);\r\n       \tX = XpY*100;\r\n       \tY = (X*X)  + X2pY2 * (10000+ uint16(_circleData>>88));\r\n        uint Z= X2pY2 * 20000;\r\n    \trequire(Y>Z, 'CSWP:5');\r\n        Y = SQRT.sqrt(Y-Z); \r\n        Z = Y > X ? X + Y : X-Y;\r\n        _mu =  uint56(1)+uint56(((10**32)*Z) / X2pY2);\r\n        circleData = (_circleData & 0xFF_FFFFFFFFFFFFFF_FFFFFFFFFFFFFF_FFFF_FFFF_FFFF_00000000000000) | uint224(_mu);\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _update(uint balance) private {\r\n\t    uint32 lastTime = uint32(balance);\t\r\n        uint32 deltaTime = uint32(block.timestamp) -lastTime ;\r\n        if (deltaTime>0 && lastTime>0) {\r\n    \t    uint circle = circleData;\r\n            uint lambda0 = uint16(circle >> 72);\r\n            uint lambda1 = uint16(circle >> 56);\r\n\t        uint CmulambdaX = 10**34 - (balance>>128)     *lambda0*uint56(circle)*uint56(circle >> 160);\r\n            uint CmulambdaY = 10**34 - uint96(balance>>32)*lambda1*uint56(circle)*uint56(circle >> 104); \r\n\t        priceCumulative += (((lambda0*CmulambdaX)<< 96)/(lambda1*CmulambdaY)) * deltaTime;  \r\n        }\r\n        reserve = uint224(balance +deltaTime);\r\n        emit Sync(balance>>32);\r\n    }\r\n\r\n    function _mintFee(uint56 mu0) private returns (uint56 mu) {\r\n        address feeTo = CoinSwapFactory(factory).feeTo();\r\n        mu=revisemu(uint192(reserve>>32));\r\n        if (mu0>mu) _mint(feeTo, totalSupply.mul(uint(mu0-mu)) / (5*mu0+mu));\r\n    }\r\n\r\n    function mint(address to) external  lock returns (uint liquidity) {\r\n        uint224 circle = circleData;\r\n        uint _totalSupply = totalSupply; \r\n        uint224 _reserve = reserve;\r\n        uint96 reserve0 = uint96(_reserve >>128);\r\n        uint96 reserve1 = uint96(_reserve >>32);\r\n        uint balance0 = IERC20(token0).balanceOf(address(this));\r\n        uint balance1 = IERC20(token1).balanceOf(address(this));\r\n        uint scaledBalance0 = balance0* uint56(circle >> 160);\r\n        uint scaledBalance1 = balance1* uint56(circle >> 104);\r\n        require((scaledBalance0< 2**96) && (scaledBalance1< 2**96) \r\n            && ( scaledBalance0 >=10**16 || scaledBalance1 >=10**16), 'CSWP:7');\r\n        if (_totalSupply == 0) { \r\n            uint lambda0 = uint16(circle >> 72);\r\n            uint lambda1 = uint16(circle >> 56);\r\n            liquidity = (scaledBalance0 * lambda0 + scaledBalance1 * lambda1) >> 1;\r\n    \t    revisemu(uint192((balance0<<96)|balance1));\r\n        } else { \r\n            uint56 mu0=_mintFee(uint56(circle));\r\n            _totalSupply = totalSupply;\r\n    \t    (uint mu, uint _totalS)=(0,0);\r\n\t        if (reserve0==0) {\r\n\t            mu=(uint(mu0) * reserve1) / balance1;\r\n\t            _totalS =  _totalSupply.mul(balance1)/reserve1;\r\n\t        } else if (reserve1==0) {\r\n\t            mu=(uint(mu0) * reserve0) / balance0;\r\n\t            _totalS = _totalSupply.mul(balance0)/reserve0;\r\n\t        } else {\r\n\t            (mu, _totalS) = (balance0 * reserve1) < (balance1 * reserve0)?\r\n\t\t        ((uint(mu0) * reserve0) / balance0, _totalSupply.mul(balance0)/reserve0) :\r\n\t\t        ((uint(mu0) * reserve1) / balance1, _totalSupply.mul(balance1)/reserve1) ;\r\n\t        }\r\n            liquidity = _totalS - _totalSupply;\r\n            circleData = (circle & 0xFF_FFFFFFFFFFFFFF_FFFFFFFFFFFFFF_FFFF_FFFF_FFFF_00000000000000) | uint224(mu);\r\n        }\r\n        _mint(to, liquidity);\r\n        _update(balance0<<128 | balance1<<32 | uint32(_reserve));\r\n        emit Mint(msg.sender, uint192((balance0-reserve0)<<96 | (balance1-reserve1)));\r\n    }\r\n\r\n    function burn(address to) external  lock returns (uint192 amount) {\r\n        uint224 _reserve = reserve;\r\n        address _token0 = token0;                                \r\n        address _token1 = token1;    \r\n        _mintFee(uint56(circleData));\r\n        uint _totalSupply = totalSupply; \r\n        uint liquidity = balanceOf[address(this)];\r\n        uint amount0 = liquidity.mul(uint96(_reserve>>128)) / _totalSupply; \r\n        uint amount1 = liquidity.mul(uint96(_reserve>>32)) / _totalSupply; \r\n        amount = uint192((amount0<<96)|amount1);\r\n        require(amount > 0, 'CSWP:8');\r\n        _burn(address(this), liquidity);\r\n        _safeTransfer(_token0, to, amount0);\r\n        _safeTransfer(_token1, to, amount1);\r\n        uint192 combinedBalance = uint192(IERC20(_token0).balanceOf(address(this))<<96 | IERC20(_token1).balanceOf(address(this)));\r\n        _update(uint(combinedBalance)<<32 | uint32(_reserve));\r\n        if (combinedBalance>0) revisemu(combinedBalance);\r\n        emit Burn(msg.sender, amount, to); \r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function swap(uint amountOut, address to, bytes calldata data) external  lock {       \r\n        uint amount0Out = (amountOut >> 96); \r\n        uint amount1Out = uint(uint96(amountOut));\r\n        uint balance0;\r\n        uint balance1;\r\n        uint _circleData = circleData;\r\n\r\n        { // avoids stack too deep errors\r\n            address _token0 = token0;\r\n            address _token1 = token1;\r\n            require((to != _token0) && (to != _token1), 'CSWP:9');\r\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);\r\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);\r\n            if (data.length > 0) ICoinSwapCallee(to).coinswapCall(msg.sender, amount0Out, amount1Out, data);\r\n            balance0 = IERC20(_token0).balanceOf(address(this));\r\n            balance1 = IERC20(_token1).balanceOf(address(this));\r\n            require(balance0*uint56(_circleData >> 160) < 2**96 \r\n                 && balance1*uint56(_circleData >> 104) < 2**96, 'CSWP:10');\r\n        }\r\n        uint amountIn0;\r\n        uint amountIn1;\r\n        uint224 _reserve = reserve;\r\n        {// if _reserve0 < amountOut, then should have been reverted above already, so no need to check here \r\n            uint96 reserve0 = uint96(_reserve >>128);\r\n            uint96 reserve1 = uint96(_reserve >>32);\r\n            amountIn0 = balance0 + amount0Out - reserve0;\r\n            amountIn1 = balance1 + amount1Out - reserve1;\r\n            uint mulambda0 = uint(uint16(_circleData >> 72))*uint56(_circleData)*uint56(_circleData >> 160);\r\n            uint mulambda1 = uint(uint16(_circleData >> 56))*uint56(_circleData)*uint56(_circleData >> 104);        \r\n            uint X=mulambda0*(balance0*1000 - amountIn0*3); \r\n            uint Y=mulambda1*(balance1*1000 - amountIn1*3);\r\n    \t    require(10**37 > X && 10**37 >Y, 'CSWP:11');\r\n            X = 10**37-X;\r\n            Y = 10**37-Y;\r\n            uint newrSquare = X*X+Y*Y;\r\n            X=10**37-(mulambda0 * reserve0*1000);\r\n            Y=10**37-(mulambda1 * reserve1*1000);\r\n            require(newrSquare<= (X*X+Y*Y), 'CSWP:12');\r\n        }\r\n        _update(balance0<<128 | balance1<<32 | uint32(_reserve));\r\n        emit Swap(msg.sender, uint192(amountIn0<<96 | amountIn1), uint192(amountOut), to);\r\n    }\r\n}\r\n\r\ncontract CoinSwapFactory {\r\n    address payable public feeTo;\r\n    address payable public feeToSetter;\r\n    mapping(address => mapping(address => address)) public getPair;\r\n    address[] public allPairs;\r\n\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    constructor(address payable _feeToSetter) {\r\n        feeToSetter = _feeToSetter;\r\n        feeTo = _feeToSetter;\r\n    }\r\n    \r\n    function allPairsLength() external view returns (uint) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    function createPair(address tokenA, address tokenB, uint224 circle) external returns (address pair) {  \r\n        require(tx.origin==feeToSetter, 'CSWP:22');\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(getPair[token0][token1] == address(0), 'CSWP:20'); \r\n        require(uint16(circle>>56)>0 && uint16(circle>>72)>0 && \r\n                uint16(circle>>88)>0 && uint16(circle>>88)<=9999\r\n                && uint56(circle>>104)>=1 && uint56(circle>>104)<=10**16\r\n                && uint56(circle>>160)>=1 && uint56(circle>>160)<=10**16, 'CSWP:23');\r\n        bytes memory bytecode = type(CoinSwapPair).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n        assembly {\r\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        CoinSwapPair(pair).initialize(token0, token1, circle);\r\n        getPair[token0][token1] = pair;\r\n        getPair[token1][token0] = pair; \r\n        allPairs.push(pair);\r\n        emit PairCreated(token0, token1, pair, allPairs.length);\r\n    }\r\n    \r\n    function setFeeTo(address payable _feeTo) external {\r\n\t    require(msg.sender == feeToSetter, 'CSWP:21');\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    function setFeeToSetter(address payable _feeToSetter) external {\r\n        require(msg.sender == feeToSetter, 'CSWP:22');\r\n        feeToSetter = _feeToSetter;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\n\r\nlibrary SQRT {\r\n    function sqrt(uint256 a) internal pure returns (uint256 x) { \r\n        if (a > 3) {\r\n            uint msbpos =0;\r\n            uint b=a;\r\n            if (b > 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\r\n                msbpos += 128;\r\n                b = b >> 128;\r\n            } \r\n            if (b > 0xFFFFFFFFFFFFFFFF) {\r\n                msbpos += 64;\r\n                b = b>>64;\r\n            }\r\n            if (b > 0xFFFFFFFF ) {\r\n                msbpos += 32;\r\n                b = b>>32;\r\n            }\r\n            if (b > 0xFFFF ) {\r\n                msbpos += 16;\r\n                b = b>>16;\r\n            }\r\n            if (b > 0xFF ) {\r\n                msbpos += 8;\r\n                b = b>>8;\r\n            }\r\n            if (b > 0xF ) {\r\n                msbpos += 4;\r\n            }\r\n            msbpos += 4;\r\n            \r\n            uint256 x0=a;\r\n            uint X=((a >> 1) + 1);\r\n            uint Y=2**(msbpos/2);\r\n            x = X< Y ? X : Y;\r\n            while (x < x0 ) {\r\n                x0 = x;\r\n                x = (a / x0 + x0) >> 1;\r\n            }\r\n        } else if (a != 0) {\r\n            x = 1;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint224\",\"name\":\"circle\",\"type\":\"uint224\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeToSetter\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CoinSwapFactory","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"00000000000000000000000003ae62fd5e08fa57682a73d2fb1259525cd7b324","EVMVersion":"istanbul","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://64db487cb806c8182b55046b8957e2e7485c04bbdead622645f5d6199435e4c3"}]}