{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\n\n\n// Part: IERC1155\n\ninterface IERC1155 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external;\n}\n\n// Part: IEulerBeats\n\ninterface IEulerBeats {\n\n    /**\n     * @dev Function to mint prints from an existing seed. Msg.value must be sufficient.\n     * @param seed The NFT id to mint print of\n     * @param _owner The current on-chain owner of the seed\n     */\n    function mintPrint(uint256 seed, address payable _owner)\n        external\n        payable\n        returns (uint256);\n\n    /**\n     * @dev Get the number of prints minted for the corresponding seed\n     * @param seed The seed/original NFT token id\n     */\n    function seedToPrintsSupply(uint256 seed)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Function to get print price\n     * @param printNumber the print number of the print Ex. if there are 2 existing prints, and you want to get the\n     * next print price, then this should be 3 as you are getting the price to mint the 3rd print\n     */\n    function getPrintPrice(uint256 printNumber) external pure returns (uint256 price);\n\n    function seedToOwner(uint256 seed) external view returns (address owner);\n\n    /**\n     * @dev The token id for the prints contains the seed/original NFT id\n     * @param seed The seed/original NFT token id\n     */\n    function getPrintTokenIdFromSeed(uint256 seed) external pure returns (uint256);\n}\n\n// File: EulerBeatsMarket.sol\n\nlibrary EulerBeatsMarket {\n\n    address public constant EULERBEATS = 0x8754F54074400CE745a7CEddC928FB1b7E985eD6;\n    address public constant PRINTINGPRESS = 0x8Cac485c30641ece09dBeB2b5245E24dE4830F27;\n\n    function buyAssetsForEth(bytes memory data, address recipient) public {\n        uint256[] memory seeds;\n        (seeds) = abi.decode(\n            data,\n            (uint256[])\n        );\n        \n        for (uint256 i = 0; i < seeds.length; i++) {\n            _buyAssetFromMarket(seeds[i], estimateAssetPriceInEth(seeds[i]), recipient);\n        }\n    }\n\n    function estimateAssetPriceInEth(uint256 seed) public view returns(uint256) {\n        // Get price to mint the next print\n        return IEulerBeats(EULERBEATS).getPrintPrice(IEulerBeats(EULERBEATS).seedToPrintsSupply(seed) + 1);\n    }\n\n    function estimateBatchAssetPriceInEth(bytes memory data) public view returns(uint256 totalCost) {\n        uint256[] memory seeds;\n        (seeds) = abi.decode(\n            data,\n            (uint256[])\n        );\n        for (uint256 i = 0; i < seeds.length; i++) {\n            totalCost += IEulerBeats(EULERBEATS).getPrintPrice(IEulerBeats(EULERBEATS).seedToPrintsSupply(seeds[i]) + 1);\n        }\n    }\n\n    function _buyAssetFromMarket(uint256 _seed, uint256 _price, address _recipient) internal {\n        bytes memory _data = abi.encodeWithSelector(IEulerBeats(PRINTINGPRESS).mintPrint.selector, _seed, IEulerBeats(EULERBEATS).seedToOwner(_seed));\n\n        (bool success, ) = PRINTINGPRESS.call{value:_price}(_data);\n        require(success, \"_buyAssetFromMarket: EulerBeats buy failed.\");\n\n        IERC1155(EULERBEATS).safeTransferFrom(address(this), _recipient, IEulerBeats(EULERBEATS).getPrintTokenIdFromSeed(_seed), 1, \"\");\n    }\n}\n","ABI":"[{\"inputs\":[],\"name\":\"EULERBEATS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRINTINGPRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"estimateAssetPriceInEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"estimateBatchAssetPriceInEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EulerBeatsMarket","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}