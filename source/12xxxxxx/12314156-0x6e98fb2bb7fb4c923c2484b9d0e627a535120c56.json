{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at FtmScan.com on 2021-04-26\r\n*/\r\n\r\n/**\r\n * Basic trigonometry functions\r\n *\r\n * Solidity library offering the functionality of basic trigonometry functions\r\n * with both input and output being integer approximated.\r\n *\r\n * This is useful since:\r\n * - At the moment no floating/fixed point math can happen in solidity\r\n * - Should be (?) cheaper than the actual operations using floating point\r\n *   if and when they are implemented.\r\n *\r\n * The implementation is based off Dave Dribin's trigint C library\r\n * http://www.dribin.org/dave/trigint/\r\n * Which in turn is based from a now deleted article which can be found in\r\n * the internet wayback machine:\r\n * http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html\r\n *\r\n * @author Lefteris Karapetsas\r\n * @license BSD3\r\n */\r\n\r\npragma solidity ^0.4.17;\r\n\r\nlibrary Trigonometry {\r\n\r\n    // Table index into the trigonometric table\r\n    uint constant INDEX_WIDTH = 4;\r\n    // Interpolation between successive entries in the tables\r\n    uint constant INTERP_WIDTH = 8;\r\n    uint constant INDEX_OFFSET = 12 - INDEX_WIDTH;\r\n    uint constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;\r\n    uint16 constant ANGLES_IN_CYCLE = 16384;\r\n    uint16 constant QUADRANT_HIGH_MASK = 8192;\r\n    uint16 constant QUADRANT_LOW_MASK = 4096;\r\n    uint constant SINE_TABLE_SIZE = 16;\r\n\r\n    // constant sine lookup table generated by gen_tables.py\r\n    // We have no other choice but this since constant arrays don't yet exist\r\n    uint8 constant entry_bytes = 2;\r\n    bytes constant sin_table = \"\\x00\\x00\\x0c\\x8c\\x18\\xf9\\x25\\x28\\x30\\xfb\\x3c\\x56\\x47\\x1c\\x51\\x33\\x5a\\x82\\x62\\xf1\\x6a\\x6d\\x70\\xe2\\x76\\x41\\x7a\\x7c\\x7d\\x89\\x7f\\x61\\x7f\\xff\";\r\n\r\n    /**\r\n     * Convenience function to apply a mask on an integer to extract a certain\r\n     * number of bits. Using exponents since solidity still does not support\r\n     * shifting.\r\n     *\r\n     * @param _value The integer whose bits we want to get\r\n     * @param _width The width of the bits (in bits) we want to extract\r\n     * @param _offset The offset of the bits (in bits) we want to extract\r\n     * @return An integer containing _width bits of _value starting at the\r\n     *         _offset bit\r\n     */\r\n    function bits(uint _value, uint _width, uint _offset) pure internal returns (uint) {\r\n        return (_value / (2 ** _offset)) & (((2 ** _width)) - 1);\r\n    }\r\n\r\n    function sin_table_lookup(uint index) pure internal returns (uint16) {\r\n        bytes memory table = sin_table;\r\n        uint offset = (index + 1) * entry_bytes;\r\n        uint16 trigint_value;\r\n        assembly {\r\n            trigint_value := mload(add(table, offset))\r\n        }\r\n\r\n        return trigint_value;\r\n    }\r\n\r\n    /**\r\n     * Return the sine of an integer approximated angle as a signed 16-bit\r\n     * integer.\r\n     *\r\n     * @param _angle A 14-bit angle. This divides the circle into 16384\r\n     *               angle units, instead of the standard 360 degrees.\r\n     * @return The sine result as a number in the range -32767 to 32767.\r\n     */\r\n    function sin(uint16 _angle) public pure returns (int) {\r\n        uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET);\r\n        uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET);\r\n\r\n        bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0;\r\n        bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;\r\n\r\n        if (!is_odd_quadrant) {\r\n            index = SINE_TABLE_SIZE - 1 - index;\r\n        }\r\n\r\n        uint x1 = sin_table_lookup(index);\r\n        uint x2 = sin_table_lookup(index + 1);\r\n        uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH);\r\n\r\n        int sine;\r\n        if (is_odd_quadrant) {\r\n            sine = int(x1) + int(approximation);\r\n        } else {\r\n            sine = int(x2) - int(approximation);\r\n        }\r\n\r\n        if (is_negative_quadrant) {\r\n            sine *= -1;\r\n        }\r\n\r\n        return sine;\r\n    }\r\n\r\n    /**\r\n     * Return the cos of an integer approximated angle.\r\n     * It functions just like the sin() method but uses the trigonometric\r\n     * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.\r\n     */\r\n    function cos(uint16 _angle) public pure returns (int) {\r\n        if (_angle > ANGLES_IN_CYCLE - QUADRANT_LOW_MASK) {\r\n            _angle = QUADRANT_LOW_MASK - ANGLES_IN_CYCLE - _angle;\r\n        } else {\r\n            _angle += QUADRANT_LOW_MASK;\r\n        }\r\n        return sin(_angle);\r\n    }\r\n\r\n}\r\n\r\n// SPDX-License-Identifier: APACHE OR MIT\r\n\r\npragma solidity ^0.4.17;\r\n\r\n/*\r\n    This library is intended to give Ethereum developers access to spatial functions to calculate\r\n    geometric values and topologicial relationships on the EVM. It is a translation of Turf.js,\r\n    a geospatial analysis library in Javascript. http://turfjs.org/\r\n    Code first developed by John IV (@johnx25bd, Founder at Astral) at ETHParis 2019.\r\n*/\r\n\r\nlibrary Spatial {\r\n        /*\r\n        Trigonemtric functions\r\n        */\r\n        function sinDegrees (uint256 _degrees) public pure returns (int256) {\r\n            uint256 degrees = _degrees % 360;\r\n            uint16 angle16bit = uint16((degrees * 16384) / 360);\r\n            return Trigonometry.sin(angle16bit);\r\n        }\r\n\r\n        function sinNanodegrees (uint256 _nanodegrees) public pure returns (int256) {\r\n            return sinDegrees(_nanodegrees / 10 ** 9 );\r\n        }\r\n\r\n        function cosDegrees (uint256 _degrees) public pure returns (int256) {\r\n            uint256 degrees = _degrees % 360;\r\n            uint16 angle16bit = uint16((degrees * 16384) / 360);\r\n            return Trigonometry.cos(angle16bit);\r\n        }\r\n\r\n        function cosNanodegrees (uint256 _nanodegrees) public pure returns (int256) {\r\n            return cosDegrees(_nanodegrees / 10 ** 9 );\r\n        }\r\n\r\n        // Babylonian method of finding square root,\r\n        // From https://ethereum.stackexchange.com/questions/2910/can-i-square-root-in-solidity\r\n        function sqrt (int256 _x) public pure returns (uint256 y_) {\r\n            if (_x < 0) {\r\n                _x = _x * -1;\r\n            }\r\n\r\n            uint256 x = uint256(_x);\r\n\r\n            uint256 z = (x + 1) / 2;\r\n            y_ = x;\r\n            while (z < y_) {\r\n                y_ = z;\r\n                z = (x / z + z) / 2;\r\n            }\r\n        }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_angle\",\"type\":\"uint16\"}],\"name\":\"cos\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_angle\",\"type\":\"uint16\"}],\"name\":\"sin\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Trigonometry","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3f9f14b37a1fa9924ab900b09906d4e894c0d28af3c1c64c7a056fb7122d327b"}]}