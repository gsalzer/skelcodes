{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MultipriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol';\\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\\nimport '@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol';\\n\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IChainlink.sol';\\nimport './interfaces/IUniswapV2.sol';\\nimport './interfaces/IUniswapV3.sol';\\n\\nimport './libraries/Math.sol';\\nimport './libraries/SafeCast.sol';\\nimport './libraries/SafeMath.sol';\\nimport './libraries/UniswapV2Library.sol';\\n\\n/// @title Multiprice oracle sourcing asset prices from multiple on-chain sources\\ncontract MultipriceOracle {\\n    using SafeCast for uint256;\\n    using SafeMath for uint256;\\n\\n    IChainLinkFeedsRegistry public immutable chainLinkRegistry;\\n    address public immutable uniswapV3Factory;\\n    uint24 public immutable uniswapV3PoolFee;\\n    IUniswapV3CrossPoolOracle public immutable uniswapV3Oracle;\\n    IUniswapV2Factory public immutable uniswapV2Factory;\\n    IUniswapV2Factory public immutable sushiswapFactory;\\n    address public immutable weth;\\n\\n    mapping(address => bool) public isUsdEquivalent;\\n\\n    uint256 private constant WEI_UNIT = 10**18;\\n\\n    constructor(\\n        IChainLinkFeedsRegistry _chainLinkRegistry,\\n        address _uniswapV3Factory,\\n        uint24 _uniswapV3PoolFee,\\n        IUniswapV3CrossPoolOracle _uniswapV3Oracle,\\n        IUniswapV2Factory _uniswapV2Factory,\\n        IUniswapV2Factory _sushiswapFactory,\\n        address _weth,\\n        address[] memory _usdEquivalents\\n    ) {\\n        chainLinkRegistry = _chainLinkRegistry;\\n        uniswapV3Factory = _uniswapV3Factory;\\n        uniswapV3PoolFee = _uniswapV3PoolFee;\\n        uniswapV3Oracle = _uniswapV3Oracle;\\n        uniswapV2Factory = _uniswapV2Factory;\\n        sushiswapFactory = _sushiswapFactory;\\n        weth = _weth;\\n\\n        for (uint256 ii = 0; ii < _usdEquivalents.length; ++ii) {\\n            isUsdEquivalent[_usdEquivalents[ii]] = true;\\n        }\\n    }\\n\\n    function assetToAsset(\\n        address _tokenIn,\\n        uint256 _amountIn,\\n        address _tokenOut,\\n        uint256 _clPriceBuffer,\\n        uint32 _uniswapV3TwapPeriod,\\n        uint8 _inclusionBitmap\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 value,\\n            uint256 cl,\\n            uint256 clBuf,\\n            uint256 uniV3Twap,\\n            uint256 uniV3Spot,\\n            uint256 uniV2Spot,\\n            uint256 sushiSpot\\n        )\\n    {\\n        // Inclusion bitmap only considers five lowest bits\\n        require(uint256(_inclusionBitmap) < 1 << 5, 'Inclusion bitmap invalid');\\n\\n        cl = chainLinkAssetToAsset(_tokenIn, _amountIn, _tokenOut);\\n        clBuf = cl.mul(WEI_UNIT.sub(_clPriceBuffer)).div(WEI_UNIT);\\n        uniV3Twap = uniV3TwapAssetToAsset(_tokenIn, _amountIn, _tokenOut, _uniswapV3TwapPeriod);\\n        uniV3Spot = uniV3SpotAssetToAsset(_tokenIn, _amountIn, _tokenOut);\\n        uniV2Spot = uniV2SpotAssetToAsset(uniswapV2Factory, _tokenIn, _amountIn, _tokenOut);\\n        sushiSpot = uniV2SpotAssetToAsset(sushiswapFactory, _tokenIn, _amountIn, _tokenOut);\\n\\n        uint256[5] memory inclusions = [clBuf, uniV3Twap, uniV3Spot, uniV2Spot, sushiSpot];\\n        for (uint256 ii = 0; _inclusionBitmap > 0; ) {\\n            if (_inclusionBitmap % 2 > 0) {\\n                value = value > 0 ? Math.min(value, inclusions[ii]) : inclusions[ii];\\n            }\\n\\n            // Loop bookkeeping\\n            ++ii;\\n            _inclusionBitmap >>= 1;\\n        }\\n    }\\n\\n    /********************\\n     * Chainlink quotes *\\n     ********************/\\n    function chainLinkAssetToAsset(\\n        address _tokenIn,\\n        uint256 _amountIn,\\n        address _tokenOut\\n    ) public view returns (uint256 amountOut) {\\n        int256 inDecimals = uint256(IERC20(_tokenIn).decimals()).toInt256();\\n        int256 outDecimals = uint256(IERC20(_tokenOut).decimals()).toInt256();\\n\\n        if (isUsdEquivalent[_tokenOut]) {\\n            uint256 rate = chainLinkRegistry.getPriceUSD(_tokenIn);\\n\\n            // Rate is 0 if the token's feed is not registered\\n            if (rate > 0) {\\n                // Adjust decimals for output amount in tokenOut's decimals\\n                // Rates for usd queries are in 8 decimals\\n                int256 eFactor = outDecimals - inDecimals - 8;\\n                return _adjustDecimals(_amountIn.mul(rate), eFactor);\\n            }\\n        }\\n\\n        if (_tokenOut == weth) {\\n            uint256 rate = chainLinkRegistry.getPriceETH(_tokenIn);\\n\\n            // Rate is 0 if the token's feed is not registered\\n            if (rate > 0) {\\n                // Adjust decimals for output amount in wei\\n                // Rates for eth queries are in 18 decimals but are cancelled out by wei's 18\\n                // decimals, leaving just the in decimals to be adjusted for\\n                int256 eFactor = -inDecimals;\\n                return _adjustDecimals(_amountIn.mul(rate), eFactor);\\n            }\\n        }\\n\\n        // Try our best to go between two chainlink feeds\\n        // Messy but tippy-toeing around stack too deeps\\n        // All four cases covered (token1 price <> token2 price):\\n        //   1. usd<>usd\\n        //   2. usd<>eth\\n        //   3. eth<>eth\\n        //   4. eth<>usd\\n\\n        uint256 inUsdRate = chainLinkRegistry.getPriceUSD(_tokenIn);\\n        uint256 outUsdRate = chainLinkRegistry.getPriceUSD(_tokenOut);\\n        if (inUsdRate > 0 && outUsdRate > 0) {\\n            // usd<>usd; both tokens priced in usd terms\\n            int256 eFactor = outDecimals - inDecimals;\\n            return _adjustDecimals(_amountIn.mul(inUsdRate).div(outUsdRate), eFactor);\\n        }\\n\\n        uint256 inEthRate = chainLinkRegistry.getPriceETH(_tokenIn);\\n        uint256 outEthRate = chainLinkRegistry.getPriceETH(_tokenOut);\\n        if (inEthRate > 0 && outEthRate > 0) {\\n            // eth<>eth; both tokens priced in eth terms\\n            int256 eFactor = outDecimals - inDecimals;\\n            return _adjustDecimals(_amountIn.mul(inEthRate).div(outEthRate), eFactor);\\n        }\\n\\n        uint256 ethUsdRate = chainLinkRegistry.getPriceUSD(weth);\\n        if (inUsdRate > 0 && outEthRate > 0) {\\n            // usd<>eth; convert via amount in -> usd -> eth -> amount out:\\n            //   amountIn (usd) = amountIn * tokenIn usd rate\\n            //   amountOut (eth) = amountIn (usd) / eth usd rate\\n            //   amountOut = amountOut (eth) / tokenOut eth rate\\n            // Adjust for e-factor first to avoid losing precision from large divisions\\n            // Usd rates cancel each other, leaving just the 18 decimals from the eth rate and token decimals\\n            int256 eFactor = outDecimals - inDecimals + 18;\\n            uint256 adjustedInUsdValue = _adjustDecimals(_amountIn.mul(inUsdRate), eFactor);\\n            return adjustedInUsdValue.div(ethUsdRate).div(outEthRate);\\n        }\\n\\n        if (inEthRate > 0 && outUsdRate > 0) {\\n            // eth<>usd; convert via amount in -> eth -> usd -> amount out:\\n            //   amountIn (eth) = amountIn * tokenIn eth rate\\n            //   amountOut (usd) = amountIn (eth) * eth usd rate\\n            //   amountOut = amountOut (usd) / tokenOut usd rate\\n            uint256 unadjustedInUsdValue = _amountIn.mul(inEthRate).mul(ethUsdRate);\\n            uint256 unadjustedOutAmount = unadjustedInUsdValue.div(outUsdRate); // split div to avoid stack too deep\\n            // Usd rates cancel each other, leaving just the 18 decimals from the eth rate and token decimals\\n            int256 eFactor = outDecimals - inDecimals - 18;\\n            return _adjustDecimals(unadjustedOutAmount, eFactor);\\n        }\\n\\n        revert('ChainLink rate not available');\\n    }\\n\\n    function _adjustDecimals(uint256 _amount, int256 _eFactor) internal pure returns (uint256) {\\n        if (_eFactor < 0) {\\n            uint256 tenToE = 10**uint256(-_eFactor);\\n            return _amount.div(tenToE);\\n        } else {\\n            uint256 tenToE = 10**uint256(_eFactor);\\n            return _amount.mul(tenToE);\\n        }\\n    }\\n\\n    /*************************\\n     * UniswapV3 TWAP quotes *\\n     *************************/\\n    function uniV3TwapAssetToAsset(\\n        address _tokenIn,\\n        uint256 _amountIn,\\n        address _tokenOut,\\n        uint32 _twapPeriod\\n    ) public view returns (uint256 amountOut) {\\n        return uniswapV3Oracle.assetToAsset(_tokenIn, _amountIn, _tokenOut, _twapPeriod);\\n    }\\n\\n    /*************************\\n     * UniswapV3 spot quotes *\\n     *************************/\\n    function uniV3SpotAssetToAsset(\\n        address _tokenIn,\\n        uint256 _amountIn,\\n        address _tokenOut\\n    ) public view returns (uint256 amountOut) {\\n        if (_tokenIn == weth) {\\n            return _uniV3SpotPrice(weth, _amountIn, _tokenOut);\\n        } else if (_tokenOut == weth) {\\n            return _uniV3SpotPrice(_tokenIn, _amountIn, weth);\\n        } else {\\n            uint256 ethAmount = _uniV3SpotPrice(_tokenIn, _amountIn, weth);\\n            return _uniV3SpotPrice(weth, ethAmount, _tokenOut);\\n        }\\n    }\\n\\n    function _uniV3SpotPrice(\\n        address _tokenIn,\\n        uint256 _amountIn,\\n        address _tokenOut\\n    ) internal view returns (uint256 amountOut) {\\n        address pool =\\n            PoolAddress.computeAddress(uniswapV3Factory, PoolAddress.getPoolKey(_tokenIn, _tokenOut, uniswapV3PoolFee));\\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3PoolState(pool).slot0();\\n\\n        // 160 + 160 - 64 = 256; 96 + 96 - 64 = 128\\n        uint256 priceX128 = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, 1 << 64);\\n\\n        // Pool prices base/quote with lowerToken/higherToken, so adjust for inputs\\n        return\\n            _tokenIn < _tokenOut\\n                ? FullMath.mulDiv(priceX128, _amountIn, 1 << 128)\\n                : FullMath.mulDiv(1 << 128, _amountIn, priceX128);\\n    }\\n\\n    /***********************************\\n     * UniswapV2/Sushiswap spot quotes *\\n     ***********************************/\\n    function uniV2SpotAssetToAsset(\\n        IUniswapV2Factory _factory,\\n        address _tokenIn,\\n        uint256 _amountIn,\\n        address _tokenOut\\n    ) public view returns (uint256 amountOut) {\\n        if (_tokenIn == weth) {\\n            return _uniV2SpotEthToAsset(_factory, _amountIn, _tokenOut);\\n        } else if (_tokenOut == weth) {\\n            return _uniV2SpotAssetToEth(_factory, _tokenIn, _amountIn);\\n        } else {\\n            uint256 ethAmount = _uniV2SpotAssetToEth(_factory, _tokenIn, _amountIn);\\n            return _uniV2SpotEthToAsset(_factory, ethAmount, _tokenOut);\\n        }\\n    }\\n\\n    function _uniV2SpotAssetToEth(\\n        IUniswapV2Factory _factory,\\n        address _tokenIn,\\n        uint256 _amountIn\\n    ) internal view returns (uint256 ethAmountOut) {\\n        address pair = _factory.getPair(_tokenIn, weth);\\n        (uint256 tokenInReserve, uint256 ethReserve) = UniswapV2Library.getReserves(pair, _tokenIn, weth);\\n        // No slippage--just spot pricing based on current reserves\\n        return UniswapV2Library.quote(_amountIn, tokenInReserve, ethReserve);\\n    }\\n\\n    function _uniV2SpotEthToAsset(\\n        IUniswapV2Factory _factory,\\n        uint256 _ethAmountIn,\\n        address _tokenOut\\n    ) internal view returns (uint256 amountOut) {\\n        address pair = _factory.getPair(weth, _tokenOut);\\n        (uint256 ethReserve, uint256 tokenOutReserve) = UniswapV2Library.getReserves(pair, weth, _tokenOut);\\n        // No slippage--just spot pricing based on current reserves\\n        return UniswapV2Library.quote(_ethAmountIn, ethReserve, tokenOutReserve);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that can change\\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\\n/// per transaction\\ninterface IUniswapV3PoolState {\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n    /// when accessed externally.\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n    /// boundary.\\n    /// observationIndex The index of the last oracle observation that was written,\\n    /// observationCardinality The current maximum number of observations stored in the pool,\\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n    /// feeProtocol The protocol fee for both tokens of the pool.\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n    /// unlocked Whether the pool is currently locked to reentrancy\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\\n    /// @dev Protocol fees will never exceed uint128 max in either token\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice The currently in range liquidity available to the pool\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice Look up information about a specific tick in the pool\\n    /// @param tick The tick to look up\\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\\n    /// tick upper,\\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\\n    /// a specific position.\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside0X128,\\n            uint256 feeGrowthOutside1X128,\\n            int56 tickCumulativeOutside,\\n            uint160 secondsPerLiquidityOutsideX128,\\n            uint32 secondsOutside,\\n            bool initialized\\n        );\\n\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    /// @notice Returns the information about a position by the position's key\\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\\n    /// @return _liquidity The amount of liquidity in the position,\\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\\n    function positions(bytes32 key)\\n        external\\n        view\\n        returns (\\n            uint128 _liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    /// @notice Returns data about a specific observation index\\n    /// @param index The element of the observations array to fetch\\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n    /// ago, rather than at a specific index in the array.\\n    /// @return blockTimestamp The timestamp of the observation,\\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\\n    function observations(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint32 blockTimestamp,\\n            int56 tickCumulative,\\n            uint160 secondsPerLiquidityCumulativeX128,\\n            bool initialized\\n        );\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = -denominator & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\\nlibrary PoolAddress {\\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\\n\\n    /// @notice The identifying key of the pool\\n    struct PoolKey {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n    }\\n\\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\\n    /// @param tokenA The first token of a pool, unsorted\\n    /// @param tokenB The second token of a pool, unsorted\\n    /// @param fee The fee level of the pool\\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\\n    function getPoolKey(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) internal pure returns (PoolKey memory) {\\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\\n    }\\n\\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\\n    /// @param factory The Uniswap V3 factory contract address\\n    /// @param key The PoolKey\\n    /// @return pool The contract address of the V3 pool\\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\\n        require(key.token0 < key.token1);\\n        pool = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex'ff',\\n                        factory,\\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\\n                        POOL_INIT_CODE_HASH\\n                    )\\n                )\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n// See https://etherscan.io/address/0x271bf4568fb737cc2e6277e9B1EE0034098cDA2a#code\\ninterface IChainLinkFeedsRegistry {\\n    function getPriceETH(address tokenIn) external view returns (uint256);\\n\\n    function getPriceUSD(address tokenIn) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.7.6;\\n\\n// See https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Factory.sol\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function migrator() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n    function setMigrator(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n// See https://github.com/sohkai/uniswap-v3-cross-pool-oracle\\ninterface IUniswapV3CrossPoolOracle {\\n    function assetToAsset(\\n        address tokenIn,\\n        uint256 amountIn,\\n        address tokenOut,\\n        uint32 twapPeriod\\n    ) external view returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity =0.7.6;\\n\\nlibrary Math {\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity =0.7.6;\\n\\n// See https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/SafeCast.sol\\nlibrary SafeCast {\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y < 2**255);\\n        z = int256(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.7.6;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n// Forked from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol\\n// Modified getReserves() to accept a pair rather than factory and updates to the internal SafeMath that's not pegged to solc 0.6.6\\n// Sushiswap's factory uses a different init code than UniswapV2's, and so it's more reliable to\\n// grab the pair's address from the factory than to calculate it\\nlibrary UniswapV2Library {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address pair, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pair).getReserves();\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IChainLinkFeedsRegistry\",\"name\":\"_chainLinkRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapV3Factory\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_uniswapV3PoolFee\",\"type\":\"uint24\"},{\"internalType\":\"contract IUniswapV3CrossPoolOracle\",\"name\":\"_uniswapV3Oracle\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"_uniswapV2Factory\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"_sushiswapFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_usdEquivalents\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_clPriceBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_uniswapV3TwapPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_inclusionBitmap\",\"type\":\"uint8\"}],\"name\":\"assetToAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"clBuf\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uniV3Twap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uniV3Spot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uniV2Spot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sushiSpot\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"name\":\"chainLinkAssetToAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainLinkRegistry\",\"outputs\":[{\"internalType\":\"contract IChainLinkFeedsRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUsdEquivalent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiswapFactory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"name\":\"uniV2SpotAssetToAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"name\":\"uniV3SpotAssetToAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_twapPeriod\",\"type\":\"uint32\"}],\"name\":\"uniV3TwapAssetToAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Factory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV3Factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV3Oracle\",\"outputs\":[{\"internalType\":\"contract IUniswapV3CrossPoolOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV3PoolFee\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MultipriceOracle","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000271bf4568fb737cc2e6277e9b1ee0034098cda2a0000000000000000000000001f98431c8ad98523631ae4a59f267346ea31f9840000000000000000000000000000000000000000000000000000000000000bb80000000000000000000000000f1f5a87f99f0918e6c81f16e59f3518698221ff0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}