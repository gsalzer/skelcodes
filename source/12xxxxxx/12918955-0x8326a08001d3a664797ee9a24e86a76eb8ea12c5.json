{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/universe/facets/FuckYousMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.0;\\n\\nimport { EternalLib } from \\\"../lib/EternalLib.sol\\\";\\nimport { AssembleLib } from \\\"../lib/AssembleLib.sol\\\";\\nimport { GenotypeLib } from \\\"../lib/GenotypeLib.sol\\\";\\nimport { MutationLib } from \\\"../lib/MutationLib.sol\\\";\\n\\n\\ncontract FuckYousMetadata {\\n\\n\\t// figure out what season using the tokenId\\n\\tfunction getSeasonal(uint tokenId) public view returns (EternalLib.Seasonal memory) {\\n\\t\\tEternalLib.EternalStorage storage s = EternalLib.eternalStorage();\\n\\n\\t\\tfor (uint i = 0; i < s.seasonals.length; i++) {\\n\\t\\t\\tif (tokenId < s.seasonals[i].boundary) {\\n\\t\\t\\t\\treturn s.seasonals[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.seasonals[0];\\n\\t}\\n\\n\\t// this is the external function FuckYous calls\\n\\tfunction getGraphics(uint tokenId)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (string memory)\\n\\t{\\n\\t\\tEternalLib.enforceTokenExists(tokenId);\\n\\n\\t\\tEternalLib.Seasonal memory seasonal = getSeasonal(tokenId);\\n\\n\\t\\treturn getGraphics(tokenId, seasonal.template);\\n\\t}\\n\\n\\tfunction getGraphics(uint tokenId, bytes16 _template)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (string memory)\\n\\t{\\n\\t\\tEternalLib.EternalStorage storage s = EternalLib.eternalStorage();\\n\\t\\tEternalLib.Template storage t = s.templates[_template];\\n\\t\\tMutationLib.MutationStorage storage m = MutationLib.mutationStorage();\\n\\n\\t\\t// check for template override\\n\\t\\tbytes16 _tm = m.mutationTemplate[tokenId];\\n\\n\\t\\tif (_tm != '') {\\n\\t\\t\\treturn AssembleLib.assembleSequence(tokenId, _tm, s.templates[_tm].graphics);\\n\\t\\t}\\n\\n\\t\\treturn AssembleLib.assembleSequence(tokenId, _template, t.graphics);\\n\\t}\\n\\n\\t// this is the external function FuckYous calls\\n\\tfunction getMetadata(uint tokenId)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (string memory)\\n\\t{\\n\\t\\tEternalLib.enforceTokenExists(tokenId);\\n\\n\\t\\tEternalLib.Seasonal memory seasonal = getSeasonal(tokenId);\\n\\n\\t\\treturn getMetadata(tokenId, seasonal.template);\\n\\t}\\n\\n\\tfunction getMetadata(uint tokenId, bytes16 _template)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (string memory)\\n\\t{\\n\\t\\tEternalLib.EternalStorage storage s = EternalLib.eternalStorage();\\n\\t\\tEternalLib.Template storage t = s.templates[_template];\\n\\t\\tMutationLib.MutationStorage storage m = MutationLib.mutationStorage();\\n\\t\\t\\n\\t\\tbytes16[] memory fenotype = GenotypeLib.deriveFenotype(tokenId, _template);\\n\\n\\t\\t// check for template override\\n\\t\\tbytes16 _tm = m.mutationTemplate[tokenId];\\n\\t\\tif (_tm != '') {\\n\\t\\t\\treturn AssembleLib.assembleSequence(tokenId, _tm, s.templates[_tm].metadata, fenotype);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn AssembleLib.assembleSequence(tokenId, _template, t.metadata, fenotype);\\n\\t}\\n\\n}\"\r\n    },\r\n    \"contracts/universe/lib/EternalLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.0;\\n\\nimport { IFuckYous } from \\\"./interfaces/IFuckYous.sol\\\";\\n\\nlibrary EternalLib {\\n\\n\\tbytes32 constant ETERNAL_STORAGE_POSITION = keccak256('wtf.fuckyous.eternal.storage');\\n\\n\\tstruct EternalStorage {\\n\\t\\tmapping(bytes16 => string) variables;\\n\\t\\tmapping(bytes16 => bytes16[]) sequences;\\n\\t\\tmapping(bytes16 => bytes16[]) genotypes;\\n\\t\\tmapping(bytes16 => Template) templates;\\n\\t\\tSeasonal[] seasonals;\\n\\t\\taddress fuckyous;\\n\\t}\\n\\n\\tstruct Template {\\n\\t\\tbytes16 key;\\n\\t\\tbytes16 name; // title of the NFT\\n\\t\\tbytes16 text; // text around the circle\\n\\t\\tbytes16 desc; // description of the NFT (text under image)\\n\\n\\t\\tbytes16 seedhash; // seed the randomness\\n\\t\\tbytes16 genotype; // which attributes are selected\\n\\t\\tbytes16 graphics; // how to assemble the SVG\\n\\t\\tbytes16 metadata; // how to assemble the JSON\\n\\t}\\n\\n\\tstruct Seasonal {\\n\\t\\tbytes16 template;\\n\\t\\tuint boundary;\\n\\t}\\n\\n\\tfunction eternalStorage() internal pure returns (EternalStorage storage es) {\\n\\t\\tbytes32 position = ETERNAL_STORAGE_POSITION;\\n\\t\\tassembly {\\n\\t\\t\\tes.slot := position\\n\\t\\t}\\n\\t}\\n\\n\\tfunction addVariable(bytes16 key, string memory val) internal {\\n\\t\\tEternalStorage storage s = eternalStorage();\\n\\t\\ts.variables[key] = val;\\n\\t}\\n\\n\\tfunction addVariables(bytes16[] memory keys, string[] memory vals) internal {\\n\\t\\tEternalStorage storage s = eternalStorage();\\n\\t\\tfor (uint i; i < keys.length; i++) {\\n\\t\\t\\ts.variables[keys[i]] = vals[i];\\n\\t\\t}\\n\\t}\\n\\n\\tfunction addSequence(bytes16 key, bytes16[] memory vals) internal {\\n\\t\\tEternalStorage storage s = eternalStorage();\\n\\t\\ts.sequences[key] = vals;\\n\\t}\\n\\n\\t// TODO: plural version?\\n\\n\\tfunction addGenotype(bytes16 key, bytes16[] memory vals) internal {\\n\\t\\tEternalStorage storage s = eternalStorage();\\n\\t\\ts.genotypes[key] = vals;\\n\\t}\\n\\n\\tfunction addTemplate(\\n\\t\\tbytes16 _key,\\n\\t\\tbytes16 _name,\\n\\t\\tbytes16 _text,\\n\\t\\tbytes16 _desc,\\n\\t\\tbytes16 _seedhash,\\n\\t\\tbytes16 _genotype,\\n\\t\\tbytes16 _graphics,\\n\\t\\tbytes16 _metadata\\n\\t) internal {\\n\\t\\tEternalStorage storage s = eternalStorage();\\n\\t\\tTemplate memory template = Template({\\n\\t\\t\\tkey: _key,\\n\\t\\t\\tname: _name,\\n\\t\\t\\ttext: _text,\\n\\t\\t\\tdesc: _desc,\\n\\t\\t\\tseedhash: _seedhash,\\n\\t\\t\\tgenotype: _genotype,\\n\\t\\t\\tgraphics: _graphics,\\n\\t\\t\\tmetadata: _metadata\\n\\t\\t});\\n\\n\\t\\ts.templates[_key] = template;\\n\\t}\\n\\n\\tfunction addSeasonal(bytes16 _template, uint _boundary) internal {\\n\\t\\tEternalStorage storage s = eternalStorage();\\n\\t\\tSeasonal memory seasonal = Seasonal({\\n\\t\\t\\ttemplate: _template,\\n\\t\\t\\tboundary: _boundary\\n\\t\\t});\\n\\n\\t\\ts.seasonals.push(seasonal);\\n\\t}\\n\\n\\tfunction setFuckYousAddress(address _address) internal {\\n\\t\\tEternalStorage storage s = eternalStorage();\\n\\t\\ts.fuckyous = _address;\\n\\t}\\n\\n\\tfunction enforceTokenExists(uint tokenId) internal view {\\n\\t\\trequire(\\n\\t\\t\\tIFuckYous(eternalStorage().fuckyous).ownerOf(tokenId) != address(0),\\n\\t\\t\\t'OOPS: non-existent token'\\n\\t\\t);\\n\\t}\\n\\n\\tfunction enforceIsTokenOwner(uint tokenId) internal view {\\n\\t\\trequire(\\n\\t\\t\\tmsg.sender == IFuckYous(eternalStorage().fuckyous).ownerOf(tokenId),\\n\\t\\t\\t'OOPS: you are not the owner of this token.'\\n\\t\\t);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/universe/lib/AssembleLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport 'base64-sol/base64.sol';\\n\\nimport { EternalLib } from \\\"./EternalLib.sol\\\";\\nimport { GenotypeLib } from \\\"./GenotypeLib.sol\\\";\\nimport { MutationLib } from \\\"./MutationLib.sol\\\";\\n\\n\\n\\nlibrary AssembleLib {\\n\\tusing Strings for uint256;\\n\\n\\t// assembly\\n\\n\\tfunction assembleSequence(\\n\\t\\tuint tokenId,\\n\\t\\tbytes16 _template,\\n\\t\\tbytes16 _sequence\\n\\t)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (string memory)\\n\\t{\\n\\t\\tbytes16[] memory fenotype = GenotypeLib.deriveFenotype(tokenId, _template);\\n\\n\\t\\treturn assembleSequence(tokenId, _template, _sequence, fenotype);\\n\\t}\\n\\n\\tfunction assembleSequence(\\n\\t\\tuint tokenId,\\n\\t\\tbytes16 _template,\\n\\t\\tbytes16 _sequence,\\n\\t\\tbytes16[] memory fenotype\\n\\t)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (string memory)\\n\\t{\\n\\t\\tEternalLib.EternalStorage storage s = EternalLib.eternalStorage();\\n\\t\\tbytes16[] memory sequence = s.sequences[_sequence];\\n\\t\\t\\n\\t\\treturn assembleSequence(tokenId, _template, sequence, fenotype);\\n\\t}\\n\\n\\tfunction assembleSequence(\\n\\t\\tuint tokenId,\\n\\t\\tbytes16 _template,\\n\\t\\tbytes16[] memory sequence,\\n\\t\\tbytes16[] memory fenotype\\n\\t)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (string memory)\\n\\t{\\n\\t\\tEternalLib.EternalStorage storage s = EternalLib.eternalStorage();\\n\\t\\tEternalLib.Template storage t = s.templates[_template];\\n\\n\\t\\tstring memory acc;\\n\\n\\t\\t// acc = join(acc, 'FENOTYPE_START');\\n\\t\\t\\n\\t\\t// for (uint i = 0; i < fenotype.length; i++) {\\n\\t\\t// \\tacc = join(acc, bytes16ToString(fenotype[i]));\\n\\t\\t// }\\n\\n\\t\\t// acc = join(acc, 'FENOTYPE_END');\\n\\t\\t\\n\\t\\tuint fi; // fenotype index\\n\\t\\tuint fv; // fenotype value index\\n\\n\\t\\t/*\\n\\t\\tReference: (tokens starting with)\\n\\t\\t\\t[a-z] → just the trait\\n\\t\\t\\t_ → build token variable\\n\\t\\t\\t# → trait variable\\n\\t\\t\\t@ → color variable\\n\\t\\t\\t$ → build order\\n\\t\\t\\t~ → build master\\n\\t\\t\\t^ → get from master\\n\\t\\t*/\\n\\n\\t\\t/*\\n\\t\\tThis long & convoluted loop does these things:\\n\\t\\t\\t1. replace '_token_id' with the actual token id\\n\\t\\t\\t2. format the trait \\\"name\\\" (ex: \\\"sad\\\") for the JSON attributes array\\n\\t\\t\\t3. insert the trait \\\"value\\\" (ex: \\\"<g id=\\\"mouth-sad\\\" />) for the SVG\\n\\t\\t\\t4. check for any overides \\n\\t\\t\\t5. recursively assembles any nested build orders\\n\\t\\t\\t6. joins build orders & encodes into base64\\n\\t\\t\\t7. accumulates the build tokens values\\n\\t\\t*/\\n\\n\\t\\tfor (uint i; i < sequence.length; i++) {\\n\\t\\t\\tif (sequence[i] == bytes16('_token_id')) {\\n\\t\\t\\t\\t// 1. replace '_token_id' with the actual token id\\n\\t\\t\\t\\tacc = join(acc, tokenId.toString());\\n\\t\\t\\t} else if (sequence[i] == bytes16('_trait_val')) {\\n\\t\\t\\t\\t// 2. format the trait \\\"name\\\" (ex: \\\"sad\\\") for the JSON attributes array\\n\\t\\t\\t\\tbytes16 _fv = replaceFirstByte(fenotype[fv], '%');\\n\\t\\t\\t\\tacc = join(acc, s.variables[_fv]);\\n\\t\\t\\t\\tfv++;\\n\\t\\t\\t} else if (sequence[i][0] == '#') {\\n\\t\\t\\t\\t// 3. insert the trait \\\"value\\\" (ex: \\\"<G id=\\\"mouth-sad\\\" />\\\") for the SVG\\n\\t\\t\\t\\tacc = join(acc, s.variables[fenotype[fi]]);\\n\\t\\t\\t\\tfi++;\\n\\t\\t\\t} else if (sequence[i][0] == '$') {\\n\\t\\t\\t\\t// 4. recursively assemble any nested build sequences\\n\\t\\t\\t\\tacc = join(acc, assembleSequence(tokenId, _template, sequence[i], fenotype));\\n\\t\\t\\t} else if (sequence[i][0] == '^') {\\n\\t\\t\\t\\t// 5. check for any overides\\n\\t\\t\\t\\tMutationLib.MutationStorage storage m = MutationLib.mutationStorage();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (sequence[i] == bytes16('^name')) {\\n\\t\\t\\t\\t\\tif (abi.encodePacked(m.mutationName[tokenId]).length > 0) {\\n\\t\\t\\t\\t\\t\\tacc = join(acc, m.mutationName[tokenId]);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tacc = join(acc, assembleSequence(tokenId, _template, t.name, fenotype));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (sequence[i] == bytes16('^text')) {\\n\\t\\t\\t\\t\\tif (abi.encodePacked(m.mutationText[tokenId]).length > 0) {\\n\\t\\t\\t\\t\\t\\tacc = join(acc, m.mutationText[tokenId]);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tacc = join(acc, assembleSequence(tokenId, _template, t.text, fenotype));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (sequence[i] == bytes16('^desc')) {\\n\\t\\t\\t\\t\\tif (abi.encodePacked(m.mutationDesc[tokenId]).length > 0) {\\n\\t\\t\\t\\t\\t\\tacc = join(acc, m.mutationDesc[tokenId]);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tacc = join(acc, assembleSequence(tokenId, _template, t.desc, fenotype));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (sequence[i] == bytes16('^graphics')) {\\n\\t\\t\\t\\t\\tacc = join(acc, assembleSequence(tokenId, _template, t.graphics, fenotype));\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (sequence[i][0] == '{') {\\n\\t\\t\\t\\t// 6. joins build sequences & encodes into base64\\n\\n\\t\\t\\t\\tstring memory ecc;\\n\\t\\t\\t\\tuint numEncode;\\n\\t\\t\\t\\t// step 1: figure out how many build tokens are to be encoded\\n\\t\\t\\t\\tfor (uint j = i + 1; j < sequence.length; j++) {\\n\\t\\t\\t\\t\\tif (sequence[j][0] == '}' && sequence[j][1] == sequence[i][1]) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnumEncode++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// step 2: create a new build sequence\\n\\t\\t\\t\\tbytes16[] memory encodeSequence = new bytes16[](numEncode);\\n\\t\\t\\t\\t// step 3: populate the new build sequence\\n\\t\\t\\t\\tuint k;\\n\\t\\t\\t\\tfor (uint j = i + 1; j < sequence.length; j++) {\\n\\t\\t\\t\\t\\tif (k < numEncode) {\\n\\t\\t\\t\\t\\t\\tencodeSequence[k] = sequence[j];\\n\\t\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t\\t\\ti++; // CRITICAL: this increments the MAIN loop to prevent dups\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// step 4: encode & assemblbe the new build sequence\\n\\t\\t\\t\\tecc = assembleSequence(tokenId, _template, encodeSequence, fenotype);\\n\\t\\t\\t\\t// step 5: join the encoded string to the accumulated string\\n\\t\\t\\t\\tacc = join(acc, encodeBase64(ecc));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// 7. accumulates the build tokens values\\n\\t\\t\\t\\tacc = join(acc, s.variables[sequence[i]]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn acc;\\n\\t}\\n\\n\\t// util\\n\\n\\tfunction join(string memory _a, string memory _b) internal pure returns (string memory) {\\n\\t\\treturn string(abi.encodePacked(bytes(_a), bytes(_b)));\\n\\t}\\n\\n\\tfunction encodeBase64(string memory _str) internal pure returns (string memory) {\\n\\t\\treturn string(abi.encodePacked(Base64.encode(bytes(_str))));\\n\\t}\\n\\n\\tfunction bytes16ToString(bytes16 _bytes) internal pure returns (string memory) {\\n\\t\\tuint j; // length\\n\\n\\t\\t// handle colors\\n\\t\\tfor (uint i; i < _bytes.length; i++) {\\n\\t\\t\\tif (_bytes[i] != 0) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// create new string, because solidity strings are weird\\n\\t\\tbytes memory str = new bytes(j);\\n\\t\\tfor (uint i; i < j; i++) {\\n\\t\\t\\tstr[i] = _bytes[i];\\n\\t\\t}\\n\\n\\t\\treturn string(str);\\n\\t}\\n\\n\\t//\\n\\t// function replaceBytesAtIndex(\\n\\t// \\tbytes32 original,\\n\\t// \\tuint position,\\n\\t// \\tbytes3 toInsert\\n\\t// ) public pure returns (bytes32) {\\n\\t// \\tbytes3 maskBytes = 0xffffff;\\n\\t// \\tbytes32 mask = bytes32(maskBytes) >> ((position*3) * 8);         \\n\\t\\t\\n\\t// \\treturn (~mask & original) | (bytes32(toInsert) >> ((position*3) * 8));\\n\\t// }\\n\\n\\tfunction replaceFirstByte(\\n\\t\\tbytes16 original,\\n\\t\\tbytes1 toInsert\\n\\t) internal pure returns (bytes16) {\\n\\t\\tbytes1 maskBytes = 0xff;\\n\\t\\tbytes16 mask = bytes16(maskBytes) >> 0;         \\n\\t\\t\\n\\t\\treturn (~mask & original) | (bytes16(toInsert) >> 0);\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/universe/lib/GenotypeLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.0;\\n\\nimport { EternalLib } from \\\"./EternalLib.sol\\\";\\nimport { AssembleLib } from \\\"./AssembleLib.sol\\\";\\nimport { MutationLib } from \\\"./MutationLib.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\nlibrary GenotypeLib {\\n\\n\\t// takes tokenId, return a list of layer names\\n\\tfunction deriveFenotype(uint tokenId, bytes16 _template) internal view returns (bytes16[] memory) {\\n\\t\\tEternalLib.EternalStorage storage s = EternalLib.eternalStorage();\\n\\t\\tbytes16 _genotype = s.templates[_template].genotype;\\n\\t\\tbytes16 seedhash = s.templates[_template].seedhash;\\n\\t\\t\\n\\t\\t//\\n\\t\\tbytes16[] memory genotypeKeys = s.genotypes[_genotype];\\n\\n\\t\\t// string memory acc;\\n\\t\\t// acc = AssembleLib.join(acc, '_template');\\n\\t\\t// acc = AssembleLib.join(acc, AssembleLib.bytes16ToString(_template));\\n\\t\\t// acc = AssembleLib.join(acc, '_genotype');\\n\\t\\t// acc = AssembleLib.join(acc, AssembleLib.bytes16ToString(_genotype));\\n\\t\\t// acc = AssembleLib.join(acc, 'GENOTYPE_START');\\n\\t\\t\\n\\t\\t// for (uint i = 0; i < genotype.length; i++) {\\n\\t\\t// \\tacc = AssembleLib.join(acc, AssembleLib.bytes16ToString(genotype[i]));\\n\\t\\t// }\\n\\n\\t\\t// acc = AssembleLib.join(acc, 'GENOTYPE_END');\\n\\t\\t// console.log('genotype: ', acc);\\n\\n\\t\\t//\\n\\t\\treturn deriveFenotype(tokenId, seedhash, genotypeKeys);\\n\\t}\\n\\n\\t// pass in seed\\n\\tfunction deriveFenotype(uint tokenId, bytes16 seedhash, bytes16[] memory genotypeKeys) internal view returns (bytes16[] memory) {\\t\\t\\n\\t\\t//\\n\\t\\tEternalLib.EternalStorage storage s = EternalLib.eternalStorage();\\n\\t\\tMutationLib.MutationStorage storage m = MutationLib.mutationStorage();\\n\\n\\t\\t// step 1: check to see if we have a hash override\\n\\t\\tuint hashy;\\n\\t\\tif (m.mutationFenotype[tokenId] != 0) {\\n\\t\\t\\thashy = m.mutationFenotype[tokenId];\\n\\t\\t} else {\\n\\t\\t\\t// step 2: generate a super simple hash\\n\\t\\t\\t// (yes, I know this isn't hiding future metadata traits, don't care)\\n\\t\\t\\thashy = uint(keccak256(abi.encodePacked(tokenId, seedhash)));\\n\\t\\t}\\n\\n\\t\\t// step 3: split this hash into 32 arrays to seed the attributes\\n\\t\\tuint8[32] memory seeds = splitHashIntoFenotype(hashy);\\n\\t\\tbytes16[] memory fenotype = new bytes16[](genotypeKeys.length);\\n\\n\\t\\t// step 4: loop through the traits\\n\\t\\tfor (uint i; i < genotypeKeys.length; i++) {\\n\\t\\t\\t// step 4.a: get the pool of traits\\n\\t\\t\\tbytes16 _genotype = genotypeKeys[i];\\n\\t\\t\\tbytes16[] storage genotype = s.genotypes[_genotype];\\n\\t\\t\\tif (genotype.length != 0) {\\n\\t\\t\\t\\t// step 4.b: if it exists, select a trait from the pool, using the seed\\n\\t\\t\\t\\tuint genotypeIndex;\\n\\t\\t\\t\\t// CHECK FOR PATTERN!\\n\\t\\t\\t\\tif (_genotype == bytes16('#s00-pattern')) {\\n\\t\\t\\t\\t\\tuint maybeIndex = seeds[i] % 32;\\n\\t\\t\\t\\t\\tif (maybeIndex < genotype.length) {\\n\\t\\t\\t\\t\\t\\tgenotypeIndex = maybeIndex;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tgenotypeIndex = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgenotypeIndex = seeds[i] % genotype.length;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// step 4.c: add the selected trait to the accumulated layers\\n\\t\\t\\t\\tfenotype[i] = genotype[genotypeIndex];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfenotype[i] = '_err';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// step 5: return the fenotype\\n\\t\\treturn fenotype;\\n\\t}\\n\\n\\tfunction splitHashIntoFenotype(uint _hash) internal pure returns (uint8[32] memory numbers) {\\n\\t\\tfor (uint i; i < numbers.length; i++) {\\n\\t\\t\\tnumbers[i] = uint8(_hash >> (i * 8));\\n\\t\\t}\\n\\n\\t\\treturn numbers;\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/universe/lib/MutationLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.0;\\n\\n\\nlibrary MutationLib {\\n\\n\\tbytes32 constant MUTATION_STORAGE_POSITION = keccak256('wtf.fuckyous.mutation0.storage');\\n\\n\\tstruct MutationStorage {\\n\\t\\tbool mutationStart;\\n\\t\\tuint mutationPrice;\\n\\t\\tmapping(uint => string) mutationName;\\n\\t\\tmapping(uint => string) mutationText;\\n\\t\\tmapping(uint => string) mutationDesc;\\n\\t\\tmapping(uint => uint) mutationFenotype;\\n\\t\\tmapping(uint => bytes16) mutationTemplate;\\n\\t}\\n\\n\\tfunction mutationStorage() internal pure returns (MutationStorage storage ms) {\\n\\t\\tbytes32 position = MUTATION_STORAGE_POSITION;\\n\\t\\tassembly {\\n\\t\\t\\tms.slot := position\\n\\t\\t}\\n\\t}\\n\\n  function mutateName(uint tokenId, string memory name) internal {\\n    MutationStorage storage s = mutationStorage();\\n    s.mutationName[tokenId] = name;\\n  }\\n  function mutateText(uint tokenId, string memory text) internal {\\n    MutationStorage storage s = mutationStorage();\\n    s.mutationText[tokenId] = text;\\n  }\\n  function mutateDesc(uint tokenId, string memory desc) internal {\\n    MutationStorage storage s = mutationStorage();\\n    s.mutationDesc[tokenId] = desc;\\n  }\\n  function mutateFenotype(uint tokenId, uint fenotype) internal {\\n    MutationStorage storage s = mutationStorage();\\n    s.mutationFenotype[tokenId] = fenotype;\\n  }\\n  function mutateTemplate(uint tokenId, bytes16 template) internal {\\n    MutationStorage storage s = mutationStorage();\\n    s.mutationTemplate[tokenId] = template;\\n  }\\n\\n\\tfunction setMutationStart(bool start) internal {\\n    MutationStorage storage s = mutationStorage();\\n    s.mutationStart = start;\\n  }\\n\\tfunction setMutationPrice(uint price) internal {\\n    MutationStorage storage s = mutationStorage();\\n    s.mutationPrice = price;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/universe/lib/interfaces/IFuckYous.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IFuckYous {\\n\\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides a function for encoding some bytes in base64\\nlibrary Base64 {\\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n        \\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n            \\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n            \\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n            \\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n            \\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               dataPtr := add(dataPtr, 3)\\n               \\n               // read 3 bytes\\n               let input := mload(dataPtr)\\n               \\n               // write 4 characters\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n            }\\n            \\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getGraphics\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"_template\",\"type\":\"bytes16\"}],\"name\":\"getGraphics\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"_template\",\"type\":\"bytes16\"}],\"name\":\"getMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getSeasonal\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"template\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"boundary\",\"type\":\"uint256\"}],\"internalType\":\"struct EternalLib.Seasonal\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"FuckYousMetadata","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}