{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.4.0 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/math/SafeMath.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/math/SignedSafeMath.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SignedSafeMath {\r\n    /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        return a + b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/common/implementation/FixedPoint.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title Library for fixed point arithmetic on uints\r\n */\r\nlibrary FixedPoint {\r\n    using SafeMath for uint256;\r\n    using SignedSafeMath for int256;\r\n\r\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\r\n    // For unsigned values:\r\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\r\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\r\n\r\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\r\n    struct Unsigned {\r\n        uint256 rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\r\n     * @param a uint to convert into a FixedPoint.\r\n     * @return the converted FixedPoint.\r\n     */\r\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if equal, or False.\r\n     */\r\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue == fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if equal, or False.\r\n     */\r\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue == b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue > b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue > fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue > b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue >= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue < b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue < fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue < b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\r\n        return a.rawValue <= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\r\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\r\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice The minimum of `a` and `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the minimum of `a` and `b`.\r\n     */\r\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return a.rawValue < b.rawValue ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice The maximum of `a` and `b`.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the maximum of `a` and `b`.\r\n     */\r\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return a.rawValue > b.rawValue ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds two `Unsigned`s, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the sum of `a` and `b`.\r\n     */\r\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.add(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return the sum of `a` and `b`.\r\n     */\r\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return add(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.sub(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return sub(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\r\n     * @param a a uint256.\r\n     * @param b a FixedPoint.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return sub(fromUnscaledUint(a), b);\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\r\n     * @dev This will \"floor\" the product.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\r\n        // stored internally as a uint256 ~10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\r\n        // would round to 3, but this computation produces the result 2.\r\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\r\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\r\n     * @dev This will \"floor\" the product.\r\n     * @param a a FixedPoint.\r\n     * @param b a uint256.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.mul(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\r\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\r\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\r\n        if (mod != 0) {\r\n            return Unsigned(mulFloor.add(1));\r\n        } else {\r\n            return Unsigned(mulFloor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\r\n     * @param a a FixedPoint.\r\n     * @param b a FixedPoint.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\r\n        return Unsigned(a.rawValue.mul(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\r\n        // 10^41 is stored internally as a uint256 10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\r\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\r\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a uint256 denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        return Unsigned(a.rawValue.div(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a uint256 numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        return div(fromUnscaledUint(a), b);\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\r\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\r\n        uint256 divFloor = aScaled.div(b.rawValue);\r\n        uint256 mod = aScaled.mod(b.rawValue);\r\n        if (mod != 0) {\r\n            return Unsigned(divFloor.add(1));\r\n        } else {\r\n            return Unsigned(divFloor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a uint256 denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\r\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\r\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\r\n        // This creates the possibility of overflow if b is very large.\r\n        return divCeil(a, fromUnscaledUint(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\r\n     * @dev This will \"floor\" the result.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a uint256 denominator.\r\n     * @return output is `a` to the power of `b`.\r\n     */\r\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\r\n        output = fromUnscaledUint(1);\r\n        for (uint256 i = 0; i < b; i = i.add(1)) {\r\n            output = mul(output, a);\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\r\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\r\n    // For signed values:\r\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\r\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\r\n\r\n    struct Signed {\r\n        int256 rawValue;\r\n    }\r\n\r\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\r\n        require(a.rawValue >= 0, \"Negative value provided\");\r\n        return Unsigned(uint256(a.rawValue));\r\n    }\r\n\r\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\r\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\r\n        return Signed(int256(a.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\r\n     * @param a int to convert into a FixedPoint.Signed.\r\n     * @return the converted FixedPoint.Signed.\r\n     */\r\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\r\n        return Signed(a.mul(SFP_SCALING_FACTOR));\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a int256.\r\n     * @return True if equal, or False.\r\n     */\r\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\r\n        return a.rawValue == fromUnscaledInt(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if equal, or False.\r\n     */\r\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\r\n        return a.rawValue == b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\r\n        return a.rawValue > b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\r\n        return a.rawValue > fromUnscaledInt(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than `b`.\r\n     * @param a an int256.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a > b`, or False.\r\n     */\r\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\r\n        return fromUnscaledInt(a).rawValue > b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\r\n        return a.rawValue >= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\r\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is greater than or equal to `b`.\r\n     * @param a an int256.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a >= b`, or False.\r\n     */\r\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\r\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\r\n        return a.rawValue < b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\r\n        return a.rawValue < fromUnscaledInt(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than `b`.\r\n     * @param a an int256.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a < b`, or False.\r\n     */\r\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\r\n        return fromUnscaledInt(a).rawValue < b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\r\n        return a.rawValue <= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\r\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Whether `a` is less than or equal to `b`.\r\n     * @param a an int256.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return True if `a <= b`, or False.\r\n     */\r\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\r\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\r\n    }\r\n\r\n    /**\r\n     * @notice The minimum of `a` and `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the minimum of `a` and `b`.\r\n     */\r\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        return a.rawValue < b.rawValue ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice The maximum of `a` and `b`.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the maximum of `a` and `b`.\r\n     */\r\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        return a.rawValue > b.rawValue ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds two `Signed`s, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the sum of `a` and `b`.\r\n     */\r\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        return Signed(a.rawValue.add(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return the sum of `a` and `b`.\r\n     */\r\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        return add(a, fromUnscaledInt(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts two `Signed`s, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        return Signed(a.rawValue.sub(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        return sub(a, fromUnscaledInt(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\r\n     * @param a an int256.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the difference of `a` and `b`.\r\n     */\r\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\r\n        return sub(fromUnscaledInt(a), b);\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies two `Signed`s, reverting on overflow.\r\n     * @dev This will \"floor\" the product.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\r\n        // stored internally as an int256 ~10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\r\n        // would round to 3, but this computation produces the result 2.\r\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\r\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\r\n     * @dev This will \"floor\" the product.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b an int256.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        return Signed(a.rawValue.mul(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\r\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\r\n        // Manual mod because SignedSafeMath doesn't support it.\r\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\r\n        if (mod != 0) {\r\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\r\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\r\n            return Signed(mulTowardsZero.add(valueToAdd));\r\n        } else {\r\n            return Signed(mulTowardsZero);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a FixedPoint.Signed.\r\n     * @return the product of `a` and `b`.\r\n     */\r\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\r\n        return Signed(a.rawValue.mul(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        // There are two caveats with this computation:\r\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\r\n        // 10^41 is stored internally as an int256 10^59.\r\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\r\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\r\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b an int256 denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        return Signed(a.rawValue.div(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\r\n     * @dev This will \"floor\" the quotient.\r\n     * @param a an int256 numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\r\n        return div(fromUnscaledInt(a), b);\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b a FixedPoint denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\r\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\r\n        int256 divTowardsZero = aScaled.div(b.rawValue);\r\n        // Manual mod because SignedSafeMath doesn't support it.\r\n        int256 mod = aScaled % b.rawValue;\r\n        if (mod != 0) {\r\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\r\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\r\n            return Signed(divTowardsZero.add(valueToAdd));\r\n        } else {\r\n            return Signed(divTowardsZero);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\r\n     * @param a a FixedPoint numerator.\r\n     * @param b an int256 denominator.\r\n     * @return the quotient of `a` divided by `b`.\r\n     */\r\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\r\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\r\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\r\n        // This creates the possibility of overflow if b is very large.\r\n        return divAwayFromZero(a, fromUnscaledInt(b));\r\n    }\r\n\r\n    /**\r\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\r\n     * @dev This will \"floor\" the result.\r\n     * @param a a FixedPoint.Signed.\r\n     * @param b a uint256 (negative exponents are not allowed).\r\n     * @return output is `a` to the power of `b`.\r\n     */\r\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\r\n        output = fromUnscaledInt(1);\r\n        for (uint256 i = 0; i < b; i = i.add(1)) {\r\n            output = mul(output, a);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/oracle/interfaces/StoreInterface.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title Interface that allows financial contracts to pay oracle fees for their use of the system.\r\n */\r\ninterface StoreInterface {\r\n    /**\r\n     * @notice Pays Oracle fees in ETH to the store.\r\n     * @dev To be used by contracts whose margin currency is ETH.\r\n     */\r\n    function payOracleFees() external payable;\r\n\r\n    /**\r\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\r\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\r\n     * @param erc20Address address of the ERC20 token used to pay the fee.\r\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\r\n     */\r\n    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external;\r\n\r\n    /**\r\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\r\n     * @param startTime defines the beginning time from which the fee is paid.\r\n     * @param endTime end time until which the fee is paid.\r\n     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a\r\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\r\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\r\n     * @return latePenalty for paying the fee after the deadline.\r\n     */\r\n    function computeRegularFee(\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        FixedPoint.Unsigned calldata pfc\r\n    ) external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);\r\n\r\n    /**\r\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\r\n     * @param currency token used to pay the final fee.\r\n     * @return finalFee amount due.\r\n     */\r\n    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);\r\n}\r\n\r\n\r\n// File contracts/oracle/interfaces/OracleAncillaryInterface.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Financial contract facing Oracle interface.\r\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\r\n */\r\nabstract contract OracleAncillaryInterface {\r\n    /**\r\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\r\n     * @dev Time must be in the past and the identifier must be supported.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @param time unix timestamp for the price request.\r\n     */\r\n\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public virtual;\r\n\r\n    /**\r\n     * @notice Whether the price for `identifier` and `time` is available.\r\n     * @dev Time must be in the past and the identifier must be supported.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\r\n     */\r\n    function hasPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (bool);\r\n\r\n    /**\r\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\r\n     * @dev If the price is not available, the method reverts.\r\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\r\n     * @param time unix timestamp for the price request.\r\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\r\n     * @return int256 representing the resolved price for the given identifier and timestamp.\r\n     */\r\n\r\n    function getPrice(\r\n        bytes32 identifier,\r\n        uint256 time,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (int256);\r\n}\r\n\r\n\r\n// File contracts/oracle/interfaces/FinderInterface.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Provides addresses of the live contracts implementing certain interfaces.\r\n * @dev Examples are the Oracle or Store interfaces.\r\n */\r\ninterface FinderInterface {\r\n    /**\r\n     * @notice Updates the address of the contract that implements `interfaceName`.\r\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\r\n     * @param implementationAddress address of the deployed contract that implements the interface.\r\n     */\r\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\r\n\r\n    /**\r\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\r\n     * @param interfaceName queried interface.\r\n     * @return implementationAddress address of the deployed contract that implements the interface.\r\n     */\r\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/oracle/interfaces/IdentifierWhitelistInterface.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.\r\n */\r\ninterface IdentifierWhitelistInterface {\r\n    /**\r\n     * @notice Adds the provided identifier as a supported identifier.\r\n     * @dev Price requests using this identifier will succeed after this call.\r\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\r\n     */\r\n    function addSupportedIdentifier(bytes32 identifier) external;\r\n\r\n    /**\r\n     * @notice Removes the identifier from the whitelist.\r\n     * @dev Price requests using this identifier will no longer succeed after this call.\r\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\r\n     */\r\n    function removeSupportedIdentifier(bytes32 identifier) external;\r\n\r\n    /**\r\n     * @notice Checks whether an identifier is on the whitelist.\r\n     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\r\n     * @return bool if the identifier is supported (or not).\r\n     */\r\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/oracle/interfaces/OptimisticOracleInterface.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Financial contract facing Oracle interface.\r\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\r\n */\r\nabstract contract OptimisticOracleInterface {\r\n    // Struct representing the state of a price request.\r\n    enum State {\r\n        Invalid, // Never requested.\r\n        Requested, // Requested, no other actions taken.\r\n        Proposed, // Proposed, but not expired or disputed yet.\r\n        Expired, // Proposed, not disputed, past liveness.\r\n        Disputed, // Disputed, but no DVM price returned yet.\r\n        Resolved, // Disputed and DVM price is available.\r\n        Settled // Final price has been set in the contract (can get here from Expired or Resolved).\r\n    }\r\n\r\n    // Struct representing a price request.\r\n    struct Request {\r\n        address proposer; // Address of the proposer.\r\n        address disputer; // Address of the disputer.\r\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\r\n        bool settled; // True if the request is settled.\r\n        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\r\n        int256 proposedPrice; // Price that the proposer submitted.\r\n        int256 resolvedPrice; // Price resolved once the request is settled.\r\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\r\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\r\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\r\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\r\n        uint256 customLiveness; // Custom liveness value set by the requester.\r\n    }\r\n\r\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\r\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\r\n    // to accept a price request made with ancillary data length over a certain size.\r\n    uint256 public constant ancillaryBytesLimit = 8192;\r\n\r\n    /**\r\n     * @notice Requests a new price.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\r\n     * This can be changed with a subsequent call to setBond().\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Set the proposal bond associated with a price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param bond custom bond amount to set.\r\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\r\n     * changed again with a subsequent call to setBond().\r\n     */\r\n    function setBond(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 bond\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\r\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\r\n     * bond, so there is still profit to be made even if the reward is refunded.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function setRefundOnDispute(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\r\n     * being auto-resolved.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param customLiveness new custom liveness.\r\n     */\r\n    function setCustomLiveness(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 customLiveness\r\n    ) external virtual;\r\n\r\n    /**\r\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\r\n     * from this proposal. However, any bonds are pulled from the caller.\r\n     * @param proposer address to set as the proposer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePriceFor(\r\n        address proposer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) public virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Proposes a price value for an existing price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\r\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\r\n     * @param disputer address to set as the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was value (the proposal was incorrect).\r\n     */\r\n    function disputePriceFor(\r\n        address disputer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Disputes a price value for an existing price request with an active proposal.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual returns (uint256 totalBond);\r\n\r\n    /**\r\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\r\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\r\n     * hasn't been settled.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return resolved price.\r\n     */\r\n    function settleAndGetPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual returns (int256);\r\n\r\n    /**\r\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\r\n     * the returned bonds as well as additional rewards.\r\n     */\r\n    function settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external virtual returns (uint256 payout);\r\n\r\n    /**\r\n     * @notice Gets the current data structure containing all information about a price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the Request data structure.\r\n     */\r\n    function getRequest(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (Request memory);\r\n\r\n    /**\r\n     * @notice Returns the state of a price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the State enum value.\r\n     */\r\n    function getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (State);\r\n\r\n    /**\r\n     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return true if price has resolved or settled, false otherwise.\r\n     */\r\n    function hasPrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view virtual returns (bool);\r\n\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes memory);\r\n}\r\n\r\n\r\n// File contracts/oracle/implementation/Constants.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Stores common interface names used throughout the DVM by registration in the Finder.\r\n */\r\nlibrary OracleInterfaces {\r\n    bytes32 public constant Oracle = \"Oracle\";\r\n    bytes32 public constant IdentifierWhitelist = \"IdentifierWhitelist\";\r\n    bytes32 public constant Store = \"Store\";\r\n    bytes32 public constant FinancialContractsAdmin = \"FinancialContractsAdmin\";\r\n    bytes32 public constant Registry = \"Registry\";\r\n    bytes32 public constant CollateralWhitelist = \"CollateralWhitelist\";\r\n    bytes32 public constant OptimisticOracle = \"OptimisticOracle\";\r\n    bytes32 public constant Bridge = \"Bridge\";\r\n    bytes32 public constant GenericHandler = \"GenericHandler\";\r\n}\r\n\r\n\r\n// File contracts/common/implementation/Timer.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Universal store of current contract time for testing environments.\r\n */\r\ncontract Timer {\r\n    uint256 private currentTime;\r\n\r\n    constructor() {\r\n        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the current time.\r\n     * @dev Will revert if not running in test mode.\r\n     * @param time timestamp to set `currentTime` to.\r\n     */\r\n    function setCurrentTime(uint256 time) external {\r\n        currentTime = time;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the currentTime variable set in the Timer.\r\n     * @return uint256 for the current Testable timestamp.\r\n     */\r\n    function getCurrentTime() public view returns (uint256) {\r\n        return currentTime;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/common/implementation/Testable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Base class that provides time overrides, but only if being run in test mode.\r\n */\r\nabstract contract Testable {\r\n    // If the contract is being run in production, then `timerAddress` will be the 0x0 address.\r\n    // Note: this variable should be set on construction and never modified.\r\n    address public timerAddress;\r\n\r\n    /**\r\n     * @notice Constructs the Testable contract. Called by child contracts.\r\n     * @param _timerAddress Contract that stores the current time in a testing environment.\r\n     * Must be set to 0x0 for production environments that use live time.\r\n     */\r\n    constructor(address _timerAddress) {\r\n        timerAddress = _timerAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if not running in test mode.\r\n     */\r\n    modifier onlyIfTest {\r\n        require(timerAddress != address(0x0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the current time.\r\n     * @dev Will revert if not running in test mode.\r\n     * @param time timestamp to set current Testable time to.\r\n     */\r\n    function setCurrentTime(uint256 time) external onlyIfTest {\r\n        Timer(timerAddress).setCurrentTime(time);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\r\n     * Otherwise, it will return the block timestamp.\r\n     * @return uint for the current Testable timestamp.\r\n     */\r\n    function getCurrentTime() public view returns (uint256) {\r\n        if (timerAddress != address(0x0)) {\r\n            return Timer(timerAddress).getCurrentTime();\r\n        } else {\r\n            return block.timestamp; // solhint-disable-line not-rely-on-time\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/common/implementation/Lockable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\r\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\r\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\r\n */\r\ncontract Lockable {\r\n    bool private _notEntered;\r\n\r\n    constructor() {\r\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\r\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\r\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\r\n        // refund coming into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\r\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\r\n     * function that does the actual state modification.\r\n     */\r\n    modifier nonReentrant() {\r\n        _preEntranceCheck();\r\n        _preEntranceSet();\r\n        _;\r\n        _postEntranceReset();\r\n    }\r\n\r\n    /**\r\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\r\n     */\r\n    modifier nonReentrantView() {\r\n        _preEntranceCheck();\r\n        _;\r\n    }\r\n\r\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\r\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\r\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\r\n    // then call `_postEntranceReset()`.\r\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\r\n    function _preEntranceCheck() internal view {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n\r\n    function _preEntranceSet() internal {\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n    }\r\n\r\n    function _postEntranceReset() internal {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/common/implementation/AncillaryData.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Library for encoding and decoding ancillary data for DVM price requests.\r\n * @notice  We assume that on-chain ancillary data can be formatted directly from bytes to utf8 encoding via\r\n * web3.utils.hexToUtf8, and that clients will parse the utf8-encoded ancillary data as a comma-delimitted key-value\r\n * dictionary. Therefore, this library provides internal methods that aid appending to ancillary data from Solidity\r\n * smart contracts. More details on UMA's ancillary data guidelines below:\r\n * https://docs.google.com/document/d/1zhKKjgY1BupBGPPrY_WOJvui0B6DMcd-xDR8-9-SPDw/edit\r\n */\r\nlibrary AncillaryData {\r\n    /**\r\n     * @notice Returns utf8-encoded address that can be read via web3.utils.hexToUtf8.\r\n     * Source: https://ethereum.stackexchange.com/questions/8346/convert-address-to-string/8447#8447\r\n     * @dev Will return address in all lower case characters and without the leading 0x.\r\n     * @param x address to encode.\r\n     * @return utf8 encoded address bytes.\r\n     */\r\n    function toUtf8BytesAddress(address x) internal pure returns (bytes memory) {\r\n        bytes memory s = new bytes(40);\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2**(8 * (19 - i)))));\r\n            bytes1 hi = bytes1(uint8(b) / 16);\r\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n            s[2 * i] = char(hi);\r\n            s[2 * i + 1] = char(lo);\r\n        }\r\n        return s;\r\n    }\r\n\r\n    function char(bytes1 b) internal pure returns (bytes1 c) {\r\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\r\n        else return bytes1(uint8(b) + 0x57);\r\n    }\r\n\r\n    /**\r\n     * @notice Converts a uint into a base-10, UTF-8 representation stored in a `string` type.\r\n     * @dev This method is based off of this code: https://stackoverflow.com/a/65707309.\r\n     */\r\n    function toUtf8BytesUint(uint256 x) internal pure returns (bytes memory) {\r\n        if (x == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = x;\r\n        uint256 len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len;\r\n        while (x != 0) {\r\n            k = k - 1;\r\n            uint8 temp = (48 + uint8(x - (x / 10) * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            x /= 10;\r\n        }\r\n        return bstr;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds \"key:value\" to `currentAncillaryData` where `value` is an address that first needs to be converted\r\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\"k1:v1\"`, then this function will return\r\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\r\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\r\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\r\n     * @param value An address to set as the value in the key:value pair to append to `currentAncillaryData`.\r\n     * @return Newly appended ancillary data.\r\n     */\r\n    function appendKeyValueAddress(\r\n        bytes memory currentAncillaryData,\r\n        bytes memory key,\r\n        address value\r\n    ) internal pure returns (bytes memory) {\r\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\r\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesAddress(value));\r\n    }\r\n\r\n    /**\r\n     * @notice Adds \"key:value\" to `currentAncillaryData` where `value` is a uint that first needs to be converted\r\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\"k1:v1\"`, then this function will return\r\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\r\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\r\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\r\n     * @param value A uint to set as the value in the key:value pair to append to `currentAncillaryData`.\r\n     * @return Newly appended ancillary data.\r\n     */\r\n    function appendKeyValueUint(\r\n        bytes memory currentAncillaryData,\r\n        bytes memory key,\r\n        uint256 value\r\n    ) internal pure returns (bytes memory) {\r\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\r\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesUint(value));\r\n    }\r\n\r\n    /**\r\n     * @notice Helper method that returns the left hand side of a \"key:value\" pair plus the colon \":\" and a leading\r\n     * comma \",\" if the `currentAncillaryData` is not empty. The return value is intended to be appended as a prefix to\r\n     * some utf8 value that is ultimately added to a comma-delimited, key-value dictionary.\r\n     */\r\n    function constructPrefix(bytes memory currentAncillaryData, bytes memory key) internal pure returns (bytes memory) {\r\n        if (currentAncillaryData.length > 0) {\r\n            return abi.encodePacked(\",\", key, \":\");\r\n        } else {\r\n            return abi.encodePacked(key, \":\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/common/interfaces/AddressWhitelistInterface.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface AddressWhitelistInterface {\r\n    function addToWhitelist(address newElement) external;\r\n\r\n    function removeFromWhitelist(address newElement) external virtual;\r\n\r\n    function isOnWhitelist(address newElement) external view virtual returns (bool);\r\n\r\n    function getWhitelist() external view virtual returns (address[] memory);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/common/implementation/AddressWhitelist.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title A contract to track a whitelist of addresses.\r\n */\r\ncontract AddressWhitelist is AddressWhitelistInterface, Ownable, Lockable {\r\n    enum Status { None, In, Out }\r\n    mapping(address => Status) public whitelist;\r\n\r\n    address[] public whitelistIndices;\r\n\r\n    event AddedToWhitelist(address indexed addedAddress);\r\n    event RemovedFromWhitelist(address indexed removedAddress);\r\n\r\n    /**\r\n     * @notice Adds an address to the whitelist.\r\n     * @param newElement the new address to add.\r\n     */\r\n    function addToWhitelist(address newElement) external override nonReentrant() onlyOwner {\r\n        // Ignore if address is already included\r\n        if (whitelist[newElement] == Status.In) {\r\n            return;\r\n        }\r\n\r\n        // Only append new addresses to the array, never a duplicate\r\n        if (whitelist[newElement] == Status.None) {\r\n            whitelistIndices.push(newElement);\r\n        }\r\n\r\n        whitelist[newElement] = Status.In;\r\n\r\n        emit AddedToWhitelist(newElement);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes an address from the whitelist.\r\n     * @param elementToRemove the existing address to remove.\r\n     */\r\n    function removeFromWhitelist(address elementToRemove) external override nonReentrant() onlyOwner {\r\n        if (whitelist[elementToRemove] != Status.Out) {\r\n            whitelist[elementToRemove] = Status.Out;\r\n            emit RemovedFromWhitelist(elementToRemove);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks whether an address is on the whitelist.\r\n     * @param elementToCheck the address to check.\r\n     * @return True if `elementToCheck` is on the whitelist, or False.\r\n     */\r\n    function isOnWhitelist(address elementToCheck) external view override nonReentrantView() returns (bool) {\r\n        return whitelist[elementToCheck] == Status.In;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets all addresses that are currently included in the whitelist.\r\n     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\r\n     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\r\n     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\r\n     * the empty index.\r\n     * @return activeWhitelist the list of addresses on the whitelist.\r\n     */\r\n    function getWhitelist() external view override nonReentrantView() returns (address[] memory activeWhitelist) {\r\n        // Determine size of whitelist first\r\n        uint256 activeCount = 0;\r\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\r\n            if (whitelist[whitelistIndices[i]] == Status.In) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        // Populate whitelist\r\n        activeWhitelist = new address[](activeCount);\r\n        activeCount = 0;\r\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\r\n            address addr = whitelistIndices[i];\r\n            if (whitelist[addr] == Status.In) {\r\n                activeWhitelist[activeCount] = addr;\r\n                activeCount++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/oracle/implementation/OptimisticOracle.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Optimistic Requester.\r\n * @notice Optional interface that requesters can implement to receive callbacks.\r\n * @dev this contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\r\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\r\n * money themselves).\r\n */\r\ninterface OptimisticRequester {\r\n    /**\r\n     * @notice Callback for proposals.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function priceProposed(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Callback for disputes.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param refund refund received in the case that refundOnDispute was enabled.\r\n     */\r\n    function priceDisputed(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 refund\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Callback for settlement.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param price price that was resolved by the escalation process.\r\n     */\r\n    function priceSettled(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 price\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title Optimistic Oracle.\r\n * @notice Pre-DVM escalation contract that allows faster settlement.\r\n */\r\ncontract OptimisticOracle is OptimisticOracleInterface, Testable, Lockable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    event RequestPrice(\r\n        address indexed requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        address currency,\r\n        uint256 reward,\r\n        uint256 finalFee\r\n    );\r\n    event ProposePrice(\r\n        address indexed requester,\r\n        address indexed proposer,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        int256 proposedPrice,\r\n        uint256 expirationTimestamp,\r\n        address currency\r\n    );\r\n    event DisputePrice(\r\n        address indexed requester,\r\n        address indexed proposer,\r\n        address indexed disputer,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        int256 proposedPrice\r\n    );\r\n    event Settle(\r\n        address indexed requester,\r\n        address indexed proposer,\r\n        address indexed disputer,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes ancillaryData,\r\n        int256 price,\r\n        uint256 payout\r\n    );\r\n\r\n    mapping(bytes32 => Request) public requests;\r\n\r\n    // Finder to provide addresses for DVM contracts.\r\n    FinderInterface public finder;\r\n\r\n    // Default liveness value for all price requests.\r\n    uint256 public defaultLiveness;\r\n\r\n    /**\r\n     * @notice Constructor.\r\n     * @param _liveness default liveness applied to each price request.\r\n     * @param _finderAddress finder to use to get addresses of DVM contracts.\r\n     * @param _timerAddress address of the timer contract. Should be 0x0 in prod.\r\n     */\r\n    constructor(\r\n        uint256 _liveness,\r\n        address _finderAddress,\r\n        address _timerAddress\r\n    ) Testable(_timerAddress) {\r\n        finder = FinderInterface(_finderAddress);\r\n        _validateLiveness(_liveness);\r\n        defaultLiveness = _liveness;\r\n    }\r\n\r\n    /**\r\n     * @notice Requests a new price.\r\n     * @param identifier price identifier being requested.\r\n     * @param timestamp timestamp of the price being requested.\r\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\r\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\r\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\r\n     *               which could make sense if the contract requests and proposes the value in the same call or\r\n     *               provides its own reward system.\r\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\r\n     * This can be changed with a subsequent call to setBond().\r\n     */\r\n    function requestPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        IERC20 currency,\r\n        uint256 reward\r\n    ) external override nonReentrant() returns (uint256 totalBond) {\r\n        require(_getState(msg.sender, identifier, timestamp, ancillaryData) == State.Invalid, \"requestPrice: Invalid\");\r\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\r\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\r\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\r\n        require(\r\n            _stampAncillaryData(ancillaryData, msg.sender).length <= ancillaryBytesLimit,\r\n            \"Ancillary Data too long\"\r\n        );\r\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\r\n        requests[_getId(msg.sender, identifier, timestamp, ancillaryData)] = Request({\r\n            proposer: address(0),\r\n            disputer: address(0),\r\n            currency: currency,\r\n            settled: false,\r\n            refundOnDispute: false,\r\n            proposedPrice: 0,\r\n            resolvedPrice: 0,\r\n            expirationTime: 0,\r\n            reward: reward,\r\n            finalFee: finalFee,\r\n            bond: finalFee,\r\n            customLiveness: 0\r\n        });\r\n\r\n        if (reward > 0) {\r\n            currency.safeTransferFrom(msg.sender, address(this), reward);\r\n        }\r\n\r\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, address(currency), reward, finalFee);\r\n\r\n        // This function returns the initial proposal bond for this request, which can be customized by calling\r\n        // setBond() with the same identifier and timestamp.\r\n        return finalFee.mul(2);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the proposal bond associated with a price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param bond custom bond amount to set.\r\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\r\n     * changed again with a subsequent call to setBond().\r\n     */\r\n    function setBond(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 bond\r\n    ) external override nonReentrant() returns (uint256 totalBond) {\r\n        require(_getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested, \"setBond: Requested\");\r\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\r\n        request.bond = bond;\r\n\r\n        // Total bond is the final fee + the newly set bond.\r\n        return bond.add(request.finalFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\r\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\r\n     * bond, so there is still profit to be made even if the reward is refunded.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     */\r\n    function setRefundOnDispute(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override nonReentrant() {\r\n        require(\r\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"setRefundOnDispute: Requested\"\r\n        );\r\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).refundOnDispute = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\r\n     * being auto-resolved.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param customLiveness new custom liveness.\r\n     */\r\n    function setCustomLiveness(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        uint256 customLiveness\r\n    ) external override nonReentrant() {\r\n        require(\r\n            _getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"setCustomLiveness: Requested\"\r\n        );\r\n        _validateLiveness(customLiveness);\r\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).customLiveness = customLiveness;\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\r\n     * from this proposal. However, any bonds are pulled from the caller.\r\n     * @param proposer address to set as the proposer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePriceFor(\r\n        address proposer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) public override nonReentrant() returns (uint256 totalBond) {\r\n        require(proposer != address(0), \"proposer address must be non 0\");\r\n        require(\r\n            _getState(requester, identifier, timestamp, ancillaryData) == State.Requested,\r\n            \"proposePriceFor: Requested\"\r\n        );\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n        request.proposer = proposer;\r\n        request.proposedPrice = proposedPrice;\r\n\r\n        // If a custom liveness has been set, use it instead of the default.\r\n        request.expirationTime = getCurrentTime().add(\r\n            request.customLiveness != 0 ? request.customLiveness : defaultLiveness\r\n        );\r\n\r\n        totalBond = request.bond.add(request.finalFee);\r\n        if (totalBond > 0) {\r\n            request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n        }\r\n\r\n        emit ProposePrice(\r\n            requester,\r\n            proposer,\r\n            identifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            proposedPrice,\r\n            request.expirationTime,\r\n            address(request.currency)\r\n        );\r\n\r\n        // Callback.\r\n        if (address(requester).isContract())\r\n            try OptimisticRequester(requester).priceProposed(identifier, timestamp, ancillaryData) {} catch {}\r\n    }\r\n\r\n    /**\r\n     * @notice Proposes a price value for an existing price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param proposedPrice price being proposed.\r\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\r\n     * the proposer once settled if the proposal is correct.\r\n     */\r\n    function proposePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData,\r\n        int256 proposedPrice\r\n    ) external override returns (uint256 totalBond) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return proposePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData, proposedPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\r\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\r\n     * @param disputer address to set as the disputer.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePriceFor(\r\n        address disputer,\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public override nonReentrant() returns (uint256 totalBond) {\r\n        require(disputer != address(0), \"disputer address must be non 0\");\r\n        require(\r\n            _getState(requester, identifier, timestamp, ancillaryData) == State.Proposed,\r\n            \"disputePriceFor: Proposed\"\r\n        );\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n        request.disputer = disputer;\r\n\r\n        uint256 finalFee = request.finalFee;\r\n        uint256 bond = request.bond;\r\n        totalBond = bond.add(finalFee);\r\n        if (totalBond > 0) {\r\n            request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\r\n        }\r\n\r\n        StoreInterface store = _getStore();\r\n\r\n        // Avoids stack too deep compilation error.\r\n        {\r\n            // Along with the final fee, \"burn\" part of the loser's bond to ensure that a larger bond always makes it\r\n            // proportionally more expensive to delay the resolution even if the proposer and disputer are the same\r\n            // party.\r\n            uint256 burnedBond = _computeBurnedBond(request);\r\n\r\n            // The total fee is the burned bond and the final fee added together.\r\n            uint256 totalFee = finalFee.add(burnedBond);\r\n\r\n            if (totalFee > 0) {\r\n                request.currency.safeIncreaseAllowance(address(store), totalFee);\r\n                _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));\r\n            }\r\n        }\r\n\r\n        _getOracle().requestPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester));\r\n\r\n        // Compute refund.\r\n        uint256 refund = 0;\r\n        if (request.reward > 0 && request.refundOnDispute) {\r\n            refund = request.reward;\r\n            request.reward = 0;\r\n            request.currency.safeTransfer(requester, refund);\r\n        }\r\n\r\n        emit DisputePrice(\r\n            requester,\r\n            request.proposer,\r\n            disputer,\r\n            identifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            request.proposedPrice\r\n        );\r\n\r\n        // Callback.\r\n        if (address(requester).isContract())\r\n            try OptimisticRequester(requester).priceDisputed(identifier, timestamp, ancillaryData, refund) {} catch {}\r\n    }\r\n\r\n    /**\r\n     * @notice Disputes a price value for an existing price request with an active proposal.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\r\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\r\n     */\r\n    function disputePrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override returns (uint256 totalBond) {\r\n        // Note: re-entrancy guard is done in the inner call.\r\n        return disputePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\r\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\r\n     * hasn't been settled.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return resolved price.\r\n     */\r\n    function settleAndGetPrice(\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override nonReentrant() returns (int256) {\r\n        if (_getState(msg.sender, identifier, timestamp, ancillaryData) != State.Settled) {\r\n            _settle(msg.sender, identifier, timestamp, ancillaryData);\r\n        }\r\n\r\n        return _getRequest(msg.sender, identifier, timestamp, ancillaryData).resolvedPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\r\n     * the returned bonds as well as additional rewards.\r\n     */\r\n    function settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) external override nonReentrant() returns (uint256 payout) {\r\n        return _settle(requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current data structure containing all information about a price request.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the Request data structure.\r\n     */\r\n    function getRequest(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() returns (Request memory) {\r\n        return _getRequest(requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the current state of a price request. See the State enum for more details.\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return the State.\r\n     */\r\n    function getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() returns (State) {\r\n        return _getState(requester, identifier, timestamp, ancillaryData);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\r\n     * @param requester sender of the initial price request.\r\n     * @param identifier price identifier to identify the existing request.\r\n     * @param timestamp timestamp to identify the existing request.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @return boolean indicating true if price exists and false if not.\r\n     */\r\n    function hasPrice(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) public view override nonReentrantView() returns (bool) {\r\n        State state = _getState(requester, identifier, timestamp, ancillaryData);\r\n        return state == State.Settled || state == State.Resolved || state == State.Expired;\r\n    }\r\n\r\n    /**\r\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\r\n     * @param ancillaryData ancillary data of the price being requested.\r\n     * @param requester sender of the initial price request.\r\n     * @return the stamped ancillary bytes.\r\n     */\r\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\r\n        public\r\n        pure\r\n        override\r\n        returns (bytes memory)\r\n    {\r\n        return _stampAncillaryData(ancillaryData, requester);\r\n    }\r\n\r\n    function _getId(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(requester, identifier, timestamp, ancillaryData));\r\n    }\r\n\r\n    function _settle(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private returns (uint256 payout) {\r\n        State state = _getState(requester, identifier, timestamp, ancillaryData);\r\n\r\n        // Set it to settled so this function can never be entered again.\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n        request.settled = true;\r\n\r\n        if (state == State.Expired) {\r\n            // In the expiry case, just pay back the proposer's bond and final fee along with the reward.\r\n            request.resolvedPrice = request.proposedPrice;\r\n            payout = request.bond.add(request.finalFee).add(request.reward);\r\n            request.currency.safeTransfer(request.proposer, payout);\r\n        } else if (state == State.Resolved) {\r\n            // In the Resolved case, pay either the disputer or the proposer the entire payout (+ bond and reward).\r\n            request.resolvedPrice = _getOracle().getPrice(\r\n                identifier,\r\n                timestamp,\r\n                _stampAncillaryData(ancillaryData, requester)\r\n            );\r\n            bool disputeSuccess = request.resolvedPrice != request.proposedPrice;\r\n            uint256 bond = request.bond;\r\n\r\n            // Unburned portion of the loser's bond = 1 - burned bond.\r\n            uint256 unburnedBond = bond.sub(_computeBurnedBond(request));\r\n\r\n            // Winner gets:\r\n            // - Their bond back.\r\n            // - The unburned portion of the loser's bond.\r\n            // - Their final fee back.\r\n            // - The request reward (if not already refunded -- if refunded, it will be set to 0).\r\n            payout = bond.add(unburnedBond).add(request.finalFee).add(request.reward);\r\n            request.currency.safeTransfer(disputeSuccess ? request.disputer : request.proposer, payout);\r\n        } else {\r\n            revert(\"_settle: not settleable\");\r\n        }\r\n\r\n        emit Settle(\r\n            requester,\r\n            request.proposer,\r\n            request.disputer,\r\n            identifier,\r\n            timestamp,\r\n            ancillaryData,\r\n            request.resolvedPrice,\r\n            payout\r\n        );\r\n\r\n        // Callback.\r\n        if (address(requester).isContract())\r\n            try\r\n                OptimisticRequester(requester).priceSettled(identifier, timestamp, ancillaryData, request.resolvedPrice)\r\n            {} catch {}\r\n    }\r\n\r\n    function _getRequest(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) private view returns (Request storage) {\r\n        return requests[_getId(requester, identifier, timestamp, ancillaryData)];\r\n    }\r\n\r\n    function _computeBurnedBond(Request storage request) private view returns (uint256) {\r\n        // burnedBond = floor(bond / 2)\r\n        return request.bond.div(2);\r\n    }\r\n\r\n    function _validateLiveness(uint256 _liveness) private pure {\r\n        require(_liveness < 5200 weeks, \"Liveness too large\");\r\n        require(_liveness > 0, \"Liveness cannot be 0\");\r\n    }\r\n\r\n    function _getState(\r\n        address requester,\r\n        bytes32 identifier,\r\n        uint256 timestamp,\r\n        bytes memory ancillaryData\r\n    ) internal view returns (State) {\r\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\r\n\r\n        if (address(request.currency) == address(0)) {\r\n            return State.Invalid;\r\n        }\r\n\r\n        if (request.proposer == address(0)) {\r\n            return State.Requested;\r\n        }\r\n\r\n        if (request.settled) {\r\n            return State.Settled;\r\n        }\r\n\r\n        if (request.disputer == address(0)) {\r\n            return request.expirationTime <= getCurrentTime() ? State.Expired : State.Proposed;\r\n        }\r\n\r\n        return\r\n            _getOracle().hasPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester))\r\n                ? State.Resolved\r\n                : State.Disputed;\r\n    }\r\n\r\n    function _getOracle() internal view returns (OracleAncillaryInterface) {\r\n        return OracleAncillaryInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\r\n    }\r\n\r\n    function _getCollateralWhitelist() internal view returns (AddressWhitelist) {\r\n        return AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\r\n    }\r\n\r\n    function _getStore() internal view returns (StoreInterface) {\r\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\r\n    }\r\n\r\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\r\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\r\n    }\r\n\r\n    /**\r\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translateable in utf8.\r\n     * For those cases, we assume that the client will be able to strip out the utf8-translateable part of the\r\n     * ancillary data that this contract stamps.\r\n     */\r\n    function _stampAncillaryData(bytes memory ancillaryData, address requester) internal pure returns (bytes memory) {\r\n        // Since this contract will be the one to formally submit DVM price requests, its useful for voters to know who\r\n        // the original requester was.\r\n        return AncillaryData.appendKeyValueAddress(ancillaryData, \"ooRequester\", requester);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liveness\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_finderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"disputer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"proposedPrice\",\"type\":\"int256\"}],\"name\":\"DisputePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"proposedPrice\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"ProposePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalFee\",\"type\":\"uint256\"}],\"name\":\"RequestPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"disputer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"Settle\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ancillaryBytesLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultLiveness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"disputePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBond\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"disputer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"disputePriceFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBond\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finder\",\"outputs\":[{\"internalType\":\"contract FinderInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"getRequest\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"disputer\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"settled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"refundOnDispute\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"proposedPrice\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"resolvedPrice\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"customLiveness\",\"type\":\"uint256\"}],\"internalType\":\"struct OptimisticOracleInterface.Request\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"getState\",\"outputs\":[{\"internalType\":\"enum OptimisticOracleInterface.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"hasPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"internalType\":\"int256\",\"name\":\"proposedPrice\",\"type\":\"int256\"}],\"name\":\"proposePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBond\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"internalType\":\"int256\",\"name\":\"proposedPrice\",\"type\":\"int256\"}],\"name\":\"proposePriceFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBond\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"requestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBond\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"disputer\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"settled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"refundOnDispute\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"proposedPrice\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"resolvedPrice\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"customLiveness\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"}],\"name\":\"setBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBond\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setCurrentTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"customLiveness\",\"type\":\"uint256\"}],\"name\":\"setCustomLiveness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"setRefundOnDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"settle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"}],\"name\":\"settleAndGetPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"ancillaryData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"stampAncillaryData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OptimisticOracle","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000001c2000000000000000000000000040f941e48a552bf496b154af6bf55725f18d77c30000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f0491d573a6c9edcd9e6392958a707356d24744094e25bc7b651a207479026f7"}]}