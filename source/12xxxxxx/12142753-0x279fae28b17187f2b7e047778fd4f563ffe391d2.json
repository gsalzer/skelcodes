{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n\n// \n// From https://gist.github.com/cryptoscopia/1156a368c19a82be2d083e04376d261e\n// The ABI encoder is necessary, but older Solidity versions should work\n// These definitions are taken from across multiple dydx contracts, and are\n// limited to just the bare minimum necessary to make flash loans work.\nlibrary Types {\n    enum AssetDenomination { Wei, Par }\n    enum AssetReference { Delta, Target }\n    struct AssetAmount {\n        bool sign;\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n}\n\nlibrary Account {\n    struct Info {\n        address owner;\n        uint256 number;\n    }\n}\n\nlibrary Actions {\n    enum ActionType {\n        Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call\n    }\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        Types.AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n}\n\ninterface ISoloMargin {\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\n}\n\n// Standard ERC-20 interface\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract FlashLoanTemplate {\n    // The DAI token contract, since we're assuming we want a loan in DAI\n    IERC20 internal DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    // The dydx Solo Margin contract, as can be found here:\n    // https://github.com/dydxprotocol/solo/blob/master/migrations/deployed.json\n    ISoloMargin internal soloMargin = ISoloMargin(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\n\n    // // RINKEBY testnet contracts\n    // ISoloMargin internal soloMargin = ISoloMargin(0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE);\n    // IERC20 internal DAI = IERC20(0x5592EC0cfb4dbc12D3aB100b257153436a1f0FEa);\n\n    enum OperationType { Inflate, Deflate }\n\n    constructor() {\n        // Give infinite approval to dydx to withdraw WETH on contract deployment,\n        // so we don't have to approve the loan repayment amount (+2 wei) on each call.\n        // The approval is used by the dydx contract to pay the loan back to itself.\n        DAI.approve(address(soloMargin), uint(-1));\n    }\n    \n    // This is the function we call\n    function _flashLoan(uint loanAmount, OperationType opType) internal {\n\n        /*\n        The flash loan functionality in dydx is predicated by their \"operate\" function,\n        which takes a list of operations to execute, and defers validating the state of\n        things until it's done executing them.\n        \n        We thus create three operations, a Withdraw (which loans us the funds), a Call\n        (which invokes the callFunction method on this contract), and a Deposit (which\n        repays the loan, plus the 2 wei fee), and pass them all to \"operate\".\n        \n        Note that the Deposit operation will invoke the transferFrom to pay the loan \n        (or whatever amount it was initialised with) back to itself, there is no need\n        to pay it back explicitly.\n        \n        The loan must be given as an ERC-20 token, so WETH is used instead of ETH. Other\n        currencies (DAI, USDC) are also available, their index can be looked up by\n        calling getMarketTokenAddress on the solo margin contract, and set as the \n        primaryMarketId in the Withdraw and Deposit definitions.\n        */\n        \n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = Actions.ActionArgs({\n            actionType: Actions.ActionType.Withdraw,\n            accountId: 0,\n            amount: Types.AssetAmount({\n                sign: false,\n                denomination: Types.AssetDenomination.Wei,\n                ref: Types.AssetReference.Delta,\n                value: loanAmount // Amount to borrow\n            }),\n            primaryMarketId: 3, // DAI\n            secondaryMarketId: 0,\n            otherAddress: address(this),\n            otherAccountId: 0,\n            data: \"\"\n        });\n        \n        operations[1] = Actions.ActionArgs({\n                actionType: Actions.ActionType.Call,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: false,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: 0\n                }),\n                primaryMarketId: 0,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: abi.encode(\n                    // Replace or add any additional variables that you want\n                    // to be available to the receiver function\n                    loanAmount,\n                    opType\n                )\n            });\n        \n        operations[2] = Actions.ActionArgs({\n            actionType: Actions.ActionType.Deposit,\n            accountId: 0,\n            amount: Types.AssetAmount({\n                sign: true,\n                denomination: Types.AssetDenomination.Wei,\n                ref: Types.AssetReference.Delta,\n                value: loanAmount + 2 // Repayment amount with 2 wei fee\n            }),\n            primaryMarketId: 3, // DAI\n            secondaryMarketId: 0,\n            otherAddress: address(this),\n            otherAccountId: 0,\n            data: \"\"\n        });\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = Account.Info({owner: address(this), number: 1});\n\n        soloMargin.operate(accountInfos, operations);\n    }\n    \n    // This is the function called by dydx after giving us the loan\n    function callFunction(address sender, Account.Info memory accountInfo, bytes memory data) external virtual;\n}\n\n// \ninterface ICERC20 is IERC20 {\n    function mint(uint256) external returns (uint256);\n    function borrow(uint256) external returns (uint);\n    function repayBorrow(uint256) external returns (uint);\n    function redeem(uint) external returns (uint);\n    function redeemUnderlying(uint) external returns (uint);\n    function borrowBalanceCurrent(address) external returns (uint);\n    function balanceOfUnderlying(address owner) external returns (uint);\n}\n\ninterface Comptroller {\n    function enterMarkets(address[] calldata)\n        external\n        returns (uint256[] memory);\n\n    function claimComp(address holder) external;\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n}\n\n/**\n * @dev CompoundDAIStrategy contract.\n * This contracts implements strategy to incresea income in COMP.\n * @author Grigorii Melnikov <grigorii.melnikov@startblock.online>\n */\ncontract CompoundDAIStrategy is FlashLoanTemplate {\n    using SafeMath for uint256;\n\n    // The cDAI token contract\n    ICERC20 private cDAI = ICERC20(0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643);\n    // The COMP token contract\n    IERC20 private COMP = IERC20(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n    // The Comptroller token contract\n    Comptroller private comptroller = Comptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n    \n    address public owner;\n\n    // // RINKEBY testnet\n    // ICERC20 private cDAI = ICERC20(0x6D7F0754FFeb405d23C51CE938289d4835bE3b14);\n    // IERC20 private COMP = IERC20(0x61460874a7196d6a22D1eE4922473664b3E95270);\n    // Comptroller private comptroller = Comptroller(0x2EAa9D77AE4D8f9cdD9FAAcd44016E746485bddb);\n\n    // Current collateral factor (k) for DAI = 75%\n    // x - initial supply in DAI, y - additional supply in DAI and borrow amount\n    // y < k * (x + y) => y < [ k / (1 - k) ] * x\n    // COLLATERAL_VALUE = k / (1 - k) = 3\n    // uint256 public constant COLLATERAL_VALUE = 3;\n\n    constructor(address agent) FlashLoanTemplate() {\n        owner = agent;\n        _enterDaiMarket();\n        // Approve transfers on the cDAI contract\n        DAI.approve(address(cDAI), uint256(-1));\n        DAI.approve(owner, uint256(-1));\n    }\n\n    modifier onlyOwner() {\n        require (owner == msg.sender, \"CompoundDAIStrategy: not owner.\");\n        _;\n    }\n\n    function _supplyDaiInternal(uint256 numTokensToSupply) private {\n        // Mint cTokens\n        uint256 mintResult = cDAI.mint(numTokensToSupply);\n        require(mintResult == 0, \"CompoundDAIStrategy: mint failed.\");\n    }\n\n    /**\n     * @notice Sender supply DAI tokens to Compound protocol\n     * @param numTokensToSupply The amount of DAIs to supply in Compound\n     * @param loanFee The amount of loans' fee\n     */\n    function supplyDai(uint256 numTokensToSupply, uint256 loanFee) external onlyOwner {\n        DAI.transferFrom(owner, address(this), numTokensToSupply.add(loanFee));\n\n        _supplyDaiInternal(numTokensToSupply);\n    }\n\n    function _redeemUnderlyingInternal(uint256 numTokensToRedeem) private {\n        uint256 result = cDAI.redeemUnderlying(numTokensToRedeem);\n\n        require(result == 0, \"CompoundDAIStrategy: redeemUnderlying failed.\");\n    }\n\n    /**\n     * @notice Redeem all DAIs from Compound and transfer them to owner\n     */\n    function redeemAll() external onlyOwner {\n        uint256 result = cDAI.redeem(cDAI.balanceOf(address(this)));\n\n        require(result == 0, \"CompoundDAIStrategy: redeemAll failed.\");\n        DAI.transfer(owner, DAI.balanceOf(address(this)));\n    }\n\n    function _enterDaiMarket() private {\n        address[] memory cTokens = new address[](1);\n        cTokens[0] = address(cDAI);\n        uint256[] memory errors = comptroller.enterMarkets(cTokens);\n\n        require(errors[0] == 0, \"CompoundDAIStrategy: enterMarkets failed.\");\n    }\n\n    function _borrowDaiFromCompound(uint256 numTokensToBorrow) private {\n        uint256 borrowResult = cDAI.borrow(numTokensToBorrow);\n        if (borrowResult == 0) {\n            return;\n        } else if (borrowResult == 3 /* COMPTROLLER_REJECTION */) {\n            revert(\"CompoundDAIStrategy: Insuficient collateral.\");\n        } else {\n            revert(\"CompoundDAIStrategy: borrow failed.\");\n        }\n    }\n\n    function _repayBorrow(uint256 repayAmmount) private {\n        uint256 error = cDAI.repayBorrow(repayAmmount);\n\n        require(error == 0, \"CompoundDAIStrategy: repayment borrow failed.\");\n    }\n\n    /**\n     * @notice Sender takes a flashloan, supplies loan on Compound and borrows the same amount to return loan\n     * @dev Size of the flashloan should be less than COLLATERAL FACTOR * balanceUnderlying\n     * @param numTokensToInflate The amount of DAI tokens to inflate\n     */\n    function inflate(uint256 numTokensToInflate) external onlyOwner {\n        require(numTokensToInflate > 0, \"CompoundDAIStrategy: Inflate request with zero amount.\");\n        require(DAI.balanceOf(address(this)) >= 2, \"CompoundDAIStrategy: Not enough DAIs for DyDx flashloan.\");\n\n        require(\n            numTokensToInflate <= DAI.balanceOf(address(soloMargin)),\n            \"CompoundDAIStrategy: Not enough DAIs in DyDx pool.\"\n        );\n        _flashLoan(numTokensToInflate, OperationType.Inflate);\n    }\n\n    /**\n     * @notice Sender takes a flashloan, repays borrow and redeem underlying tokens to return loan\n     */\n    function deflate() external onlyOwner {\n        require(DAI.balanceOf(address(this)) >= 2, \"CompoundDAIStrategy: Not enoug DAIs for DyDx flashloan.\");\n\n        uint256 borrowBalance = cDAI.borrowBalanceCurrent(address(this));\n\n        require(\n            borrowBalance <= DAI.balanceOf(address(soloMargin)),\n            \"CompoundDAIStrategy: Not enough DAIs in DyDx pool.\"\n        );\n        _flashLoan(borrowBalance, OperationType.Deflate);\n    }\n\n    function callFunction(address /* sender */, Account.Info memory /* accountInfo */, bytes memory data)\n        external \n        override \n    {\n        require(msg.sender == address(soloMargin), \"CompoundDAIStrategy: Only DyDx Solo margin contract can call.\");\n\n        // This must match the variables defined in the FlashLoanTemplate\n        (\n            uint loanAmount,\n            OperationType opType\n        ) = abi.decode(data, (\n            uint, OperationType\n        ));\n\n        if (opType == OperationType.Inflate) {\n            _supplyDaiInternal(loanAmount);\n            _borrowDaiFromCompound(loanAmount);\n        } else {\n            _repayBorrow(loanAmount);\n            _redeemUnderlyingInternal(loanAmount);\n        }\n    }\n\n    /**\n     * @notice Claim COMP tokens\n     */\n    function claimComp() external onlyOwner {\n        comptroller.claimComp(address(this));\n\n        COMP.transfer(owner, COMP.balanceOf(address(this)));\n    }\n\n    function changeOwner(address newOwner) external onlyOwner {\n        owner = newOwner;\n    }\n\n    function repayManually(address cTokenAddr) external onlyOwner {\n        ICERC20 cToken = ICERC20(cTokenAddr);\n\n        cToken.repayBorrow(uint256(-1));\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct Account.Info\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimComp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deflate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokensToInflate\",\"type\":\"uint256\"}],\"name\":\"inflate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"}],\"name\":\"repayManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokensToSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanFee\",\"type\":\"uint256\"}],\"name\":\"supplyDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CompoundDAIStrategy","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ac1c30c8ae96a6cdd392bc2593a6e00d964b73c2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}