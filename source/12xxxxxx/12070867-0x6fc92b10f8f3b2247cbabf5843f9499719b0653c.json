{"status":"1","message":"OK","result":[{"SourceCode":"# Copyright (C) 2021 VolumeFi Software, Inc.\r\n\r\n# @version ^0.2.0\r\n\r\ninterface ERC20:\r\n    def balanceOf(addr: address) -> uint256: view\r\n    def allowance(_owner: address, _spender: address) -> uint256: view\r\n    def approve(spender: address, amount: uint256): nonpayable\r\n    def transfer(recipient: address, amount: uint256): nonpayable\r\n    def transferFrom(sender: address, recipient: address, amount: uint256): nonpayable\r\n\r\ninterface WrappedEth:\r\n    def deposit(): payable\r\n    def withdraw(wad: uint256): nonpayable\r\n\r\n# Curve Registry Contract\r\ninterface CrvRegistry:\r\n    def get_n_coins(_pool: address) -> uint256[2]: view\r\n    def get_coins(_pool: address) -> address[8]: view\r\n    def get_underlying_coins(_pool: address) -> address[8]: view\r\n    def get_lp_token(_pool: address) -> address: view\r\n\r\n# 4-token-Curve Pool interface for add_liquidity including is_underlying parameter\r\ninterface CurveUnderlyingAdd4Pool:\r\n    def add_liquidity(_amounts: uint256[4], _min_amount: uint256, _is_underlying: bool): nonpayable\r\n\r\n# 3-token-Curve Pool interface for add_liquidity including is_underlying parameter\r\ninterface CurveUnderlyingAdd3Pool:\r\n    def add_liquidity(_amounts: uint256[3], _min_amount: uint256, _is_underlying: bool): nonpayable\r\n\r\n# 2-token-Curve Pool interface for add_liquidity including is_underlying parameter\r\ninterface CurveUnderlyingAdd2Pool:\r\n    def add_liquidity(_amounts: uint256[2], _min_amount: uint256, _is_underlying: bool): nonpayable\r\n\r\n# 4-token Curve Pool interface for add_liquidity\r\ninterface Curve4Pool:\r\n    def add_liquidity(_amounts: uint256[4], _min_amount: uint256): nonpayable\r\n\r\n# 3-token Curve Pool interface for add_liquidity\r\ninterface Curve3Pool:\r\n    def add_liquidity(_amounts: uint256[3], _min_amount: uint256): nonpayable\r\n\r\n# 2-token Curve Pool interface for add_liquidity\r\ninterface Curve2Pool:\r\n    def add_liquidity(_amounts: uint256[2], _min_amount: uint256): nonpayable\r\n\r\n# 4-token-Curve Pool interface for add_liquidity including ETH as coin\r\ninterface CurveEth4Pool:\r\n    def add_liquidity(_amounts: uint256[4], _min_amount: uint256): payable\r\n\r\n# 3-token-Curve Pool interface for add_liquidity including ETH as coin\r\ninterface CurveEth3Pool:\r\n    def add_liquidity(_amounts: uint256[3], _min_amount: uint256): payable\r\n\r\n# 2-token-Curve Pool interface for add_liquidity including ETH as coin\r\ninterface CurveEth2Pool:\r\n    def add_liquidity(_amounts: uint256[2], _min_amount: uint256): payable\r\n\r\nevent CurveTokenBought:\r\n    lpToken: address\r\n    tokenBought: uint256\r\n\r\nUNISWAPV2ROUTER02: constant(address) = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\nDEADLINE: constant(uint256) = MAX_UINT256\r\n\r\npaused: public(bool)\r\nadmin: public(address)\r\nfeeAmount: public(uint256)\r\nfeeAddress: public(address)\r\ncrvRegistry: public(address) # Curve Registry Contract\r\nuniIndex: public(HashMap[address, uint256]) # coin index to bring from uniswap\r\nnoUnderlyingPool: public(HashMap[address, bool]) # Curve Pools not using separate underlying coins\r\nmetaPool: public(HashMap[address, address]) # Curve meta Pools for deposit / withdraw\r\nunderlyingAddPool: public(HashMap[address, bool]) # Curve Pools with add_liquidity including is_underlying parameter\r\npausedPool: public(HashMap[address, bool]) # Pause protocol individual Curve Pool\r\n\r\n@internal\r\ndef _token2Token(fromToken: address, toToken: address, tokens2Trade: uint256, deadline: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice token to token swap using Uniswap\r\n    @param fromToken contract address of the offered token\r\n    @param toToken contract address of the desired toToken\r\n    @param token2Trade amount of fromToken\r\n    @param deadline timestamp after revert transaction\r\n    @return amount of toToken\r\n    \"\"\"\r\n    if fromToken == toToken:\r\n        return tokens2Trade\r\n    if ERC20(fromToken).allowance(self, UNISWAPV2ROUTER02) > 0:\r\n        ERC20(fromToken).approve(UNISWAPV2ROUTER02, 0)\r\n    ERC20(fromToken).approve(UNISWAPV2ROUTER02, tokens2Trade)\r\n    \r\n    addrBytes: Bytes[288] = concat(convert(tokens2Trade, bytes32), convert(0, bytes32), convert(160, bytes32), convert(self, bytes32), convert(deadline, bytes32), convert(2, bytes32), convert(fromToken, bytes32), convert(toToken, bytes32))\r\n    funcsig: Bytes[4] = method_id(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\")\r\n    full_data: Bytes[292] = concat(funcsig, addrBytes)\r\n    \r\n    _response: Bytes[128] = raw_call(\r\n        UNISWAPV2ROUTER02,\r\n        full_data,\r\n        max_outsize=128\r\n    )\r\n    tokenBought: uint256 = convert(slice(_response, 96, 32), uint256)\r\n    assert tokenBought > 0, \"Error Swapping Token 2\"\r\n    return tokenBought\r\n\r\n@internal\r\ndef _eth2Token(token: address, eth2Trade: uint256, deadline: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice eth to token swap using Uniswap\r\n    @param token contract address of the desired Token\r\n    @param eth2Trade amount of Ethereum\r\n    @param deadline timestamp after revert transaction\r\n    @return amount of toToken\r\n    \"\"\"\r\n    if token == VETH or token == ZERO_ADDRESS:\r\n        return eth2Trade\r\n    elif token == WETH:\r\n        WrappedEth(WETH).deposit(value=eth2Trade)\r\n        return eth2Trade\r\n    else:\r\n        WrappedEth(WETH).deposit(value=eth2Trade)\r\n        return self._token2Token(WETH, token, eth2Trade, deadline)\r\n\r\n@internal\r\ndef _token2Eth(token: address, amount: uint256, deadline: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice token to eth swap using Uniswap\r\n    @param token contract address of the desired Token\r\n    @param eth2Trade amount of Ethereum\r\n    @param deadline timestamp after revert transaction\r\n    @return amount of toToken\r\n    \"\"\"\r\n    if token == VETH or token == ZERO_ADDRESS:\r\n        return amount\r\n    elif token == WETH:\r\n        WrappedEth(WETH).withdraw(amount)\r\n        return amount\r\n    else:\r\n        tokenAmount: uint256 = self._token2Token(token, WETH, amount, deadline)\r\n        WrappedEth(WETH).withdraw(tokenAmount)\r\n        return tokenAmount\r\n\r\n@internal\r\ndef _pullTokens(token: address, amount: uint256, sender: address, msg_value: uint256):\r\n    \"\"\"\r\n    @notice pull token from sender\r\n    @param token contract address of the offered Token\r\n    @param amount amount of the offered Token\r\n    @param sender token sender address\r\n    @param msg_value remaining Eth amount\r\n    \"\"\"\r\n    if token == VETH or token == ZERO_ADDRESS:\r\n        assert msg_value >= amount, \"ETH not enough\"\r\n        if msg_value > amount:\r\n            send(sender, msg_value - amount)\r\n    else:\r\n        ERC20(token).transferFrom(sender, self, amount)\r\n        if msg_value > 0:\r\n            send(sender, msg_value)\r\n\r\n@internal\r\ndef _enterCurve(pool: address, entryToken: address, amount: uint256, index: uint256, tokenCount: uint256, lpToken: address) -> uint256:\r\n    \"\"\"\r\n    @notice add liquidity to Curve pool\r\n    @param pool contract address of Curve pool\r\n    @param entryToken contract address to add liquidity\r\n    @param amount amount of entryToken\r\n    @param index index of entryToken in the pool\r\n    @param tokenCount number of coins of the pool\r\n    @param lpToken Curve LP token of the Pool\r\n    @return amount of minted lpToken\r\n    \"\"\"\r\n    if entryToken != ZERO_ADDRESS and entryToken != VETH:\r\n        if ERC20(entryToken).allowance(self, pool) > 0:\r\n            ERC20(entryToken).approve(pool, 0)\r\n        ERC20(entryToken).approve(pool, amount)\r\n    if tokenCount == 4:\r\n        amounts: uint256[4] = empty(uint256[4])\r\n        amounts[index] = amount\r\n        if self.underlyingAddPool[pool]:\r\n            CurveUnderlyingAdd4Pool(pool).add_liquidity(amounts, 0, True)\r\n        elif entryToken == VETH:\r\n            CurveEth4Pool(pool).add_liquidity(amounts, 0, value=amount)\r\n        else:\r\n            Curve4Pool(pool).add_liquidity(amounts, 0)\r\n    elif tokenCount == 3:\r\n        amounts: uint256[3] = empty(uint256[3])\r\n        amounts[index] = amount\r\n        if self.underlyingAddPool[pool]:\r\n            CurveUnderlyingAdd3Pool(pool).add_liquidity(amounts, 0, True)\r\n        elif entryToken == VETH:\r\n            CurveEth3Pool(pool).add_liquidity(amounts, 0, value=amount)\r\n        else:\r\n            Curve3Pool(pool).add_liquidity(amounts, 0)\r\n    elif tokenCount == 2:\r\n        amounts: uint256[2] = empty(uint256[2])\r\n        amounts[index] = amount\r\n        if self.underlyingAddPool[pool]:\r\n            CurveUnderlyingAdd2Pool(pool).add_liquidity(amounts, 0, True)\r\n        elif entryToken == VETH:\r\n            CurveEth2Pool(pool).add_liquidity(amounts, 0, value=amount)\r\n        else:\r\n            Curve2Pool(pool).add_liquidity(amounts, 0)\r\n    else:\r\n        raise \"Token count error\"\r\n    return ERC20(lpToken).balanceOf(self)\r\n\r\n@internal\r\n@view\r\ndef _getCurvePool(crvReg: address, swap: address, token: address) -> (address, address, uint256, uint256):\r\n    \"\"\"\r\n    @notice get Curve Pool information from Curve Registry\r\n    @param crvReg contract address of Curve Registry\r\n    @param swap contract address of Curve pool\r\n    @param token contract address of offered token\r\n    @return pool contract address of Curve pool\r\n    @return entryToken contract address to add liquidity\r\n    @return tokenIndex index of entryToken in the pool\r\n    @return tokenCount number of coins of the pool\r\n    \"\"\"\r\n    pool: address = self.metaPool[swap]\r\n    entryToken: address = token\r\n    tokenIndex: uint256 = 0\r\n    if pool == ZERO_ADDRESS:\r\n        pool = swap\r\n    if token == ZERO_ADDRESS:\r\n        entryToken = VETH\r\n    tokenCount: uint256 = CrvRegistry(crvReg).get_n_coins(swap)[1]\r\n    coins: address[8] = empty(address[8])\r\n    if self.noUnderlyingPool[swap]:\r\n        coins = CrvRegistry(crvReg).get_coins(swap)\r\n    else:\r\n        coins = CrvRegistry(crvReg).get_underlying_coins(swap)\r\n\r\n    for i in range(8):\r\n        if i == tokenCount:\r\n            tokenIndex = self.uniIndex[swap]\r\n            entryToken = coins[tokenIndex]\r\n            break\r\n        if coins[i] == entryToken:\r\n            tokenIndex = i\r\n            break\r\n    return (pool, entryToken, tokenIndex, tokenCount)\r\n\r\n@internal\r\ndef _getEntryToken(token: address, entryToken: address, amount: uint256, deadline: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice get entry token amount to Curve pool\r\n    @param token contract address of the offered token\r\n    @param entryToken contract address to add liquidity\r\n    @param amount amount of the offered token\r\n    @return amount of the entryToken\r\n    \"\"\"\r\n    tokenAmount: uint256 = amount\r\n    if token == entryToken:\r\n        return tokenAmount\r\n    if token == VETH or token == ZERO_ADDRESS:\r\n        if entryToken == WETH:\r\n            WrappedEth(WETH).deposit(value=tokenAmount)\r\n        else:\r\n            tokenAmount = self._eth2Token(entryToken, tokenAmount, deadline)\r\n    elif token == WETH:\r\n        if entryToken == VETH or entryToken == ZERO_ADDRESS:\r\n            WrappedEth(WETH).withdraw(tokenAmount)\r\n        else:\r\n            tokenAmount = self._token2Token(WETH, entryToken, tokenAmount, deadline)\r\n    else:\r\n        if entryToken == VETH or entryToken == ZERO_ADDRESS:\r\n            tokenAmount = self._token2Eth(token, tokenAmount, deadline)\r\n        else:\r\n            tokenAmount = self._token2Token(token, WETH, tokenAmount, deadline)\r\n            if entryToken != WETH:\r\n                tokenAmount = self._token2Token(WETH, entryToken, tokenAmount, deadline)\r\n    return tokenAmount\r\n\r\n@external\r\ndef __init__():\r\n    self.admin = msg.sender\r\n    self.feeAmount = 1 * 10 ** 16\r\n    self.feeAddress = 0xf29399fB3311082d9F8e62b988cBA44a5a98ebeD\r\n    self.crvRegistry = 0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c\r\n\r\n    # Curve meta pool addresses for deposit / withdraw\r\n    self.metaPool[0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56] = 0xeB21209ae4C2c9FF2a86ACA31E123764A3B6Bc06 # Compound\r\n    self.metaPool[0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C] = 0xac795D2c97e60DF6a99ff1c814727302fD747a80 # USDT\r\n    self.metaPool[0x06364f10B501e868329afBc005b3492902d6C763] = 0xA50cCc70b6a011CffDdf45057E39679379187287 # PAX\r\n    self.metaPool[0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51] = 0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3 # Y\r\n    self.metaPool[0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27] = 0xb6c057591E073249F2D9D88Ba59a46CFC9B59EdB # BUSD\r\n    self.metaPool[0xA5407eAE9Ba41422680e2e00537571bcC53efBfD] = 0xFCBa3E75865d2d561BE8D220616520c171F12851 # sUSD\r\n    self.metaPool[0x4f062658EaAF2C1ccf8C8e36D6824CDf41167956] = 0x64448B78561690B70E17CBE8029a3e5c1bB7136e # gusd\r\n    self.metaPool[0x3eF6A01A0f81D6046290f3e2A8c5b843e738E604] = 0x09672362833d8f703D5395ef3252D4Bfa51c15ca # husd\r\n    self.metaPool[0x3E01dD8a5E1fb3481F0F589056b428Fc308AF0Fb] = 0xF1f85a74AD6c64315F85af52d3d46bF715236ADc # usdk\r\n    self.metaPool[0x0f9cb53Ebe405d49A0bbdBD291A65Ff571bC83e1] = 0x094d12e5b541784701FD8d65F11fc0598FBC6332 # usdn\r\n    self.metaPool[0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171] = 0x1de7f0866e2c4adAC7b457c58Cc25c8688CDa1f2 # linkusd\r\n    self.metaPool[0x8474DdbE98F5aA3179B3B3F5942D724aFcdec9f6] = 0x803A2B40c5a9BB2B86DD630B274Fa2A9202874C2 # musd\r\n    self.metaPool[0xC18cC39da8b11dA8c3541C598eE022258F9744da] = 0xBE175115BF33E12348ff77CcfEE4726866A0Fbd5 # rsv\r\n    self.metaPool[0xC25099792E9349C7DD09759744ea681C7de2cb66] = 0xaa82ca713D94bBA7A89CEAB55314F9EfFEdDc78c # tbtc\r\n    self.metaPool[0x8038C01A0390a8c547446a0b2c18fc9aEFEcc10c] = 0x61E10659fe3aa93d036d099405224E4Ac24996d0 # dusd\r\n    self.metaPool[0x7F55DDe206dbAD629C080068923b36fe9D6bDBeF] = 0x11F419AdAbbFF8d595E7d5b223eee3863Bb3902C # pbtc\r\n    self.metaPool[0x071c661B4DeefB59E2a3DdB20Db036821eeE8F4b] = 0xC45b2EEe6e09cA176Ca3bB5f7eEe7C47bF93c756 # bbtc\r\n    self.metaPool[0xd81dA8D904b52208541Bade1bD6595D8a251F8dd] = 0xd5BCf53e2C81e1991570f33Fa881c49EEa570C8D # obtc\r\n    self.metaPool[0x890f4e345B1dAED0367A877a1612f86A1f86985f] = 0xB0a0716841F2Fc03fbA72A891B8Bb13584F52F2d # ust\r\n    self.metaPool[0x42d7025938bEc20B69cBae5A77421082407f053A] = 0x3c8cAee4E09296800f8D29A68Fa3837e2dae4940 # steth\r\n\r\n    # Curve Pools with add_liquidity including is_underlying parameter\r\n    self.underlyingAddPool[0xDeBF20617708857ebe4F679508E7b7863a8A8EeE] = True # aave\r\n    self.underlyingAddPool[0xEB16Ae0052ed37f479f7fe63849198Df1765a733] = True # saave\r\n    self.underlyingAddPool[0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF] = True # ironbank\r\n\r\n    # Curve Pools not using separate underlying coins\r\n    self.noUnderlyingPool[0x93054188d876f558f4a66B2EF1d97d16eDf0895B] = True # ren\r\n    self.noUnderlyingPool[0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714] = True # sbtc\r\n    self.noUnderlyingPool[0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F] = True # hbtc\r\n\r\n    # coin index of Curve Pools to bring from uniswap (maximum liquidity XXX-ETH)\r\n    self.uniIndex[0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56] = 1 # Compound - USDC\r\n    self.uniIndex[0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C] = 1 # USDT - USDC\r\n    self.uniIndex[0x06364f10B501e868329afBc005b3492902d6C763] = 1 # PAX - USDC\r\n    self.uniIndex[0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51] = 1 # Y - USDC\r\n    self.uniIndex[0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27] = 1 # BUSD - USDC\r\n    self.uniIndex[0xA5407eAE9Ba41422680e2e00537571bcC53efBfD] = 1 # sUSD - USDC\r\n    self.uniIndex[0x93054188d876f558f4a66B2EF1d97d16eDf0895B] = 1 # ren - WBTC\r\n    self.uniIndex[0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714] = 1 # sbtc - WBTC\r\n    self.uniIndex[0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F] = 1 # hbtc - WBTC\r\n    self.uniIndex[0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7] = 1 # 3pool - USDC\r\n    self.uniIndex[0x4f062658EaAF2C1ccf8C8e36D6824CDf41167956] = 2 # gusd - USDC\r\n    self.uniIndex[0x3eF6A01A0f81D6046290f3e2A8c5b843e738E604] = 2 # husd - USDC\r\n    self.uniIndex[0x3E01dD8a5E1fb3481F0F589056b428Fc308AF0Fb] = 2 # usdk - USDC\r\n    self.uniIndex[0x0f9cb53Ebe405d49A0bbdBD291A65Ff571bC83e1] = 2 # usdn - USDC\r\n    self.uniIndex[0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171] = 2 # linkusd - USDC\r\n    self.uniIndex[0x8474DdbE98F5aA3179B3B3F5942D724aFcdec9f6] = 2 # musd - USDC\r\n    self.uniIndex[0xC18cC39da8b11dA8c3541C598eE022258F9744da] = 2 # rsv - USDC\r\n    self.uniIndex[0xC25099792E9349C7DD09759744ea681C7de2cb66] = 2 # tbtc - WBTC\r\n    self.uniIndex[0x8038C01A0390a8c547446a0b2c18fc9aEFEcc10c] = 2 # dusd - USDC\r\n    self.uniIndex[0x7F55DDe206dbAD629C080068923b36fe9D6bDBeF] = 2 # pbtc - WBTC\r\n    self.uniIndex[0x071c661B4DeefB59E2a3DdB20Db036821eeE8F4b] = 2 # bbtc - WBTC\r\n    self.uniIndex[0xd81dA8D904b52208541Bade1bD6595D8a251F8dd] = 2 # obtc - WBTC\r\n    self.uniIndex[0x890f4e345B1dAED0367A877a1612f86A1f86985f] = 2 # ust - USDC\r\n    self.uniIndex[0x0Ce6a5fF5217e38315f87032CF90686C96627CAA] = 0 # eurs - EURS\r\n    self.uniIndex[0xc5424B857f758E906013F3555Dad202e4bdB4567] = 0 # seth - ETH\r\n    self.uniIndex[0xDeBF20617708857ebe4F679508E7b7863a8A8EeE] = 1 # aave - USDC\r\n    self.uniIndex[0xDC24316b9AE028F1497c275EB9192a3Ea0f67022] = 0 # steth - ETH\r\n    self.uniIndex[0xEB16Ae0052ed37f479f7fe63849198Df1765a733] = 0 # saave - DAI\r\n    self.uniIndex[0xA96A65c051bF88B4095Ee1f2451C2A9d43F53Ae2] = 0 # ankreth - ETH\r\n    self.uniIndex[0x42d7025938bEc20B69cBae5A77421082407f053A] = 2 # usdp - USDC\r\n    self.uniIndex[0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF] = 1 # ironbank - USDC\r\n    self.uniIndex[0xF178C0b5Bb7e7aBF4e12A4838C7b7c5bA2C623c0] = 0 # link - LINK\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef investTokenForCrvPair(token: address, amount: uint256, swap: address, minPoolTokens: uint256, deadline: uint256=DEADLINE) -> uint256:\r\n    \"\"\"\r\n    @notice invest token / Eth for Curve Liquidity Provider pools\r\n    @param token contract address of the offered Token\r\n    @param amount amount of the offered Token\r\n    @param swap contract address of Curve pool\r\n    @param minPoolTokens minimum lptoken amount to succeed transaction\r\n    @param deadline timestamp after revert transaction\r\n    @return amount of lpToken to investor\r\n    \"\"\"\r\n    assert self.pausedPool[swap] == False, \"Paused Pair\"\r\n    assert self.paused == False, \"Paused\"\r\n    crvReg: address = self.crvRegistry\r\n    lpToken: address = CrvRegistry(crvReg).get_lp_token(swap)\r\n    fee: uint256 = self.feeAmount\r\n    msg_value: uint256 = msg.value\r\n    \r\n    assert msg.value >= fee, \"Insufficient fee\"\r\n    send(self.feeAddress, fee)\r\n    msg_value -= fee\r\n    assert amount > 0, \"Invalid input amount\"\r\n\r\n    self._pullTokens(token, amount, msg.sender, msg_value)\r\n    pool: address = ZERO_ADDRESS\r\n    entryToken: address = VETH\r\n    tokenIndex: uint256 = 0\r\n    tokenCount: uint256 = 0\r\n    (pool, entryToken, tokenIndex, tokenCount) = self._getCurvePool(crvReg, swap, token)\r\n\r\n    entryAmount: uint256 = self._getEntryToken(token, entryToken, amount, deadline)\r\n\r\n    crvTokensBought: uint256 = self._enterCurve(pool, entryToken, entryAmount, tokenIndex, tokenCount, lpToken)\r\n    ERC20(lpToken).transfer(msg.sender, crvTokensBought)\r\n\r\n    assert crvTokensBought >= minPoolTokens\r\n    log CurveTokenBought(lpToken, crvTokensBought)\r\n    return crvTokensBought\r\n\r\n# Admin functions\r\n@external\r\ndef pause(_paused: bool):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.paused = _paused\r\n\r\n@external\r\ndef newAdmin(_admin: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.admin = _admin\r\n\r\n@external\r\ndef newFeeAmount(_feeAmount: uint256):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.feeAmount = _feeAmount\r\n\r\n@external\r\ndef newFeeAddress(_feeAddress: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.feeAddress = _feeAddress\r\n\r\n@external\r\ndef newCrvRegistry(_crvRegistry: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.crvRegistry = _crvRegistry\r\n\r\n@external\r\ndef modifyMetaPool(swap: address, meta: address):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.metaPool[swap] = meta\r\n\r\n@external\r\ndef modifyUnderlyingAddPool(swap: address, underlyingAdd: bool):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.underlyingAddPool[swap] = underlyingAdd\r\n\r\n@external\r\ndef modifyNoUnderlyingPool(swap: address, noUnderlying: bool):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.noUnderlyingPool[swap] = noUnderlying\r\n\r\n@external\r\ndef modifyUniIndex(swap: address, _uniIndex: uint256):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.uniIndex[swap] = _uniIndex\r\n\r\n@external\r\ndef pausePool(swap: address, _pausedPool: bool):\r\n    assert msg.sender == self.admin, \"Not admin\"\r\n    self.pausedPool[swap] = _pausedPool\r\n\r\n@external\r\n@payable\r\ndef __default__(): pass","ABI":"[{\"name\":\"CurveTokenBought\",\"inputs\":[{\"type\":\"address\",\"name\":\"lpToken\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"tokenBought\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"investTokenForCrvPair\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"token\"},{\"type\":\"uint256\",\"name\":\"amount\"},{\"type\":\"address\",\"name\":\"swap\"},{\"type\":\"uint256\",\"name\":\"minPoolTokens\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"investTokenForCrvPair\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"token\"},{\"type\":\"uint256\",\"name\":\"amount\"},{\"type\":\"address\",\"name\":\"swap\"},{\"type\":\"uint256\",\"name\":\"minPoolTokens\"},{\"type\":\"uint256\",\"name\":\"deadline\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"name\":\"pause\",\"outputs\":[],\"inputs\":[{\"type\":\"bool\",\"name\":\"_paused\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36577},{\"name\":\"newAdmin\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_admin\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36607},{\"name\":\"newFeeAmount\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_feeAmount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36537},{\"name\":\"newFeeAddress\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_feeAddress\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36667},{\"name\":\"newCrvRegistry\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_crvRegistry\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36697},{\"name\":\"modifyMetaPool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"swap\"},{\"type\":\"address\",\"name\":\"meta\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36942},{\"name\":\"modifyUnderlyingAddPool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"swap\"},{\"type\":\"bool\",\"name\":\"underlyingAdd\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36972},{\"name\":\"modifyNoUnderlyingPool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"swap\"},{\"type\":\"bool\",\"name\":\"noUnderlying\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37002},{\"name\":\"modifyUniIndex\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"swap\"},{\"type\":\"uint256\",\"name\":\"_uniIndex\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36932},{\"name\":\"pausePool\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"swap\"},{\"type\":\"bool\",\"name\":\"_pausedPool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37062},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"name\":\"paused\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1691},{\"name\":\"admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1721},{\"name\":\"feeAmount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1751},{\"name\":\"feeAddress\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1781},{\"name\":\"crvRegistry\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1811},{\"name\":\"uniIndex\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2056},{\"name\":\"noUnderlyingPool\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2086},{\"name\":\"metaPool\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2116},{\"name\":\"underlyingAddPool\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2146},{\"name\":\"pausedPool\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2176}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.8","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}