{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.8.4;\r\npragma experimental ABIEncoderV2;\r\n// Leak alpha for run and profit with https://twitter.com/mevalphaleak\r\n\r\ncontract DyDxFlashLoanHelper {\r\n    function marketIdFromTokenAddress(address tokenAddress) internal pure returns (uint256 resultId) {\r\n        assembly {\r\n            switch tokenAddress\r\n            case 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 {\r\n                resultId := 0\r\n            }\r\n            case 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 {\r\n                resultId := 2\r\n            }\r\n            case 0x6B175474E89094C44Da98b954EedeAC495271d0F {\r\n                resultId := 3\r\n            }\r\n            default {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n    function wrapWithDyDx(address requiredToken, uint256 requiredBalance, bool requiredApprove, bytes calldata data) public {\r\n        Types.ActionArgs[] memory operations = new Types.ActionArgs[](3);\r\n        operations[0] = Types.ActionArgs({\r\n            actionType: Types.ActionType.Withdraw,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: false,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: requiredBalance\r\n            }),\r\n            primaryMarketId: marketIdFromTokenAddress(requiredToken),\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n        operations[1] = Types.ActionArgs({\r\n            actionType: Types.ActionType.Call,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: false,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: 0\r\n            }),\r\n            primaryMarketId: 0,\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: data\r\n        });\r\n        operations[2] = Types.ActionArgs({\r\n            actionType: Types.ActionType.Deposit,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: true,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: requiredBalance + (requiredToken == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 ? 1 : 2)\r\n            }),\r\n            primaryMarketId: marketIdFromTokenAddress(requiredToken),\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n\r\n        Types.AccountInfo[] memory accountInfos = new Types.AccountInfo[](1);\r\n        accountInfos[0] = Types.AccountInfo({\r\n            owner: address(this),\r\n            number: 1\r\n        });\r\n        if (requiredApprove) {\r\n          // Approval might be already set or can be set inside of 'operations[1]'\r\n          IERC20Token(requiredToken).approve(\r\n            0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e,\r\n            0xffffffffffffffffffffffffffffffff // Max uint112\r\n          );\r\n        }\r\n        ISoloMargin(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e).operate(accountInfos, operations);\r\n    }\r\n}\r\n\r\ncontract IAlphaLeakConstants {\r\n    address internal constant TOKEN_WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address internal constant TOKEN_USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n    address internal constant TOKEN_DAI  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n\r\n    address internal constant PROXY_DYDX  = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\r\n    address internal constant ORACLE_USDC = 0x986b5E1e1755e3C2440e960477f25201B0a8bbD4;\r\n    address internal constant ORACLE_DAI  = 0x773616E4d11A78F511299002da57A0a94577F1f4;\r\n\r\n    uint256 internal constant FLAG_TRANSFORM_ETH_TO_WETH_BEFORE_APE = 0x1;\r\n    uint256 internal constant FLAG_TRANSFORM_WETH_TO_ETH_BEFORE_APE = 0x2;\r\n    uint256 internal constant FLAG_TRANSFORM_ETH_TO_WETH_AFTER_APE  = 0x4;\r\n    uint256 internal constant FLAG_TRANSFORM_WETH_TO_ETH_AFTER_APE  = 0x8;\r\n\r\n    uint256 internal constant FLAG_FLASH_DYDY_WETH     = 0x10;\r\n    uint256 internal constant FLAG_FLASH_DYDY_USDC     = 0x20;\r\n    uint256 internal constant FLAG_FLASH_DYDY_DAI      = 0x40;\r\n\r\n    uint256 internal constant FLAG_WETH_ACCOUNTING     = 0x80;\r\n    uint256 internal constant FLAG_USDC_ACCOUNTING     = 0x100;\r\n    uint256 internal constant FLAG_DAI_ACCOUNTING      = 0x200;\r\n\r\n\r\n    uint256 internal constant FLAG_EXIT_WETH           = 0x400;\r\n    uint256 internal constant FLAG_PAY_COINBASE_SHARE  = 0x800;\r\n    uint256 internal constant FLAG_PAY_COINBASE_AMOUNT = 0x1000;\r\n\r\n\r\n    uint256 internal constant FLAG_RETURN_WETH         = 0x2000;\r\n    uint256 internal constant FLAG_RETURN_USDC         = 0x4000;\r\n    uint256 internal constant FLAG_RETURN_DAI          = 0x8000;\r\n}\r\n\r\ncontract ApeBot is DyDxFlashLoanHelper, IAlphaLeakConstants {\r\n    string  public constant name = \"https://twitter.com/mevalphaleak\";\r\n\r\n    fallback() external payable {}\r\n    function callFunction(\r\n        address,\r\n        Types.AccountInfo memory,\r\n        bytes calldata data\r\n    ) external {\r\n        // Added to support DyDx flash loans natively\r\n        // Security checks aren't necessary since I'm an ape\r\n        address(this).call(data);\r\n    }\r\n    function executeOperation(\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata _params\r\n    ) external {\r\n        // Added to support AAVE v1 flash loans natively\r\n        // Security checks aren't necessary since I'm an ape\r\n        address(this).call(_params);\r\n    }\r\n    function executeOperation(\r\n        address[] calldata,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        address,\r\n        bytes calldata params\r\n    )\r\n        external\r\n        returns (bool)\r\n    {\r\n        // Added to support AAVE v2 flash loans natively\r\n        // Security checks aren't necessary since I'm an ape\r\n        address(this).call(params);\r\n        return true;\r\n    }\r\n\r\n    function uniswapV2Call(\r\n        address,\r\n        uint,\r\n        uint,\r\n        bytes calldata data\r\n    ) external {\r\n        // Added to support uniswap v2 flash swaps natively\r\n        // Security checks aren't necessary since I'm an ape\r\n        address(this).call(data);\r\n    }\r\n    function uniswapV3FlashCallback(\r\n        uint256,\r\n        uint256,\r\n        bytes calldata data\r\n    ) external {\r\n        // Added to support uniswap v3 flash loans natively\r\n        // Security checks aren't necessary since I'm an ape\r\n        address(this).call(data);\r\n    }\r\n    function uniswapV3MintCallback(\r\n        uint256,\r\n        uint256,\r\n        bytes calldata data\r\n    ) external {\r\n        // Added to support uniswap v3 flash mints natively\r\n        // Security checks aren't necessary since I'm an ape\r\n        address(this).call(data);\r\n    }\r\n    function uniswapV3SwapCallback(\r\n        int256,\r\n        int256,\r\n        bytes calldata data\r\n    ) external {\r\n        // Added to support uniswap v3 flash swaps natively\r\n        // Security checks aren't necessary since I'm an ape\r\n        address(this).call(data);\r\n    }\r\n\r\n    // All funds left on this contract will be imidiately lost to snipers\r\n    // This function is completely permision-less and allows anyone to execute any arbitrary logic\r\n    // Overall goal is to make a contract which allows to execute all types of nested flash loans\r\n    function ape(uint256 actionFlags, uint256[] memory data) public payable {\r\n        // FLAGS are used to simplify some common actions, they aren't necessary\r\n        if ((actionFlags & (FLAG_TRANSFORM_ETH_TO_WETH_BEFORE_APE | FLAG_TRANSFORM_WETH_TO_ETH_BEFORE_APE)) > 0) {\r\n            if ((actionFlags & FLAG_TRANSFORM_ETH_TO_WETH_BEFORE_APE) > 0) {\r\n                uint selfbalance = address(this).balance;\r\n                if (selfbalance > 1) WETH9(TOKEN_WETH).deposit{value: selfbalance - 1}();\r\n            } else {\r\n                uint wethbalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\r\n                if (wethbalance > 1) WETH9(TOKEN_WETH).withdraw(wethbalance - 1);\r\n            }\r\n        }\r\n\r\n        uint callId = 0;\r\n        for (; callId < data.length;) {\r\n            assembly {\r\n                let callInfo := mload(add(data, mul(add(callId, 1), 0x20)))\r\n                let callLength := and(div(callInfo, 0x1000000000000000000000000000000000000000000000000000000), 0xffff)\r\n                let p := mload(0x40)   // Find empty storage location using \"free memory pointer\"\r\n                // Place signature at begining of empty storage, hacky logic to compute shift here\r\n                let callSignDataShiftResult := mul(and(callInfo, 0xffffffff0000000000000000000000000000000000000000000000), 0x10000000000)\r\n                switch callSignDataShiftResult\r\n                case 0 {\r\n                    callLength := mul(callLength, 0x20)\r\n                    callSignDataShiftResult := add(data, mul(0x20, add(callId, 3)))\r\n                    for { let i := 0 } lt(i, callLength) { i := add(i, 0x20) } {\r\n                        mstore(add(p, i), mload(add(callSignDataShiftResult, i)))\r\n                    }\r\n                }\r\n                default {\r\n                    mstore(p, callSignDataShiftResult)\r\n                    callLength := add(mul(callLength, 0x20), 4)\r\n                    callSignDataShiftResult := add(data, sub(mul(0x20, add(callId, 3)), 4))\r\n                    for { let i := 4 } lt(i, callLength) { i := add(i, 0x20) } {\r\n                        mstore(add(p, i), mload(add(callSignDataShiftResult, i)))\r\n                    }\r\n                }\r\n\r\n                mstore(0x40, add(p, add(callLength, 0x20)))\r\n                // new free pointer position after the output values of the called function.\r\n\r\n                let callContract := and(callInfo, 0xffffffffffffffffffffffffffffffffffffffff)\r\n                // Re-use callSignDataShiftResult as success\r\n                switch and(callInfo, 0xf000000000000000000000000000000000000000000000000000000000000000)\r\n                case 0x1000000000000000000000000000000000000000000000000000000000000000 {\r\n                    callSignDataShiftResult := delegatecall(\r\n                                    and(div(callInfo, 0x10000000000000000000000000000000000000000), 0xffffff), // allowed gas to use\r\n                                    callContract, // contract to execute\r\n                                    p,    // Inputs are at location p\r\n                                    callLength, //Inputs size\r\n                                    p,    //Store output over input\r\n                                    0x20) //Output is 32 bytes long\r\n                }\r\n                default {\r\n                    callSignDataShiftResult := call(\r\n                                    and(div(callInfo, 0x10000000000000000000000000000000000000000), 0xffffff), // allowed gas to use\r\n                                    callContract, // contract to execute\r\n                                    mload(add(data, mul(add(callId, 2), 0x20))), // wei value amount\r\n                                    p,    // Inputs are at location p\r\n                                    callLength, //Inputs size\r\n                                    p,    //Store output over input\r\n                                    0x20) //Output is 32 bytes long\r\n                }\r\n\r\n                callSignDataShiftResult := and(div(callInfo, 0x10000000000000000000000000000000000000000000000000000000000), 0xff)\r\n                if gt(callSignDataShiftResult, 0) {\r\n                    // We're copying call result as input to some futher call\r\n                    mstore(add(data, mul(callSignDataShiftResult, 0x20)), mload(p))\r\n                }\r\n                callId := add(callId, add(and(div(callInfo, 0x1000000000000000000000000000000000000000000000000000000), 0xffff), 2))\r\n                mstore(0x40, p) // Set storage pointer to empty space\r\n            }\r\n        }\r\n\r\n        // FLAGS are used to simplify some common actions, they aren't necessary\r\n        if ((actionFlags & (FLAG_TRANSFORM_ETH_TO_WETH_AFTER_APE | FLAG_TRANSFORM_WETH_TO_ETH_AFTER_APE)) > 0) {\r\n            if ((actionFlags & FLAG_TRANSFORM_ETH_TO_WETH_AFTER_APE) > 0) {\r\n                uint selfbalance = address(this).balance;\r\n                if (selfbalance > 1) WETH9(TOKEN_WETH).deposit{value: selfbalance - 1}();\r\n            } else {\r\n                uint wethbalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\r\n                if (wethbalance > 1) WETH9(TOKEN_WETH).withdraw(wethbalance - 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function signature 0x00000000\r\n    // Should be main entry point for any simple MEV searcher\r\n    // Though you can always use 'ape' function directly with general purpose logic\r\n    function wfjizxua(\r\n        uint256 actionFlags,\r\n        uint256[] calldata actionData\r\n    ) external payable returns(int256 ethProfitDelta) {\r\n        int256[4] memory balanceDeltas;\r\n        balanceDeltas[0] = int256(address(this).balance);\r\n        if ((actionFlags & (FLAG_WETH_ACCOUNTING | FLAG_USDC_ACCOUNTING | FLAG_DAI_ACCOUNTING)) > 0) {\r\n            // In general ACCOUNTING flags should be used only during simulation and not production to avoid wasting gas on oracle calls\r\n            if ((actionFlags & FLAG_WETH_ACCOUNTING) > 0) {\r\n                balanceDeltas[1] = int256(IERC20Token(TOKEN_WETH).balanceOf(address(this)));\r\n            }\r\n            if ((actionFlags & FLAG_USDC_ACCOUNTING) > 0) {\r\n                balanceDeltas[2] = int256(IERC20Token(TOKEN_USDC).balanceOf(address(this)));\r\n            }\r\n            if ((actionFlags & FLAG_DAI_ACCOUNTING) > 0) {\r\n                balanceDeltas[3] = int256(IERC20Token(TOKEN_DAI).balanceOf(address(this)));\r\n            }\r\n        }\r\n\r\n        if ((actionFlags & (FLAG_FLASH_DYDY_WETH | FLAG_FLASH_DYDY_USDC | FLAG_FLASH_DYDY_DAI)) > 0) {\r\n            // This simple logic only supports single token flashloans\r\n            // For multiple tokens or multiple providers you should use general purpose logic using 'ape' function\r\n            if ((actionFlags & FLAG_FLASH_DYDY_WETH) > 0) {\r\n                uint256 balanceToFlash = IERC20Token(TOKEN_WETH).balanceOf(PROXY_DYDX);\r\n                this.wrapWithDyDx(\r\n                    TOKEN_WETH,\r\n                    balanceToFlash - 1,\r\n                    IERC20Token(TOKEN_WETH).allowance(address(this), PROXY_DYDX) < balanceToFlash,\r\n                    abi.encodeWithSignature('ape(uint256,uint256[])', actionFlags, actionData)\r\n                );\r\n            } else if ((actionFlags & FLAG_FLASH_DYDY_USDC) > 0) {\r\n                uint256 balanceToFlash = IERC20Token(TOKEN_USDC).balanceOf(PROXY_DYDX);\r\n                this.wrapWithDyDx(\r\n                    TOKEN_USDC,\r\n                    balanceToFlash - 1,\r\n                    IERC20Token(TOKEN_USDC).allowance(address(this), PROXY_DYDX) < balanceToFlash,\r\n                    abi.encodeWithSignature('ape(uint256,uint256[])', actionFlags, actionData)\r\n                );\r\n            } else if ((actionFlags & FLAG_FLASH_DYDY_DAI) > 0) {\r\n                uint256 balanceToFlash = IERC20Token(TOKEN_DAI).balanceOf(PROXY_DYDX);\r\n                this.wrapWithDyDx(\r\n                    TOKEN_DAI,\r\n                    balanceToFlash - 1,\r\n                    IERC20Token(TOKEN_DAI).allowance(address(this), PROXY_DYDX) < balanceToFlash,\r\n                    abi.encodeWithSignature('ape(uint256,uint256[])', actionFlags, actionData)\r\n                );\r\n            }\r\n        } else {\r\n            this.ape(actionFlags, actionData);\r\n        }\r\n\r\n        if ((actionFlags & FLAG_EXIT_WETH) > 0) {\r\n            uint wethbalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\r\n            if (wethbalance > 1) WETH9(TOKEN_WETH).withdraw(wethbalance - 1);\r\n        }\r\n\r\n\r\n        ethProfitDelta = int256(address(this).balance) - balanceDeltas[0];\r\n        if ((actionFlags & (FLAG_WETH_ACCOUNTING | FLAG_USDC_ACCOUNTING | FLAG_DAI_ACCOUNTING)) > 0) {\r\n            if ((actionFlags & FLAG_WETH_ACCOUNTING) > 0) {\r\n                ethProfitDelta += int256(IERC20Token(TOKEN_WETH).balanceOf(address(this))) - balanceDeltas[1];\r\n            }\r\n            if ((actionFlags & FLAG_USDC_ACCOUNTING) > 0) {\r\n                ethProfitDelta += (int256(IERC20Token(TOKEN_USDC).balanceOf(address(this))) - balanceDeltas[2]) * IChainlinkAggregator(ORACLE_USDC).latestAnswer() / (1 ether);\r\n            }\r\n            if ((actionFlags & FLAG_DAI_ACCOUNTING) > 0) {\r\n                ethProfitDelta += (int256(IERC20Token(TOKEN_DAI).balanceOf(address(this))) - balanceDeltas[3]) * IChainlinkAggregator(ORACLE_DAI).latestAnswer() / (1 ether);\r\n            }\r\n        }\r\n\r\n\r\n        if ((actionFlags & FLAG_PAY_COINBASE_AMOUNT) > 0) {\r\n            uint selfbalance = address(this).balance;\r\n            uint amountToPay = actionFlags / 0x100000000000000000000000000000000;\r\n            if (selfbalance < amountToPay) {\r\n                // Attempting to cover the gap via WETH token\r\n                WETH9(TOKEN_WETH).withdraw(amountToPay - selfbalance);\r\n            }\r\n            payable(block.coinbase).transfer(amountToPay);\r\n        } else if ((actionFlags & FLAG_PAY_COINBASE_SHARE) > 0) {\r\n            uint selfbalance = address(this).balance;\r\n            uint amountToPay = (actionFlags / 0x100000000000000000000000000000000) * uint256(ethProfitDelta) / (1 ether);\r\n            if (selfbalance < amountToPay) {\r\n                // Attempting to cover the gap via WETH token\r\n                WETH9(TOKEN_WETH).withdraw(amountToPay - selfbalance);\r\n            }\r\n            payable(block.coinbase).transfer(amountToPay);\r\n        }\r\n\r\n        uint selfBalance = address(this).balance;\r\n        if (selfBalance > 1) payable(msg.sender).transfer(selfBalance - 1);\r\n        if ((actionFlags & (FLAG_RETURN_WETH | FLAG_RETURN_USDC | FLAG_RETURN_DAI)) > 0) {\r\n            // Majority of simple atomic arbs should just need ETH\r\n            if ((actionFlags & FLAG_RETURN_WETH) > 0) {\r\n                uint tokenBalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\r\n                if (tokenBalance > 1) IERC20Token(TOKEN_WETH).transfer(msg.sender, tokenBalance - 1);\r\n            }\r\n            if ((actionFlags & FLAG_RETURN_USDC) > 0) {\r\n                uint tokenBalance = IERC20Token(TOKEN_USDC).balanceOf(address(this));\r\n                if (tokenBalance > 1) IERC20Token(TOKEN_USDC).transfer(msg.sender, tokenBalance - 1);\r\n            }\r\n            if ((actionFlags & FLAG_RETURN_DAI) > 0) {\r\n                uint tokenBalance = IERC20Token(TOKEN_DAI).balanceOf(address(this));\r\n                if (tokenBalance > 1) IERC20Token(TOKEN_DAI).transfer(msg.sender, tokenBalance - 1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Types {\r\n    enum ActionType {\r\n        Deposit,   // supply tokens\r\n        Withdraw,  // borrow tokens\r\n        Transfer,  // transfer balance between accounts\r\n        Buy,       // buy an amount of some token (externally)\r\n        Sell,      // sell an amount of some token (externally)\r\n        Trade,     // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize,  // use excess tokens to zero-out a completely negative account\r\n        Call       // send arbitrary data to an address\r\n    }\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    struct AccountInfo {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n}\r\n\r\ncontract ISoloMargin {\r\n    function operate(Types.AccountInfo[] memory accounts, Types.ActionArgs[] memory actions) public {}\r\n    function getMarketTokenAddress(uint256 marketId) public view returns (address) {}\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    string public name;\r\n    string public symbol;\r\n    function decimals() public view returns (uint8) {}\r\n    function totalSupply() public view returns (uint256) {}\r\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\r\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {}\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {}\r\n}\r\n\r\ncontract WETH9 {\r\n    function deposit() public payable {}\r\n    function withdraw(uint wad) public {}\r\n}\r\n\r\ninterface IChainlinkAggregator {\r\n  function latestAnswer() external view returns (int256);\r\n}","ABI":"[{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actionFlags\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"name\":\"ape\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.AccountInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3FlashCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3MintCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actionFlags\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"actionData\",\"type\":\"uint256[]\"}],\"name\":\"wfjizxua\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"ethProfitDelta\",\"type\":\"int256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requiredToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requiredBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requiredApprove\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"wrapWithDyDx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ApeBot","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9e05f519090abef664db665b013c295921fb04914a21d86974860cc8843bbf91"}]}