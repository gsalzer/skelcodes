{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract ERC20 {\\n    using SafeMath for uint;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n    uint  public totalSupply;\\n    address public operator;\\n    address public pendingOperator;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n    mapping (address => bool) public minters;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint) public nonces;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event AddMinter(address indexed minter);\\n    event RemoveMinter(address indexed minter);\\n    event ChangeOperator(address indexed newOperator);\\n\\n    modifier onlyOperator {\\n        require(msg.sender == operator, \\\"ERC20:ONLY_OPERATOR\\\");\\n        _;\\n    }\\n\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) public {\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n        operator = msg.sender;\\n        uint chainId;\\n        assembly {\\n            chainId := chainid\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes(name)),\\n                keccak256(bytes('1')),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function setPendingOperator(address newOperator_) public onlyOperator {\\n        pendingOperator = newOperator_;\\n    }\\n\\n    function claimOperator() public {\\n        require(msg.sender == pendingOperator, \\\"ERC20:ONLY_PENDING_OPERATOR\\\");\\n        operator = pendingOperator;\\n        pendingOperator = address(0);\\n        emit ChangeOperator(operator);\\n    }\\n\\n    function addMinter(address minter_) public onlyOperator {\\n        minters[minter_] = true;\\n        emit AddMinter(minter_);\\n    }\\n\\n    function removeMinter(address minter_) public onlyOperator {\\n        minters[minter_] = false;\\n        emit RemoveMinter(minter_);\\n    }\\n\\n    function mint(address to, uint amount) public {\\n        require(minters[msg.sender] == true || msg.sender == operator, \\\"ERC20:ONLY_MINTERS_OR_OPERATOR\\\");\\n        _mint(to, amount);\\n    }\\n\\n    function burn(uint amount) public {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    function _mint(address to, uint value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        require(deadline >= block.timestamp, 'ERC20:EXPIRED');\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'ERC20:SIGNATURE_INVALID');\\n        _approve(owner, spender, value);\\n    }\\n}\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\r\\n\\r\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\r\\n// Subject to the MIT license.\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SAFEMATH:ADD_OVERFLOW\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, errorMessage);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot underflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SAFEMATH:SUB_UNDERFLOW\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot underflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SAFEMATH:MUL_OVERFLOW\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, errorMessage);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers.\\r\\n     * Reverts on division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers.\\r\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Stabilizer.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./ERC20.sol\\\";\\r\\n\\r\\ninterface IStrat {\\r\\n    function invest() external; // underlying amount must be sent from vault to strat address before\\r\\n    function divest(uint amount) external; // should send requested amount to vault directly, not less or more\\r\\n    function calcTotalValue() external returns (uint);\\r\\n    function underlying() external view returns (address);\\r\\n}\\r\\n\\r\\ncontract Stabilizer {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    uint public constant MAX_FEE = 1000; // 10%\\r\\n    uint public constant FEE_DENOMINATOR = 10000;\\r\\n    uint public buyFee;\\r\\n    uint public sellFee;\\r\\n    uint public supplyCap;\\r\\n    uint public supply;\\r\\n    ERC20 public synth;\\r\\n    ERC20 public reserve;\\r\\n    address public operator;\\r\\n    IStrat public strat;\\r\\n    address public governance;\\r\\n\\r\\n    constructor(ERC20 synth_, ERC20 reserve_, address gov_, uint buyFee_, uint sellFee_, uint supplyCap_) public {\\r\\n        require(buyFee_ <= MAX_FEE, \\\"STABILIZER:BUYFEE_TOO_HIGH\\\");\\r\\n        require(sellFee_ <= MAX_FEE, \\\"STABILIZER:SELLFEE_TOO_HIGH\\\");\\r\\n        synth = synth_;\\r\\n        reserve = reserve_;\\r\\n        governance = gov_;\\r\\n        buyFee = buyFee_;\\r\\n        sellFee = sellFee_;\\r\\n        operator = msg.sender;\\r\\n        supplyCap = supplyCap_;\\r\\n    }\\r\\n\\r\\n    modifier onlyOperator {\\r\\n        require(msg.sender == operator || msg.sender == governance, \\\"STABILIZER:ONLY_OPERATOR_OR_GOV\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyGovernance {\\r\\n        require(msg.sender == governance, \\\"STABILIZER:ONLY_GOV\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setOperator(address operator_) public {\\r\\n        require(msg.sender == governance || msg.sender == operator, \\\"STABILIZER:ONLY_GOV_OR_OPERATOR\\\");\\r\\n        require(operator_ != address(0), \\\"STABILIZER:NO_ADDRESS_ZERO\\\");\\r\\n        operator = operator_;\\r\\n    }\\r\\n\\r\\n    function setBuyFee(uint amount) public onlyGovernance {\\r\\n        require(amount <= MAX_FEE, \\\"STABILIZER:AMOUNT_TOO_HIGH\\\");\\r\\n        buyFee = amount;\\r\\n    }\\r\\n\\r\\n    function setSellFee(uint amount) public onlyGovernance {\\r\\n        require(amount <= MAX_FEE, \\\"STABILIZER:AMOUNT_TOO_HIGH\\\");\\r\\n        sellFee = amount;\\r\\n    }\\r\\n    \\r\\n    function setCap(uint amount) public onlyOperator {\\r\\n        supplyCap = amount;\\r\\n    }\\r\\n\\r\\n    function setGovernance(address gov_) public onlyGovernance {\\r\\n        require(gov_ != address(0), \\\"STABILIZER:NO_ADDRESS_ZERO\\\");\\r\\n        governance = gov_;\\r\\n    }\\r\\n\\r\\n    function setStrat(IStrat newStrat) public onlyGovernance {\\r\\n        require(newStrat.underlying() == address(reserve), \\\"STABILIZER:INVALID_STRAT\\\");\\r\\n        if(address(strat) != address(0)) {\\r\\n            uint prevTotalValue = strat.calcTotalValue();\\r\\n            strat.divest(prevTotalValue);\\r\\n        }\\r\\n        reserve.transfer(address(newStrat), reserve.balanceOf(address(this)));\\r\\n        newStrat.invest();\\r\\n        strat = newStrat;\\r\\n    }\\r\\n\\r\\n    function removeStrat() public onlyGovernance {\\r\\n        uint prevTotalValue = strat.calcTotalValue();\\r\\n        strat.divest(prevTotalValue);\\r\\n\\r\\n        strat = IStrat(address(0));\\r\\n    }\\r\\n\\r\\n    function takeProfit() public {\\r\\n        uint totalReserves = getTotalReserves();\\r\\n        if(totalReserves > supply) {\\r\\n            uint profit = totalReserves - supply; // underflow prevented by if condition\\r\\n            if(address(strat) != address(0)) {\\r\\n                uint bal = reserve.balanceOf(address(this));\\r\\n                if(bal < profit) {\\r\\n                    strat.divest(profit - bal); // underflow prevented by if condition\\r\\n                }\\r\\n            }\\r\\n            reserve.transfer(governance, profit);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function buy(uint amount) public {\\r\\n        require(supply.add(amount) <= supplyCap, \\\"STABILIZER:SUPPLY_EXCEEDED_CAP\\\");\\r\\n        if(address(strat) != address(0)) {\\r\\n            reserve.transferFrom(msg.sender, address(strat), amount);\\r\\n            strat.invest();\\r\\n        } else {\\r\\n            reserve.transferFrom(msg.sender, address(this), amount);\\r\\n        }\\r\\n\\r\\n        if(buyFee > 0) {\\r\\n            uint fee = amount.mul(buyFee).div(FEE_DENOMINATOR);\\r\\n            reserve.transferFrom(msg.sender, governance, fee);\\r\\n            emit Buy(msg.sender, amount, amount.add(fee));\\r\\n        } else {\\r\\n            emit Buy(msg.sender, amount, amount);\\r\\n        }\\r\\n\\r\\n        synth.mint(msg.sender, amount);\\r\\n        supply = supply.add(amount);\\r\\n    }\\r\\n\\r\\n    function sell(uint amount) public {\\r\\n        synth.transferFrom(msg.sender, address(this), amount);\\r\\n        synth.burn(amount);\\r\\n\\r\\n        uint reserveBal = reserve.balanceOf(address(this));\\r\\n        if(address(strat) != address(0) && reserveBal < amount) {\\r\\n            strat.divest(amount - reserveBal); // underflow prevented by if condition\\r\\n        }\\r\\n\\r\\n        uint afterFee;\\r\\n        if(sellFee > 0) {\\r\\n            uint fee = amount.mul(sellFee).div(FEE_DENOMINATOR);\\r\\n            afterFee = amount.sub(fee);\\r\\n            reserve.transfer(governance, fee);\\r\\n        } else {\\r\\n            afterFee = amount;\\r\\n        }\\r\\n        \\r\\n        reserve.transfer(msg.sender, afterFee);\\r\\n        supply = supply.sub(amount);\\r\\n        emit Sell(msg.sender, amount, afterFee);\\r\\n    }\\r\\n\\r\\n    function rescue(ERC20 token) public onlyGovernance {\\r\\n        require(token != reserve, \\\"STABILIZER:RESERVE_NOT_RESCUED\\\");\\r\\n        token.transfer(governance, token.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function getTotalReserves() internal returns (uint256 bal) { // new view function because strat.calcTotalValue() is not view function\\r\\n        bal = reserve.balanceOf(address(this));\\r\\n        if(address(strat) != address(0)) {\\r\\n            bal = bal.add(strat.calcTotalValue());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event Buy(address indexed user, uint purchased, uint spent);\\r\\n    event Sell(address indexed user, uint sold, uint received);\\r\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"synth_\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"reserve_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gov_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCap_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spent\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeStrat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBuyFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"gov_\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSellFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IStrat\",\"name\":\"newStrat\",\"type\":\"address\"}],\"name\":\"setStrat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strat\",\"outputs\":[{\"internalType\":\"contract IStrat\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synth\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"takeProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Stabilizer","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000003b471d24cec15829fa602d38b046b4f2e8cdaf00000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000001dd1fb688200be97d312399ece57cda7fdaa5aab000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000d3c21bcecceda1000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}