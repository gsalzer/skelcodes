{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.12;\r\n\r\n// SPDX-License-Identifier: MIT AND Apache-2.0\r\n\r\n// License: MIT\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Copied from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/solc-0.6/contracts/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n}\r\n\r\n\r\n// License: Apache-2.0\r\n\r\n/*\r\n* @author Hamdi Allam hamdi.allam97@gmail.com\r\n* Please reach out with any questions or concerns\r\n*/\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem item;   // Item that's being iterated over.\r\n        uint nextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\r\n    * @param self The iterator.\r\n    * @return The next element in the iteration.\r\n    */\r\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\r\n        require(hasNext(self));\r\n\r\n        uint ptr = self.nextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        self.nextPtr = ptr + itemLength;\r\n\r\n        return RLPItem(itemLength, ptr);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the iteration has more elements.\r\n    * @param self The iterator.\r\n    * @return true if the iteration has more elements.\r\n    */\r\n    function hasNext(Iterator memory self) internal pure returns (bool) {\r\n        RLPItem memory item = self.item;\r\n        return self.nextPtr < item.memPtr + item.len;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n    * @dev Create an iterator. Reverts if item is not a list.\r\n    * @param self The RLP item.\r\n    * @return An 'Iterator' over the item.\r\n    */\r\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\r\n        require(isList(self));\r\n\r\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\r\n        return Iterator(self, ptr);\r\n    }\r\n\r\n    /*\r\n    * @param the RLP item.\r\n    */\r\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len;\r\n    }\r\n\r\n    /*\r\n     * @param the RLP item.\r\n     * @return (memPtr, len) pair: location of the item's payload in memory.\r\n     */\r\n    function payloadLocation(RLPItem memory item) internal pure returns (uint, uint) {\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint memPtr = item.memPtr + offset;\r\n        uint len = item.len - offset; // data length\r\n        return (memPtr, len);\r\n    }\r\n\r\n    /*\r\n    * @param the RLP item.\r\n    */\r\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\r\n        (, uint len) = payloadLocation(item);\r\n        return len;\r\n    }\r\n\r\n    /*\r\n    * @param the RLP item containing the encoded list.\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        RLPItem[] memory result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr);\r\n            memPtr = memPtr + dataLen;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        if (item.len == 0) return false;\r\n\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\r\n     * @return keccak256 hash of RLP encoded bytes.\r\n     */\r\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\r\n        uint256 ptr = item.memPtr;\r\n        uint256 len = item.len;\r\n        bytes32 result;\r\n        assembly {\r\n            result := keccak256(ptr, len)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /*\r\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\r\n     * @return keccak256 hash of the item payload.\r\n     */\r\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\r\n        (uint memPtr, uint len) = payloadLocation(item);\r\n        bytes32 result;\r\n        assembly {\r\n            result := keccak256(memPtr, len)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        bytes memory result = new bytes(item.len);\r\n        if (result.length == 0) return result;\r\n\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    // any non-zero byte except \"0x80\" is considered true\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1);\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        // SEE Github Issue #5.\r\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\r\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\r\n        // here.\r\n        if (result == 0 || result == STRING_SHORT_START) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix\r\n        require(item.len == 21);\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        require(item.len > 0 && item.len <= 33);\r\n\r\n        (uint memPtr, uint len) = payloadLocation(item);\r\n\r\n        uint result;\r\n        assembly {\r\n            result := mload(memPtr)\r\n\r\n            // shfit to the correct location if neccesary\r\n            if lt(len, 32) {\r\n                result := div(result, exp(256, sub(32, len)))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // enforces 32 byte length\r\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\r\n        // one byte prefix\r\n        require(item.len == 33);\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + 1;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        require(item.len > 0);\r\n\r\n        (uint memPtr, uint len) = payloadLocation(item);\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(memPtr, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n    /*\r\n    * Private Helpers\r\n    */\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) private pure returns (uint) {\r\n        if (item.len == 0) return 0;\r\n\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n           count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) private pure returns (uint) {\r\n        uint itemLen;\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            itemLen = 1;\r\n\r\n        else if (byte0 < STRING_LONG_START)\r\n            itemLen = byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n\r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            itemLen = byte0 - LIST_SHORT_START + 1;\r\n        }\r\n\r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        return itemLen;\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) private pure {\r\n        if (len == 0) return;\r\n\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// License: MIT\r\n\r\n/**\r\n * Copied from https://github.com/lorenzb/proveth/blob/c74b20e/onchain/ProvethVerifier.sol\r\n * with minor performance and code style-related modifications.\r\n */\r\n\r\nlibrary MerklePatriciaProofVerifier {\r\n    using RLPReader for RLPReader.RLPItem;\r\n    using RLPReader for bytes;\r\n\r\n    /// @dev Validates a Merkle-Patricia-Trie proof.\r\n    ///      If the proof proves the inclusion of some key-value pair in the\r\n    ///      trie, the value is returned. Otherwise, i.e. if the proof proves\r\n    ///      the exclusion of a key from the trie, an empty byte array is\r\n    ///      returned.\r\n    /// @param rootHash is the Keccak-256 hash of the root node of the MPT.\r\n    /// @param path is the key of the node whose inclusion/exclusion we are\r\n    ///        proving.\r\n    /// @param stack is the stack of MPT nodes (starting with the root) that\r\n    ///        need to be traversed during verification.\r\n    /// @return value whose inclusion is proved or an empty byte array for\r\n    ///         a proof of exclusion\r\n    function extractProofValue(\r\n        bytes32 rootHash,\r\n        bytes memory path,\r\n        RLPReader.RLPItem[] memory stack\r\n    ) internal pure returns (bytes memory value) {\r\n        bytes memory mptKey = _decodeNibbles(path, 0);\r\n        uint256 mptKeyOffset = 0;\r\n\r\n        bytes32 nodeHashHash;\r\n        bytes memory rlpNode;\r\n        RLPReader.RLPItem[] memory node;\r\n\r\n        RLPReader.RLPItem memory rlpValue;\r\n\r\n        if (stack.length == 0) {\r\n            // Root hash of empty Merkle-Patricia-Trie\r\n            require(rootHash == 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421);\r\n            return new bytes(0);\r\n        }\r\n\r\n        // Traverse stack of nodes starting at root.\r\n        for (uint256 i = 0; i < stack.length; i++) {\r\n\r\n            // We use the fact that an rlp encoded list consists of some\r\n            // encoding of its length plus the concatenation of its\r\n            // *rlp-encoded* items.\r\n\r\n            // The root node is hashed with Keccak-256 ...\r\n            if (i == 0 && rootHash != stack[i].rlpBytesKeccak256()) {\r\n                revert();\r\n            }\r\n            // ... whereas all other nodes are hashed with the MPT\r\n            // hash function.\r\n            if (i != 0 && nodeHashHash != _mptHashHash(stack[i])) {\r\n                revert();\r\n            }\r\n            // We verified that stack[i] has the correct hash, so we\r\n            // may safely decode it.\r\n            node = stack[i].toList();\r\n\r\n            if (node.length == 2) {\r\n                // Extension or Leaf node\r\n\r\n                bool isLeaf;\r\n                bytes memory nodeKey;\r\n                (isLeaf, nodeKey) = _merklePatriciaCompactDecode(node[0].toBytes());\r\n\r\n                uint256 prefixLength = _sharedPrefixLength(mptKeyOffset, mptKey, nodeKey);\r\n                mptKeyOffset += prefixLength;\r\n\r\n                if (prefixLength < nodeKey.length) {\r\n                    // Proof claims divergent extension or leaf. (Only\r\n                    // relevant for proofs of exclusion.)\r\n                    // An Extension/Leaf node is divergent iff it \"skips\" over\r\n                    // the point at which a Branch node should have been had the\r\n                    // excluded key been included in the trie.\r\n                    // Example: Imagine a proof of exclusion for path [1, 4],\r\n                    // where the current node is a Leaf node with\r\n                    // path [1, 3, 3, 7]. For [1, 4] to be included, there\r\n                    // should have been a Branch node at [1] with a child\r\n                    // at 3 and a child at 4.\r\n\r\n                    // Sanity check\r\n                    if (i < stack.length - 1) {\r\n                        // divergent node must come last in proof\r\n                        revert();\r\n                    }\r\n\r\n                    return new bytes(0);\r\n                }\r\n\r\n                if (isLeaf) {\r\n                    // Sanity check\r\n                    if (i < stack.length - 1) {\r\n                        // leaf node must come last in proof\r\n                        revert();\r\n                    }\r\n\r\n                    if (mptKeyOffset < mptKey.length) {\r\n                        return new bytes(0);\r\n                    }\r\n\r\n                    rlpValue = node[1];\r\n                    return rlpValue.toBytes();\r\n                } else { // extension\r\n                    // Sanity check\r\n                    if (i == stack.length - 1) {\r\n                        // shouldn't be at last level\r\n                        revert();\r\n                    }\r\n\r\n                    if (!node[1].isList()) {\r\n                        // rlp(child) was at least 32 bytes. node[1] contains\r\n                        // Keccak256(rlp(child)).\r\n                        nodeHashHash = node[1].payloadKeccak256();\r\n                    } else {\r\n                        // rlp(child) was less than 32 bytes. node[1] contains\r\n                        // rlp(child).\r\n                        nodeHashHash = node[1].rlpBytesKeccak256();\r\n                    }\r\n                }\r\n            } else if (node.length == 17) {\r\n                // Branch node\r\n\r\n                if (mptKeyOffset != mptKey.length) {\r\n                    // we haven't consumed the entire path, so we need to look at a child\r\n                    uint8 nibble = uint8(mptKey[mptKeyOffset]);\r\n                    mptKeyOffset += 1;\r\n                    if (nibble >= 16) {\r\n                        // each element of the path has to be a nibble\r\n                        revert();\r\n                    }\r\n\r\n                    if (_isEmptyBytesequence(node[nibble])) {\r\n                        // Sanity\r\n                        if (i != stack.length - 1) {\r\n                            // leaf node should be at last level\r\n                            revert();\r\n                        }\r\n\r\n                        return new bytes(0);\r\n                    } else if (!node[nibble].isList()) {\r\n                        nodeHashHash = node[nibble].payloadKeccak256();\r\n                    } else {\r\n                        nodeHashHash = node[nibble].rlpBytesKeccak256();\r\n                    }\r\n                } else {\r\n                    // we have consumed the entire mptKey, so we need to look at what's contained in this node.\r\n\r\n                    // Sanity\r\n                    if (i != stack.length - 1) {\r\n                        // should be at last level\r\n                        revert();\r\n                    }\r\n\r\n                    return node[16].toBytes();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /// @dev Computes the hash of the Merkle-Patricia-Trie hash of the RLP item.\r\n    ///      Merkle-Patricia-Tries use a weird \"hash function\" that outputs\r\n    ///      *variable-length* hashes: If the item is shorter than 32 bytes,\r\n    ///      the MPT hash is the item. Otherwise, the MPT hash is the\r\n    ///      Keccak-256 hash of the item.\r\n    ///      The easiest way to compare variable-length byte sequences is\r\n    ///      to compare their Keccak-256 hashes.\r\n    /// @param item The RLP item to be hashed.\r\n    /// @return Keccak-256(MPT-hash(item))\r\n    function _mptHashHash(RLPReader.RLPItem memory item) private pure returns (bytes32) {\r\n        if (item.len < 32) {\r\n            return item.rlpBytesKeccak256();\r\n        } else {\r\n            return keccak256(abi.encodePacked(item.rlpBytesKeccak256()));\r\n        }\r\n    }\r\n\r\n    function _isEmptyBytesequence(RLPReader.RLPItem memory item) private pure returns (bool) {\r\n        if (item.len != 1) {\r\n            return false;\r\n        }\r\n        uint8 b;\r\n        uint256 memPtr = item.memPtr;\r\n        assembly {\r\n            b := byte(0, mload(memPtr))\r\n        }\r\n        return b == 0x80 /* empty byte string */;\r\n    }\r\n\r\n\r\n    function _merklePatriciaCompactDecode(bytes memory compact) private pure returns (bool isLeaf, bytes memory nibbles) {\r\n        require(compact.length > 0);\r\n        uint256 first_nibble = uint8(compact[0]) >> 4 & 0xF;\r\n        uint256 skipNibbles;\r\n        if (first_nibble == 0) {\r\n            skipNibbles = 2;\r\n            isLeaf = false;\r\n        } else if (first_nibble == 1) {\r\n            skipNibbles = 1;\r\n            isLeaf = false;\r\n        } else if (first_nibble == 2) {\r\n            skipNibbles = 2;\r\n            isLeaf = true;\r\n        } else if (first_nibble == 3) {\r\n            skipNibbles = 1;\r\n            isLeaf = true;\r\n        } else {\r\n            // Not supposed to happen!\r\n            revert();\r\n        }\r\n        return (isLeaf, _decodeNibbles(compact, skipNibbles));\r\n    }\r\n\r\n\r\n    function _decodeNibbles(bytes memory compact, uint256 skipNibbles) private pure returns (bytes memory nibbles) {\r\n        require(compact.length > 0);\r\n\r\n        uint256 length = compact.length * 2;\r\n        require(skipNibbles <= length);\r\n        length -= skipNibbles;\r\n\r\n        nibbles = new bytes(length);\r\n        uint256 nibblesLength = 0;\r\n\r\n        for (uint256 i = skipNibbles; i < skipNibbles + length; i += 1) {\r\n            if (i % 2 == 0) {\r\n                nibbles[nibblesLength] = bytes1((uint8(compact[i/2]) >> 4) & 0xF);\r\n            } else {\r\n                nibbles[nibblesLength] = bytes1((uint8(compact[i/2]) >> 0) & 0xF);\r\n            }\r\n            nibblesLength += 1;\r\n        }\r\n\r\n        assert(nibblesLength == nibbles.length);\r\n    }\r\n\r\n\r\n    function _sharedPrefixLength(uint256 xsOffset, bytes memory xs, bytes memory ys) private pure returns (uint256) {\r\n        uint256 i;\r\n        for (i = 0; i + xsOffset < xs.length && i < ys.length; i++) {\r\n            if (xs[i + xsOffset] != ys[i]) {\r\n                return i;\r\n            }\r\n        }\r\n        return i;\r\n    }\r\n}\r\n\r\n\r\n// License: MIT\r\n\r\n/**\r\n * @title A helper library for verification of Merkle Patricia account and state proofs.\r\n */\r\nlibrary Verifier {\r\n    using RLPReader for RLPReader.RLPItem;\r\n    using RLPReader for bytes;\r\n\r\n    uint256 constant HEADER_STATE_ROOT_INDEX = 3;\r\n    uint256 constant HEADER_NUMBER_INDEX = 8;\r\n    uint256 constant HEADER_TIMESTAMP_INDEX = 11;\r\n\r\n    struct BlockHeader {\r\n        bytes32 hash;\r\n        bytes32 stateRootHash;\r\n        uint256 number;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct Account {\r\n        bool exists;\r\n        uint256 nonce;\r\n        uint256 balance;\r\n        bytes32 storageRoot;\r\n        bytes32 codeHash;\r\n    }\r\n\r\n    struct SlotValue {\r\n        bool exists;\r\n        uint256 value;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Parses block header and verifies its presence onchain within the latest 256 blocks.\r\n     * @param _headerRlpBytes RLP-encoded block header.\r\n     */\r\n    function verifyBlockHeader(bytes memory _headerRlpBytes)\r\n        internal view returns (BlockHeader memory)\r\n    {\r\n        BlockHeader memory header = parseBlockHeader(_headerRlpBytes);\r\n        // ensure that the block is actually in the blockchain\r\n        require(header.hash == blockhash(header.number), \"blockhash mismatch\");\r\n        return header;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Parses RLP-encoded block header.\r\n     * @param _headerRlpBytes RLP-encoded block header.\r\n     */\r\n    function parseBlockHeader(bytes memory _headerRlpBytes)\r\n        internal pure returns (BlockHeader memory)\r\n    {\r\n        BlockHeader memory result;\r\n        RLPReader.RLPItem[] memory headerFields = _headerRlpBytes.toRlpItem().toList();\r\n\r\n        result.stateRootHash = bytes32(headerFields[HEADER_STATE_ROOT_INDEX].toUint());\r\n        result.number = headerFields[HEADER_NUMBER_INDEX].toUint();\r\n        result.timestamp = headerFields[HEADER_TIMESTAMP_INDEX].toUint();\r\n        result.hash = keccak256(_headerRlpBytes);\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Verifies Merkle Patricia proof of an account and extracts the account fields.\r\n     *\r\n     * @param _addressHash Keccak256 hash of the address corresponding to the account.\r\n     * @param _stateRootHash MPT root hash of the Ethereum state trie.\r\n     */\r\n    function extractAccountFromProof(\r\n        bytes32 _addressHash, // keccak256(abi.encodePacked(address))\r\n        bytes32 _stateRootHash,\r\n        RLPReader.RLPItem[] memory _proof\r\n    )\r\n        internal pure returns (Account memory)\r\n    {\r\n        bytes memory acctRlpBytes = MerklePatriciaProofVerifier.extractProofValue(\r\n            _stateRootHash,\r\n            abi.encodePacked(_addressHash),\r\n            _proof\r\n        );\r\n\r\n        Account memory account;\r\n\r\n        if (acctRlpBytes.length == 0) {\r\n            return account;\r\n        }\r\n\r\n        RLPReader.RLPItem[] memory acctFields = acctRlpBytes.toRlpItem().toList();\r\n        require(acctFields.length == 4);\r\n\r\n        account.exists = true;\r\n        account.nonce = acctFields[0].toUint();\r\n        account.balance = acctFields[1].toUint();\r\n        account.storageRoot = bytes32(acctFields[2].toUint());\r\n        account.codeHash = bytes32(acctFields[3].toUint());\r\n\r\n        return account;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Verifies Merkle Patricia proof of a slot and extracts the slot's value.\r\n     *\r\n     * @param _slotHash Keccak256 hash of the slot position.\r\n     * @param _storageRootHash MPT root hash of the account's storage trie.\r\n     */\r\n    function extractSlotValueFromProof(\r\n        bytes32 _slotHash,\r\n        bytes32 _storageRootHash,\r\n        RLPReader.RLPItem[] memory _proof\r\n    )\r\n        internal pure returns (SlotValue memory)\r\n    {\r\n        bytes memory valueRlpBytes = MerklePatriciaProofVerifier.extractProofValue(\r\n            _storageRootHash,\r\n            abi.encodePacked(_slotHash),\r\n            _proof\r\n        );\r\n\r\n        SlotValue memory value;\r\n\r\n        if (valueRlpBytes.length != 0) {\r\n            value.exists = true;\r\n            value.value = valueRlpBytes.toRlpItem().toUint();\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n}\r\n\r\n\r\n// License: MIT\r\n\r\n\r\ninterface IPriceHelper {\r\n    function get_dy(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256[2] memory xp,\r\n        uint256 A,\r\n        uint256 fee\r\n    ) external pure returns (uint256);\r\n}\r\n\r\n\r\ninterface IStableSwap {\r\n    function fee() external view returns (uint256);\r\n    function A_precise() external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title\r\n *   A trustless oracle for the stETH/ETH Curve pool using Merkle Patricia\r\n *   proofs of Ethereum state.\r\n *\r\n * @notice\r\n *   The oracle currently assumes that the pool's fee and A (amplification\r\n *   coefficient) values don't change between the time of proof generation\r\n *   and submission.\r\n */\r\ncontract StableSwapStateOracle {\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @notice Logs the updated slot values of Curve pool and stETH contracts.\r\n     */\r\n    event SlotValuesUpdated(\r\n        uint256 timestamp,\r\n        uint256 poolEthBalance,\r\n        uint256 poolAdminEthBalance,\r\n        uint256 poolAdminStethBalance,\r\n        uint256 stethPoolShares,\r\n        uint256 stethTotalShares,\r\n        uint256 stethBeaconBalance,\r\n        uint256 stethBufferedEther,\r\n        uint256 stethDepositedValidators,\r\n        uint256 stethBeaconValidators\r\n    );\r\n\r\n    /**\r\n     * @notice Logs the updated stETH and ETH pool balances and the calculated stETH/ETH price.\r\n     */\r\n    event PriceUpdated(\r\n        uint256 timestamp,\r\n        uint256 etherBalance,\r\n        uint256 stethBalance,\r\n        uint256 stethPrice\r\n    );\r\n\r\n    /**\r\n     * @notice Logs the updated price update threshold percentage advised to offchain clients.\r\n     */\r\n    event PriceUpdateThresholdChanged(uint256 threshold);\r\n\r\n    /**\r\n     * @notice\r\n     *   Logs the updated address having the right to change the advised price update threshold.\r\n     */\r\n    event AdminChanged(address admin);\r\n\r\n\r\n    /// @dev Reporting data that is more fresh than this number of blocks ago is prohibited\r\n    uint256 constant public MIN_BLOCK_DELAY = 15;\r\n\r\n    // Constants for offchain proof generation\r\n\r\n    address constant public POOL_ADDRESS = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\r\n    address constant public STETH_ADDRESS = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\r\n\r\n    /// @dev keccak256(abi.encodePacked(uint256(1)))\r\n    bytes32 constant public POOL_ADMIN_BALANCES_0_POS = 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6;\r\n\r\n    /// @dev bytes32(uint256(POOL_ADMIN_BALANCES_0_POS) + 1)\r\n    bytes32 constant public POOL_ADMIN_BALANCES_1_POS = 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf7;\r\n\r\n    /// @dev keccak256(uint256(0xdc24316b9ae028f1497c275eb9192a3ea0f67022) . uint256(0))\r\n    bytes32 constant public STETH_POOL_SHARES_POS = 0xae68078d7ee25b2b7bcb7d4b9fe9acf61f251fe08ff637df07889375d8385158;\r\n\r\n    /// @dev keccak256(\"lido.StETH.totalShares\")\r\n    bytes32 constant public STETH_TOTAL_SHARES_POS = 0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\r\n\r\n    /// @dev keccak256(\"lido.Lido.beaconBalance\")\r\n    bytes32 constant public STETH_BEACON_BALANCE_POS = 0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483;\r\n\r\n    /// @dev keccak256(\"lido.Lido.bufferedEther\")\r\n    bytes32 constant public STETH_BUFFERED_ETHER_POS = 0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0;\r\n\r\n    /// @dev keccak256(\"lido.Lido.depositedValidators\")\r\n    bytes32 constant public STETH_DEPOSITED_VALIDATORS_POS = 0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c;\r\n\r\n    /// @dev keccak256(\"lido.Lido.beaconValidators\")\r\n    bytes32 constant public STETH_BEACON_VALIDATORS_POS = 0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10;\r\n\r\n    // Constants for onchain proof verification\r\n\r\n    /// @dev keccak256(abi.encodePacked(POOL_ADDRESS))\r\n    bytes32 constant POOL_ADDRESS_HASH = 0xc70f76036d72b7bb865881e931082ea61bb4f13ec9faeb17f0591b18b6fafbd7;\r\n\r\n    /// @dev keccak256(abi.encodePacked(STETH_ADDRESS))\r\n    bytes32 constant STETH_ADDRESS_HASH = 0x6c958a912fe86c83262fbd4973f6bd042cef76551aaf679968f98665979c35e7;\r\n\r\n    /// @dev keccak256(abi.encodePacked(POOL_ADMIN_BALANCES_0_POS))\r\n    bytes32 constant POOL_ADMIN_BALANCES_0_HASH = 0xb5d9d894133a730aa651ef62d26b0ffa846233c74177a591a4a896adfda97d22;\r\n\r\n    /// @dev keccak256(abi.encodePacked(POOL_ADMIN_BALANCES_1_POS)\r\n    bytes32 constant POOL_ADMIN_BALANCES_1_HASH = 0xea7809e925a8989e20c901c4c1da82f0ba29b26797760d445a0ce4cf3c6fbd31;\r\n\r\n    /// @dev keccak256(abi.encodePacked(STETH_POOL_SHARES_POS)\r\n    bytes32 constant STETH_POOL_SHARES_HASH = 0xe841c8fb2710e169d6b63e1130fb8013d57558ced93619655add7aef8c60d4dc;\r\n\r\n    /// @dev keccak256(abi.encodePacked(STETH_TOTAL_SHARES_POS)\r\n    bytes32 constant STETH_TOTAL_SHARES_HASH = 0x4068b5716d4c00685289292c9cdc7e059e67159cd101476377efe51ba7ab8e9f;\r\n\r\n    /// @dev keccak256(abi.encodePacked(STETH_BEACON_BALANCE_POS)\r\n    bytes32 constant STETH_BEACON_BALANCE_HASH = 0xa6965d4729b36ed8b238f6ba55294196843f8be2850c5f63b6fb6d29181b50f8;\r\n\r\n    /// @dev keccak256(abi.encodePacked(STETH_BUFFERED_ETHER_POS)\r\n    bytes32 constant STETH_BUFFERED_ETHER_HASH = 0xa39079072910ef75f32ddc4f40104882abfc19580cc249c694e12b6de868ee1d;\r\n\r\n    /// @dev keccak256(abi.encodePacked(STETH_DEPOSITED_VALIDATORS_POS)\r\n    bytes32 constant STETH_DEPOSITED_VALIDATORS_HASH = 0x17216d3ffd8719eeee6d8052f7c1e6269bd92d2390d3e3fc4cde1f026e427fb3;\r\n\r\n    /// @dev keccak256(abi.encodePacked(STETH_BEACON_VALIDATORS_POS)\r\n    bytes32 constant STETH_BEACON_VALIDATORS_HASH = 0x6fd60d3960d8a32cbc1a708d6bf41bbce8152e61e72b2236d5e1ecede9c4cc72;\r\n\r\n    uint256 constant internal STETH_DEPOSIT_SIZE = 32 ether;\r\n\r\n    /**\r\n     * @dev A helper contract for calculating stETH/ETH price from its stETH and ETH balances.\r\n     */\r\n    IPriceHelper internal helper;\r\n\r\n    /**\r\n     * @notice The admin has the right to set the suggested price update threshold (see below).\r\n     */\r\n    address public admin;\r\n\r\n    /**\r\n     * @notice\r\n     *   The price update threshold percentage advised to oracle clients.\r\n     *   Expressed in basis points: 10000 BP equal to 100%, 100 BP to 1%.\r\n     *\r\n     * @dev\r\n     *   If the current price in the pool differs less than this, the clients are advised to\r\n     *   skip updating the oracle. However, this threshold is not enforced, so clients are\r\n     *   free to update the oracle with any valid price.\r\n     */\r\n    uint256 public priceUpdateThreshold;\r\n\r\n    /**\r\n     * @notice The timestamp of the proven pool state/price.\r\n     */\r\n    uint256 public timestamp;\r\n\r\n    /**\r\n     * @notice The proven ETH balance of the pool.\r\n     */\r\n    uint256 public etherBalance;\r\n\r\n    /**\r\n     * @notice The proven stETH balance of the pool.\r\n     */\r\n    uint256 public stethBalance;\r\n\r\n    /**\r\n     * @notice The proven stETH/ETH price in the pool.\r\n     */\r\n    uint256 public stethPrice;\r\n\r\n\r\n    /**\r\n     * @param _helper Address of the deployed instance of the StableSwapPriceHelper.vy contract.\r\n     * @param _admin The address that has the right to set the suggested price update threshold.\r\n     * @param _priceUpdateThreshold The initial value of the suggested price update threshold.\r\n     *        Expressed in basis points, 10000 BP corresponding to 100%.\r\n     */\r\n    constructor(IPriceHelper _helper, address _admin, uint256 _priceUpdateThreshold) public {\r\n        helper = _helper;\r\n        _setAdmin(_admin);\r\n        _setPriceUpdateThreshold(_priceUpdateThreshold);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Passes the right to set the suggested price update threshold to a new address.\r\n     */\r\n    function setAdmin(address _admin) external {\r\n        require(msg.sender == admin);\r\n        _setAdmin(_admin);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Sets the suggested price update threshold.\r\n     *\r\n     * @param _priceUpdateThreshold The suggested price update threshold.\r\n     *        Expressed in basis points, 10000 BP corresponding to 100%.\r\n     */\r\n    function setPriceUpdateThreshold(uint256 _priceUpdateThreshold) external {\r\n        require(msg.sender == admin);\r\n        _setPriceUpdateThreshold(_priceUpdateThreshold);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Retuens a set of values used by the clients for proof generation.\r\n     */\r\n    function getProofParams() external view returns (\r\n        address poolAddress,\r\n        address stethAddress,\r\n        bytes32 poolAdminEtherBalancePos,\r\n        bytes32 poolAdminCoinBalancePos,\r\n        bytes32 stethPoolSharesPos,\r\n        bytes32 stethTotalSharesPos,\r\n        bytes32 stethBeaconBalancePos,\r\n        bytes32 stethBufferedEtherPos,\r\n        bytes32 stethDepositedValidatorsPos,\r\n        bytes32 stethBeaconValidatorsPos,\r\n        uint256 advisedPriceUpdateThreshold\r\n    ) {\r\n        return (\r\n            POOL_ADDRESS,\r\n            STETH_ADDRESS,\r\n            POOL_ADMIN_BALANCES_0_POS,\r\n            POOL_ADMIN_BALANCES_1_POS,\r\n            STETH_POOL_SHARES_POS,\r\n            STETH_TOTAL_SHARES_POS,\r\n            STETH_BEACON_BALANCE_POS,\r\n            STETH_BUFFERED_ETHER_POS,\r\n            STETH_DEPOSITED_VALIDATORS_POS,\r\n            STETH_BEACON_VALIDATORS_POS,\r\n            priceUpdateThreshold\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * @return _timestamp The timestamp of the proven pool state/price.\r\n     * @return _etherBalance The proven ETH balance of the pool.\r\n     * @return _stethBalance The proven stETH balance of the pool.\r\n     * @return _stethPrice The proven stETH/ETH price in the pool.\r\n     */\r\n    function getState() external view returns (\r\n        uint256 _timestamp,\r\n        uint256 _etherBalance,\r\n        uint256 _stethBalance,\r\n        uint256 _stethPrice\r\n    ) {\r\n        return (timestamp, etherBalance, stethBalance, stethPrice);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Used by the offchain clients to submit the proof.\r\n     *\r\n     * @dev Reverts unless:\r\n     *   - the block the submitted data corresponds to is in the chain;\r\n     *   - the block is at least `MIN_BLOCK_DELAY` blocks old;\r\n     *   - all submitted proofs are valid.\r\n     *\r\n     * @param _blockHeaderRlpBytes RLP-encoded block header.\r\n     *\r\n     * @param _proofRlpBytes RLP-encoded list of Merkle Patricia proofs:\r\n     *    1. proof of the Curve pool contract account;\r\n     *    2. proof of the stETH contract account;\r\n     *    3. proof of the `admin_balances[0]` slot of the Curve pool contract;\r\n     *    4. proof of the `admin_balances[1]` slot of the Curve pool contract;\r\n     *    5. proof of the `shares[0xDC24316b9AE028F1497c275EB9192a3Ea0f67022]` slot of stETH contract;\r\n     *    6. proof of the `keccak256(\"lido.StETH.totalShares\")` slot of stETH contract;\r\n     *    7. proof of the `keccak256(\"lido.Lido.beaconBalance\")` slot of stETH contract;\r\n     *    8. proof of the `keccak256(\"lido.Lido.bufferedEther\")` slot of stETH contract;\r\n     *    9. proof of the `keccak256(\"lido.Lido.depositedValidators\")` slot of stETH contract;\r\n     *   10. proof of the `keccak256(\"lido.Lido.beaconValidators\")` slot of stETH contract.\r\n     */\r\n    function submitState(bytes memory _blockHeaderRlpBytes, bytes memory _proofRlpBytes)\r\n        external\r\n    {\r\n        Verifier.BlockHeader memory blockHeader = Verifier.verifyBlockHeader(_blockHeaderRlpBytes);\r\n\r\n        {\r\n            uint256 currentBlock = block.number;\r\n            // ensure block finality\r\n            require(\r\n                currentBlock > blockHeader.number &&\r\n                currentBlock - blockHeader.number >= MIN_BLOCK_DELAY,\r\n                \"block too fresh\"\r\n            );\r\n        }\r\n\r\n        require(blockHeader.timestamp > timestamp, \"stale data\");\r\n\r\n        RLPReader.RLPItem[] memory proofs = _proofRlpBytes.toRlpItem().toList();\r\n        require(proofs.length == 10, \"total proofs\");\r\n\r\n        Verifier.Account memory accountPool = Verifier.extractAccountFromProof(\r\n            POOL_ADDRESS_HASH,\r\n            blockHeader.stateRootHash,\r\n            proofs[0].toList()\r\n        );\r\n\r\n        require(accountPool.exists, \"accountPool\");\r\n\r\n        Verifier.Account memory accountSteth = Verifier.extractAccountFromProof(\r\n            STETH_ADDRESS_HASH,\r\n            blockHeader.stateRootHash,\r\n            proofs[1].toList()\r\n        );\r\n\r\n        require(accountSteth.exists, \"accountSteth\");\r\n\r\n        Verifier.SlotValue memory slotPoolAdminBalances0 = Verifier.extractSlotValueFromProof(\r\n            POOL_ADMIN_BALANCES_0_HASH,\r\n            accountPool.storageRoot,\r\n            proofs[2].toList()\r\n        );\r\n\r\n        require(slotPoolAdminBalances0.exists, \"adminBalances0\");\r\n\r\n        Verifier.SlotValue memory slotPoolAdminBalances1 = Verifier.extractSlotValueFromProof(\r\n            POOL_ADMIN_BALANCES_1_HASH,\r\n            accountPool.storageRoot,\r\n            proofs[3].toList()\r\n        );\r\n\r\n        require(slotPoolAdminBalances1.exists, \"adminBalances1\");\r\n\r\n        Verifier.SlotValue memory slotStethPoolShares = Verifier.extractSlotValueFromProof(\r\n            STETH_POOL_SHARES_HASH,\r\n            accountSteth.storageRoot,\r\n            proofs[4].toList()\r\n        );\r\n\r\n        require(slotStethPoolShares.exists, \"poolShares\");\r\n\r\n        Verifier.SlotValue memory slotStethTotalShares = Verifier.extractSlotValueFromProof(\r\n            STETH_TOTAL_SHARES_HASH,\r\n            accountSteth.storageRoot,\r\n            proofs[5].toList()\r\n        );\r\n\r\n        require(slotStethTotalShares.exists, \"totalShares\");\r\n\r\n        Verifier.SlotValue memory slotStethBeaconBalance = Verifier.extractSlotValueFromProof(\r\n            STETH_BEACON_BALANCE_HASH,\r\n            accountSteth.storageRoot,\r\n            proofs[6].toList()\r\n        );\r\n\r\n        require(slotStethBeaconBalance.exists, \"beaconBalance\");\r\n\r\n        Verifier.SlotValue memory slotStethBufferedEther = Verifier.extractSlotValueFromProof(\r\n            STETH_BUFFERED_ETHER_HASH,\r\n            accountSteth.storageRoot,\r\n            proofs[7].toList()\r\n        );\r\n\r\n        require(slotStethBufferedEther.exists, \"bufferedEther\");\r\n\r\n        Verifier.SlotValue memory slotStethDepositedValidators = Verifier.extractSlotValueFromProof(\r\n            STETH_DEPOSITED_VALIDATORS_HASH,\r\n            accountSteth.storageRoot,\r\n            proofs[8].toList()\r\n        );\r\n\r\n        require(slotStethDepositedValidators.exists, \"depositedValidators\");\r\n\r\n        Verifier.SlotValue memory slotStethBeaconValidators = Verifier.extractSlotValueFromProof(\r\n            STETH_BEACON_VALIDATORS_HASH,\r\n            accountSteth.storageRoot,\r\n            proofs[9].toList()\r\n        );\r\n\r\n        require(slotStethBeaconValidators.exists, \"beaconValidators\");\r\n\r\n        emit SlotValuesUpdated(\r\n            blockHeader.timestamp,\r\n            accountPool.balance,\r\n            slotPoolAdminBalances0.value,\r\n            slotPoolAdminBalances1.value,\r\n            slotStethPoolShares.value,\r\n            slotStethTotalShares.value,\r\n            slotStethBeaconBalance.value,\r\n            slotStethBufferedEther.value,\r\n            slotStethDepositedValidators.value,\r\n            slotStethBeaconValidators.value\r\n        );\r\n\r\n        uint256 newEtherBalance = accountPool.balance.sub(slotPoolAdminBalances0.value);\r\n        uint256 newStethBalance = _getStethBalanceByShares(\r\n            slotStethPoolShares.value,\r\n            slotStethTotalShares.value,\r\n            slotStethBeaconBalance.value,\r\n            slotStethBufferedEther.value,\r\n            slotStethDepositedValidators.value,\r\n            slotStethBeaconValidators.value\r\n        ).sub(slotPoolAdminBalances1.value);\r\n\r\n        uint256 newStethPrice = _calcPrice(newEtherBalance, newStethBalance);\r\n\r\n        timestamp = blockHeader.timestamp;\r\n        etherBalance = newEtherBalance;\r\n        stethBalance = newStethBalance;\r\n        stethPrice = newStethPrice;\r\n\r\n        emit PriceUpdated(blockHeader.timestamp, newEtherBalance, newStethBalance, newStethPrice);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Given the values of stETH smart contract slots, calculates the amount of stETH owned\r\n     *      by the Curve pool by reproducing calculations performed in the stETH contract.\r\n     */\r\n    function _getStethBalanceByShares(\r\n        uint256 _shares,\r\n        uint256 _totalShares,\r\n        uint256 _beaconBalance,\r\n        uint256 _bufferedEther,\r\n        uint256 _depositedValidators,\r\n        uint256 _beaconValidators\r\n    )\r\n        internal pure returns (uint256)\r\n    {\r\n        // https://github.com/lidofinance/lido-dao/blob/v1.0.0/contracts/0.4.24/StETH.sol#L283\r\n        // https://github.com/lidofinance/lido-dao/blob/v1.0.0/contracts/0.4.24/Lido.sol#L719\r\n        // https://github.com/lidofinance/lido-dao/blob/v1.0.0/contracts/0.4.24/Lido.sol#L706\r\n        if (_totalShares == 0) {\r\n            return 0;\r\n        }\r\n        uint256 transientBalance = _depositedValidators.sub(_beaconValidators).mul(STETH_DEPOSIT_SIZE);\r\n        uint256 totalPooledEther = _bufferedEther.add(_beaconBalance).add(transientBalance);\r\n        return _shares.mul(totalPooledEther).div(_totalShares);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Given the ETH and stETH balances of the Curve pool, calculates the corresponding\r\n     *      stETH/ETH price by reproducing calculations performed in the pool contract.\r\n     */\r\n    function _calcPrice(uint256 _etherBalance, uint256 _stethBalance) internal view returns (uint256) {\r\n        uint256 A = IStableSwap(POOL_ADDRESS).A_precise();\r\n        uint256 fee = IStableSwap(POOL_ADDRESS).fee();\r\n        return helper.get_dy(1, 0, 10**18, [_etherBalance, _stethBalance], A, fee);\r\n    }\r\n\r\n\r\n    function _setPriceUpdateThreshold(uint256 _priceUpdateThreshold) internal {\r\n        require(_priceUpdateThreshold <= 10000);\r\n        priceUpdateThreshold = _priceUpdateThreshold;\r\n        emit PriceUpdateThresholdChanged(_priceUpdateThreshold);\r\n    }\r\n\r\n\r\n    function _setAdmin(address _admin) internal {\r\n        require(_admin != address(0));\r\n        require(_admin != admin);\r\n        admin = _admin;\r\n        emit AdminChanged(_admin);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IPriceHelper\",\"name\":\"_helper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_priceUpdateThreshold\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"PriceUpdateThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"etherBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stethBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stethPrice\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolEthBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolAdminEthBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolAdminStethBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stethPoolShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stethTotalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stethBeaconBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stethBufferedEther\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stethDepositedValidators\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stethBeaconValidators\",\"type\":\"uint256\"}],\"name\":\"SlotValuesUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_BLOCK_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_ADMIN_BALANCES_0_POS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_ADMIN_BALANCES_1_POS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STETH_BEACON_BALANCE_POS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STETH_BEACON_VALIDATORS_POS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STETH_BUFFERED_ETHER_POS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STETH_DEPOSITED_VALIDATORS_POS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STETH_POOL_SHARES_POS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STETH_TOTAL_SHARES_POS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etherBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProofParams\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stethAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"poolAdminEtherBalancePos\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"poolAdminCoinBalancePos\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stethPoolSharesPos\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stethTotalSharesPos\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stethBeaconBalancePos\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stethBufferedEtherPos\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stethDepositedValidatorsPos\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stethBeaconValidatorsPos\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"advisedPriceUpdateThreshold\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_etherBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stethBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stethPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceUpdateThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceUpdateThreshold\",\"type\":\"uint256\"}],\"name\":\"setPriceUpdateThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stethBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stethPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_blockHeaderRlpBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_proofRlpBytes\",\"type\":\"bytes\"}],\"name\":\"submitState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StableSwapStateOracle","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fef762dfdc87f79879aaef221a6a5d302833fe27000000000000000000000000e19fc582dd93fa876cf4061eb5456f310144f57b00000000000000000000000000000000000000000000000000000000000001f4","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://095da2537f60d3d5845a4a76859503b83425e5f1d2b667b113624fbfc887af03"}]}