{"status":"1","message":"OK","result":[{"SourceCode":"{\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor(){\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\\n\\n\\n\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n\"},\"SCoinPublicSale.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ninterface OracleInterface{\\n    function getPrice(string memory _currencySymbol) external  view returns(int256);    \\n    function doesCurrencyExists (string memory _currencySymbol) external view returns(bool);\\n}\\n\\ninterface Token{\\n    function transferOwnership(address newOwner) external;\\n    function stop() external;\\n    function start() external;\\n    function close() external;\\n    function decimals() external view returns(uint256);\\n    function symbol() external view returns(string memory);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function mint( address to, uint256 value ) external returns (bool);\\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\\n    function burn(uint256 _value) external;\\n    function owner() external returns(address);\\n}\\n\\ncontract SCoinPublicSale is Ownable{\\n\\n    using SafeMath for uint256;\\n    // Default active phase i.e 1st one\\n    uint256 public defaultActivePhase=1;\\n    uint public phaseTime=1 days;\\n    uint public phaseCount=16;\\n    uint public hardcap = 60000000000000000000000000000;\\n    uint public softcap=6000000000000000000000000000;\\n    uint public softcapTimestamp;\\n    // currentcap is just to store the cap till it reaches softcap\\n    uint public currentCap;\\n    uint[] tempArray;\\n    \\n    \\n    // Store number of tokens sold in each phase\\n    mapping(uint256=\\u003euint256) public tokensSoldInEachPhase;\\n    \\n    // Decimal factor for token price \\n    uint256 decimalFactorTokenPrice=10**3;\\n    uint256 decimalFactor;\\n    \\n    uint256 userPurchaseTokens;\\n    \\n    struct PhasesInfo{\\n        uint256 tokenSaleLimit;\\n        uint256 price;\\n    }\\n    mapping( uint256 =\\u003e PhasesInfo ) public listOfPhases;\\n    mapping(uint=\\u003euint) public phaseToEndTimes;\\n    \\n    \\n    address public tokenContractAddress= 0x1dfed394649BdCF973554Db52fE903f9e5e534a2;\\n    address public oracleWrapperAddress= 0x68E6d0ff31265a967603254a2254e5649675cD26;\\n    address public usdtContractAddress= 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address payable public adminAddress= 0x33dFAC456A6884B50872ac26C0C968DE6E442ffa;\\n    \\n    uint256 public  currentTimeStamp;\\n    event TokenSold(uint256 tokenPurchasedAmount, address indexed userAddress, uint256 timestamp, uint256 typeOf,uint256 ethAmount);\\n\\n    constructor(){\\n        decimalFactor=10**Token(tokenContractAddress).decimals();\\n        currentTimeStamp=block.timestamp;\\n        listOfPhases[1]=PhasesInfo({tokenSaleLimit:60000000*decimalFactor,price:60}); // phase1 , i.e 100/10**3=0.1\\n        listOfPhases[2]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:150}); // phase2 \\n        listOfPhases[3]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:170}); // phase3 \\n        listOfPhases[4]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:180}); // phase4 \\n        listOfPhases[5]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:200}); // phase5 \\n        \\n        listOfPhases[6]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:230}); // phase6 10% of 2.5M\\n        listOfPhases[7]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:260}); // phase7 10% of left over\\n        listOfPhases[8]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:290}); // phase8 10% of  left over\\n        listOfPhases[9]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:320}); // phase9 10% of  left over\\n        listOfPhases[10]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:350}); // phase11 10% of  left over\\n        listOfPhases[11]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:390}); // phase12 10% of  left over\\n        listOfPhases[12]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:440}); // phase13 10% of  left over\\n        listOfPhases[13]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:480}); // phase14 10% of  left over\\n        listOfPhases[14]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:530}); // phase14 10% of  left over\\n        listOfPhases[15]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:580}); // phase14 10% of  left over\\n        listOfPhases[16]=PhasesInfo({tokenSaleLimit:20000000*decimalFactor,price:630}); // phase14 10% of  left over\\n        \\n        // set the phase end timestamp\\n        phaseToEndTimes[1]=currentTimeStamp+(20*phaseTime);\\n        \\n        for(uint i=2;i\\u003c=phaseCount;i++){\\n            uint lastPhaseEndTime= phaseToEndTimes[i-1];\\n            phaseToEndTimes[i]= lastPhaseEndTime+(10*phaseTime);\\n        }\\n        \\n    }\\n\\n \\n    // 1\\n    // Get active phase token price\\n    function activePhasePrice() internal returns (uint256 ) {\\n        \\n        Token tObj= Token(tokenContractAddress);\\n        uint256 currentPhaseAsPerDate  = activePhase();\\n        require(currentPhaseAsPerDate!=0,\\\"ICO completed\\\");\\n        if(currentPhaseAsPerDate == defaultActivePhase){\\n            if(soldTokenInfo(currentPhaseAsPerDate)==listOfPhases[currentPhaseAsPerDate].tokenSaleLimit){\\n                require(tObj.balanceOf(address(this))\\u003e0,\\\"All tokens have been sold.\\\");\\n                defaultActivePhase = defaultActivePhase.add(1);\\n                return listOfPhases[defaultActivePhase].price;\\n            }else{\\n                return (listOfPhases[defaultActivePhase].price);\\n            }\\n        }else if(currentPhaseAsPerDate\\u003edefaultActivePhase){\\n            uint256 carryOverTokens;\\n            for(uint256 i=defaultActivePhase;i\\u003ccurrentPhaseAsPerDate;i++){\\n                carryOverTokens+=listOfPhases[i].tokenSaleLimit.sub(soldTokenInfo(i));\\n            }\\n            listOfPhases[currentPhaseAsPerDate].tokenSaleLimit+=carryOverTokens;\\n            defaultActivePhase = currentPhaseAsPerDate;\\n            return listOfPhases[defaultActivePhase].price;\\n        }else{\\n            return listOfPhases[defaultActivePhase].price;\\n        }\\n    }\\n    \\n    // Get active phase as per current date timestamp\\n    function activePhase() public view returns (uint256){\\n        uint _currentTimeStamp=block.timestamp;\\n        for(uint i=1;i\\u003c=phaseCount;i++){\\n            if(_currentTimeStamp\\u003c=phaseToEndTimes[i]){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    // Get total number of tokens sold per phase\\n    function soldTokenInfo(uint256  _phase) public view returns (uint256){\\n        return tokensSoldInEachPhase[_phase];\\n    }\\n    \\n    // Buy tokens \\n    function buyTokens(uint typeOf , uint256 _tokenAmount) public  payable {\\n        \\n        // if typeOf==1 , buy tokens using eth\\n        if(typeOf == 1){\\n            require(msg.value\\u003e0,\\u0027Eth amount cannot be zero.\\u0027);\\n            OracleInterface oObj = OracleInterface(oracleWrapperAddress);\\n            uint256 currentEthPrice=uint256(oObj.getPrice(\\u0027ETH\\u0027)); // eth price in usd\\n            uint256 priceOfEthInDollar=(msg.value).mul(currentEthPrice); // price in dollar with 10**8\\n            uint256 currentTokenPrice = activePhasePrice(); // token current price in usd\\n            userPurchaseTokens=0;\\n            getPurchasedTokensAmount(priceOfEthInDollar,currentTokenPrice, defaultActivePhase,typeOf);\\n            \\n            // updating the softcap variable to reflect the amount of tokens sold\\n            if(currentCap\\u003csoftcap){\\n                currentCap=currentCap.add(userPurchaseTokens.mul(currentTokenPrice));\\n                \\n                if(currentCap\\u003e=softcap){\\n                    softcapTimestamp=block.timestamp;\\n                }\\n            }\\n            // softcap= softcap.add(userPurchaseTokens.mul(currentTokenPrice));\\n           \\n            Token tObj= Token(tokenContractAddress);\\n            tObj.transfer(msg.sender,userPurchaseTokens);\\n            adminAddress.transfer(msg.value);\\n            \\n            \\n            emit TokenSold(userPurchaseTokens,msg.sender,block.timestamp,typeOf, msg.value);\\n            userPurchaseTokens=0;\\n            \\n        }else {\\n            // if typeof ==2 , buy tokens using usdt \\n            require(_tokenAmount\\u003e0,\\u0027Token amount cannot be zero.\\u0027);\\n             Token usdtContractObj = Token(usdtContractAddress);\\n             require(usdtContractObj.allowance(msg.sender,address(this))\\u003e=_tokenAmount,\\u0027USDT Tokens not approved.\\u0027);\\n    \\n             OracleInterface oObj = OracleInterface(oracleWrapperAddress);\\n            uint256 currentUsdtPrice=uint256(oObj.getPrice(\\u0027USDT\\u0027)); // USDT price in usd\\n            uint256 priceOfUsdtInDollar=(_tokenAmount).mul(currentUsdtPrice); // price in dollar with 10**8\\n            uint256 currentTokenPrice = activePhasePrice(); // token current price in usd\\n            userPurchaseTokens=0;\\n            getPurchasedTokensAmount(priceOfUsdtInDollar,currentTokenPrice, defaultActivePhase,typeOf);\\n            \\n            // updating the softcap variable to reflect the amount of tokens sold\\n             if(currentCap\\u003csoftcap){\\n                currentCap=currentCap.add(userPurchaseTokens.mul(currentTokenPrice));\\n                \\n                if(currentCap\\u003e=softcap){\\n                    softcapTimestamp=block.timestamp;\\n                }\\n            }  \\n          \\n            Token tObj= Token(tokenContractAddress);\\n            // send usdt to contract\\n            usdtContractObj.transferFrom(msg.sender,adminAddress,_tokenAmount);\\n            // contract sends scoin to user\\n            tObj.transfer(msg.sender,userPurchaseTokens);\\n            \\n            emit TokenSold(userPurchaseTokens,msg.sender,block.timestamp,typeOf,_tokenAmount);\\n            userPurchaseTokens=0;\\n        }\\n    }\\n\\n    function getPurchasedTokensAmount(uint256 priceOfEthInDollar,uint256 currentTokenPrice, uint256 phase,uint typeOf) internal{\\n        uint256 noOfTokenAccordingToCurrentPhase;\\n        uint256 currentDecimalFactor;\\n       \\n        if(typeOf==1){\\n            currentDecimalFactor= 10**18;\\n        }else {\\n            Token usdtContractObj = Token(usdtContractAddress);\\n            currentDecimalFactor= 10**(usdtContractObj.decimals());\\n        }\\n        noOfTokenAccordingToCurrentPhase=(priceOfEthInDollar.mul(decimalFactorTokenPrice).mul(decimalFactor))\\n                                                    .div(currentTokenPrice\\n                                                    .mul(10**8)\\n                                                    .mul(currentDecimalFactor)); // no of tokens that can be purchased from current phase\\n        \\n        if(listOfPhases[phase].tokenSaleLimit.sub(soldTokenInfo(phase)) \\u003e=noOfTokenAccordingToCurrentPhase){\\n            userPurchaseTokens+=noOfTokenAccordingToCurrentPhase;\\n            tokensSoldInEachPhase[phase]+=noOfTokenAccordingToCurrentPhase;\\n        }else{\\n            uint256 noOfTokenLeftInCurrentPhase=listOfPhases[phase].tokenSaleLimit.sub(soldTokenInfo(phase));\\n            userPurchaseTokens+=noOfTokenLeftInCurrentPhase;\\n            tokensSoldInEachPhase[phase]+=noOfTokenLeftInCurrentPhase;\\n            uint256 priceOfCurrentLeftToken=(noOfTokenLeftInCurrentPhase.mul(currentTokenPrice)).div(10**3);\\n            uint256 dollarLeft=priceOfEthInDollar.sub(priceOfCurrentLeftToken.mul(10**8));\\n            if(dollarLeft\\u003e0){\\n                defaultActivePhase = phase.add(1);\\n                getPurchasedTokensAmount(dollarLeft,listOfPhases[defaultActivePhase].price,defaultActivePhase,typeOf);\\n            }\\n        }\\n    }\\n    \\n    function estimatedToken(uint256 amount,uint typeOf) public view returns(uint256){\\n        OracleInterface oObj = OracleInterface(oracleWrapperAddress);\\n        require(oObj.doesCurrencyExists(typeOf==1?\\\"ETH\\\":\\\"USDT\\\"),\\u0027Invalid currency.\\u0027);\\n        uint256 currentCurrencyPrice=uint256(oObj.getPrice(typeOf==1?\\\"ETH\\\":\\\"USDT\\\")); // eth  OR USDT price in usd\\n        \\n\\n        uint256 priceOfUsedCurrencyInDollar=(amount).mul(currentCurrencyPrice);\\n        uint256 currentTokenPrice=listOfPhases[defaultActivePhase].price;\\n        \\n        uint256 currentDecimalFactor;\\n        if(typeOf==1){\\n            currentDecimalFactor= 10**18;\\n        }else {\\n            Token usdtContractObj = Token(usdtContractAddress);\\n             currentDecimalFactor= 10**(usdtContractObj.decimals());\\n\\n        }\\n        uint256 noOfTokenAccordingToCurrentPhase=(priceOfUsedCurrencyInDollar.mul(decimalFactorTokenPrice).mul(decimalFactor))\\n                                                    .div(currentTokenPrice\\n                                                        .mul(10**8)\\n                                                        .mul(currentDecimalFactor));\\n        return noOfTokenAccordingToCurrentPhase;\\n    }\\n    \\n    // function to send rewards after ico is finished\\n    function sendRewards() public onlyOwner returns (bool){\\n        require(activePhase()==0,\\u0027ICO not completed yet.\\u0027);\\n        \\n        Token tObj= Token(tokenContractAddress);\\n            \\n        tObj.transfer(adminAddress,tObj.balanceOf(address(this)));\\n        return true;\\n        \\n    }\\n    \\n    function updateOracleWrapperAddress(address _oracleWrapperAddress) public onlyOwner{\\n        oracleWrapperAddress=_oracleWrapperAddress;\\n    }\\n    \\n    function adminContractAddress(address payable _adminAddress) public onlyOwner{\\n        adminAddress=_adminAddress;\\n    }\\n    \\n    function updateUsdtContractAddress(address _usdtAddress) public onlyOwner{\\n        require(_usdtAddress!=address(0),\\u0027Invalid address.\\u0027);\\n        usdtContractAddress= _usdtAddress;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPurchasedAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"typeOf\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activePhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_adminAddress\",\"type\":\"address\"}],\"name\":\"adminContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeOf\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultActivePhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"typeOf\",\"type\":\"uint256\"}],\"name\":\"estimatedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardcap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listOfPhases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSaleLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleWrapperAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phaseCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phaseToEndTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"softcap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"softcapTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_phase\",\"type\":\"uint256\"}],\"name\":\"soldTokenInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensSoldInEachPhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleWrapperAddress\",\"type\":\"address\"}],\"name\":\"updateOracleWrapperAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddress\",\"type\":\"address\"}],\"name\":\"updateUsdtContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SCoinPublicSale","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b97fabe988289af0438553a3e8d1d3ab8140d5d9413d7ab3fc5b7d4bac34d5c9"}]}