{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Kevin Park, Email: kevin@fruitful.fi, Twitter: @tenQkp, Telegram: @freeparkingcapital Discord: tenQ#3843\r\n* www.fruitful.fi\r\n* https://twitter.com/FruitfulFi\r\n* www.loveboat.exchange\r\n* https://twitter.com/LoveBoatDEX\r\n* fruitful.eth\r\n* Credit: Nick Mudge\r\n*\r\n* DiamondLove: A multichain decentralized protocol for trading and providing rewards.\r\n* \r\n* Implementation of an ERC20 governance token that can govern itself and a project\r\n* using the Diamond Standard.\r\n/******************************************************************************/\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary LibGovStorage {\r\n    struct Voted {\r\n        uint96 votes;\r\n        bool support;\r\n    }\r\n\r\n    struct Proposal {\r\n        mapping(address => Voted) voted;\r\n        address proposalContract;\r\n        address proposer;\r\n        uint64 endTime;\r\n        bool executed;\r\n        bool stuck;\r\n        uint96 againstVotes;\r\n        uint96 forVotes;\r\n    }\r\n\r\n    // How Divisors work:\r\n    // To get a percentage of a number in Solidity we divide instead of multiply\r\n    // We get the number to divide to get a percentage of a number with this formula:\r\n    // divisor = 100 / percentage number\r\n    // For example let's say we want 25 percent of the number 7808.\r\n    // First we need to get the divisor so we get it like this:  100 / 25 = 4\r\n    // So the divisor is 4.  Now we divide 475 by 4 which is 1952\r\n    // And that is the answer: 25 percent of 7808 is 1952.\r\n\r\n    struct GovernanceStorage {\r\n        mapping(address => uint96) balances;\r\n        mapping(address => mapping(address => uint96)) approved;\r\n        uint96 totalSupplyCap;\r\n        uint96 totalSupply;\r\n        address loveMinter;\r\n        // The initial account to grant all the tokens\r\n        address loveBoat;\r\n        uint256 mintingAllowedAfter;\r\n        mapping(uint256 => Proposal) proposals;\r\n        mapping(address => uint24[]) votedProposalIds;\r\n        uint24 proposalCount;\r\n        // Proposer must own enough tokens to submit a proposal\r\n        uint8 proposalThresholdDivisor;\r\n        // The minimum amount of time a proposal can be voted on. In hours.\r\n        uint16 minimumVotingTime;\r\n        // The maximum amount of time a proposal can be voted on. In hours.\r\n        uint16 maximumVotingTime;\r\n        // Require an amount of governance tokens for votes to pass a proposal\r\n        uint8 quorumDivisor;\r\n        // Proposers get an additional amount of tokens if proposal passes\r\n        uint8 proposerAwardDivisor;\r\n        // Voters get an additional amount of tokens for voting on a proposal\r\n        uint8 voterAwardDivisor;\r\n        // Cap voter and proposer token awards.\r\n        // This is to help prevent too much inflation\r\n        uint8 voteAwardCapDivisor;\r\n    }\r\n\r\n    function governanceStorage() internal pure returns (GovernanceStorage storage ds) {\r\n        bytes32 position = keccak256(\"governance.token.diamond.governance\");\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n}\r\n\r\nlibrary LibDiamond {\r\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct DiamondStorage {\r\n        // maps function selectors to the facets that execute the functions.\r\n        // and maps the selectors to their position in the selectorSlots array.\r\n        // func selector => address facet, selector position\r\n        mapping(bytes4 => bytes32) facets;\r\n        // array of slots of function selectors.\r\n        // each slot holds 8 function selectors.\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        // The number of function selectors in selectorSlots\r\n        uint16 selectorCount;\r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        // owner of the contract\r\n        address contractOwner;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\r\n    }\r\n\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    bytes32 internal constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 internal constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    // Internal function version of diamondCut\r\n    // This code is almost the same as the external diamondCut,\r\n    // except it is using 'Facet[] memory _diamondCut' instead of\r\n    // 'Facet[] calldata _diamondCut'.\r\n    // The code is duplicated to prevent copying calldata to memory which\r\n    // causes an error for a two dimensional array.\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        if (selectorCount & 7 > 0) {\r\n            // get last selectorSlot\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        if (selectorCount & 7 > 0) {\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        uint256 _selectorCount,\r\n        bytes32 _selectorSlot,\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal returns (uint256, bytes32) {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        if (_action == IDiamondCut.FacetCutAction.Add) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\r\n                // add facet for selector\r\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\r\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\r\n                // clear selector position in slot and add selector\r\n                _selectorSlot =\r\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\r\n                    (bytes32(selector) >> selectorInSlotPosition);\r\n                // if slot is full then write it to storage\r\n                if (selectorInSlotPosition == 224) {\r\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\r\n                    _selectorSlot = 0;\r\n                }\r\n                _selectorCount++;\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n                // only useful if immutable functions exist\r\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\r\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\r\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\r\n                // replace old facet address\r\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\r\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\r\n            uint256 selectorSlotCount = _selectorCount >> 3;\r\n            uint256 selectorInSlotIndex = _selectorCount & 7;\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                if (_selectorSlot == 0) {\r\n                    // get last selectorSlot\r\n                    selectorSlotCount--;\r\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n                // adding a block here prevents stack too deep error\r\n                {\r\n                    bytes4 selector = _selectors[selectorIndex];\r\n                    bytes32 oldFacet = ds.facets[selector];\r\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\r\n                    // only useful if immutable functions exist\r\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\r\n                    // replace selector with last selector in ds.facets\r\n                    // gets the last selector\r\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\r\n                    if (lastSelector != selector) {\r\n                        // update last selector slot position info\r\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\r\n                    }\r\n                    delete ds.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                    // update storage with the modified slot\r\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    _selectorSlot =\r\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete ds.selectorSlots[selectorSlotCount];\r\n                    _selectorSlot = 0;\r\n                }\r\n            }\r\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\r\n        } else {\r\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n        }\r\n        return (_selectorCount, _selectorSlot);\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\r\n        } else {\r\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    // bubble up the error\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"LibDiamondCut: _init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n\r\ncontract DiamondCutFacet is IDiamondCut {\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        if (selectorCount & 7 > 0) {\r\n            // get last selectorSlot\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        if (selectorCount & 7 > 0) {\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        LibDiamond.initializeDiamondCut(_init, _calldata);\r\n    }\r\n}\r\n\r\ncontract DiamondLoupe is IDiamondLoupe, IERC165 {\r\n    // Diamond Loupe Functions\r\n    ////////////////////////////////////////////////////////////////////\r\n    /// These functions are expected to be called frequently by tools.\r\n\r\n    /// @notice Gets all facets and their selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view override returns (Facet[] memory facets_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facets_ = new Facet[](ds.selectorCount);\r\n        uint8[] memory numFacetSelectors = new uint8[](ds.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\r\n                bool continueLoop = false;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\r\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\r\n                        // probably will never have more than 256 functions from one facet contract\r\n                        require(numFacetSelectors[facetIndex] < 255);\r\n                        numFacetSelectors[facetIndex]++;\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continueLoop = false;\r\n                    continue;\r\n                }\r\n                facets_[numFacets].facetAddress = facetAddress_;\r\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\r\n                facets_[numFacets].functionSelectors[0] = selector;\r\n                numFacetSelectors[numFacets] = 1;\r\n                numFacets++;\r\n            }\r\n        }\r\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n            uint256 numSelectors = numFacetSelectors[facetIndex];\r\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\r\n            // setting the number of selectors\r\n            assembly {\r\n                mstore(selectors, numSelectors)\r\n            }\r\n        }\r\n        // setting the number of facets\r\n        assembly {\r\n            mstore(facets_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\r\n    function facetFunctionSelectors(address _facet) external view override returns (bytes4[] memory _facetFunctionSelectors) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 numSelectors;\r\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facet = address(bytes20(ds.facets[selector]));\r\n                if (_facet == facet) {\r\n                    _facetFunctionSelectors[numSelectors] = selector;\r\n                    numSelectors++;\r\n                }\r\n            }\r\n        }\r\n        // Set the number of selectors in the array\r\n        assembly {\r\n            mstore(_facetFunctionSelectors, numSelectors)\r\n        }\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddresses_ = new address[](ds.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\r\n                bool continueLoop = false;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continueLoop = false;\r\n                    continue;\r\n                }\r\n                facetAddresses_[numFacets] = facetAddress_;\r\n                numFacets++;\r\n            }\r\n        }\r\n        // Set the number of facet addresses in the array\r\n        assembly {\r\n            mstore(facetAddresses_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\r\n    }\r\n\r\n    // This implements ERC-165.\r\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        return ds.supportedInterfaces[_interfaceId];\r\n    }\r\n}\r\n\r\ncontract LoveToken {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public pure returns (string memory) {\r\n        return \"Love\";\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public pure returns (string memory) {\r\n        return \"LOVE\";\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() external view returns (uint256) {\r\n        return LibGovStorage.governanceStorage().totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens held by the `account`\r\n     * @param _account The address of the account to get the balance of\r\n     * @return The number of tokens held\r\n     */\r\n    function balanceOf(address _account) external view returns (uint256) {\r\n        return LibGovStorage.governanceStorage().balances[_account];\r\n    }\r\n\r\n    /// @notice Minimum time between mints\r\n    uint32 public constant minimumTimeBetweenMints = 1 days * 365;\r\n\r\n    /// @notice Cap on the percentage of totalSupply that can be minted at each mint\r\n    uint8 public constant mintCap = 2;\r\n\r\n    /// @notice An event thats emitted when the loveMinter address is changed\r\n    event MinterChanged(address loveMinter, address newMinter);\r\n\r\n    /// @notice The standard EIP-20 transfer event\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @notice The standard EIP-20 approval event\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    function mintingAllowedAfter() public view returns (uint256) {\r\n        return LibGovStorage.governanceStorage().mintingAllowedAfter;\r\n    }\r\n\r\n    /**\r\n     * @notice Change the loveMinter address\r\n     * @param _loveMinter The address of the new loveMinter\r\n     */\r\n    function setMinter(address _loveMinter) external {\r\n        require(msg.sender == LibGovStorage.governanceStorage().loveMinter, \"Love:setMinter: only the minter can change the minter address\");\r\n\r\n        emit MinterChanged(LibGovStorage.governanceStorage().loveMinter, _loveMinter);\r\n        LibGovStorage.governanceStorage().loveMinter = _loveMinter;\r\n    }\r\n\r\n    /**\r\n     * @notice Mint new tokens\r\n     * @param _dst The address of the destination account\r\n     * @param _rawAmount The number of tokens to be minted\r\n     */\r\n    function mint(address _dst, uint256 _rawAmount) external {\r\n        require(msg.sender == LibGovStorage.governanceStorage().loveMinter, \"Love:mint: only the minter can mint\");\r\n        require(block.timestamp >= LibGovStorage.governanceStorage().mintingAllowedAfter, \"Love:mint: minting not allowed yet\");\r\n        require(_dst != address(0), \"Love:mint: cannot transfer to the zero address\");\r\n\r\n        // record the mint\r\n        LibGovStorage.governanceStorage().mintingAllowedAfter = SafeMath.add(block.timestamp, minimumTimeBetweenMints);\r\n\r\n        // mint the amount\r\n        uint96 amount = safe96(_rawAmount, \"Love:mint: amount exceeds 96 bits\");\r\n        require(\r\n            amount <= SafeMath.div(SafeMath.mul(LibGovStorage.governanceStorage().totalSupply, mintCap), 100),\r\n            \"Love:mint: exceeded mint cap\"\r\n        );\r\n        LibGovStorage.governanceStorage().totalSupply = safe96(\r\n            SafeMath.add(LibGovStorage.governanceStorage().totalSupply, amount),\r\n            \"Love:mint: totalSupply exceeds 96 bits\"\r\n        );\r\n\r\n        // transfer the amount to the recipient\r\n        LibGovStorage.governanceStorage().balances[_dst] = add96(\r\n            LibGovStorage.governanceStorage().balances[_dst],\r\n            amount,\r\n            \"Love:mint: transfer amount overflows\"\r\n        );\r\n        emit Transfer(address(0), _dst, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param _to The address of the destination account\r\n     * @param _value The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address _to, uint256 _value) external returns (bool) {\r\n        uint96 value = safe96(_value, \"Love:transfer: value exceeds 96 bits\");\r\n        _transferFrom(msg.sender, _to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param _from The address of the source account\r\n     * @param _to The address of the destination account\r\n     * @param _rawValue The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _rawValue\r\n    ) external returns (bool) {\r\n        address spender = msg.sender;\r\n        uint96 spenderAllowance = LibGovStorage.governanceStorage().approved[_from][spender];\r\n        uint96 value = safe96(_rawValue, \"Love: value exceeds 96 bits\");\r\n\r\n        if (spender != _from && spenderAllowance != type(uint96).max) {\r\n            uint96 newSpenderAllowance = sub96(spenderAllowance, value, \"Love:transferFrom: value exceeds spenderAllowance\");\r\n            LibGovStorage.governanceStorage().approved[_from][spender] = newSpenderAllowance;\r\n            emit Approval(_from, spender, newSpenderAllowance);\r\n        }\r\n\r\n        _transferFrom(_from, _to, value);\r\n        return true;\r\n    }\r\n\r\n    function _transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint96 _value\r\n    ) internal {\r\n        require(_from != address(0), \"Love:_transferFrom: transfer from the zero address\");\r\n        require(_to != address(0), \"Love:_transferFrom: transfer to the zero address\");\r\n        require(_value <= LibGovStorage.governanceStorage().balances[_from], \"Love:_transferFrom: transfer amount exceeds balance\");\r\n        LibGovStorage.governanceStorage().balances[_from] = sub96(\r\n            LibGovStorage.governanceStorage().balances[_from],\r\n            _value,\r\n            \"Love:_transferFrom: value exceeds balance\"\r\n        );\r\n        LibGovStorage.governanceStorage().balances[_to] = add96(\r\n            LibGovStorage.governanceStorage().balances[_to],\r\n            _value,\r\n            \"Love:_transferFrom: value overflows\"\r\n        );\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `_spender` to transfer up to `_rawValue` from `src`\r\n     * @dev This will overwrite the approval _rawValue for `_spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param _spender The address of the account which may transfer tokens\r\n     * @param _rawValue The number of tokens that are approved\r\n     * returns success whether or not the approval succeeded\r\n     */\r\n    function approve(address _spender, uint256 _rawValue) external returns (bool success) {\r\n        uint96 value = safe96(_rawValue, \"Love: value exceeds 96 bits\");\r\n        LibGovStorage.governanceStorage().approved[msg.sender][_spender] = value;\r\n        emit Approval(msg.sender, _spender, value);\r\n        success = true;\r\n    }\r\n\r\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\r\n        require(n < 2**96, errorMessage);\r\n        return uint96(n);\r\n    }\r\n\r\n    function add96(\r\n        uint96 a,\r\n        uint96 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint96) {\r\n        uint96 c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub96(\r\n        uint96 a,\r\n        uint96 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint96) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n}\r\n\r\ncontract DiamondLove {\r\n    /// @dev Placing these events here in order to emit the ERC20 standard Transfer event at DiamondLove contract deployment\r\n    /// @notice An event thats emitted when the loveMinter address is changed\r\n    event MinterChanged(address loveMinter, address newMinter);\r\n\r\n    /// @notice The standard EIP-20 transfer event\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    constructor() {\r\n        LibGovStorage.GovernanceStorage storage gs = LibGovStorage.governanceStorage();\r\n        // Set total supply cap. The token supply cannot grow past this.\r\n        gs.totalSupplyCap = 100_000_000e18;\r\n        gs.totalSupply = 1_000_000e18;\r\n        gs.loveMinter = 0x287300059f50850d098b974AbE59106c4F52c989; // Initial address with the permission to mint Love tokens.\r\n        emit MinterChanged(address(0), gs.loveMinter);\r\n        gs.loveBoat = 0x287300059f50850d098b974AbE59106c4F52c989; // The address the token genesis minting will be sent to.\r\n\r\n        // No minting is allowed for about a year after the contract is deployed. Only 2% of the total supply can be minted every year.\r\n        gs.mintingAllowedAfter = block.timestamp + (1 days * 365);\r\n\r\n        // Initially mint tokens to gs.loveBoat. This is the Fruitful Labs EOA. The vesting contract will be deployed on Polygon L2.\r\n        gs.balances[gs.loveBoat] = gs.totalSupply;\r\n        emit Transfer(address(0), gs.loveBoat, gs.balances[gs.loveBoat]);\r\n\r\n        // Set DiamondLove contract owner\r\n        LibDiamond.setContractOwner(0x287300059f50850d098b974AbE59106c4F52c989);\r\n\r\n        // Deploy facets\r\n        DiamondCutFacet diamondCutFacet = new DiamondCutFacet();\r\n        DiamondLoupe diamondLoupe = new DiamondLoupe();\r\n        LoveToken loveToken = new LoveToken();\r\n\r\n        // Create array of facet cuts (DiamondCutFacet, DiamondLoupe, LoveToken)\r\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](3);\r\n\r\n        // Add DiamondCutFacet\r\n        bytes4[] memory funcSDiamondCut = new bytes4[](1);\r\n        funcSDiamondCut[0] = DiamondCutFacet.diamondCut.selector;\r\n\r\n        cut[0] = IDiamondCut.FacetCut(address(diamondCutFacet), IDiamondCut.FacetCutAction.Add, funcSDiamondCut);\r\n\r\n        // Add DiamondLoupe\r\n        bytes4[] memory funcSDiamondLoupe = new bytes4[](5);\r\n        funcSDiamondLoupe[0] = IDiamondLoupe.facetFunctionSelectors.selector;\r\n        funcSDiamondLoupe[1] = IDiamondLoupe.facets.selector;\r\n        funcSDiamondLoupe[2] = IDiamondLoupe.facetAddress.selector;\r\n        funcSDiamondLoupe[3] = IDiamondLoupe.facetAddresses.selector;\r\n        funcSDiamondLoupe[4] = IERC165.supportsInterface.selector;\r\n\r\n        cut[1] = IDiamondCut.FacetCut(address(diamondLoupe), IDiamondCut.FacetCutAction.Add, funcSDiamondLoupe);\r\n\r\n        // Add LoveToken\r\n        bytes4[] memory funcSLoveToken = new bytes4[](11);\r\n        funcSLoveToken[0] = LoveToken.name.selector;\r\n        funcSLoveToken[1] = LoveToken.symbol.selector;\r\n        funcSLoveToken[2] = LoveToken.decimals.selector;\r\n        funcSLoveToken[3] = LoveToken.totalSupply.selector;\r\n        funcSLoveToken[4] = LoveToken.balanceOf.selector;\r\n        funcSLoveToken[5] = LoveToken.mintingAllowedAfter.selector;\r\n        funcSLoveToken[6] = LoveToken.setMinter.selector;\r\n        funcSLoveToken[7] = LoveToken.mint.selector;\r\n        funcSLoveToken[8] = LoveToken.transfer.selector;\r\n        funcSLoveToken[9] = LoveToken.transferFrom.selector;\r\n        funcSLoveToken[10] = LoveToken.approve.selector;\r\n\r\n        cut[2] = IDiamondCut.FacetCut(address(loveToken), IDiamondCut.FacetCutAction.Add, funcSLoveToken);\r\n\r\n        LibDiamond.diamondCut(cut, address(0), new bytes(0));\r\n\r\n        // adding ERC165 data\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n    }\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n        LibDiamond.DiamondStorage storage ds;\r\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        address facet = address(bytes20(ds.facets[msg.sig]));\r\n        require(facet != address(0), \"DiamondLove: Function does not exist\");\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n                case 0 {\r\n                    revert(0, returndatasize())\r\n                }\r\n                default {\r\n                    return(0, returndatasize())\r\n                }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loveMinter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"MinterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DiamondLove","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"istanbul","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://647c88e197458dad1f1efe2114aae3d43566970a3a564f24a140f19b1ddf8cca"}]}