{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/staking/libs/Cobbs.sol\": {\r\n      \"content\": \"/*\\n\\n  Copyright 2019 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\n// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibFixedMath.sol\\\";\\n\\nlibrary LibCobbDouglas {\\n    /// @dev The cobb-douglas function used to compute fee-based rewards for\\n    ///      staking pools in a given epoch. This function does not perform\\n    ///      bounds checking on the inputs, but the following conditions\\n    ///      need to be true:\\n    ///         0 <= fees / totalFees <= 1\\n    ///         0 <= stake / totalStake <= 1\\n    ///         0 <= alphaNumerator / alphaDenominator <= 1\\n    /// @param totalRewards collected over an epoch.\\n    /// @param fees Fees attributed to the the staking pool.\\n    /// @param totalFees Total fees collected across all pools that earned rewards.\\n    /// @param stake Stake attributed to the staking pool.\\n    /// @param totalStake Total stake across all pools that earned rewards.\\n    /// @param alphaNumerator Numerator of `alpha` in the cobb-douglas function.\\n    /// @param alphaDenominator Denominator of `alpha` in the cobb-douglas\\n    ///        function.\\n    /// @return rewards Rewards owed to the staking pool.\\n    function cobbDouglas(\\n        uint256 totalRewards,\\n        uint256 fees,\\n        uint256 totalFees,\\n        uint256 stake,\\n        uint256 totalStake,\\n        uint32 alphaNumerator,\\n        uint32 alphaDenominator\\n    ) public pure returns (uint256 rewards) {\\n        int256 feeRatio = LibFixedMath.toFixed(fees, totalFees);\\n        int256 stakeRatio = LibFixedMath.toFixed(stake, totalStake);\\n        if (feeRatio == 0 || stakeRatio == 0) {\\n            return rewards = 0;\\n        }\\n        // The cobb-doublas function has the form:\\n        // `totalRewards * feeRatio ^ alpha * stakeRatio ^ (1-alpha)`\\n        // This is equivalent to:\\n        // `totalRewards * stakeRatio * e^(alpha * (ln(feeRatio / stakeRatio)))`\\n        // However, because `ln(x)` has the domain of `0 < x < 1`\\n        // and `exp(x)` has the domain of `x < 0`,\\n        // and fixed-point math easily overflows with multiplication,\\n        // we will choose the following if `stakeRatio > feeRatio`:\\n        // `totalRewards * stakeRatio / e^(alpha * (ln(stakeRatio / feeRatio)))`\\n\\n        // Compute\\n        // `e^(alpha * ln(feeRatio/stakeRatio))` if feeRatio <= stakeRatio\\n        // or\\n        // `e^(alpa * ln(stakeRatio/feeRatio))` if feeRatio > stakeRatio\\n        int256 n = feeRatio <= stakeRatio\\n            ? LibFixedMath.div(feeRatio, stakeRatio)\\n            : LibFixedMath.div(stakeRatio, feeRatio);\\n        n = LibFixedMath.exp(\\n            LibFixedMath.mulDiv(\\n                LibFixedMath.ln(n),\\n                int256(alphaNumerator),\\n                int256(alphaDenominator)\\n            )\\n        );\\n        // Compute\\n        // `totalRewards * n` if feeRatio <= stakeRatio\\n        // or\\n        // `totalRewards / n` if stakeRatio > feeRatio\\n        // depending on the choice we made earlier.\\n        n = feeRatio <= stakeRatio\\n            ? LibFixedMath.mul(stakeRatio, n)\\n            : LibFixedMath.div(stakeRatio, n);\\n        // Multiply the above with totalRewards.\\n        rewards = LibFixedMath.uintMul(n, totalRewards);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/libs/LibFixedMath.sol\": {\r\n      \"content\": \"/*\\n\\n  Copyright 2017 Bprotocol Foundation, 2019 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\n// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.3;\\n\\n// solhint-disable indent\\n/// @dev Signed, fixed-point, 127-bit precision math library.\\nlibrary LibFixedMath {\\n    // 1\\n    int256 private constant FIXED_1 = int256(\\n        0x0000000000000000000000000000000080000000000000000000000000000000\\n    );\\n    // 2**255\\n    int256 private constant MIN_FIXED_VAL = int256(\\n        0x8000000000000000000000000000000000000000000000000000000000000000\\n    );\\n    // 1^2 (in fixed-point)\\n    int256 private constant FIXED_1_SQUARED = int256(\\n        0x4000000000000000000000000000000000000000000000000000000000000000\\n    );\\n    // 1\\n    int256 private constant LN_MAX_VAL = FIXED_1;\\n    // e ^ -63.875\\n    int256 private constant LN_MIN_VAL = int256(\\n        0x0000000000000000000000000000000000000000000000000000000733048c5a\\n    );\\n    // 0\\n    int256 private constant EXP_MAX_VAL = 0;\\n    // -63.875\\n    int256 private constant EXP_MIN_VAL = -int256(\\n        0x0000000000000000000000000000001ff0000000000000000000000000000000\\n    );\\n\\n    /// @dev Get one as a fixed-point number.\\n    function one() internal pure returns (int256 f) {\\n        f = FIXED_1;\\n    }\\n\\n    /// @dev Returns the addition of two fixed point numbers, reverting on overflow.\\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = _add(a, b);\\n    }\\n\\n    /// @dev Returns the addition of two fixed point numbers, reverting on overflow.\\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (b == MIN_FIXED_VAL) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        c = _add(a, -b);\\n    }\\n\\n    /// @dev Returns the multiplication of two fixed point numbers, reverting on overflow.\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = _mul(a, b) / FIXED_1;\\n    }\\n\\n    /// @dev Returns the division of two fixed point numbers.\\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = _div(_mul(a, FIXED_1), b);\\n    }\\n\\n    /// @dev Performs (a * n) / d, without scaling for precision.\\n    function mulDiv(\\n        int256 a,\\n        int256 n,\\n        int256 d\\n    ) internal pure returns (int256 c) {\\n        c = _div(_mul(a, n), d);\\n    }\\n\\n    /// @dev Returns the unsigned integer result of multiplying a fixed-point\\n    ///      number with an integer, reverting if the multiplication overflows.\\n    ///      Negative results are clamped to zero.\\n    function uintMul(int256 f, uint256 u) internal pure returns (uint256) {\\n        if (int256(u) < int256(0)) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        int256 c = _mul(f, int256(u));\\n        if (c <= 0) {\\n            return 0;\\n        }\\n        return uint256(uint256(c) >> 127);\\n    }\\n\\n    /// @dev Returns the absolute value of a fixed point number.\\n    function abs(int256 f) internal pure returns (int256 c) {\\n        if (f == MIN_FIXED_VAL) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        if (f >= 0) {\\n            c = f;\\n        } else {\\n            c = -f;\\n        }\\n    }\\n\\n    /// @dev Returns 1 / `x`, where `x` is a fixed-point number.\\n    function invert(int256 f) internal pure returns (int256 c) {\\n        c = _div(FIXED_1_SQUARED, f);\\n    }\\n\\n    /// @dev Convert signed `n` / 1 to a fixed-point number.\\n    function toFixed(int256 n) internal pure returns (int256 f) {\\n        f = _mul(n, FIXED_1);\\n    }\\n\\n    /// @dev Convert signed `n` / `d` to a fixed-point number.\\n    function toFixed(int256 n, int256 d) internal pure returns (int256 f) {\\n        f = _div(_mul(n, FIXED_1), d);\\n    }\\n\\n    /// @dev Convert unsigned `n` / 1 to a fixed-point number.\\n    ///      Reverts if `n` is too large to fit in a fixed-point number.\\n    function toFixed(uint256 n) internal pure returns (int256 f) {\\n        if (int256(n) < int256(0)) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        f = _mul(int256(n), FIXED_1);\\n    }\\n\\n    /// @dev Convert unsigned `n` / `d` to a fixed-point number.\\n    ///      Reverts if `n` / `d` is too large to fit in a fixed-point number.\\n    function toFixed(uint256 n, uint256 d) internal pure returns (int256 f) {\\n        if (int256(n) < int256(0)) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        if (int256(d) < int256(0)) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        f = _div(_mul(int256(n), FIXED_1), int256(d));\\n    }\\n\\n    /// @dev Convert a fixed-point number to an integer.\\n    function toInteger(int256 f) internal pure returns (int256 n) {\\n        return f / FIXED_1;\\n    }\\n\\n    /// @dev Get the natural logarithm of a fixed-point number 0 < `x` <= LN_MAX_VAL\\n    function ln(int256 x) internal pure returns (int256 r) {\\n        if (x > LN_MAX_VAL) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        if (x <= 0) {\\n            revert(\\\"too-small\\\");\\n        }\\n        if (x == FIXED_1) {\\n            return 0;\\n        }\\n        if (x <= LN_MIN_VAL) {\\n            return EXP_MIN_VAL;\\n        }\\n\\n        int256 y;\\n        int256 z;\\n        int256 w;\\n\\n        // Rewrite the input as a quotient of negative natural exponents and a single residual q, such that 1 < q < 2\\n        // For example: log(0.3) = log(e^-1 * e^-0.25 * 1.0471028872385522)\\n        //              = 1 - 0.25 - log(1 + 0.0471028872385522)\\n        // e ^ -32\\n        if (x <= int256(0x00000000000000000000000000000000000000000001c8464f76164760000000)) {\\n            r -= int256(0x0000000000000000000000000000001000000000000000000000000000000000); // - 32\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x00000000000000000000000000000000000000000001c8464f76164760000000); // / e ^ -32\\n        }\\n        // e ^ -16\\n        if (x <= int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000800000000000000000000000000000000); // - 16\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000); // / e ^ -16\\n        }\\n        // e ^ -8\\n        if (x <= int256(0x00000000000000000000000000000000000afe10820813d78000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000400000000000000000000000000000000); // - 8\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x00000000000000000000000000000000000afe10820813d78000000000000000); // / e ^ -8\\n        }\\n        // e ^ -4\\n        if (x <= int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000200000000000000000000000000000000); // - 4\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000); // / e ^ -4\\n        }\\n        // e ^ -2\\n        if (x <= int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000100000000000000000000000000000000); // - 2\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000); // / e ^ -2\\n        }\\n        // e ^ -1\\n        if (x <= int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000080000000000000000000000000000000); // - 1\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000); // / e ^ -1\\n        }\\n        // e ^ -0.5\\n        if (x <= int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000040000000000000000000000000000000); // - 0.5\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000); // / e ^ -0.5\\n        }\\n        // e ^ -0.25\\n        if (x <= int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000020000000000000000000000000000000); // - 0.25\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000); // / e ^ -0.25\\n        }\\n        // e ^ -0.125\\n        if (x <= int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) {\\n            r -= int256(0x0000000000000000000000000000000010000000000000000000000000000000); // - 0.125\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d); // / e ^ -0.125\\n        }\\n        // `x` is now our residual in the range of 1 <= x <= 2 (or close enough).\\n\\n        // Add the taylor series for log(1 + z), where z = x - 1\\n        z = y = x - FIXED_1;\\n        w = (y * y) / FIXED_1;\\n        r += (z * (0x100000000000000000000000000000000 - y)) / 0x100000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\\n        r += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\\n        r += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\\n        r += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\\n        r += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\\n        r += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\\n        r += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\\n        r += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\\n    }\\n\\n    /// @dev Compute the natural exponent for a fixed-point number EXP_MIN_VAL <= `x` <= 1\\n    function exp(int256 x) internal pure returns (int256 r) {\\n        if (x < EXP_MIN_VAL) {\\n            // Saturate to zero below EXP_MIN_VAL.\\n            return 0;\\n        }\\n        if (x == 0) {\\n            return FIXED_1;\\n        }\\n        if (x > EXP_MAX_VAL) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n\\n        // Rewrite the input as a product of natural exponents and a\\n        // single residual q, where q is a number of small magnitude.\\n        // For example: e^-34.419 = e^(-32 - 2 - 0.25 - 0.125 - 0.044)\\n        //              = e^-32 * e^-2 * e^-0.25 * e^-0.125 * e^-0.044\\n        //              -> q = -0.044\\n\\n        // Multiply with the taylor series for e^q\\n        int256 y;\\n        int256 z;\\n        // q = x % 0.125 (the residual)\\n        z = y = x % 0x0000000000000000000000000000000010000000000000000000000000000000;\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\\n        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\\n\\n        // Multiply with the non-residual terms.\\n        x = -x;\\n        // e ^ -32\\n        if ((x & int256(0x0000000000000000000000000000001000000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x00000000000000000000000000000000000000f1aaddd7742e56d32fb9f99744)) /\\n                int256(0x0000000000000000000000000043cbaf42a000812488fc5c220ad7b97bf6e99e); // * e ^ -32\\n        }\\n        // e ^ -16\\n        if ((x & int256(0x0000000000000000000000000000000800000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x00000000000000000000000000000000000afe10820813d65dfe6a33c07f738f)) /\\n                int256(0x000000000000000000000000000005d27a9f51c31b7c2f8038212a0574779991); // * e ^ -16\\n        }\\n        // e ^ -8\\n        if ((x & int256(0x0000000000000000000000000000000400000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x0000000000000000000000000000000002582ab704279e8efd15e0265855c47a)) /\\n                int256(0x0000000000000000000000000000001b4c902e273a58678d6d3bfdb93db96d02); // * e ^ -8\\n        }\\n        // e ^ -4\\n        if ((x & int256(0x0000000000000000000000000000000200000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x000000000000000000000000000000001152aaa3bf81cb9fdb76eae12d029571)) /\\n                int256(0x00000000000000000000000000000003b1cc971a9bb5b9867477440d6d157750); // * e ^ -4\\n        }\\n        // e ^ -2\\n        if ((x & int256(0x0000000000000000000000000000000100000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x000000000000000000000000000000002f16ac6c59de6f8d5d6f63c1482a7c86)) /\\n                int256(0x000000000000000000000000000000015bf0a8b1457695355fb8ac404e7a79e3); // * e ^ -2\\n        }\\n        // e ^ -1\\n        if ((x & int256(0x0000000000000000000000000000000080000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x000000000000000000000000000000004da2cbf1be5827f9eb3ad1aa9866ebb3)) /\\n                int256(0x00000000000000000000000000000000d3094c70f034de4b96ff7d5b6f99fcd8); // * e ^ -1\\n        }\\n        // e ^ -0.5\\n        if ((x & int256(0x0000000000000000000000000000000040000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x0000000000000000000000000000000063afbe7ab2082ba1a0ae5e4eb1b479dc)) /\\n                int256(0x00000000000000000000000000000000a45af1e1f40c333b3de1db4dd55f29a7); // * e ^ -0.5\\n        }\\n        // e ^ -0.25\\n        if ((x & int256(0x0000000000000000000000000000000020000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) /\\n                int256(0x00000000000000000000000000000000910b022db7ae67ce76b441c27035c6a1); // * e ^ -0.25\\n        }\\n        // e ^ -0.125\\n        if ((x & int256(0x0000000000000000000000000000000010000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x00000000000000000000000000000000783eafef1c0a8f3978c7f81824d62ebf)) /\\n                int256(0x0000000000000000000000000000000088415abbe9a76bead8d00cf112e4d4a8); // * e ^ -0.125\\n        }\\n    }\\n\\n    /// @dev Returns the multiplication two numbers, reverting on overflow.\\n    function _mul(int256 a, int256 b) private pure returns (int256 c) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        c = a * b;\\n        if (c / a != b || c / b != a) {\\n            revert(\\\"overflow\\\");\\n        }\\n    }\\n\\n    /// @dev Returns the division of two numbers, reverting on division by zero.\\n    function _div(int256 a, int256 b) private pure returns (int256 c) {\\n        if (b == 0) {\\n            revert(\\\"overflow\\\");\\n        }\\n        if (a == MIN_FIXED_VAL && b == -1) {\\n            revert(\\\"overflow\\\");\\n        }\\n        c = a / b;\\n    }\\n\\n    /// @dev Adds two numbers, reverting on overflow.\\n    function _add(int256 a, int256 b) private pure returns (int256 c) {\\n        c = a + b;\\n        if ((a < 0 && b < 0 && c > a) || (a > 0 && b > 0 && c < a)) {\\n            revert(\\\"overflow\\\");\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"alphaNumerator\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"alphaDenominator\",\"type\":\"uint32\"}],\"name\":\"cobbDouglas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"LibCobbDouglas","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}