{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.8;\\n\\nimport \\\"./ERC20Basic.sol\\\";\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20  {\\n     /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    \\n    event Deposit(address indexed from, uint256 value);\\n    \\n    event Withdraw(address indexed to, uint256 value);\\n    \\n}\\n\"},\"ERC20Basic.sol\":{\"content\":\"pragma solidity ^0.4.8;\\n\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/179\\n */\\ncontract ERC20Basic {\\n  /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    \\n    event Deposit(address indexed from, uint256 value);\\n    \\n    event Withdraw(address indexed to, uint256 value);\\n    \\n}\\n\"},\"GalacticCrowdsale.sol\":{\"content\":\"pragma solidity ^0.4.8;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @title GalacticCrowdsale\\n * @dev Crowdsale is a base contract for managing a token crowdsale,\\n * allowing investors to purchase tokens with ether. This contract implements\\n * such functionality in its most fundamental form and can be extended to provide additional\\n * functionality and/or custom behavior.\\n * The external interface represents the basic interface for purchasing tokens, and conform\\n * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\\n * the methods to add functionality. Consider using \\u0027super\\u0027 where appropiate to concatenate\\n * behavior.\\n */\\ncontract GalacticCrowdsale {\\n  using SafeMath for uint256;\\n\\n  // The token being sold\\n  ERC20 public token;\\n\\n  // Address where funds are collected\\n  address  public wallet;\\n\\n  // How many token units a buyer gets per wei\\n  uint256 public rate;\\n\\n  // Amount of wei raised\\n  uint256 public weiRaised;\\n  \\n  uint256 public tokensSold;\\n\\n  /**\\n   * Event for token purchase logging\\n   * @param purchaser who paid for the tokens\\n   * @param beneficiary who got the tokens\\n   * @param value weis paid for purchase\\n   * @param amount amount of tokens purchased\\n   */\\n  event TokenPurchase(\\n    address indexed purchaser,\\n    address indexed beneficiary,\\n    uint256 value,\\n    uint256 amount\\n  );\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    \\n    event Deposit(address indexed from, uint256 value);\\n  /**\\n   * @param _rate Number of token units a buyer gets per wei\\n   * @param _wallet Address where collected funds will be forwarded to\\n   * @param _token Address of the token being sold\\n   */\\n  constructor(uint256 _rate, address  _wallet, address _token) public {\\n    require(_rate \\u003e 0);\\n    require(_wallet != address(0));\\n    require(_token != address(0));\\n\\n    rate = _rate;\\n    wallet = _wallet;\\n    token = ERC20(_token);\\n  }\\n\\n  // -----------------------------------------\\n  // Crowdsale external interface\\n  // -----------------------------------------\\n\\n  /**\\n   * @dev fallback function ***DO NOT OVERRIDE***\\n   */\\n  function () external payable {\\n    \\n    buyTokens(msg.sender);\\n  }\\n\\n  /**\\n   * @dev low level token purchase ***DO NOT OVERRIDE***\\n   * @param _beneficiary Address performing the token purchase\\n   */\\n  function buyTokens(address  _beneficiary) public payable {\\n\\n    uint256 amountTobuy = msg.value;\\n    uint256 dexBalance = token.balanceOf(address(this));\\n    require(amountTobuy \\u003e 0, \\\"You need to send some ether\\\");\\n    require(amountTobuy \\u003c= dexBalance, \\\"Not enough tokens in the reserve\\\");\\n \\n\\n    // calculate token amount to be created\\n    uint256 tokens = _getTokenAmount(amountTobuy);\\n\\n    tokensSold = tokensSold.add(tokens);\\n    // update state\\n    weiRaised = weiRaised.add(amountTobuy);\\n    emit Deposit(_beneficiary,tokens);\\n    ERC20(token).transfer(address(_beneficiary), tokens);\\n    emit Transfer(address(0),_beneficiary,tokens);\\n    \\n    emit TokenPurchase(\\n      msg.sender,\\n      _beneficiary,\\n      amountTobuy,\\n      tokens\\n    );\\n    \\n   \\n\\n    _updatePurchasingState(_beneficiary, amountTobuy);\\n   \\n    wallet.transfer(msg.value);\\n    _postValidatePurchase(_beneficiary, amountTobuy);\\n  }\\n  \\n  function tokensRemaining() public view returns (uint256){\\n      return token.balanceOf(address(this));\\n  }\\n  \\n\\n  // -----------------------------------------\\n  // Internal interface (extensible)\\n  // -----------------------------------------\\n\\n  /**\\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\\n   * @param _beneficiary Address performing the token purchase\\n   * @param _weiAmount Value in wei involved in the purchase\\n   */\\n  function _preValidatePurchase(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    require(_beneficiary != address(0));\\n    require(_weiAmount != 0);\\n  }\\n\\n  /**\\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\\n   * @param _beneficiary Address performing the token purchase\\n   * @param _weiAmount Value in wei involved in the purchase\\n   */\\n  function _postValidatePurchase(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    // optional override\\n  }\\n\\n  /**\\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\\n   * @param _beneficiary Address performing the token purchase\\n   * @param _tokenAmount Number of tokens to be emitted\\n   */\\n  function _deliverTokens(\\n    address _beneficiary,\\n    uint256 _tokenAmount\\n  )\\n    internal\\n  {\\n    token.transfer(_beneficiary, _tokenAmount);\\n  }\\n\\n  /**\\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\\n   * @param _beneficiary Address receiving the tokens\\n   * @param _tokenAmount Number of tokens to be purchased\\n   */\\n  function _processPurchase(\\n    address _beneficiary,\\n    uint256 _tokenAmount\\n  )\\n    internal\\n  {\\n    _deliverTokens(_beneficiary, _tokenAmount);\\n  }\\n\\n  /**\\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\\n   * @param _beneficiary Address receiving the tokens\\n   * @param _weiAmount Value in wei involved in the purchase\\n   */\\n  function _updatePurchasingState(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n  {\\n    // optional override\\n  }\\n\\n  /**\\n   * @dev Override to extend the way in which ether is converted to tokens.\\n   * @param _weiAmount Value in wei to be converted into tokens\\n   * @return Number of tokens that can be purchased with the specified _weiAmount\\n   */\\n  function _getTokenAmount(uint256 _weiAmount)\\n    internal view returns (uint256)\\n  {\\n    return _weiAmount.div(rate);\\n  }\\n\\n  \\n}\\n\"},\"GalacticSale.sol\":{\"content\":\"/**\\n * \\n * \\n  _______      ___       __          ___       ______ .___________. _______ .______       __   __    __  .___  ___. \\n /  _____|    /   \\\\     |  |        /   \\\\     /      ||           ||   ____||   _  \\\\     |  | |  |  |  | |   \\\\/   | \\n|  |  __     /  ^  \\\\    |  |       /  ^  \\\\   |  ,----\\u0027`---|  |----`|  |__   |  |_)  |    |  | |  |  |  | |  \\\\  /  | \\n|  | |_ |   /  /_\\\\  \\\\   |  |      /  /_\\\\  \\\\  |  |         |  |     |   __|  |      /     |  | |  |  |  | |  |\\\\/|  | \\n|  |__| |  /  _____  \\\\  |  `----./  _____  \\\\ |  `----.    |  |     |  |____ |  |\\\\  \\\\----.|  | |  `--\\u0027  | |  |  |  | \\n \\\\______| /__/     \\\\__\\\\ |_______/__/     \\\\__\\\\ \\\\______|    |__|     |_______|| _| `._____||__|  \\\\______/  |__|  |__|                                                                                                                \\n\\n____ _  _ ____ ___  _ ____ _  _ ____    ____ ____    ___ _  _ ____    ____ ____ _    ____ ____ ___ ____ ____ _ _  _ _  _ \\n| __ |  | |__| |  \\\\ | |__| |\\\\ | [__     |  | |___     |  |__| |___    | __ |__| |    |__| |     |  |___ |__/ | |  | |\\\\/| \\n|__] |__| |  | |__/ | |  | | \\\\| ___]    |__| |        |  |  | |___    |__] |  | |___ |  | |___  |  |___ |  \\\\ | |__| |  | \\n                                                                                                                         \\n____ ____ ___ ____ ___     ____ _  _ ___     ____ ___ ____ ____ _  _ ____ _  _                                           \\n[__  |___  |  |___ |__]    |__| |\\\\ | |  \\\\    [__   |  |__| |__/ |\\\\/| |__| |\\\\ |                                           \\n___] |___  |  |___ |       |  | | \\\\| |__/    ___]  |  |  | |  \\\\ |  | |  | | \\\\|   \\n\\nReality Benders\\n\\n(3)(6)(9)\\n\\nElon Musk\\nRichard Brandson\\nSpace Force\\nInternational Space Station\\n * \\n *\\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\\n */\\n\\n\\npragma solidity ^0.4.8;\\n\\nimport \\\"./IncreasingPriceCrowdsale.sol\\\";\\nimport \\\"./GalacticCrowdsale.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\ncontract GalacticSale is IncreasingPriceCrowdsale, Ownable {\\n\\n  address  private ownerwallet;\\n  constructor (\\n    uint256 _openingTime,\\n    uint256 _closingTime,\\n    address  _wallet,\\n    address _token,\\n    uint256 _initialRate,\\n    uint256 _finalRate\\n  )\\n    public\\n    GalacticCrowdsale(_initialRate, _wallet, _token)\\n    TimedCrowdsale(_openingTime, _closingTime)\\n    IncreasingPriceCrowdsale(_initialRate, _finalRate)\\n  {\\n      ownerwallet=_wallet;\\n  }\\n  \\n  function closeSale() onlyOwner public{\\n      if(!hasClosed()) revert();\\n      uint256 contractTokenBalance = tokensRemaining();\\n     \\n      if(contractTokenBalance\\u003e0){\\n        ERC20(token).transfer(ownerwallet,contractTokenBalance);  \\n        emit Transfer(address(0),address(ownerwallet),contractTokenBalance);\\n      }\\n  }\\n\\n}\"},\"IncreasingPriceCrowdsale.sol\":{\"content\":\"pragma solidity ^0.4.8;\\n\\nimport \\\"./TimedCrowdsale.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @title IncreasingPriceCrowdsale\\n * @dev Extension of Crowdsale contract that increases the price of tokens linearly in time.\\n * Note that what should be provided to the constructor is the initial and final _rates_, that is,\\n * the amount of tokens per wei contributed. Thus, the initial rate must be greater than the final rate.\\n */\\ncontract IncreasingPriceCrowdsale is TimedCrowdsale {\\n  using SafeMath for uint256;\\n\\n  uint256 public initialRate;\\n  uint256 public finalRate;\\n\\n  /**\\n   * @dev Constructor, takes intial and final rates of tokens received per wei contributed.\\n   * @param _initialRate Number of tokens a buyer gets per wei at the start of the crowdsale\\n   * @param _finalRate Number of tokens a buyer gets per wei at the end of the crowdsale\\n   */\\n  constructor(uint256 _initialRate, uint256 _finalRate) public {\\n    require(_initialRate \\u003e= _finalRate);\\n    require(_finalRate \\u003e 0);\\n    initialRate = _initialRate;\\n    finalRate = _finalRate;\\n  }\\n\\n  /**\\n   * @dev Returns the rate of tokens per wei at the present time.\\n   * Note that, as price _increases_ with time, the rate _decreases_.\\n   * @return The number of tokens a buyer gets per wei at a given time\\n   */\\n  function getCurrentRate() public view returns (uint256) {\\n    // solium-disable-next-line security/no-block-members\\n    uint256 elapsedTime = block.timestamp.sub(openingTime);\\n    uint256 timeRange = closingTime.sub(openingTime);\\n    uint256 rateRange = initialRate.sub(finalRate);\\n    return initialRate.sub(elapsedTime.mul(rateRange).div(timeRange));\\n  }\\n\\n  /**\\n   * @dev Overrides parent method taking into account variable rate.\\n   * @param _weiAmount The value in wei to be converted into tokens\\n   * @return The number of tokens _weiAmount wei will buy at present time\\n   */\\n  function _getTokenAmount(uint256 _weiAmount)\\n    internal view returns (uint256)\\n  {\\n    uint256 currentRate = getCurrentRate();\\n    return (_weiAmount.div(currentRate)).mul(1 ether);\\n  }\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.8;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev revert()s if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(owner, newOwner);\\n    owner = newOwner;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipRenounced(owner);\\n    owner = address(0);\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.8;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"},\"TimedCrowdsale.sol\":{\"content\":\"pragma solidity ^0.4.8;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./GalacticCrowdsale.sol\\\";\\n\\n\\n/**\\n * @title TimedCrowdsale\\n * @dev Crowdsale accepting contributions only within a time frame.\\n */\\ncontract TimedCrowdsale is GalacticCrowdsale {\\n  using SafeMath for uint256;\\n\\n  uint256 public openingTime;\\n  uint256 public closingTime;\\n\\n  /**\\n   * @dev Reverts if not in crowdsale time range.\\n   */\\n  modifier onlyWhileOpen {\\n    // solium-disable-next-line security/no-block-members\\n    require(block.timestamp \\u003e= openingTime \\u0026\\u0026 block.timestamp \\u003c= closingTime);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Constructor, takes crowdsale opening and closing times.\\n   * @param _openingTime Crowdsale opening time\\n   * @param _closingTime Crowdsale closing time\\n   */\\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\\n    // solium-disable-next-line security/no-block-members\\n    require(_openingTime \\u003e= block.timestamp);\\n    require(_closingTime \\u003e= _openingTime);\\n\\n    openingTime = _openingTime;\\n    closingTime = _closingTime;\\n  }\\n\\n  /**\\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\\n   * @return Whether crowdsale period has elapsed\\n   */\\n  function hasClosed() public view returns (bool) {\\n    // solium-disable-next-line security/no-block-members\\n    return block.timestamp \\u003e closingTime;\\n  }\\n\\n  /**\\n   * @dev Extend parent behavior requiring to be within contributing period\\n   * @param _beneficiary Token purchaser\\n   * @param _weiAmount Amount of wei contributed\\n   */\\n  function _preValidatePurchase(\\n    address _beneficiary,\\n    uint256 _weiAmount\\n  )\\n    internal\\n    onlyWhileOpen\\n  {\\n    super._preValidatePurchase(_beneficiary, _weiAmount);\\n  }\\n\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_initialRate\",\"type\":\"uint256\"},{\"name\":\"_finalRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"}]","ContractName":"GalacticSale","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000060d6129800000000000000000000000000000000000000000000000000000000614f49d80000000000000000000000003b43abc0eff01dab1ba168acba49b6ac1a1efbdb000000000000000000000000508aa5addc164b3be4d3732e6ae2abe6549b1ca500000000000000000000000000000000000000000000002111735814dc48000000000000000000000000000000000000000000000000001088b9ac0a6e240000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://bdb9fe1faea0057f9c9a8a69d8c349d7362faf5ad7312ab01a3ad55961303521"}]}