{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/Globals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nuint256 constant SECONDS_IN_THE_YEAR = 365 * 24 * 60 * 60; // 365 days * 24 hours * 60 minutes * 60 seconds\\nuint256 constant MAX_INT = type(uint256).max;\\n\\nuint256 constant DECIMALS = 10**18;\\n\\nuint256 constant PRECISION = 10**25;\\nuint256 constant PERCENTAGE_100 = 100 * PRECISION;\\n\\nuint256 constant BLOCKS_PER_DAY = 6450;\\nuint256 constant BLOCKS_PER_YEAR = BLOCKS_PER_DAY * 365;\\n\\nuint256 constant APY_TOKENS = DECIMALS;\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/LiquidityRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\n\\nimport \\\"./interfaces/IPolicyBook.sol\\\";\\nimport \\\"./interfaces/IPolicyBookRegistry.sol\\\";\\nimport \\\"./interfaces/IContractsRegistry.sol\\\";\\nimport \\\"./interfaces/ILiquidityRegistry.sol\\\";\\nimport \\\"./interfaces/IBMIDAIStaking.sol\\\";\\n\\nimport \\\"./abstract/AbstractDependant.sol\\\";\\n\\nimport \\\"./Globals.sol\\\";\\n\\ncontract LiquidityRegistry is ILiquidityRegistry, AbstractDependant {\\n    using SafeMath for uint256;\\n    using Math for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    IPolicyBookRegistry public policyBookRegistry;\\n    IBMIDAIStaking public bmiDaiStaking;\\n\\n    // User address => policy books array\\n    mapping(address => EnumerableSet.AddressSet) private _policyBooks;\\n\\n    event PolicyBookAdded(address _userAddr, address _policyBookAddress);\\n    event PolicyBookRemoved(address _userAddr, address _policyBookAddress);\\n\\n    modifier onlyEligibleContracts() {\\n        require(\\n            msg.sender == address(bmiDaiStaking) || policyBookRegistry.isPolicyBook(msg.sender),\\n            \\\"LR: Not an eligible contract\\\"\\n        );\\n        _;\\n    }\\n\\n    function setDependencies(IContractsRegistry _contractsRegistry)\\n        external\\n        override\\n        onlyInjectorOrZero\\n    {\\n        policyBookRegistry = IPolicyBookRegistry(\\n            _contractsRegistry.getPolicyBookRegistryContract()\\n        );\\n        bmiDaiStaking = IBMIDAIStaking(_contractsRegistry.getBMIDAIStakingContract());\\n    }\\n\\n    function tryToAddPolicyBook(address _userAddr, address _policyBookAddr)\\n        external\\n        override\\n        onlyEligibleContracts\\n    {\\n        if (\\n            IERC20(_policyBookAddr).balanceOf(_userAddr) > 0 ||\\n            bmiDaiStaking.balanceOf(_userAddr) > 0\\n        ) {\\n            _policyBooks[_userAddr].add(_policyBookAddr);\\n\\n            emit PolicyBookAdded(_userAddr, _policyBookAddr);\\n        }\\n    }\\n\\n    function tryToRemovePolicyBook(address _userAddr, address _policyBookAddr)\\n        external\\n        override\\n        onlyEligibleContracts\\n    {\\n        if (\\n            IERC20(_policyBookAddr).balanceOf(_userAddr) == 0 &&\\n            bmiDaiStaking.balanceOf(_userAddr) == 0 &&\\n            IPolicyBook(_policyBookAddr).getWithdrawalStatus(_userAddr) ==\\n            IPolicyBook.WithdrawalStatus.NONE\\n        ) {\\n            _policyBooks[_userAddr].remove(_policyBookAddr);\\n\\n            emit PolicyBookRemoved(_userAddr, _policyBookAddr);\\n        }\\n    }\\n\\n    function getPolicyBooksArrLength(address _userAddr) external view override returns (uint256) {\\n        return _policyBooks[_userAddr].length();\\n    }\\n\\n    function getPolicyBooksArr(address _userAddr)\\n        external\\n        view\\n        override\\n        returns (address[] memory _resultArr)\\n    {\\n        uint256 _policyBooksArrLength = _policyBooks[_userAddr].length();\\n\\n        _resultArr = new address[](_policyBooksArrLength);\\n\\n        for (uint256 i = 0; i < _policyBooksArrLength; i++) {\\n            _resultArr[i] = _policyBooks[_userAddr].at(i);\\n        }\\n    }\\n\\n    /// @notice _bmiDaiRatio comes with 10**18 precision\\n    function getLiquidityInfos(\\n        address _userAddr,\\n        uint256 _offset,\\n        uint256 _limit\\n    ) external view override returns (LiquidityInfo[] memory _resultArr) {\\n        uint256 _to = (_offset.add(_limit)).min(_policyBooks[_userAddr].length()).max(_offset);\\n\\n        _resultArr = new LiquidityInfo[](_to - _offset);\\n\\n        for (uint256 i = _offset; i < _to; i++) {\\n            address _currentPolicyBookAddr = _policyBooks[_userAddr].at(i);\\n\\n            (uint256 _lockedAmount, , ) =\\n                IPolicyBook(_currentPolicyBookAddr).withdrawalsInfo(_userAddr);\\n            uint256 _availableAmount =\\n                IERC20(address(_currentPolicyBookAddr)).balanceOf(_userAddr);\\n\\n            uint256 _bmiDaiRaito = IPolicyBook(_currentPolicyBookAddr).convertDAIXToDAI(10**18);\\n\\n            _resultArr[i - _offset] = LiquidityInfo(\\n                _currentPolicyBookAddr,\\n                _lockedAmount,\\n                _availableAmount,\\n                _bmiDaiRaito\\n            );\\n        }\\n    }\\n\\n    function getWithdrawalRequests(\\n        address _userAddr,\\n        uint256 _offset,\\n        uint256 _limit\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 _arrLength, WithdrawalRequestInfo[] memory _resultArr)\\n    {\\n        uint256 _to = (_offset.add(_limit)).min(_policyBooks[_userAddr].length()).max(_offset);\\n\\n        _resultArr = new WithdrawalRequestInfo[](_to - _offset);\\n\\n        for (uint256 i = _offset; i < _to; i++) {\\n            IPolicyBook _currentPolicyBook = IPolicyBook(_policyBooks[_userAddr].at(i));\\n\\n            (uint256 _requestAmount, uint256 _readyToWithdrawDate, bool withdrawalAllowed) =\\n                _currentPolicyBook.withdrawalsInfo(_userAddr);\\n\\n            IPolicyBook.WithdrawalStatus _currentStatus =\\n                _currentPolicyBook.getWithdrawalStatus(_userAddr);\\n\\n            if (withdrawalAllowed || _currentStatus == IPolicyBook.WithdrawalStatus.NONE) {\\n                continue;\\n            }\\n\\n            uint256 _endWithdrawDate;\\n\\n            if (block.timestamp > _readyToWithdrawDate) {\\n                _endWithdrawDate = _readyToWithdrawDate.add(\\n                    _currentPolicyBook.READY_TO_WITHDRAW_PERIOD()\\n                );\\n            }\\n\\n            (uint256 coverTokens, uint256 liquidity) =\\n                _currentPolicyBook.getNewCoverAndLiquidity();\\n\\n            _resultArr[_arrLength] = WithdrawalRequestInfo(\\n                address(_currentPolicyBook),\\n                _requestAmount,\\n                _currentPolicyBook.convertDAIXToDAI(_requestAmount),\\n                liquidity.sub(coverTokens),\\n                _readyToWithdrawDate,\\n                _endWithdrawDate\\n            );\\n\\n            _arrLength++;\\n        }\\n    }\\n\\n    function getWithdrawalSet(\\n        address _userAddr,\\n        uint256 _offset,\\n        uint256 _limit\\n    ) external view override returns (uint256 _arrLength, WithdrawalSetInfo[] memory _resultArr) {\\n        uint256 _to = (_offset.add(_limit)).min(_policyBooks[_userAddr].length()).max(_offset);\\n\\n        _resultArr = new WithdrawalSetInfo[](_to - _offset);\\n\\n        for (uint256 i = _offset; i < _to; i++) {\\n            IPolicyBook _currentPolicyBook = IPolicyBook(_policyBooks[_userAddr].at(i));\\n\\n            (uint256 _requestAmount, , bool withdrawalAllowed) =\\n                _currentPolicyBook.withdrawalsInfo(_userAddr);\\n\\n            if (!withdrawalAllowed) {\\n                continue;\\n            }\\n\\n            (uint256 coverTokens, uint256 liquidity) =\\n                _currentPolicyBook.getNewCoverAndLiquidity();\\n\\n            _resultArr[_arrLength] = WithdrawalSetInfo(\\n                address(_currentPolicyBook),\\n                _requestAmount,\\n                _currentPolicyBook.convertDAIXToDAI(_requestAmount),\\n                liquidity.sub(coverTokens)\\n            );\\n\\n            _arrLength++;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/abstract/AbstractDependant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\n\\nimport \\\"../interfaces/IContractsRegistry.sol\\\";\\n\\nabstract contract AbstractDependant {\\n    /// @dev keccak256(AbstractDependant.setInjector(address)) - 1\\n    bytes32 private constant _INJECTOR_SLOT =\\n        0xd6b8f2e074594ceb05d47c27386969754b6ad0c15e5eb8f691399cd0be980e76;\\n\\n    modifier onlyInjectorOrZero() {\\n        address _injector = injector();\\n\\n        require(_injector == address(0) || _injector == msg.sender, \\\"Dependant: Not an injector\\\");\\n        _;\\n    }\\n\\n    function setInjector(address _injector) external onlyInjectorOrZero {\\n        bytes32 slot = _INJECTOR_SLOT;\\n\\n        assembly {\\n            sstore(slot, _injector)\\n        }\\n    }\\n\\n    /// @dev has to apply onlyInjectorOrZero() modifier\\n    function setDependencies(IContractsRegistry) external virtual;\\n\\n    function injector() public view returns (address _injector) {\\n        bytes32 slot = _INJECTOR_SLOT;\\n\\n        assembly {\\n            _injector := sload(slot)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IBMIDAIStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface IBMIDAIStaking {\\n    struct StakingInfo {\\n        address policyBookAddress;\\n        uint256 stakedBmiDaiAmount;\\n    }\\n\\n    struct PolicyBookInfo {\\n        uint256 totalStakedDai;\\n        uint256 rewardPerBlock;\\n        uint256 stakingAPY;\\n        uint256 liquidityAPY;\\n    }\\n\\n    struct UserInfo {\\n        uint256 totalStakedBmiDai;\\n        uint256 totalStakedDai;\\n        uint256 totalBmiReward;\\n    }\\n\\n    struct NFTsInfo {\\n        uint256 nftIndex;\\n        string uri;\\n        uint256 stakedBmiDaiAmount;\\n        uint256 stakedDaiAmount;\\n        uint256 reward;\\n    }\\n\\n    function aggregateNFTs(address policyBookAddress, uint256[] calldata tokenIds) external;\\n\\n    function stakeDAIx(uint256 amount, address policyBookAddress) external;\\n\\n    function stakeDAIxWithPermit(\\n        uint256 bmiDaiAmount,\\n        address policyBookAddress,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function stakeDAIxFrom(address user, uint256 amount) external;\\n\\n    function stakeDAIxFromWithPermit(\\n        address user,\\n        uint256 bmiDaiAmount,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function getPolicyBookAPY(address policyBookAddress) external view returns (uint256);\\n\\n    function restakeBMIProfit(uint256 tokenId) external;\\n\\n    function restakeStakerBMIProfit(address policyBookAddress) external;\\n\\n    function withdrawBMIProfit(uint256 tokenID) external;\\n\\n    function withdrawStakerBMIProfit(address policyBookAddress) external;\\n\\n    function withdrawFundsWithProfit(uint256 tokenID) external;\\n\\n    function withdrawStakerFundsWithProfit(address policyBookAddress) external;\\n\\n    function stakingInfoByToken(uint256 tokenID) external view returns (StakingInfo memory);\\n\\n    /// @notice exhaustive information about staker's stakes\\n    /// @param staker is a user to return information for\\n    /// @param policyBooksAddresses is an array of PolicyBooks to check the stakes in\\n    /// @param offset is a starting ordinal number of user's NFT\\n    /// @param limit is a number of NFTs to check per function's call\\n    /// @return policyBooksInfo - an array of infos (totalStakedDai, rewardPerBlock (in BMI), stakingAPY, liquidityAPY)\\n    /// @return usersInfo - an array of user's info per PolicyBook (totalStakedBmiDai, totalStakedDai, totalBmiReward)\\n    /// @return nftsCount - number of NFTs for each respective PolicyBook\\n    /// @return nftsInfo - 2 dimensional array of NFTs info per each PolicyBook (nftIndex, uri, stakedBmiDaiAmount, stakedDaiAmount, reward (in BMI))\\n    function stakingInfoByStaker(\\n        address staker,\\n        address[] calldata policyBooksAddresses,\\n        uint256 offset,\\n        uint256 limit\\n    )\\n        external\\n        view\\n        returns (\\n            PolicyBookInfo[] memory policyBooksInfo,\\n            UserInfo[] memory usersInfo,\\n            uint256[] memory nftsCount,\\n            NFTsInfo[][] memory nftsInfo\\n        );\\n\\n    function getSlashedBMIProfit(uint256 tokenId) external view returns (uint256);\\n\\n    function getBMIProfit(uint256 tokenId) external view returns (uint256);\\n\\n    function getSlashedStakerBMIProfit(\\n        address staker,\\n        address policyBookAddress,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256 totalProfit);\\n\\n    function getStakerBMIProfit(\\n        address staker,\\n        address policyBookAddress,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256 totalProfit);\\n\\n    function totalStaked(address user) external view returns (uint256);\\n\\n    function totalStakedDAI(address user) external view returns (uint256);\\n\\n    function stakedByNFT(uint256 tokenId) external view returns (uint256);\\n\\n    function stakedDAIByNFT(uint256 tokenId) external view returns (uint256);\\n\\n    function policyBookByNFT(uint256 tokenId) external view returns (address);\\n\\n    function balanceOf(address user) external view returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function tokenOfOwnerByIndex(address user, uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IClaimingRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IPolicyBookFabric.sol\\\";\\n\\ninterface IClaimingRegistry {\\n    enum ClaimStatus {\\n        CAN_CLAIM,\\n        UNCLAIMABLE,\\n        PENDING,\\n        AWAITING_CALCULATION,\\n        REJECTED_CAN_APPEAL,\\n        REJECTED,\\n        ACCEPTED\\n    }\\n\\n    struct ClaimInfo {\\n        address claimer;\\n        address policyBookAddress;\\n        string evidenceURI;\\n        uint256 dateSubmitted;\\n        uint256 dateEnded;\\n        bool appeal;\\n        ClaimStatus status;\\n        uint256 claimAmount;\\n    }\\n\\n    /// @notice returns anonymous voting duration\\n    function anonymousVotingDuration(uint256 index) external view returns (uint256);\\n\\n    /// @notice returns the whole voting duration\\n    function votingDuration(uint256 index) external view returns (uint256);\\n\\n    /// @notice returns how many time should pass before anyone could calculate a claim result\\n    function anyoneCanCalculateClaimResultAfter(uint256 index) external view returns (uint256);\\n\\n    /// @notice returns true if a user can buy new policy of specified PolicyBook\\n    function canBuyNewPolicy(address buyer, address policyBookAddress)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// @notice submits new PolicyBook claim for the user\\n    function submitClaim(\\n        address user,\\n        address policyBookAddress,\\n        string calldata evidenceURI,\\n        uint256 cover,\\n        bool appeal\\n    ) external returns (uint256);\\n\\n    /// @notice returns true if the claim with this index exists\\n    function claimExists(uint256 index) external view returns (bool);\\n\\n    /// @notice returns claim submition time\\n    function claimSubmittedTime(uint256 index) external view returns (uint256);\\n\\n    /// @notice returns claim end time or zero in case it is pending\\n    function claimEndTime(uint256 index) external view returns (uint256);\\n\\n    /// @notice returns true if the claim is anonymously votable\\n    function isClaimAnonymouslyVotable(uint256 index) external view returns (bool);\\n\\n    /// @notice returns true if the claim is exposably votable\\n    function isClaimExposablyVotable(uint256 index) external view returns (bool);\\n\\n    /// @notice returns true if claim is anonymously votable or exposably votable\\n    function isClaimVotable(uint256 index) external view returns (bool);\\n\\n    /// @notice returns true if a claim can be calculated by anyone\\n    function canClaimBeCalculatedByAnyone(uint256 index) external view returns (bool);\\n\\n    /// @notice returns true if this claim is pending or awaiting\\n    function isClaimPending(uint256 index) external view returns (bool);\\n\\n    /// @notice returns how many claims the holder has\\n    function countPolicyClaimerClaims(address user) external view returns (uint256);\\n\\n    /// @notice returns how many pending claims are there\\n    function countPendingClaims() external view returns (uint256);\\n\\n    /// @notice returns how many claims are there\\n    function countClaims() external view returns (uint256);\\n\\n    /// @notice returns a claim index of it's claimer and an ordinal number\\n    function claimOfOwnerIndexAt(address claimer, uint256 orderIndex)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice returns pending claim index by its ordinal index\\n    function pendingClaimIndexAt(uint256 orderIndex) external view returns (uint256);\\n\\n    /// @notice returns claim index by its ordinal index\\n    function claimIndexAt(uint256 orderIndex) external view returns (uint256);\\n\\n    /// @notice returns current active claim index by policybook and claimer\\n    function claimIndex(address claimer, address policyBookAddress)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice returns true if the claim is appealed\\n    function isClaimAppeal(uint256 index) external view returns (bool);\\n\\n    /// @notice returns current status of a claim\\n    function policyStatus(address claimer, address policyBookAddress)\\n        external\\n        view\\n        returns (ClaimStatus);\\n\\n    /// @notice returns current status of a claim\\n    function claimStatus(uint256 index) external view returns (ClaimStatus);\\n\\n    /// @notice returns the claim owner (claimer)\\n    function claimOwner(uint256 index) external view returns (address);\\n\\n    /// @notice returns the claim PolicyBook\\n    function claimPolicyBook(uint256 index) external view returns (address);\\n\\n    /// @notice returns claim info by its index\\n    function claimInfo(uint256 index) external view returns (ClaimInfo memory _claimInfo);\\n\\n    /// @notice marks the user's claim as Accepted\\n    function acceptClaim(uint256 index) external;\\n\\n    /// @notice marks the user's claim as Rejected\\n    function rejectClaim(uint256 index) external;\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IContractsRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface IContractsRegistry {\\n    function getUniswapRouterContract() external view returns (address);\\n\\n    function getUniswapBMIToETHPairContract() external view returns (address);\\n\\n    function getWETHContract() external view returns (address);\\n\\n    function getDAIContract() external view returns (address);\\n\\n    function getBMIContract() external view returns (address);\\n\\n    function getPriceFeedContract() external view returns (address);\\n\\n    function getPolicyBookRegistryContract() external view returns (address);\\n\\n    function getPolicyBookFabricContract() external view returns (address);\\n\\n    function getBMIDAIStakingContract() external view returns (address);\\n\\n    function getRewardsGeneratorContract() external view returns (address);\\n\\n    function getBMIUtilityNFTContract() external view returns (address);\\n\\n    function getLiquidityMiningContract() external view returns (address);\\n\\n    function getClaimingRegistryContract() external view returns (address);\\n\\n    function getPolicyRegistryContract() external view returns (address);\\n\\n    function getLiquidityRegistryContract() external view returns (address);\\n\\n    function getClaimVotingContract() external view returns (address);\\n\\n    function getReinsurancePoolContract() external view returns (address);\\n\\n    function getPolicyBookAdminContract() external view returns (address);\\n\\n    function getPolicyQuoteContract() external view returns (address);\\n\\n    function getLegacyBMIStakingContract() external view returns (address);\\n\\n    function getBMIStakingContract() external view returns (address);\\n\\n    function getSTKBMIContract() external view returns (address);\\n\\n    function getVBMIContract() external view returns (address);\\n\\n    function getLegacyLiquidityMiningStakingContract() external view returns (address);\\n\\n    function getLiquidityMiningStakingContract() external view returns (address);\\n\\n    function getReputationSystemContract() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/ILiquidityRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface ILiquidityRegistry {\\n    struct LiquidityInfo {\\n        address policyBookAddr;\\n        uint256 lockedAmount;\\n        uint256 availableAmount;\\n        uint256 bmiDaiRatio; // multiply availableAmount by this num to get DAI\\n    }\\n\\n    struct WithdrawalRequestInfo {\\n        address policyBookAddr;\\n        uint256 requestAmount;\\n        uint256 requestDAIAmount;\\n        uint256 availableLiquidity;\\n        uint256 readyToWithdrawDate;\\n        uint256 endWithdrawDate;\\n    }\\n\\n    struct WithdrawalSetInfo {\\n        address policyBookAddr;\\n        uint256 requestAmount;\\n        uint256 requestDAIAmount;\\n        uint256 availableDAIAmount;\\n    }\\n\\n    function tryToAddPolicyBook(address _userAddr, address _policyBookAddr) external;\\n\\n    function tryToRemovePolicyBook(address _userAddr, address _policyBookAddr) external;\\n\\n    function getPolicyBooksArrLength(address _userAddr) external view returns (uint256);\\n\\n    function getPolicyBooksArr(address _userAddr)\\n        external\\n        view\\n        returns (address[] memory _resultArr);\\n\\n    function getLiquidityInfos(\\n        address _userAddr,\\n        uint256 _offset,\\n        uint256 _limit\\n    ) external view returns (LiquidityInfo[] memory _resultArr);\\n\\n    function getWithdrawalRequests(\\n        address _userAddr,\\n        uint256 _offset,\\n        uint256 _limit\\n    ) external view returns (uint256 _arrLength, WithdrawalRequestInfo[] memory _resultArr);\\n\\n    function getWithdrawalSet(\\n        address _userAddr,\\n        uint256 _offset,\\n        uint256 _limit\\n    ) external view returns (uint256 _arrLength, WithdrawalSetInfo[] memory _resultArr);\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IPolicyBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IPolicyBookFabric.sol\\\";\\nimport \\\"./IClaimingRegistry.sol\\\";\\n\\ninterface IPolicyBook {\\n    enum WithdrawalStatus {NONE, PENDING, READY, EXPIRED}\\n\\n    struct PolicyHolder {\\n        uint256 coverTokens;\\n        uint256 startEpochNumber;\\n        uint256 endEpochNumber;\\n        uint256 paid;\\n    }\\n\\n    struct WithdrawalInfo {\\n        uint256 withdrawalAmount;\\n        uint256 readyToWithdrawDate;\\n        bool withdrawalAllowed;\\n    }\\n\\n    function EPOCH_DURATION() external view returns (uint256);\\n\\n    function READY_TO_WITHDRAW_PERIOD() external view returns (uint256);\\n\\n    function whitelisted() external view returns (bool);\\n\\n    function epochStartTime() external view returns (uint256);\\n\\n    // @TODO: should we let DAO to change contract address?\\n    /// @notice Returns address of contract this PolicyBook covers, access: ANY\\n    /// @return _contract is address of covered contract\\n    function insuranceContractAddress() external view returns (address _contract);\\n\\n    /// @notice Returns type of contract this PolicyBook covers, access: ANY\\n    /// @return _type is type of contract\\n    function contractType() external view returns (IPolicyBookFabric.ContractType _type);\\n\\n    function totalLiquidity() external view returns (uint256);\\n\\n    function totalCoverTokens() external view returns (uint256);\\n\\n    function withdrawalsInfo(address _userAddr)\\n        external\\n        view\\n        returns (\\n            uint256 _withdrawalAmount,\\n            uint256 _readyToWithdrawDate,\\n            bool _withdrawalAllowed\\n        );\\n\\n    function __PolicyBook_init(\\n        address _insuranceContract,\\n        IPolicyBookFabric.ContractType _contractType,\\n        string calldata _description,\\n        string calldata _projectSymbol\\n    ) external;\\n\\n    function whitelist(bool _whitelisted) external;\\n\\n    function getEpoch(uint256 time) external view returns (uint256);\\n\\n    /// @notice get DAI equivalent\\n    function convertDAIXToDAI(uint256 _amount) external view returns (uint256);\\n\\n    /// @notice get DAIx equivalent\\n    function convertDAIToDAIX(uint256 _amount) external view returns (uint256);\\n\\n    /// @notice returns how many BMI tokens needs to approve in order to submit a claim\\n    function getClaimApprovalAmount(address user) external view returns (uint256);\\n\\n    /// @notice submits new claim of the policy book\\n    function submitClaimAndInitializeVoting(string calldata evidenceURI) external;\\n\\n    /// @notice submits new appeal claim of the policy book\\n    function submitAppealAndInitializeVoting(string calldata evidenceURI) external;\\n\\n    /// @notice updates info on claim acceptance\\n    function commitClaim(\\n        address claimer,\\n        uint256 claimAmount,\\n        uint256 claimEndTime,\\n        IClaimingRegistry.ClaimStatus status\\n    ) external;\\n\\n    /// @notice function to get precise current cover and liquidity\\n    function getNewCoverAndLiquidity()\\n        external\\n        view\\n        returns (uint256 newTotalCoverTokens, uint256 newTotalLiquidity);\\n\\n    /// @notice view function to get precise policy price\\n    function getPolicyPrice(uint256 _epochsNumber, uint256 _coverTokens)\\n        external\\n        view\\n        returns (uint256 totalSeconds, uint256 totalPrice);\\n\\n    function buyPolicyFor(\\n        address _buyer,\\n        uint256 _epochsNumber,\\n        uint256 _coverTokens\\n    ) external;\\n\\n    /// @notice Let user to buy policy by supplying DAI, access: ANY\\n    /// @param _durationSeconds is number of seconds to cover\\n    /// @param _coverTokens is number of tokens to cover\\n    function buyPolicy(uint256 _durationSeconds, uint256 _coverTokens) external;\\n\\n    function updateEpochsInfo() external;\\n\\n    function secondsToEndCurrentEpoch() external view returns (uint256);\\n\\n    /// @notice Let user to add liquidity by supplying DAI, access: ANY\\n    /// @param _liqudityAmount is amount of DAI tokens to secure\\n    function addLiquidity(uint256 _liqudityAmount) external;\\n\\n    /// @notice Let eligible contracts add liqiudity for another user by supplying DAI\\n    /// @param _liquidityHolderAddr is address of address to assign cover\\n    /// @param _liqudityAmount is amount of DAI tokens to secure\\n    function addLiquidityFor(address _liquidityHolderAddr, uint256 _liqudityAmount) external;\\n\\n    function addLiquidityAndStake(uint256 _liquidityAmount, uint256 _bmiDAIxAmount) external;\\n\\n    function getAvailableDAIXWithdrawableAmount(address _userAddr) external view returns (uint256);\\n\\n    function getWithdrawalStatus(address _userAddr) external view returns (WithdrawalStatus);\\n\\n    function requestWithdrawal(uint256 _tokensToWithdraw) external;\\n\\n    function requestWithdrawalWithPermit(\\n        uint256 _tokensToWithdraw,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external;\\n\\n    function unlockTokens() external;\\n\\n    /// @notice Let user to withdraw deposited liqiudity, access: ANY\\n    function withdrawLiquidity() external;\\n\\n    function getAPY() external view returns (uint256);\\n\\n    /// @notice Getting user stats, access: ANY\\n    function userStats(address _user) external view returns (PolicyHolder memory);\\n\\n    /// @notice Getting number stats, access: ANY\\n    /// @return _maxCapacities is a max token amount that a user can buy\\n    /// @return _totalDaiLiquidity is PolicyBook's liquidity\\n    /// @return _stakedDAI is how much DAI are staked on this PolicyBook\\n    /// @return _annualProfitYields is its APY\\n    /// @return _annualInsuranceCost is percentage of cover tokens that is required to be paid for 1 year of insurance\\n    function numberStats()\\n        external\\n        view\\n        returns (\\n            uint256 _maxCapacities,\\n            uint256 _totalDaiLiquidity,\\n            uint256 _stakedDAI,\\n            uint256 _annualProfitYields,\\n            uint256 _annualInsuranceCost,\\n            uint256 _bmiDaiRatio\\n        );\\n\\n    /// @notice Getting info, access: ANY\\n    /// @return _symbol is the symbol of PolicyBook (bmiDaiX)\\n    /// @return _insuredContract is an addres of insured contract\\n    /// @return _contractType is a type of insured contract\\n    /// @return _whitelisted is a state of whitelisting\\n    function info()\\n        external\\n        view\\n        returns (\\n            string memory _symbol,\\n            address _insuredContract,\\n            IPolicyBookFabric.ContractType _contractType,\\n            bool _whitelisted\\n        );\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IPolicyBookFabric.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\n\\ninterface IPolicyBookFabric {\\n    enum ContractType {CONTRACT, STABLECOIN, SERVICE, EXCHANGE}\\n\\n    /// @notice Create new Policy Book contract, access: ANY\\n    /// @param _contract is Contract to create policy book for\\n    /// @param _contractType is Contract to create policy book for\\n    /// @param _description is bmiDAIx token desription for this policy book\\n    /// @param _projectSymbol replaces x in bmiDAIx token symbol\\n    /// @param _initialDeposit is an amount user deposits on creation (addLiquidity())\\n    /// @return _policyBook is address of created contract\\n    function create(\\n        address _contract,\\n        ContractType _contractType,\\n        string calldata _description,\\n        string calldata _projectSymbol,\\n        uint256 _initialDeposit\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"/Users/home/BMI/bridgemutual-core/contracts/interfaces/IPolicyBookRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IPolicyBookFabric.sol\\\";\\n\\ninterface IPolicyBookRegistry {\\n    struct PolicyBookStats {\\n        string symbol;\\n        address insuredContract;\\n        IPolicyBookFabric.ContractType contractType;\\n        uint256 maxCapacity;\\n        uint256 totalDaiLiquidity;\\n        uint256 stakedDAI;\\n        uint256 APY;\\n        uint256 annualInsuranceCost;\\n        uint256 bmiDaiRatio;\\n        bool whitelisted;\\n    }\\n\\n    /// @notice Adds PolicyBook to registry, access: PolicyFabric\\n    function add(\\n        address insuredContract,\\n        IPolicyBookFabric.ContractType contractType,\\n        address policyBook\\n    ) external;\\n\\n    function whitelist(address policyBookAddress, bool whitelisted) external;\\n\\n    /// @notice returns required allowances for the policybooks\\n    function getPoliciesPrices(\\n        address[] calldata policyBooks,\\n        uint256[] calldata epochsNumbers,\\n        uint256[] calldata coversTokens\\n    ) external view returns (uint256[] memory _durations, uint256[] memory _allowances);\\n\\n    /// @notice Buys a batch of policies\\n    function buyPolicyBatch(\\n        address[] calldata policyBooks,\\n        uint256[] calldata epochsNumbers,\\n        uint256[] calldata coversTokens\\n    ) external;\\n\\n    /// @notice Checks if provided address is a PolicyBook\\n    function isPolicyBook(address policyBook) external view returns (bool);\\n\\n    /// @notice Returns number of registered PolicyBooks with certain contract type\\n    function countByType(IPolicyBookFabric.ContractType contractType)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Returns number of registered PolicyBooks, access: ANY\\n    function count() external view returns (uint256);\\n\\n    function countByTypeWhitelisted(IPolicyBookFabric.ContractType contractType)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function countWhitelisted() external view returns (uint256);\\n\\n    /// @notice Listing registered PolicyBooks with certain contract type, access: ANY\\n    /// @return _policyBooksArr is array of registered PolicyBook addresses with certain contract type\\n    function listByType(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory _policyBooksArr);\\n\\n    /// @notice Listing registered PolicyBooks, access: ANY\\n    /// @return _policyBooksArr is array of registered PolicyBook addresses\\n    function list(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (address[] memory _policyBooksArr);\\n\\n    function listByTypeWhitelisted(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory _policyBooksArr);\\n\\n    function listWhitelisted(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (address[] memory _policyBooksArr);\\n\\n    /// @notice Listing registered PolicyBooks with stats and certain contract type, access: ANY\\n    function listWithStatsByType(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats);\\n\\n    /// @notice Listing registered PolicyBooks with stats, access: ANY\\n    function listWithStats(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats);\\n\\n    function listWithStatsByTypeWhitelisted(\\n        IPolicyBookFabric.ContractType contractType,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats);\\n\\n    function listWithStatsWhitelisted(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (address[] memory _policyBooksArr, PolicyBookStats[] memory _stats);\\n\\n    /// @notice Getting stats from policy books, access: ANY\\n    /// @param policyBooks is list of PolicyBooks addresses\\n    function stats(address[] calldata policyBooks)\\n        external\\n        view\\n        returns (PolicyBookStats[] memory _stats);\\n\\n    /// @notice Return existing Policy Book contract, access: ANY\\n    /// @param insuredContract is contract address to lookup for created IPolicyBook\\n    function policyBookFor(address insuredContract) external view returns (address);\\n\\n    /// @notice Getting stats from policy books, access: ANY\\n    /// @param insuredContracts is list of insuredContracts in registry\\n    function statsByInsuredContracts(address[] calldata insuredContracts)\\n        external\\n        view\\n        returns (PolicyBookStats[] memory _stats);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_policyBookAddress\",\"type\":\"address\"}],\"name\":\"PolicyBookAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_policyBookAddress\",\"type\":\"address\"}],\"name\":\"PolicyBookRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bmiDaiStaking\",\"outputs\":[{\"internalType\":\"contract IBMIDAIStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"getLiquidityInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"policyBookAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bmiDaiRatio\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityRegistry.LiquidityInfo[]\",\"name\":\"_resultArr\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getPolicyBooksArr\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_resultArr\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getPolicyBooksArrLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"getWithdrawalRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_arrLength\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"policyBookAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestDAIAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"readyToWithdrawDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endWithdrawDate\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityRegistry.WithdrawalRequestInfo[]\",\"name\":\"_resultArr\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"getWithdrawalSet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_arrLength\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"policyBookAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestDAIAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableDAIAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityRegistry.WithdrawalSetInfo[]\",\"name\":\"_resultArr\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"injector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_injector\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policyBookRegistry\",\"outputs\":[{\"internalType\":\"contract IPolicyBookRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IContractsRegistry\",\"name\":\"_contractsRegistry\",\"type\":\"address\"}],\"name\":\"setDependencies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_injector\",\"type\":\"address\"}],\"name\":\"setInjector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policyBookAddr\",\"type\":\"address\"}],\"name\":\"tryToAddPolicyBook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policyBookAddr\",\"type\":\"address\"}],\"name\":\"tryToRemovePolicyBook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidityRegistry","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}