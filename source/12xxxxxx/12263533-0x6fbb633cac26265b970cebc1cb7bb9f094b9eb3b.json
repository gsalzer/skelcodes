{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.2 \\u003c0.8.0;\\r\\n\\r\\nlibrary Address {\\r\\n   \\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n    \\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n \\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"IERC20Interface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\ninterface IERC20{\\r\\n    function approve( address, uint256)  external returns(bool);\\r\\n\\r\\n     function allowance(address, address) external view returns (uint256);\\r\\n    function balanceOf(address)  external view returns(uint256);\\r\\n\\r\\n    function decimals()  external view returns(uint8);\\r\\n\\r\\n    function totalSupply() external  view returns(uint256);\\r\\n\\r\\n    function transferFrom(address,address,uint256) external  returns(bool);\\r\\n\\r\\n    function transfer(address,uint256) external  returns(bool);\\r\\n    function mint(address , uint256 ) external ;\\r\\n    function burn(address , uint256 ) external ;\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor () internal {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\\r\\n\"},\"RoyaleLP.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.6.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n\\r\\nimport \\u0027./StrategyInterface.sol\\u0027;\\r\\nimport \\u0027./ReentrancyGuard.sol\\u0027;\\r\\nimport \\u0027./SafeERC20.sol\\u0027;\\r\\n\\r\\ncontract RoyaleLP is ReentrancyGuard {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    uint256 public constant DENOMINATOR = 10000;\\r\\n\\r\\n    uint128 public fees = 25; // for .25% fee, for 1.75% fee =\\u003e 175\\r\\n\\r\\n    uint256 public poolPart = 750 ; // 7.5% of total Liquidity will remain in the pool\\r\\n\\r\\n    uint256 public selfBalance;\\r\\n\\r\\n    IERC20[3] public tokens;\\r\\n\\r\\n    IERC20 public rpToken;\\r\\n\\r\\n    rStrategy public strategy;\\r\\n    \\r\\n    address public wallet;\\r\\n    \\r\\n    address public nominatedWallet;\\r\\n\\r\\n    uint public YieldPoolBalance;\\r\\n    uint public liquidityProvidersAPY;\\r\\n\\r\\n    //storage for user related to supply and withdraw\\r\\n    \\r\\n    uint256 public lock_period = 1209600;\\r\\n\\r\\n    struct depositDetails {\\r\\n        uint index;\\r\\n        uint amount;\\r\\n        uint256 time;\\r\\n        uint256 remAmt;\\r\\n    }\\r\\n    \\r\\n    mapping(address =\\u003e depositDetails[]) public amountSupplied;\\r\\n    mapping(address =\\u003e uint256[3]) public amountWithdraw;\\r\\n    mapping(address =\\u003e uint256[3]) public amountBurnt;\\r\\n    \\r\\n    mapping(address =\\u003e bool) public isInQ;\\r\\n    \\r\\n    address[] public withdrawRecipients;\\r\\n    \\r\\n    uint public maxWithdrawRequests=25;\\r\\n    \\r\\n    uint256[3] public totalWithdraw;\\r\\n    \\r\\n    uint[3] public reserveAmount;\\r\\n    mapping(address =\\u003e bool)public reserveRecipients;\\r\\n    \\r\\n    //storage to store total loan given\\r\\n    uint256 public loanGiven;\\r\\n    \\r\\n    uint public loanPart=2000;\\r\\n    \\r\\n  \\r\\n    modifier onlyWallet(){\\r\\n      require(wallet ==msg.sender, \\\"NA\\\");\\r\\n      _;\\r\\n    }\\r\\n  \\r\\n     modifier validAmount(uint amount){\\r\\n      require(amount \\u003e 0 , \\\"NV\\\");\\r\\n      _;\\r\\n    }\\r\\n    \\r\\n    // EVENTS \\r\\n    event userSupplied(address user,uint amount);\\r\\n    event userRecieved(address user,uint amount);\\r\\n    event userAddedToQ(address user,uint amount);\\r\\n    event yieldAdded(uint amount);\\r\\n    event walletNominated(address newOwner);\\r\\n    event walletChanged(address oldOwner, address newOwner);\\r\\n   \\r\\n    \\r\\n    constructor(address[3] memory _tokens,address _rpToken,address _wallet) public {\\r\\n        require(_wallet != address(0), \\\"Wallet address cannot be 0\\\");\\r\\n        for(uint8 i=0; i\\u003c3; i++) {\\r\\n            tokens[i] = IERC20(_tokens[i]);\\r\\n        }\\r\\n        rpToken = IERC20(_rpToken);\\r\\n        wallet=_wallet;\\r\\n    }\\r\\n    \\r\\n    function nominateNewOwner(address _wallet) external onlyWallet {\\r\\n        nominatedWallet = _wallet;\\r\\n        emit walletNominated(_wallet);\\r\\n    }\\r\\n\\r\\n    function acceptOwnership() external {\\r\\n        require(msg.sender == nominatedWallet, \\\"You must be nominated before you can accept ownership\\\");\\r\\n        emit walletChanged(wallet, nominatedWallet);\\r\\n        wallet = nominatedWallet;\\r\\n        nominatedWallet = address(0);\\r\\n    }\\r\\n\\r\\n\\r\\n    /* INTERNAL FUNCTIONS */\\r\\n   \\r\\n    \\r\\n    //For checking whether array contains any non zero elements or not.\\r\\n    function checkValidArray(uint256[3] memory amounts)internal pure returns(bool){\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            if(amounts[i]\\u003e0){\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // This function deposits the liquidity to yield generation pool using yield Strategy contract\\r\\n    function _deposit(uint256[3] memory amounts) internal {\\r\\n        strategy.deposit(amounts);\\r\\n        uint decimal;\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            decimal=tokens[i].decimals();\\r\\n            YieldPoolBalance =YieldPoolBalance.add(amounts[i].mul(10**18).div(10**decimal));\\r\\n        }\\r\\n    }\\r\\n   \\r\\n\\r\\n    //This function is used to updating the array of user\\u0027s individual deposit , called when users withdraw/claim tokens.\\r\\n    function updateLockedRPT(address recipient,uint256 amount) internal{\\r\\n        for(uint8 j=0; j\\u003camountSupplied[recipient].length; j++) {\\r\\n            if(amountSupplied[recipient][j].remAmt \\u003e 0 \\u0026\\u0026 amount \\u003e 0 ) {\\r\\n                if(amount \\u003e= amountSupplied[recipient][j].remAmt) {\\r\\n                        amount = amount.sub( amountSupplied[recipient][j].remAmt);\\r\\n                        amountSupplied[recipient][j].remAmt = 0;\\r\\n                }\\r\\n                else {\\r\\n                        amountSupplied[recipient][j].remAmt =(amountSupplied[recipient][j].remAmt).sub(amount);\\r\\n                        amount = 0;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n     }\\r\\n\\r\\n    //Funtion determines whether requested withdrawl amount is available in the pool or not.\\r\\n    //If yes then fulfills withdraw request \\r\\n    //and if no then put the request into the withdraw queue.\\r\\n    function checkWithdraw(uint256 amount,uint256 burnAmt,uint _index) internal{\\r\\n        uint256 poolBalance;\\r\\n        poolBalance = getBalances(_index);\\r\\n        rpToken.burn(msg.sender, burnAmt);\\r\\n        if(amount \\u003c= poolBalance) {\\r\\n            uint decimal;\\r\\n            decimal=tokens[_index].decimals();\\r\\n            uint temp = amount.sub(amount.mul(fees).div(DENOMINATOR));\\r\\n            selfBalance=selfBalance.sub(temp.mul(10**18).div(10**decimal));\\r\\n            updateLockedRPT(msg.sender,burnAmt);\\r\\n            tokens[_index].safeTransfer(msg.sender, temp);\\r\\n            emit userRecieved(msg.sender, temp); \\r\\n         }\\r\\n         else {\\r\\n             require(withdrawRecipients.length\\u003cmaxWithdrawRequests || isInQ[msg.sender],\\\"requests limit Exceeded\\\");\\r\\n            _takeBackQ(amount,burnAmt,_index);\\r\\n            emit userAddedToQ(msg.sender, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    // this will add unfulfilled withdraw requests to the withdrawl queue\\r\\n    function _takeBackQ(uint256 amount,uint256 _burnAmount,uint256 _index) internal {\\r\\n        amountWithdraw[msg.sender][_index] =amountWithdraw[msg.sender][_index].add( amount);\\r\\n        amountBurnt[msg.sender][_index]=amountBurnt[msg.sender][_index].add(_burnAmount);\\r\\n        uint currentPoolAmount=getBalances(_index);\\r\\n        uint withdrawAmount=amount.sub(currentPoolAmount);\\r\\n        reserveAmount[_index] = reserveAmount[_index].add(currentPoolAmount);\\r\\n        totalWithdraw[_index]=totalWithdraw[_index].add(withdrawAmount);\\r\\n        uint total;\\r\\n        total=(totalWithdraw[1].add(totalWithdraw[2])).mul(1e18).div(10**6);\\r\\n        require((totalWithdraw[0]+total)\\u003c=YieldPoolBalance,\\\"Not enough balance\\\");\\r\\n        if(!isInQ[msg.sender]) {\\r\\n            isInQ[msg.sender] = true;\\r\\n            withdrawRecipients.push(msg.sender);\\r\\n            \\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    //this function is called when Royale Govenance withdrawl from yield generation pool.It add all the withdrawl amount in the reserve amount.\\r\\n    //All the users who requested for the withdrawl are added to the reserveRecipients.\\r\\n    function updateWithdrawQueue() internal{\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            reserveAmount[i]=reserveAmount[i].add(totalWithdraw[i]);\\r\\n            totalWithdraw[i]=0;\\r\\n        }\\r\\n        for(uint i=0; i\\u003cwithdrawRecipients.length; i++) {\\r\\n            reserveRecipients[withdrawRecipients[i]]=true;\\r\\n            isInQ[withdrawRecipients[i]]=false;\\r\\n        }\\r\\n        uint count=withdrawRecipients.length;\\r\\n        for(uint i=0;i\\u003ccount;i++){\\r\\n            withdrawRecipients.pop();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // this will withdraw Liquidity from yield genaration pool using yield Strategy\\r\\n    function _withdraw(uint256[3] memory amounts) internal {\\r\\n        strategy.withdraw(amounts);\\r\\n        uint decimal;\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            decimal=tokens[i].decimals();\\r\\n            YieldPoolBalance =YieldPoolBalance.sub(amounts[i].mul(10**18).div(10**decimal));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //This function calculate RPT to be mint or burn\\r\\n    //amount parameter is amount of token\\r\\n    //_index can be 0/1/2 \\r\\n    //0-DAI\\r\\n    //1-USDC\\r\\n    //2-USDT\\r\\n    function calcRptAmount(uint256 amount,uint _index) public view returns(uint256) {\\r\\n        uint256 total = calculateTotalToken(true);\\r\\n        uint256 decimal = 0;\\r\\n        decimal=tokens[_index].decimals();\\r\\n        amount=amount.mul(1e18).div(10**decimal);\\r\\n        if(total==0){\\r\\n            return amount;\\r\\n        }\\r\\n        else{\\r\\n          return (amount.mul(rpToken.totalSupply()).div(total)); \\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    //function to check available amount to withdraw for user\\r\\n    function availableLiquidity(address addr, uint coin,bool _time) public view returns(uint256 token,uint256 RPT) {\\r\\n        uint256 amount=0;\\r\\n        for(uint8 j=0; j\\u003camountSupplied[addr].length; j++) {\\r\\n                if( (!_time || (now - amountSupplied[addr][j].time)  \\u003e lock_period)\\u0026\\u0026amountSupplied[addr][j].remAmt \\u003e0)   {\\r\\n                        amount =amount.add(amountSupplied[addr][j].remAmt);\\r\\n                }\\r\\n        }\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            amount =amount.sub(amountBurnt[addr][i]);\\r\\n        }\\r\\n        uint256 total=calculateTotalToken(true);\\r\\n        uint256 decimal;\\r\\n        decimal=tokens[coin].decimals();\\r\\n        return ((amount.mul(total).mul(10**decimal).div(rpToken.totalSupply())).div(10**18),amount);\\r\\n    }\\r\\n    \\r\\n\\r\\n    //calculated available total tokens in the pool by substracting withdrawal, reserve amount.\\r\\n    //In case supply is true , it adds total loan given.\\r\\n    function calculateTotalToken(bool _supply)public view returns(uint256){\\r\\n        uint256 decimal;\\r\\n        uint withdrawTotal;\\r\\n        uint reserveTotal;\\r\\n       \\r\\n        for(uint8 i=0; i\\u003c3; i++) {\\r\\n            decimal = tokens[i].decimals();\\r\\n            withdrawTotal=withdrawTotal.add(totalWithdraw[i].mul(1e18).div(10**decimal));\\r\\n            reserveTotal=reserveTotal.add(reserveAmount[i].mul(1e18).div(10**decimal));\\r\\n        } \\r\\n        if(_supply){\\r\\n            return selfBalance.sub(withdrawTotal).sub(reserveTotal).add(loanGiven);\\r\\n        }\\r\\n        else{\\r\\n            return selfBalance.sub(withdrawTotal).sub(reserveTotal);\\r\\n        }\\r\\n        \\r\\n    }\\r\\n    \\r\\n    /* USER FUNCTIONS (exposed to frontend) */\\r\\n   \\r\\n    //For depositing liquidity to the pool.\\r\\n    //_index will be 0/1/2     0-DAI , 1-USDC , 2-USDT\\r\\n    function supply(uint256 amount,uint256 _index) external nonReentrant  validAmount(amount){\\r\\n        uint decimal;\\r\\n        uint256 mintAmount=calcRptAmount(amount,_index);\\r\\n        amountSupplied[msg.sender].push(depositDetails(_index,amount,now,mintAmount));\\r\\n        decimal=tokens[_index].decimals();\\r\\n        selfBalance=selfBalance.add(amount.mul(10**18).div(10**decimal));\\r\\n        tokens[_index].safeTransferFrom(msg.sender, address(this), amount);\\r\\n        rpToken.mint(msg.sender, mintAmount);\\r\\n        emit userSupplied(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    \\r\\n    //for withdrawing the liquidity\\r\\n    //First Parameter is amount of RPT\\r\\n    //Second is which token to be withdrawal with this RPT.\\r\\n    function requestWithdrawWithRPT(uint256 amount,uint256 _index) external nonReentrant validAmount(amount){\\r\\n        require(!reserveRecipients[msg.sender],\\\"Claim first\\\");\\r\\n        require(rpToken.balanceOf(msg.sender) \\u003e= amount, \\\"low RPT\\\");\\r\\n        (,uint availableRPT)=availableLiquidity(msg.sender,_index,true );\\r\\n        require(availableRPT\\u003e=amount,\\\"NA\\\");\\r\\n        uint256 total = calculateTotalToken(true);\\r\\n        uint256 tokenAmount;\\r\\n        tokenAmount=amount.mul(total).div(rpToken.totalSupply());\\r\\n        require(tokenAmount \\u003c= calculateTotalToken(false),\\\"Not Enough Pool balance\\\");\\r\\n        uint decimal;\\r\\n        decimal=tokens[_index].decimals();\\r\\n        checkWithdraw(tokenAmount.mul(10**decimal).div(10**18),amount,_index);  \\r\\n    }\\r\\n    \\r\\n    //For claiming withdrawal after user added to the reserve recipient.\\r\\n    function claimTokens() external  nonReentrant{\\r\\n        require(reserveRecipients[msg.sender] , \\\"request withdraw first\\\");\\r\\n        \\r\\n        uint totalBurnt;\\r\\n        uint decimal;\\r\\n        for(uint8 i=0; i\\u003c3; i++) {\\r\\n            if(amountWithdraw[msg.sender][i] \\u003e 0) {\\r\\n                decimal=tokens[i].decimals();\\r\\n                uint temp = amountWithdraw[msg.sender][i].sub((amountWithdraw[msg.sender][i].mul(fees)).div(DENOMINATOR));\\r\\n                reserveAmount[i] =reserveAmount[i].sub(amountWithdraw[msg.sender][i]);\\r\\n                selfBalance = selfBalance.sub(temp.mul(1e18).div(10**decimal));\\r\\n                totalBurnt =totalBurnt.add(amountBurnt[msg.sender][i]);\\r\\n                amountWithdraw[msg.sender][i] = 0;\\r\\n                amountBurnt[msg.sender][i]=0;\\r\\n                tokens[i].safeTransfer(msg.sender,  temp);\\r\\n                emit userRecieved(msg.sender,temp);\\r\\n            }\\r\\n        }\\r\\n        updateLockedRPT(msg.sender,totalBurnt);\\r\\n        reserveRecipients[msg.sender] = false;\\r\\n    }\\r\\n\\r\\n\\r\\n    // this function deposits without minting RPT.\\r\\n    //Used to deposit Yield\\r\\n    function depositYield(uint256 amount,uint _index) external{\\r\\n        uint decimal;\\r\\n        decimal=tokens[_index].decimals();\\r\\n        selfBalance=selfBalance.add(amount.mul(1e18).div(10**decimal));\\r\\n        liquidityProvidersAPY=liquidityProvidersAPY.add(amount.mul(1e18).div(10**decimal));\\r\\n        tokens[_index].safeTransferFrom(msg.sender,address(this),amount);\\r\\n        emit yieldAdded(amount);\\r\\n    }\\r\\n\\r\\n\\r\\n    /* CORE FUNCTIONS (called by owner only) */\\r\\n\\r\\n    //Transfer token to rStrategy by maintaining pool ratio.\\r\\n    function deposit() onlyWallet() external  {\\r\\n        uint256[3] memory amounts;\\r\\n        uint256 totalAmount;\\r\\n        uint256 decimal;\\r\\n        totalAmount=calculateTotalToken(false);\\r\\n        uint balanceAmount=totalAmount.mul(poolPart.div(3)).div(DENOMINATOR);\\r\\n        uint tokenBalance;\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            decimal=tokens[i].decimals();\\r\\n            amounts[i]=getBalances(i);\\r\\n            tokenBalance=balanceAmount.mul(10**decimal).div(10**18);\\r\\n            if(amounts[i]\\u003etokenBalance) {\\r\\n                amounts[i]=amounts[i].sub(tokenBalance);\\r\\n                tokens[i].safeTransfer(address(strategy),amounts[i]);\\r\\n            }\\r\\n            else{\\r\\n                amounts[i]=0;\\r\\n            }\\r\\n        }\\r\\n        if(checkValidArray(amounts)){\\r\\n            _deposit(amounts);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\r\\n    //Withdraw from Yield genaration pool.\\r\\n    function withdraw() onlyWallet() external  {\\r\\n        require(checkValidArray(totalWithdraw), \\\"queue empty\\\");\\r\\n        _withdraw(totalWithdraw);\\r\\n        updateWithdrawQueue();\\r\\n    }\\r\\n\\r\\n   //Withdraw total liquidity from yield generation pool\\r\\n    function withdrawAll() external onlyWallet() {\\r\\n        uint[3] memory amounts;\\r\\n        amounts=strategy.withdrawAll();\\r\\n        uint decimal;\\r\\n        selfBalance=0;\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            decimal=tokens[i].decimals();\\r\\n            selfBalance=selfBalance.add((tokens[i].balanceOf(address(this))).mul(1e18).div(10**decimal));\\r\\n        }\\r\\n        YieldPoolBalance=0;\\r\\n        updateWithdrawQueue();\\r\\n    }\\r\\n\\r\\n\\r\\n    //function for rebalancing royale pool(ratio)      \\r\\n    function rebalance() onlyWallet() external {\\r\\n        uint256 currentAmount;\\r\\n        uint256[3] memory amountToWithdraw;\\r\\n        uint256[3] memory amountToDeposit;\\r\\n        uint totalAmount;\\r\\n        uint256 decimal;\\r\\n        totalAmount=calculateTotalToken(false);\\r\\n        uint balanceAmount=totalAmount.mul(poolPart.div(3)).div(DENOMINATOR);\\r\\n        uint tokenBalance;\\r\\n        for(uint8 i=0;i\\u003c3;i++) {\\r\\n           currentAmount=getBalances(i);\\r\\n           decimal=tokens[i].decimals();\\r\\n           tokenBalance=balanceAmount.mul(10**decimal).div(10**18);\\r\\n           if(tokenBalance \\u003e currentAmount) {\\r\\n              amountToWithdraw[i] = tokenBalance.sub(currentAmount);\\r\\n           }\\r\\n           else if(tokenBalance \\u003c currentAmount) {\\r\\n               amountToDeposit[i] = currentAmount.sub(tokenBalance);\\r\\n               tokens[i].safeTransfer(address(strategy), amountToDeposit[i]);\\r\\n               \\r\\n           }\\r\\n           else {\\r\\n               amountToWithdraw[i] = 0;\\r\\n               amountToDeposit[i] = 0;\\r\\n           }\\r\\n        }\\r\\n        if(checkValidArray(amountToDeposit)){\\r\\n             _deposit(amountToDeposit);\\r\\n             \\r\\n        }\\r\\n        if(checkValidArray(amountToWithdraw)) {\\r\\n            _withdraw(amountToWithdraw);\\r\\n            \\r\\n        }\\r\\n\\r\\n    }\\r\\n    \\r\\n    //For withdrawing loan from the royale Pool\\r\\n    function withdrawLoan(uint[3] memory amounts,address _recipient)external onlyWallet(){\\r\\n        require(checkValidArray(amounts),\\\"amount can not zero\\\");\\r\\n        uint decimal;\\r\\n        uint total;\\r\\n        for(uint i=0;i\\u003c3;i++){\\r\\n           decimal=tokens[i].decimals();\\r\\n           total=total.add(amounts[i].mul(1e18).div(10**decimal));\\r\\n        }\\r\\n        require(loanGiven.add(total)\\u003c=(calculateTotalToken(true).mul(loanPart).div(DENOMINATOR)),\\\"Exceed limit\\\");\\r\\n        require(total\\u003ccalculateTotalToken(false),\\\"Not enough balance\\\");\\r\\n        _withdraw(amounts);\\r\\n        loanGiven =loanGiven.add(total);\\r\\n        selfBalance=selfBalance.sub(total);\\r\\n        for(uint8 i=0; i\\u003c3; i++) {\\r\\n            if(amounts[i] \\u003e 0) {\\r\\n                tokens[i].safeTransfer(_recipient, amounts[i]);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n    }\\r\\n    \\r\\n   // For repaying the loan to the royale Pool.\\r\\n    function repayLoan(uint[3] memory amounts)external {\\r\\n        require(checkValidArray(amounts),\\\"amount can\\u0027t be zero\\\");\\r\\n        uint decimal;\\r\\n        for(uint8 i=0; i\\u003c3; i++) {\\r\\n            if(amounts[i] \\u003e 0) {\\r\\n                decimal=tokens[i].decimals();\\r\\n                loanGiven =loanGiven.sub(amounts[i].mul(1e18).div(10**decimal));\\r\\n                selfBalance=selfBalance.add(amounts[i].mul(1e18).div(10**decimal));\\r\\n                tokens[i].safeTransferFrom(msg.sender,address(this),amounts[i]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n\\r\\n    //for changing pool ratio\\r\\n    function changePoolPart(uint128 _newPoolPart) external onlyWallet()  {\\r\\n        poolPart = _newPoolPart;\\r\\n        \\r\\n    }\\r\\n\\r\\n   //For changing yield Strategy\\r\\n    function changeStrategy(address _strategy) onlyWallet() external  {\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            require(YieldPoolBalance==0, \\\"Call withdrawAll function first\\\");\\r\\n        } \\r\\n        strategy=rStrategy(_strategy);\\r\\n        \\r\\n    }\\r\\n\\r\\n    function setLockPeriod(uint256 lockperiod) onlyWallet() external  {\\r\\n        lock_period = lockperiod;\\r\\n        \\r\\n    }\\r\\n\\r\\n     // for changing withdrawal fees  \\r\\n    function setWithdrawFees(uint128 _fees) onlyWallet() external {\\r\\n        fees = _fees;\\r\\n\\r\\n    }\\r\\n    \\r\\n    function changeLoanPart(uint256 _value)onlyWallet() external{\\r\\n        loanPart=_value;\\r\\n    }\\r\\n\\r\\n   /* function transferAllFunds(address _address)external onlyWallet(){\\r\\n        selfBalance=0;\\r\\n        for(uint8 i=0;i\\u003c3;i++){\\r\\n            tokens[i].safeTransfer(_address,tokens[i].balanceOf(address(this)));\\r\\n        }\\r\\n    } */  \\r\\n    \\r\\n    function getBalances(uint _index) public view returns(uint256) {\\r\\n        return (tokens[_index].balanceOf(address(this)).sub(reserveAmount[_index]));\\r\\n    }\\r\\n}\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\nimport \\u0027./SafeMath.sol\\u0027;\\r\\nimport \\\"./IERC20Interface.sol\\\";\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        uint256 c = a + b;\\r\\n        if (c \\u003c a) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b \\u003e a) return (false, 0);\\r\\n        return (true, a - b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) return (true, 0);\\r\\n        uint256 c = a * b;\\r\\n        if (c / a != b) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a / b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a % b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) return 0;\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"StrategyInterface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n\\r\\ninterface rStrategy {\\r\\n\\r\\n    function deposit(uint256[3] calldata) external;\\r\\n    function withdraw(uint256[3] calldata) external;\\r\\n    function withdrawAll()  external returns(uint256[3] memory);\\r\\n    \\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"_tokens\",\"type\":\"address[3]\"},{\"internalType\":\"address\",\"name\":\"_rpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"userAddedToQ\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"userRecieved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"userSupplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"walletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"walletNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"yieldAdded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"YieldPoolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"amountBurnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"amountSupplied\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remAmt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"amountWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"coin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_time\",\"type\":\"bool\"}],\"name\":\"availableLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RPT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"calcRptAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_supply\",\"type\":\"bool\"}],\"name\":\"calculateTotalToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeLoanPart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_newPoolPart\",\"type\":\"uint128\"}],\"name\":\"changePoolPart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"changeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"depositYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isInQ\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityProvidersAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loanGiven\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loanPart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock_period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWithdrawRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"}],\"name\":\"repayLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"requestWithdrawWithRPT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserveAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reserveRecipients\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rpToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockperiod\",\"type\":\"uint256\"}],\"name\":\"setLockPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_fees\",\"type\":\"uint128\"}],\"name\":\"setWithdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"contract rStrategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawRecipients\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RoyaleLP","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000ee7c29f912760611365108ace4ae86bc76b8488e000000000000000000000000ccbbf208cd893959f78f7e68e8896e11e9cd3beb","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5b7c4a920d8b60411c9da6ba4b42ccb460cc017afff65c9f85f3283c96f19b4c"}]}