{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.1;\r\n\r\n\r\ncontract SignatureVerifier {\r\n\r\n    function verifySignature(bytes32 hash, bytes memory signature, address signer) public pure returns (bool) {\r\n        address addressFromSig = recoverSigner(hash, signature);\r\n        return addressFromSig == signer;\r\n    }\r\n\r\n    /**\r\n    * @dev Recover signer address from a message by using their signature\r\n    * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n    * @param sig bytes signature, the signature is generated using web3.eth.sign(). Inclusive \"0x...\"\r\n    */\r\n    function recoverSigner(bytes32 hash, bytes memory sig) public pure returns (address) {\r\n        require(sig.length == 65, \"Require correct length\");\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Divide the signature in r, s and v variables\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        require(v == 27 || v == 28, \"Signature version not match\");\r\n\r\n        return recoverSigner2(hash, v, r, s);\r\n    }\r\n\r\n    function recoverSigner2(bytes32 h, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, h));\r\n        address addr = ecrecover(prefixedHash, v, r, s);\r\n\r\n        return addr;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"h\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"recoverSigner2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"verifySignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"SignatureVerifier","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cb048b1020968d650298ffbca27717576d452198ac5284c3728f5e6a85310cb2"}]}