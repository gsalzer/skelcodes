{"status":"1","message":"OK","result":[{"SourceCode":"{\"SwapFactory.sol\":{\"content\":\"// SPDX-License-Identifier: No License (None)\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\n\\r\\ninterface IERC20 {\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IValidator {\\r\\n    // returns rate (with 18 decimals) = Token B price / Token A price\\r\\n    function getRate(address tokenA, address tokenB) external returns (uint256);\\r\\n    // returns: user balance, native (foreign for us) encoded balance, foreign (native for us) encoded balance\\r\\n    function checkBalances(address factory, address[] calldata user) external returns(uint256);\\r\\n    // returns: user balance\\r\\n    function checkBalance(address factory, address user) external returns(uint256);\\r\\n    // returns: oracle fee\\r\\n    function getOracleFee(uint256 req) external returns(uint256);  //req: 1 - cancel, 2 - claim, returns: value\\r\\n}\\r\\n\\r\\ninterface ISmart {\\r\\n    function requestCompensation(address user, uint256 feeAmount) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface IAuction {\\r\\n    function contributeFromSmartSwap(address payable user) external payable returns (bool);\\r\\n    function contributeFromSmartSwap(address token, uint256 amount, address user) external returns (bool);\\r\\n}\\r\\n\\r\\nabstract contract Ownable {\\r\\n    address internal _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n/*  we use proxy, so owner will be set in initialize() function\\r\\n    constructor () {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n*/\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract SmartSwap is Ownable {\\r\\n\\r\\n    struct Cancel {\\r\\n        uint64 pairID; // pair ID\\r\\n        address sender; // user who has to receive canceled amount\\r\\n        uint256 amount; // amount of token user want to cancel from order\\r\\n        //uint128 foreignBalance; // amount of token already swapped (on other chain)\\r\\n    }\\r\\n\\r\\n    struct Claim {\\r\\n        uint64 pairID;     // pair ID\\r\\n        address sender;     // address who send tokens to swap\\r\\n        address receiver;   // address who has to receive swapped amount\\r\\n        uint64 claimID;     // uniq claim ID\\r\\n        bool isInvestment;  // is claim to contributeFromSmartSwap\\r\\n        uint128 amount;     // amount of foreign tokens user want to swap\\r\\n        uint128 currentRate;\\r\\n        uint256 foreignBalance;  //[0] foreignBalance, [1] foreignSpent, [2] nativeSpent, [3] nativeRate\\r\\n    }\\r\\n\\r\\n    struct Pair {\\r\\n        address tokenA;\\r\\n        address tokenB;        \\r\\n    }\\r\\n\\r\\n    address constant NATIVE_COINS = 0x0000000000000000000000000000000000000009; // 1 - BNB, 2 - ETH, 3 - BTC\\r\\n    uint256 constant NOMINATOR = 10**18;\\r\\n    uint256 constant MAX_AMOUNT = 2**128;\\r\\n\\r\\n    address public foreignFactory;\\r\\n    address payable public validator;\\r\\n    uint256 public rateDiffLimit;   // allowed difference (in percent) between LP provided rate and Oracle rate.\\r\\n    mapping(address =\\u003e bool) public isSystem;  // system address mey change fee amount\\r\\n    address public auction; // auction address\\r\\n    address public contractSmart;  // the contract address to request Smart token in exchange of fee\\r\\n    mapping (address =\\u003e uint256) licenseeFee;  // the licensee may set personal fee (in percent wih 2 decimals). It have to compensate this fee with own tokens.\\r\\n    mapping (address =\\u003e address) licenseeCompensator;    // licensee contract which will compensate fee with tokens\\r\\n \\r\\n    mapping(address =\\u003e bool) public isExchange;         // is Exchange address\\r\\n    mapping(address =\\u003e bool) public isExcludedSender;   // address excluded from receiving SMART token as fee compensation\\r\\n\\r\\n    // fees\\r\\n    uint256 public swapGasReimbursement;      // percentage of swap Gas Reimbursement by SMART tokens\\r\\n    uint256 public companyFeeReimbursement;   // percentage of company Fee Reimbursement by SMART tokens\\r\\n    uint256 public cancelGasReimbursement;    // percentage of cancel Gas Reimbursement by SMART tokens\\r\\n    uint256 public companyFee; // the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\\r\\n    uint256 public processingFee; // the fee in base coin, to compensate Gas when back-end call claimTokenBehalf()\\r\\n    address public feeReceiver; // address which receive the fee (by default is validator)\\r\\n    uint256 private collectedFees; // amount of collected fee (starts from 1 to avoid additional gas usage)\\r\\n\\r\\n    mapping(address =\\u003e uint256) public decimals;   // token address =\\u003e token decimals\\r\\n    uint256 public pairIDCounter;\\r\\n    mapping(uint256 =\\u003e Pair) public getPairByID;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public getPairID;    // tokenA =\\u003e tokenB =\\u003e pair ID or 0 if not exist\\r\\n    mapping(uint256 =\\u003e uint256) public totalSupply;    // pairID =\\u003e totalSupply amount of tokenA on the pair\\r\\n\\r\\n    // hashAddress = address(keccak256(tokenA, tokenB, sender, receiver))\\r\\n    mapping(address =\\u003e uint256) private _balanceOf;       // hashAddress =\\u003e amount of tokenA\\r\\n    mapping(address =\\u003e Cancel) public cancelRequest;    // hashAddress =\\u003e amount of tokenA to cancel\\r\\n    mapping(address =\\u003e Claim) public claimRequest;      // hashAddress =\\u003e amount of tokenA to swap\\r\\n\\r\\n    mapping(address =\\u003e bool) public isLiquidityProvider;    // list of Liquidity Providers\\r\\n    uint256 claimIdCounter;    // counter of claim requests\\r\\n\\r\\n// ============================ Events ============================\\r\\n\\r\\n    event PairAdded(address indexed tokenA, address indexed tokenB, uint256 indexed pairID);\\r\\n    event PairRemoved(address indexed tokenA, address indexed tokenB, uint256 indexed pairID);\\r\\n    event SwapRequest(\\r\\n        address indexed tokenA,\\r\\n        address indexed tokenB,\\r\\n        address indexed sender,\\r\\n        address receiver,\\r\\n        uint256 amountA,\\r\\n        bool isInvestment,\\r\\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\\r\\n        uint128 limitPice   // Do not match user if token A price less this limit\\r\\n    );\\r\\n    event CancelRequest(address indexed hashAddress, uint256 amount);\\r\\n    event CancelApprove(address indexed hashAddress, uint256 newBalance);\\r\\n    event ClaimRequest(address indexed hashAddress, uint64 claimID, uint256 amount, bool isInvestment);\\r\\n    event ClaimApprove(address indexed hashAddress, uint64 claimID, uint256 nativeAmount, uint256 foreignAmount, bool isInvestment);\\r\\n    event ExchangeInvestETH(address indexed exchange, address indexed whom, uint256 value);\\r\\n    event SetSystem(address indexed system, bool active);\\r\\n    event SetLicensee(address indexed system, address indexed compensator);\\r\\n\\r\\n    /**\\r\\n    * @dev Throws if called by any account other than the system.\\r\\n    */\\r\\n    modifier onlySystem() {\\r\\n        require(isSystem[msg.sender] || owner() == msg.sender, \\\"Caller is not the system\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    // run only once from proxy\\r\\n    function initialize(address newOwner) external {\\r\\n        require(newOwner != address(0) \\u0026\\u0026 _owner == address(0)); // run only once\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n        rateDiffLimit = 5;   // allowed difference (in percent) between LP provided rate and Oracle rate.\\r\\n        swapGasReimbursement = 100;      // percentage of swap Gas Reimbursement by SMART tokens\\r\\n        companyFeeReimbursement = 100;   // percentage of company Fee Reimbursement by SMART tokens\\r\\n        cancelGasReimbursement = 100;    // percentage of cancel Gas Reimbursement by SMART tokens\\r\\n        companyFee = 0; // the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\\r\\n        collectedFees = 1; // amount of collected fee (starts from 1 to avoid additional gas usage)\\r\\n    }\\r\\n\\r\\n    // get amount of collected fees that can be claimed\\r\\n    function getColletedFees() external view returns (uint256) {\\r\\n        // collectedFees starts from 1 to avoid additional gas usage to initiate storage (when collectedFees = 0)\\r\\n        return collectedFees - 1;\\r\\n    }\\r\\n\\r\\n    // claim fees by feeReceiver\\r\\n    function claimFee() external returns (uint256 feeAmount)\\r\\n    {\\r\\n        require(msg.sender == feeReceiver);\\r\\n        feeAmount = collectedFees - 1;\\r\\n        collectedFees = 1;        \\r\\n        TransferHelper.safeTransferETH(msg.sender, feeAmount);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address hashAddress) external view returns(uint256) {\\r\\n        return _balanceOf[hashAddress];\\r\\n    }\\r\\n\\r\\n    // return balance for swap\\r\\n    function getBalance(\\r\\n        address tokenA,\\r\\n        address tokenB, \\r\\n        address sender,\\r\\n        address receiver\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _balanceOf[_getHashAddress(tokenA, tokenB, sender, receiver)];\\r\\n    }\\r\\n\\r\\n    function getHashAddress(\\r\\n        address tokenA,\\r\\n        address tokenB, \\r\\n        address sender,\\r\\n        address receiver\\r\\n    )\\r\\n        external\\r\\n        pure\\r\\n        returns (address)\\r\\n    {\\r\\n        return _getHashAddress(tokenA, tokenB, sender, receiver);\\r\\n    }\\r\\n\\r\\n    //user should approve tokens transfer before calling this function.\\r\\n    //if no licensee set it to address(0)\\r\\n    function swap(\\r\\n        address tokenA,\\r\\n        address tokenB, \\r\\n        address receiver,\\r\\n        uint256 amountA,\\r\\n        address licensee,\\r\\n        bool isInvestment,\\r\\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\\r\\n        uint128 limitPice   // Do not match user if token A price less this limit\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transferFee(tokenA, amountA, msg.sender, licensee);\\r\\n        _swap(tokenA, tokenB, msg.sender, receiver, amountA, isInvestment, minimumAmountToClaim, limitPice);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function cancel(\\r\\n        address tokenA,\\r\\n        address tokenB, \\r\\n        address receiver,\\r\\n        uint256 amountA    //amount of tokenA to cancel\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (bool)\\r\\n    {\\r\\n        _cancel(tokenA, tokenB, msg.sender, receiver, amountA);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function claimTokenBehalf(\\r\\n        address tokenA, // foreignToken\\r\\n        address tokenB, // nativeToken\\r\\n        address sender,\\r\\n        address receiver,\\r\\n        bool isInvestment,\\r\\n        uint128 amountA,    //amount of tokenA that has to be swapped\\r\\n        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\\r\\n        uint256 foreignBalance  // total tokens amount sent by user to pair on other chain\\r\\n    )        \\r\\n        external\\r\\n        onlySystem\\r\\n        returns (bool) \\r\\n    {\\r\\n        _claimTokenBehalf(tokenA, tokenB, sender, receiver, isInvestment, amountA, currentRate, foreignBalance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // add liquidity to counterparty \\r\\n    function addLiquidityAndClaimBehalf(\\r\\n        address tokenA, // Native token\\r\\n        address tokenB, // Foreign token\\r\\n        address receiver,\\r\\n        bool isInvestment,\\r\\n        uint128 amountA,    //amount of tokenA that has to be swapped\\r\\n        uint128 currentRate,     // rate with 18 decimals: tokenB price / tokenA price\\r\\n        uint256 foreignBalance,  // total tokens amount sent by user to pair on other chain\\r\\n        address senderCounterparty,\\r\\n        address receiverCounterparty\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        onlySystem\\r\\n        returns (bool)\\r\\n    {\\r\\n\\r\\n        _transferFee(tokenA, amountA, msg.sender, address(0));\\r\\n        _swap(tokenA, tokenB, msg.sender, receiver, amountA, false,0,0);\\r\\n        uint256 amountB = amountA * 10**(18+decimals[tokenB]-decimals[tokenA]) / currentRate;\\r\\n        _claimTokenBehalf(tokenB, tokenA, senderCounterparty, receiverCounterparty, isInvestment, uint128(amountB), currentRate, foreignBalance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function balanceCallback(address hashAddress, uint256 foreignBalance) external returns(bool) {\\r\\n        require (validator == msg.sender, \\\"Not validator\\\");\\r\\n        _cancelApprove(hashAddress, foreignBalance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function balancesCallback(\\r\\n        address hashAddress, \\r\\n        uint256 foreignBalance, // total user\\u0027s tokens balance on foreign chain\\r\\n        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\\r\\n        uint256 nativeEncoded   // (nativeRate, nativeSpent) = _decode(nativeEncoded)\\r\\n    ) \\r\\n        external \\r\\n        returns(bool) \\r\\n    {\\r\\n        require (validator == msg.sender, \\\"Not validator\\\");\\r\\n        _claimBehalfApprove(hashAddress, foreignBalance, foreignSpent, nativeEncoded);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // get system variables for debugging \\r\\n    function getPairVars(uint256 pairID) external view returns (uint256 native, uint256 foreign, uint256 foreignRate) {\\r\\n        address nativeHash = _getHashAddress(getPairByID[pairID].tokenA, getPairByID[pairID].tokenB, address(0), address(0));\\r\\n        address foreignHash = _getHashAddress(getPairByID[pairID].tokenB, getPairByID[pairID].tokenA, address(0), address(0));\\r\\n        // native - amount of native tokens that swapped from available foreign\\r\\n        native = _balanceOf[nativeHash];\\r\\n        // foreign = total foreign tokens already swapped\\r\\n        // foreignRate = rate (native price / foreign price) of available foreign tokens on other chain\\r\\n        (foreignRate, foreign) = _decode(_balanceOf[foreignHash]);\\r\\n        // Example: assume system vars = 0, rate of prices ETH/BNB = 2 (or BNB/ETH = 0.5)\\r\\n        // on ETH chain: \\r\\n        // 1. claim ETH for 60 BNB == 60 * 0.5 = 30 ETH, \\r\\n        // set: foreign = 60 BNB, foreignRate = 0.5 BNB/ETH prices (already swapped BNB)\\r\\n        //\\r\\n        // on BSC chain:\\r\\n        // 2. claim BNB for 20 ETH, assume new rate of prices ETH/BNB = 4 (or BNB/ETH = 0.25)\\r\\n        // get from ETH chain foreign(ETH) = 60 BNB, foreignRate(ETH) = 0.5 BNB/ETH prices\\r\\n        // available amount of already swapped BNB = 60 BNB (foreign from ETH) - 0 BNB (native) = 60 BNB with rate 0.5 BNB/ETH\\r\\n        // claimed BNB amount = 20 ETH / 0.5 BNB/ETH = 40 BNB (we use rate of already swapped BNB)\\r\\n        // set: native = 40 BNB (we use BNB that was already swapped on step 1)\\r\\n        //\\r\\n        // 3. New claim BNB for 30 ETH, assume new rate of prices ETH/BNB = 4 (or BNB/ETH = 0.25)\\r\\n        // get from ETH chain foreign(ETH) = 60 BNB, foreignRate(ETH) = 0.5 BNB/ETH prices\\r\\n        // available amount of already swapped BNB = 60 BNB (foreign from ETH) - 40 BNB (native) = 20 BNB with rate 0.5 BNB/ETH\\r\\n        // 20 BNB * 0.5 = 10 ETH (we claimed 20 BNB for 10 ETH with already swapped rate)\\r\\n        // set: native = 40 BNB + 20 BNB = 60 BNB (we use all BNB that was already swapped on step 1)\\r\\n        // claimed rest BNB amount for (30-10) ETH = 20 ETH / 0.25 BNB/ETH = 80 BNB (we use new rate)\\r\\n        // set: foreign = 20 ETH, foreignRate = 0.25 BNB/ETH prices (already swapped ETH)\\r\\n    }\\r\\n// ================== For Jointer Auction =========================================================================\\r\\n\\r\\n    // ETH side\\r\\n    // function for invest ETH from from exchange on user behalf\\r\\n    function contributeWithEtherBehalf(address payable _whom) external payable returns (bool) {\\r\\n        require(isExchange[msg.sender], \\\"Not an Exchange address\\\");\\r\\n        address tokenA = address(2);    // ETH (native coin)\\r\\n        address tokenB = address(1);    // BNB (foreign coin)\\r\\n        uint256 amount = msg.value - processingFee;\\r\\n        emit ExchangeInvestETH(msg.sender, _whom, msg.value);\\r\\n        _transferFee(tokenA, amount, _whom, address(0));    // no licensee\\r\\n        _swap(tokenA, tokenB, _whom, auction, amount, true,0,0);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // BSC side\\r\\n    // tokenB - foreign token address or address(1) for ETH\\r\\n    // amountB - amount of foreign tokens or ETH\\r\\n    function claimInvestmentBehalf(\\r\\n        address tokenB, // foreignToken\\r\\n        address user, \\r\\n        uint128 amountB,    //amount of tokenB that has to be swapped\\r\\n        uint128 currentRate,     // rate with 18 decimals: tokenB price / Native coin price\\r\\n        uint256 foreignBalance  // total tokens amount sent by user to pair on other chain\\r\\n    ) \\r\\n        external \\r\\n        onlySystem \\r\\n        returns (bool) \\r\\n    {\\r\\n        address tokenA = address(1);    // BNB (native coin)\\r\\n        _claimTokenBehalf(tokenB, tokenA, user, auction, true, amountB, currentRate, foreignBalance);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n// ================= END For Jointer Auction ===========================================================================\\r\\n\\r\\n// ============================ Restricted functions ============================\\r\\n\\r\\n    // set processing fee - amount that have to be paid on other chain to claimTokenBehalf.\\r\\n    // Set in amount of native coins (BNB or ETH)\\r\\n    function setProcessingFee(uint256 _fee) external onlySystem returns(bool) {\\r\\n        processingFee = _fee;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // set licensee compensator contract address, if this address is address(0) - remove licensee.\\r\\n    // compensator contract has to compensate the fee by other tokens.\\r\\n    // licensee fee in percent with 2 decimals. I.e. 10 = 0.1%\\r\\n    function setLicensee(address _licensee, address _compensator, uint256 _fee) external onlySystem returns(bool) {\\r\\n        licenseeCompensator[_licensee] = _compensator;\\r\\n        require(_fee \\u003c 10000, \\\"too big fee\\\");    // fee should be less then 100%\\r\\n        licenseeFee[_licensee] = _fee;\\r\\n        emit SetLicensee(_licensee, _compensator);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // set licensee fee in percent with 2 decimals. I.e. 10 = 0.1%\\r\\n    function setLicenseeFee(uint256 _fee) external returns(bool) {\\r\\n        require(licenseeCompensator[msg.sender] != address(0), \\\"licensee is not registered\\\");\\r\\n        require(_fee \\u003c 10000, \\\"too big fee\\\");    // fee should be less then 100%\\r\\n        licenseeFee[msg.sender] = _fee;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n// ============================ Owner\\u0027s functions ============================\\r\\n\\r\\n    //the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\\r\\n    function setCompanyFee(uint256 _fee) external onlyOwner returns(bool) {\\r\\n        require(_fee \\u003c 10000, \\\"too big fee\\\");    // fee should be less then 100%\\r\\n        companyFee = _fee;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Reimbursement Percentage without decimals: 100 = 100%\\r\\n    function setReimbursementPercentage (uint256 id, uint256 _fee) external onlyOwner returns(bool) {\\r\\n        if (id == 1) swapGasReimbursement = _fee;      // percentage of swap Gas Reimbursement by SMART tokens\\r\\n        else if (id == 2) cancelGasReimbursement = _fee;    // percentage of cancel Gas Reimbursement by SMART tokens\\r\\n        else if (id == 3) companyFeeReimbursement = _fee;   // percentage of company Fee Reimbursement by SMART tokens\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setSystem(address _system, bool _active) external onlyOwner returns(bool) {\\r\\n        isSystem[_system] = _active;\\r\\n        emit SetSystem(_system, _active);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setValidator(address payable _validator) external onlyOwner returns(bool) {\\r\\n        validator = _validator;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setForeignFactory(address _addr) external onlyOwner returns(bool) {\\r\\n        foreignFactory = _addr;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setFeeReceiver(address _addr) external onlyOwner returns(bool) {\\r\\n        feeReceiver = _addr;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setMSSContract(address _addr) external onlyOwner returns(bool) {\\r\\n        contractSmart = _addr;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setAuction(address _addr) external onlyOwner returns(bool) {\\r\\n        auction = _addr;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // for ETH side only\\r\\n    function changeExchangeAddress(address _which,bool _bool) external onlyOwner returns(bool){\\r\\n        isExchange[_which] = _bool;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function changeExcludedAddress(address _which,bool _bool) external onlyOwner returns(bool){\\r\\n        isExcludedSender[_which] = _bool;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function createPair(address tokenA, uint256 decimalsA, address tokenB, uint256 decimalsB) public onlyOwner returns (uint256) {\\r\\n        require(getPairID[tokenA][tokenB] == 0, \\\"Pair exist\\\");\\r\\n        uint256 pairID = ++pairIDCounter;\\r\\n        getPairID[tokenA][tokenB] = pairID;\\r\\n        getPairByID[pairID] = Pair(tokenA, tokenB);\\r\\n        if (decimals[tokenA] == 0) decimals[tokenA] = decimalsA;\\r\\n        if (decimals[tokenB] == 0) decimals[tokenB] = decimalsB;\\r\\n        return pairID;\\r\\n    }\\r\\n\\r\\n// ============================ Internal functions ============================\\r\\n    function _swap(\\r\\n        address tokenA, // nativeToken\\r\\n        address tokenB, // foreignToken\\r\\n        address sender,\\r\\n        address receiver,\\r\\n        uint256 amountA,\\r\\n        bool isInvestment,\\r\\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\\r\\n        uint128 limitPice   // Do not match user if token A price less this limit\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        uint256 pairID = getPairID[tokenA][tokenB];\\r\\n        require(pairID != 0, \\\"Pair not exist\\\");\\r\\n        if (tokenA \\u003e NATIVE_COINS) {\\r\\n            TransferHelper.safeTransferFrom(tokenA, sender, address(this), amountA);\\r\\n        }\\r\\n        // (amount \\u003e= msg.value) is checking when pay fee in the function transferFee()\\r\\n        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\\r\\n        _balanceOf[hashAddress] += amountA;\\r\\n        totalSupply[pairID] += amountA;\\r\\n        emit SwapRequest(tokenA, tokenB, sender, receiver, amountA, isInvestment, minimumAmountToClaim, limitPice);\\r\\n    }\\r\\n\\r\\n    function _cancel(\\r\\n        address tokenA, // nativeToken\\r\\n        address tokenB, // foreignToken\\r\\n        address sender,\\r\\n        address receiver,\\r\\n        uint256 amountA    //amount of tokenA to cancel\\r\\n        //uint128 foreignBalance // amount of tokenA swapped by hashAddress (get by server-side)\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        require(msg.value \\u003e= IValidator(validator).getOracleFee(1), \\\"Insufficient fee\\\");    // check oracle fee for Cancel request\\r\\n        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\\r\\n        uint256 pairID = getPairID[tokenA][tokenB];\\r\\n        require(pairID != 0, \\\"Pair not exist\\\");\\r\\n        if (cancelRequest[hashAddress].amount == 0) {  // new cancel request\\r\\n            uint256 balance = _balanceOf[hashAddress];\\r\\n            require(balance \\u003e= amountA \\u0026\\u0026 amountA != 0, \\\"Wrong amount\\\");\\r\\n            totalSupply[pairID] = totalSupply[pairID] - amountA;\\r\\n            _balanceOf[hashAddress] = balance - amountA;\\r\\n        } else { // repeat cancel request in case oracle issues.\\r\\n            amountA = cancelRequest[hashAddress].amount;\\r\\n        }\\r\\n        cancelRequest[hashAddress] = Cancel(uint64(pairID), sender, amountA);\\r\\n        // transfer fee to validator. May be changed to request tokens for compensation\\r\\n        TransferHelper.safeTransferETH(feeReceiver, msg.value);\\r\\n        if(contractSmart != address(0) \\u0026\\u0026 !isExcludedSender[sender]) {\\r\\n            uint256 feeAmount = msg.value * cancelGasReimbursement / 100;\\r\\n            if (feeAmount != 0)\\r\\n                ISmart(contractSmart).requestCompensation(sender, feeAmount);\\r\\n        }\\r\\n        // request Oracle for fulfilled amount from hashAddress\\r\\n        IValidator(validator).checkBalance(foreignFactory, hashAddress);\\r\\n        emit CancelRequest(hashAddress, amountA);\\r\\n        //emit CancelRequest(tokenA, tokenB, sender, receiver, amountA);\\r\\n    }\\r\\n\\r\\n    function _cancelApprove(address hashAddress, uint256 foreignBalance) internal {\\r\\n        Cancel memory c = cancelRequest[hashAddress];\\r\\n        delete cancelRequest[hashAddress];\\r\\n        //require(c.foreignBalance == foreignBalance, \\\"Oracle error\\\");\\r\\n        uint256 balance = _balanceOf[hashAddress];\\r\\n        uint256 amount = uint256(c.amount);\\r\\n        uint256 pairID = uint256(c.pairID);\\r\\n        if (foreignBalance \\u003c= balance) {\\r\\n            //approved - transfer token to its sender\\r\\n            _transfer(getPairByID[pairID].tokenA, c.sender, amount);\\r\\n        } else {\\r\\n            //disapproved\\r\\n            balance += amount;\\r\\n            _balanceOf[hashAddress] = balance;\\r\\n            totalSupply[pairID] += amount;\\r\\n        }\\r\\n        emit CancelApprove(hashAddress, balance);\\r\\n    }\\r\\n\\r\\n    function _claimTokenBehalf(\\r\\n        address tokenA, // foreignToken\\r\\n        address tokenB, // nativeToken\\r\\n        address sender,\\r\\n        address receiver,\\r\\n        bool isInvestment,\\r\\n        uint128 amountA,    //amount of tokenA that has to be swapped\\r\\n        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\\r\\n        uint256 foreignBalance  // total tokens amount sent bu user to pair on other chain\\r\\n        // [1] foreignSpent, [2] nativeSpent, [3] nativeRate\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        uint256 pairID = getPairID[tokenB][tokenA]; // getPairID[nativeToken][foreignToken]\\r\\n        require(pairID != 0, \\\"Pair not exist\\\");\\r\\n        // check rate\\r\\n        uint256 diffRate = uint256(currentRate) * 100 / IValidator(validator).getRate(tokenB, tokenA);\\r\\n        uint256 diffLimit = rateDiffLimit;\\r\\n        require(diffRate \\u003e= 100 - diffLimit \\u0026\\u0026 diffRate \\u003c= 100 + diffLimit, \\\"Wrong rate\\\");\\r\\n\\r\\n        uint64 claimID;\\r\\n        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\\r\\n        if (claimRequest[hashAddress].amount == 0) {  // new claim request\\r\\n            _balanceOf[hashAddress] += uint256(amountA); // total swapped amount of foreign token\\r\\n            claimID = uint64(++claimIdCounter);\\r\\n        } else { // repeat claim request in case oracle issues.\\r\\n            claimID = claimRequest[hashAddress].claimID;\\r\\n            if (amountA == 0) {    // cancel claim request\\r\\n                emit ClaimApprove(hashAddress, claimID, 0, 0, claimRequest[hashAddress].isInvestment);\\r\\n                _balanceOf[hashAddress] = _balanceOf[hashAddress] - claimRequest[hashAddress].amount;\\r\\n                delete claimRequest[hashAddress];\\r\\n                return;\\r\\n            }\\r\\n            amountA = claimRequest[hashAddress].amount;\\r\\n        }\\r\\n        address[] memory users = new address[](3);\\r\\n        users[0] = hashAddress;\\r\\n        users[1] = _getHashAddress(tokenA, tokenB, address(0), address(0)); // Native hash address on foreign chain\\r\\n        users[2] = _getHashAddress(tokenB, tokenA, address(0), address(0)); // Foreign hash address on foreign chain\\r\\n        claimRequest[hashAddress] = Claim(uint64(pairID), sender, receiver, claimID, isInvestment, amountA, currentRate, foreignBalance);\\r\\n        IValidator(validator).checkBalances(foreignFactory, users);\\r\\n        emit ClaimRequest(hashAddress, claimID, amountA, isInvestment);\\r\\n        //emit ClaimRequest(tokenA, tokenB, sender, receiver, amountA);\\r\\n    }\\r\\n\\r\\n    // Approve or disapprove claim request.\\r\\n    function _claimBehalfApprove(\\r\\n        address hashAddress, \\r\\n        uint256 foreignBalance, // total user\\u0027s tokens balance on foreign chain\\r\\n        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\\r\\n        uint256 nativeEncoded   // (nativeSpent, nativeRate) = _decode(nativeEncoded)\\r\\n    ) \\r\\n        internal \\r\\n    {\\r\\n        Claim memory c = claimRequest[hashAddress];\\r\\n        delete claimRequest[hashAddress];\\r\\n        //address hashSwap = _getHashAddress(getPairByID[c.pairID].tokenB, getPairByID[c.pairID].tokenA, c.sender, c.receiver);\\r\\n        uint256 balance = _balanceOf[hashAddress];   // swapped amount of foreign tokens (include current claim amount)\\r\\n        uint256 amount = uint256(c.amount);     // amount of foreign token to swap\\r\\n        require (amount != 0, \\\"No active claim request\\\");\\r\\n        require(foreignBalance == c.foreignBalance, \\\"Oracle error\\\");\\r\\n\\r\\n        uint256 nativeAmount;\\r\\n        uint256 rest;\\r\\n        if (foreignBalance \\u003e= balance) {\\r\\n            //approve, user deposited not less foreign tokens then want to swap\\r\\n            uint256 pairID = uint256(c.pairID);\\r\\n            (uint256 nativeRate, uint256 nativeSpent) = _decode(nativeEncoded);\\r\\n            (nativeAmount, rest) = _calculateAmount(\\r\\n                pairID,\\r\\n                amount, \\r\\n                uint256(c.currentRate),\\r\\n                foreignSpent,\\r\\n                nativeSpent,\\r\\n                nativeRate\\r\\n            );\\r\\n            if (rest != 0) {\\r\\n                _balanceOf[hashAddress] = balance - rest;    // not all amount swapped\\r\\n                amount = amount - rest;     // swapped amount\\r\\n            }\\r\\n            require(totalSupply[pairID] \\u003e= nativeAmount, \\\"Not enough Total Supply\\\");   // may be commented\\r\\n            totalSupply[pairID] = totalSupply[pairID] - nativeAmount;\\r\\n            if (c.isInvestment)\\r\\n                _contributeFromSmartSwap(getPairByID[pairID].tokenA, c.receiver, c.sender, nativeAmount);\\r\\n            else\\r\\n                _transfer(getPairByID[pairID].tokenA, c.receiver, nativeAmount);\\r\\n        } else {\\r\\n            //disapprove, discard claim\\r\\n            _balanceOf[hashAddress] = balance - amount;\\r\\n            amount = 0;\\r\\n        }\\r\\n        emit ClaimApprove(hashAddress, c.claimID, nativeAmount, amount, c.isInvestment);\\r\\n    }\\r\\n\\r\\n    // use structure to avoid stack too deep\\r\\n    struct CalcVariables {\\r\\n        // 18 decimals nominator with decimals converter: \\r\\n        // Foreign = Native * Rate(18) / nominatorNativeToForeign\\r\\n        uint256 nominatorForeignToNative; // 10**(18 + foreign decimals - native decimals)\\r\\n        uint256 nominatorNativeToForeign; // 10**(18 + native decimals - foreign decimals)\\r\\n        uint256 localNative;        // already swapped Native tokens = _balanceOf[hashNative]\\r\\n        uint256 localForeign;       // already swapped Foreign tokens = decoded _balanceOf[hashForeign]\\r\\n        uint256 localForeignRate;   // Foreign token price / Native token price = decoded _balanceOf[hashForeign]\\r\\n        address hashNative;         // _getHashAddress(tokenA, tokenB, address(0), address(0));\\r\\n        address hashForeign;        // _getHashAddress(tokenB, tokenA, address(0), address(0));\\r\\n    }\\r\\n\\r\\n    function _calculateAmount(\\r\\n        uint256 pairID,\\r\\n        uint256 foreignAmount,\\r\\n        uint256 rate,    // Foreign token price / Native token price = (Native amount / Foreign amount)\\r\\n        uint256 foreignSpent,   // already swapped Foreign tokens (got from foreign contract)\\r\\n        uint256 nativeSpent,    // already swapped Native tokens (got from foreign contract)\\r\\n        uint256 nativeRate  // Native token price / Foreign token price. I.e. on BSC side: BNB price / ETH price = 0.2\\r\\n    )\\r\\n        internal\\r\\n        returns(uint256 nativeAmount, uint256 rest)\\r\\n    {\\r\\n        CalcVariables memory vars;\\r\\n        {\\r\\n            address tokenA = getPairByID[pairID].tokenA;\\r\\n            address tokenB = getPairByID[pairID].tokenB;\\r\\n            uint256 nativeDecimals = decimals[tokenA];\\r\\n            uint256 foreignDecimals = decimals[tokenB];\\r\\n            vars.nominatorForeignToNative = 10**(18+foreignDecimals-nativeDecimals);\\r\\n            vars.nominatorNativeToForeign = 10**(18+nativeDecimals-foreignDecimals);\\r\\n            vars.hashNative = _getHashAddress(tokenA, tokenB, address(0), address(0));\\r\\n            vars.hashForeign = _getHashAddress(tokenB, tokenA, address(0), address(0));\\r\\n            vars.localNative = _balanceOf[vars.hashNative];\\r\\n            (vars.localForeignRate, vars.localForeign) = _decode(_balanceOf[vars.hashForeign]);\\r\\n        }\\r\\n\\r\\n        // step 1. Check is it enough unspent native tokens\\r\\n        {\\r\\n            require(nativeSpent \\u003e= vars.localNative, \\\"NativeSpent balance higher then remote\\\");\\r\\n            uint256 nativeAvailable = nativeSpent - vars.localNative;\\r\\n            // nativeAvailable - amount ready to spend native tokens\\r\\n            // nativeRate = Native token price / Foreign token price. I.e. on BSC side BNB price / ETH price = 0.2\\r\\n            if (nativeAvailable != 0) {\\r\\n                // ?\\r\\n                uint256 requireAmount = foreignAmount * vars.nominatorNativeToForeign / nativeRate;\\r\\n                if (requireAmount \\u003c= nativeAvailable) {\\r\\n                    nativeAmount = requireAmount;   // use already swapped tokens\\r\\n                    foreignAmount = 0;\\r\\n                }\\r\\n                else {\\r\\n                    nativeAmount = nativeAvailable;\\r\\n                    foreignAmount = (requireAmount - nativeAvailable) * nativeRate / vars.nominatorNativeToForeign;\\r\\n                }\\r\\n                _balanceOf[vars.hashNative] += nativeAmount;\\r\\n            }\\r\\n        }\\r\\n        require(totalSupply[pairID] \\u003e= nativeAmount,\\\"ERR: Not enough Total Supply\\\");\\r\\n        // step 2. recalculate rate for swapped tokens\\r\\n        if (foreignAmount != 0) {\\r\\n            // i.e. on BSC side: rate = ETH price / BNB price = 5\\r\\n            uint256 requireAmount = foreignAmount * rate / vars.nominatorForeignToNative;\\r\\n            if (totalSupply[pairID] \\u003c nativeAmount + requireAmount) {\\r\\n                requireAmount = totalSupply[pairID] - nativeAmount;\\r\\n                rest = foreignAmount - (requireAmount * vars.nominatorForeignToNative / rate);\\r\\n                foreignAmount = foreignAmount - rest;\\r\\n            }\\r\\n            nativeAmount = nativeAmount + requireAmount;\\r\\n            require(vars.localForeign \\u003e= foreignSpent, \\\"ForeignSpent balance higher then local\\\");\\r\\n            uint256 foreignAvailable = vars.localForeign - foreignSpent;\\r\\n            // vars.localForeignRate, foreignAvailable - rate and amount swapped foreign tokens\\r\\n            if (foreignAvailable != 0) { // recalculate avarage rate (native amount / foreign amount)\\r\\n                rate = ((foreignAvailable * vars.localForeignRate) + (requireAmount * vars.nominatorForeignToNative)) / (foreignAvailable + foreignAmount);\\r\\n            }\\r\\n            _balanceOf[vars.hashForeign] = _encode(rate, vars.localForeign + foreignAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // transfer fee to receiver and request SMART token as compensation.\\r\\n    // tokenA - token that user send\\r\\n    // amount - amount of tokens that user send\\r\\n    // user - address of user\\r\\n    function _transferFee(address tokenA, uint256 amount, address user, address licensee) internal {\\r\\n        require(licensee == address(0) || licenseeCompensator[licensee] != address(0), \\\"licensee is not registered\\\");\\r\\n        uint256 feeAmount = msg.value;\\r\\n        uint256 compFee; // company fee\\r\\n        if (tokenA \\u003c NATIVE_COINS) {\\r\\n            require(feeAmount \\u003e= amount, \\\"Insuficiant value\\\");   // if native coin, then feeAmount = msg.value - swap amount\\r\\n            feeAmount -= amount;\\r\\n            compFee = amount * companyFee / 10000;    // company fee\\r\\n        }\\r\\n        require(feeAmount \\u003e= processingFee, \\\"Insufficient processing fee\\\");\\r\\n        uint256 otherFee = feeAmount - processingFee;\\r\\n        uint256 licenseeFeeAmount;\\r\\n        uint256 licenseeFeeRate = licenseeFee[licensee];\\r\\n        if (licenseeFeeRate != 0 \\u0026\\u0026 otherFee != 0) {\\r\\n            if (tokenA \\u003c NATIVE_COINS) {\\r\\n                licenseeFeeAmount = amount * licenseeFeeRate / 10000;\\r\\n            } else {\\r\\n                licenseeFeeAmount = (otherFee * licenseeFeeRate)/(licenseeFeeRate + companyFee);\\r\\n            }\\r\\n        }\\r\\n        require(otherFee \\u003e= compFee + licenseeFeeAmount, \\\"Insuficiant fee\\\");\\r\\n        feeAmount -= licenseeFeeAmount;\\r\\n\\r\\n        if (licenseeFeeAmount != 0) {\\r\\n            TransferHelper.safeTransferETH(licensee, licenseeFeeAmount);\\r\\n            ISmart(licenseeCompensator[licensee]).requestCompensation(user, licenseeFeeAmount);\\r\\n        }\\r\\n\\r\\n        //TransferHelper.safeTransferETH(feeReceiver, feeAmount);\\r\\n        collectedFees += feeAmount;\\r\\n        if(contractSmart != address(0) \\u0026\\u0026 !isExcludedSender[msg.sender]) {\\r\\n            feeAmount = ((feeAmount - processingFee) * companyFeeReimbursement + processingFee * swapGasReimbursement) / 100;\\r\\n            if (feeAmount != 0)\\r\\n                ISmart(contractSmart).requestCompensation(user, feeAmount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // contribute from SmartSwap on user behalf\\r\\n    function _contributeFromSmartSwap(address token, address to, address user, uint256 value) internal {\\r\\n        if (token \\u003c NATIVE_COINS) {\\r\\n            IAuction(to).contributeFromSmartSwap{value: value}(payable(user));\\r\\n        } else {\\r\\n            IERC20(token).approve(to, value);\\r\\n            IAuction(to).contributeFromSmartSwap(token, value, user);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // call appropriate transfer function\\r\\n    function _transfer(address token, address to, uint256 value) internal {\\r\\n        if (token \\u003c NATIVE_COINS) \\r\\n            TransferHelper.safeTransferETH(to, value);\\r\\n        else\\r\\n            TransferHelper.safeTransfer(token, to, value);\\r\\n    }\\r\\n\\r\\n    // encode 64 bits of rate (decimal = 9). and 192 bits of amount \\r\\n    // into uint256 where high 64 bits is rate and low 192 bit is amount\\r\\n    // rate = foreign token price / native token price\\r\\n    function _encode(uint256 rate, uint256 amount) internal pure returns(uint256 encodedBalance) {\\r\\n        require(amount \\u003c MAX_AMOUNT, \\\"Amount overflow\\\");\\r\\n        require(rate \\u003c MAX_AMOUNT, \\\"Rate overflow\\\");\\r\\n        encodedBalance = rate * MAX_AMOUNT + amount;\\r\\n    }\\r\\n\\r\\n    // decode from uint256 where high 64 bits is rate and low 192 bit is amount\\r\\n    // rate = foreign token price / native token price\\r\\n    function _decode(uint256 encodedBalance) internal pure returns(uint256 rate, uint256 amount) {\\r\\n        rate = encodedBalance / MAX_AMOUNT;\\r\\n        amount = uint128(encodedBalance);\\r\\n    }\\r\\n    \\r\\n    function _getHashAddress(\\r\\n        address tokenA,\\r\\n        address tokenB, \\r\\n        address sender,\\r\\n        address receiver\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (address)\\r\\n    {\\r\\n        return address(uint160(uint256(keccak256(abi.encodePacked(tokenA, tokenB, sender, receiver)))));\\r\\n    }\\r\\n}\\r\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity \\u003e=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: APPROVE_FAILED\\u0027);\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FAILED\\u0027);\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027);\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, \\u0027TransferHelper: ETH_TRANSFER_FAILED\\u0027);\\n    }\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"CancelApprove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CancelRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"claimID\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"foreignAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"}],\"name\":\"ClaimApprove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"claimID\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"}],\"name\":\"ClaimRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ExchangeInvestETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairID\",\"type\":\"uint256\"}],\"name\":\"PairAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairID\",\"type\":\"uint256\"}],\"name\":\"PairRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"system\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"compensator\",\"type\":\"address\"}],\"name\":\"SetLicensee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"system\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"SetSystem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"minimumAmountToClaim\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"limitPice\",\"type\":\"uint128\"}],\"name\":\"SwapRequest\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountA\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentRate\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"senderCounterparty\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverCounterparty\",\"type\":\"address\"}],\"name\":\"addLiquidityAndClaimBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"}],\"name\":\"balanceCallback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hashAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"foreignSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeEncoded\",\"type\":\"uint256\"}],\"name\":\"balancesCallback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelGasReimbursement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cancelRequest\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"pairID\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_which\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"changeExchangeAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_which\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"changeExcludedAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amountB\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentRate\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"}],\"name\":\"claimInvestmentBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimRequest\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"pairID\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"claimID\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentRate\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amountA\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentRate\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"foreignBalance\",\"type\":\"uint256\"}],\"name\":\"claimTokenBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyFeeReimbursement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractSmart\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"contributeWithEtherBehalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimalsA\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimalsB\",\"type\":\"uint256\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foreignFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getColletedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getHashAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getPairByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPairID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairID\",\"type\":\"uint256\"}],\"name\":\"getPairVars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"native\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"foreign\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"foreignRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLiquidityProvider\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSystem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairIDCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateDiffLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setCompanyFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setForeignFactory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_licensee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_compensator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setLicensee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setLicenseeFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setMSSContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setProcessingFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setReimbursementPercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_system\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setSystem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"setValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"licensee\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isInvestment\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"minimumAmountToClaim\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"limitPice\",\"type\":\"uint128\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapGasReimbursement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SmartSwap","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://61f88424eff2d91811d46e86d2b42a590d42e5803d116a9e57a14f2d4d7ec240"}]}