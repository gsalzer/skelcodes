{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.6.6;\r\n\r\ninterface IMulanV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IMulanV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IMulanV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IMulanV2Router02 is IMulanV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ncontract MulanV2Router02 is IMulanV2Router02 {\r\n    using SafeMath for uint;\r\n\r\naddress public immutable override factory;\r\naddress public immutable override WETH;\r\n\r\nmodifier ensure(uint deadline) {\r\nrequire(deadline >= block.timestamp, 'MulanV2Router: EXPIRED');\r\n_;\r\n}\r\n\r\nconstructor(address _factory, address _WETH) public {\r\nfactory = _factory;\r\nWETH = _WETH;\r\n}\r\n\r\nreceive() external payable {\r\nassert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n}\r\n\r\n// **** ADD LIQUIDITY ****\r\nfunction _addLiquidity(\r\naddress tokenA,\r\naddress tokenB,\r\nuint amountADesired,\r\nuint amountBDesired,\r\nuint amountAMin,\r\nuint amountBMin\r\n) internal virtual returns (uint amountA, uint amountB) {\r\n// create the pair if it doesn't exist yet\r\nif (IMulanV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\r\nIMulanV2Factory(factory).createPair(tokenA, tokenB);\r\n}\r\n(uint reserveA, uint reserveB) = MulanV2Library.getReserves(factory, tokenA, tokenB);\r\nif (reserveA == 0 && reserveB == 0) {\r\n(amountA, amountB) = (amountADesired, amountBDesired);\r\n} else {\r\nuint amountBOptimal = MulanV2Library.quote(amountADesired, reserveA, reserveB);\r\nif (amountBOptimal <= amountBDesired) {\r\nrequire(amountBOptimal >= amountBMin, 'MulanV2Router: INSUFFICIENT_B_AMOUNT');\r\n(amountA, amountB) = (amountADesired, amountBOptimal);\r\n} else {\r\nuint amountAOptimal = MulanV2Library.quote(amountBDesired, reserveB, reserveA);\r\nassert(amountAOptimal <= amountADesired);\r\nrequire(amountAOptimal >= amountAMin, 'MulanV2Router: INSUFFICIENT_A_AMOUNT');\r\n(amountA, amountB) = (amountAOptimal, amountBDesired);\r\n}\r\n}\r\n}\r\nfunction addLiquidity(\r\naddress tokenA,\r\naddress tokenB,\r\nuint amountADesired,\r\nuint amountBDesired,\r\nuint amountAMin,\r\nuint amountBMin,\r\naddress to,\r\nuint deadline\r\n) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\naddress pair = MulanV2Library.pairFor(factory, tokenA, tokenB);\r\nTransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\nTransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\nliquidity = IMulanV2Pair(pair).mint(to);\r\n}\r\nfunction addLiquidityETH(\r\naddress token,\r\nuint amountTokenDesired,\r\nuint amountTokenMin,\r\nuint amountETHMin,\r\naddress to,\r\nuint deadline\r\n) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\r\n(amountToken, amountETH) = _addLiquidity(\r\ntoken,\r\nWETH,\r\namountTokenDesired,\r\nmsg.value,\r\namountTokenMin,\r\namountETHMin\r\n);\r\naddress pair = MulanV2Library.pairFor(factory, token, WETH);\r\nTransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\nIWETH(WETH).deposit{value: amountETH}();\r\nassert(IWETH(WETH).transfer(pair, amountETH));\r\nliquidity = IMulanV2Pair(pair).mint(to);\r\n// refund dust eth, if any\r\nif (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n}\r\n\r\n// **** REMOVE LIQUIDITY ****\r\nfunction removeLiquidity(\r\naddress tokenA,\r\naddress tokenB,\r\nuint liquidity,\r\nuint amountAMin,\r\nuint amountBMin,\r\naddress to,\r\nuint deadline\r\n) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\r\naddress pair = MulanV2Library.pairFor(factory, tokenA, tokenB);\r\nIMulanV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\r\n(uint amount0, uint amount1) = IMulanV2Pair(pair).burn(to);\r\n(address token0,) = MulanV2Library.sortTokens(tokenA, tokenB);\r\n(amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\nrequire(amountA >= amountAMin, 'MulanV2Router: INSUFFICIENT_A_AMOUNT');\r\nrequire(amountB >= amountBMin, 'MulanV2Router: INSUFFICIENT_B_AMOUNT');\r\n}\r\nfunction removeLiquidityETH(\r\naddress token,\r\nuint liquidity,\r\nuint amountTokenMin,\r\nuint amountETHMin,\r\naddress to,\r\nuint deadline\r\n) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\r\n(amountToken, amountETH) = removeLiquidity(\r\ntoken,\r\nWETH,\r\nliquidity,\r\namountTokenMin,\r\namountETHMin,\r\naddress(this),\r\ndeadline\r\n);\r\nTransferHelper.safeTransfer(token, to, amountToken);\r\nIWETH(WETH).withdraw(amountETH);\r\nTransferHelper.safeTransferETH(to, amountETH);\r\n}\r\nfunction removeLiquidityWithPermit(\r\naddress tokenA,\r\naddress tokenB,\r\nuint liquidity,\r\nuint amountAMin,\r\nuint amountBMin,\r\naddress to,\r\nuint deadline,\r\nbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n) external virtual override returns (uint amountA, uint amountB) {\r\naddress pair = MulanV2Library.pairFor(factory, tokenA, tokenB);\r\nuint value = approveMax ? uint(-1) : liquidity;\r\nIMulanV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n(amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n}\r\nfunction removeLiquidityETHWithPermit(\r\naddress token,\r\nuint liquidity,\r\nuint amountTokenMin,\r\nuint amountETHMin,\r\naddress to,\r\nuint deadline,\r\nbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n) external virtual override returns (uint amountToken, uint amountETH) {\r\naddress pair = MulanV2Library.pairFor(factory, token, WETH);\r\nuint value = approveMax ? uint(-1) : liquidity;\r\nIMulanV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n(amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n}\r\n\r\n// **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\r\nfunction removeLiquidityETHSupportingFeeOnTransferTokens(\r\naddress token,\r\nuint liquidity,\r\nuint amountTokenMin,\r\nuint amountETHMin,\r\naddress to,\r\nuint deadline\r\n) public virtual override ensure(deadline) returns (uint amountETH) {\r\n(, amountETH) = removeLiquidity(\r\ntoken,\r\nWETH,\r\nliquidity,\r\namountTokenMin,\r\namountETHMin,\r\naddress(this),\r\ndeadline\r\n);\r\nTransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\nIWETH(WETH).withdraw(amountETH);\r\nTransferHelper.safeTransferETH(to, amountETH);\r\n}\r\nfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\naddress token,\r\nuint liquidity,\r\nuint amountTokenMin,\r\nuint amountETHMin,\r\naddress to,\r\nuint deadline,\r\nbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n) external virtual override returns (uint amountETH) {\r\naddress pair = MulanV2Library.pairFor(factory, token, WETH);\r\nuint value = approveMax ? uint(-1) : liquidity;\r\nIMulanV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\namountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\r\ntoken, liquidity, amountTokenMin, amountETHMin, to, deadline\r\n);\r\n}\r\n\r\n// **** SWAP ****\r\n// requires the initial amount to have already been sent to the first pair\r\nfunction _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\r\nfor (uint i; i < path.length - 1; i++) {\r\n(address input, address output) = (path[i], path[i + 1]);\r\n(address token0,) = MulanV2Library.sortTokens(input, output);\r\nuint amountOut = amounts[i + 1];\r\n(uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\naddress to = i < path.length - 2 ? MulanV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\nIMulanV2Pair(MulanV2Library.pairFor(factory, input, output)).swap(\r\namount0Out, amount1Out, to, new bytes(0)\r\n);\r\n}\r\n}\r\nfunction swapExactTokensForTokens(\r\nuint amountIn,\r\nuint amountOutMin,\r\naddress[] calldata path,\r\naddress to,\r\nuint deadline\r\n) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\namounts = MulanV2Library.getAmountsOut(factory, amountIn, path);\r\nrequire(amounts[amounts.length - 1] >= amountOutMin, 'MulanV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\nTransferHelper.safeTransferFrom(\r\npath[0], msg.sender, MulanV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n);\r\n_swap(amounts, path, to);\r\n}\r\nfunction swapTokensForExactTokens(\r\nuint amountOut,\r\nuint amountInMax,\r\naddress[] calldata path,\r\naddress to,\r\nuint deadline\r\n) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\namounts = MulanV2Library.getAmountsIn(factory, amountOut, path);\r\nrequire(amounts[0] <= amountInMax, 'MulanV2Router: EXCESSIVE_INPUT_AMOUNT');\r\nTransferHelper.safeTransferFrom(\r\npath[0], msg.sender, MulanV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n);\r\n_swap(amounts, path, to);\r\n}\r\nfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\nexternal\r\nvirtual\r\noverride\r\npayable\r\nensure(deadline)\r\nreturns (uint[] memory amounts)\r\n{\r\nrequire(path[0] == WETH, 'MulanV2Router: INVALID_PATH');\r\namounts = MulanV2Library.getAmountsOut(factory, msg.value, path);\r\nrequire(amounts[amounts.length - 1] >= amountOutMin, 'MulanV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\nIWETH(WETH).deposit{value: amounts[0]}();\r\nassert(IWETH(WETH).transfer(MulanV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n_swap(amounts, path, to);\r\n}\r\nfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\nexternal\r\nvirtual\r\noverride\r\nensure(deadline)\r\nreturns (uint[] memory amounts)\r\n{\r\nrequire(path[path.length - 1] == WETH, 'MulanV2Router: INVALID_PATH');\r\namounts = MulanV2Library.getAmountsIn(factory, amountOut, path);\r\nrequire(amounts[0] <= amountInMax, 'MulanV2Router: EXCESSIVE_INPUT_AMOUNT');\r\nTransferHelper.safeTransferFrom(\r\npath[0], msg.sender, MulanV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n);\r\n_swap(amounts, path, address(this));\r\nIWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\nTransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n}\r\nfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\nexternal\r\nvirtual\r\noverride\r\nensure(deadline)\r\nreturns (uint[] memory amounts)\r\n{\r\nrequire(path[path.length - 1] == WETH, 'MulanV2Router: INVALID_PATH');\r\namounts = MulanV2Library.getAmountsOut(factory, amountIn, path);\r\nrequire(amounts[amounts.length - 1] >= amountOutMin, 'MulanV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\nTransferHelper.safeTransferFrom(\r\npath[0], msg.sender, MulanV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n);\r\n_swap(amounts, path, address(this));\r\nIWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\nTransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n}\r\nfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\nexternal\r\nvirtual\r\noverride\r\npayable\r\nensure(deadline)\r\nreturns (uint[] memory amounts)\r\n{\r\nrequire(path[0] == WETH, 'MulanV2Router: INVALID_PATH');\r\namounts = MulanV2Library.getAmountsIn(factory, amountOut, path);\r\nrequire(amounts[0] <= msg.value, 'MulanV2Router: EXCESSIVE_INPUT_AMOUNT');\r\nIWETH(WETH).deposit{value: amounts[0]}();\r\nassert(IWETH(WETH).transfer(MulanV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n_swap(amounts, path, to);\r\n// refund dust eth, if any\r\nif (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n}\r\n\r\n// **** SWAP (supporting fee-on-transfer tokens) ****\r\n// requires the initial amount to have already been sent to the first pair\r\nfunction _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\r\nfor (uint i; i < path.length - 1; i++) {\r\n(address input, address output) = (path[i], path[i + 1]);\r\n(address token0,) = MulanV2Library.sortTokens(input, output);\r\nIMulanV2Pair pair = IMulanV2Pair(MulanV2Library.pairFor(factory, input, output));\r\nuint amountInput;\r\nuint amountOutput;\r\n{ // scope to avoid stack too deep errors\r\n(uint reserve0, uint reserve1,) = pair.getReserves();\r\n(uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\namountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\namountOutput = MulanV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\r\n}\r\n(uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\naddress to = i < path.length - 2 ? MulanV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\npair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n}\r\n}\r\nfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\nuint amountIn,\r\nuint amountOutMin,\r\naddress[] calldata path,\r\naddress to,\r\nuint deadline\r\n) external virtual override ensure(deadline) {\r\nTransferHelper.safeTransferFrom(\r\npath[0], msg.sender, MulanV2Library.pairFor(factory, path[0], path[1]), amountIn\r\n);\r\nuint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n_swapSupportingFeeOnTransferTokens(path, to);\r\nrequire(\r\nIERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n'MulanV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\r\n);\r\n}\r\nfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\r\nuint amountOutMin,\r\naddress[] calldata path,\r\naddress to,\r\nuint deadline\r\n)\r\nexternal\r\nvirtual\r\noverride\r\npayable\r\nensure(deadline)\r\n{\r\nrequire(path[0] == WETH, 'MulanV2Router: INVALID_PATH');\r\nuint amountIn = msg.value;\r\nIWETH(WETH).deposit{value: amountIn}();\r\nassert(IWETH(WETH).transfer(MulanV2Library.pairFor(factory, path[0], path[1]), amountIn));\r\nuint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n_swapSupportingFeeOnTransferTokens(path, to);\r\nrequire(\r\nIERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n'MulanV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\r\n);\r\n}\r\nfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\nuint amountIn,\r\nuint amountOutMin,\r\naddress[] calldata path,\r\naddress to,\r\nuint deadline\r\n)\r\nexternal\r\nvirtual\r\noverride\r\nensure(deadline)\r\n{\r\nrequire(path[path.length - 1] == WETH, 'MulanV2Router: INVALID_PATH');\r\nTransferHelper.safeTransferFrom(\r\npath[0], msg.sender, MulanV2Library.pairFor(factory, path[0], path[1]), amountIn\r\n);\r\n_swapSupportingFeeOnTransferTokens(path, address(this));\r\nuint amountOut = IERC20(WETH).balanceOf(address(this));\r\nrequire(amountOut >= amountOutMin, 'MulanV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\nIWETH(WETH).withdraw(amountOut);\r\nTransferHelper.safeTransferETH(to, amountOut);\r\n}\r\n\r\n// **** LIBRARY FUNCTIONS ****\r\nfunction quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\r\nreturn MulanV2Library.quote(amountA, reserveA, reserveB);\r\n}\r\n\r\nfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\r\npublic\r\npure\r\nvirtual\r\noverride\r\nreturns (uint amountOut)\r\n{\r\nreturn MulanV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\r\n}\r\n\r\nfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\r\npublic\r\npure\r\nvirtual\r\noverride\r\nreturns (uint amountIn)\r\n{\r\nreturn MulanV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\r\n}\r\n\r\nfunction getAmountsOut(uint amountIn, address[] memory path)\r\npublic\r\nview\r\nvirtual\r\noverride\r\nreturns (uint[] memory amounts)\r\n{\r\nreturn MulanV2Library.getAmountsOut(factory, amountIn, path);\r\n}\r\n\r\nfunction getAmountsIn(uint amountOut, address[] memory path)\r\npublic\r\nview\r\nvirtual\r\noverride\r\nreturns (uint[] memory amounts)\r\n{\r\nreturn MulanV2Library.getAmountsIn(factory, amountOut, path);\r\n}\r\n}\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\nfunction add(uint x, uint y) internal pure returns (uint z) {\r\nrequire((z = x + y) >= x, 'ds-math-add-overflow');\r\n}\r\n\r\nfunction sub(uint x, uint y) internal pure returns (uint z) {\r\nrequire((z = x - y) <= x, 'ds-math-sub-underflow');\r\n}\r\n\r\nfunction mul(uint x, uint y) internal pure returns (uint z) {\r\nrequire(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n}\r\n}\r\n\r\nlibrary MulanV2Library {\r\nusing SafeMath for uint;\r\n\r\n// returns sorted token addresses, used to handle return values from pairs sorted in this order\r\nfunction sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\nrequire(tokenA != tokenB, 'MulanV2Library: IDENTICAL_ADDRESSES');\r\n(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\nrequire(token0 != address(0), 'MulanV2Library: ZERO_ADDRESS');\r\n}\r\n\r\n// calculates the CREATE2 address for a pair without making any external calls\r\nfunction pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n(address token0, address token1) = sortTokens(tokenA, tokenB);\r\npair = address(uint(keccak256(abi.encodePacked(\r\nhex'ff',\r\nfactory,\r\nkeccak256(abi.encodePacked(token0, token1)),\r\nhex'0395c7282c80c57363fdcba39dc6455449ff9b9638ae528a3eeb3fcf103a1e31' // init code hash\r\n))));\r\n}\r\n\r\n// fetches and sorts the reserves for a pair\r\nfunction getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n(address token0,) = sortTokens(tokenA, tokenB);\r\n(uint reserve0, uint reserve1,) = IMulanV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n(reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n}\r\n\r\n// given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\nfunction quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\nrequire(amountA > 0, 'MulanV2Library: INSUFFICIENT_AMOUNT');\r\nrequire(reserveA > 0 && reserveB > 0, 'MulanV2Library: INSUFFICIENT_LIQUIDITY');\r\namountB = amountA.mul(reserveB) / reserveA;\r\n}\r\n\r\n// given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\nfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\nrequire(amountIn > 0, 'MulanV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\nrequire(reserveIn > 0 && reserveOut > 0, 'MulanV2Library: INSUFFICIENT_LIQUIDITY');\r\nuint amountInWithFee = amountIn.mul(997);\r\nuint numerator = amountInWithFee.mul(reserveOut);\r\nuint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\namountOut = numerator / denominator;\r\n}\r\n\r\n// given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\nfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\nrequire(amountOut > 0, 'MulanV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\nrequire(reserveIn > 0 && reserveOut > 0, 'MulanV2Library: INSUFFICIENT_LIQUIDITY');\r\nuint numerator = reserveIn.mul(amountOut).mul(1000);\r\nuint denominator = reserveOut.sub(amountOut).mul(997);\r\namountIn = (numerator / denominator).add(1);\r\n}\r\n\r\n// performs chained getAmountOut calculations on any number of pairs\r\nfunction getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\nrequire(path.length >= 2, 'MulanV2Library: INVALID_PATH');\r\namounts = new uint[](path.length);\r\namounts[0] = amountIn;\r\nfor (uint i; i < path.length - 1; i++) {\r\n(uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\namounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n}\r\n}\r\n\r\n// performs chained getAmountIn calculations on any number of pairs\r\nfunction getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\nrequire(path.length >= 2, 'MulanV2Library: INVALID_PATH');\r\namounts = new uint[](path.length);\r\namounts[amounts.length - 1] = amountOut;\r\nfor (uint i = path.length - 1; i > 0; i--) {\r\n(uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\namounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n}\r\n}\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\nfunction safeApprove(address token, address to, uint value) internal {\r\n// bytes4(keccak256(bytes('approve(address,uint256)')));\r\n(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\nrequire(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n}\r\n\r\nfunction safeTransfer(address token, address to, uint value) internal {\r\n// bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\nrequire(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n}\r\n\r\nfunction safeTransferFrom(address token, address from, address to, uint value) internal {\r\n// bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\nrequire(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n}\r\n\r\nfunction safeTransferETH(address to, uint value) internal {\r\n(bool success,) = to.call{value:value}(new bytes(0));\r\nrequire(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETHSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MulanV2Router02","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ba1498c77cfba69dd58362d256c593140b7e716400000000000000000000000073d02307abf9e38700a285df05b3664d33155c95","EVMVersion":"istanbul","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://47e52e4139ce9c65327c725e594bfd83876e74877163a7e4a9c402fbf55023fe"}]}