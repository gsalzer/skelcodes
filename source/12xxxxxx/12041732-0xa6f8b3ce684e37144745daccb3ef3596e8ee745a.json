{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a * b;\r\n        assertion(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal pure returns(uint) {\r\n        assertion(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a + b;\r\n        assertion(c >= a && c >= b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal pure returns(uint) {\r\n        require(b != 0, 'Divide by zero');\r\n\r\n        return a / b;\r\n    }\r\n\r\n    function safeCeil(uint a, uint b) internal pure returns (uint) {\r\n        require(b > 0);\r\n\r\n        uint v = a / b;\r\n\r\n        if(v * b == a) return v;\r\n\r\n        return v + 1;  // b cannot be 1, so v <= a / 2\r\n    }\r\n\r\n    function assertion(bool flag) internal pure {\r\n        if (!flag) revert('Assertion fail.');\r\n    }\r\n}\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWallet {\r\n\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        if (msg.sender != address(this))\r\n            revert(\"Unauthorized.\");\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner])\r\n            revert(\"Unauthorized.\");\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        if (!isOwner[owner])\r\n            revert(\"Unauthorized.\");\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        if (transactions[transactionId].destination == address(0))\r\n            revert(\"Existed transaction id.\");\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner])\r\n            revert(\"Not confirmed transaction.\");\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        if (confirmations[transactionId][owner])\r\n            revert(\"Confirmed transaction.\");\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        if (transactions[transactionId].executed)\r\n            revert(\"Executed transaction.\");\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == address(0))\r\n            revert(\"Address is null\");\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (   ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount\r\n            || _required == 0\r\n            || ownerCount == 0)\r\n            revert(\"Invalid requirement\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n        external\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    constructor(address[] memory _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == address(0))\r\n                revert(\"Invalid owner\");\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        emit OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        emit OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param owner Address of new owner.\r\n    function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        emit OwnerRemoval(owner);\r\n        emit OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        emit RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes memory data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            (bool result, ) = txn.destination.call.value(txn.value)(txn.data);\r\n            if (result)\r\n                emit Execution(transactionId);\r\n            else {\r\n                emit ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes memory data)\r\n        public\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        emit Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        view\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        view\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        view\r\n        returns (address[] memory _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        view\r\n        returns (uint[] memory _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}\r\n\r\ncontract EthVault is MultiSigWallet{\r\n    string public constant chain = \"ETH\";\r\n\r\n    bool public isActivated = true;\r\n\r\n    address payable public implementation;\r\n    address public tetherAddress;\r\n\r\n    uint public depositCount = 0;\r\n\r\n    mapping(bytes32 => bool) public isUsedWithdrawal;\r\n\r\n    mapping(bytes32 => address) public tokenAddr;\r\n    mapping(address => bytes32) public tokenSummaries;\r\n\r\n    mapping(bytes32 => bool) public isValidChain;\r\n\r\n    constructor(address[] memory _owners, uint _required, address payable _implementation, address _tetherAddress) MultiSigWallet(_owners, _required) public {\r\n        implementation = _implementation;\r\n        tetherAddress = _tetherAddress;\r\n\r\n        // klaytn valid chain default setting\r\n        isValidChain[sha256(abi.encodePacked(address(this), \"KLAYTN\"))] = true;\r\n    }\r\n\r\n    function _setImplementation(address payable _newImp) public onlyWallet {\r\n        require(implementation != _newImp);\r\n        implementation = _newImp;\r\n\r\n    }\r\n\r\n    function () payable external {\r\n        address impl = implementation;\r\n        require(impl != address(0));\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract TIERC20 {\r\n    function transfer(address to, uint value) public;\r\n    function transferFrom(address from, address to, uint value) public;\r\n\r\n    function balanceOf(address who) public view returns (uint);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC721 {\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface IFarm {\r\n    function deposit(uint amount) external;\r\n    function withdrawAll() external;\r\n    function withdraw(address toAddr, uint amount) external;\r\n}\r\n\r\ninterface OrbitBridgeReceiver {\r\n    function onTokenBridgeReceived(address _token, uint256 _value, bytes calldata _data) external returns(uint);\r\n\tfunction onNFTBridgeReceived(address _token, uint256 _tokenId, bytes calldata _data) external returns(uint);\r\n}\r\n\r\nlibrary LibTokenManager {\r\n    function depositToken(address payable implAddr, address token, string memory toChain, uint amount) public returns(uint8 decimal) {\r\n        EthVaultImpl impl = EthVaultImpl(implAddr);\r\n        require(impl.isValidChain(impl.getChainId(toChain)));\r\n        require(amount != 0);\r\n\r\n        if(token == address(0)){\r\n            decimal = 18;\r\n        }\r\n        else if(token == impl.tetherAddress() || impl.silentTokenList(token)){\r\n            TIERC20(token).transferFrom(msg.sender, implAddr, amount);\r\n            decimal = TIERC20(token).decimals();\r\n        }\r\n        else{\r\n            if(!IERC20(token).transferFrom(msg.sender, implAddr, amount)) revert();\r\n            decimal = IERC20(token).decimals();\r\n        }\r\n        require(decimal > 0);\r\n\r\n        address payable farm = impl.farms(token);\r\n        if(farm != address(0)){\r\n            _transferToken(impl, token, farm, amount);\r\n            IFarm(farm).deposit(amount);\r\n        }\r\n    }\r\n    \r\n    function _transferToken(EthVaultImpl impl, address token, address payable destination, uint amount) public {\r\n        if(token == address(0)){\r\n            (bool transfered,) = destination.call.value(amount)(\"\");\r\n            require(transfered);\r\n        }\r\n        else if(token == impl.tetherAddress() || impl.silentTokenList(token)){\r\n            TIERC20(token).transfer(destination, amount);\r\n        }\r\n        else{\r\n            if(!IERC20(token).transfer(destination, amount)) revert();\r\n        }\r\n    }\r\n}\r\n\r\nlibrary LibCallBridgeReceiver {\r\n    event BridgeReceiverResult(bool success, address fromAddress, address tokenAddress, bytes data);\r\n    \r\n    function callReceiver(bool isFungible, uint gasLimitForBridgeReceiver, address tokenAddress, uint256 _int, bytes memory data, address toAddr, address fromAddr) public {\r\n        bool result;\r\n        bytes memory callbytes;\r\n        if (isFungible) {\r\n            callbytes = abi.encodeWithSignature(\"onTokenBridgeReceived(address,uint256,bytes)\", tokenAddress, _int, data);\r\n        } else {\r\n            callbytes = abi.encodeWithSignature(\"onNFTBridgeReceived(address,uint256,bytes)\", tokenAddress, _int, data);\r\n        }\r\n        if (gasLimitForBridgeReceiver > 0) {\r\n            (result, ) = toAddr.call.gas(gasLimitForBridgeReceiver)(callbytes);\r\n        } else {\r\n            (result, ) = toAddr.call(callbytes);\r\n        }\r\n        emit BridgeReceiverResult(result, fromAddr, tokenAddress, data);\r\n    }\r\n}\r\n\r\ncontract EthVaultImpl is EthVault, SafeMath{\r\n    uint public bridgingFee = 0;\r\n    address payable public feeGovernance;\r\n    mapping(address => bool) public silentTokenList;\r\n\r\n    mapping(address => address payable) public farms;\r\n    uint public taxRate; // 0.01% interval\r\n    address public taxReceiver;\r\n\r\n    uint public gasLimitForBridgeReceiver;\r\n    \r\n    event Deposit(string toChain, address fromAddr, bytes toAddr, address token, uint8 decimal, uint amount, uint depositId, bytes data);\r\n    event DepositNFT(string toChain, address fromAddr, bytes toAddr, address token, uint tokenId, uint amount, uint depositId, bytes data);\r\n\r\n    event Withdraw(string fromChain, bytes fromAddr, bytes toAddr, bytes token, bytes32[] bytes32s, uint[] uints, bytes data);\r\n    event WithdrawNFT(string fromChain, bytes fromAddr, bytes toAddr, bytes token, bytes32[] bytes32s, uint[] uints, bytes data);\r\n\r\n    event BridgeReceiverResult(bool success, address fromAddress, address tokenAddress, bytes data);\r\n    \r\n    modifier onlyActivated {\r\n        require(isActivated);\r\n        _;\r\n    }\r\n\r\n    constructor(address[] memory _owner) public EthVault(_owner, _owner.length, address(0), address(0)) {\r\n    }\r\n\r\n    function getVersion() public pure returns(string memory){\r\n        return \"20210310\";\r\n    }\r\n\r\n    function changeActivate(bool activate) public onlyWallet {\r\n        isActivated = activate;\r\n    }\r\n\r\n    function setTetherAddress(address tether) public onlyWallet {\r\n        tetherAddress = tether;\r\n    }\r\n\r\n    function getChainId(string memory _chain) public view returns(bytes32){\r\n        return sha256(abi.encodePacked(address(this), _chain));\r\n    }\r\n\r\n    function setValidChain(string memory _chain, bool valid) public onlyWallet {\r\n        isValidChain[getChainId(_chain)] = valid;\r\n    }\r\n\r\n    function setSilentToken(address token, bool valid) public onlyWallet {\r\n        silentTokenList[token] = valid;\r\n    }\r\n    \r\n    function setParams(uint _taxRate, address _taxReceiver, uint _gasLimitForBridgeReceiver) public onlyWallet {\r\n        require(_taxRate < 10000);\r\n        require(_taxReceiver != address(0));\r\n        taxRate = _taxRate;\r\n        taxReceiver = _taxReceiver;\r\n        gasLimitForBridgeReceiver = _gasLimitForBridgeReceiver;\r\n    }\r\n\r\n    function addFarm(address token, address payable proxy) public onlyWallet {\r\n        require(farms[token] == address(0));\r\n\r\n        uint amount;\r\n        if(token == address(0)){\r\n            amount = address(this).balance;\r\n        }\r\n        else{\r\n            amount = IERC20(token).balanceOf(address(this));\r\n        }\r\n\r\n        LibTokenManager._transferToken(this, token, proxy, amount);\r\n        IFarm(proxy).deposit(amount);\r\n\r\n        farms[token] = proxy;\r\n    }\r\n\r\n    function removeFarm(address token, address payable newProxy) public onlyWallet {\r\n        require(farms[token] != address(0));\r\n\r\n        IFarm(farms[token]).withdrawAll();\r\n\r\n        if(newProxy != address(0)){\r\n            uint amount;\r\n            if(token == address(0)){\r\n                amount = address(this).balance;\r\n            }\r\n            else{\r\n                amount = IERC20(token).balanceOf(address(this));\r\n            }\r\n\r\n            LibTokenManager._transferToken(this, token, newProxy, amount);\r\n            IFarm(newProxy).deposit(amount);\r\n        }\r\n\r\n        farms[token] = newProxy;\r\n    }\r\n    \r\n    function deposit(string memory toChain, bytes memory toAddr) payable public {\r\n        _depositToken(address(0), toChain, toAddr, msg.value, \"\");\r\n    }\r\n\r\n    function deposit(string memory toChain, bytes memory toAddr, bytes memory data) payable public {\r\n        require(data.length != 0);\r\n        _depositToken(address(0), toChain, toAddr, msg.value, data);\r\n    }\r\n    \r\n    function depositToken(address token, string memory toChain, bytes memory toAddr, uint amount) public {\r\n        _depositToken(token, toChain, toAddr, amount, \"\");\r\n    }\r\n\r\n    function depositToken(address token, string memory toChain, bytes memory toAddr, uint amount, bytes memory data) public {\r\n        require(data.length != 0);\r\n        _depositToken(token, toChain, toAddr, amount, data);\r\n    }\r\n\r\n    function _depositToken(address token, string memory toChain, bytes memory toAddr, uint amount, bytes memory data) private onlyActivated {\r\n        uint8 decimal = LibTokenManager.depositToken(address(this), token, toChain, amount);\r\n\r\n        if(taxRate > 0 && taxReceiver != address(0)){\r\n            uint tax = _payTax(token, amount, decimal);\r\n            amount = safeSub(amount, tax);\r\n        }\r\n\r\n        depositCount = depositCount + 1;\r\n        emit Deposit(toChain, msg.sender, toAddr, token, decimal, amount, depositCount, data);\r\n    }\r\n    \r\n    function depositNFT(address token, string memory toChain, bytes memory toAddr, uint tokenId) public {\r\n        _depositNFT(token, toChain, toAddr, tokenId, \"\");\r\n    }\r\n    \r\n    function depositNFT(address token, string memory toChain, bytes memory toAddr, uint tokenId, bytes memory data) public {\r\n        require(data.length != 0);\r\n        _depositNFT(token, toChain, toAddr, tokenId, data);\r\n    }\r\n\r\n    function _depositNFT(address token, string memory toChain, bytes memory toAddr, uint tokenId, bytes memory data) private onlyActivated {\r\n        require(isValidChain[getChainId(toChain)]);\r\n        require(token != address(0));\r\n        require(IERC721(token).ownerOf(tokenId) == msg.sender);\r\n\r\n        IERC721(token).transferFrom(msg.sender, address(this), tokenId);\r\n        require(IERC721(token).ownerOf(tokenId) == address(this));\r\n\r\n        depositCount = depositCount + 1;\r\n        emit DepositNFT(toChain, msg.sender, toAddr, token, tokenId, 1, depositCount, data);\r\n    }\r\n\r\n    // Fix Data Info\r\n    ///@param bytes32s [0]:govId, [1]:txHash\r\n    ///@param uints [0]:amount, [1]:decimal\r\n    function withdraw(\r\n        address hubContract,\r\n        string memory fromChain,\r\n        bytes memory fromAddr,\r\n        bytes memory toAddr,\r\n        bytes memory token,\r\n        bytes32[] memory bytes32s,\r\n        uint[] memory uints,\r\n        bytes memory data,\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s\r\n    ) public onlyActivated {\r\n        require(bytes32s.length >= 1);\r\n        require(uints.length >= 2);\r\n        require(bytes32s[0] == sha256(abi.encodePacked(hubContract, chain, address(this))));\r\n        require(isValidChain[getChainId(fromChain)]);\r\n\r\n        bytes32 whash = sha256(abi.encodePacked(hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints, data));\r\n\r\n        require(!isUsedWithdrawal[whash]);\r\n        isUsedWithdrawal[whash] = true;\r\n\r\n        uint validatorCount = _validate(whash, v, r, s);\r\n        require(validatorCount >= required);\r\n\r\n        address payable _toAddr = bytesToAddress(toAddr);\r\n        address tokenAddress = bytesToAddress(token);\r\n\r\n        if(farms[tokenAddress] != address(0)){ // farmProxy 출금\r\n            IFarm(farms[tokenAddress]).withdraw(_toAddr, uints[0]);\r\n        }\r\n        else{ // 일반 출금\r\n            LibTokenManager._transferToken(this, tokenAddress, _toAddr, uints[0]);\r\n        }\r\n\r\n        if(isContract(_toAddr) && data.length != 0){\r\n            address _from = bytesToAddress(fromAddr);\r\n            LibCallBridgeReceiver.callReceiver(true, gasLimitForBridgeReceiver, tokenAddress, uints[0], data, _toAddr, _from);\r\n        }\r\n\r\n        emit Withdraw(fromChain, fromAddr, toAddr, token, bytes32s, uints, data);\r\n    }\r\n\r\n    // Fix Data Info\r\n    ///@param bytes32s [0]:govId, [1]:txHash\r\n    ///@param uints [0]:amount, [1]:tokenId\r\n    function withdrawNFT(\r\n        address hubContract,\r\n        string memory fromChain,\r\n        bytes memory fromAddr,\r\n        bytes memory toAddr,\r\n        bytes memory token,\r\n        bytes32[] memory bytes32s,\r\n        uint[] memory uints,\r\n        bytes memory data,\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s\r\n    ) public onlyActivated {\r\n        require(bytes32s.length >= 1);\r\n        require(uints.length >= 2);\r\n        require(bytes32s[0] == sha256(abi.encodePacked(hubContract, chain, address(this))));\r\n        require(isValidChain[getChainId(fromChain)]);\r\n\r\n        bytes32 whash = sha256(abi.encodePacked(\"NFT\", hubContract, fromChain, chain, fromAddr, toAddr, token, bytes32s, uints, data));\r\n\r\n        require(!isUsedWithdrawal[whash]);\r\n        isUsedWithdrawal[whash] = true;\r\n\r\n        uint validatorCount = _validate(whash, v, r, s);\r\n        require(validatorCount >= required);\r\n\r\n        address payable _toAddr = bytesToAddress(toAddr);\r\n        address tokenAddress = bytesToAddress(token);\r\n\r\n        require(IERC721(tokenAddress).ownerOf(uints[1]) == address(this));\r\n        IERC721(tokenAddress).transferFrom(address(this), _toAddr, uints[1]);\r\n        require(IERC721(tokenAddress).ownerOf(uints[1]) == _toAddr);\r\n\r\n        if(isContract(_toAddr) && data.length != 0){\r\n            address _from = bytesToAddress(fromAddr);\r\n            LibCallBridgeReceiver.callReceiver(false, gasLimitForBridgeReceiver, tokenAddress, uints[1], data, _toAddr, _from);\r\n        }\r\n        \r\n        emit WithdrawNFT(fromChain, fromAddr, toAddr, token, bytes32s, uints, data);\r\n    }\r\n\r\n    function _validate(bytes32 whash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) private view returns(uint){\r\n        uint validatorCount = 0;\r\n        address[] memory vaList = new address[](owners.length);\r\n\r\n        uint i=0;\r\n        uint j=0;\r\n\r\n        for(i; i<v.length; i++){\r\n            address va = ecrecover(whash,v[i],r[i],s[i]);\r\n            if(isOwner[va]){\r\n                for(j=0; j<validatorCount; j++){\r\n                    require(vaList[j] != va);\r\n                }\r\n\r\n                vaList[validatorCount] = va;\r\n                validatorCount += 1;\r\n            }\r\n        }\r\n\r\n        return validatorCount;\r\n    }\r\n\r\n    function _payTax(address token, uint amount, uint8 decimal) private returns (uint tax) {\r\n        tax = safeDiv(safeMul(amount, taxRate), 10000);\r\n        if(tax > 0){\r\n            depositCount = depositCount + 1;\r\n            emit Deposit(\"ORBIT\", msg.sender, abi.encodePacked(taxReceiver), token, decimal, tax, depositCount, \"\");\r\n        }\r\n    }\r\n\r\n    function isContract(address _addr) private view returns (bool){\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) public pure returns (address payable addr) {\r\n        assembly {\r\n            addr := mload(add(bys,20))\r\n        }\r\n    }\r\n\r\n    function () payable external{\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taxRate\",\"type\":\"uint256\"},{\"name\":\"_taxReceiver\",\"type\":\"address\"},{\"name\":\"_gasLimitForBridgeReceiver\",\"type\":\"uint256\"}],\"name\":\"setParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tether\",\"type\":\"address\"}],\"name\":\"setTetherAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"valid\",\"type\":\"bool\"}],\"name\":\"setSilentToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_chain\",\"type\":\"string\"}],\"name\":\"getChainId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"confirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"depositNFT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"activate\",\"type\":\"bool\"}],\"name\":\"changeActivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tetherAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hubContract\",\"type\":\"address\"},{\"name\":\"fromChain\",\"type\":\"string\"},{\"name\":\"fromAddr\",\"type\":\"bytes\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"token\",\"type\":\"bytes\"},{\"name\":\"bytes32s\",\"type\":\"bytes32[]\"},{\"name\":\"uints\",\"type\":\"uint256[]\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"withdrawNFT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"farms\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bys\",\"type\":\"bytes\"}],\"name\":\"bytesToAddress\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActivated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"addFarm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"silentTokenList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasLimitForBridgeReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"depositNFT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"tokenAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"taxRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"newProxy\",\"type\":\"address\"}],\"name\":\"removeFarm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridgingFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isUsedWithdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionIds\",\"outputs\":[{\"name\":\"_transactionIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_chain\",\"type\":\"string\"},{\"name\":\"valid\",\"type\":\"bool\"}],\"name\":\"setValidChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeGovernance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hubContract\",\"type\":\"address\"},{\"name\":\"fromChain\",\"type\":\"string\"},{\"name\":\"fromAddr\",\"type\":\"bytes\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"token\",\"type\":\"bytes\"},{\"name\":\"bytes32s\",\"type\":\"bytes32[]\"},{\"name\":\"uints\",\"type\":\"uint256[]\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"name\":\"_confirmations\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newImp\",\"type\":\"address\"}],\"name\":\"_setImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chain\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenSummaries\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"taxReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"addTransaction\",\"outputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isValidChain\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"toChain\",\"type\":\"string\"},{\"name\":\"toAddr\",\"type\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"toChain\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"decimal\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"toChain\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"DepositNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromChain\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"toAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"bytes32s\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"uints\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromChain\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"toAddr\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"bytes32s\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"uints\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"WithdrawNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BridgeReceiverResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Submission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"RequirementChange\",\"type\":\"event\"}]","ContractName":"EthVaultImpl","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000857c6880f5457a251af1c6f0d7f61740e43bf436","EVMVersion":"Default","Library":"LibCallBridgeReceiver:396d419db676be4e3213e918c022889c3c4280f1;LibTokenManager:8ee9f5b51032058ad0e0940d07628190eca44f6d","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://a965e917565727056c2aa837f5ef8afd960103c8703d9f8d2682a77de793f0e2"}]}