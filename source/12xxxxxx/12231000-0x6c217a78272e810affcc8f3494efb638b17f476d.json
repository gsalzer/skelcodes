{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/WalletFactory.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"../wallet/Proxy.sol\\\";\\nimport \\\"../wallet/BaseWallet.sol\\\";\\nimport \\\"./base/Managed.sol\\\";\\nimport \\\"./storage/IGuardianStorage.sol\\\";\\nimport \\\"../modules/common/Utils.sol\\\";\\n\\n/**\\n * @title WalletFactory\\n * @notice The WalletFactory contract creates and assigns wallets to accounts.\\n * @author Julien Niset, Olivier VDB - <julien@argent.xyz>, <olivier@argent.xyz>\\n */\\ncontract WalletFactory is Managed {\\n\\n    address constant internal ETH_TOKEN = address(0);\\n\\n    // The address of the base wallet implementation\\n    address immutable public walletImplementation;\\n    // The address of the GuardianStorage\\n    address immutable public guardianStorage;\\n    // The recipient of the refund\\n    address public refundAddress; \\n\\n    // *************** Events *************************** //\\n\\n    event RefundAddressChanged(address addr);\\n    event WalletCreated(address indexed wallet, address indexed owner, address indexed guardian, address refundToken, uint256 refundAmount);\\n\\n    // *************** Constructor ********************** //\\n\\n    /**\\n     * @notice Default constructor.\\n     */\\n    constructor(address _walletImplementation, address _guardianStorage, address _refundAddress) {\\n        require(_walletImplementation != address(0), \\\"WF: empty wallet implementation\\\");\\n        require(_guardianStorage != address(0), \\\"WF: empty guardian storage\\\");\\n        require(_refundAddress != address(0), \\\"WF: empty refund address\\\");\\n        walletImplementation = _walletImplementation;\\n        guardianStorage = _guardianStorage;\\n        refundAddress = _refundAddress;\\n    }\\n\\n    // *************** External Functions ********************* //\\n\\n    /**\\n    * @notice Disables the ability for the owner of the factory to revoke a manager.\\n    */\\n    function revokeManager(address /*_manager*/) override external pure {\\n        revert(\\\"WF: managers can't be revoked\\\");\\n    }\\n     \\n    /**\\n     * @notice Creates a wallet for an owner account at a specific address.\\n     * The wallet is initialised with the target modules and a first guardian by default.\\n     * The wallet is created using the CREATE2 opcode and must have been approved \\n     * by a manager of the factory.\\n     * @param _owner The account address.\\n     * @param _modules The list of modules for the wallet.\\n     * @param _guardian The guardian address.\\n     * @param _salt The salt.\\n     * @param _refundAmount The amount to refund to the relayer.\\n     * @param _refundToken The token to use to refund the relayer.\\n     * @param _ownerSignature The owner signature on the refund info.\\n     * @param _managerSignature The manager signature on the wallet address.\\n     */\\n    function createCounterfactualWallet(\\n        address _owner,\\n        address[] calldata _modules,\\n        address _guardian,\\n        bytes20 _salt,\\n        uint256 _refundAmount,\\n        address _refundToken,\\n        bytes calldata _ownerSignature,\\n        bytes calldata _managerSignature\\n    )\\n        external\\n        returns (address _wallet)\\n    {\\n        validateInputs(_owner, _modules, _guardian);\\n        bytes32 newsalt = newSalt(_salt, _owner, _modules, _guardian);\\n        address payable wallet = payable(new Proxy{salt: newsalt}(walletImplementation));\\n        validateAuthorisedCreation(wallet, _managerSignature);\\n        configureWallet(BaseWallet(wallet), _owner, _modules, _guardian);\\n        if (_refundAmount > 0 && _ownerSignature.length == 65) {\\n            validateAndRefund(wallet, _owner, _refundAmount, _refundToken, _ownerSignature);\\n        }\\n        // remove the factory from the authorised modules\\n        BaseWallet(wallet).authoriseModule(address(this), false);\\n\\n        // emit event\\n        emit WalletCreated(wallet, _owner, _guardian, _refundToken, _refundAmount);\\n\\n        return wallet;\\n    }\\n\\n    /**\\n     * @notice Gets the address of a counterfactual wallet with a first default guardian.\\n     * @param _owner The account address.\\n     * @param _modules The list of modules for wallet.\\n     * @param _guardian The guardian address.\\n     * @param _salt The salt.\\n     * @return _wallet The address that the wallet will have when created using CREATE2 and the same input parameters.\\n     */\\n    function getAddressForCounterfactualWallet(\\n        address _owner,\\n        address[] calldata _modules,\\n        address _guardian,\\n        bytes20 _salt\\n    )\\n        external\\n        view\\n        returns (address _wallet)\\n    {\\n        validateInputs(_owner, _modules, _guardian);\\n        bytes32 newsalt = newSalt(_salt, _owner, _modules, _guardian);\\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(uint160(walletImplementation)));\\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\\n        _wallet = address(uint160(uint256(hash)));\\n    }\\n\\n    /**\\n     * @notice Lets the owner of the factory change the refund address.\\n     * @param _refundAddress The address to use for refunds.\\n     */\\n    function changeRefundAddress(address _refundAddress) external onlyOwner {\\n        require(_refundAddress != address(0), \\\"WF: cannot set to empty\\\");\\n        refundAddress = _refundAddress;\\n        emit RefundAddressChanged(_refundAddress);\\n    }\\n\\n    /**\\n     * @notice Required to make the factory a module during the \\n     * initialisation of the wallet. \\n     * @param _wallet The wallet.\\n     */\\n    function init(BaseWallet _wallet) external pure {\\n        //do nothing\\n    }\\n\\n    // *************** Internal Functions ********************* //\\n\\n    /**\\n     * @notice Helper method to configure a wallet for a set of input parameters.\\n     * @param _wallet The target wallet\\n     * @param _owner The owner address.\\n     * @param _modules The list of modules.\\n     * @param _guardian The guardian.\\n     */\\n    function configureWallet(BaseWallet _wallet, address _owner, address[] calldata _modules, address _guardian) internal {\\n        // add the factory to modules so it can add the first guardian and trigger the refund\\n        address[] memory extendedModules = new address[](_modules.length + 1);\\n        extendedModules[0] = address(this);\\n        for (uint i = 0; i < _modules.length; i++) {\\n            extendedModules[i + 1] = _modules[i];\\n        }\\n\\n        // initialise the wallet with the owner and the extended modules\\n        _wallet.init(_owner, extendedModules);\\n\\n        // add the first guardian\\n        IGuardianStorage(guardianStorage).addGuardian(address(_wallet), _guardian);\\n    }\\n\\n    /**\\n     * @notice Generates a new salt based on a provided salt, an owner, a list of modules and an optional guardian.\\n     * The extra parameters are pre-hashed to be compatible with zk-sync CREATE2 API (!! the order of the parameters \\n     * assumes https://github.com/matter-labs/zksync/pull/259 has been merged !!).\\n     * @param _salt The salt provided. In practice the hash of the L2 public key.\\n     * @param _owner The owner address.\\n     * @param _modules The list of modules for wallet.\\n     * @param _guardian The guardian address.\\n     */\\n    function newSalt(bytes20 _salt, address _owner, address[] calldata _modules, address _guardian) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(keccak256(abi.encodePacked(_owner, _modules, _guardian)), _salt));\\n    }\\n\\n    /**\\n     * @notice Throws if the owner, guardian, or module array is invalid.\\n     * @param _owner The owner address.\\n     * @param _modules The list of modules for the wallet.\\n     * @param _guardian The guardian address.\\n     */\\n    function validateInputs(address _owner, address[] calldata _modules, address _guardian) internal pure {\\n        require(_owner != address(0), \\\"WF: empty owner address\\\");\\n        require(_owner != _guardian, \\\"WF: owner cannot be guardian\\\");\\n        require(_modules.length > 0, \\\"WF: empty modules\\\");\\n        require(_guardian != (address(0)), \\\"WF: empty guardian\\\");        \\n    }\\n\\n    /**\\n     * @notice Throws if the sender is not a manager and the manager's signature for the\\n     * creation of the new wallet is invalid.\\n     * @param _wallet The wallet address\\n     * @param _managerSignature The manager's signature\\n     */\\n    function validateAuthorisedCreation(address _wallet, bytes memory _managerSignature) internal view {\\n        address manager;\\n        if(_managerSignature.length != 65) {\\n            manager = msg.sender;\\n        } else {\\n            bytes32 signedHash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", bytes32(uint256(uint160(_wallet)))));\\n            manager = Utils.recoverSigner(signedHash, _managerSignature, 0);\\n        }\\n        require(managers[manager], \\\"WF: unauthorised wallet creation\\\");\\n    }\\n\\n    /**\\n     * @notice Refunds the creation of the wallet when provided with a valid signature from the wallet owner.\\n     * @param _wallet The wallet created\\n     * @param _owner The owner address\\n     * @param _refundAmount The amount to refund\\n     * @param _refundToken The token to use for the refund\\n     * @param _ownerSignature A signature from the wallet owner approving the refund amount and token. \\n     */\\n    function validateAndRefund(\\n        address _wallet,\\n        address _owner,\\n        uint256 _refundAmount,\\n        address _refundToken,\\n        bytes memory _ownerSignature\\n    )\\n        internal\\n    {\\n        bytes32 signedHash = keccak256(abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(abi.encodePacked(_wallet, _refundAmount, _refundToken))\\n            ));\\n        address signer = Utils.recoverSigner(signedHash, _ownerSignature, 0);\\n        if (signer == _owner) {\\n            if (_refundToken == ETH_TOKEN) {\\n                invokeWallet(_wallet, refundAddress, _refundAmount, \\\"\\\");\\n            } else {\\n                bytes memory methodData = abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", refundAddress, _refundAmount);\\n                bytes memory transferSuccessBytes = invokeWallet(_wallet, _refundToken, 0, methodData);\\n                if (transferSuccessBytes.length > 0) {\\n                    require(abi.decode(transferSuccessBytes, (bool)), \\\"WF: Refund transfer failed\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Invoke the wallet to execute the refund transfer.\\n     * @param _wallet The wallet\\n     * @param _to The destination of the call\\n     * @param _value The value of the call\\n     * @param _data The data associated to the call\\n     */\\n    function invokeWallet(\\n        address _wallet,\\n        address _to,\\n        uint256 _value,\\n        bytes memory _data\\n    )\\n        internal\\n        returns (bytes memory _res)\\n    {\\n        bool success;\\n        (success, _res) = _wallet.call(abi.encodeWithSignature(\\\"invoke(address,uint256,bytes)\\\", _to, _value, _data));\\n        if (success) {\\n            (_res) = abi.decode(_res, (bytes));\\n        } else {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/base/Managed.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"./Owned.sol\\\";\\n\\n/**\\n * @title Managed\\n * @notice Basic contract that defines a set of managers. Only the owner can add/remove managers.\\n * @author Julien Niset, Olivier VDB - <julien@argent.xyz>, <olivier@argent.xyz>\\n */\\ncontract Managed is Owned {\\n\\n    // The managers\\n    mapping (address => bool) public managers;\\n\\n    /**\\n     * @notice Throws if the sender is not a manager.\\n     */\\n    modifier onlyManager {\\n        require(managers[msg.sender] == true, \\\"M: Must be manager\\\");\\n        _;\\n    }\\n\\n    event ManagerAdded(address indexed _manager);\\n    event ManagerRevoked(address indexed _manager);\\n\\n    /**\\n    * @notice Adds a manager.\\n    * @param _manager The address of the manager.\\n    */\\n    function addManager(address _manager) external onlyOwner {\\n        require(_manager != address(0), \\\"M: Address must not be null\\\");\\n        if (managers[_manager] == false) {\\n            managers[_manager] = true;\\n            emit ManagerAdded(_manager);\\n        }\\n    }\\n\\n    /**\\n    * @notice Revokes a manager.\\n    * @param _manager The address of the manager.\\n    */\\n    function revokeManager(address _manager) external virtual onlyOwner {\\n        // solhint-disable-next-line reason-string\\n        require(managers[_manager] == true, \\\"M: Target must be an existing manager\\\");\\n        delete managers[_manager];\\n        emit ManagerRevoked(_manager);\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/base/Owned.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.5.4 <0.9.0;\\n\\n/**\\n * @title Owned\\n * @notice Basic contract to define an owner.\\n * @author Julien Niset - <julien@argent.xyz>\\n */\\ncontract Owned {\\n\\n    // The owner\\n    address public owner;\\n\\n    event OwnerChanged(address indexed _newOwner);\\n\\n    /**\\n     * @notice Throws if the sender is not the owner.\\n     */\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Must be owner\\\");\\n        _;\\n    }\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Lets the owner transfer ownership of the contract to a new owner.\\n     * @param _newOwner The new owner.\\n     */\\n    function changeOwner(address _newOwner) external onlyOwner {\\n        require(_newOwner != address(0), \\\"Address must not be null\\\");\\n        owner = _newOwner;\\n        emit OwnerChanged(_newOwner);\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/IGuardianStorage.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.5.4 <0.9.0;\\n\\ninterface IGuardianStorage {\\n\\n    /**\\n     * @notice Lets an authorised module add a guardian to a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian to add.\\n     */\\n    function addGuardian(address _wallet, address _guardian) external;\\n\\n    /**\\n     * @notice Lets an authorised module revoke a guardian from a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The guardian to revoke.\\n     */\\n    function revokeGuardian(address _wallet, address _guardian) external;\\n\\n    /**\\n     * @notice Checks if an account is a guardian for a wallet.\\n     * @param _wallet The target wallet.\\n     * @param _guardian The account.\\n     * @return true if the account is a guardian for a wallet.\\n     */\\n    function isGuardian(address _wallet, address _guardian) external view returns (bool);\\n\\n    function isLocked(address _wallet) external view returns (bool);\\n\\n    function getLock(address _wallet) external view returns (uint256);\\n\\n    function getLocker(address _wallet) external view returns (address);\\n\\n    function setLock(address _wallet, uint256 _releaseAfter) external;\\n\\n    function getGuardians(address _wallet) external view returns (address[] memory);\\n\\n    function guardianCount(address _wallet) external view returns (uint256);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/common/IModule.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\n/**\\n * @title IModule\\n * @notice Interface for a Module.\\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\\n */\\ninterface IModule {\\n\\n    /**\\t\\n     * @notice Adds a module to a wallet. Cannot execute when wallet is locked (or under recovery)\\t\\n     * @param _wallet The target wallet.\\t\\n     * @param _module The modules to authorise.\\t\\n     */\\t\\n    function addModule(address _wallet, address _module) external;\\n\\n    /**\\n     * @notice Inits a Module for a wallet by e.g. setting some wallet specific parameters in storage.\\n     * @param _wallet The wallet.\\n     */\\n    function init(address _wallet) external;\\n\\n\\n    /**\\n     * @notice Returns whether the module implements a callback for a given static call method.\\n     * @param _methodId The method id.\\n     */\\n    function supportsStaticCall(bytes4 _methodId) external view returns (bool _isSupported);\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/modules/common/Utils.sol\": {\r\n      \"content\": \"// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\n/**\\n * @title Utils\\n * @notice Common utility methods used by modules.\\n */\\nlibrary Utils {\\n\\n    // ERC20, ERC721 & ERC1155 transfers & approvals\\n    bytes4 private constant ERC20_TRANSFER = bytes4(keccak256(\\\"transfer(address,uint256)\\\"));\\n    bytes4 private constant ERC20_APPROVE = bytes4(keccak256(\\\"approve(address,uint256)\\\"));\\n    bytes4 private constant ERC721_SET_APPROVAL_FOR_ALL = bytes4(keccak256(\\\"setApprovalForAll(address,bool)\\\"));\\n    bytes4 private constant ERC721_TRANSFER_FROM = bytes4(keccak256(\\\"transferFrom(address,address,uint256)\\\"));\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256)\\\"));\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM_BYTES = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,bytes)\\\"));\\n    bytes4 private constant ERC1155_SAFE_TRANSFER_FROM = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"));\\n\\n    bytes4 private constant OWNER_SIG = 0x8da5cb5b;\\n    /**\\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\\n    * @param _signedHash The signed hash\\n    * @param _signatures The concatenated signatures.\\n    * @param _index The index of the signature to recover.\\n    */\\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\\n        }\\n        require(v == 27 || v == 28, \\\"Utils: bad v value in signature\\\");\\n\\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\\n        require(recoveredAddress != address(0), \\\"Utils: ecrecover returned 0\\\");\\n        return recoveredAddress;\\n    }\\n\\n    /**\\n    * @notice Helper method to recover the spender from a contract call. \\n    * The method returns the contract unless the call is to a standard method of a ERC20/ERC721/ERC1155 token\\n    * in which case the spender is recovered from the data.\\n    * @param _to The target contract.\\n    * @param _data The data payload.\\n    */\\n    function recoverSpender(address _to, bytes memory _data) internal pure returns (address spender) {\\n        if(_data.length >= 68) {\\n            bytes4 methodId;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                methodId := mload(add(_data, 0x20))\\n            }\\n            if(\\n                methodId == ERC20_TRANSFER ||\\n                methodId == ERC20_APPROVE ||\\n                methodId == ERC721_SET_APPROVAL_FOR_ALL) \\n            {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    spender := mload(add(_data, 0x24))\\n                }\\n                return spender;\\n            }\\n            if(\\n                methodId == ERC721_TRANSFER_FROM ||\\n                methodId == ERC721_SAFE_TRANSFER_FROM ||\\n                methodId == ERC721_SAFE_TRANSFER_FROM_BYTES ||\\n                methodId == ERC1155_SAFE_TRANSFER_FROM)\\n            {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    spender := mload(add(_data, 0x44))\\n                }\\n                return spender;\\n            }\\n        }\\n\\n        spender = _to;\\n    }\\n\\n    /**\\n    * @notice Helper method to parse data and extract the method signature.\\n    */\\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\\n        require(_data.length >= 4, \\\"Utils: Invalid functionPrefix\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            prefix := mload(add(_data, 0x20))\\n        }\\n    }\\n\\n    /**\\n    * @notice Checks if an address is a contract.\\n    * @param _addr The address.\\n    */\\n    function isContract(address _addr) internal view returns (bool) {\\n        uint32 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n\\n    /**\\n    * @notice Checks if an address is a guardian or an account authorised to sign on behalf of a smart-contract guardian\\n    * given a list of guardians.\\n    * @param _guardians the list of guardians\\n    * @param _guardian the address to test\\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\\n    */\\n    function isGuardianOrGuardianSigner(address[] memory _guardians, address _guardian) internal view returns (bool, address[] memory) {\\n        if (_guardians.length == 0 || _guardian == address(0)) {\\n            return (false, _guardians);\\n        }\\n        bool isFound = false;\\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < _guardians.length; i++) {\\n            if (!isFound) {\\n                // check if _guardian is an account guardian\\n                if (_guardian == _guardians[i]) {\\n                    isFound = true;\\n                    continue;\\n                }\\n                // check if _guardian is the owner of a smart contract guardian\\n                if (isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\\n                    isFound = true;\\n                    continue;\\n                }\\n            }\\n            if (index < updatedGuardians.length) {\\n                updatedGuardians[index] = _guardians[i];\\n                index++;\\n            }\\n        }\\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\\n    }\\n\\n    /**\\n    * @notice Checks if an address is the owner of a guardian contract.\\n    * The method does not revert if the call to the owner() method consumes more then 25000 gas.\\n    * @param _guardian The guardian contract\\n    * @param _owner The owner to verify.\\n    */\\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\\n        address owner = address(0);\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr,OWNER_SIG)\\n            let result := staticcall(25000, _guardian, ptr, 0x20, ptr, 0x20)\\n            if eq(result, 1) {\\n                owner := mload(ptr)\\n            }\\n        }\\n        return owner == _owner;\\n    }\\n\\n    /**\\n    * @notice Returns ceil(a / b).\\n    */\\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a / b;\\n        if (a % b == 0) {\\n            return c;\\n        } else {\\n            return c + 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/wallet/BaseWallet.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\nimport \\\"../modules/common/IModule.sol\\\";\\nimport \\\"./IWallet.sol\\\";\\n\\n/**\\n * @title BaseWallet\\n * @notice Simple modular wallet that authorises modules to call its invoke() method.\\n * @author Julien Niset - <julien@argent.xyz>\\n */\\ncontract BaseWallet is IWallet {\\n\\n    // The owner\\n    address public override owner;\\n    // The authorised modules\\n    mapping (address => bool) public override authorised;\\n    // module executing static calls\\n    address public staticCallExecutor;\\n    // The number of modules\\n    uint public override modules;\\n\\n    event AuthorisedModule(address indexed module, bool value);\\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\\n    event Received(uint indexed value, address indexed sender, bytes data);\\n    event OwnerChanged(address owner);\\n\\n    /**\\n     * @notice Throws if the sender is not an authorised module.\\n     */\\n    modifier moduleOnly {\\n        require(authorised[msg.sender], \\\"BW: sender not authorized\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Inits the wallet by setting the owner and authorising a list of modules.\\n     * @param _owner The owner.\\n     * @param _modules The modules to authorise.\\n     */\\n    function init(address _owner, address[] calldata _modules) external {\\n        require(owner == address(0) && modules == 0, \\\"BW: wallet already initialised\\\");\\n        require(_modules.length > 0, \\\"BW: empty modules\\\");\\n        owner = _owner;\\n        modules = _modules.length;\\n        for (uint256 i = 0; i < _modules.length; i++) {\\n            require(authorised[_modules[i]] == false, \\\"BW: module is already added\\\");\\n            authorised[_modules[i]] = true;\\n            IModule(_modules[i]).init(address(this));\\n            emit AuthorisedModule(_modules[i], true);\\n        }\\n        if (address(this).balance > 0) {\\n            emit Received(address(this).balance, address(0), \\\"\\\");\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IWallet\\n     */\\n    function authoriseModule(address _module, bool _value) external override moduleOnly {\\n        if (authorised[_module] != _value) {\\n            emit AuthorisedModule(_module, _value);\\n            if (_value == true) {\\n                modules += 1;\\n                authorised[_module] = true;\\n                IModule(_module).init(address(this));\\n            } else {\\n                modules -= 1;\\n                require(modules > 0, \\\"BW: cannot remove last module\\\");\\n                delete authorised[_module];\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @inheritdoc IWallet\\n    */\\n    function enabled(bytes4 _sig) public view override returns (address) {\\n        address executor = staticCallExecutor;\\n        if(executor != address(0) && IModule(executor).supportsStaticCall(_sig)) {\\n            return executor;\\n        }\\n        return address(0);\\n    }\\n\\n    /**\\n    * @inheritdoc IWallet\\n    */\\n    function enableStaticCall(address _module, bytes4 /* _method */) external override moduleOnly {\\n        if(staticCallExecutor != _module) {\\n            require(authorised[_module], \\\"BW: unauthorized executor\\\");\\n            staticCallExecutor = _module;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IWallet\\n     */\\n    function setOwner(address _newOwner) external override moduleOnly {\\n        require(_newOwner != address(0), \\\"BW: address cannot be null\\\");\\n        owner = _newOwner;\\n        emit OwnerChanged(_newOwner);\\n    }\\n\\n    /**\\n     * @notice Performs a generic transaction.\\n     * @param _target The address for the transaction.\\n     * @param _value The value of the transaction.\\n     * @param _data The data of the transaction.\\n     */\\n    function invoke(address _target, uint _value, bytes calldata _data) external moduleOnly returns (bytes memory _result) {\\n        bool success;\\n        (success, _result) = _target.call{value: _value}(_data);\\n        if (!success) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n        emit Invoked(msg.sender, _target, _value, _data);\\n    }\\n\\n    /**\\n     * @notice This method delegates the static call to a target contract if the data corresponds\\n     * to an enabled module, or logs the call otherwise.\\n     */\\n    fallback() external payable {\\n        address module = enabled(msg.sig);\\n        if (module == address(0)) {\\n            emit Received(msg.value, msg.sender, msg.data);\\n        } else {\\n            require(authorised[module], \\\"BW: unauthorised module\\\");\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                calldatacopy(0, 0, calldatasize())\\n                let result := staticcall(gas(), module, 0, calldatasize(), 0, 0)\\n                returndatacopy(0, 0, returndatasize())\\n                switch result\\n                case 0 {revert(0, returndatasize())}\\n                default {return (0, returndatasize())}\\n            }\\n        }\\n    }\\n\\n    receive() external payable {\\n    }\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/wallet/IWallet.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.5.4 <0.9.0;\\n\\n/**\\n * @title IWallet\\n * @notice Interface for the BaseWallet\\n */\\ninterface IWallet {\\n    /**\\n     * @notice Returns the wallet owner.\\n     * @return The wallet owner address.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the number of authorised modules.\\n     * @return The number of authorised modules.\\n     */\\n    function modules() external view returns (uint);\\n\\n    /**\\n     * @notice Sets a new owner for the wallet.\\n     * @param _newOwner The new owner.\\n     */\\n    function setOwner(address _newOwner) external;\\n\\n    /**\\n     * @notice Checks if a module is authorised on the wallet.\\n     * @param _module The module address to check.\\n     * @return `true` if the module is authorised, otherwise `false`.\\n     */\\n    function authorised(address _module) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the module responsible for a static call redirection.\\n     * @param _sig The signature of the static call.\\n     * @return the module doing the redirection\\n     */\\n    function enabled(bytes4 _sig) external view returns (address);\\n\\n    /**\\n     * @notice Enables/Disables a module.\\n     * @param _module The target module.\\n     * @param _value Set to `true` to authorise the module.\\n     */\\n    function authoriseModule(address _module, bool _value) external;\\n\\n    /**\\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\\n    * @param _module The target module.\\n    * @param _method The static method signature.\\n    */\\n    function enableStaticCall(address _module, bytes4 _method) external;\\n}\"\r\n    },\r\n    \"/Users/Elena/Source/argent-contracts/contracts/wallet/Proxy.sol\": {\r\n      \"content\": \"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.3;\\n\\n/**\\n * @title Proxy\\n * @notice Basic proxy that delegates all calls to a fixed implementing contract.\\n * The implementing contract cannot be upgraded.\\n * @author Julien Niset - <julien@argent.xyz>\\n */\\ncontract Proxy {\\n\\n    address immutable public implementation;\\n\\n    event Received(uint indexed value, address indexed sender, bytes data);\\n\\n    constructor(address _implementation) {\\n        implementation = _implementation;\\n    }\\n\\n    fallback() external payable {\\n        address target = implementation;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 {revert(0, returndatasize())}\\n            default {return (0, returndatasize())}\\n        }\\n    }\\n\\n    receive() external payable {\\n        emit Received(msg.value, msg.sender, \\\"\\\");\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_walletImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardianStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_refundAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"ManagerRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"RefundAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"}],\"name\":\"WalletCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_refundAddress\",\"type\":\"address\"}],\"name\":\"changeRefundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"},{\"internalType\":\"bytes20\",\"name\":\"_salt\",\"type\":\"bytes20\"},{\"internalType\":\"uint256\",\"name\":\"_refundAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_refundToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_ownerSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_managerSignature\",\"type\":\"bytes\"}],\"name\":\"createCounterfactualWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"},{\"internalType\":\"bytes20\",\"name\":\"_salt\",\"type\":\"bytes20\"}],\"name\":\"getAddressForCounterfactualWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardianStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BaseWallet\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"revokeManager\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WalletFactory","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"000000000000000000000000ad45d7e5ac29f888d0a7f007bbb73210ebc153b20000000000000000000000004cac0996ede3125a72be96942d299b1b26e5381b000000000000000000000000482579f93dc13e6b434e38b5a0447ca543d88a46","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}