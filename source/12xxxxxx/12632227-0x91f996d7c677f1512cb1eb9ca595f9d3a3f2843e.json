{"status":"1","message":"OK","result":[{"SourceCode":"{\"tmp3.sol\":{\"content\":\"// SPDX-License-Identifier: PRIVATE\\npragma solidity \\u003e=0.7.0 \\u003c 0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./tmp4.sol\\\";\\n\\nstruct InvestInfo {\\n  address Addr;\\n  uint256 ID;\\n\\n  uint256 restCRFI;\\n  uint256 perTimeCRFI;\\n  \\n  uint256 nextTime;\\n  uint256 duration;\\n  uint256 totalNums;\\n}\\n\\ncontract Distribution is  ReentrancyGuard {\\n  //////////////////// for using\\n  using SafeMath for uint256;\\n\\n  //////////////////// constant\\n\\n  ////////////////////\\n  IERC20 CRFI;\\n\\n  //////////////////// invest\\n  // invest\\n  uint256 public NewInvestID;\\n  mapping(uint256 =\\u003e InvestInfo) Invests;\\n  mapping(address =\\u003e uint256) public InvestAddrID;\\n\\n\\n  //////////////////// modifier\\n  constructor(address crfiAddr){\\n    CRFI = IERC20(crfiAddr);\\n    NewInvestID = 1;\\n  }\\n  \\n  //////////////////// public\\n  function Charge(address to,\\n                  uint256 totalCRFI,\\n                  uint256 nextTime,\\n                  uint256 duration,\\n                  uint256 totalNums)\\n    public\\n    nonReentrant(){\\n\\n    uint256 uID = getUID(to);\\n    InvestInfo storage uInfo = Invests[uID];\\n    \\n    withdraw(uInfo);\\n    require(uInfo.restCRFI == 0, \\\"have rest crfi\\\");\\n\\n    require(to != address(0x0), \\\"user must not zero addr\\\");\\n    require(totalCRFI \\u003e 0, \\\"totalCRFI must \\u003e 0\\\");\\n    require(duration \\u003e 0, \\\"duration must \\u003e 0\\\");\\n    require(totalNums \\u003e 0, \\\"totalNums must \\u003e 0\\\");\\n    require(totalCRFI \\u003e totalNums, \\\"totalCRFI must \\u003e totalNums\\\");\\n\\n    CRFI.transferFrom(msg.sender, address(this), totalCRFI);\\n\\n    uInfo.restCRFI = totalCRFI;\\n    uInfo.perTimeCRFI = totalCRFI / totalNums;\\n    uInfo.nextTime = nextTime;\\n    uInfo.duration = duration;\\n    uInfo.totalNums = totalNums;\\n  }\\n\\n  function Withdraw(address addr)\\n    public\\n    nonReentrant(){\\n    if(addr == address(0x0)){\\n      addr = msg.sender;\\n    }\\n    \\n    uint256 uID = getUID(addr);\\n    InvestInfo storage uInfo = Invests[uID];\\n    \\n    withdraw(uInfo);\\n  }\\n    \\n\\n  //////////////////// view\\n  function GetInvestInfo(address addr)\\n    public\\n    view\\n    returns(uint256 restCRFI,\\n            uint256 perTimeCRFI,\\n            uint256 nextTime,\\n            uint256 duration,\\n            uint256 totalNums,\\n            uint256 avaiCRFI){\\n    \\n    uint256 uID = InvestAddrID[addr];\\n    if(uID == 0){\\n      return(restCRFI,\\n             perTimeCRFI,\\n             nextTime,\\n             duration,\\n             totalNums,\\n             avaiCRFI);\\n    }\\n    \\n    InvestInfo storage uInfo = Invests[uID];\\n    (avaiCRFI, nextTime, totalNums) = calcNowAvaiCRFI(uInfo);\\n\\n    restCRFI = uInfo.restCRFI.sub(avaiCRFI);\\n    return(restCRFI,\\n           uInfo.perTimeCRFI,\\n           nextTime,\\n           uInfo.duration,\\n           totalNums,\\n           avaiCRFI);\\n  }\\n\\n  //////////////////// internal\\n\\n  function withdraw(InvestInfo storage uInfo)\\n    internal{\\n    (uint256 avaiCRFI, uint256 nextTime, uint256 totalNums) = calcNowAvaiCRFI(uInfo);\\n    if(avaiCRFI == 0){\\n      return;\\n    }\\n\\n    uInfo.restCRFI = uInfo.restCRFI.sub(avaiCRFI);\\n    uInfo.nextTime = nextTime;\\n    uInfo.totalNums = totalNums;\\n\\n    CRFI.transfer(uInfo.Addr, avaiCRFI);\\n  }\\n    \\n  function calcNowAvaiCRFI(InvestInfo storage uInfo)\\n    internal\\n    view\\n    returns(uint256 avaiCRFI, uint256 nextTime, uint256 totalNums){\\n    if(block.timestamp \\u003c uInfo.nextTime || uInfo.restCRFI == 0 || uInfo.totalNums == 0){\\n      return (0, uInfo.nextTime, uInfo.totalNums);\\n    }\\n\\n    uint256 times = block.timestamp.sub(uInfo.nextTime) / uInfo.duration;\\n    times++;\\n    if(times \\u003e uInfo.totalNums){\\n      times = uInfo.totalNums;\\n    }\\n\\n    avaiCRFI = times.mul(uInfo.perTimeCRFI);\\n    nextTime = uInfo.nextTime.add(uInfo.duration.mul(times));\\n    \\n    totalNums = uInfo.totalNums.sub(times);\\n    if(totalNums == 0){\\n      avaiCRFI = uInfo.restCRFI;\\n    }\\n\\n    return(avaiCRFI, nextTime, totalNums);\\n  }\\n\\n  function getUID(address addr) internal returns(uint256 uID){\\n    uID = InvestAddrID[addr];\\n    if(uID != 0){\\n      return uID;\\n    }\\n\\n    uID = NewInvestID;\\n    NewInvestID++;\\n\\n    InvestInfo storage uInfo = Invests[uID];\\n    uInfo.Addr = addr;\\n    uInfo.ID = uID;\\n        \\n    InvestAddrID[addr] = uID;\\n    return uID;\\n  }\\n\\n}\\n\"},\"tmp4.sol\":{\"content\":\"// SPDX-License-Identifier: PRIVATE\\npragma solidity \\u003e=0.6.0 \\u003c 0.8.0;\\n\\n// import \\\"github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/IERC20.sol\\\";\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c \\u003c a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b \\u003e a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crfiAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalNums\",\"type\":\"uint256\"}],\"name\":\"Charge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"GetInvestInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"restCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perTimeCRFI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalNums\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avaiCRFI\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"InvestAddrID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NewInvestID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Distribution","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008848812bd31aeee33313c10a840ffc3169078c5b","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c5f79d89b206ca142550a12ed0c87df3b5cb6a1996a03881835b6f05d36c217c"}]}