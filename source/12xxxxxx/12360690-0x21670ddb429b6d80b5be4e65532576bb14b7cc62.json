{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.2;\r\npragma experimental ABIEncoderV2;\r\n\r\n/*******************************************************\r\n *                     Ownable\r\n *******************************************************/\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\n\r\n/*******************************************************\r\n *                       Interfaces\r\n *******************************************************/\r\ninterface ICyToken {\r\n    function underlying() external view returns (address);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function supplyRatePerBlock() external view returns (uint256);\r\n\r\n    function borrowRatePerBlock() external view returns (uint256);\r\n\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n    function reserveFactorMantissa() external view returns (uint256);\r\n\r\n    function getCash() external view returns (uint256);\r\n\r\n    function totalBorrows() external view returns (uint256);\r\n\r\n    function borrowBalanceStored(address accountAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function totalReserves() external view returns (uint256);\r\n\r\n    function balanceOf(address accountAddress) external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IUnitroller {\r\n    struct Market {\r\n        bool isListed;\r\n        uint256 collateralFactorMantissa;\r\n    }\r\n\r\n    function oracle() external view returns (address);\r\n\r\n    function getAssetsIn(address accountAddress)\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    function markets(address marketAddress)\r\n        external\r\n        view\r\n        returns (Market memory);\r\n}\r\n\r\ninterface IAddressesGenerator {\r\n    function assetsAddresses() external view returns (address[] memory);\r\n\r\n    function assetsLength() external view returns (uint256);\r\n\r\n    function registry() external view returns (address);\r\n\r\n    function getPositionSpenderAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n}\r\n\r\ninterface IHelper {\r\n    struct Allowance {\r\n        address owner;\r\n        address spender;\r\n        uint256 amount;\r\n        address token;\r\n    }\r\n\r\n    function allowances(\r\n        address ownerAddress,\r\n        address[] memory tokensAddresses,\r\n        address[] memory spenderAddresses\r\n    ) external view returns (Allowance[] memory);\r\n\r\n    function uniqueAddresses(address[] memory input)\r\n        external\r\n        pure\r\n        returns (address[] memory);\r\n}\r\n\r\ninterface ICreamOracle {\r\n    function getUnderlyingPrice(address) external view returns (uint256);\r\n}\r\n\r\ninterface IOracle {\r\n    function getNormalizedValueUsdc(\r\n        address tokenAddress,\r\n        uint256 amount,\r\n        uint256 priceUsdc\r\n    ) external view returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function approve(address spender, uint256 amount) external;\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address spender, address owner)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n/*******************************************************\r\n *                     Adapter Logic\r\n *******************************************************/\r\ncontract RegistryAdapterIronBank is Ownable {\r\n    /*******************************************************\r\n     *           Common code shared by all adapters\r\n     *******************************************************/\r\n    address public comptrollerAddress; // Comptroller address\r\n    address public creamOracleAddress; // Cream oracle address\r\n    address public helperAddress; // Helper utility address\r\n    address public oracleAddress; // Yearn oracle address\r\n    uint256 public blocksPerYear = 2102400;\r\n    address[] private _extensionsAddresses; // Optional contract extensions provide a way to add new features at a later date\r\n    ICreamOracle creamOracle; // Cream oracle\r\n    IUnitroller comptroller; // Comptroller\r\n    IOracle oracle; // Yearn oracle\r\n    IHelper helper; // A helper utility is used for batch allowance fetching and address array merging\r\n    IAddressesGenerator public addressesGenerator; // A utility for fetching assets addresses and length\r\n\r\n    /**\r\n     * High level static information about an asset\r\n     */\r\n    struct AssetStatic {\r\n        address id; // Asset address\r\n        string typeId; // Asset typeId (for example \"VAULT_V2\" or \"IRON_BANK_MARKET\")\r\n        address tokenId; // Underlying token address\r\n        string name; // Asset Name\r\n        string version; // Asset version\r\n        string symbol; // Asset symbol\r\n        uint8 decimals; // Asset decimals\r\n    }\r\n\r\n    /**\r\n     * High level dynamic information about an asset\r\n     */\r\n    struct AssetDynamic {\r\n        address id; // Asset address\r\n        string typeId; // Asset typeId (for example \"VAULT_V2\" or \"IRON_BANK_MARKET\")\r\n        address tokenId; // Underlying token address;\r\n        TokenAmount underlyingTokenBalance; // Underlying token balances\r\n        AssetMetadata metadata; // Metadata specific to the asset type of this adapter\r\n    }\r\n\r\n    /**\r\n     * Information about a user's position relative to an asset\r\n     */\r\n    struct Position {\r\n        address assetId; // Asset address\r\n        address tokenId; // Underlying asset token address\r\n        string typeId; // Position typeId (for example \"DEPOSIT,\" \"BORROW,\" \"LEND\")\r\n        uint256 balance; // asset.balanceOf(account)\r\n        TokenAmount underlyingTokenBalance; // Represents a user's asset position in underlying tokens\r\n        Allowance[] tokenAllowances; // Underlying token allowances\r\n        Allowance[] assetAllowances; // Asset allowances\r\n    }\r\n\r\n    /**\r\n     * Token amount representation\r\n     */\r\n    struct TokenAmount {\r\n        uint256 amount; // Amount in underlying token decimals\r\n        uint256 amountUsdc; // Amount in USDC (6 decimals)\r\n    }\r\n\r\n    /**\r\n     * Allowance information\r\n     */\r\n    struct Allowance {\r\n        address owner; // Allowance owner\r\n        address spender; // Allowance spender\r\n        uint256 amount; // Allowance amount (in underlying token)\r\n    }\r\n\r\n    /**\r\n     * Information about the adapter\r\n     */\r\n    struct AdapterInfo {\r\n        address id; // Adapter address\r\n        string typeId; // Adapter typeId (for example \"VAULT_V2\" or \"IRON_BANK_MARKET\")\r\n        string categoryId; // Adapter categoryId (for example \"VAULT\")\r\n    }\r\n\r\n    /**\r\n     * Fetch static information about an array of assets. This method can be used for off-chain pagination.\r\n     */\r\n    function assetsStatic(address[] memory _assetsAddresses)\r\n        public\r\n        view\r\n        returns (AssetStatic[] memory)\r\n    {\r\n        uint256 numberOfAssets = _assetsAddresses.length;\r\n        AssetStatic[] memory _assets = new AssetStatic[](numberOfAssets);\r\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\r\n            address assetAddress = _assetsAddresses[assetIdx];\r\n            AssetStatic memory _asset = assetStatic(assetAddress);\r\n            _assets[assetIdx] = _asset;\r\n        }\r\n        return _assets;\r\n    }\r\n\r\n    /**\r\n     * Fetch dynamic information about an array of assets. This method can be used for off-chain pagination.\r\n     */\r\n    function assetsDynamic(address[] memory _assetsAddresses)\r\n        public\r\n        view\r\n        returns (AssetDynamic[] memory)\r\n    {\r\n        uint256 numberOfAssets = _assetsAddresses.length;\r\n        AssetDynamic[] memory _assets = new AssetDynamic[](numberOfAssets);\r\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\r\n            address assetAddress = _assetsAddresses[assetIdx];\r\n            AssetDynamic memory _asset = assetDynamic(assetAddress);\r\n            _assets[assetIdx] = _asset;\r\n        }\r\n        return _assets;\r\n    }\r\n\r\n    /**\r\n     * Fetch static information for all assets\r\n     */\r\n    function assetsStatic() external view returns (AssetStatic[] memory) {\r\n        address[] memory _assetsAddresses = assetsAddresses();\r\n        return assetsStatic(_assetsAddresses);\r\n    }\r\n\r\n    /**\r\n     * Fetch dynamic information for all assets\r\n     */\r\n    function assetsDynamic() external view returns (AssetDynamic[] memory) {\r\n        address[] memory _assetsAddresses = assetsAddresses();\r\n        return assetsDynamic(_assetsAddresses);\r\n    }\r\n\r\n    /**\r\n     * Fetch underlying token allowances relative to an asset.\r\n     * This is useful for determining whether or not a user has token approvals\r\n     * to allow depositing into an asset\r\n     */\r\n    function tokenAllowances(address accountAddress, address assetAddress)\r\n        public\r\n        view\r\n        returns (Allowance[] memory)\r\n    {\r\n        address tokenAddress = underlyingTokenAddress(assetAddress);\r\n        address[] memory tokenAddresses = new address[](1);\r\n        address[] memory assetAddresses = new address[](1);\r\n        tokenAddresses[0] = tokenAddress;\r\n        assetAddresses[0] = assetAddress;\r\n        bytes memory allowances =\r\n            abi.encode(\r\n                helper.allowances(\r\n                    accountAddress,\r\n                    tokenAddresses,\r\n                    assetAddresses\r\n                )\r\n            );\r\n        return abi.decode(allowances, (Allowance[]));\r\n    }\r\n\r\n    /**\r\n     * Fetch asset allowances based on positionSpenderAddresses (configurable).\r\n     * This is useful to determine if a particular zap contract is approved for the asset (zap out use case)\r\n     */\r\n    function assetAllowances(address accountAddress, address assetAddress)\r\n        public\r\n        view\r\n        returns (Allowance[] memory)\r\n    {\r\n        address[] memory assetAddresses = new address[](1);\r\n        assetAddresses[0] = assetAddress;\r\n        bytes memory allowances =\r\n            abi.encode(\r\n                helper.allowances(\r\n                    accountAddress,\r\n                    assetAddresses,\r\n                    addressesGenerator.getPositionSpenderAddresses()\r\n                )\r\n            );\r\n        return abi.decode(allowances, (Allowance[]));\r\n    }\r\n\r\n    /**\r\n     * Internal method for constructing a TokenAmount struct given a token balance and address\r\n     */\r\n    function tokenAmount(\r\n        uint256 amount,\r\n        address tokenAddress,\r\n        uint256 tokenPriceUsdc\r\n    ) internal view returns (TokenAmount memory) {\r\n        return\r\n            TokenAmount({\r\n                amount: amount,\r\n                amountUsdc: oracle.getNormalizedValueUsdc(\r\n                    tokenAddress,\r\n                    amount,\r\n                    tokenPriceUsdc\r\n                )\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch the total number of assets for this adapter\r\n     */\r\n    function assetsLength() public view returns (uint256) {\r\n        return addressesGenerator.assetsLength();\r\n    }\r\n\r\n    /**\r\n     * Fetch all asset addresses for this adapter\r\n     */\r\n    function assetsAddresses() public view returns (address[] memory) {\r\n        return addressesGenerator.assetsAddresses();\r\n    }\r\n\r\n    /**\r\n     * Fetch registry address from addresses generator\r\n     */\r\n    function registry() public view returns (address) {\r\n        return addressesGenerator.registry();\r\n    }\r\n\r\n    /**\r\n     * Allow storage slots to be manually updated\r\n     */\r\n    function updateSlot(bytes32 slot, bytes32 value) external onlyOwner {\r\n        assembly {\r\n            sstore(slot, value)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set optional fallback extension addresses\r\n     */\r\n    function setExtensionsAddresses(address[] memory _newExtensionsAddresses)\r\n        external\r\n        onlyOwner\r\n    {\r\n        _extensionsAddresses = _newExtensionsAddresses;\r\n    }\r\n\r\n    /**\r\n     * Fetch fallback extension addresses\r\n     */\r\n    function extensionsAddresses() external view returns (address[] memory) {\r\n        return (_extensionsAddresses);\r\n    }\r\n\r\n    /**\r\n     * Configure adapter\r\n     */\r\n    constructor(\r\n        address _oracleAddress,\r\n        address _helperAddress,\r\n        address _addressesGeneratorAddress\r\n    ) {\r\n        require(_oracleAddress != address(0), \"Missing oracle address\");\r\n        oracleAddress = _oracleAddress;\r\n        helperAddress = _helperAddress;\r\n        addressesGenerator = IAddressesGenerator(_addressesGeneratorAddress);\r\n        address _comptrollerAddress = registry();\r\n        comptrollerAddress = _comptrollerAddress;\r\n        comptroller = IUnitroller(comptrollerAddress);\r\n        creamOracleAddress = comptroller.oracle();\r\n        creamOracle = ICreamOracle(creamOracleAddress);\r\n        oracle = IOracle(_oracleAddress);\r\n        helper = IHelper(_helperAddress);\r\n    }\r\n\r\n    /*******************************************************\r\n     *                     Iron Bank Adapter\r\n     *******************************************************/\r\n    /**\r\n     * Iron Bank Adapter\r\n     */\r\n    function adapterInfo() public view returns (AdapterInfo memory) {\r\n        return\r\n            AdapterInfo({\r\n                id: address(this),\r\n                typeId: \"IRON_BANK_MARKET\",\r\n                categoryId: \"LENDING\"\r\n            });\r\n    }\r\n\r\n    // Position types supported by this adapter\r\n    string constant positionLend = \"LEND\";\r\n    string constant positionBorrow = \"BORROW\";\r\n    string[] public supportedPositions = [positionLend, positionBorrow];\r\n\r\n    /**\r\n     * Metadata specific to this asset type\r\n     */\r\n    struct AssetMetadata {\r\n        uint256 totalSuppliedUsdc;\r\n        uint256 totalBorrowedUsdc;\r\n        uint256 lendApyBips;\r\n        uint256 borrowApyBips;\r\n        uint256 liquidity;\r\n        uint256 liquidityUsdc;\r\n        uint256 collateralFactor;\r\n        bool isActive;\r\n        uint256 reserveFactor;\r\n        uint256 exchangeRate;\r\n    }\r\n\r\n    /**\r\n     * High level adapter metadata scoped to a user\r\n     */\r\n    struct AdapterPosition {\r\n        uint256 supplyBalanceUsdc;\r\n        uint256 borrowBalanceUsdc;\r\n        uint256 borrowLimitUsdc;\r\n        uint256 utilizationRatioBips;\r\n    }\r\n\r\n    /**\r\n     * Metadata specific to an asset type scoped to a user\r\n     */\r\n    struct AssetUserMetadata {\r\n        address assetId;\r\n        bool enteredMarket;\r\n        uint256 supplyBalanceUsdc;\r\n        uint256 borrowBalanceUsdc;\r\n        uint256 borrowLimitUsdc;\r\n    }\r\n\r\n    /**\r\n     * Fetch asset metadata scoped to a user\r\n     */\r\n    function assetUserMetadata(address accountAddress, address assetAddress)\r\n        public\r\n        view\r\n        returns (AssetUserMetadata memory)\r\n    {\r\n        bool enteredMarket;\r\n        address[] memory markets = comptroller.getAssetsIn(accountAddress);\r\n        for (uint256 marketIdx; marketIdx < markets.length; marketIdx++) {\r\n            address marketAddress = markets[marketIdx];\r\n            if (marketAddress == assetAddress) {\r\n                enteredMarket = true;\r\n                break;\r\n            }\r\n        }\r\n        ICyToken asset = ICyToken(assetAddress);\r\n        IUnitroller.Market memory market = comptroller.markets(assetAddress);\r\n        uint256 supplyBalanceShares = asset.balanceOf(accountAddress);\r\n        uint256 supplyBalanceUnderlying =\r\n            (supplyBalanceShares * asset.exchangeRateStored()) / 10**18;\r\n        address tokenAddress = underlyingTokenAddress(assetAddress);\r\n        uint256 tokenPriceUsdc = assetUnderlyingTokenPriceUsdc(assetAddress);\r\n        uint256 supplyBalanceUsdc =\r\n            oracle.getNormalizedValueUsdc(\r\n                tokenAddress,\r\n                supplyBalanceUnderlying,\r\n                tokenPriceUsdc\r\n            );\r\n        uint256 borrowBalanceShares = asset.borrowBalanceStored(accountAddress);\r\n        uint256 borrowBalanceUsdc =\r\n            oracle.getNormalizedValueUsdc(\r\n                tokenAddress,\r\n                borrowBalanceShares,\r\n                tokenPriceUsdc\r\n            );\r\n        uint256 borrowLimitUsdc =\r\n            (supplyBalanceUsdc * market.collateralFactorMantissa) / 10**18;\r\n\r\n        return\r\n            AssetUserMetadata({\r\n                assetId: assetAddress,\r\n                enteredMarket: enteredMarket,\r\n                supplyBalanceUsdc: supplyBalanceUsdc,\r\n                borrowBalanceUsdc: borrowBalanceUsdc,\r\n                borrowLimitUsdc: borrowLimitUsdc\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch asset metadata scoped to a user\r\n     */\r\n    function assetsUserMetadata(address accountAddress)\r\n        public\r\n        view\r\n        returns (AssetUserMetadata[] memory)\r\n    {\r\n        address[] memory _assetsAddresses = assetsAddresses();\r\n        uint256 numberOfAssets = _assetsAddresses.length;\r\n        AssetUserMetadata[] memory _assetsUserMetadata =\r\n            new AssetUserMetadata[](numberOfAssets);\r\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\r\n            address assetAddress = _assetsAddresses[assetIdx];\r\n            _assetsUserMetadata[assetIdx] = assetUserMetadata(\r\n                accountAddress,\r\n                assetAddress\r\n            );\r\n        }\r\n        return _assetsUserMetadata;\r\n    }\r\n\r\n    function underlyingTokenAddress(address assetAddress)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        ICyToken cyToken = ICyToken(assetAddress);\r\n        address tokenAddress = cyToken.underlying();\r\n        return tokenAddress;\r\n    }\r\n\r\n    /**\r\n     * Fetch static information about an asset\r\n     */\r\n    function assetStatic(address assetAddress)\r\n        public\r\n        view\r\n        returns (AssetStatic memory)\r\n    {\r\n        ICyToken asset = ICyToken(assetAddress);\r\n        address tokenAddress = underlyingTokenAddress(assetAddress);\r\n        return\r\n            AssetStatic({\r\n                id: assetAddress,\r\n                typeId: adapterInfo().typeId,\r\n                tokenId: tokenAddress,\r\n                name: asset.name(),\r\n                version: \"2.0.0\",\r\n                symbol: asset.symbol(),\r\n                decimals: asset.decimals()\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch underlying token price given a cyToken address\r\n     */\r\n    function assetUnderlyingTokenPriceUsdc(address assetAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        address _underlyingTokenAddress = underlyingTokenAddress(assetAddress);\r\n        IERC20 underlyingToken = IERC20(_underlyingTokenAddress);\r\n        uint8 underlyingTokenDecimals = underlyingToken.decimals();\r\n        uint256 underlyingTokenPrice =\r\n            creamOracle.getUnderlyingPrice(assetAddress) /\r\n                (10**(36 - underlyingTokenDecimals - 6));\r\n        return underlyingTokenPrice;\r\n    }\r\n\r\n    /**\r\n     * Fetch dynamic information about an asset\r\n     */\r\n    function assetDynamic(address assetAddress)\r\n        public\r\n        view\r\n        returns (AssetDynamic memory)\r\n    {\r\n        ICyToken asset = ICyToken(assetAddress);\r\n        address tokenAddress = underlyingTokenAddress(assetAddress);\r\n        uint256 liquidity = asset.getCash();\r\n        uint256 liquidityUsdc;\r\n        uint256 tokenPriceUsdc = assetUnderlyingTokenPriceUsdc(assetAddress);\r\n        if (liquidity > 0) {\r\n            liquidityUsdc = oracle.getNormalizedValueUsdc(\r\n                tokenAddress,\r\n                liquidity,\r\n                tokenPriceUsdc\r\n            );\r\n        }\r\n        IUnitroller.Market memory market = comptroller.markets(assetAddress);\r\n\r\n        uint256 balance = assetBalance(assetAddress);\r\n        TokenAmount memory underlyingTokenBalance =\r\n            tokenAmount(balance, tokenAddress, tokenPriceUsdc);\r\n\r\n        uint256 totalBorrowed = asset.totalBorrows();\r\n        uint256 totalBorrowedUsdc =\r\n            oracle.getNormalizedValueUsdc(\r\n                tokenAddress,\r\n                totalBorrowed,\r\n                tokenPriceUsdc\r\n            );\r\n\r\n        AssetMetadata memory metadata =\r\n            AssetMetadata({\r\n                totalSuppliedUsdc: underlyingTokenBalance.amountUsdc,\r\n                totalBorrowedUsdc: totalBorrowedUsdc,\r\n                lendApyBips: (asset.supplyRatePerBlock() * blocksPerYear) /\r\n                    10**14,\r\n                borrowApyBips: (asset.borrowRatePerBlock() * blocksPerYear) /\r\n                    10**14,\r\n                liquidity: liquidity,\r\n                liquidityUsdc: liquidityUsdc,\r\n                collateralFactor: market.collateralFactorMantissa,\r\n                isActive: market.isListed,\r\n                reserveFactor: asset.reserveFactorMantissa(),\r\n                exchangeRate: asset.exchangeRateStored()\r\n            });\r\n\r\n        return\r\n            AssetDynamic({\r\n                id: assetAddress,\r\n                typeId: adapterInfo().typeId,\r\n                tokenId: tokenAddress,\r\n                underlyingTokenBalance: underlyingTokenBalance,\r\n                metadata: metadata\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch asset positions of an account given an asset address\r\n     */\r\n    function assetPositionsOf(address accountAddress, address assetAddress)\r\n        public\r\n        view\r\n        returns (Position[] memory)\r\n    {\r\n        ICyToken asset = ICyToken(assetAddress);\r\n        address tokenAddress = underlyingTokenAddress(assetAddress);\r\n        uint256 supplyBalanceShares = asset.balanceOf(accountAddress);\r\n        uint256 borrowBalanceShares = asset.borrowBalanceStored(accountAddress);\r\n\r\n        uint8 currentPositionIdx;\r\n        Position[] memory positions = new Position[](2);\r\n\r\n        uint256 tokenPriceUsdc = assetUnderlyingTokenPriceUsdc(assetAddress);\r\n\r\n        if (supplyBalanceShares > 0) {\r\n            uint256 supplyBalanceUnderlying =\r\n                (supplyBalanceShares * asset.exchangeRateStored()) / 10**18;\r\n            positions[currentPositionIdx] = Position({\r\n                assetId: assetAddress,\r\n                tokenId: tokenAddress,\r\n                typeId: positionLend,\r\n                balance: supplyBalanceShares,\r\n                underlyingTokenBalance: tokenAmount(\r\n                    supplyBalanceUnderlying,\r\n                    tokenAddress,\r\n                    tokenPriceUsdc\r\n                ),\r\n                tokenAllowances: tokenAllowances(accountAddress, assetAddress),\r\n                assetAllowances: assetAllowances(accountAddress, assetAddress)\r\n            });\r\n            currentPositionIdx++;\r\n        }\r\n        if (borrowBalanceShares > 0) {\r\n            positions[currentPositionIdx] = Position({\r\n                assetId: assetAddress,\r\n                tokenId: tokenAddress,\r\n                typeId: positionBorrow,\r\n                balance: borrowBalanceShares,\r\n                underlyingTokenBalance: tokenAmount(\r\n                    borrowBalanceShares,\r\n                    tokenAddress,\r\n                    tokenPriceUsdc\r\n                ),\r\n                tokenAllowances: tokenAllowances(accountAddress, assetAddress),\r\n                assetAllowances: assetAllowances(accountAddress, assetAddress)\r\n            });\r\n            currentPositionIdx++;\r\n        }\r\n\r\n        // Trim positions\r\n        bytes memory positionsEncoded = abi.encode(positions);\r\n        assembly {\r\n            mstore(add(positionsEncoded, 0x40), currentPositionIdx)\r\n        }\r\n        positions = abi.decode(positionsEncoded, (Position[]));\r\n\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Fetch positions for an account given an asset address\r\n     */\r\n    function assetsPositionsOf(\r\n        address accountAddress,\r\n        address[] memory _assetsAddresses\r\n    ) public view returns (Position[] memory) {\r\n        uint256 numberOfAssets = _assetsAddresses.length;\r\n\r\n        // Maximum of two positions per market: LEND and BORROW\r\n        Position[] memory positions = new Position[](numberOfAssets * 2);\r\n        uint256 currentPositionIdx;\r\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\r\n            address assetAddress = _assetsAddresses[assetIdx];\r\n            Position[] memory assetPositions =\r\n                assetPositionsOf(accountAddress, assetAddress);\r\n\r\n            for (\r\n                uint256 assetPositionIdx = 0;\r\n                assetPositionIdx < assetPositions.length;\r\n                assetPositionIdx++\r\n            ) {\r\n                Position memory position = assetPositions[assetPositionIdx];\r\n                if (position.balance > 0) {\r\n                    positions[currentPositionIdx] = position;\r\n                    currentPositionIdx++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Trim positions\r\n        bytes memory encodedData = abi.encode(positions);\r\n        assembly {\r\n            mstore(add(encodedData, 0x40), currentPositionIdx)\r\n        }\r\n        positions = abi.decode(encodedData, (Position[]));\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Fetch asset positions for an account for all assets\r\n     */\r\n    function assetsPositionsOf(address accountAddress)\r\n        public\r\n        view\r\n        returns (Position[] memory)\r\n    {\r\n        address[] memory _assetsAddresses = assetsAddresses();\r\n        return assetsPositionsOf(accountAddress, _assetsAddresses);\r\n    }\r\n\r\n    /**\r\n     * Fetch asset balance in underlying tokens\r\n     */\r\n    function assetBalance(address assetAddress) public view returns (uint256) {\r\n        ICyToken cyToken = ICyToken(assetAddress);\r\n        uint256 cash = cyToken.getCash();\r\n        uint256 totalBorrows = cyToken.totalBorrows();\r\n        uint256 totalReserves = cyToken.totalReserves();\r\n        uint256 totalSupplied = (cash + totalBorrows - totalReserves);\r\n        return totalSupplied;\r\n    }\r\n\r\n    /**\r\n     * Fetch high level information about an account\r\n     */\r\n    function adapterPositionOf(address accountAddress)\r\n        external\r\n        view\r\n        returns (AdapterPosition memory)\r\n    {\r\n        AssetUserMetadata[] memory _assetsUserMetadata =\r\n            assetsUserMetadata(accountAddress);\r\n        uint256 supplyBalanceUsdc;\r\n        uint256 borrowBalanceUsdc;\r\n        uint256 borrowLimitUsdc;\r\n        for (\r\n            uint256 metadataIdx = 0;\r\n            metadataIdx < _assetsUserMetadata.length;\r\n            metadataIdx++\r\n        ) {\r\n            AssetUserMetadata memory _assetUserMetadata =\r\n                _assetsUserMetadata[metadataIdx];\r\n            supplyBalanceUsdc += _assetUserMetadata.supplyBalanceUsdc;\r\n            borrowBalanceUsdc += _assetUserMetadata.borrowBalanceUsdc;\r\n            borrowLimitUsdc += _assetUserMetadata.borrowLimitUsdc;\r\n        }\r\n        uint256 utilizationRatioBips;\r\n        if (borrowLimitUsdc > 0) {\r\n            utilizationRatioBips =\r\n                (borrowBalanceUsdc * 10000) /\r\n                borrowLimitUsdc;\r\n        }\r\n        return\r\n            AdapterPosition({\r\n                supplyBalanceUsdc: supplyBalanceUsdc,\r\n                borrowBalanceUsdc: borrowBalanceUsdc,\r\n                borrowLimitUsdc: borrowLimitUsdc,\r\n                utilizationRatioBips: utilizationRatioBips\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Returns unique list of token addresses associated with this adapter\r\n     */\r\n    function assetsTokensAddresses() public view returns (address[] memory) {\r\n        address[] memory _assetsAddresses = assetsAddresses();\r\n        uint256 numberOfAssets = _assetsAddresses.length;\r\n        address[] memory _tokensAddresses = new address[](numberOfAssets);\r\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\r\n            address assetAddress = _assetsAddresses[assetIdx];\r\n            _tokensAddresses[assetIdx] = underlyingTokenAddress(assetAddress);\r\n        }\r\n        return _tokensAddresses;\r\n    }\r\n\r\n    /**\r\n     * Cascading fallback proxy provides the contract with the ability to add new features at a later time\r\n     */\r\n    fallback() external {\r\n        for (uint256 i = 0; i < _extensionsAddresses.length; i++) {\r\n            address extension = _extensionsAddresses[i];\r\n            assembly {\r\n                let _target := extension\r\n                calldatacopy(0, 0, calldatasize())\r\n                let success := staticcall(\r\n                    gas(),\r\n                    _target,\r\n                    0,\r\n                    calldatasize(),\r\n                    0,\r\n                    0\r\n                )\r\n                returndatacopy(0, 0, returndatasize())\r\n                if success {\r\n                    return(0, returndatasize())\r\n                }\r\n            }\r\n        }\r\n        revert(\"Extensions: Fallback proxy failed to return data\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_helperAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressesGeneratorAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"adapterInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"categoryId\",\"type\":\"string\"}],\"internalType\":\"struct RegistryAdapterIronBank.AdapterInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"adapterPositionOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supplyBalanceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowBalanceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationRatioBips\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.AdapterPosition\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressesGenerator\",\"outputs\":[{\"internalType\":\"contract IAddressesGenerator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetAllowances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.Allowance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetDynamic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSuppliedUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lendApyBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowApyBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetDynamic\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetPositionsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.Allowance[]\",\"name\":\"tokenAllowances\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.Allowance[]\",\"name\":\"assetAllowances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct RegistryAdapterIronBank.Position[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetStatic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetStatic\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetUnderlyingTokenPriceUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetUserMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enteredMarket\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"supplyBalanceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowBalanceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetUserMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsDynamic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSuppliedUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lendApyBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowApyBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetDynamic[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assetsAddresses\",\"type\":\"address[]\"}],\"name\":\"assetsDynamic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSuppliedUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowedUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lendApyBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowApyBips\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetDynamic[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_assetsAddresses\",\"type\":\"address[]\"}],\"name\":\"assetsPositionsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.Allowance[]\",\"name\":\"tokenAllowances\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.Allowance[]\",\"name\":\"assetAllowances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct RegistryAdapterIronBank.Position[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"assetsPositionsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.Allowance[]\",\"name\":\"tokenAllowances\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.Allowance[]\",\"name\":\"assetAllowances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct RegistryAdapterIronBank.Position[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsStatic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetStatic[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assetsAddresses\",\"type\":\"address[]\"}],\"name\":\"assetsStatic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetStatic[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsTokensAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"assetsUserMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enteredMarket\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"supplyBalanceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowBalanceUsdc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowLimitUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.AssetUserMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksPerYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"comptrollerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creamOracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extensionsAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"helperAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newExtensionsAddresses\",\"type\":\"address[]\"}],\"name\":\"setExtensionsAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supportedPositions\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"tokenAllowances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryAdapterIronBank.Allowance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"underlyingTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"updateSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RegistryAdapterIronBank","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000083d95e0d5f402511db06817aff3f9ea88224b0300000000000000000000000004218e20db87023049fc582aaa4bd47a3611a20ab000000000000000000000000a0b57619a980dfefd50f24f310ee1b55a40a9d46","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://efd384e00e9eb8c983cd59acf7b5bac30f22fbf854aab2e9d8643979da3dc2c1"}]}