{"status":"1","message":"OK","result":[{"SourceCode":"/// StakingRewardsEscrow.sol\r\n\r\n// Copyright (C) 2021 Reflexer Labs, INC\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.6.7;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nabstract contract TokenLike {\r\n    function balanceOf(address) virtual public view returns (uint256);\r\n    function transfer(address, uint256) virtual external returns (bool);\r\n}\r\n\r\ncontract StakingRewardsEscrow is ReentrancyGuard {\r\n    // --- Auth ---\r\n    mapping (address => uint) public authorizedAccounts;\r\n    /**\r\n     * @notice Add auth to an account\r\n     * @param account Account to add auth to\r\n     */\r\n    function addAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 1;\r\n        emit AddAuthorization(account);\r\n    }\r\n    /**\r\n     * @notice Remove auth from an account\r\n     * @param account Account to remove auth from\r\n     */\r\n    function removeAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 0;\r\n        emit RemoveAuthorization(account);\r\n    }\r\n    /**\r\n    * @notice Checks whether msg.sender can call an authed function\r\n    **/\r\n    modifier isAuthorized {\r\n        require(authorizedAccounts[msg.sender] == 1, \"StakingRewardsEscrow/account-not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Structs ---\r\n    struct EscrowSlot {\r\n        uint256 total;\r\n        uint256 startDate;\r\n        uint256 duration;\r\n        uint256 claimedUntil;\r\n        uint256 amountClaimed;\r\n    }\r\n\r\n    // --- Variables ---\r\n    // The address allowed to request escrows\r\n    address   public escrowRequestor;\r\n    // The time during which a chunk is escrowed\r\n    uint256   public escrowDuration;\r\n    // Time in a slot during which rewards to escrow can be added without creating a new escrow slot\r\n    uint256   public durationToStartEscrow;\r\n    // Current amount of slots to claim in one shot\r\n    uint256   public slotsToClaim;\r\n    // The token to escrow\r\n    TokenLike public token;\r\n\r\n    uint256   public constant MAX_ESCROW_DURATION          = 365 days;\r\n    uint256   public constant MAX_DURATION_TO_START_ESCROW = 30 days;\r\n    uint256   public constant MAX_SLOTS_TO_CLAIM           = 25;\r\n\r\n    // Oldest slot from which to start claiming unlocked rewards\r\n    mapping (address => uint256)                        public oldestEscrowSlot;\r\n    // Next slot to fill for every user\r\n    mapping (address => uint256)                        public currentEscrowSlot;\r\n    // All escrows for all accounts\r\n    mapping (address => mapping(uint256 => EscrowSlot)) public escrows;\r\n\r\n    // --- Events ---\r\n    event AddAuthorization(address account);\r\n    event RemoveAuthorization(address account);\r\n    event ModifyParameters(bytes32 indexed parameter, uint256 data);\r\n    event ModifyParameters(bytes32 indexed parameter, address data);\r\n    event EscrowRewards(address indexed who, uint256 amount, uint256 currentEscrowSlot);\r\n    event ClaimRewards(address indexed who, uint256 amount);\r\n\r\n    constructor(\r\n      address escrowRequestor_,\r\n      address token_,\r\n      uint256 escrowDuration_,\r\n      uint256 durationToStartEscrow_\r\n    ) public {\r\n      require(escrowRequestor_ != address(0), \"StakingRewardsEscrow/null-requestor\");\r\n      require(token_ != address(0), \"StakingRewardsEscrow/null-token\");\r\n      require(both(escrowDuration_ > 0, escrowDuration_ <= MAX_ESCROW_DURATION), \"StakingRewardsEscrow/invalid-escrow-duration\");\r\n      require(both(durationToStartEscrow_ > 0, durationToStartEscrow_ < escrowDuration_), \"StakingRewardsEscrow/invalid-duration-start-escrow\");\r\n      require(escrowDuration_ > durationToStartEscrow_, \"StakingRewardsEscrow/\");\r\n\r\n      authorizedAccounts[msg.sender] = 1;\r\n\r\n      escrowRequestor        = escrowRequestor_;\r\n      token                  = TokenLike(token_);\r\n      escrowDuration         = escrowDuration_;\r\n      durationToStartEscrow  = durationToStartEscrow_;\r\n      slotsToClaim           = MAX_SLOTS_TO_CLAIM;\r\n\r\n      emit AddAuthorization(msg.sender);\r\n    }\r\n\r\n    // --- Boolean Logic ---\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n    function either(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := or(x, y)}\r\n    }\r\n\r\n    // --- Math ---\r\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"StakingRewardsEscrow/add-overflow\");\r\n    }\r\n    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"StakingRewardsEscrow/sub-underflow\");\r\n    }\r\n    function multiply(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"StakingRewardsEscrow/mul-overflow\");\r\n    }\r\n    function minimum(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    /*\r\n    * @notify Modify an uint256 parameter\r\n    * @param parameter The name of the parameter to modify\r\n    * @param data New value for the parameter\r\n    */\r\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\r\n        if (parameter == \"escrowDuration\") {\r\n          require(both(data > 0, data <= MAX_ESCROW_DURATION), \"StakingRewardsEscrow/invalid-escrow-duration\");\r\n          require(data > durationToStartEscrow, \"StakingRewardsEscrow/smaller-than-start-escrow-duration\");\r\n          escrowDuration = data;\r\n        }\r\n        else if (parameter == \"durationToStartEscrow\") {\r\n          require(both(data > 1, data <= MAX_DURATION_TO_START_ESCROW), \"StakingRewardsEscrow/duration-to-start-escrow\");\r\n          require(data < escrowDuration, \"StakingRewardsEscrow/not-lower-than-escrow-duration\");\r\n          durationToStartEscrow = data;\r\n        }\r\n        else if (parameter == \"slotsToClaim\") {\r\n          require(both(data >= 1, data <= MAX_SLOTS_TO_CLAIM), \"StakingRewardsEscrow/invalid-slots-to-claim\");\r\n          slotsToClaim = data;\r\n        }\r\n        else revert(\"StakingRewardsEscrow/modify-unrecognized-param\");\r\n        emit ModifyParameters(parameter, data);\r\n    }\r\n    /*\r\n    * @notify Modify an address parameter\r\n    * @param parameter The name of the parameter to modify\r\n    * @param data New value for the parameter\r\n    */\r\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\r\n        require(data != address(0), \"StakingRewardsEscrow/null-data\");\r\n\r\n        if (parameter == \"escrowRequestor\") {\r\n            escrowRequestor = data;\r\n        }\r\n        else revert(\"StakingRewardsEscrow/modify-unrecognized-param\");\r\n        emit ModifyParameters(parameter, data);\r\n    }\r\n\r\n    // --- Core Logic ---\r\n    /*\r\n    * @notice Put more rewards under escrow for a specific address\r\n    * @param who The address that will get escrowed tokens\r\n    * @param amount Amount of tokens to escrow\r\n    */\r\n    function escrowRewards(address who, uint256 amount) external nonReentrant {\r\n        require(escrowRequestor == msg.sender, \"StakingRewardsEscrow/not-requestor\");\r\n        require(who != address(0), \"StakingRewardsEscrow/null-who\");\r\n        require(amount > 0, \"StakingRewardsEscrow/null-amount\");\r\n\r\n        if (\r\n          either(currentEscrowSlot[who] == 0,\r\n          now > addition(escrows[who][currentEscrowSlot[who] - 1].startDate, durationToStartEscrow))\r\n        ) {\r\n          escrows[who][currentEscrowSlot[who]] = EscrowSlot(amount, now, escrowDuration, now, 0);\r\n          currentEscrowSlot[who] = addition(currentEscrowSlot[who], 1);\r\n        } else {\r\n          escrows[who][currentEscrowSlot[who] - 1].total = addition(escrows[who][currentEscrowSlot[who] - 1].total, amount);\r\n        }\r\n\r\n        emit EscrowRewards(who, amount, currentEscrowSlot[who] - 1);\r\n    }\r\n    /**\r\n    * @notice Return the total amount of tokens that are being escrowed for a specific account\r\n    * @param who The address for which we calculate the amount of tokens that are still waiting to be unlocked\r\n    */\r\n    function getTokensBeingEscrowed(address who) public view returns (uint256) {\r\n        if (oldestEscrowSlot[who] >= currentEscrowSlot[who]) return 0;\r\n\r\n        EscrowSlot memory escrowReward;\r\n\r\n        uint256 totalEscrowed;\r\n        uint256 endDate;\r\n\r\n        for (uint i = oldestEscrowSlot[who]; i <= currentEscrowSlot[who]; i++) {\r\n            escrowReward = escrows[who][i];\r\n            endDate      = addition(escrowReward.startDate, escrowReward.duration);\r\n\r\n            if (escrowReward.amountClaimed >= escrowReward.total) {\r\n              continue;\r\n            }\r\n\r\n            if (both(escrowReward.claimedUntil < endDate, now >= endDate)) {\r\n              continue;\r\n            }\r\n\r\n            totalEscrowed = addition(totalEscrowed, subtract(escrowReward.total, escrowReward.amountClaimed));\r\n        }\r\n\r\n        return totalEscrowed;\r\n    }\r\n    /*\r\n    * @notice Return the total amount of tokens that can be claimed right now for an address\r\n    * @param who The address to claim on behalf of\r\n    */\r\n    function getClaimableTokens(address who) public view returns (uint256) {\r\n        if (currentEscrowSlot[who] == 0) return 0;\r\n        if (oldestEscrowSlot[who] >= currentEscrowSlot[who]) return 0;\r\n\r\n        uint256 lastSlotToClaim = (subtract(currentEscrowSlot[who], oldestEscrowSlot[who]) > slotsToClaim) ?\r\n          addition(oldestEscrowSlot[who], subtract(slotsToClaim, 1)) : subtract(currentEscrowSlot[who], 1);\r\n\r\n        EscrowSlot memory escrowReward;\r\n\r\n        uint256 totalToTransfer;\r\n        uint256 endDate;\r\n        uint256 reward;\r\n\r\n        for (uint i = oldestEscrowSlot[who]; i <= lastSlotToClaim; i++) {\r\n            escrowReward = escrows[who][i];\r\n            endDate      = addition(escrowReward.startDate, escrowReward.duration);\r\n\r\n            if (escrowReward.amountClaimed >= escrowReward.total) {\r\n              continue;\r\n            }\r\n\r\n            if (both(escrowReward.claimedUntil < endDate, now >= endDate)) {\r\n              totalToTransfer = addition(totalToTransfer, subtract(escrowReward.total, escrowReward.amountClaimed));\r\n              continue;\r\n            }\r\n\r\n            if (escrowReward.claimedUntil == now) continue;\r\n\r\n            reward = subtract(escrowReward.total, escrowReward.amountClaimed) / subtract(endDate, escrowReward.claimedUntil);\r\n            reward = multiply(reward, subtract(now, escrowReward.claimedUntil));\r\n            if (addition(escrowReward.amountClaimed, reward) > escrowReward.total) {\r\n              reward = subtract(escrowReward.total, escrowReward.amountClaimed);\r\n            }\r\n\r\n            totalToTransfer = addition(totalToTransfer, reward);\r\n        }\r\n\r\n        return totalToTransfer;\r\n    }\r\n    /*\r\n    * @notice Claim vested tokens\r\n    * @param who The address to claim on behalf of\r\n    */\r\n    function claimTokens(address who) public nonReentrant {\r\n        require(currentEscrowSlot[who] > 0, \"StakingRewardsEscrow/invalid-address\");\r\n        require(oldestEscrowSlot[who] < currentEscrowSlot[who], \"StakingRewardsEscrow/no-slot-to-claim\");\r\n\r\n        uint256 lastSlotToClaim = (subtract(currentEscrowSlot[who], oldestEscrowSlot[who]) > slotsToClaim) ?\r\n          addition(oldestEscrowSlot[who], subtract(slotsToClaim, 1)) : subtract(currentEscrowSlot[who], 1);\r\n\r\n        EscrowSlot storage escrowReward;\r\n\r\n        uint256 totalToTransfer;\r\n        uint256 endDate;\r\n        uint256 reward;\r\n\r\n        for (uint i = oldestEscrowSlot[who]; i <= lastSlotToClaim; i++) {\r\n            escrowReward = escrows[who][i];\r\n            endDate      = addition(escrowReward.startDate, escrowReward.duration);\r\n\r\n            if (escrowReward.amountClaimed >= escrowReward.total) {\r\n              oldestEscrowSlot[who] = addition(oldestEscrowSlot[who], 1);\r\n              continue;\r\n            }\r\n\r\n            if (both(escrowReward.claimedUntil < endDate, now >= endDate)) {\r\n              totalToTransfer            = addition(totalToTransfer, subtract(escrowReward.total, escrowReward.amountClaimed));\r\n              escrowReward.amountClaimed = escrowReward.total;\r\n              escrowReward.claimedUntil  = now;\r\n              oldestEscrowSlot[who]      = addition(oldestEscrowSlot[who], 1);\r\n              continue;\r\n            }\r\n\r\n            if (escrowReward.claimedUntil == now) continue;\r\n\r\n            reward = subtract(escrowReward.total, escrowReward.amountClaimed) / subtract(endDate, escrowReward.claimedUntil);\r\n            reward = multiply(reward, subtract(now, escrowReward.claimedUntil));\r\n            if (addition(escrowReward.amountClaimed, reward) > escrowReward.total) {\r\n              reward = subtract(escrowReward.total, escrowReward.amountClaimed);\r\n            }\r\n\r\n            totalToTransfer            = addition(totalToTransfer, reward);\r\n            escrowReward.amountClaimed = addition(escrowReward.amountClaimed, reward);\r\n            escrowReward.claimedUntil  = now;\r\n        }\r\n\r\n        if (totalToTransfer > 0) {\r\n            require(token.transfer(who, totalToTransfer), \"StakingRewardsEscrow/cannot-transfer-rewards\");\r\n        }\r\n\r\n        emit ClaimRewards(who, totalToTransfer);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"escrowRequestor_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"escrowDuration_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"durationToStartEscrow_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentEscrowSlot\",\"type\":\"uint256\"}],\"name\":\"EscrowRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveAuthorization\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_DURATION_TO_START_ESCROW\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ESCROW_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SLOTS_TO_CLAIM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"currentEscrowSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"durationToStartEscrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escrowDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escrowRequestor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"escrowRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"escrows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedUntil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getClaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getTokensBeingEscrowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oldestEscrowSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slotsToClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StakingRewardsEscrow","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fa5e4955a11902f849ecaddef355db69c2036de60000000000000000000000006243d8cea23066d098a15582d81a598b4e8391f40000000000000000000000000000000000000000000000000000000000f0c8a00000000000000000000000000000000000000000000000000000000000127500","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4bc7c338a69b84c48351cb2207f960ee034b8cf7230bee53d0e511031ec5f779"}]}