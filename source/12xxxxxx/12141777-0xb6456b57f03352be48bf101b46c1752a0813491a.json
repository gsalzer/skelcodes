{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.1;\r\n\r\ninterface ISupplyController {\r\n\tfunction mintIncentive(address addr) external;\r\n\tfunction mintableIncentive(address addr) external view returns (uint);\r\n\tfunction mint(address token, address owner, uint amount) external;\r\n\tfunction changeSupplyController(address newSupplyController) external;\r\n}\r\n\r\ninterface IADXToken {\r\n\tfunction transfer(address to, uint256 amount) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\tfunction balanceOf(address spender) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\tfunction totalSupply() external returns (uint);\r\n\tfunction supplyController() external view returns (ISupplyController);\r\n\tfunction changeSupplyController(address newSupplyController) external;\r\n\tfunction mint(address owner, uint amount) external;\r\n}\r\n\r\n\r\ninterface IERCDecimals {\r\n\tfunction decimals() external view returns (uint);\r\n}\r\n\r\ninterface IChainlink {\r\n\t// AUDIT: ensure this API is not deprecated\r\n\tfunction latestAnswer() external view returns (uint);\r\n}\r\n\r\n// Full interface here: https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol\r\ninterface IUniswapSimple {\r\n\tfunction WETH() external pure returns (address);\r\n\tfunction swapTokensForExactTokens(\r\n\t\tuint amountOut,\r\n\t\tuint amountInMax,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external returns (uint[] memory amounts);\r\n}\r\n\r\ncontract StakingPool {\r\n\t// ERC20 stuff\r\n\t// Constants\r\n\tstring public constant name = \"AdEx Staking Token\";\r\n\tuint8 public constant decimals = 18;\r\n\tstring public constant symbol = \"ADX-STAKING\";\r\n\r\n\t// Mutable variables\r\n\tuint public totalSupply;\r\n\tmapping(address => uint) private balances;\r\n\tmapping(address => mapping(address => uint)) private allowed;\r\n\r\n\t// EIP 2612\r\n\tbytes32 public DOMAIN_SEPARATOR;\r\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\tmapping(address => uint) public nonces;\r\n\r\n\t// ERC20 events\r\n\tevent Approval(address indexed owner, address indexed spender, uint amount);\r\n\tevent Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n\t// ERC20 methods\r\n\tfunction balanceOf(address owner) external view returns (uint balance) {\r\n\t\treturn balances[owner];\r\n\t}\r\n\r\n\tfunction transfer(address to, uint amount) external returns (bool success) {\r\n\t\trequire(to != address(this), \"BAD_ADDRESS\");\r\n\t\tbalances[msg.sender] = balances[msg.sender] - amount;\r\n\t\tbalances[to] = balances[to] + amount;\r\n\t\temit Transfer(msg.sender, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address from, address to, uint amount) external returns (bool success) {\r\n\t\tbalances[from] = balances[from] - amount;\r\n\t\tallowed[from][msg.sender] = allowed[from][msg.sender] - amount;\r\n\t\tbalances[to] = balances[to] + amount;\r\n\t\temit Transfer(from, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approve(address spender, uint amount) external returns (bool success) {\r\n\t\tallowed[msg.sender][spender] = amount;\r\n\t\temit Approval(msg.sender, spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowance(address owner, address spender) external view returns (uint remaining) {\r\n\t\treturn allowed[owner][spender];\r\n\t}\r\n\r\n\t// EIP 2612\r\n\tfunction permit(address owner, address spender, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n\t\trequire(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\r\n\t\tbytes32 digest = keccak256(abi.encodePacked(\r\n\t\t\t\"\\x19\\x01\",\r\n\t\t\tDOMAIN_SEPARATOR,\r\n\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline))\r\n\t\t));\r\n\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\r\n\t\trequire(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNATURE\");\r\n\t\tallowed[owner][spender] = amount;\r\n\t\temit Approval(owner, spender, amount);\r\n\t}\r\n\r\n\t// Inner\r\n\tfunction innerMint(address owner, uint amount) internal {\r\n\t\ttotalSupply = totalSupply + amount;\r\n\t\tbalances[owner] = balances[owner] + amount;\r\n\t\t// Because of https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\r\n\t\temit Transfer(address(0), owner, amount);\r\n\t}\r\n\tfunction innerBurn(address owner, uint amount) internal {\r\n\t\ttotalSupply = totalSupply - amount;\r\n\t\tbalances[owner] = balances[owner] - amount;\r\n\t\temit Transfer(owner, address(0), amount);\r\n\t}\r\n\r\n\t// Pool functionality\r\n\tuint public timeToUnbond = 20 days;\r\n\tuint public rageReceivedPromilles = 700;\r\n\r\n\tIUniswapSimple public uniswap; // = IUniswapSimple(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\tIChainlink public ADXUSDOracle; // = IChainlink(0x231e764B44b2C1b7Ca171fa8021A24ed520Cde10);\r\n\r\n\tIADXToken public immutable ADXToken;\r\n\taddress public guardian;\r\n\taddress public validator;\r\n\taddress public governance;\r\n\r\n\t// claim token whitelist: normally claim tokens are stablecoins\r\n\t// eg Tether (0xdAC17F958D2ee523a2206206994597C13D831ec7)\r\n\tmapping (address => bool) public whitelistedClaimTokens;\r\n\r\n\t// Commitment ID against the max amount of tokens it will pay out\r\n\tmapping (bytes32 => uint) public commitments;\r\n\t// How many of a user's shares are locked\r\n\tmapping (address => uint) public lockedShares;\r\n\t// Unbonding commitment from a staker\r\n\tstruct UnbondCommitment {\r\n\t\taddress owner;\r\n\t\tuint shares;\r\n\t\tuint unlocksAt;\r\n\t}\r\n\r\n\t// claims/penalizations limits\r\n\tuint public maxDailyPenaltiesPromilles;\r\n\tuint public limitLastReset;\r\n\tuint public limitRemaining;\r\n\r\n\t// Staking pool events\r\n\t// LogLeave/LogWithdraw must begin with the UnbondCommitment struct\r\n\tevent LogLeave(address indexed owner, uint shares, uint unlocksAt, uint maxTokens);\r\n\tevent LogWithdraw(address indexed owner, uint shares, uint unlocksAt, uint maxTokens, uint receivedTokens);\r\n\tevent LogRageLeave(address indexed owner, uint shares, uint maxTokens, uint receivedTokens);\r\n\tevent LogNewGuardian(address newGuardian);\r\n\tevent LogClaim(address tokenAddr, address to, uint amountInUSD, uint burnedValidatorShares, uint usedADX, uint totalADX, uint totalShares);\r\n\tevent LogPenalize(uint burnedADX);\r\n\r\n\tconstructor(IADXToken token, IUniswapSimple uni, IChainlink oracle, address guardianAddr, address validatorStakingWallet, address governanceAddr, address claimToken) {\r\n\t\tADXToken = token;\r\n\t\tuniswap = uni;\r\n\t\tADXUSDOracle = oracle;\r\n\t\tguardian = guardianAddr;\r\n\t\tvalidator = validatorStakingWallet;\r\n\t\tgovernance = governanceAddr;\r\n\t\twhitelistedClaimTokens[claimToken] = true;\r\n\r\n\t\t// EIP 2612\r\n\t\tuint chainId;\r\n\t\tassembly {\r\n\t\t\tchainId := chainid()\r\n\t\t}\r\n\t\tDOMAIN_SEPARATOR = keccak256(\r\n\t\t\tabi.encode(\r\n\t\t\t\tkeccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n\t\t\t\tkeccak256(bytes(name)),\r\n\t\t\t\tkeccak256(bytes(\"1\")),\r\n\t\t\t\tchainId,\r\n\t\t\t\taddress(this)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t// Governance functions\r\n\tfunction setGovernance(address addr) external {\r\n\t\trequire(governance == msg.sender, \"NOT_GOVERNANCE\");\r\n\t\tgovernance = addr;\r\n\t}\r\n\tfunction setDailyPenaltyMax(uint max) external {\r\n\t\trequire(governance == msg.sender, \"NOT_GOVERNANCE\");\r\n\t\trequire(max <= 200, \"DAILY_PENALTY_TOO_LARGE\");\r\n\t\tmaxDailyPenaltiesPromilles = max;\r\n\t\tresetLimits();\r\n\t}\r\n\tfunction setRageReceived(uint rageReceived) external {\r\n\t\trequire(governance == msg.sender, \"NOT_GOVERNANCE\");\r\n\t\t// AUDIT: should there be a minimum here?\r\n\t\trequire(rageReceived <= 1000, \"TOO_LARGE\");\r\n\t\trageReceivedPromilles = rageReceived;\r\n\t}\r\n\tfunction setTimeToUnbond(uint time) external {\r\n\t\trequire(governance == msg.sender, \"NOT_GOVERNANCE\");\r\n\t\trequire(time >= 1 days && time <= 30 days, \"BOUNDS\");\r\n\t\ttimeToUnbond = time;\r\n\t}\r\n\tfunction setGuardian(address newGuardian) external {\r\n\t\trequire(governance == msg.sender, \"NOT_GOVERNANCE\");\r\n\t\tguardian = newGuardian;\r\n\t\temit LogNewGuardian(newGuardian);\r\n\t}\r\n\tfunction setWhitelistedClaimToken(address token, bool whitelisted) external {\r\n\t\trequire(governance == msg.sender, \"NOT_GOVERNANCE\");\r\n\t\twhitelistedClaimTokens[token] = whitelisted;\r\n\t}\r\n\r\n\t// Pool stuff\r\n\tfunction shareValue() external view returns (uint) {\r\n\t\tif (totalSupply == 0) return 0;\r\n\t\treturn ((ADXToken.balanceOf(address(this)) + ADXToken.supplyController().mintableIncentive(address(this)))\r\n\t\t\t* 1e18)\r\n\t\t\t/ totalSupply;\r\n\t}\r\n\r\n\tfunction innerEnter(address recipient, uint amount) internal {\r\n\t\t// Please note that minting has to be in the beginning so that we take it into account\r\n\t\t// when using ADXToken.balanceOf()\r\n\t\t// Minting makes an external call but it\"s to a trusted contract (ADXToken)\r\n\t\tADXToken.supplyController().mintIncentive(address(this));\r\n\r\n\t\tuint totalADX = ADXToken.balanceOf(address(this));\r\n\r\n\t\t// The totalADX == 0 check here should be redudnant; the only way to get totalSupply to a nonzero val is by adding ADX\r\n\t\tif (totalSupply == 0 || totalADX == 0) {\r\n\t\t\tinnerMint(recipient, amount);\r\n\t\t} else {\r\n\t\t\tuint256 newShares = (amount * totalSupply) / totalADX;\r\n\t\t\tinnerMint(recipient, newShares);\r\n\t\t}\r\n\t\trequire(ADXToken.transferFrom(msg.sender, address(this), amount));\r\n\t\t// no events, as innerMint already emits enough to know the shares amount and price\r\n\t}\r\n\r\n\tfunction enter(uint amount) external {\r\n\t\tinnerEnter(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction enterTo(address recipient, uint amount) external {\r\n\t\tinnerEnter(recipient, amount);\r\n\t}\r\n\r\n\tfunction unbondingCommitmentWorth(address owner, uint shares, uint unlocksAt) external view returns (uint) {\r\n\t\tif (totalSupply == 0) return 0;\r\n\t\tbytes32 commitmentId = keccak256(abi.encode(UnbondCommitment({ owner: owner, shares: shares, unlocksAt: unlocksAt })));\r\n\t\tuint maxTokens = commitments[commitmentId];\r\n\t\tuint totalADX = ADXToken.balanceOf(address(this));\r\n\t\tuint currentTokens = (shares * totalADX) / totalSupply;\r\n\t\treturn currentTokens > maxTokens ? maxTokens : currentTokens;\r\n\t}\r\n\r\n\tfunction leave(uint shares, bool skipMint) external {\r\n\t\tif (!skipMint) ADXToken.supplyController().mintIncentive(address(this));\r\n\r\n\t\trequire(shares <= balances[msg.sender] - lockedShares[msg.sender], \"INSUFFICIENT_SHARES\");\r\n\t\tuint totalADX = ADXToken.balanceOf(address(this));\r\n\t\tuint maxTokens = (shares * totalADX) / totalSupply;\r\n\t\tuint unlocksAt = block.timestamp + timeToUnbond;\r\n\t\tbytes32 commitmentId = keccak256(abi.encode(UnbondCommitment({ owner: msg.sender, shares: shares, unlocksAt: unlocksAt })));\r\n\t\trequire(commitments[commitmentId] == 0, \"COMMITMENT_EXISTS\");\r\n\r\n\t\tcommitments[commitmentId] = maxTokens;\r\n\t\tlockedShares[msg.sender] += shares;\r\n\r\n\t\temit LogLeave(msg.sender, shares, unlocksAt, maxTokens);\r\n\t}\r\n\r\n\tfunction withdraw(uint shares, uint unlocksAt, bool skipMint) external {\r\n\t\tif (!skipMint) ADXToken.supplyController().mintIncentive(address(this));\r\n\r\n\t\trequire(block.timestamp > unlocksAt, \"UNLOCK_TOO_EARLY\");\r\n\t\tbytes32 commitmentId = keccak256(abi.encode(UnbondCommitment({ owner: msg.sender, shares: shares, unlocksAt: unlocksAt })));\r\n\t\tuint maxTokens = commitments[commitmentId];\r\n\t\trequire(maxTokens > 0, \"NO_COMMITMENT\");\r\n\t\tuint totalADX = ADXToken.balanceOf(address(this));\r\n\t\tuint currentTokens = (shares * totalADX) / totalSupply;\r\n\t\tuint receivedTokens = currentTokens > maxTokens ? maxTokens : currentTokens;\r\n\r\n\t\tcommitments[commitmentId] = 0;\r\n\t\tlockedShares[msg.sender] -= shares;\r\n\r\n\t\tinnerBurn(msg.sender, shares);\r\n\t\trequire(ADXToken.transfer(msg.sender, receivedTokens));\r\n\r\n\t\temit LogWithdraw(msg.sender, shares, unlocksAt, maxTokens, receivedTokens);\r\n\t}\r\n\r\n\tfunction rageLeave(uint shares, bool skipMint) external {\r\n\t\tif (!skipMint) ADXToken.supplyController().mintIncentive(address(this));\r\n\r\n\t\tuint totalADX = ADXToken.balanceOf(address(this));\r\n\t\tuint adxAmount = (shares * totalADX) / totalSupply;\r\n\t\tuint receivedTokens = (adxAmount * rageReceivedPromilles) / 1000;\r\n\t\tinnerBurn(msg.sender, shares);\r\n\t\trequire(ADXToken.transfer(msg.sender, receivedTokens));\r\n\r\n\t\temit LogRageLeave(msg.sender, shares, adxAmount, receivedTokens);\r\n\t}\r\n\r\n\t// Insurance mechanism\r\n\t// In case something goes wrong, this can be used to recoup funds\r\n\t// As of V5, the idea is to use it to provide some interest (eg 10%) for late refunds, in case channels get stuck and have to wait through their challenge period\r\n\tfunction claim(address tokenOut, address to, uint amount) external {\r\n\t\trequire(msg.sender == guardian, \"NOT_GUARDIAN\");\r\n\r\n\t\t// start by resetting claim/penalty limits\r\n\t\tresetLimits();\r\n\r\n\t\t// NOTE: minting is intentionally skipped here\r\n\t\t// This means that a validator may be punished a bit more when burning their shares,\r\n\t\t// but it guarantees that claim() always works\r\n\t\tuint totalADX = ADXToken.balanceOf(address(this));\r\n\r\n\t\t// Note: whitelist of tokenOut tokens\r\n\t\trequire(whitelistedClaimTokens[tokenOut], \"TOKEN_NOT_WHITELISTED\");\r\n\r\n\t\taddress[] memory path = new address[](3);\r\n\t\tpath[0] = address(ADXToken);\r\n\t\tpath[1] = uniswap.WETH();\r\n\t\tpath[2] = tokenOut;\r\n\r\n\t\t// You may think the Uniswap call enables reentrancy, but reentrancy is a problem only if the pattern is check-call-modify, not call-check-modify as is here\r\n\t\t// there\"s no case in which we \"double-spend\" a value\r\n\t\t// Plus, ADX, USDT and uniswap are all trusted\r\n\r\n\t\t// Slippage protection; 5% slippage allowed\r\n\t\tuint price = ADXUSDOracle.latestAnswer();\r\n\t\t// chainlink price is in 1e8\r\n\t\t// for example, if the amount is in 1e6;\r\n\t\t// we need to convert from 1e6 to 1e18 (adx) but we divide by 1e8 (price); 18 - 6 + 8 ; verified this by calculating manually\r\n\t\tuint multiplier = 1.05e26 / (10 ** IERCDecimals(tokenOut).decimals());\r\n\t\tuint adxAmountMax = (amount * multiplier) / price;\r\n\t\trequire(adxAmountMax < totalADX, \"INSUFFICIENT_ADX\");\r\n\t\tuint[] memory amounts = uniswap.swapTokensForExactTokens(amount, adxAmountMax, path, to, block.timestamp);\r\n\r\n\t\t// calculate the total ADX amount used in the swap\r\n\t\tuint adxAmountUsed = amounts[0];\r\n\r\n\t\t// burn the validator shares so that they pay for it first, before dilluting other holders\r\n\t\t// calculate the worth in ADX of the validator\"s shares\r\n\t\tuint sharesNeeded = (adxAmountUsed * totalSupply) / totalADX;\r\n\t\tuint toBurn = sharesNeeded < balances[validator] ? sharesNeeded : balances[validator];\r\n\t\tif (toBurn > 0) innerBurn(validator, toBurn);\r\n\r\n\t\t// Technically redundant cause we\"ll fail on the subtraction, but we\"re doing this for better err msgs\r\n\t\trequire(limitRemaining >= adxAmountUsed, \"LIMITS\");\r\n\t\tlimitRemaining -= adxAmountUsed;\r\n\r\n\t\temit LogClaim(tokenOut, to, amount, toBurn, adxAmountUsed, totalADX, totalSupply);\r\n\t}\r\n\r\n\tfunction penalize(uint adxAmount) external {\r\n\t\trequire(msg.sender == guardian, \"NOT_GUARDIAN\");\r\n\t\t// AUDIT: we can do getLimitRemaining() instead of resetLimits() that returns the remaining limit\r\n\t\tresetLimits();\r\n\t\t// Technically redundant cause we'll fail on the subtraction, but we're doing this for better err msgs\r\n\t\trequire(limitRemaining >= adxAmount, \"LIMITS\");\r\n\t\tlimitRemaining -= adxAmount;\r\n\t\trequire(ADXToken.transfer(address(0), adxAmount));\r\n\t\temit LogPenalize(adxAmount);\r\n\t}\r\n\r\n\tfunction resetLimits() internal {\r\n\t\tif (block.timestamp - limitLastReset > 24 hours) {\r\n\t\t\tlimitLastReset = block.timestamp;\r\n\t\t\tlimitRemaining = (ADXToken.balanceOf(address(this)) * maxDailyPenaltiesPromilles) / 1000;\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IADXToken\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapSimple\",\"name\":\"uni\",\"type\":\"address\"},{\"internalType\":\"contract IChainlink\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardianAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validatorStakingWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"governanceAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"claimToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountInUSD\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnedValidatorShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usedADX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalADX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"LogClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlocksAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"}],\"name\":\"LogLeave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"LogNewGuardian\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnedADX\",\"type\":\"uint256\"}],\"name\":\"LogPenalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedTokens\",\"type\":\"uint256\"}],\"name\":\"LogRageLeave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlocksAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedTokens\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADXToken\",\"outputs\":[{\"internalType\":\"contract IADXToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ADXUSDOracle\",\"outputs\":[{\"internalType\":\"contract IChainlink\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enterTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipMint\",\"type\":\"bool\"}],\"name\":\"leave\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitLastReset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDailyPenaltiesPromilles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"adxAmount\",\"type\":\"uint256\"}],\"name\":\"penalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipMint\",\"type\":\"bool\"}],\"name\":\"rageLeave\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rageReceivedPromilles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setDailyPenaltyMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rageReceived\",\"type\":\"uint256\"}],\"name\":\"setRageReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setTimeToUnbond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedClaimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shareValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToUnbond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlocksAt\",\"type\":\"uint256\"}],\"name\":\"unbondingCommitmentWorth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap\",\"outputs\":[{\"internalType\":\"contract IUniswapSimple\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedClaimTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlocksAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipMint\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StakingPool","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ade00c28244d5ce17d72e40330b1c318cd12b7c30000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000231e764b44b2c1b7ca171fa8021a24ed520cde1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ad2d3389895d00910a09f85b12073170af43a2f0000000000000000000000001304f1b9e8eb2c328b564e7fad2c8402a5954572000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a8c2242f25e07400bcca16448c8ff485560366840b7295ef5c83c38b0d888570"}]}