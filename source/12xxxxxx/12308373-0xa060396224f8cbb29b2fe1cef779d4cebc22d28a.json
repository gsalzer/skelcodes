{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\token\\ERC721\\IERC721Metadata.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.7.0 <0.8.5;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts\\access\\AccessControl.sol\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(\r\n            uint256(s) <=\r\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\r\n            \"ECDSA: invalid signature 's' value\"\r\n        );\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor() {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev {ERC721} token, including:\r\n *\r\n *  - ability for holders to burn (destroy) their tokens\r\n *  - a minter role that allows for token minting (creation)\r\n *  - a pauser role that allows to stop all token transfers\r\n *  - token ID and URI autogeneration\r\n *\r\n * This contract uses {AccessControl} to lock permissioned functions using the\r\n * different roles - head to its documentation for details.\r\n *\r\n * The account that deploys the contract will be granted the minter and pauser\r\n * roles, as well as the default admin role, which will let it grant both minter\r\n * and pauser roles to other accounts.\r\n */\r\ncontract Decurly is ERC165, Context, Ownable {\r\n    using ECDSA for bytes32;\r\n    using Strings for uint256;\r\n\r\n    /*\r\n     *     bytes4(keccak256('name()')) == 0x06fdde03\r\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\r\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n    /*\r\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x6352211e;\r\n\r\n    mapping(address => bool) private _minters;\r\n\r\n    struct OwnerInfo {\r\n        address owner;\r\n        uint32 ttl;\r\n        uint32 timestamp;\r\n        bool DNSSEC;\r\n        string domain;\r\n    }\r\n\r\n    mapping(uint256 => OwnerInfo) private _tokenOwners;\r\n    mapping(address => uint256) private _defaultDomain;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    string private _baseURI;\r\n    uint8 private _maxTrustScore;\r\n\r\n    uint256 private _chainId;\r\n    \r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        string memory baseURI_\r\n    ) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _baseURI = baseURI_;\r\n        addMinter(_msgSender());\r\n        _maxTrustScore = 95;\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        fetchChainId();\r\n    }\r\n\r\n    /*\r\n     * Gets the owner of a tokenId\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\r\n        return _tokenOwners[tokenId].owner;\r\n    }\r\n\r\n    function _mint(\r\n        string memory domain,\r\n        address to,\r\n        uint32 ttl,\r\n        uint256 id,\r\n        bool DNSSEC,\r\n        bool setAsDefault,\r\n        uint32 timestamp\r\n    ) private {\r\n        OwnerInfo memory ownerInfo = _tokenOwners[id];\r\n        address tOwner = ownerInfo.owner;\r\n        if (tOwner != to) {\r\n            ownerInfo.domain = domain;\r\n            ownerInfo.owner = to;\r\n            if (_defaultDomain[tOwner] == id) {\r\n                _defaultDomain[tOwner] = 0;\r\n            }\r\n            ownerInfo.timestamp = timestamp;\r\n            emit Transfer(tOwner, to, id);\r\n        }\r\n        if (setAsDefault && _defaultDomain[to] != id) {\r\n            _defaultDomain[to] = id;\r\n        }\r\n        ownerInfo.DNSSEC = DNSSEC;\r\n        ownerInfo.ttl = ttl;\r\n        _tokenOwners[id] = ownerInfo;\r\n    }\r\n\r\n    /*\r\n     * Minting should only be possible:\r\n     *    - Signer has minter role.\r\n     *    - parameters are signed correctly\r\n     *    - Ticket was not already used.\r\n     *    - ttl is valid\r\n     * Idea:\r\n     * We could save some space by converting domain to a base38 encoding\r\n     * Saving 2-Bit per domain-Character (Allowed domain Characters are [a-z] (lowercase is enough) [0-9] and [.-])\r\n     * on a theoretical length of 256 Byte we would save two SSTORE operations\r\n     */\r\n    function mint(\r\n        string memory domain,\r\n        address to,\r\n        uint32 ttl,\r\n        uint256 id,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v,\r\n        bool DNSSEC,\r\n        bool setAsDefault\r\n    ) external payable {\r\n        require(ttl >= block.timestamp, \"Error:Old ticket\");\r\n        require(_tokenOwners[id].ttl < ttl, \"Error:Already used\");\r\n        bytes32 hashed =\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    domain,\r\n                    to,\r\n                    id,\r\n                    ttl,\r\n                    msg.value,\r\n                    DNSSEC,\r\n                    setAsDefault,\r\n                    _chainId\r\n                )\r\n            );\r\n        require(_minters[hashed.recover(v, r, s)] == true, \"Error:Unsigned tx\");\r\n        _mint(\r\n            domain,\r\n            to,\r\n            ttl,\r\n            id,\r\n            DNSSEC,\r\n            setAsDefault,\r\n            uint32(block.timestamp)\r\n        );\r\n    }\r\n\r\n    // EVM has chainId\r\n    function fetchChainId() public onlyOwner {\r\n        _chainId = _getChainId();\r\n    }\r\n\r\n    // in case there is no chainId on the EVM i have to come up with one...\r\n    function setChainId(uint256 id) external onlyOwner {\r\n        _chainId = id;\r\n    }\r\n\r\n    /*\r\n     * To save users minting costs, the transfer of current contract holdings ist done owner\r\n     * This saves an unneccessary transfer in the minting process.\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        require(payable(msg.sender).send(address(this).balance));\r\n    }\r\n\r\n    /*\r\n     * Multichain....\r\n     */\r\n    function _getChainId() internal pure returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n\r\n    /*\r\n     * Burns domain token if you want to get rid of it\r\n     */\r\n    function burn(uint256 id) public {\r\n        require(ownerOf(id) == msg.sender, \"Error: you have to be Owner\");\r\n        _tokenOwners[id].owner = address(0);\r\n        if (_defaultDomain[msg.sender] != 0) {\r\n            delete _defaultDomain[msg.sender];\r\n        }\r\n        emit Transfer(msg.sender, address(0), id);\r\n    }\r\n\r\n    /*\r\n     * Gets default domain for address\r\n     */\r\n    function getDefaultDomain(address adr)\r\n        external\r\n        view\r\n        returns (string memory domain)\r\n    {\r\n        uint256 id = _defaultDomain[adr];\r\n        require(adr != address(0), \"Error: No default for null address\");\r\n        require(ownerOf(id) == adr, \"Error: No default domain\");\r\n        return _tokenOwners[id].domain;\r\n    }\r\n\r\n    /*\r\n     * Sets default domaintoken for address\r\n     */\r\n    function setDefaultDomainToken(uint256 id) external {\r\n        require(ownerOf(id) == msg.sender, \"Error: Not owner of domain\");\r\n        _defaultDomain[msg.sender] = id;\r\n    }\r\n\r\n    /*\r\n     * Resets domaintoken for address\r\n     */\r\n    function resetDefaultDomainToken() external {\r\n        _defaultDomain[msg.sender] = 0;\r\n    }\r\n\r\n    /*\r\n     * Gets tokenId for a given domain (Punycoded)\r\n     */\r\n    function getDomainTokenId(string memory domain)\r\n        public\r\n        pure\r\n        returns (uint256 tokenId)\r\n    {\r\n        return uint256(keccak256(abi.encodePacked(domain)));\r\n    }\r\n\r\n    /*\r\n     * Gets domainstring for the token\r\n     */\r\n    function getDomainOfToken(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (string memory domain)\r\n    {\r\n        return _tokenOwners[tokenId].domain;\r\n    }\r\n\r\n    /*\r\n     * Gets the owner wallet of the domain\r\n     */\r\n    function getDomainOwner(string memory domain)\r\n        public\r\n        view\r\n        returns (address owner)\r\n    {\r\n        return ownerOf(getDomainTokenId(domain));\r\n    }\r\n\r\n    /*\r\n     * Tokenname\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /*\r\n     * Tokensymbol\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /*\r\n     * TokenUri\r\n     */\r\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\r\n        require(\r\n            ownerOf(tokenId) != address(0),\r\n            \"ERC721Metadata: URI query for nonexistent token\"\r\n        );\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    baseURI(),\r\n                    _chainId.toString(),\r\n                    \"/\",\r\n                    tokenId.toString()\r\n                )\r\n            );\r\n    }\r\n\r\n    /*\r\n     * FFU => SET 100 once DNSSEC verification is implemented\r\n     */\r\n\r\n    function setCurrentMaxTrustScore(uint8 score) external onlyOwner {\r\n        _maxTrustScore = score;\r\n    }\r\n\r\n    /*\r\n     * Gives you the current max trustScore reachable (DNSSEC is not implemented yet)\r\n     */\r\n    function getCurrentMaxTrustScore() public view returns (uint8) {\r\n        return _maxTrustScore;\r\n    }\r\n\r\n    /*\r\n     * See getTrustScore(uint256 id) but domain-string based\r\n     */\r\n    function getTrustScore(string memory domain) public view returns (uint256) {\r\n        return getTrustScore(getDomainTokenId(domain));\r\n    }\r\n\r\n    /*\r\n     * Gets a trustScore (0 - 100) for a domain\r\n     * DNSSEC Domains are 100\r\n     *\r\n     * NON DNSSEC domain are 0 - 95 (Zero at day one and 90 at day 9)\r\n     * Final value of non-DNSSEC domains is 95 after day 10.\r\n     * If you want some security on non DNSSEC entries you might consider that in a case of a broad DNS-Spoofing attack\r\n     * it could probably last about one to five days in normal cases.\r\n     * If you have critical payments on chain, implement the getTrustScore accordingly!\r\n     */\r\n    function getTrustScore(uint256 id) public view returns (uint256) {\r\n        require(ownerOf(id) != address(0), \"Error: id has no owner\");\r\n        if (_tokenOwners[id].DNSSEC) {\r\n            return 100;\r\n        }\r\n        uint256 sinceInception = block.timestamp - _tokenOwners[id].timestamp;\r\n        uint256 daysSinceInception = sinceInception / 86400;\r\n        if (daysSinceInception > 9) {\r\n            return 95;\r\n        } else {\r\n            return daysSinceInception * 10;\r\n        }\r\n    }\r\n\r\n    function setBaseURI(string memory baseURI_) public onlyOwner {\r\n        _baseURI = baseURI_;\r\n    }\r\n\r\n    function baseURI() public view returns (string memory) {\r\n        return _baseURI;\r\n    }\r\n\r\n    /* adds a minter role */\r\n    function addMinter(address minter_) public onlyOwner {\r\n        _minters[minter_] = true;\r\n    }\r\n\r\n    /* removes a minter role */\r\n    function removeMinter(address minter_) public onlyOwner {\r\n        _minters[minter_] = false;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMaxTrustScore\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getDefaultDomain\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getDomainOfToken\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"name\":\"getDomainOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"name\":\"getDomainTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"name\":\"getTrustScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTrustScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"ttl\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"DNSSEC\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"setAsDefault\",\"type\":\"bool\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetDefaultDomainToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"setChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"score\",\"type\":\"uint8\"}],\"name\":\"setCurrentMaxTrustScore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"setDefaultDomainToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Decurly","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000744656375726c790000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034445430000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001264656375726c792e636f6d2f746f6b656e2f0000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3b0fb1f09381a34e411dfcbff60658771c0f45e8d9b6d403d53659406e5aeed0"}]}