{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n// @title Meowshi (MEOW) 🐈 🍣 🍱\r\n// @author Gatoshi Nyakamoto\r\n\r\npragma solidity 0.8.4;\r\n\r\n/// @notice Interface for depositing into & withdrawing from BentoBox vault.\r\ninterface IERC20{} interface IBentoBoxBasic {\r\n    function deposit( \r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    function withdraw(\r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256 amountOut, uint256 shareOut);\r\n}\r\n\r\n/// @notice Interface for depositing into & withdrawing from SushiBar.\r\ninterface ISushiBar { \r\n    function balanceOf(address account) external view returns (uint256);\r\n    function enter(uint256 amount) external;\r\n    function leave(uint256 share) external;\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n/// @notice Meowshi takes SUSHI/xSUSHI to mint governing MEOW tokens that can be burned to claim SUSHI/xSUSHI from BENTO with yields.\r\n//  ៱˳_˳៱   ∫\r\ncontract Meowshi {\r\n    IBentoBoxBasic constant bento = IBentoBoxBasic(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966); // BENTO vault contract (multinet)\r\n    ISushiBar constant sushiToken = ISushiBar(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2); // SUSHI token contract (mainnet)\r\n    address constant sushiBar = 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272; // xSUSHI token contract for staking SUSHI (mainnet)\r\n    string constant public name = \"Meowshi\";\r\n    string constant public symbol = \"MEOW\";\r\n    uint8 constant public decimals = 18;\r\n    uint256 constant multiplier = 100_000; // 1 xSUSHI BENTO share = 100,000 MEOW\r\n    uint256 public totalSupply;\r\n    \r\n    /// @notice owner -> spender -> allowance mapping.\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    /// @notice owner -> balance mapping.\r\n    mapping(address => uint256) public balanceOf;\r\n    /// @notice owner -> nonce mapping used in {permit}.\r\n    mapping(address => uint256) public nonces;\r\n    /// @notice A record of each account's delegate.\r\n    mapping(address => address) public delegates;\r\n    /// @notice A record of voting checkpoints for each account, by index.\r\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\r\n    /// @notice The number of checkpoints for each account.\r\n    mapping(address => uint32) public numCheckpoints;\r\n    /// @notice The ERC-712 typehash for this contract's domain.\r\n    bytes32 constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n    /// @notice The ERC-712 typehash for the delegation struct used by the contract.\r\n    bytes32 constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n    /// @notice The ERC-712 typehash for the {permit} struct used by the contract.\r\n    bytes32 constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    /// @notice Events that are emitted when an ERC-20 approval or transfer occurs. \r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    /// @notice An event that's emitted when an account changes its delegate.\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n    /// @notice An event that's emitted when a delegate account's vote balance changes.\r\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\r\n    \r\n    /// @notice A checkpoint for marking number of votes from a given block.\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint96 votes;\r\n    }\r\n    \r\n    constructor() {\r\n        sushiToken.approve(sushiBar, type(uint256).max); // max {approve} xSUSHI to draw SUSHI from this contract\r\n        ISushiBar(sushiBar).approve(address(bento), type(uint256).max); // max {approve} BENTO to draw xSUSHI from this contract\r\n    }\r\n    \r\n    /// @notice Enables calling multiple methods in a single call to this contract.\r\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        unchecked {for (uint256 i = 0; i < data.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n            if (!success) {\r\n                if (result.length < 68) revert();\r\n                assembly {result := add(result, 0x04)}\r\n                revert(abi.decode(result, (string)));\r\n            }\r\n            results[i] = result;}}\r\n    }\r\n\r\n    /*************\r\n    MEOW FUNCTIONS\r\n    *************/\r\n    // **** xSUSHI\r\n    /// @notice Enter Meowshi. Deposit xSUSHI `amount`. Mint MEOW for `to`.\r\n    function meow(address to, uint256 amount) external returns (uint256 shares) {\r\n        ISushiBar(sushiBar).transferFrom(msg.sender, address(bento), amount); // forward to BENTO for skim\r\n        (, shares) = bento.deposit(IERC20(sushiBar), address(bento), address(this), amount, 0);\r\n        meowMint(to, shares * multiplier);\r\n    }\r\n\r\n    /// @notice Leave Meowshi. Burn MEOW `amount`. Claim xSUSHI for `to`.\r\n    function unmeow(address to, uint256 amount) external returns (uint256 amountOut) {\r\n        meowBurn(amount);\r\n        unchecked {(amountOut, ) = bento.withdraw(IERC20(sushiBar), address(this), to, 0, amount / multiplier);}\r\n    }\r\n    \r\n    // **** SUSHI\r\n    /// @notice Enter Meowshi. Deposit SUSHI `amount`. Mint MEOW for `to`.\r\n    function meowSushi(address to, uint256 amount) external returns (uint256 shares) {\r\n        sushiToken.transferFrom(msg.sender, address(this), amount);\r\n        ISushiBar(sushiBar).enter(amount);\r\n        (, shares) = bento.deposit(IERC20(sushiBar), address(this), address(this), ISushiBar(sushiBar).balanceOf(address(this)), 0);\r\n        meowMint(to, shares * multiplier);\r\n    }\r\n\r\n    /// @notice Leave Meowshi. Burn MEOW `amount`. Claim SUSHI for `to`.\r\n    function unmeowSushi(address to, uint256 amount) external returns (uint256 amountOut) {\r\n        meowBurn(amount);\r\n        unchecked {(amountOut, ) = bento.withdraw(IERC20(sushiBar), address(this), address(this), 0, amount / multiplier);}\r\n        ISushiBar(sushiBar).leave(amountOut);\r\n        sushiToken.transfer(to, sushiToken.balanceOf(address(this))); \r\n    }\r\n\r\n    // **** SUPPLY MGMT\r\n    /// @notice Internal mint function for *meow*.\r\n    function meowMint(address to, uint256 amount) private {\r\n        balanceOf[to] += amount;\r\n        totalSupply += amount;\r\n        _moveDelegates(address(0), delegates[to], amount);\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n    \r\n    /// @notice Internal burn function for *unmeow*.\r\n    function meowBurn(uint256 amount) private {\r\n        balanceOf[msg.sender] -= amount;\r\n        unchecked {totalSupply -= amount;}\r\n        _moveDelegates(delegates[msg.sender], address(0), amount);\r\n        emit Transfer(msg.sender, address(0), amount);\r\n    }\r\n    \r\n    /**************\r\n    TOKEN FUNCTIONS\r\n    **************/\r\n    /// @notice Approves `amount` from msg.sender to be spent by `spender`.\r\n    /// @param spender Address of the party that can draw tokens from msg.sender's account.\r\n    /// @param amount The maximum collective `amount` that `spender` can draw.\r\n    /// @return (bool) Returns 'true' if succeeded.\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Triggers an approval from owner to spends.\r\n    /// @param owner The address to approve from.\r\n    /// @param spender The address to be approved.\r\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite).\r\n    /// @param deadline The time at which to expire the signature.\r\n    /// @param v The recovery byte of the signature.\r\n    /// @param r Half of the ECDSA signature pair.\r\n    /// @param s Half of the ECDSA signature pair.\r\n    function permit(address owner, address spender, uint256 amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        unchecked {bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s); \r\n        require(signatory != address(0), 'Meowshi::permit: invalid signature');\r\n        require(signatory == owner, 'Meowshi::permit: unauthorized');}\r\n        require(block.timestamp <= deadline, 'Meowshi::permit: signature expired');\r\n        allowance[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    \r\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\r\n    /// @param to The address to move tokens `to`.\r\n    /// @param amount The token `amount` to move.\r\n    /// @return (bool) Returns 'true' if succeeded.\r\n    function transfer(address to, uint256 amount) external returns (bool) {\r\n        balanceOf[msg.sender] -= amount; \r\n        unchecked {balanceOf[to] += amount;}\r\n        _moveDelegates(delegates[msg.sender], delegates[to], amount);\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval from `from`.\r\n    /// @param from Address to draw tokens `from`.\r\n    /// @param to The address to move tokens `to`.\r\n    /// @param amount The token `amount` to move.\r\n    /// @return (bool) Returns 'true' if succeeded.\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\r\n        if (allowance[from][msg.sender] != type(uint256).max) {allowance[from][msg.sender] -= amount;}\r\n        balanceOf[from] -= amount;\r\n        unchecked {balanceOf[to] += amount;}\r\n        _moveDelegates(delegates[from], delegates[to], amount);\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n    \r\n    /*******************\r\n    DELEGATION FUNCTIONS\r\n    *******************/\r\n    /// @notice Delegate votes from `msg.sender` to `delegatee`.\r\n    /// @param delegatee The address to delegate votes to.\r\n    function delegate(address delegatee) external {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /// @notice Delegates votes from signatory to `delegatee`.\r\n    /// @param delegatee The address to delegate votes to.\r\n    /// @param nonce The contract state required to match the signature.\r\n    /// @param expiry The time at which to expire the signature.\r\n    /// @param v The recovery byte of the signature.\r\n    /// @param r Half of the ECDSA signature pair.\r\n    /// @param s Half of the ECDSA signature pair.\r\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), 'Meowshi::delegateBySig: invalid signature');\r\n        unchecked {require(nonce == nonces[signatory]++, 'Meowshi::delegateBySig: invalid nonce');}\r\n        require(block.timestamp <= expiry, 'Meowshi::delegateBySig: signature expired');\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n    \r\n    function _delegate(address delegator, address delegatee) private {\r\n        address currentDelegate = delegates[delegator]; \r\n        delegates[delegator] = delegatee;\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n        _moveDelegates(currentDelegate, delegatee, balanceOf[delegator]);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) private {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            unchecked {if (srcRep != address(0)) {\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint256 srcRepNew = srcRepOld - amount;\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint256 dstRepNew = dstRepOld + amount;\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }}\r\n        }\r\n    }\r\n    \r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes) private {\r\n        if (block.number < 2**32) { // overflow check for casting - we don't want to prevent MEOW burns\r\n            uint32 blockNumber = uint32(block.number);\r\n        unchecked {if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = _safe96(newVotes);\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, _safe96(newVotes));\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;}}\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);}\r\n    }\r\n    \r\n    function _safe96(uint256 n) private pure returns (uint96) {\r\n        require(n < 2**96, 'Meowshi::amount exceeds 96 bits'); \r\n        return uint96(n);\r\n    }\r\n    \r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n    /// @notice Get current chain. \r\n    function getChainId() private view returns (uint256) {\r\n        uint256 chainId;\r\n        assembly {chainId := chainid()}\r\n        return chainId;\r\n    }\r\n\r\n    /// @notice Gets the current votes balance for `account`.\r\n    /// @param account The address to get votes balance.\r\n    /// @return The number of current votes for `account`.\r\n    function getCurrentVotes(address account) external view returns (uint256) {\r\n        unchecked {uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;}\r\n    }\r\n\r\n    /// @notice Determine the prior number of votes for an `account` as of a block number.\r\n    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n    /// @param account The address of the `account` to check.\r\n    /// @param blockNumber The block number to get the vote balance at.\r\n    /// @return The number of votes the `account` had as of the given block.\r\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256) {\r\n        require(blockNumber < block.number, 'Meowshi::getPriorVotes: not yet determined');\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {return 0;}\r\n        // @dev First check most recent balance.\r\n        unchecked {if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {return checkpoints[account][nCheckpoints - 1].votes;}\r\n        // @dev Next check implicit zero balance.\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {return 0;}\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2;\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {upper = center - 1;}}\r\n        return checkpoints[account][lower].votes;}\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"checkpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fromBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"votes\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"delegateBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCurrentVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPriorVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"meow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"meowSushi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numCheckpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unmeow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unmeowSushi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Meowshi","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://89785668526fe6c44054d13ddfcf9e0c0e411d5ae8ee7be027ca4d2c9684f703"}]}