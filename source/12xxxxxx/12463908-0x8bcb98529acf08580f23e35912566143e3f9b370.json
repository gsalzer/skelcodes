{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/GebProxySaviourActions.sol\npragma solidity =0.6.7 >=0.6.7;\n\n////// lib/geb-proxy-registry/lib/ds-proxy/lib/ds-auth/src/auth.sol\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.6.7; */\n\ninterface DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) external view returns (bool);\n}\n\nabstract contract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        virtual\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        virtual\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) virtual internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n////// src/GebProxyActions.sol\n/// GebProxyActions.sol\n\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity 0.6.7; */\n\n/* import \"ds-auth/auth.sol\"; */\n\nabstract contract CollateralLike_3 {\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public;\n    function transferFrom(address, address, uint) virtual public;\n    function deposit() virtual public payable;\n    function withdraw(uint) virtual public;\n}\n\nabstract contract ManagerLike {\n    function safeCan(address, uint, address) virtual public view returns (uint);\n    function collateralTypes(uint) virtual public view returns (bytes32);\n    function ownsSAFE(uint) virtual public view returns (address);\n    function safes(uint) virtual public view returns (address);\n    function safeEngine() virtual public view returns (address);\n    function openSAFE(bytes32, address) virtual public returns (uint);\n    function transferSAFEOwnership(uint, address) virtual public;\n    function allowSAFE(uint, address, uint) virtual public;\n    function allowHandler(address, uint) virtual public;\n    function modifySAFECollateralization(uint, int, int) virtual public;\n    function transferCollateral(uint, address, uint) virtual public;\n    function transferInternalCoins(uint, address, uint) virtual public;\n    function quitSystem(uint, address) virtual public;\n    function enterSystem(address, uint) virtual public;\n    function moveSAFE(uint, uint) virtual public;\n    function protectSAFE(uint, address, address) virtual public;\n}\n\nabstract contract SAFEEngineLike_15 {\n    function canModifySAFE(address, address) virtual public view returns (uint);\n    function collateralTypes(bytes32) virtual public view returns (uint, uint, uint, uint, uint);\n    function coinBalance(address) virtual public view returns (uint);\n    function safes(bytes32, address) virtual public view returns (uint, uint);\n    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;\n    function approveSAFEModification(address) virtual public;\n    function transferInternalCoins(address, address, uint) virtual public;\n}\n\nabstract contract CollateralJoinLike_2 {\n    function decimals() virtual public returns (uint);\n    function collateral() virtual public returns (CollateralLike_3);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n\nabstract contract GNTJoinLike {\n    function bags(address) virtual public view returns (address);\n    function make(address) virtual public returns (address);\n}\n\nabstract contract DSTokenLike_3 {\n    function balanceOf(address) virtual public view returns (uint);\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public returns (bool);\n    function transferFrom(address, address, uint) virtual public returns (bool);\n}\n\nabstract contract WethLike {\n    function balanceOf(address) virtual public view returns (uint);\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public;\n    function transferFrom(address, address, uint) virtual public;\n    function deposit() virtual public payable;\n    function withdraw(uint) virtual public;\n}\n\nabstract contract CoinJoinLike_3 {\n    function safeEngine() virtual public returns (SAFEEngineLike_15);\n    function systemCoin() virtual public returns (DSTokenLike_3);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n\nabstract contract ApproveSAFEModificationLike {\n    function approveSAFEModification(address) virtual public;\n    function denySAFEModification(address) virtual public;\n}\n\nabstract contract GlobalSettlementLike_3 {\n    function collateralCashPrice(bytes32) virtual public view returns (uint);\n    function redeemCollateral(bytes32, uint) virtual public;\n    function freeCollateral(bytes32) virtual public;\n    function prepareCoinsForRedeeming(uint) virtual public;\n    function processSAFE(bytes32, address) virtual public;\n}\n\nabstract contract TaxCollectorLike {\n    function taxSingle(bytes32) virtual public returns (uint);\n}\n\nabstract contract CoinSavingsAccountLike_2 {\n    function savings(address) virtual public view returns (uint);\n    function updateAccumulatedRate() virtual public returns (uint);\n    function deposit(uint) virtual public;\n    function withdraw(uint) virtual public;\n}\n\nabstract contract ProxyRegistryLike {\n    function proxies(address) virtual public view returns (address);\n    function build(address) virtual public returns (address);\n}\n\nabstract contract ProxyLike {\n    function owner() virtual public view returns (address);\n}\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ncontract Common {\n    uint256 constant RAY = 10 ** 27;\n\n    // Internal functions\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n    }\n\n    function _coinJoin_join(address apt, address safeHandler, uint wad) internal {\n        // Approves adapter to take the COIN amount\n        CoinJoinLike_3(apt).systemCoin().approve(apt, wad);\n        // Joins COIN into the safeEngine\n        CoinJoinLike_3(apt).join(safeHandler, wad);\n    }\n\n    // Public functions\n    function coinJoin_join(address apt, address safeHandler, uint wad) public {\n        // Gets COIN from the user's wallet\n        CoinJoinLike_3(apt).systemCoin().transferFrom(msg.sender, address(this), wad);\n\n        _coinJoin_join(apt, safeHandler, wad);\n    }\n}\n\ncontract BasicActions is Common {\n    // Internal functions\n\n    /// @notice Safe subtraction\n    /// @dev Reverts on overflows\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    /// @notice Safe conversion uint -> int\n    /// @dev Reverts on overflows\n    function toInt(uint x) internal pure returns (int y) {\n        y = int(x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    /// @notice Converts a wad (18 decimal places) to rad (45 decimal places)\n    function toRad(uint wad) internal pure returns (uint rad) {\n        rad = multiply(wad, 10 ** 27);\n    }\n\n    function convertTo18(address collateralJoin, uint256 amt) internal returns (uint256 wad) {\n        // For those collaterals that have other than 18 decimals precision we need to do the conversion before passing to modifySAFECollateralization function\n        // Adapters will automatically handle the difference of precision\n        uint decimals = CollateralJoinLike_2(collateralJoin).decimals();\n        wad = amt;\n        if (decimals < 18) {\n          wad = multiply(\n              amt,\n              10 ** (18 - decimals)\n          );\n        } else if (decimals > 18) {\n          wad = amt / 10 ** (decimals - 18);\n        }\n    }\n\n    /// @notice Gets delta debt generated (Total Safe debt minus available safeHandler COIN balance)\n    /// @param safeEngine address\n    /// @param taxCollector address\n    /// @param safeHandler address\n    /// @param collateralType bytes32\n    /// @return deltaDebt\n    function _getGeneratedDeltaDebt(\n        address safeEngine,\n        address taxCollector,\n        address safeHandler,\n        bytes32 collateralType,\n        uint wad\n    ) internal returns (int deltaDebt) {\n        // Updates stability fee rate\n        uint rate = TaxCollectorLike(taxCollector).taxSingle(collateralType);\n        require(rate > 0, \"invalid-collateral-type\");\n\n        // Gets COIN balance of the handler in the safeEngine\n        uint coin = SAFEEngineLike_15(safeEngine).coinBalance(safeHandler);\n\n        // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n        if (coin < multiply(wad, RAY)) {\n            // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n            deltaDebt = toInt(subtract(multiply(wad, RAY), coin) / rate);\n            // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n            deltaDebt = multiply(uint(deltaDebt), rate) < multiply(wad, RAY) ? deltaDebt + 1 : deltaDebt;\n        }\n    }\n\n    /// @notice Gets repaid delta debt generated (rate adjusted debt)\n    /// @param safeEngine address\n    /// @param coin uint amount\n    /// @param safe uint - safeId\n    /// @param collateralType bytes32\n        /// @return deltaDebt\n    function _getRepaidDeltaDebt(\n        address safeEngine,\n        uint coin,\n        address safe,\n        bytes32 collateralType\n    ) internal view returns (int deltaDebt) {\n        // Gets actual rate from the safeEngine\n        (, uint rate,,,) = SAFEEngineLike_15(safeEngine).collateralTypes(collateralType);\n        require(rate > 0, \"invalid-collateral-type\");\n\n        // Gets actual generatedDebt value of the safe\n        (, uint generatedDebt) = SAFEEngineLike_15(safeEngine).safes(collateralType, safe);\n\n        // Uses the whole coin balance in the safeEngine to reduce the debt\n        deltaDebt = toInt(coin / rate);\n        // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n        deltaDebt = uint(deltaDebt) <= generatedDebt ? - deltaDebt : - toInt(generatedDebt);\n    }\n\n    /// @notice Gets repaid debt (rate adjusted rate minus COIN balance available in usr's address)\n    /// @param safeEngine address\n    /// @param usr address\n    /// @param safe uint\n    /// @param collateralType address\n    /// @return wad\n    function _getRepaidAlDebt(\n        address safeEngine,\n        address usr,\n        address safe,\n        bytes32 collateralType\n    ) internal view returns (uint wad) {\n        // Gets actual rate from the safeEngine\n        (, uint rate,,,) = SAFEEngineLike_15(safeEngine).collateralTypes(collateralType);\n        // Gets actual generatedDebt value of the safe\n        (, uint generatedDebt) = SAFEEngineLike_15(safeEngine).safes(collateralType, safe);\n        // Gets actual coin amount in the safe\n        uint coin = SAFEEngineLike_15(safeEngine).coinBalance(usr);\n\n        uint rad = subtract(multiply(generatedDebt, rate), coin);\n        wad = rad / RAY;\n\n        // If the rad precision has some dust, it will need to request for 1 extra wad wei\n        wad = multiply(wad, RAY) < rad ? wad + 1 : wad;\n    }\n\n    /// @notice Generates Debt (and sends coin balance to address to)\n    /// @param manager address\n    /// @param taxCollector address\n    /// @param coinJoin address\n    /// @param safe uint\n    /// @param wad uint - amount of debt to be generated\n    /// @param to address - receiver of the balance of generated COIN\n    function _generateDebt(address manager, address taxCollector, address coinJoin, uint safe, uint wad, address to) internal {\n        address safeHandler = ManagerLike(manager).safes(safe);\n        address safeEngine = ManagerLike(manager).safeEngine();\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        // Generates debt in the SAFE\n        modifySAFECollateralization(manager, safe, 0, _getGeneratedDeltaDebt(safeEngine, taxCollector, safeHandler, collateralType, wad));\n        // Moves the COIN amount (balance in the safeEngine in rad) to proxy's address\n        transferInternalCoins(manager, safe, address(this), toRad(wad));\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (SAFEEngineLike_15(safeEngine).canModifySAFE(address(this), address(coinJoin)) == 0) {\n            SAFEEngineLike_15(safeEngine).approveSAFEModification(coinJoin);\n        }\n        // Exits COIN to this contract\n        CoinJoinLike_3(coinJoin).exit(to, wad);\n    }\n\n    /// @notice Generates Debt (and sends coin balance to address to)\n    /// @param manager address\n    /// @param ethJoin address\n    /// @param safe uint\n    /// @param value uint - amount of ETH to be locked in the Safe.\n    /// @dev Proxy needs to have enough balance (> value), public functions should handle this.\n    function _lockETH(\n        address manager,\n        address ethJoin,\n        uint safe,\n        uint value\n    ) internal {\n        // Receives ETH amount, converts it to WETH and joins it into the safeEngine\n        ethJoin_join(ethJoin, address(this), value);\n        // Locks WETH amount into the SAFE\n        SAFEEngineLike_15(ManagerLike(manager).safeEngine()).modifySAFECollateralization(\n            ManagerLike(manager).collateralTypes(safe),\n            ManagerLike(manager).safes(safe),\n            address(this),\n            address(this),\n            toInt(value),\n            0\n        );\n    }\n\n    /// @notice Repays debt\n    /// @param manager address\n    /// @param coinJoin address\n    /// @param safe uint\n    /// @param wad uint - amount of debt to be repayed\n    function _repayDebt(\n        address manager,\n        address coinJoin,\n        uint safe,\n        uint wad,\n        bool transferFromCaller\n    ) internal {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safeHandler = ManagerLike(manager).safes(safe);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n\n        address own = ManagerLike(manager).ownsSAFE(safe);\n        if (own == address(this) || ManagerLike(manager).safeCan(own, safe, address(this)) == 1) {\n            // Joins COIN amount into the safeEngine\n            if (transferFromCaller) coinJoin_join(coinJoin, safeHandler, wad);\n            else _coinJoin_join(coinJoin, safeHandler, wad);\n            // // Paybacks debt to the SAFE\n            modifySAFECollateralization(manager, safe, 0, _getRepaidDeltaDebt(safeEngine, SAFEEngineLike_15(safeEngine).coinBalance(safeHandler), safeHandler, collateralType));\n        } else {\n             // Joins COIN amount into the safeEngine\n            if (transferFromCaller) coinJoin_join(coinJoin, address(this), wad);\n            else _coinJoin_join(coinJoin, address(this), wad);\n            // Paybacks debt to the SAFE\n            SAFEEngineLike_15(safeEngine).modifySAFECollateralization(\n                collateralType,\n                safeHandler,\n                address(this),\n                address(this),\n                0,\n                _getRepaidDeltaDebt(safeEngine, wad * RAY, safeHandler, collateralType)\n            );\n        }\n    }\n\n    /// @notice Repays debt and frees collateral ETH\n    /// @param manager address\n    /// @param ethJoin address\n    /// @param coinJoin address\n    /// @param safe uint\n    /// @param collateralWad uint - amount of ETH to free\n    /// @param deltaWad uint - amount of debt to be repayed\n    /// @param transferFromCaller True if transferring coin from caller, false if balance in the proxy\n    function _repayDebtAndFreeETH(\n        address manager,\n        address ethJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralWad,\n        uint deltaWad,\n        bool transferFromCaller\n    ) internal {\n        address safeHandler = ManagerLike(manager).safes(safe);\n        // Joins COIN amount into the safeEngine\n        if (transferFromCaller) coinJoin_join(coinJoin, safeHandler, deltaWad);\n        else _coinJoin_join(coinJoin, safeHandler, deltaWad);\n        // Paybacks debt to the SAFE and unlocks WETH amount from it\n        modifySAFECollateralization(\n            manager,\n            safe,\n            -toInt(collateralWad),\n            _getRepaidDeltaDebt(ManagerLike(manager).safeEngine(), SAFEEngineLike_15(ManagerLike(manager).safeEngine()).coinBalance(safeHandler), safeHandler, ManagerLike(manager).collateralTypes(safe))\n        );\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), collateralWad);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike_2(ethJoin).exit(address(this), collateralWad);\n        // Converts WETH to ETH\n        CollateralJoinLike_2(ethJoin).collateral().withdraw(collateralWad);\n    }\n\n    // Public functions\n\n    /// @notice ERC20 transfer\n    /// @param collateral address - address of ERC20 collateral\n    /// @param dst address - Transfer destination\n    /// @param amt address - Amount to transfer\n    function transfer(address collateral, address dst, uint amt) external {\n        CollateralLike_3(collateral).transfer(dst, amt);\n    }\n\n    /// @notice Joins the system with the full msg.value\n    /// @param apt address - Address of the adapter\n    /// @param safe uint - Safe Id\n    function ethJoin_join(address apt, address safe) external payable {\n        ethJoin_join(apt, safe, msg.value);\n    }\n\n    /// @notice Joins the system with the a specified value\n    /// @param apt address - Address of the adapter\n    /// @param safe uint - Safe Id\n    /// @param value uint - Value to join\n    function ethJoin_join(address apt, address safe, uint value) public payable {\n        // Wraps ETH in WETH\n        CollateralJoinLike_2(apt).collateral().deposit{value: value}();\n        // Approves adapter to take the WETH amount\n        CollateralJoinLike_2(apt).collateral().approve(address(apt), value);\n        // Joins WETH collateral into the safeEngine\n        CollateralJoinLike_2(apt).join(safe, value);\n    }\n\n    /// @notice Approves an address to modify the Safe\n    /// @param safeEngine address\n    /// @param usr address - Address allowed to modify Safe\n    function approveSAFEModification(\n        address safeEngine,\n        address usr\n    ) external {\n        ApproveSAFEModificationLike(safeEngine).approveSAFEModification(usr);\n    }\n\n    /// @notice Denies an address to modify the Safe\n    /// @param safeEngine address\n    /// @param usr address - Address disallowed to modify Safe\n    function denySAFEModification(\n        address safeEngine,\n        address usr\n    ) external {\n        ApproveSAFEModificationLike(safeEngine).denySAFEModification(usr);\n    }\n\n    /// @notice Opens a brand new Safe\n    /// @param manager address - Safe Manager\n    /// @param collateralType bytes32 - collateral type\n    /// @param usr address - Owner of the safe\n    function openSAFE(\n        address manager,\n        bytes32 collateralType,\n        address usr\n    ) public returns (uint safe) {\n        safe = ManagerLike(manager).openSAFE(collateralType, usr);\n    }\n\n    /// @notice Transfer the ownership of a proxy owned Safe\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param usr address - Owner of the safe\n    function transferSAFEOwnership(\n        address manager,\n        uint safe,\n        address usr\n    ) public {\n        ManagerLike(manager).transferSAFEOwnership(safe, usr);\n    }\n\n    /// @notice Transfer the ownership to a new proxy owned by a different address\n    /// @param proxyRegistry address - Safe Manager\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param dst address - Owner of the new proxy\n    function transferSAFEOwnershipToProxy(\n        address proxyRegistry,\n        address manager,\n        uint safe,\n        address dst\n    ) external {\n        // Gets actual proxy address\n        address proxy = ProxyRegistryLike(proxyRegistry).proxies(dst);\n        // Checks if the proxy address already existed and dst address is still the owner\n        if (proxy == address(0) || ProxyLike(proxy).owner() != dst) {\n            uint csize;\n            assembly {\n                csize := extcodesize(dst)\n            }\n            // We want to avoid creating a proxy for a contract address that might not be able to handle proxies, then losing the SAFE\n            require(csize == 0, \"dst-is-a-contract\");\n            // Creates the proxy for the dst address\n            proxy = ProxyRegistryLike(proxyRegistry).build(dst);\n        }\n        // Transfers SAFE to the dst proxy\n        transferSAFEOwnership(manager, safe, proxy);\n    }\n\n    /// @notice Allow/disallow a usr address to manage the safe\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param usr address - usr address\n    /// uint ok - 1 for allowed\n    function allowSAFE(\n        address manager,\n        uint safe,\n        address usr,\n        uint ok\n    ) external {\n        ManagerLike(manager).allowSAFE(safe, usr, ok);\n    }\n\n    /// @notice Allow/disallow a usr address to quit to the sender handler\n    /// @param manager address - Safe Manager\n    /// @param usr address - usr address\n    /// uint ok - 1 for allowed\n    function allowHandler(\n        address manager,\n        address usr,\n        uint ok\n    ) external {\n        ManagerLike(manager).allowHandler(usr, ok);\n    }\n\n    /// @notice Transfer wad amount of safe collateral from the safe address to a dst address.\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param dst address - destination address\n    /// uint wad - amount\n    function transferCollateral(\n        address manager,\n        uint safe,\n        address dst,\n        uint wad\n    ) public {\n        ManagerLike(manager).transferCollateral(safe, dst, wad);\n    }\n\n    /// @notice Transfer rad amount of COIN from the safe address to a dst address.\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param dst address - destination address\n    /// uint rad - amount\n    function transferInternalCoins(\n        address manager,\n        uint safe,\n        address dst,\n        uint rad\n    ) public {\n        ManagerLike(manager).transferInternalCoins(safe, dst, rad);\n    }\n\n\n    /// @notice Modify a SAFE's collateralization ratio while keeping the generated COIN or collateral freed in the SAFE handler address.\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param deltaCollateral - int\n    /// @param deltaDebt - int\n    function modifySAFECollateralization(\n        address manager,\n        uint safe,\n        int deltaCollateral,\n        int deltaDebt\n    ) public {\n        ManagerLike(manager).modifySAFECollateralization(safe, deltaCollateral, deltaDebt);\n    }\n\n    /// @notice Quit the system, migrating the safe (lockedCollateral, generatedDebt) to a different dst handler\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param dst - destination handler\n    function quitSystem(\n        address manager,\n        uint safe,\n        address dst\n    ) external {\n        ManagerLike(manager).quitSystem(safe, dst);\n    }\n\n    /// @notice Import a position from src handler to the handler owned by safe\n    /// @param manager address - Safe Manager\n    /// @param src - source handler\n    /// @param safe uint - Safe Id\n    function enterSystem(\n        address manager,\n        address src,\n        uint safe\n    ) external {\n        ManagerLike(manager).enterSystem(src, safe);\n    }\n\n    /// @notice Move a position from safeSrc handler to the safeDst handler\n    /// @param manager address - Safe Manager\n    /// @param safeSrc uint - Source Safe Id\n    /// @param safeDst uint - Destination Safe Id\n    function moveSAFE(\n        address manager,\n        uint safeSrc,\n        uint safeDst\n    ) external {\n        ManagerLike(manager).moveSAFE(safeSrc, safeDst);\n    }\n\n    /// @notice Lock ETH (msg.value) as collateral in safe\n    /// @param manager address - Safe Manager\n    /// @param ethJoin address\n    /// @param safe uint - Safe Id\n    function lockETH(\n        address manager,\n        address ethJoin,\n        uint safe\n    ) public payable {\n        _lockETH(manager, ethJoin, safe, msg.value);\n    }\n\n    /// @notice Free ETH (wad) from safe and sends it to msg.sender\n    /// @param manager address - Safe Manager\n    /// @param ethJoin address\n    /// @param safe uint - Safe Id\n    /// @param wad uint - Amount\n    function freeETH(\n        address manager,\n        address ethJoin,\n        uint safe,\n        uint wad\n    ) public {\n        // Unlocks WETH amount from the SAFE\n        modifySAFECollateralization(manager, safe, -toInt(wad), 0);\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), wad);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike_2(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        CollateralJoinLike_2(ethJoin).collateral().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n\n\n    /// @notice Exits ETH (wad) from balance available in the handler\n    /// @param manager address - Safe Manager\n    /// @param ethJoin address\n    /// @param safe uint - Safe Id\n    /// @param wad uint - Amount\n    function exitETH(\n        address manager,\n        address ethJoin,\n        uint safe,\n        uint wad\n    ) external {\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), wad);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike_2(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        CollateralJoinLike_2(ethJoin).collateral().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n\n    /// @notice Generates debt and sends COIN amount to msg.sender\n    /// @param manager address\n    /// @param taxCollector address\n    /// @param coinJoin address\n    /// @param safe uint - Safe Id\n    /// @param wad uint - Amount\n    function generateDebt(\n        address manager,\n        address taxCollector,\n        address coinJoin,\n        uint safe,\n        uint wad\n    ) public {\n        _generateDebt(manager, taxCollector, coinJoin, safe, wad, msg.sender);\n    }\n\n    /// @notice Repays debt\n    /// @param manager address\n    /// @param coinJoin address\n    /// @param safe uint - Safe Id\n    /// @param wad uint - Amount\n    function repayDebt(\n        address manager,\n        address coinJoin,\n        uint safe,\n        uint wad\n    ) public {\n        _repayDebt(manager, coinJoin, safe, wad, true);\n    }\n\n    /// @notice Locks Eth, generates debt and sends COIN amount (deltaWad) to msg.sender\n    /// @param manager address\n    /// @param taxCollector address\n    /// @param ethJoin address\n    /// @param coinJoin address\n    /// @param safe uint - Safe Id\n    /// @param deltaWad uint - Amount\n    function lockETHAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address ethJoin,\n        address coinJoin,\n        uint safe,\n        uint deltaWad\n    ) public payable {\n        _lockETH(manager, ethJoin, safe, msg.value);\n        _generateDebt(manager, taxCollector, coinJoin, safe, deltaWad, msg.sender);\n    }\n\n    /// @notice Opens Safe, locks Eth, generates debt and sends COIN amount (deltaWad) to msg.sender\n    /// @param manager address\n    /// @param taxCollector address\n    /// @param ethJoin address\n    /// @param coinJoin address\n    /// @param deltaWad uint - Amount\n    function openLockETHAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address ethJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint deltaWad\n    ) external payable returns (uint safe) {\n        safe = openSAFE(manager, collateralType, address(this));\n        lockETHAndGenerateDebt(manager, taxCollector, ethJoin, coinJoin, safe, deltaWad);\n    }\n\n    /// @notice Repays debt and frees ETH (sends it to msg.sender)\n    /// @param manager address\n    /// @param ethJoin address\n    /// @param coinJoin address\n    /// @param safe uint - Safe Id\n    /// @param collateralWad uint - Amount of collateral to free\n    /// @param deltaWad uint - Amount of debt to repay\n    function repayDebtAndFreeETH(\n        address manager,\n        address ethJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralWad,\n        uint deltaWad\n    ) external {\n        _repayDebtAndFreeETH(manager, ethJoin, coinJoin, safe, collateralWad, deltaWad, true);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(collateralWad);\n    }    \n}\n\ncontract GebProxyActions is BasicActions {\n\n    function tokenCollateralJoin_join(address apt, address safe, uint amt, bool transferFrom) public {\n        // Only executes for tokens that have approval/transferFrom implementation\n        if (transferFrom) {\n            // Gets token from the user's wallet\n            CollateralJoinLike_2(apt).collateral().transferFrom(msg.sender, address(this), amt);\n            // Approves adapter to take the token amount\n            CollateralJoinLike_2(apt).collateral().approve(apt, amt);\n        }\n        // Joins token collateral into the safeEngine\n        CollateralJoinLike_2(apt).join(safe, amt);\n    }\n\n    function protectSAFE(\n        address manager,\n        uint safe,\n        address liquidationEngine,\n        address saviour\n    ) public {\n        ManagerLike(manager).protectSAFE(safe, liquidationEngine, saviour);\n    }\n\n    function makeCollateralBag(\n        address collateralJoin\n    ) public returns (address bag) {\n        bag = GNTJoinLike(collateralJoin).make(address(this));\n    }\n\n    function safeLockETH(\n        address manager,\n        address ethJoin,\n        uint safe,\n        address owner\n    ) public payable {\n        require(ManagerLike(manager).ownsSAFE(safe) == owner, \"owner-missmatch\");\n        lockETH(manager, ethJoin, safe);\n    }\n\n    function lockTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint safe,\n        uint amt,\n        bool transferFrom\n    ) public {\n        // Takes token amount from user's wallet and joins into the safeEngine\n        tokenCollateralJoin_join(collateralJoin, address(this), amt, transferFrom);\n        // Locks token amount into the SAFE\n        SAFEEngineLike_15(ManagerLike(manager).safeEngine()).modifySAFECollateralization(\n            ManagerLike(manager).collateralTypes(safe),\n            ManagerLike(manager).safes(safe),\n            address(this),\n            address(this),\n            toInt(convertTo18(collateralJoin, amt)),\n            0\n        );\n    }\n\n    function safeLockTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint safe,\n        uint amt,\n        bool transferFrom,\n        address owner\n    ) public {\n        require(ManagerLike(manager).ownsSAFE(safe) == owner, \"owner-missmatch\");\n        lockTokenCollateral(manager, collateralJoin, safe, amt, transferFrom);\n    }\n\n    function freeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint safe,\n        uint amt\n    ) public {\n        uint wad = convertTo18(collateralJoin, amt);\n        // Unlocks token amount from the SAFE\n        modifySAFECollateralization(manager, safe, -toInt(wad), 0);\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), wad);\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike_2(collateralJoin).exit(msg.sender, amt);\n    }\n\n    function exitTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint safe,\n        uint amt\n    ) public {\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), convertTo18(collateralJoin, amt));\n\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike_2(collateralJoin).exit(msg.sender, amt);\n    }\n\n    function generateDebtAndProtectSAFE(\n        address manager,\n        address taxCollector,\n        address coinJoin,\n        uint safe,\n        uint wad,\n        address liquidationEngine,\n        address saviour\n    ) external {\n        generateDebt(manager, taxCollector, coinJoin, safe, wad);\n        protectSAFE(manager, safe, liquidationEngine, saviour);\n    }\n\n    function safeRepayDebt(\n        address manager,\n        address coinJoin,\n        uint safe,\n        uint wad,\n        address owner\n    ) public {\n        require(ManagerLike(manager).ownsSAFE(safe) == owner, \"owner-missmatch\");\n        repayDebt(manager, coinJoin, safe, wad);\n    }\n\n    function repayAllDebt(\n        address manager,\n        address coinJoin,\n        uint safe\n    ) public {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safeHandler = ManagerLike(manager).safes(safe);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        (, uint generatedDebt) = SAFEEngineLike_15(safeEngine).safes(collateralType, safeHandler);\n\n        address own = ManagerLike(manager).ownsSAFE(safe);\n        if (own == address(this) || ManagerLike(manager).safeCan(own, safe, address(this)) == 1) {\n            // Joins COIN amount into the safeEngine\n            coinJoin_join(coinJoin, safeHandler, _getRepaidAlDebt(safeEngine, safeHandler, safeHandler, collateralType));\n            // Paybacks debt to the SAFE\n            modifySAFECollateralization(manager, safe, 0, -int(generatedDebt));\n        } else {\n            // Joins COIN amount into the safeEngine\n            coinJoin_join(coinJoin, address(this), _getRepaidAlDebt(safeEngine, address(this), safeHandler, collateralType));\n            // Paybacks debt to the SAFE\n            SAFEEngineLike_15(safeEngine).modifySAFECollateralization(\n                collateralType,\n                safeHandler,\n                address(this),\n                address(this),\n                0,\n                -int(generatedDebt)\n            );\n        }\n    }\n\n    function safeRepayAllDebt(\n        address manager,\n        address coinJoin,\n        uint safe,\n        address owner\n    ) public {\n        require(ManagerLike(manager).ownsSAFE(safe) == owner, \"owner-missmatch\");\n        repayAllDebt(manager, coinJoin, safe);\n    }\n\n    function openLockETHGenerateDebtAndProtectSAFE(\n        address manager,\n        address taxCollector,\n        address ethJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint deltaWad,\n        address liquidationEngine,\n        address saviour\n    ) public payable returns (uint safe) {\n        safe = openSAFE(manager, collateralType, address(this));\n        lockETHAndGenerateDebt(manager, taxCollector, ethJoin, coinJoin, safe, deltaWad);\n        protectSAFE(manager, safe, liquidationEngine, saviour);\n    }\n\n    function lockTokenCollateralAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address collateralJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralAmount,\n        uint deltaWad,\n        bool transferFrom\n    ) public {\n        address safeHandler = ManagerLike(manager).safes(safe);\n        address safeEngine = ManagerLike(manager).safeEngine();\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        // Takes token amount from user's wallet and joins into the safeEngine\n        tokenCollateralJoin_join(collateralJoin, safeHandler, collateralAmount, transferFrom);\n        // Locks token amount into the SAFE and generates debt\n        modifySAFECollateralization(manager, safe, toInt(convertTo18(collateralJoin, collateralAmount)), _getGeneratedDeltaDebt(safeEngine, taxCollector, safeHandler, collateralType, deltaWad));\n        // Moves the COIN amount (balance in the safeEngine in rad) to proxy's address\n        transferInternalCoins(manager, safe, address(this), toRad(deltaWad));\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (SAFEEngineLike_15(safeEngine).canModifySAFE(address(this), address(coinJoin)) == 0) {\n            SAFEEngineLike_15(safeEngine).approveSAFEModification(coinJoin);\n        }\n        // Exits COIN to the user's wallet as a token\n        CoinJoinLike_3(coinJoin).exit(msg.sender, deltaWad);\n    }\n\n    function lockTokenCollateralGenerateDebtAndProtectSAFE(\n        address manager,\n        address taxCollector,\n        address collateralJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralAmount,\n        uint deltaWad,\n        bool transferFrom,\n        address liquidationEngine,\n        address saviour\n    ) public {\n        lockTokenCollateralAndGenerateDebt(\n          manager,\n          taxCollector,\n          collateralJoin,\n          coinJoin,\n          safe,\n          collateralAmount,\n          deltaWad,\n          transferFrom\n        );\n        protectSAFE(manager, safe, liquidationEngine, saviour);\n    }\n\n    function openLockTokenCollateralAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address collateralJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint collateralAmount,\n        uint deltaWad,\n        bool transferFrom\n    ) public returns (uint safe) {\n        safe = openSAFE(manager, collateralType, address(this));\n        lockTokenCollateralAndGenerateDebt(manager, taxCollector, collateralJoin, coinJoin, safe, collateralAmount, deltaWad, transferFrom);\n    }\n\n    function openLockTokenCollateralGenerateDebtAndProtectSAFE(\n        address manager,\n        address taxCollector,\n        address collateralJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint collateralAmount,\n        uint deltaWad,\n        bool transferFrom,\n        address liquidationEngine,\n        address saviour\n    ) public returns (uint safe) {\n        safe = openSAFE(manager, collateralType, address(this));\n        lockTokenCollateralAndGenerateDebt(manager, taxCollector, collateralJoin, coinJoin, safe, collateralAmount, deltaWad, transferFrom);\n        protectSAFE(manager, safe, liquidationEngine, saviour);\n    }\n\n    function openLockGNTAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address gntJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint collateralAmount,\n        uint deltaWad\n    ) public returns (address bag, uint safe) {\n        // Creates bag (if doesn't exist) to hold GNT\n        bag = GNTJoinLike(gntJoin).bags(address(this));\n        if (bag == address(0)) {\n            bag = makeCollateralBag(gntJoin);\n        }\n        // Transfer funds to the funds which previously were sent to the proxy\n        CollateralLike_3(CollateralJoinLike_2(gntJoin).collateral()).transfer(bag, collateralAmount);\n        safe = openLockTokenCollateralAndGenerateDebt(manager, taxCollector, gntJoin, coinJoin, collateralType, collateralAmount, deltaWad, false);\n    }\n\n    function openLockGNTGenerateDebtAndProtectSAFE(\n        address manager,\n        address taxCollector,\n        address gntJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint collateralAmount,\n        uint deltaWad,\n        address liquidationEngine,\n        address saviour\n    ) public returns (address bag, uint safe) {\n        (bag, safe) = openLockGNTAndGenerateDebt(\n          manager,\n          taxCollector,\n          gntJoin,\n          coinJoin,\n          collateralType,\n          collateralAmount,\n          deltaWad\n        );\n        protectSAFE(manager, safe, liquidationEngine, saviour);\n    }\n\n    function repayAllDebtAndFreeETH(\n        address manager,\n        address ethJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralWad\n    ) public {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safeHandler = ManagerLike(manager).safes(safe);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        (, uint generatedDebt) = SAFEEngineLike_15(safeEngine).safes(collateralType, safeHandler);\n\n        // Joins COIN amount into the safeEngine\n        coinJoin_join(coinJoin, safeHandler, _getRepaidAlDebt(safeEngine, safeHandler, safeHandler, collateralType));\n        // Paybacks debt to the SAFE and unlocks WETH amount from it\n        modifySAFECollateralization(\n            manager,\n            safe,\n            -toInt(collateralWad),\n            -int(generatedDebt)\n        );\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), collateralWad);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike_2(ethJoin).exit(address(this), collateralWad);\n        // Converts WETH to ETH\n        CollateralJoinLike_2(ethJoin).collateral().withdraw(collateralWad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(collateralWad);\n    }\n\n    function repayDebtAndFreeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralAmount,\n        uint deltaWad\n    ) external {\n        address safeHandler = ManagerLike(manager).safes(safe);\n        // Joins COIN amount into the safeEngine\n        coinJoin_join(coinJoin, safeHandler, deltaWad);\n        uint collateralWad = convertTo18(collateralJoin, collateralAmount);\n        // Paybacks debt to the SAFE and unlocks token amount from it\n        modifySAFECollateralization(\n            manager,\n            safe,\n            -toInt(collateralWad),\n            _getRepaidDeltaDebt(ManagerLike(manager).safeEngine(), SAFEEngineLike_15(ManagerLike(manager).safeEngine()).coinBalance(safeHandler), safeHandler, ManagerLike(manager).collateralTypes(safe))\n        );\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), collateralWad);\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike_2(collateralJoin).exit(msg.sender, collateralAmount);\n    }\n\n    function repayAllDebtAndFreeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralAmount\n    ) public {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safeHandler = ManagerLike(manager).safes(safe);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        (, uint generatedDebt) = SAFEEngineLike_15(safeEngine).safes(collateralType, safeHandler);\n\n        // Joins COIN amount into the safeEngine\n        coinJoin_join(coinJoin, safeHandler, _getRepaidAlDebt(safeEngine, safeHandler, safeHandler, collateralType));\n        uint collateralWad = convertTo18(collateralJoin, collateralAmount);\n        // Paybacks debt to the SAFE and unlocks token amount from it\n        modifySAFECollateralization(\n            manager,\n            safe,\n            -toInt(collateralWad),\n            -int(generatedDebt)\n        );\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), collateralWad);\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike_2(collateralJoin).exit(msg.sender, collateralAmount);\n    }\n}\n\ncontract GebProxyActionsGlobalSettlement is Common {\n\n    // Internal functions\n    function _freeCollateral(\n        address manager,\n        address globalSettlement,\n        uint safe\n    ) internal returns (uint lockedCollateral) {\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        address safeHandler = ManagerLike(manager).safes(safe);\n        SAFEEngineLike_15 safeEngine = SAFEEngineLike_15(ManagerLike(manager).safeEngine());\n        uint generatedDebt;\n        (lockedCollateral, generatedDebt) = safeEngine.safes(collateralType, safeHandler);\n\n        // If SAFE still has debt, it needs to be paid\n        if (generatedDebt > 0) {\n            GlobalSettlementLike_3(globalSettlement).processSAFE(collateralType, safeHandler);\n            (lockedCollateral,) = safeEngine.safes(collateralType, safeHandler);\n        }\n        // Approves the manager to transfer the position to proxy's address in the safeEngine\n        if (safeEngine.canModifySAFE(address(this), address(manager)) == 0) {\n            safeEngine.approveSAFEModification(manager);\n        }\n        // Transfers position from SAFE to the proxy address\n        ManagerLike(manager).quitSystem(safe, address(this));\n        // Frees the position and recovers the collateral in the safeEngine registry\n        GlobalSettlementLike_3(globalSettlement).freeCollateral(collateralType);\n    }\n\n    // Public functions\n    function freeETH(\n        address manager,\n        address ethJoin,\n        address globalSettlement,\n        uint safe\n    ) external {\n        uint wad = _freeCollateral(manager, globalSettlement, safe);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike_2(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        CollateralJoinLike_2(ethJoin).collateral().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n\n    function freeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        address globalSettlement,\n        uint safe\n    ) public {\n        uint amt = _freeCollateral(manager, globalSettlement, safe) / 10 ** (18 - CollateralJoinLike_2(collateralJoin).decimals());\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike_2(collateralJoin).exit(msg.sender, amt);\n    }\n\n    function prepareCoinsForRedeeming(\n        address coinJoin,\n        address globalSettlement,\n        uint wad\n    ) public {\n        coinJoin_join(coinJoin, address(this), wad);\n        SAFEEngineLike_15 safeEngine = CoinJoinLike_3(coinJoin).safeEngine();\n        // Approves the globalSettlement to take out COIN from the proxy's balance in the safeEngine\n        if (safeEngine.canModifySAFE(address(this), address(globalSettlement)) == 0) {\n            safeEngine.approveSAFEModification(globalSettlement);\n        }\n        GlobalSettlementLike_3(globalSettlement).prepareCoinsForRedeeming(wad);\n    }\n\n    function redeemETH(\n        address ethJoin,\n        address globalSettlement,\n        bytes32 collateralType,\n        uint wad\n    ) public {\n        GlobalSettlementLike_3(globalSettlement).redeemCollateral(collateralType, wad);\n        uint collateralWad = multiply(wad, GlobalSettlementLike_3(globalSettlement).collateralCashPrice(collateralType)) / RAY;\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike_2(ethJoin).exit(address(this), collateralWad);\n        // Converts WETH to ETH\n        CollateralJoinLike_2(ethJoin).collateral().withdraw(collateralWad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(collateralWad);\n    }\n\n    function redeemTokenCollateral(\n        address collateralJoin,\n        address globalSettlement,\n        bytes32 collateralType,\n        uint wad\n    ) public {\n        GlobalSettlementLike_3(globalSettlement).redeemCollateral(collateralType, wad);\n        // Exits token amount to the user's wallet as a token\n        uint amt = multiply(wad, GlobalSettlementLike_3(globalSettlement).collateralCashPrice(collateralType)) / RAY / 10 ** (18 - CollateralJoinLike_2(collateralJoin).decimals());\n        CollateralJoinLike_2(collateralJoin).exit(msg.sender, amt);\n    }\n}\n\ncontract GebProxyActionsCoinSavingsAccount is Common {\n\n    function deposit(\n        address coinJoin,\n        address coinSavingsAccount,\n        uint wad\n    ) public {\n        SAFEEngineLike_15 safeEngine = CoinJoinLike_3(coinJoin).safeEngine();\n        // Executes updateAccumulatedRate to get the accumulatedRates updated to latestUpdateTime == now, otherwise join will fail\n        uint accumulatedRates = CoinSavingsAccountLike_2(coinSavingsAccount).updateAccumulatedRate();\n        // Joins wad amount to the safeEngine balance\n        coinJoin_join(coinJoin, address(this), wad);\n        // Approves the coinSavingsAccount to take out COIN from the proxy's balance in the safeEngine\n        if (safeEngine.canModifySAFE(address(this), address(coinSavingsAccount)) == 0) {\n            safeEngine.approveSAFEModification(coinSavingsAccount);\n        }\n        // Joins the savings value (equivalent to the COIN wad amount) in the coinSavingsAccount\n        CoinSavingsAccountLike_2(coinSavingsAccount).deposit(multiply(wad, RAY) / accumulatedRates);\n    }\n\n    function withdraw(\n        address coinJoin,\n        address coinSavingsAccount,\n        uint wad\n    ) public {\n        SAFEEngineLike_15 safeEngine = CoinJoinLike_3(coinJoin).safeEngine();\n        // Executes updateAccumulatedRate to count the savings accumulated until this moment\n        uint accumulatedRates = CoinSavingsAccountLike_2(coinSavingsAccount).updateAccumulatedRate();\n        // Calculates the savings value in the coinSavingsAccount equivalent to the COIN wad amount\n        uint savings = multiply(wad, RAY) / accumulatedRates;\n        // Exits COIN from the coinSavingsAccount\n        CoinSavingsAccountLike_2(coinSavingsAccount).withdraw(savings);\n        // Checks the actual balance of COIN in the safeEngine after the coinSavingsAccount exit\n        uint bal = CoinJoinLike_3(coinJoin).safeEngine().coinBalance(address(this));\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (safeEngine.canModifySAFE(address(this), address(coinJoin)) == 0) {\n            safeEngine.approveSAFEModification(coinJoin);\n        }\n        // It is necessary to check if due rounding the exact wad amount can be exited by the adapter.\n        // Otherwise it will do the minimum COIN balance in the safeEngine\n        CoinJoinLike_3(coinJoin).exit(\n            msg.sender,\n            bal >= multiply(wad, RAY) ? wad : bal / RAY\n        );\n    }\n\n    function withdrawAll(\n        address coinJoin,\n        address coinSavingsAccount\n    ) public {\n        SAFEEngineLike_15 safeEngine = CoinJoinLike_3(coinJoin).safeEngine();\n        // Executes updateAccumulatedRate to count the savings accumulated until this moment\n        uint accumulatedRates = CoinSavingsAccountLike_2(coinSavingsAccount).updateAccumulatedRate();\n        // Gets the total savings belonging to the proxy address\n        uint savings = CoinSavingsAccountLike_2(coinSavingsAccount).savings(address(this));\n        // Exits COIN from the coinSavingsAccount\n        CoinSavingsAccountLike_2(coinSavingsAccount).withdraw(savings);\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (safeEngine.canModifySAFE(address(this), address(coinJoin)) == 0) {\n            safeEngine.approveSAFEModification(coinJoin);\n        }\n        // Exits the COIN amount corresponding to the value of savings\n        CoinJoinLike_3(coinJoin).exit(msg.sender, multiply(accumulatedRates, savings) / RAY);\n    }\n}\n\n\n////// src/GebProxySaviourActions.sol\n/// GebProxySaviourActions.sol\n\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity 0.6.7; */\n\n/* import \"./GebProxyActions.sol\"; */\n\nabstract contract GebSaviourLike {\n    function deposit(uint256, uint256) virtual external;\n    function deposit(bytes32, uint256, uint256) virtual external;\n    function withdraw(uint256, uint256, address) virtual external;\n    function withdraw(bytes32, uint256, uint256, address) virtual external;\n    function getReserves(uint256, address) virtual external;\n}\nabstract contract SaviourCRatioSetterLike_2 {\n    function setDesiredCollateralizationRatio(bytes32, uint256, uint256) virtual external;\n}\n\n/// @title Saviour proxy actions\n/// @notice This contract is supposed to be used alongside a DSProxy contract\n/// @dev These functions are meant to be used as a a library for a DSProxy\ncontract GebProxySaviourActions {\n    // --- Internal Logic ---\n    /*\n    * @notice Transfer a token from the caller to the proxy and approve another address to pull the tokens from the proxy\n    * @param token The token being transferred and approved\n    * @param target The address that can pull tokens from the proxy\n    * @param amount The amount of tokens being transferred and approved\n    */\n    function transferTokenFromAndApprove(address token, address target, uint256 amount) internal {\n        DSTokenLike_3(token).transferFrom(msg.sender, address(this), amount);\n        DSTokenLike_3(token).approve(target, 0);\n        DSTokenLike_3(token).approve(target, amount);\n    }\n\n    // --- External Logic ---\n    /*\n    * @notice Transfer all tokens that the proxy has out of an array of tokens to the caller\n    * @param tokens The array of tokens being transfered\n    */\n    function transferTokensToCaller(address[] memory tokens) public {\n        for (uint i = 0; i < tokens.length; i++) {\n            uint256 selfBalance = DSTokenLike_3(tokens[i]).balanceOf(address(this));\n            if (selfBalance > 0) {\n              DSTokenLike_3(tokens[i]).transfer(msg.sender, selfBalance);\n            }\n        }\n    }\n    /*\n    * @notice Attach a saviour to a SAFE\n    * @param saviour The saviour contract being attached\n    * @param manager The SAFE manager contract\n    * @param safe The ID of the SAFE being covered\n    * @param liquidationEngine The LiquidationEngine contract\n    */\n    function protectSAFE(\n        address saviour,\n        address manager,\n        uint safe,\n        address liquidationEngine\n    ) public {\n        ManagerLike(manager).protectSAFE(safe, liquidationEngine, saviour);\n    }\n    /*\n    * @notice Set a custom desired collateralization ratio for a specific SAFE\n    * @param cRatioSetter The address of the saviour cRatio setter\n    * @param collateralType The collateral type of the SAFE\n    * @param safe The ID of the SAFE\n    * @param cRatio The desired collateralization ratio for the SAFE\n    */\n    function setDesiredCollateralizationRatio(\n        address cRatioSetter,\n        bytes32 collateralType,\n        uint256 safe,\n        uint256 cRatio\n    ) public {\n        SaviourCRatioSetterLike_2(cRatioSetter).setDesiredCollateralizationRatio(collateralType, safe, cRatio);\n    }\n    /*\n    * @notice Deposit cover in a saviour contract\n    * @param collateralSpecific Whether the collateral type of the SAFE needs to be passed to the saviour contract\n    * @param saviour The saviour contract being attached\n    * @param manager The SAFE manager contract\n    * @param token The token being used as cover\n    * @param safe The ID of the SAFE being covered\n    * @param tokenAmount The amount of tokens being deposited as cover\n    */\n    function deposit(\n        bool collateralSpecific,\n        address saviour,\n        address manager,\n        address token,\n        uint256 safe,\n        uint256 tokenAmount\n    ) public {\n        transferTokenFromAndApprove(token, saviour, tokenAmount);\n\n        if (collateralSpecific) {\n          GebSaviourLike(saviour).deposit(ManagerLike(manager).collateralTypes(safe), safe, tokenAmount);\n        } else {\n          GebSaviourLike(saviour).deposit(safe, tokenAmount);\n        }\n    }\n    /*\n    * @notice Set a custom desired collateralization ratio for a specific SAFE and deposit cover in a saviour for the SAFE\n    * @param collateralSpecific Whether the collateral type of the SAFE needs to be passed to the saviour contract\n    * @param saviour The saviour contract being attached\n    * @param cRatioSetter The address of the saviour cRatio setter\n    * @param manager The SAFE manager contract\n    * @param token The token being used as cover\n    * @param safe The ID of the SAFE being covered\n    * @param tokenAmount The amount of tokens being deposited as cover\n    * @param cRatio The desired collateralization ratio for the SAFE\n    */\n    function setDesiredCRatioDeposit(\n        bool collateralSpecific,\n        address saviour,\n        address cRatioSetter,\n        address manager,\n        address token,\n        uint256 safe,\n        uint256 tokenAmount,\n        uint256 cRatio\n    ) public {\n        setDesiredCollateralizationRatio(cRatioSetter, ManagerLike(manager).collateralTypes(safe), safe, cRatio);\n        deposit(collateralSpecific, saviour, manager, token, safe, tokenAmount);\n    }\n    /*\n    * @notice Withdraw cover from a saviour contract\n    * @param collateralSpecific Whether the collateral type of the SAFE needs to be passed to the saviour contract\n    * @param saviour The saviour contract from which to withdraw cover\n    * @param manager The SAFE manager contract\n    * @param safe The ID of the SAFE being covered\n    * @param tokenAmount The amount of tokens being withdrawn\n    * @param dst The address that will receive the withdrawn tokens\n    */\n    function withdraw(\n        bool collateralSpecific,\n        address saviour,\n        address manager,\n        uint256 safe,\n        uint256 tokenAmount,\n        address dst\n    ) public {\n        if (collateralSpecific) {\n          GebSaviourLike(saviour).withdraw(ManagerLike(manager).collateralTypes(safe), safe, tokenAmount, dst);\n        } else {\n          GebSaviourLike(saviour).withdraw(safe, tokenAmount, dst);\n        }\n    }\n    /*\n    * @notice Set a custom desired collateralization ratio for a specific SAFE and withdraw cover from a saviour protecting the SAFE\n    * @param collateralSpecific Whether the collateral type of the SAFE needs to be passed to the saviour contract\n    * @param saviour The saviour contract from which to withdraw cover\n    * @param cRatioSetter The address of the saviour cRatio setter\n    * @param manager The SAFE manager contract\n    * @param safe The ID of the SAFE being covered\n    * @param tokenAmount The amount of tokens being withdrawn\n    * @param cRatio The desired collateralization ratio for the SAFE\n    * @param dst The address that will receive the withdrawn tokens\n    */\n    function setDesiredCRatioWithdraw(\n        bool collateralSpecific,\n        address saviour,\n        address cRatioSetter,\n        address manager,\n        uint256 safe,\n        uint256 tokenAmount,\n        uint256 cRatio,\n        address dst\n    ) public {\n        setDesiredCollateralizationRatio(cRatioSetter, ManagerLike(manager).collateralTypes(safe), safe, cRatio);\n        withdraw(collateralSpecific, saviour, manager, safe, tokenAmount, dst);\n    }\n    /*\n    * @notice Attach a saviour to a SAFE and deposit cover in it\n    * @param collateralSpecific Whether the collateral type of the SAFE needs to be passed to the saviour contract\n    * @param saviour The saviour contract being attached\n    * @param manager The SAFE manager contract\n    * @param token The token being used as cover\n    * @param liquidationEngine The LiquidationEngine contract\n    * @param safe The ID of the SAFE being covered\n    * @param tokenAmount The amount of tokens being deposited as cover\n    */\n    function protectSAFEDeposit(\n        bool collateralSpecific,\n        address saviour,\n        address manager,\n        address token,\n        address liquidationEngine,\n        uint256 safe,\n        uint256 tokenAmount\n    ) public {\n        protectSAFE(saviour, manager, safe, liquidationEngine);\n        deposit(collateralSpecific, saviour, manager, token, safe, tokenAmount);\n    }\n    /*\n    * @notice Attach a saviour to a SAFE, set the SAFE's desired cRatio and deposit cover in the saviour\n    * @param collateralSpecific Whether the collateral type of the SAFE needs to be passed to the saviour contract\n    * @param saviour The saviour contract being attached\n    * @param cRatioSetter The cRatio setter contract\n    * @param manager The SAFE manager contract\n    * @param token The token being used as cover\n    * @param liquidationEngine The LiquidationEngine contract\n    * @param safe The ID of the SAFE being covered\n    * @param tokenAmount The amount of tokens being deposited as cover\n    * @param cRatio The desired collateralization ratio\n    */\n    function protectSAFESetDesiredCRatioDeposit(\n        bool collateralSpecific,\n        address saviour,\n        address cRatioSetter,\n        address manager,\n        address token,\n        address liquidationEngine,\n        uint256 safe,\n        uint256 tokenAmount,\n        uint256 cRatio\n    ) public {\n        protectSAFE(saviour, manager, safe, liquidationEngine);\n        setDesiredCollateralizationRatio(cRatioSetter, ManagerLike(manager).collateralTypes(safe), safe, cRatio);\n        deposit(collateralSpecific, saviour, manager, token, safe, tokenAmount);\n    }\n    /*\n    * @notice Withdraw cover from a saviour and uncover a SAFE\n    * @param collateralSpecific Whether the collateral type of the SAFE needs to be passed to the saviour contract\n    * @param saviour The saviour contract being detached\n    * @param manager The SAFE manager contract\n    * @param token The token being used as cover\n    * @param liquidationEngine The LiquidationEngine contract\n    * @param safe The ID of the SAFE being covered\n    * @param tokenAmount The amount of tokens being withdrawn\n    * @param dst The address that will receive the withdrawn tokens\n    */\n    function withdrawUncoverSAFE(\n        bool collateralSpecific,\n        address saviour,\n        address manager,\n        address token,\n        address liquidationEngine,\n        uint256 safe,\n        uint256 tokenAmount,\n        address dst\n    ) public {\n        withdraw(collateralSpecific, saviour, manager, safe, tokenAmount, dst);\n        protectSAFE(address(0), manager, safe, liquidationEngine);\n    }\n    /*\n    * @notice Withdraw cover from a saviour, cover a SAFE with a new saviour and deposit cover in the new saviour\n    * @param withdrawCollateralSpecific Whether the collateral type of the SAFE needs to be passed to the withdraw saviour contract\n    * @param depositCollateralSpecific Whether the collateral type of the SAFE needs to be passed to the deposit saviour contract\n    * @param withdrawSaviour The saviour from which cover is being withdrawn\n    * @param depositSaviour The new saviour that wil protect the SAFE\n    * @param manager The SAFE manager contract\n    * @param depositToken The token being deposited in the depositSaviour\n    * @param liquidationEngine The LiquidationEngine contract\n    * @param safe The SAFE being covered by the new saviour\n    * @param withdrawTokenAmount The amount of tokens being withdrawn from the old saviour\n    * @param depositTokenAmount The amount of tokens being deposited in the new saviour\n    * @param withdrawDst The address that will receive the withdrawn tokens\n    */\n    function withdrawProtectSAFEDeposit(\n        bool withdrawCollateralSpecific,\n        bool depositCollateralSpecific,\n        address withdrawSaviour,\n        address depositSaviour,\n        address manager,\n        address depositToken,\n        address liquidationEngine,\n        uint256 safe,\n        uint256 withdrawTokenAmount,\n        uint256 depositTokenAmount,\n        address withdrawDst\n    ) public {\n        withdraw(withdrawCollateralSpecific, withdrawSaviour, manager, safe, withdrawTokenAmount, withdrawDst);\n        protectSAFE(depositSaviour, manager, safe, liquidationEngine);\n        deposit(depositCollateralSpecific, depositSaviour, manager, depositToken, safe, depositTokenAmount);\n    }\n    /*\n    * @notice Withdraw reserve tokens from a saviour without uncovering a SAFE\n    * @param saviour The saviour from which to withdraw reserve assets\n    * @param safe The ID of the SAFE that has tokens in reserves\n    * @param The address that will receive the reserve tokens\n    */\n    function getReserves(address saviour, uint256 safe, address dst) public {\n        GebSaviourLike(saviour).getReserves(safe, dst);\n    }\n    /*\n    * @notice Withdraw reserve tokens from a saviour and uncover a SAFE\n    * @param saviour The saviour from which to withdraw reserve assets\n    * @param manager The SAFE manager contract\n    * @param liquidationEngine The LiquidationEngine contract\n    * @param safe The ID of the SAFE that has tokens in reserves\n    * @param The address that will receive the reserve tokens\n    */\n    function getReservesAndUncover(address saviour, address manager, address liquidationEngine, uint256 safe, address dst) public {\n        GebSaviourLike(saviour).getReserves(safe, dst);\n        protectSAFE(address(0), manager, safe, liquidationEngine);\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"collateralSpecific\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"saviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"saviour\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"getReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"saviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationEngine\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"getReservesAndUncover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"saviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"liquidationEngine\",\"type\":\"address\"}],\"name\":\"protectSAFE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"collateralSpecific\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"saviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationEngine\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"protectSAFEDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"collateralSpecific\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"saviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cRatioSetter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationEngine\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cRatio\",\"type\":\"uint256\"}],\"name\":\"protectSAFESetDesiredCRatioDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"collateralSpecific\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"saviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cRatioSetter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cRatio\",\"type\":\"uint256\"}],\"name\":\"setDesiredCRatioDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"collateralSpecific\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"saviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cRatioSetter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cRatio\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"setDesiredCRatioWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cRatioSetter\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cRatio\",\"type\":\"uint256\"}],\"name\":\"setDesiredCollateralizationRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"transferTokensToCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"collateralSpecific\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"saviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"withdrawCollateralSpecific\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"depositCollateralSpecific\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"withdrawSaviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"depositSaviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationEngine\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"withdrawDst\",\"type\":\"address\"}],\"name\":\"withdrawProtectSAFEDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"collateralSpecific\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"saviour\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationEngine\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"safe\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"withdrawUncoverSAFE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GebProxySaviourActions","CompilerVersion":"v0.6.7+commit.b8d736ae","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}