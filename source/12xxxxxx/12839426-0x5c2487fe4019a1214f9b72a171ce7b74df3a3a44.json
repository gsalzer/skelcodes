{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/options/lib/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Stripped version of the following:\\n// https://github.com/pipermerriam/ethereum-datetime\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\n// SAFEMATH DISCLAIMER:\\n// We and don't use SafeMath here intentionally, because all of the operations are basic arithmetics\\n// (we have introduced a limit of year 2100 to definitely fit into uint16, hoping Year2100-problem will not be our problem)\\n// and the results are used solely for display purposes (generating a token SYMBOL).\\n// Moreover - input data is provided only by contract owners, as creation of tokens is limited to owner only.\\nlibrary DateTime {\\n    struct _DateTime {\\n        uint16 year;\\n        uint8 month;\\n        uint8 day;\\n    }\\n\\n    uint256 constant DAY_IN_SECONDS = 86400; // leap second?\\n    uint256 constant YEAR_IN_SECONDS = 31536000;\\n    uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\\n\\n    uint16 constant ORIGIN_YEAR = 1970;\\n\\n    function isLeapYear(uint16 year) public pure returns (bool) {\\n        if (year % 4 != 0) {\\n            return false;\\n        }\\n        if (year % 100 != 0) {\\n            return true;\\n        }\\n        if (year % 400 != 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    function leapYearsBefore(uint256 year) public pure returns (uint256) {\\n        year -= 1;\\n        return year / 4 - year / 100 + year / 400;\\n    }\\n\\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\n            return 31;\\n        } else if (month == 4 || month == 6 || month == 9 || month == 11) {\\n            return 30;\\n        } else if (isLeapYear(year)) {\\n            return 29;\\n        } else {\\n            return 28;\\n        }\\n    }\\n\\n    function parseTimestamp(uint256 timestamp) public pure returns (_DateTime memory dt) {\\n        uint256 secondsAccountedFor = 0;\\n        uint256 buf;\\n        uint8 i;\\n\\n        // Year\\n        dt.year = getYear(timestamp);\\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\\n\\n        // Month\\n        uint256 secondsInMonth;\\n        for (i = 1; i <= 12; i++) {\\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\\n            if (secondsInMonth + secondsAccountedFor > timestamp) {\\n                dt.month = i;\\n                break;\\n            }\\n            secondsAccountedFor += secondsInMonth;\\n        }\\n\\n        // Day\\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\\n                dt.day = i;\\n                break;\\n            }\\n            secondsAccountedFor += DAY_IN_SECONDS;\\n        }\\n    }\\n\\n    function getYear(uint256 timestamp) public pure returns (uint16) {\\n        require(timestamp < 4102444800, \\\"Years after 2100 aren't supported for sanity and safety reasons\\\");\\n        uint256 secondsAccountedFor = 0;\\n        uint16 year;\\n        uint256 numLeapYears;\\n\\n        // Year\\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\\n\\n        while (secondsAccountedFor > timestamp) {\\n            if (isLeapYear(uint16(year - 1))) {\\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\n            } else {\\n                secondsAccountedFor -= YEAR_IN_SECONDS;\\n            }\\n            year -= 1;\\n        }\\n        return year;\\n    }\\n\\n    function getMonth(uint256 timestamp) external pure returns (uint8) {\\n        return parseTimestamp(timestamp).month;\\n    }\\n\\n    function getDay(uint256 timestamp) external pure returns (uint8) {\\n        return parseTimestamp(timestamp).day;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getDay\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"getDaysInMonth\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMonth\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getYear\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"isLeapYear\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"}],\"name\":\"leapYearsBefore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"parseTimestamp\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"day\",\"type\":\"uint8\"}],\"internalType\":\"struct DateTime._DateTime\",\"name\":\"dt\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"DateTime","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}