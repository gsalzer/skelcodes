{"status":"1","message":"OK","result":[{"SourceCode":"// Dependency file: contracts/zeppelin/upgradable/Initializable.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || !initialized, \"Contract instance is already initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// Dependency file: contracts/zeppelin/upgradable/utils/ReentrancyGuard.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n// import \"contracts/zeppelin/upgradable/Initializable.sol\";\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard is Initializable {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    function initialize() public initializer {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: no reentrant allowed\");\r\n    }\r\n}\r\n\r\n// Dependency file: contracts/zeppelin/GSN/Context.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract  Context {\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/access/Roles.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account doesn't have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/upgradable/access/roles/UpgradablePauserRole.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n// import \"contracts/zeppelin/upgradable/Initializable.sol\";\r\n\r\n// import \"contracts/zeppelin/GSN/Context.sol\";\r\n// import \"contracts/zeppelin/access/Roles.sol\";\r\n\r\ncontract UpgradablePauserRole is Initializable, Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    function __PauserRol_init(address sender) public initializer {\r\n        if (!isPauser(sender)) {\r\n            _addPauser(sender);\r\n        }\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(_msgSender()), \"PauserRole: caller doesn't have the role\");\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(_msgSender());\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/upgradable/lifecycle/UpgradablePausable.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n// import \"contracts/zeppelin/upgradable/Initializable.sol\";\r\n\r\n// import \"contracts/zeppelin/GSN/Context.sol\";\r\n// import \"contracts/zeppelin/upgradable/access/roles/UpgradablePauserRole.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract UpgradablePausable is Initializable, Context, UpgradablePauserRole {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n     * to the deployer.\r\n     */\r\n    function __Pausable_init(address sender) public initializer {\r\n        UpgradablePauserRole.__PauserRol_init(sender);\r\n\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to pause, triggers stopped state.\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to unpause, returns to normal state.\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/upgradable/ownership/UpgradableOwnable.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n// import \"contracts/zeppelin/upgradable/Initializable.sol\";\r\n\r\n// import \"contracts/zeppelin/GSN/Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract UpgradableOwnable is Initializable, Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/introspection/IERC1820Registry.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as `account`'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `_account`.\r\n     * - `_interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `_implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(address _account, bytes32 _interfaceHash, address _implementer) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `_interfaceHash` for `_account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `_interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `_account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address _account, bytes32 _interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     *  @param account Address of the contract for which to update the cache.\r\n     *  @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\r\n     *  If the result is not cached a direct lookup on the contract address is performed.\r\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     *  {updateERC165Cache} with the contract address.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/token/ERC777/IERC777Recipient.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\r\n *\r\n * Accounts can be notified of `IERC777` tokens being sent to them by having a\r\n * contract implement this interface (contract holders can be their own\r\n * implementer) and registering it on the\r\n * [ERC1820 global registry](https://eips.ethereum.org/EIPS/eip-1820).\r\n *\r\n * See `IERC1820Registry` and `ERC1820Implementer`.\r\n */\r\ninterface IERC777Recipient {\r\n    /**\r\n     * @dev Called by an `IERC777` token contract whenever tokens are being\r\n     * moved or created into a registered account (`to`). The type of operation\r\n     * is conveyed by `from` being the zero address or not.\r\n     *\r\n     * This call occurs _after_ the token contract's state is updated, so\r\n     * `IERC777.balanceOf`, etc., can be used to query the post-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/token/ERC20/IERC20.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/math/SafeMath.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/utils/Address.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n     /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/token/ERC20/SafeERC20.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n// import \"contracts/zeppelin/token/ERC20/IERC20.sol\";\r\n// import \"contracts/zeppelin/math/SafeMath.sol\";\r\n// import \"contracts/zeppelin/utils/Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/zeppelin/token/ERC777/IERC777.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the ERC777Token standard as defined in the EIP.\r\n *\r\n * This contract uses the\r\n * [ERC1820 registry standard](https://eips.ethereum.org/EIPS/eip-1820) to let\r\n * token holders and recipients react to token movements by using setting implementers\r\n * for the associated interfaces in said registry. See `IERC1820Registry` and\r\n * `ERC1820Implementer`.\r\n */\r\ninterface IERC777 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the smallest part of the token that is not divisible. This\r\n     * means all token operations (creation, movement and destruction) must have\r\n     * amounts that are a multiple of this number.\r\n     *\r\n     * For most token contracts, this value will equal 1.\r\n     */\r\n    function granularity() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (`owner`).\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * If send or receive hooks are registered for the caller and `recipient`,\r\n     * the corresponding functions will be called with `data` and empty\r\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\r\n     *\r\n     * Emits a `Sent` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\r\n     * interface.\r\n     */\r\n    function send(address recipient, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with `data` and empty `operatorData`. See `IERC777Sender`.\r\n     *\r\n     * Emits a `Burned` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Returns true if an account is an operator of `tokenHolder`.\r\n     * Operators can send and burn tokens on behalf of their owners. All\r\n     * accounts are their own operator.\r\n     *\r\n     * See `operatorSend` and `operatorBurn`.\r\n     */\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See `isOperatorFor`.\r\n     *\r\n     * Emits an `AuthorizedOperator` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function authorizeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See `isOperatorFor` and `defaultOperators`.\r\n     *\r\n     * Emits a `RevokedOperator` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function revokeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Returns the list of default operators. These accounts are operators\r\n     * for all token holders, even if `authorizeOperator` was never called on\r\n     * them.\r\n     *\r\n     * This list is immutable, but individual holders may revoke these via\r\n     * `revokeOperator`, in which case `isOperatorFor` will return false.\r\n     */\r\n    function defaultOperators() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\r\n     * be an operator of `sender`.\r\n     *\r\n     * If send or receive hooks are registered for `sender` and `recipient`,\r\n     * the corresponding functions will be called with `data` and\r\n     * `operatorData`. See `IERC777Sender` and `IERC777Recipient`.\r\n     *\r\n     * Emits a `Sent` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `sender` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `sender`.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the `tokensReceived`\r\n     * interface.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\r\n     * The caller must be an operator of `account`.\r\n     *\r\n     * If a send hook is registered for `account`, the corresponding function\r\n     * will be called with `data` and `operatorData`. See `IERC777Sender`.\r\n     *\r\n     * Emits a `Burned` event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `account`.\r\n     */\r\n    function operatorBurn(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    function decimals() external returns (uint8);\r\n\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\n\r\n// Dependency file: contracts/LibEIP712.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\n// https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol\r\nlibrary LibEIP712 {\r\n\r\n    // Hash of the EIP712 Domain Separator Schema\r\n    // keccak256(abi.encodePacked(\r\n    //     \"EIP712Domain(\",\r\n    //     \"string name,\",\r\n    //     \"string version,\",\r\n    //     \"uint256 chainId,\",\r\n    //     \"address verifyingContract\",\r\n    //     \")\"\r\n    // ))\r\n    bytes32 constant internal _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n\r\n    /// @dev Calculates a EIP712 domain separator.\r\n    /// @param name The EIP712 domain name.\r\n    /// @param version The EIP712 domain version.\r\n    /// @param verifyingContract The EIP712 verifying contract.\r\n    /// @return result EIP712 domain separator.\r\n    function hashEIP712Domain(\r\n        string memory name,\r\n        string memory version,\r\n        uint256 chainId,\r\n        address verifyingContract\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        bytes32 schemaHash = _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH;\r\n\r\n        // Assembly for more efficient computing:\r\n        // keccak256(abi.encodePacked(\r\n        //     _EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\r\n        //     keccak256(bytes(name)),\r\n        //     keccak256(bytes(version)),\r\n        //     chainId,\r\n        //     uint256(verifyingContract)\r\n        // ))\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            // Calculate hashes of dynamic data\r\n            let nameHash := keccak256(add(name, 32), mload(name))\r\n            let versionHash := keccak256(add(version, 32), mload(version))\r\n\r\n            // Load free memory pointer\r\n            let memPtr := mload(64)\r\n\r\n            // Store params in memory\r\n            mstore(memPtr, schemaHash)\r\n            mstore(add(memPtr, 32), nameHash)\r\n            mstore(add(memPtr, 64), versionHash)\r\n            mstore(add(memPtr, 96), chainId)\r\n            mstore(add(memPtr, 128), verifyingContract)\r\n\r\n            // Compute hash\r\n            result := keccak256(memPtr, 160)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /// @dev Calculates EIP712 encoding for a hash struct with a given domain hash.\r\n    /// @param eip712DomainHash Hash of the domain domain separator data, computed\r\n    ///                         with getDomainHash().\r\n    /// @param hashStruct The EIP712 hash struct.\r\n    /// @return result EIP712 hash applied to the given EIP712 Domain.\r\n    function hashEIP712Message(bytes32 eip712DomainHash, bytes32 hashStruct)\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        // Assembly for more efficient computing:\r\n        // keccak256(abi.encodePacked(\r\n        //     EIP191_HEADER,\r\n        //     EIP712_DOMAIN_HASH,\r\n        //     hashStruct\r\n        // ));\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            // Load free memory pointer\r\n            let memPtr := mload(64)\r\n\r\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\r\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\r\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\r\n\r\n            // Compute hash\r\n            result := keccak256(memPtr, 66)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// Dependency file: contracts/LibUtils.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\nlibrary LibUtils {\r\n\r\n    function decimalsToGranularity(uint8 decimals) internal pure returns (uint256) {\r\n        require(decimals <= 18, \"LibUtils: Decimals not <= 18\");\r\n        return uint256(10)**(18-decimals);\r\n    }\r\n\r\n    function getDecimals(address tokenToUse) internal view returns (uint8) {\r\n        //support decimals as uint256 or uint8\r\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"decimals()\"));\r\n        require(success, \"LibUtils: No decimals\");\r\n        // uint<M>: enc(X) is the big-endian encoding of X,\r\n        //padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.\r\n        return uint8(abi.decode(data, (uint256)));\r\n    }\r\n\r\n    function getGranularity(address tokenToUse) internal view returns (uint256) {\r\n        //support granularity if ERC777\r\n        (bool success, bytes memory data) = tokenToUse.staticcall(abi.encodeWithSignature(\"granularity()\"));\r\n        require(success, \"LibUtils: No granularity\");\r\n\r\n        return abi.decode(data, (uint256));\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) internal pure returns (address addr) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            addr := mload(add(bys,20))\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// Dependency file: contracts/IBridge.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\ninterface IBridge {\r\n\r\n    struct ClaimData {\r\n        address payable to;\r\n        uint256 amount;\r\n        bytes32 blockHash;\r\n        bytes32 transactionHash;\r\n        uint32 logIndex;\r\n    }\r\n\r\n    function version() external pure returns (string memory);\r\n\r\n    function getFeePercentage() external view returns(uint);\r\n\r\n    /**\r\n     * ERC-20 tokens approve and transferFrom pattern\r\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\r\n     */\r\n    function receiveTokensTo(address tokenToUse, address to, uint256 amount) external;\r\n\r\n    /**\r\n     * Use network currency and cross it.\r\n     */\r\n    function depositTo(address to) external payable;\r\n\r\n    /**\r\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\r\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\r\n     */\r\n    function tokensReceived (\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * Accepts the transaction from the other chain that was voted and sent by the Federation contract\r\n     */\r\n    function acceptTransfer(\r\n        address _originalTokenAddress,\r\n        address payable _from,\r\n        address payable _to,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        bytes32 _transactionHash,\r\n        uint32 _logIndex\r\n    ) external;\r\n\r\n    /**\r\n     * Claims the crossed transaction using the hash, this sends the funds to the address indicated in\r\n     */\r\n    function claim(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\r\n\r\n    function claimFallback(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\r\n\r\n    function claimGasless(\r\n        ClaimData calldata _claimData,\r\n        address payable _relayer,\r\n        uint256 _fee,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 receivedAmount);\r\n\r\n    function getTransactionDataHash(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        bytes32 _transactionHash,\r\n        uint32 _logIndex\r\n    ) external returns(bytes32);\r\n\r\n    event Cross(\r\n        address indexed _tokenAddress,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _amount,\r\n        bytes _userData\r\n    );\r\n    event NewSideToken(\r\n        address indexed _newSideTokenAddress,\r\n        address indexed _originalTokenAddress,\r\n        string _newSymbol,\r\n        uint256 _granularity\r\n    );\r\n    event AcceptedCrossTransfer(\r\n        bytes32 indexed _transactionHash,\r\n        address indexed _originalTokenAddress,\r\n        address indexed _to,\r\n        address  _from,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        uint256 _logIndex\r\n    );\r\n    event FeePercentageChanged(uint256 _amount);\r\n    event Claimed(\r\n        bytes32 indexed _transactionHash,\r\n        address indexed _originalTokenAddress,\r\n        address indexed _to,\r\n        address _sender,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        uint256 _logIndex,\r\n        address _reciever,\r\n        address _relayer,\r\n        uint256 _fee\r\n    );\r\n}\r\n\r\n// Dependency file: contracts/ISideToken.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\ninterface ISideToken {\r\n    function mint(address account, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;\r\n}\r\n\r\n// Dependency file: contracts/ISideTokenFactory.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\n\r\ninterface ISideTokenFactory {\r\n\r\n    function createSideToken(string calldata name, string calldata symbol, uint256 granularity) external returns(address);\r\n\r\n    event SideTokenCreated(address indexed sideToken, string symbol, uint256 granularity);\r\n}\r\n\r\n// Dependency file: contracts/IAllowTokens.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\ninterface IAllowTokens {\r\n\r\n    struct Limits {\r\n        uint256 min;\r\n        uint256 max;\r\n        uint256 daily;\r\n        uint256 mediumAmount;\r\n        uint256 largeAmount;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        bool allowed;\r\n        uint256 typeId;\r\n        uint256 spentToday;\r\n        uint256 lastDay;\r\n    }\r\n\r\n    struct TypeInfo {\r\n        string description;\r\n        Limits limits;\r\n    }\r\n\r\n    struct TokensAndType {\r\n        address token;\r\n        uint256 typeId;\r\n    }\r\n\r\n    function version() external pure returns (string memory);\r\n\r\n    function getInfoAndLimits(address token) external view returns (TokenInfo memory info, Limits memory limit);\r\n\r\n    function calcMaxWithdraw(address token) external view returns (uint256 maxWithdraw);\r\n\r\n    function getTypesLimits() external view returns(Limits[] memory limits);\r\n\r\n    function getTypeDescriptionsLength() external view returns(uint256);\r\n\r\n    function getTypeDescriptions() external view returns(string[] memory descriptions);\r\n\r\n    function setToken(address token, uint256 typeId) external;\r\n\r\n    function getConfirmations() external view returns (uint256 smallAmount, uint256 mediumAmount, uint256 largeAmount);\r\n\r\n    function isTokenAllowed(address token) external view returns (bool);\r\n\r\n    function updateTokenTransfer(address token, uint256 amount) external;\r\n}\r\n\r\n// Dependency file: contracts/IWrapped.sol\r\n\r\n\r\n// pragma solidity ^0.7.0;\r\n// pragma abicoder v2;\r\ninterface IWrapped {\r\n    function balanceOf(address) external returns(uint);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint wad) external;\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function approve(address guy, uint wad) external returns (bool);\r\n\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\n// Root file: contracts/Bridge.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n// Import base Initializable contract\r\n// import \"contracts/zeppelin/upgradable/Initializable.sol\";\r\n// Import interface and library from OpenZeppelin contracts\r\n// import \"contracts/zeppelin/upgradable/utils/ReentrancyGuard.sol\";\r\n// import \"contracts/zeppelin/upgradable/lifecycle/UpgradablePausable.sol\";\r\n// import \"contracts/zeppelin/upgradable/ownership/UpgradableOwnable.sol\";\r\n\r\n// import \"contracts/zeppelin/introspection/IERC1820Registry.sol\";\r\n// import \"contracts/zeppelin/token/ERC777/IERC777Recipient.sol\";\r\n// import \"contracts/zeppelin/token/ERC20/IERC20.sol\";\r\n// import \"contracts/zeppelin/token/ERC20/SafeERC20.sol\";\r\n// import \"contracts/zeppelin/utils/Address.sol\";\r\n// import \"contracts/zeppelin/math/SafeMath.sol\";\r\n// import \"contracts/zeppelin/token/ERC777/IERC777.sol\";\r\n\r\n// import \"contracts/LibEIP712.sol\";\r\n// import \"contracts/LibUtils.sol\";\r\n\r\n// import \"contracts/IBridge.sol\";\r\n// import \"contracts/ISideToken.sol\";\r\n// import \"contracts/ISideTokenFactory.sol\";\r\n// import \"contracts/IAllowTokens.sol\";\r\n// import \"contracts/IWrapped.sol\";\r\n\r\n\r\ncontract Bridge is Initializable, IBridge, IERC777Recipient, UpgradablePausable, UpgradableOwnable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    address constant internal NULL_ADDRESS = address(0);\r\n    bytes32 constant internal NULL_HASH = bytes32(0);\r\n    IERC1820Registry constant internal erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    address internal federation;\r\n    uint256 internal feePercentage;\r\n    string public symbolPrefix;\r\n    bytes32 public DOMAIN_SEPARATOR; // replaces uint256 internal _depprecatedLastDay;\r\n    uint256 internal _deprecatedSpentToday;\r\n\r\n    mapping (address => address) public mappedTokens; // OirignalToken => SideToken\r\n    mapping (address => address) public originalTokens; // SideToken => OriginalToken\r\n    mapping (address => bool) public knownTokens; // OriginalToken => true\r\n    mapping (bytes32 => bool) public claimed; // transactionDataHash => true // previously named processed\r\n    IAllowTokens public allowTokens;\r\n    ISideTokenFactory public sideTokenFactory;\r\n    //Bridge_v1 variables\r\n    bool public isUpgrading;\r\n    uint256 constant public feePercentageDivider = 10000; // Porcentage with up to 2 decimals\r\n    //Bridge_v3 variables\r\n    bytes32 constant internal _erc777Interface = keccak256(\"ERC777Token\");\r\n    IWrapped public wrappedCurrency;\r\n    mapping (bytes32 => bytes32) public transactionsDataHashes; // transactionHash => transactionDataHash\r\n    mapping (bytes32 => address) public originalTokenAddresses; // transactionHash => originalTokenAddress\r\n    mapping (bytes32 => address) public senderAddresses; // transactionHash => senderAddress\r\n\r\n    // keccak256(\"Claim(address to,uint256 amount,bytes32 transactionHash,address relayer,uint256 fee,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant CLAIM_TYPEHASH = 0xf18ceda3f6355f78c234feba066041a50f6557bfb600201e2a71a89e2dd80433;\r\n    mapping(address => uint) public nonces;\r\n\r\n    event AllowTokensChanged(address _newAllowTokens);\r\n    event FederationChanged(address _newFederation);\r\n    event SideTokenFactoryChanged(address _newSideTokenFactory);\r\n    event Upgrading(bool _isUpgrading);\r\n    event WrappedCurrencyChanged(address _wrappedCurrency);\r\n\r\n    function initialize(\r\n        address _manager,\r\n        address _federation,\r\n        address _allowTokens,\r\n        address _sideTokenFactory,\r\n        string memory _symbolPrefix\r\n    ) public initializer {\r\n        UpgradableOwnable.initialize(_manager);\r\n        UpgradablePausable.__Pausable_init(_manager);\r\n        symbolPrefix = _symbolPrefix;\r\n        allowTokens = IAllowTokens(_allowTokens);\r\n        sideTokenFactory = ISideTokenFactory(_sideTokenFactory);\r\n        federation = _federation;\r\n        //keccak256(\"ERC777TokensRecipient\")\r\n        erc1820.setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\r\n        initDomainSeparator();\r\n    }\r\n\r\n    receive () external payable {\r\n        // The fallback function is needed to use WRBTC\r\n        require(_msgSender() == address(wrappedCurrency), \"Bridge: not wrappedCurrency\");\r\n    }\r\n\r\n    function version() override external pure returns (string memory) {\r\n        return \"v3\";\r\n    }\r\n\r\n    function initDomainSeparator() public {\r\n        uint chainId;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = LibEIP712.hashEIP712Domain(\r\n            \"RSK Token Bridge\",\r\n            \"1\",\r\n            chainId,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    modifier whenNotUpgrading() {\r\n        require(!isUpgrading, \"Bridge: Upgrading\");\r\n        _;\r\n    }\r\n\r\n    function acceptTransfer(\r\n        address _originalTokenAddress,\r\n        address payable _from,\r\n        address payable _to,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        bytes32 _transactionHash,\r\n        uint32 _logIndex\r\n    ) external whenNotPaused nonReentrant override {\r\n        require(_msgSender() == federation, \"Bridge: Not Federation\");\r\n        require(knownTokens[_originalTokenAddress] ||\r\n            mappedTokens[_originalTokenAddress] != NULL_ADDRESS,\r\n            \"Bridge: Unknown token\"\r\n        );\r\n        require(_to != NULL_ADDRESS, \"Bridge: Null To\");\r\n        require(_amount > 0, \"Bridge: Amount 0\");\r\n        require(_blockHash != NULL_HASH, \"Bridge: Null BlockHash\");\r\n        require(_transactionHash != NULL_HASH, \"Bridge: Null TxHash\");\r\n        require(transactionsDataHashes[_transactionHash] == bytes32(0), \"Bridge: Already accepted\");\r\n\r\n        bytes32 _transactionDataHash = getTransactionDataHash(\r\n            _to,\r\n            _amount,\r\n            _blockHash,\r\n            _transactionHash,\r\n            _logIndex\r\n        );\r\n        // Do not remove, claimed also has the previously processed using the older bridge version\r\n        // https://github.com/rsksmart/tokenbridge/blob/TOKENBRIDGE-1.2.0/bridge/contracts/Bridge.sol#L41\r\n        require(!claimed[_transactionDataHash], \"Bridge: Already claimed\");\r\n\r\n        transactionsDataHashes[_transactionHash] = _transactionDataHash;\r\n        originalTokenAddresses[_transactionHash] = _originalTokenAddress;\r\n        senderAddresses[_transactionHash] = _from;\r\n\r\n        emit AcceptedCrossTransfer(\r\n            _transactionHash,\r\n            _originalTokenAddress,\r\n            _to,\r\n            _from,\r\n            _amount,\r\n            _blockHash,\r\n            _logIndex\r\n        );\r\n    }\r\n\r\n\r\n    function createSideToken(\r\n        uint256 _typeId,\r\n        address _originalTokenAddress,\r\n        uint8 _originalTokenDecimals,\r\n        string calldata _originalTokenSymbol,\r\n        string calldata _originalTokenName\r\n    ) external onlyOwner {\r\n        require(_originalTokenAddress != NULL_ADDRESS, \"Bridge: Null token\");\r\n        address sideToken = mappedTokens[_originalTokenAddress];\r\n        require(sideToken == NULL_ADDRESS, \"Bridge: Already exists\");\r\n        uint256 granularity = LibUtils.decimalsToGranularity(_originalTokenDecimals);\r\n        string memory newSymbol = string(abi.encodePacked(symbolPrefix, _originalTokenSymbol));\r\n\r\n        // Create side token\r\n        sideToken = sideTokenFactory.createSideToken(_originalTokenName, newSymbol, granularity);\r\n\r\n        mappedTokens[_originalTokenAddress] = sideToken;\r\n        originalTokens[sideToken] = _originalTokenAddress;\r\n        allowTokens.setToken(sideToken, _typeId);\r\n\r\n        emit NewSideToken(sideToken, _originalTokenAddress, newSymbol, granularity);\r\n    }\r\n\r\n    function claim(ClaimData calldata _claimData)\r\n    external override returns (uint256 receivedAmount) {\r\n\r\n        receivedAmount = _claim(\r\n            _claimData,\r\n            _claimData.to,\r\n            payable(address(0)),\r\n            0\r\n        );\r\n        return receivedAmount;\r\n    }\r\n\r\n    function claimFallback(ClaimData calldata _claimData)\r\n    external override returns (uint256 receivedAmount) {\r\n        require(_msgSender() == senderAddresses[_claimData.transactionHash],\"Bridge: invalid sender\");\r\n        receivedAmount = _claim(\r\n            _claimData,\r\n            _msgSender(),\r\n            payable(address(0)),\r\n            0\r\n        );\r\n        return receivedAmount;\r\n    }\r\n\r\n    function getDigest(\r\n        ClaimData memory _claimData,\r\n        address payable _relayer,\r\n        uint256 _fee,\r\n        uint256 _deadline\r\n    ) internal returns (bytes32) {\r\n        return LibEIP712.hashEIP712Message(\r\n            DOMAIN_SEPARATOR,\r\n            keccak256(\r\n                abi.encode(\r\n                    CLAIM_TYPEHASH,\r\n                    _claimData.to,\r\n                    _claimData.amount,\r\n                    _claimData.transactionHash,\r\n                    _relayer,\r\n                    _fee,\r\n                    nonces[_claimData.to]++,\r\n                    _deadline\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // Inspired by https://github.com/dapphub/ds-dach/blob/master/src/dach.sol\r\n    function claimGasless(\r\n        ClaimData calldata _claimData,\r\n        address payable _relayer,\r\n        uint256 _fee,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external override returns (uint256 receivedAmount) {\r\n        require(_deadline >= block.timestamp, \"Bridge: EXPIRED\");\r\n\r\n        bytes32 digest = getDigest(_claimData, _relayer, _fee, _deadline);\r\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\r\n        require(_claimData.to != address(0) && recoveredAddress == _claimData.to, \"Bridge: INVALID_SIGNATURE\");\r\n\r\n        receivedAmount = _claim(\r\n            _claimData,\r\n            _claimData.to,\r\n            _relayer,\r\n            _fee\r\n        );\r\n        return receivedAmount;\r\n    }\r\n\r\n    function _claim(\r\n        ClaimData calldata _claimData,\r\n        address payable _reciever,\r\n        address payable _relayer,\r\n        uint256 _fee\r\n    ) internal nonReentrant returns (uint256 receivedAmount) {\r\n        address originalTokenAddress = originalTokenAddresses[_claimData.transactionHash];\r\n        require(originalTokenAddress != NULL_ADDRESS, \"Bridge: Tx not crossed\");\r\n\r\n        bytes32 transactionDataHash = getTransactionDataHash(\r\n            _claimData.to,\r\n            _claimData.amount,\r\n            _claimData.blockHash,\r\n            _claimData.transactionHash,\r\n            _claimData.logIndex\r\n        );\r\n        require(transactionsDataHashes[_claimData.transactionHash] == transactionDataHash, \"Bridge: Wrong transactionDataHash\");\r\n        require(!claimed[transactionDataHash], \"Bridge: Already claimed\");\r\n\r\n        claimed[transactionDataHash] = true;\r\n        if (knownTokens[originalTokenAddress]) {\r\n            receivedAmount =_claimCrossBackToToken(\r\n                originalTokenAddress,\r\n                _reciever,\r\n                _claimData.amount,\r\n                _relayer,\r\n                _fee\r\n            );\r\n        } else {\r\n            receivedAmount =_claimCrossToSideToken(\r\n                originalTokenAddress,\r\n                _reciever,\r\n                _claimData.amount,\r\n                _relayer,\r\n                _fee\r\n            );\r\n        }\r\n        emit Claimed(\r\n            _claimData.transactionHash,\r\n            originalTokenAddress,\r\n            _claimData.to,\r\n            senderAddresses[_claimData.transactionHash],\r\n            _claimData.amount,\r\n            _claimData.blockHash,\r\n            _claimData.logIndex,\r\n            _reciever,\r\n            _relayer,\r\n            _fee\r\n        );\r\n        return receivedAmount;\r\n    }\r\n\r\n    function _claimCrossToSideToken(\r\n        address _originalTokenAddress,\r\n        address payable _receiver,\r\n        uint256 _amount,\r\n        address payable _relayer,\r\n        uint256 _fee\r\n    ) internal returns (uint256 receivedAmount) {\r\n        address sideToken = mappedTokens[_originalTokenAddress];\r\n        uint256 granularity = IERC777(sideToken).granularity();\r\n        uint256 formattedAmount = _amount.mul(granularity);\r\n        require(_fee <= formattedAmount, \"Bridge: fee too high\");\r\n        receivedAmount = formattedAmount - _fee;\r\n        ISideToken(sideToken).mint(_receiver, receivedAmount, \"\", \"\");\r\n        if(_fee > 0) {\r\n            ISideToken(sideToken).mint(_relayer, _fee, \"\", \"relayer fee\");\r\n        }\r\n        return receivedAmount;\r\n    }\r\n\r\n    function _claimCrossBackToToken(\r\n        address _originalTokenAddress,\r\n        address payable _receiver,\r\n        uint256 _amount,\r\n        address payable _relayer,\r\n        uint256 _fee\r\n    ) internal returns (uint256 receivedAmount) {\r\n        uint256 decimals = LibUtils.getDecimals(_originalTokenAddress);\r\n        //As side tokens are ERC777 they will always have 18 decimals\r\n        uint256 formattedAmount = _amount.div(uint256(10) ** (18 - decimals));\r\n        require(_fee <= formattedAmount, \"Bridge: fee too high\");\r\n        receivedAmount = formattedAmount - _fee;\r\n        if(address(wrappedCurrency) == _originalTokenAddress) {\r\n            wrappedCurrency.withdraw(formattedAmount);\r\n            _receiver.transfer(receivedAmount);\r\n            if(_fee > 0) {\r\n                _relayer.transfer(_fee);\r\n            }\r\n        } else {\r\n            IERC20(_originalTokenAddress).safeTransfer(_receiver, receivedAmount);\r\n            if(_fee > 0) {\r\n                IERC20(_originalTokenAddress).safeTransfer(_relayer, _fee);\r\n            }\r\n        }\r\n        return receivedAmount;\r\n    }\r\n\r\n    /**\r\n     * ERC-20 tokens approve and transferFrom pattern\r\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\r\n     */\r\n    function receiveTokensTo(address tokenToUse, address to, uint256 amount) override public {\r\n        address sender = _msgSender();\r\n        //Transfer the tokens on IERC20, they should be already Approved for the bridge Address to use them\r\n        IERC20(tokenToUse).safeTransferFrom(sender, address(this), amount);\r\n        crossTokens(tokenToUse, sender, to, amount, \"\");\r\n    }\r\n\r\n    /**\r\n     * Use network currency and cross it.\r\n     */\r\n    function depositTo(address to) override external payable {\r\n        address sender = _msgSender();\r\n        require(address(wrappedCurrency) != NULL_ADDRESS, \"Bridge: wrappedCurrency empty\");\r\n        wrappedCurrency.deposit{ value: msg.value }();\r\n        crossTokens(address(wrappedCurrency), sender, to, msg.value, \"\");\r\n    }\r\n\r\n    /**\r\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\r\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\r\n     */\r\n    function tokensReceived (\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata\r\n    ) external override(IBridge, IERC777Recipient){\r\n        //Hook from ERC777address\r\n        if(operator == address(this)) return; // Avoid loop from bridge calling to ERC77transferFrom\r\n        require(to == address(this), \"Bridge: Not to this address\");\r\n        address tokenToUse = _msgSender();\r\n        require(erc1820.getInterfaceImplementer(tokenToUse, _erc777Interface) != NULL_ADDRESS, \"Bridge: Not ERC777 token\");\r\n        require(userData.length != 0 || !from.isContract(), \"Bridge: Specify receiver address in data\");\r\n        address receiver = userData.length == 0 ? from : LibUtils.bytesToAddress(userData);\r\n        crossTokens(tokenToUse, from, receiver, amount, userData);\r\n    }\r\n\r\n    function crossTokens(address tokenToUse, address from, address to, uint256 amount, bytes memory userData)\r\n    internal whenNotUpgrading whenNotPaused nonReentrant {\r\n        knownTokens[tokenToUse] = true;\r\n        uint256 fee = amount.mul(feePercentage).div(feePercentageDivider);\r\n        uint256 amountMinusFees = amount.sub(fee);\r\n        uint8 decimals = LibUtils.getDecimals(tokenToUse);\r\n        uint formattedAmount = amount;\r\n        if(decimals != 18) {\r\n            formattedAmount = amount.mul(uint256(10)**(18-decimals));\r\n        }\r\n        // We consider the amount before fees converted to 18 decimals to check the limits\r\n        // updateTokenTransfer revert if token not allowed\r\n        allowTokens.updateTokenTransfer(tokenToUse, formattedAmount);\r\n        address originalTokenAddress = tokenToUse;\r\n        if (originalTokens[tokenToUse] != NULL_ADDRESS) {\r\n            //Side Token Crossing\r\n            originalTokenAddress = originalTokens[tokenToUse];\r\n            uint256 granularity = LibUtils.getGranularity(tokenToUse);\r\n            uint256 modulo = amountMinusFees.mod(granularity);\r\n            fee = fee.add(modulo);\r\n            amountMinusFees = amountMinusFees.sub(modulo);\r\n            IERC777(tokenToUse).burn(amountMinusFees, userData);\r\n        }\r\n\r\n        emit Cross(\r\n            originalTokenAddress,\r\n            from,\r\n            to,\r\n            amountMinusFees,\r\n            userData\r\n        );\r\n\r\n        if (fee > 0) {\r\n            //Send the payment to the MultiSig of the Federation\r\n            IERC20(tokenToUse).safeTransfer(owner(), fee);\r\n        }\r\n    }\r\n\r\n    function getTransactionDataHash(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes32 _blockHash,\r\n        bytes32 _transactionHash,\r\n        uint32 _logIndex\r\n    )\r\n        public pure override returns(bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_blockHash, _transactionHash, _to, _amount, _logIndex));\r\n    }\r\n\r\n    function setFeePercentage(uint amount) external onlyOwner {\r\n        require(amount < (feePercentageDivider/10), \"Bridge: bigger than 10%\");\r\n        feePercentage = amount;\r\n        emit FeePercentageChanged(feePercentage);\r\n    }\r\n\r\n    function getFeePercentage() external view override returns(uint) {\r\n        return feePercentage;\r\n    }\r\n\r\n    function changeFederation(address newFederation) external onlyOwner {\r\n        require(newFederation != NULL_ADDRESS, \"Bridge: Federation is empty\");\r\n        federation = newFederation;\r\n        emit FederationChanged(federation);\r\n    }\r\n\r\n\r\n    function changeAllowTokens(address newAllowTokens) external onlyOwner {\r\n        require(newAllowTokens != NULL_ADDRESS, \"Bridge: AllowTokens is empty\");\r\n        allowTokens = IAllowTokens(newAllowTokens);\r\n        emit AllowTokensChanged(newAllowTokens);\r\n    }\r\n\r\n    function getFederation() external view returns(address) {\r\n        return federation;\r\n    }\r\n\r\n    function changeSideTokenFactory(address newSideTokenFactory) external onlyOwner {\r\n        require(newSideTokenFactory != NULL_ADDRESS, \"Bridge: SideTokenFactory is empty\");\r\n        sideTokenFactory = ISideTokenFactory(newSideTokenFactory);\r\n        emit SideTokenFactoryChanged(newSideTokenFactory);\r\n    }\r\n\r\n    function setUpgrading(bool _isUpgrading) external onlyOwner {\r\n        isUpgrading = _isUpgrading;\r\n        emit Upgrading(isUpgrading);\r\n    }\r\n\r\n    function setWrappedCurrency(address _wrappedCurrency) external onlyOwner {\r\n        require(_wrappedCurrency != NULL_ADDRESS, \"Bridge: wrapp is empty\");\r\n        wrappedCurrency = IWrapped(_wrappedCurrency);\r\n        emit WrappedCurrencyChanged(_wrappedCurrency);\r\n    }\r\n\r\n    function hasCrossed(bytes32 transactionHash) public view returns (bool) {\r\n        return transactionsDataHashes[transactionHash] != bytes32(0);\r\n    }\r\n\r\n    function hasBeenClaimed(bytes32 transactionHash) public view returns (bool) {\r\n        return claimed[transactionsDataHashes[transactionHash]];\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_originalTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_blockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_logIndex\",\"type\":\"uint256\"}],\"name\":\"AcceptedCrossTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newAllowTokens\",\"type\":\"address\"}],\"name\":\"AllowTokensChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_originalTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_blockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_logIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_reciever\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_userData\",\"type\":\"bytes\"}],\"name\":\"Cross\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newFederation\",\"type\":\"address\"}],\"name\":\"FederationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FeePercentageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newSideTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_originalTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_newSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_granularity\",\"type\":\"uint256\"}],\"name\":\"NewSideToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newSideTokenFactory\",\"type\":\"address\"}],\"name\":\"SideTokenFactoryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isUpgrading\",\"type\":\"bool\"}],\"name\":\"Upgrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_wrappedCurrency\",\"type\":\"address\"}],\"name\":\"WrappedCurrencyChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CLAIM_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"__Pausable_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"__PauserRol_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_originalTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_logIndex\",\"type\":\"uint32\"}],\"name\":\"acceptTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowTokens\",\"outputs\":[{\"internalType\":\"contract IAllowTokens\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAllowTokens\",\"type\":\"address\"}],\"name\":\"changeAllowTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFederation\",\"type\":\"address\"}],\"name\":\"changeFederation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSideTokenFactory\",\"type\":\"address\"}],\"name\":\"changeSideTokenFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"logIndex\",\"type\":\"uint32\"}],\"internalType\":\"struct IBridge.ClaimData\",\"name\":\"_claimData\",\"type\":\"tuple\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"logIndex\",\"type\":\"uint32\"}],\"internalType\":\"struct IBridge.ClaimData\",\"name\":\"_claimData\",\"type\":\"tuple\"}],\"name\":\"claimFallback\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"logIndex\",\"type\":\"uint32\"}],\"internalType\":\"struct IBridge.ClaimData\",\"name\":\"_claimData\",\"type\":\"tuple\"},{\"internalType\":\"address payable\",\"name\":\"_relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"claimGasless\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_originalTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_originalTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_originalTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_originalTokenName\",\"type\":\"string\"}],\"name\":\"createSideToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"depositTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentageDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFederation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_logIndex\",\"type\":\"uint32\"}],\"name\":\"getTransactionDataHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"hasBeenClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"hasCrossed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initDomainSeparator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_federation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_allowTokens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sideTokenFactory\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_symbolPrefix\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUpgrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"knownTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mappedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"originalTokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"originalTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenToUse\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"receiveTokensTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"senderAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isUpgrading\",\"type\":\"bool\"}],\"name\":\"setUpgrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrappedCurrency\",\"type\":\"address\"}],\"name\":\"setWrappedCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sideTokenFactory\",\"outputs\":[{\"internalType\":\"contract ISideTokenFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbolPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"transactionsDataHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedCurrency\",\"outputs\":[{\"internalType\":\"contract IWrapped\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Bridge","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e143d2279b60c05f738592181a70ec82915a0a581781d565db6d7865329e772a"}]}