{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.7.1;\r\n\r\ninterface TransferETHInterface {\r\n    receive() external payable;\r\n\r\n    event LogTransferETH(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/bondToken/BondTokenInterface.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\ninterface BondTokenInterface is IERC20 {\r\n    event LogExpire(uint128 rateNumerator, uint128 rateDenominator, bool firstTime);\r\n\r\n    function mint(address account, uint256 amount) external returns (bool success);\r\n\r\n    function expire(uint128 rateNumerator, uint128 rateDenominator)\r\n        external\r\n        returns (bool firstTime);\r\n\r\n    function simpleBurn(address account, uint256 amount) external returns (bool success);\r\n\r\n    function burn(uint256 amount) external returns (bool success);\r\n\r\n    function burnAll() external returns (uint256 amount);\r\n\r\n    function getRate() external view returns (uint128 rateNumerator, uint128 rateDenominator);\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/oracle/LatestPriceOracleInterface.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n/**\r\n * @dev Interface of the price oracle.\r\n */\r\ninterface LatestPriceOracleInterface {\r\n    /**\r\n     * @dev Returns `true`if oracle is working.\r\n     */\r\n    function isWorking() external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the last updated price. Decimals is 8.\r\n     **/\r\n    function latestPrice() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the timestamp of the last updated price.\r\n     */\r\n    function latestTimestamp() external returns (uint256);\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/oracle/PriceOracleInterface.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n/**\r\n * @dev Interface of the price oracle.\r\n */\r\ninterface PriceOracleInterface is LatestPriceOracleInterface {\r\n    /**\r\n     * @dev Returns the latest id. The id start from 1 and increments by 1.\r\n     */\r\n    function latestId() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the historical price specified by `id`. Decimals is 8.\r\n     */\r\n    function getPrice(uint256 id) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the timestamp of historical price specified by `id`.\r\n     */\r\n    function getTimestamp(uint256 id) external returns (uint256);\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/bondMaker/BondMakerInterface.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\ninterface BondMakerInterface {\r\n    event LogNewBond(\r\n        bytes32 indexed bondID,\r\n        address indexed bondTokenAddress,\r\n        uint256 indexed maturity,\r\n        bytes32 fnMapID\r\n    );\r\n\r\n    event LogNewBondGroup(\r\n        uint256 indexed bondGroupID,\r\n        uint256 indexed maturity,\r\n        uint64 indexed sbtStrikePrice,\r\n        bytes32[] bondIDs\r\n    );\r\n\r\n    event LogIssueNewBonds(uint256 indexed bondGroupID, address indexed issuer, uint256 amount);\r\n\r\n    event LogReverseBondGroupToCollateral(\r\n        uint256 indexed bondGroupID,\r\n        address indexed owner,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogExchangeEquivalentBonds(\r\n        address indexed owner,\r\n        uint256 indexed inputBondGroupID,\r\n        uint256 indexed outputBondGroupID,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogLiquidateBond(bytes32 indexed bondID, uint128 rateNumerator, uint128 rateDenominator);\r\n\r\n    function registerNewBond(uint256 maturity, bytes calldata fnMap)\r\n        external\r\n        returns (\r\n            bytes32 bondID,\r\n            address bondTokenAddress,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function registerNewBondGroup(bytes32[] calldata bondIDList, uint256 maturity)\r\n        external\r\n        returns (uint256 bondGroupID);\r\n\r\n    function reverseBondGroupToCollateral(uint256 bondGroupID, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function exchangeEquivalentBonds(\r\n        uint256 inputBondGroupID,\r\n        uint256 outputBondGroupID,\r\n        uint256 amount,\r\n        bytes32[] calldata exceptionBonds\r\n    ) external returns (bool);\r\n\r\n    function liquidateBond(uint256 bondGroupID, uint256 oracleHintID)\r\n        external\r\n        returns (uint256 totalPayment);\r\n\r\n    function collateralAddress() external view returns (address);\r\n\r\n    function oracleAddress() external view returns (PriceOracleInterface);\r\n\r\n    function feeTaker() external view returns (address);\r\n\r\n    function decimalsOfBond() external view returns (uint8);\r\n\r\n    function decimalsOfOraclePrice() external view returns (uint8);\r\n\r\n    function maturityScale() external view returns (uint256);\r\n\r\n    function nextBondGroupID() external view returns (uint256);\r\n\r\n    function getBond(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (\r\n            address bondAddress,\r\n            uint256 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function getFnMap(bytes32 fnMapID) external view returns (bytes memory fnMap);\r\n\r\n    function getBondGroup(uint256 bondGroupID)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs, uint256 maturity);\r\n\r\n    function generateFnMapID(bytes calldata fnMap) external view returns (bytes32 fnMapID);\r\n\r\n    function generateBondID(uint256 maturity, bytes calldata fnMap)\r\n        external\r\n        view\r\n        returns (bytes32 bondID);\r\n}\r\n\r\n// File: contracts/Interfaces/StrategyInterface.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ninterface SimpleStrategyInterface {\r\n    function calcNextMaturity() external view returns (uint256 nextTimeStamp);\r\n\r\n    function calcCallStrikePrice(\r\n        uint256 currentPriceE8,\r\n        uint64 priceUnit,\r\n        bool isReversedOracle\r\n    ) external pure returns (uint256 callStrikePrice);\r\n\r\n    function calcRoundPrice(\r\n        uint256 price,\r\n        uint64 priceUnit,\r\n        uint8 divisor\r\n    ) external pure returns (uint256 roundedPrice);\r\n\r\n    function getTrancheBonds(\r\n        BondMakerInterface bondMaker,\r\n        address aggregatorAddress,\r\n        uint256 issueBondGroupIdOrStrikePrice,\r\n        uint256 price,\r\n        uint256[] calldata bondGroupList,\r\n        uint64 priceUnit,\r\n        bool isReversedOracle\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 issueAmount,\r\n            uint256 ethAmount,\r\n            uint256[2] memory IDAndAmountOfBurn\r\n        );\r\n\r\n    function getCurrentStrikePrice(\r\n        uint256 currentPriceE8,\r\n        uint64 priceUnit,\r\n        bool isReversedOracle\r\n    ) external pure returns (uint256);\r\n\r\n    function getCurrentSpread(\r\n        address owner,\r\n        address oracleAddress,\r\n        bool isReversedOracle\r\n    ) external view returns (int16);\r\n\r\n    function registerCurrentFeeBase(\r\n        int16 currentFeeBase,\r\n        uint256 currentCollateralPerToken,\r\n        uint256 nextCollateralPerToken,\r\n        address owner,\r\n        address oracleAddress,\r\n        bool isReversedOracle\r\n    ) external;\r\n}\r\n\r\n// File: contracts/Interfaces/SimpleAggragatorInterface.sol\r\n\r\n\r\npragma experimental ABIEncoderV2;\r\npragma solidity 0.7.1;\r\n\r\ninterface SimpleAggregatorInterface {\r\n    struct TotalReward {\r\n        uint64 term;\r\n        uint64 value;\r\n    }\r\n\r\n    enum AggregatorPhase {BEFORE_START, ACTIVE, COOL_TIME, AFTER_MATURITY, EXPIRED}\r\n\r\n    function renewMaturity() external;\r\n\r\n    function removeLiquidity(uint128 amount) external returns (bool success);\r\n\r\n    function settleTokens() external returns (uint256 unsentETH, uint256 unsentToken);\r\n\r\n    function changeSpread() external;\r\n\r\n    function liquidateBonds(uint256 hintID) external;\r\n\r\n    function trancheBonds() external;\r\n\r\n    function claimReward() external;\r\n\r\n    function addSuitableBondGroup() external returns (uint256 bondGroupID);\r\n\r\n    function getCollateralAddress() external view returns (address);\r\n\r\n    function getCollateralAmount() external view returns (uint256);\r\n\r\n    function getCollateralDecimal() external view returns (int16);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function getExpectedBalance(address user) external view returns (uint256 expectedBalance);\r\n\r\n    function getCurrentPhase() external view returns (AggregatorPhase);\r\n\r\n    function updateStartBondGroupId() external;\r\n\r\n    function getInfo()\r\n        external\r\n        view\r\n        returns (\r\n            address bondMaker,\r\n            address strategy,\r\n            address dotc,\r\n            address bondPricerAddress,\r\n            address oracleAddress,\r\n            address rewardTokenAddress,\r\n            address registratorAddress,\r\n            address owner,\r\n            bool reverseOracle,\r\n            uint64 basePriceUnit,\r\n            uint128 maxSupply\r\n        );\r\n\r\n    function getCurrentStatus()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 term,\r\n            int16 feeBase,\r\n            uint32 uncheckbondGroupId,\r\n            uint64 unit,\r\n            uint64 trancheTime,\r\n            bool isDanger\r\n        );\r\n\r\n    function getTermInfo(uint256 term)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 SBTID\r\n        );\r\n\r\n    function getBondGroupIDFromTermAndPrice(uint256 term, uint256 price)\r\n        external\r\n        view\r\n        returns (uint256 bondGroupID);\r\n\r\n    function getRewardAmount(address user) external view returns (uint64);\r\n\r\n    function getTotalRewards() external view returns (TotalReward[] memory);\r\n\r\n    function isTotalSupplySafe() external view returns (bool);\r\n\r\n    function getTotalUnmovedAssets() external view returns (uint256, uint256);\r\n\r\n    function totalShareData(uint256 term)\r\n        external\r\n        view\r\n        returns (uint128 totalShare, uint128 totalCollateralPerToken);\r\n\r\n    function getCollateralPerToken(uint256 term) external view returns (uint256);\r\n\r\n    function getBondGroupIdFromStrikePrice(uint256 term, uint256 strikePrice)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getBalanceData(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint128 amount,\r\n            uint64 term,\r\n            uint64 rewardAmount\r\n        );\r\n\r\n    function getIssuableBondGroups() external view returns (uint256[] memory);\r\n\r\n    function getLiquidationData(uint256 term)\r\n        external\r\n        view\r\n        returns (\r\n            bool isLiquidated,\r\n            uint32 liquidatedBondGroupID,\r\n            uint32 endBondGroupId\r\n        );\r\n}\r\n\r\n// File: contracts/Interfaces/VolatilityOracleInterface.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\ninterface VolatilityOracleInterface {\r\n    function getVolatility(uint64 untilMaturity) external view returns (uint64 volatilityE8);\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/bondPricer/Enums.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n/**\r\n    Pure SBT:\r\n        ___________\r\n       /\r\n      /\r\n     /\r\n    /\r\n\r\n    LBT Shape:\r\n              /\r\n             /\r\n            /\r\n           /\r\n    ______/\r\n\r\n    SBT Shape:\r\n              ______\r\n             /\r\n            /\r\n    _______/\r\n\r\n    Triangle:\r\n              /\\\r\n             /  \\\r\n            /    \\\r\n    _______/      \\________\r\n */\r\nenum BondType {NONE, PURE_SBT, SBT_SHAPE, LBT_SHAPE, TRIANGLE}\r\n\r\n// File: contracts/BondToken_and_GDOTC/bondPricer/BondPricerInterface.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ninterface BondPricerInterface {\r\n    /**\r\n     * @notice Calculate bond price and leverage by black-scholes formula.\r\n     * @param bondType type of target bond.\r\n     * @param points coodinates of polyline which is needed for price calculation\r\n     * @param spotPrice is a oracle price.\r\n     * @param volatilityE8 is a oracle volatility.\r\n     * @param untilMaturity Remaining period of target bond in second\r\n     **/\r\n    function calcPriceAndLeverage(\r\n        BondType bondType,\r\n        uint256[] calldata points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity\r\n    ) external view returns (uint256 price, uint256 leverageE8);\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n// File: contracts/Interfaces/ExchangeInterface.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n\r\ninterface ExchangeInterface {\r\n    function changeSpread(int16 spread) external;\r\n\r\n    function createVsBondPool(\r\n        BondMakerInterface bondMakerForUserAddress,\r\n        VolatilityOracleInterface volatilityOracleAddress,\r\n        BondPricerInterface bondPricerForUserAddress,\r\n        BondPricerInterface bondPricerAddress,\r\n        int16 feeBaseE4\r\n    ) external returns (bytes32 poolID);\r\n\r\n    function createVsErc20Pool(\r\n        ERC20 swapPairAddress,\r\n        LatestPriceOracleInterface swapPairOracleAddress,\r\n        BondPricerInterface bondPricerAddress,\r\n        int16 feeBaseE4,\r\n        bool isBondSale\r\n    ) external returns (bytes32 poolID);\r\n\r\n    function createVsEthPool(\r\n        LatestPriceOracleInterface ethOracleAddress,\r\n        BondPricerInterface bondPricerAddress,\r\n        int16 feeBaseE4,\r\n        bool isBondSale\r\n    ) external returns (bytes32 poolID);\r\n\r\n    function updateVsBondPool(\r\n        bytes32 poolID,\r\n        VolatilityOracleInterface volatilityOracleAddress,\r\n        BondPricerInterface bondPricerForUserAddress,\r\n        BondPricerInterface bondPricerAddress,\r\n        int16 feeBaseE4\r\n    ) external;\r\n\r\n    function updateVsErc20Pool(\r\n        bytes32 poolID,\r\n        LatestPriceOracleInterface swapPairOracleAddress,\r\n        BondPricerInterface bondPricerAddress,\r\n        int16 feeBaseE4\r\n    ) external;\r\n\r\n    function updateVsEthPool(\r\n        bytes32 poolID,\r\n        LatestPriceOracleInterface ethOracleAddress,\r\n        BondPricerInterface bondPricerAddress,\r\n        int16 feeBaseE4\r\n    ) external;\r\n\r\n    function generateVsBondPoolID(address seller, address bondMakerForUser)\r\n        external\r\n        view\r\n        returns (bytes32 poolID);\r\n\r\n    function generateVsErc20PoolID(\r\n        address seller,\r\n        address swapPairAddress,\r\n        bool isBondSale\r\n    ) external view returns (bytes32 poolID);\r\n\r\n    function generateVsEthPoolID(address seller, bool isBondSale)\r\n        external\r\n        view\r\n        returns (bytes32 poolID);\r\n\r\n    function withdrawEth() external;\r\n\r\n    function depositEth() external payable;\r\n\r\n    function ethAllowance(address owner) external view returns (uint256 amount);\r\n\r\n    function bondMakerAddress() external view returns (BondMakerInterface);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SignedSafeMath.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/math/UseSafeMath.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice ((a - 1) / b) + 1 = (a + b -1) / b\r\n * for example a.add(10**18 -1).div(10**18) = a.sub(1).div(10**18) + 1\r\n */\r\n\r\nlibrary SafeMathDivRoundUp {\r\n    using SafeMath for uint256;\r\n\r\n    function divRoundUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(b > 0, errorMessage);\r\n        return ((a - 1) / b) + 1;\r\n    }\r\n\r\n    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return divRoundUp(a, b, \"SafeMathDivRoundUp: modulo by zero\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title UseSafeMath\r\n * @dev One can use SafeMath for not only uint256 but also uin64 or uint16,\r\n * and also can use SafeCast for uint256.\r\n * For example:\r\n *   uint64 a = 1;\r\n *   uint64 b = 2;\r\n *   a = a.add(b).toUint64() // `a` become 3 as uint64\r\n * In addition, one can use SignedSafeMath and SafeCast.toUint256(int256) for int256.\r\n * In the case of the operation to the uint64 value, one needs to cast the value into int256 in\r\n * advance to use `sub` as SignedSafeMath.sub not SafeMath.sub.\r\n * For example:\r\n *   int256 a = 1;\r\n *   uint64 b = 2;\r\n *   int256 c = 3;\r\n *   a = a.add(int256(b).sub(c)); // `a` becomes 0 as int256\r\n *   b = a.toUint256().toUint64(); // `b` becomes 0 as uint64\r\n */\r\nabstract contract UseSafeMath {\r\n    using SafeMath for uint256;\r\n    using SafeMathDivRoundUp for uint256;\r\n    using SafeMath for uint64;\r\n    using SafeMathDivRoundUp for uint64;\r\n    using SafeMath for uint16;\r\n    using SignedSafeMath for int256;\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/math/AdvancedMath.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\nabstract contract AdvancedMath {\r\n    /**\r\n     * @dev sqrt(2*PI) * 10^8\r\n     */\r\n    int256 internal constant SQRT_2PI_E8 = 250662827;\r\n    int256 internal constant PI_E8 = 314159265;\r\n    int256 internal constant E_E8 = 271828182;\r\n    int256 internal constant INV_E_E8 = 36787944; // 1/e\r\n    int256 internal constant LOG2_E8 = 30102999;\r\n    int256 internal constant LOG3_E8 = 47712125;\r\n\r\n    int256 internal constant p = 23164190;\r\n    int256 internal constant b1 = 31938153;\r\n    int256 internal constant b2 = -35656378;\r\n    int256 internal constant b3 = 178147793;\r\n    int256 internal constant b4 = -182125597;\r\n    int256 internal constant b5 = 133027442;\r\n\r\n    /**\r\n     * @dev Calcurate an approximate value of the square root of x by Babylonian method.\r\n     */\r\n    function _sqrt(int256 x) internal pure returns (int256 y) {\r\n        require(x >= 0, \"cannot calculate the square root of a negative number\");\r\n        int256 z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns log(x) for any positive x.\r\n     */\r\n    function _logTaylor(int256 inputE4) internal pure returns (int256 outputE4) {\r\n        require(inputE4 > 1, \"input should be positive number\");\r\n        int256 inputE8 = inputE4 * 10**4;\r\n        // input x for _logTayler1 is adjusted to 1/e < x < 1.\r\n        while (inputE8 < INV_E_E8) {\r\n            inputE8 = (inputE8 * E_E8) / 10**8;\r\n            outputE4 -= 10**4;\r\n        }\r\n        while (inputE8 > 10**8) {\r\n            inputE8 = (inputE8 * INV_E_E8) / 10**8;\r\n            outputE4 += 10**4;\r\n        }\r\n        outputE4 += _logTaylor1(inputE8 / 10**4 - 10**4);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate an approximate value of the logarithm of input value by\r\n     * Taylor expansion around 1.\r\n     * @dev log(x + 1) = x - 1/2 x^2 + 1/3 x^3 - 1/4 x^4 + 1/5 x^5\r\n     *                     - 1/6 x^6 + 1/7 x^7 - 1/8 x^8 + ...\r\n     */\r\n    function _logTaylor1(int256 inputE4) internal pure returns (int256 outputE4) {\r\n        outputE4 =\r\n            inputE4 -\r\n            inputE4**2 /\r\n            (2 * 10**4) +\r\n            inputE4**3 /\r\n            (3 * 10**8) -\r\n            inputE4**4 /\r\n            (4 * 10**12) +\r\n            inputE4**5 /\r\n            (5 * 10**16) -\r\n            inputE4**6 /\r\n            (6 * 10**20) +\r\n            inputE4**7 /\r\n            (7 * 10**24) -\r\n            inputE4**8 /\r\n            (8 * 10**28);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the cumulative distribution function of standard normal\r\n     * distribution.\r\n     * @dev Abramowitz and Stegun, Handbook of Mathematical Functions (1964)\r\n     * http://people.math.sfu.ca/~cbm/aands/\r\n     */\r\n    function _calcPnorm(int256 inputE4) internal pure returns (int256 outputE8) {\r\n        require(inputE4 < 440 * 10**4 && inputE4 > -440 * 10**4, \"input is too large\");\r\n        int256 _inputE4 = inputE4 > 0 ? inputE4 : inputE4 * (-1);\r\n        int256 t = 10**16 / (10**8 + (p * _inputE4) / 10**4);\r\n        int256 X2 = (inputE4 * inputE4) / 2;\r\n        int256 exp2X2 = 10**8 +\r\n            X2 +\r\n            (X2**2 / (2 * 10**8)) +\r\n            (X2**3 / (6 * 10**16)) +\r\n            (X2**4 / (24 * 10**24)) +\r\n            (X2**5 / (120 * 10**32)) +\r\n            (X2**6 / (720 * 10**40));\r\n        int256 Z = (10**24 / exp2X2) / SQRT_2PI_E8;\r\n        int256 y = (b5 * t) / 10**8;\r\n        y = ((y + b4) * t) / 10**8;\r\n        y = ((y + b3) * t) / 10**8;\r\n        y = ((y + b2) * t) / 10**8;\r\n        y = 10**8 - (Z * ((y + b1) * t)) / 10**16;\r\n        return inputE4 > 0 ? y : 10**8 - y;\r\n    }\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/bondPricer/GeneralizedPricing.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev The decimals of price, point, spotPrice and strikePrice are all the same.\r\n */\r\ncontract GeneralizedPricing is AdvancedMath {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev sqrt(365*86400) * 10^8\r\n     */\r\n    int256 internal constant SQRT_YEAR_E8 = 5615.69229926 * 10**8;\r\n\r\n    int256 internal constant MIN_ND1_E8 = 0.0001 * 10**8;\r\n    int256 internal constant MAX_ND1_E8 = 0.9999 * 10**8;\r\n    uint256 internal constant MAX_LEVERAGE_E8 = 1000 * 10**8;\r\n\r\n    /**\r\n     * @notice Calculate bond price and leverage by black-scholes formula.\r\n     * @param bondType type of target bond.\r\n     * @param points coodinates of polyline which is needed for price calculation\r\n     * @param untilMaturity Remaining period of target bond in second\r\n     **/\r\n    function calcPriceAndLeverage(\r\n        BondType bondType,\r\n        uint256[] memory points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity\r\n    ) public pure returns (uint256 price, uint256 leverageE8) {\r\n        if (bondType == BondType.LBT_SHAPE) {\r\n            (price, leverageE8) = _calcLbtShapePriceAndLeverage(\r\n                points,\r\n                spotPrice,\r\n                volatilityE8,\r\n                untilMaturity\r\n            );\r\n        } else if (bondType == BondType.SBT_SHAPE) {\r\n            (price, leverageE8) = _calcSbtShapePrice(\r\n                points,\r\n                spotPrice,\r\n                volatilityE8,\r\n                untilMaturity\r\n            );\r\n        } else if (bondType == BondType.TRIANGLE) {\r\n            (price, leverageE8) = _calcTrianglePrice(\r\n                points,\r\n                spotPrice,\r\n                volatilityE8,\r\n                untilMaturity\r\n            );\r\n        } else if (bondType == BondType.PURE_SBT) {\r\n            (price, leverageE8) = _calcPureSBTPrice(points, spotPrice, volatilityE8, untilMaturity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate pure call option price and multiply incline of LBT.\r\n     **/\r\n\r\n    function _calcLbtShapePriceAndLeverage(\r\n        uint256[] memory points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity\r\n    ) internal pure returns (uint256 price, uint256 leverageE8) {\r\n        require(points.length == 3, \"3 coordinates is needed for LBT price calculation\");\r\n        uint256 inclineE8 = (points[2].mul(10**8)).div(points[1].sub(points[0]));\r\n        (uint256 callOptionPriceE8, int256 nd1E8) = calcCallOptionPrice(\r\n            spotPrice,\r\n            int256(points[0]),\r\n            volatilityE8,\r\n            untilMaturity\r\n        );\r\n        price = (callOptionPriceE8 * inclineE8) / 10**8;\r\n        leverageE8 = _calcLbtLeverage(\r\n            uint256(spotPrice),\r\n            price,\r\n            (nd1E8 * int256(inclineE8)) / 10**8\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate (etherPrice - call option price at strike price of SBT).\r\n     **/\r\n    function _calcPureSBTPrice(\r\n        uint256[] memory points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity\r\n    ) internal pure returns (uint256 price, uint256 leverageE8) {\r\n        require(points.length == 1, \"1 coordinate is needed for pure SBT price calculation\");\r\n        (uint256 callOptionPrice1, int256 nd1E8) = calcCallOptionPrice(\r\n            spotPrice,\r\n            int256(points[0]),\r\n            volatilityE8,\r\n            untilMaturity\r\n        );\r\n        price = uint256(spotPrice) > callOptionPrice1 ? (uint256(spotPrice) - callOptionPrice1) : 0;\r\n        leverageE8 = _calcLbtLeverage(uint256(spotPrice), price, 10**8 - nd1E8);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate (call option1  - call option2) * incline of SBT.\r\n\r\n              ______                 /\r\n             /                      /\r\n            /          =           /        -                   /\r\n    _______/               _______/                 ___________/\r\n    SBT SHAPE BOND         CALL OPTION 1            CALL OPTION 2\r\n     **/\r\n    function _calcSbtShapePrice(\r\n        uint256[] memory points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity\r\n    ) internal pure returns (uint256 price, uint256 leverageE8) {\r\n        require(points.length == 3, \"3 coordinates is needed for SBT price calculation\");\r\n        uint256 inclineE8 = (points[2].mul(10**8)).div(points[1].sub(points[0]));\r\n        (uint256 callOptionPrice1, int256 nd11E8) = calcCallOptionPrice(\r\n            spotPrice,\r\n            int256(points[0]),\r\n            volatilityE8,\r\n            untilMaturity\r\n        );\r\n        (uint256 callOptionPrice2, int256 nd12E8) = calcCallOptionPrice(\r\n            spotPrice,\r\n            int256(points[1]),\r\n            volatilityE8,\r\n            untilMaturity\r\n        );\r\n        price = callOptionPrice1 > callOptionPrice2\r\n            ? (inclineE8 * (callOptionPrice1 - callOptionPrice2)) / 10**8\r\n            : 0;\r\n        leverageE8 = _calcLbtLeverage(\r\n            uint256(spotPrice),\r\n            price,\r\n            (int256(inclineE8) * (nd11E8 - nd12E8)) / 10**8\r\n        );\r\n    }\r\n\r\n    /**\r\n      * @notice Calculate (call option1 * left incline) - (call option2 * (left incline + right incline)) + (call option3 * right incline).\r\n\r\n                                                                   /\r\n                                                                  /\r\n                                                                 /\r\n              /\\                            /                    \\\r\n             /  \\                          /                      \\\r\n            /    \\            =           /     -                  \\          +\r\n    _______/      \\________       _______/               _______    \\             __________________\r\n                                                                     \\                          \\\r\n                                                                      \\                          \\\r\n\r\n    **/\r\n    function _calcTrianglePrice(\r\n        uint256[] memory points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity\r\n    ) internal pure returns (uint256 price, uint256 leverageE8) {\r\n        require(\r\n            points.length == 4,\r\n            \"4 coordinates is needed for triangle option price calculation\"\r\n        );\r\n        uint256 incline1E8 = (points[2].mul(10**8)).div(points[1].sub(points[0]));\r\n        uint256 incline2E8 = (points[2].mul(10**8)).div(points[3].sub(points[1]));\r\n        (uint256 callOptionPrice1, int256 nd11E8) = calcCallOptionPrice(\r\n            spotPrice,\r\n            int256(points[0]),\r\n            volatilityE8,\r\n            untilMaturity\r\n        );\r\n        (uint256 callOptionPrice2, int256 nd12E8) = calcCallOptionPrice(\r\n            spotPrice,\r\n            int256(points[1]),\r\n            volatilityE8,\r\n            untilMaturity\r\n        );\r\n        (uint256 callOptionPrice3, int256 nd13E8) = calcCallOptionPrice(\r\n            spotPrice,\r\n            int256(points[3]),\r\n            volatilityE8,\r\n            untilMaturity\r\n        );\r\n        int256 nd1E8 = ((nd11E8 * int256(incline1E8)) +\r\n            (nd13E8 * int256(incline2E8)) -\r\n            (int256(incline1E8 + incline2E8) * nd12E8)) / 10**8;\r\n\r\n        uint256 price12 = (callOptionPrice1 * incline1E8) + (callOptionPrice3 * incline2E8);\r\n        price = price12 > (incline1E8 + incline2E8) * callOptionPrice2\r\n            ? (price12 - ((incline1E8 + incline2E8) * callOptionPrice2)) / 10**8\r\n            : 0;\r\n        leverageE8 = _calcLbtLeverage(uint256(spotPrice), price, nd1E8);\r\n    }\r\n\r\n    /**\r\n     * @dev calcCallOptionPrice() imposes the restrictions of strikePrice, spotPrice, nd1E8 and nd2E8.\r\n     */\r\n    function _calcLbtPrice(\r\n        int256 spotPrice,\r\n        int256 strikePrice,\r\n        int256 nd1E8,\r\n        int256 nd2E8\r\n    ) internal pure returns (int256 lbtPrice) {\r\n        int256 lowestPrice = (spotPrice > strikePrice) ? spotPrice - strikePrice : 0;\r\n        lbtPrice = (spotPrice * nd1E8 - strikePrice * nd2E8) / 10**8;\r\n        if (lbtPrice < lowestPrice) {\r\n            lbtPrice = lowestPrice;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calcCallOptionPrice() imposes the restrictions of spotPrice, lbtPrice and nd1E8.\r\n     */\r\n    function _calcLbtLeverage(\r\n        uint256 spotPrice,\r\n        uint256 lbtPrice,\r\n        int256 nd1E8\r\n    ) internal pure returns (uint256 lbtLeverageE8) {\r\n        int256 modifiedNd1E8 = nd1E8 < MIN_ND1_E8 ? MIN_ND1_E8 : nd1E8 > MAX_ND1_E8\r\n            ? MAX_ND1_E8\r\n            : nd1E8;\r\n        return lbtPrice != 0 ? (uint256(modifiedNd1E8) * spotPrice) / lbtPrice : MAX_LEVERAGE_E8;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate pure call option price and N(d1) by black-scholes formula.\r\n     * @param spotPrice is a oracle price.\r\n     * @param strikePrice Strike price of call option\r\n     * @param volatilityE8 is a oracle volatility.\r\n     * @param untilMaturity Remaining period of target bond in second\r\n     **/\r\n    function calcCallOptionPrice(\r\n        int256 spotPrice,\r\n        int256 strikePrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity\r\n    ) public pure returns (uint256 price, int256 nd1E8) {\r\n        require(spotPrice > 0 && spotPrice < 10**13, \"oracle price should be between 0 and 10^13\");\r\n        require(\r\n            volatilityE8 > 0 && volatilityE8 < 10 * 10**8,\r\n            \"oracle volatility should be between 0% and 1000%\"\r\n        );\r\n        require(\r\n            untilMaturity > 0 && untilMaturity < 31536000,\r\n            \"the bond should not have expired and less than 1 year\"\r\n        );\r\n        require(\r\n            strikePrice > 0 && strikePrice < 10**13,\r\n            \"strike price should be between 0 and 10^13\"\r\n        );\r\n\r\n        int256 spotPerStrikeE4 = (spotPrice * 10**4) / strikePrice;\r\n        int256 sigE8 = (volatilityE8 * (_sqrt(untilMaturity)) * (10**8)) / SQRT_YEAR_E8;\r\n\r\n        int256 logSigE4 = _logTaylor(spotPerStrikeE4);\r\n        int256 d1E4 = ((logSigE4 * 10**8) / sigE8) + (sigE8 / (2 * 10**4));\r\n        nd1E8 = _calcPnorm(d1E4);\r\n\r\n        int256 d2E4 = d1E4 - (sigE8 / 10**4);\r\n        int256 nd2E8 = _calcPnorm(d2E4);\r\n        price = uint256(_calcLbtPrice(spotPrice, strikePrice, nd1E8, nd2E8));\r\n    }\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/bondPricer/CustomGeneralizedPricing.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\nabstract contract CustomGeneralizedPricing is BondPricerInterface {\r\n    using SafeMath for uint256;\r\n\r\n    GeneralizedPricing internal immutable _originalBondPricerAddress;\r\n\r\n    constructor(address originalBondPricerAddress) {\r\n        _originalBondPricerAddress = GeneralizedPricing(originalBondPricerAddress);\r\n    }\r\n\r\n    function calcPriceAndLeverage(\r\n        BondType bondType,\r\n        uint256[] calldata points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity\r\n    ) external view override returns (uint256 price, uint256 leverageE8) {\r\n        (price, leverageE8) = _originalBondPricerAddress.calcPriceAndLeverage(\r\n            bondType,\r\n            points,\r\n            spotPrice,\r\n            volatilityE8,\r\n            untilMaturity\r\n        );\r\n        if (bondType == BondType.LBT_SHAPE) {\r\n            require(\r\n                _isAcceptableLbt(points, spotPrice, volatilityE8, untilMaturity, price, leverageE8),\r\n                \"the liquid bond is not acceptable\"\r\n            );\r\n        } else if (bondType == BondType.SBT_SHAPE) {\r\n            require(\r\n                _isAcceptableSbt(points, spotPrice, volatilityE8, untilMaturity, price, leverageE8),\r\n                \"the solid bond is not acceptable\"\r\n            );\r\n        } else if (bondType == BondType.TRIANGLE) {\r\n            require(\r\n                _isAcceptableTriangleBond(\r\n                    points,\r\n                    spotPrice,\r\n                    volatilityE8,\r\n                    untilMaturity,\r\n                    price,\r\n                    leverageE8\r\n                ),\r\n                \"the triangle bond is not acceptable\"\r\n            );\r\n        } else if (bondType == BondType.PURE_SBT) {\r\n            require(\r\n                _isAcceptablePureSbt(\r\n                    points,\r\n                    spotPrice,\r\n                    volatilityE8,\r\n                    untilMaturity,\r\n                    price,\r\n                    leverageE8\r\n                ),\r\n                \"the pure solid bond is not acceptable\"\r\n            );\r\n        } else {\r\n            require(\r\n                _isAcceptableOtherBond(\r\n                    points,\r\n                    spotPrice,\r\n                    volatilityE8,\r\n                    untilMaturity,\r\n                    price,\r\n                    leverageE8\r\n                ),\r\n                \"the bond is not acceptable\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function originalBondPricer() external view returns (address originalBondPricerAddress) {\r\n        originalBondPricerAddress = address(_originalBondPricerAddress);\r\n    }\r\n\r\n    function _isAcceptableLbt(\r\n        uint256[] memory points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity,\r\n        uint256 bondPrice,\r\n        uint256 bondLeverageE8\r\n    ) internal view virtual returns (bool);\r\n\r\n    function _isAcceptableSbt(\r\n        uint256[] memory points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity,\r\n        uint256 bondPrice,\r\n        uint256 bondLeverageE8\r\n    ) internal view virtual returns (bool);\r\n\r\n    function _isAcceptableTriangleBond(\r\n        uint256[] memory points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity,\r\n        uint256 bondPrice,\r\n        uint256 bondLeverageE8\r\n    ) internal view virtual returns (bool);\r\n\r\n    function _isAcceptablePureSbt(\r\n        uint256[] memory points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity,\r\n        uint256 bondPrice,\r\n        uint256 bondLeverageE8\r\n    ) internal view virtual returns (bool);\r\n\r\n    function _isAcceptableOtherBond(\r\n        uint256[] memory points,\r\n        int256 spotPrice,\r\n        int256 volatilityE8,\r\n        int256 untilMaturity,\r\n        uint256 bondPrice,\r\n        uint256 bondLeverageE8\r\n    ) internal view virtual returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/util/Time.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\nabstract contract Time {\r\n    function _getBlockTimestampSec() internal view returns (uint256 unixtimesec) {\r\n        unixtimesec = block.timestamp; // solhint-disable-line not-rely-on-time\r\n    }\r\n}\r\n\r\n// File: contracts/SimpleAggregator/BondPricerWithAcceptableMaturity.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n\r\ncontract BondPricerWithAcceptableMaturity is CustomGeneralizedPricing, Ownable, Time {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal _acceptableMaturity;\r\n\r\n    event LogUpdateAcceptableMaturity(uint256 acceptableMaturity);\r\n\r\n    constructor(address originalBondPricerAddress)\r\n        CustomGeneralizedPricing(originalBondPricerAddress)\r\n    {\r\n        _updateAcceptableMaturity(0);\r\n    }\r\n\r\n    function updateAcceptableMaturity(uint256 acceptableMaturity) external onlyOwner {\r\n        _updateAcceptableMaturity(acceptableMaturity);\r\n    }\r\n\r\n    function getAcceptableMaturity() external view returns (uint256 acceptableMaturity) {\r\n        acceptableMaturity = _acceptableMaturity;\r\n    }\r\n\r\n    function _updateAcceptableMaturity(uint256 acceptableMaturity) internal {\r\n        _acceptableMaturity = acceptableMaturity;\r\n        emit LogUpdateAcceptableMaturity(acceptableMaturity);\r\n    }\r\n\r\n    function _isAcceptableLbt(\r\n        uint256[] memory,\r\n        int256 etherPriceE8,\r\n        int256 ethVolatilityE8,\r\n        int256 untilMaturity,\r\n        uint256,\r\n        uint256\r\n    ) internal view override returns (bool) {\r\n        _isAcceptable(etherPriceE8, ethVolatilityE8, untilMaturity);\r\n        return true;\r\n    }\r\n\r\n    function _isAcceptableSbt(\r\n        uint256[] memory,\r\n        int256 etherPriceE8,\r\n        int256 ethVolatilityE8,\r\n        int256 untilMaturity,\r\n        uint256,\r\n        uint256\r\n    ) internal view override returns (bool) {\r\n        _isAcceptable(etherPriceE8, ethVolatilityE8, untilMaturity);\r\n        return true;\r\n    }\r\n\r\n    function _isAcceptableTriangleBond(\r\n        uint256[] memory,\r\n        int256 etherPriceE8,\r\n        int256 ethVolatilityE8,\r\n        int256 untilMaturity,\r\n        uint256,\r\n        uint256\r\n    ) internal view override returns (bool) {\r\n        _isAcceptable(etherPriceE8, ethVolatilityE8, untilMaturity);\r\n        return true;\r\n    }\r\n\r\n    function _isAcceptablePureSbt(\r\n        uint256[] memory,\r\n        int256 etherPriceE8,\r\n        int256 ethVolatilityE8,\r\n        int256 untilMaturity,\r\n        uint256,\r\n        uint256\r\n    ) internal view override returns (bool) {\r\n        _isAcceptable(etherPriceE8, ethVolatilityE8, untilMaturity);\r\n        return true;\r\n    }\r\n\r\n    function _isAcceptableOtherBond(\r\n        uint256[] memory,\r\n        int256,\r\n        int256,\r\n        int256,\r\n        uint256,\r\n        uint256\r\n    ) internal pure override returns (bool) {\r\n        revert(\"the bond is not pure SBT type\");\r\n    }\r\n\r\n    /**\r\n     * @notice Add this function to CustomGeneralizedPricing\r\n     * When user sells bond which expired or whose maturity is after the aggregator's maturity, revert the transaction\r\n     */\r\n    function _isAcceptable(\r\n        int256 etherPriceE8,\r\n        int256 ethVolatilityE8,\r\n        int256 untilMaturity\r\n    ) internal view {\r\n        require(\r\n            etherPriceE8 > 0 && etherPriceE8 < 100000 * 10**8,\r\n            \"ETH price should be between $0 and $100000\"\r\n        );\r\n        require(\r\n            ethVolatilityE8 > 0 && ethVolatilityE8 < 10 * 10**8,\r\n            \"ETH volatility should be between 0% and 1000%\"\r\n        );\r\n        require(untilMaturity >= 0, \"the bond has been expired\");\r\n        require(untilMaturity <= 12 weeks, \"the bond maturity must be less than 12 weeks\");\r\n        require(\r\n            _getBlockTimestampSec().add(uint256(untilMaturity)) == _acceptableMaturity,\r\n            \"the bond maturity must not exceed the current maturity of aggregator\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/Interfaces/BondRegistratorInterface.sol\r\n\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ninterface BondRegistratorInterface {\r\n    struct Points {\r\n        uint64 x1;\r\n        uint64 y1;\r\n        uint64 x2;\r\n        uint64 y2;\r\n    }\r\n\r\n    function getFnMap(Points[] memory points) external pure returns (bytes memory fnMap);\r\n\r\n    function registerSBT(\r\n        BondMakerInterface bondMaker,\r\n        uint64 sbtStrikePrice,\r\n        uint64 maturity\r\n    ) external returns (bytes32);\r\n\r\n    function registerBondGroup(\r\n        BondMakerInterface bondMaker,\r\n        uint256 callStrikePrice,\r\n        uint64 sbtStrikePrice,\r\n        uint64 maturity,\r\n        bytes32 SBTId\r\n    ) external returns (uint256 bondGroupId);\r\n\r\n    function registerBond(\r\n        BondMakerInterface bondMaker,\r\n        Points[] memory points,\r\n        uint256 maturity\r\n    ) external returns (bytes32);\r\n}\r\n\r\n// File: contracts/Interfaces/UseVolatilityOracle.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\ncontract UseVolatilityOracle {\r\n    using SafeMath for uint256;\r\n    using SafeCast for uint256;\r\n    VolatilityOracleInterface volOracle;\r\n\r\n    constructor(VolatilityOracleInterface _volOracle) {\r\n        volOracle = _volOracle;\r\n    }\r\n\r\n    function _getVolatility(uint256 maturity) internal view returns (uint256) {\r\n        return volOracle.getVolatility(maturity.sub(block.timestamp).toUint64());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/SimpleAggregator/SimpleAggregator.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract SimpleAggregator is SimpleAggregatorInterface, UseVolatilityOracle {\r\n    using SafeMath for uint256;\r\n    using SafeCast for uint256;\r\n    using SafeERC20 for ERC20;\r\n    struct ReceivedCollateral {\r\n        uint128 term;\r\n        uint128 value;\r\n    }\r\n    struct UnRemovedToken {\r\n        uint128 term;\r\n        uint128 value;\r\n    }\r\n    struct LiquidationData {\r\n        uint32 endBondGroupId;\r\n        uint32 liquidatedBondGroupID;\r\n        bool isLiquidated;\r\n    }\r\n    struct TermInfo {\r\n        uint64 maturity;\r\n        uint64 strikePrice;\r\n        bytes32 SBTId;\r\n    }\r\n    struct ShareData {\r\n        uint128 totalShare;\r\n        uint128 totalCollateralPerToken;\r\n    }\r\n    struct BalanceData {\r\n        uint128 balance;\r\n        uint64 rewardAmount;\r\n        uint64 term;\r\n    }\r\n\r\n    uint256 constant INFINITY = uint256(-1);\r\n    uint256 constant COOLTIME = 3600 * 24 * 3;\r\n    SimpleStrategyInterface internal immutable STRATEGY;\r\n    ExchangeInterface internal immutable DOTC;\r\n    ERC20 internal immutable REWARD_TOKEN;\r\n    BondPricerWithAcceptableMaturity internal immutable BOND_PRICER;\r\n    LatestPriceOracleInterface internal immutable ORACLE;\r\n    BondMakerInterface internal immutable BONDMAKER;\r\n    BondRegistratorInterface internal immutable BOND_REGISTRATOR;\r\n    address internal immutable OWNER;\r\n    bool internal immutable REVERSE_ORACLE;\r\n    int16 internal constant MAX_SUPPLY_DENUMERATOR = 8;\r\n    uint64 internal immutable BASE_PRICE_UNIT;\r\n\r\n    mapping(uint256 => TermInfo) internal termInfo;\r\n\r\n    mapping(uint256 => uint256[]) internal issuableBondGroupIds;\r\n    mapping(uint256 => mapping(uint256 => uint256)) internal strikePriceToBondGroup;\r\n\r\n    TotalReward[] internal totalRewards;\r\n    // Aggregator Status\r\n    mapping(uint256 => LiquidationData) internal liquidationData;\r\n    mapping(uint256 => ShareData) internal shareData;\r\n    uint256 internal currentTerm;\r\n    uint64 internal priceUnit;\r\n    uint64 internal lastTrancheTime;\r\n    uint32 internal startBondGroupId = 1;\r\n    int16 internal currentFeeBase;\r\n    bool internal isTotalSupplyDanger;\r\n\r\n    mapping(address => ReceivedCollateral) internal receivedCollaterals;\r\n    mapping(address => UnRemovedToken) internal unremovedTokens;\r\n    mapping(address => BalanceData) internal balance;\r\n    mapping(address => mapping(address => uint128)) internal allowances;\r\n\r\n    uint8 public constant override decimals = 8;\r\n    string public constant override symbol = \"LASH\";\r\n    string public constant override name = \"LIEN_AGGREGATOR_SHARE\";\r\n\r\n    mapping(uint256 => uint128) internal totalReceivedCollateral;\r\n    mapping(uint256 => uint128) internal totalUnremovedTokens;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    event SetAddLiquidity(address indexed user, uint256 indexed term, uint256 collateralAmount);\r\n\r\n    event SetRemoveLiquidity(address indexed user, uint256 indexed term, uint256 tokenAmount);\r\n\r\n    event SettleLiquidity(\r\n        address indexed user,\r\n        uint256 indexed term,\r\n        uint256 collateralAmount,\r\n        uint256 tokenAmount\r\n    );\r\n\r\n    event TrancheBond(\r\n        uint64 indexed issueBondGroupId,\r\n        uint64 issueAmount,\r\n        uint64 indexed burnBondGroupId,\r\n        uint64 burnAmount\r\n    );\r\n\r\n    event UpdateMaturity(uint64 indexed term, int16 newFeeBase, uint64 maturity);\r\n\r\n    event AddLiquidity(address indexed user, uint256 tokenAmount);\r\n\r\n    modifier isActive() {\r\n        require(block.timestamp <= termInfo[currentTerm].maturity, \"Not active\");\r\n        _;\r\n    }\r\n\r\n    modifier endCoolTime() {\r\n        require(block.timestamp > lastTrancheTime + COOLTIME, \"Cool Time\");\r\n        _;\r\n    }\r\n\r\n    modifier afterMaturity() {\r\n        require(block.timestamp > termInfo[currentTerm].maturity, \"Not Matured\");\r\n        _;\r\n    }\r\n\r\n    modifier isRunning() {\r\n        require(currentTerm != 0, \"Not running\");\r\n        _;\r\n    }\r\n\r\n    // When collateralPerToken becomes very small value, total supply of share token can overflow\r\n    modifier isSafeSupply() {\r\n        require(!isTotalSupplyDanger, \"Unsafe supply\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyBonusProvider() {\r\n        require(msg.sender == OWNER, \"Only provider\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyProviderFirstTime() {\r\n        require(msg.sender == OWNER || currentTerm != 0, \"Only provider\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        LatestPriceOracleInterface _oracle,\r\n        BondPricerWithAcceptableMaturity _pricer,\r\n        SimpleStrategyInterface _strategy,\r\n        ERC20 _rewardToken,\r\n        BondRegistratorInterface _registrator,\r\n        ExchangeInterface _exchangeAddress,\r\n        uint64 _priceUnit,\r\n        uint64 _firstRewardRate,\r\n        bool _reverseOracle,\r\n        VolatilityOracleInterface _volOracle\r\n    ) UseVolatilityOracle(_volOracle) {\r\n        BONDMAKER = _exchangeAddress.bondMakerAddress();\r\n        BOND_PRICER = _pricer;\r\n        ORACLE = _oracle;\r\n        BASE_PRICE_UNIT = _priceUnit;\r\n        REVERSE_ORACLE = _reverseOracle;\r\n        REWARD_TOKEN = _rewardToken;\r\n        BOND_REGISTRATOR = _registrator;\r\n        DOTC = _exchangeAddress;\r\n\r\n        STRATEGY = _strategy;\r\n\r\n        totalRewards.push(TotalReward(1, _firstRewardRate));\r\n        priceUnit = _priceUnit;\r\n        OWNER = msg.sender;\r\n        require(\r\n            _firstRewardRate >= 10**decimals && _firstRewardRate <= 1000000 * 10**decimals,\r\n            \"Out of range\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update maturity and strike price of SBT\r\n     * Then, determine total amount of collateral asset and totalSupply of share token\r\n     * Collateral asset to be withdrawn in `settleTokens()` is sent for reserve contract\r\n     */\r\n    function renewMaturity() public onlyProviderFirstTime override {\r\n        uint256 totalUnsentTokens;\r\n        uint256 collateralPerTokenE8;\r\n        uint256 _currentTerm = currentTerm;\r\n        uint256 currentUnremoved = totalUnremovedTokens[_currentTerm];\r\n        require(liquidationData[_currentTerm].isLiquidated || _currentTerm == 0, \"Not expired yet\");\r\n        uint256 totalShare = shareData[_currentTerm].totalShare;\r\n        if (totalShare > 0) {\r\n            uint256 collateralAmount = getCollateralAmount();\r\n            collateralPerTokenE8 = _applyDecimalGap(\r\n                collateralAmount.mul(10**decimals).div(totalShare),\r\n                true\r\n            );\r\n            totalUnsentTokens = _applyDecimalGap(\r\n                uint256(totalReceivedCollateral[_currentTerm]).mul(10**decimals) /\r\n                    collateralPerTokenE8,\r\n                true\r\n            );\r\n        } else if (totalReceivedCollateral[_currentTerm] > 0) {\r\n            totalUnsentTokens = _applyDecimalGap(totalReceivedCollateral[_currentTerm], true);\r\n            collateralPerTokenE8 = 10**decimals;\r\n        }\r\n\r\n        uint256 _totalSupply = totalShare + totalUnsentTokens;\r\n        shareData[_currentTerm + 1].totalCollateralPerToken = collateralPerTokenE8.toUint128();\r\n        shareData[_currentTerm + 1].totalShare = uint256(totalShare)\r\n            .add(totalUnsentTokens)\r\n            .sub(currentUnremoved)\r\n            .toUint128();\r\n\r\n        if (\r\n            shareData[_currentTerm + 1].totalShare >\r\n            uint128(-1) / 10**uint128(MAX_SUPPLY_DENUMERATOR)\r\n        ) {\r\n            isTotalSupplyDanger = true;\r\n        }\r\n\r\n        if (_currentTerm != 0) {\r\n            _updateFeeBase();\r\n        }\r\n\r\n        if (_totalSupply > 0 && currentUnremoved > 0) {\r\n            _reserveAsset(collateralPerTokenE8);\r\n        }\r\n        _updateBondGroupData();\r\n\r\n        emit UpdateMaturity(currentTerm.toUint64(), currentFeeBase, termInfo[currentTerm].maturity);\r\n    }\r\n\r\n    /**\r\n     * @notice Update total reward token amount for one term\r\n     * Only owner can call this function\r\n     * @param rewardRate is restricted from 10**8 (1 LIEN) to 10**14 (total supply of Lien token)\r\n     */\r\n    function updateTotalReward(uint64 rewardRate) public onlyBonusProvider isRunning {\r\n        require(rewardRate >= 10**decimals && rewardRate <= 1000000 * 10**decimals, \"Out of range\");\r\n        totalRewards.push(TotalReward(currentTerm.toUint64() + 1, rewardRate));\r\n    }\r\n\r\n    function _updateBondGroupData() internal {\r\n        uint256 nextTimeStamp = STRATEGY.calcNextMaturity();\r\n        uint256 currentPriceE8 = ORACLE.latestPrice();\r\n        uint256 currentStrikePrice = STRATEGY.getCurrentStrikePrice(\r\n            currentPriceE8,\r\n            priceUnit,\r\n            REVERSE_ORACLE\r\n        );\r\n\r\n        _updatePriceUnit(currentPriceE8);\r\n\r\n        // Register SBT for next term\r\n        bytes32 SBTId = BOND_REGISTRATOR.registerSBT(\r\n            BONDMAKER,\r\n            currentStrikePrice.toUint64(),\r\n            nextTimeStamp.toUint64()\r\n        );\r\n        (address sbtAddress, , , ) = BONDMAKER.getBond(SBTId);\r\n        IERC20(sbtAddress).approve(address(DOTC), INFINITY);\r\n\r\n        currentTerm += 1;\r\n        TermInfo memory newTermInfo = TermInfo(\r\n            nextTimeStamp.toUint64(),\r\n            currentStrikePrice.toUint64(),\r\n            SBTId\r\n        );\r\n        termInfo[currentTerm] = newTermInfo;\r\n        BOND_PRICER.updateAcceptableMaturity(nextTimeStamp);\r\n    }\r\n\r\n    function _addLiquidity(uint256 amount) internal returns (bool success) {\r\n        (, uint256 unsentToken, uint256 addLiquidityTerm) = _settleTokens();\r\n        _updateBalanceDataForLiquidityMove(msg.sender, unsentToken, 0, addLiquidityTerm);\r\n        uint256 _currentTerm = currentTerm;\r\n        if (receivedCollaterals[msg.sender].value == 0) {\r\n            receivedCollaterals[msg.sender].term = uint128(_currentTerm);\r\n        }\r\n        receivedCollaterals[msg.sender].value += amount.toUint128();\r\n        totalReceivedCollateral[_currentTerm] += amount.toUint128();\r\n        emit SetAddLiquidity(msg.sender, _currentTerm, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Make a reservation for removing liquidity\r\n     * Collateral asset can be withdrawn from next term\r\n     * Share token to be removed is burned at this point\r\n     * Before remove liquidity, run _settleTokens()\r\n     */\r\n\r\n    function removeLiquidity(uint128 amount) external override returns (bool success) {\r\n        (, uint256 unsentToken, uint256 addLiquidityTerm) = _settleTokens();\r\n        uint256 _currentTerm = currentTerm;\r\n        if (unremovedTokens[msg.sender].value == 0) {\r\n            unremovedTokens[msg.sender].term = uint128(_currentTerm);\r\n        }\r\n        unremovedTokens[msg.sender].value += amount;\r\n        totalUnremovedTokens[_currentTerm] += amount;\r\n        _updateBalanceDataForLiquidityMove(msg.sender, unsentToken, amount, addLiquidityTerm);\r\n        emit SetRemoveLiquidity(msg.sender, _currentTerm, amount);\r\n        return true;\r\n    }\r\n\r\n    function _settleTokens()\r\n        internal\r\n        returns (\r\n            uint256 unsentETH,\r\n            uint256 unsentToken,\r\n            uint256 addLiquidityTerm\r\n        )\r\n    {\r\n        uint256 _currentTerm = currentTerm;\r\n        uint128 lastRemoveLiquidityTerm = unremovedTokens[msg.sender].term;\r\n        uint128 lastRemoveLiquidityValue = unremovedTokens[msg.sender].value;\r\n        uint128 lastAddLiquidityTerm = receivedCollaterals[msg.sender].term;\r\n        uint128 lastAddLiquidityValue = receivedCollaterals[msg.sender].value;\r\n        if (_currentTerm == 0) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        if (lastRemoveLiquidityValue != 0 && _currentTerm > lastRemoveLiquidityTerm) {\r\n            unsentETH = _applyDecimalGap(\r\n                uint256(lastRemoveLiquidityValue)\r\n                    .mul(shareData[uint256(lastRemoveLiquidityTerm + 1)].totalCollateralPerToken)\r\n                    .div(10**decimals),\r\n                false\r\n            );\r\n            if (unsentETH > 0) {\r\n                _sendTokens(msg.sender, unsentETH);\r\n            }\r\n            delete unremovedTokens[msg.sender];\r\n        }\r\n\r\n        if (lastAddLiquidityValue != 0 && _currentTerm > lastAddLiquidityTerm) {\r\n            unsentToken = _applyDecimalGap(\r\n                uint256(lastAddLiquidityValue).mul(10**decimals).div(\r\n                    uint256(shareData[lastAddLiquidityTerm + 1].totalCollateralPerToken)\r\n                ),\r\n                true\r\n            );\r\n            addLiquidityTerm = lastAddLiquidityTerm;\r\n            delete receivedCollaterals[msg.sender];\r\n        }\r\n        emit SettleLiquidity(msg.sender, _currentTerm, unsentETH, unsentToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Increment share token for addLiquidity data\r\n     * Transfer collateral asset for remove liquidity data\r\n     */\r\n    function settleTokens() external override returns (uint256 unsentETH, uint256 unsentToken) {\r\n        uint256 addLiquidityTerm;\r\n        (unsentETH, unsentToken, addLiquidityTerm) = _settleTokens();\r\n        _updateBalanceDataForLiquidityMove(msg.sender, unsentToken, 0, addLiquidityTerm);\r\n    }\r\n\r\n    /**\r\n     * @notice Update `startBondGroupId` to run `liquidateBonds()` more efficiently\r\n     * All bond groups before `startBondGroupId` has expired before maturity of previous term\r\n     */\r\n    function updateStartBondGroupId() external override isRunning {\r\n        uint32 _startBondGroupId = startBondGroupId;\r\n        uint64 previousMaturity = termInfo[currentTerm - 1].maturity;\r\n        require(previousMaturity != 0, \"Maturity shoudld exist\");\r\n        while (true) {\r\n            (, uint256 maturity) = BONDMAKER.getBondGroup(_startBondGroupId);\r\n            if (maturity >= previousMaturity) {\r\n                startBondGroupId = _startBondGroupId;\r\n                return;\r\n            }\r\n            _startBondGroupId += 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Liquidate and burn all bonds in this aggregator\r\n     * Aggregator can search for 50 bondGroup and burn 10 bonds one time\r\n     */\r\n    function liquidateBonds(uint256 hintID) public override afterMaturity {\r\n        \r\n        uint256 _currentTerm = currentTerm;\r\n        require(!liquidationData[_currentTerm].isLiquidated, \"Expired\");\r\n        if (liquidationData[_currentTerm].endBondGroupId == 0) {\r\n            liquidationData[_currentTerm].endBondGroupId = BONDMAKER.nextBondGroupID().toUint32();\r\n        }\r\n        // ToDo: Register least bond group ID\r\n        uint32 endIndex;\r\n        uint32 startIndex;\r\n        uint32 liquidateBondNumber;\r\n        uint64 maturity = termInfo[_currentTerm].maturity;\r\n        {\r\n            uint256 ethAllowance = DOTC.ethAllowance(address(this));\r\n            if (ethAllowance > 0) {\r\n                DOTC.withdrawEth();\r\n            }\r\n        }\r\n\r\n        if (liquidationData[_currentTerm].liquidatedBondGroupID == 0) {\r\n            startIndex = startBondGroupId;\r\n        } else {\r\n            startIndex = liquidationData[_currentTerm].liquidatedBondGroupID;\r\n        }\r\n\r\n        if (liquidationData[_currentTerm].endBondGroupId - startIndex > 50) {\r\n            endIndex = startIndex + 50;\r\n            liquidationData[_currentTerm].liquidatedBondGroupID = endIndex;\r\n        } else {\r\n            endIndex = liquidationData[_currentTerm].endBondGroupId;\r\n        }\r\n\r\n        for (uint256 i = startIndex; i < endIndex; i++) {\r\n            liquidateBondNumber = _liquidateBondGroup(\r\n                i,\r\n                liquidateBondNumber,\r\n                maturity,\r\n                hintID\r\n            );\r\n\r\n            if (liquidateBondNumber > 9) {\r\n                if (i == endIndex - 1) {\r\n                    liquidationData[_currentTerm].isLiquidated = true;\r\n                } else {\r\n                    liquidationData[_currentTerm].liquidatedBondGroupID = uint32(i + 1);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (endIndex == liquidationData[_currentTerm].endBondGroupId) {\r\n            liquidationData[_currentTerm].isLiquidated = true;\r\n        } else {\r\n            liquidationData[_currentTerm].liquidatedBondGroupID = endIndex;\r\n        }\r\n    }\r\n\r\n    function addSuitableBondGroup() external override isActive returns (uint256 bondGroupID) {\r\n        uint256 currentPriceE8 = ORACLE.latestPrice();\r\n        return _addSuitableBondGroup(currentPriceE8);\r\n    }\r\n\r\n    /**\r\n     * @notice Can not tranche bonds for 3 days from last execution of this function\r\n     */\r\n    function trancheBonds() external override isActive endCoolTime {\r\n        uint256 currentPriceE8 = ORACLE.latestPrice();\r\n        uint256 bondGroupId = _getSuitableBondGroup(currentPriceE8);\r\n        if (bondGroupId == 0) {\r\n            bondGroupId = _addSuitableBondGroup(currentPriceE8);\r\n        }\r\n\r\n        (uint256 amount, uint256 ethAmount, uint256[2] memory reverseBonds) = STRATEGY\r\n            .getTrancheBonds(\r\n            BONDMAKER,\r\n            address(this),\r\n            bondGroupId,\r\n            currentPriceE8,\r\n            issuableBondGroupIds[currentTerm],\r\n            priceUnit,\r\n            REVERSE_ORACLE\r\n        );\r\n\r\n        if (ethAmount > 0) {\r\n            DOTC.depositEth{value: ethAmount}();\r\n        }\r\n\r\n\r\n        if (reverseBonds[1] > 0) {\r\n            // Burn bond and get collateral asset\r\n            require(\r\n                BONDMAKER.reverseBondGroupToCollateral(reverseBonds[0], reverseBonds[1]),\r\n                \"Reverse\"\r\n            );\r\n        }\r\n\r\n        if (amount > 0) {\r\n            _issueBonds(bondGroupId, amount);\r\n        }\r\n        \r\n        lastTrancheTime = block.timestamp.toUint64();\r\n        emit TrancheBond(\r\n            uint64(bondGroupId),\r\n            uint64(amount),\r\n            uint64(reverseBonds[0]),\r\n            uint64(reverseBonds[1])\r\n        );\r\n    }\r\n\r\n    function _burnBond(\r\n        uint256 bondGroupId,\r\n        address bondAddress,\r\n        uint32 liquidateBondNumber,\r\n        bool isLiquidated,\r\n        uint256 hintID\r\n    ) internal returns (uint32, bool) {\r\n        BondTokenInterface bond = BondTokenInterface(bondAddress);\r\n        if (bond.balanceOf(address(this)) > 0) {\r\n            if (!isLiquidated) {\r\n                // If this bond group is not liquidated in _liquidateBondGroup, try liquidate\r\n                // BondMaker contract does not revert even if someone else calls 'BONDMAKER.liquidateBond()'\r\n                BONDMAKER.liquidateBond(bondGroupId, hintID);\r\n                isLiquidated = true;\r\n            }\r\n            bond.burnAll();\r\n            liquidateBondNumber += 1;\r\n        }\r\n        return (liquidateBondNumber, isLiquidated);\r\n    }\r\n\r\n    function _liquidateBondGroup(\r\n        uint256 bondGroupId,\r\n        uint32 liquidateBondNumber,\r\n        uint64 maturity,\r\n        uint256 hintID\r\n    ) internal returns (uint32) {\r\n        (bytes32[] memory bondIds, uint256 _maturity) = BONDMAKER.getBondGroup(bondGroupId);\r\n        if (_maturity != maturity) {\r\n            return liquidateBondNumber;\r\n        }\r\n        bool isLiquidated;\r\n        for (uint256 i = 0; i < bondIds.length; i++) {\r\n            (address bondAddress, , , ) = BONDMAKER.getBond(bondIds[i]);\r\n            (liquidateBondNumber, isLiquidated) = _burnBond(\r\n                bondGroupId,\r\n                bondAddress,\r\n                liquidateBondNumber,\r\n                isLiquidated,\r\n                hintID\r\n            );\r\n        }\r\n        return liquidateBondNumber;\r\n    }\r\n\r\n    function _getSuitableBondGroup(uint256 currentPriceE8) internal view returns (uint256) {\r\n        uint256 roundedPrice = STRATEGY.calcRoundPrice(currentPriceE8, priceUnit, 1);\r\n\r\n\r\n            mapping(uint256 => uint256) storage priceToGroupBondId\r\n         = strikePriceToBondGroup[currentTerm];\r\n        if (priceToGroupBondId[roundedPrice] != 0) {\r\n            return priceToGroupBondId[roundedPrice];\r\n        }\r\n        // Suitable bond range is in between current price +- 2 * priceUnit\r\n        for (uint256 i = 1; i <= 2; i++) {\r\n            if (priceToGroupBondId[roundedPrice - priceUnit * i] != 0) {\r\n                return priceToGroupBondId[roundedPrice - priceUnit * i];\r\n            }\r\n\r\n            if (priceToGroupBondId[roundedPrice + priceUnit * i] != 0) {\r\n                return priceToGroupBondId[roundedPrice + priceUnit * i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function _addSuitableBondGroup(uint256 currentPriceE8) internal returns (uint256 bondGroupID) {\r\n        uint256 callStrikePrice = STRATEGY.calcCallStrikePrice(\r\n            currentPriceE8,\r\n            priceUnit,\r\n            REVERSE_ORACLE\r\n        );\r\n        uint256 _currentTerm = currentTerm;\r\n        TermInfo memory info = termInfo[_currentTerm];\r\n        callStrikePrice = _adjustPrice(info.strikePrice, callStrikePrice);\r\n        bondGroupID = BOND_REGISTRATOR.registerBondGroup(\r\n            BONDMAKER,\r\n            callStrikePrice,\r\n            info.strikePrice,\r\n            info.maturity,\r\n            info.SBTId\r\n        );\r\n        // If reverse oracle is set to aggregator, make Collateral/USD price\r\n        if (REVERSE_ORACLE) {\r\n            _addBondGroup(\r\n                bondGroupID,\r\n                STRATEGY.calcCallStrikePrice(currentPriceE8, priceUnit, false)\r\n            );\r\n        } else {\r\n            _addBondGroup(bondGroupID, callStrikePrice);\r\n        }\r\n    }\r\n\r\n    function _addBondGroup(uint256 bondGroupId, uint256 callStrikePriceInEthUSD) internal {\r\n        // Register bond group info\r\n        issuableBondGroupIds[currentTerm].push(bondGroupId);\r\n        strikePriceToBondGroup[currentTerm][callStrikePriceInEthUSD] = bondGroupId;\r\n\r\n        (bytes32[] memory bondIDs, ) = BONDMAKER.getBondGroup(bondGroupId);\r\n        (address bondType1Address, , , ) = BONDMAKER.getBond(bondIDs[1]);\r\n\r\n        // Infinite approve if no approval\r\n        if (IERC20(bondType1Address).allowance(address(this), address(DOTC)) == 0) {\r\n            IERC20(bondType1Address).approve(address(DOTC), INFINITY);\r\n        }\r\n\r\n        (address bondType2Address, , , ) = BONDMAKER.getBond(bondIDs[2]);\r\n\r\n        if (IERC20(bondType2Address).allowance(address(this), address(DOTC)) == 0) {\r\n            IERC20(bondType2Address).approve(address(DOTC), INFINITY);\r\n        }\r\n        (address bondType3Address, , , ) = BONDMAKER.getBond(bondIDs[3]);\r\n        if (IERC20(bondType3Address).allowance(address(this), address(DOTC)) == 0) {\r\n            IERC20(bondType3Address).approve(address(DOTC), INFINITY);\r\n        }\r\n    }\r\n\r\n    function _updatePriceUnit(uint256 currentPriceE8) internal {\r\n        uint256 multiplyer = currentPriceE8.div(50 * BASE_PRICE_UNIT);\r\n        if (multiplyer == 0) {\r\n            priceUnit = BASE_PRICE_UNIT;\r\n        } else {\r\n            priceUnit = ((25 * multiplyer * BASE_PRICE_UNIT) / 10).toUint64();\r\n        }\r\n    }\r\n\r\n    function _updateFeeBase() internal {\r\n        STRATEGY.registerCurrentFeeBase(\r\n            currentFeeBase,\r\n            shareData[currentTerm].totalCollateralPerToken,\r\n            shareData[currentTerm + 1].totalCollateralPerToken,\r\n            OWNER,\r\n            address(ORACLE),\r\n            REVERSE_ORACLE\r\n        );\r\n        changeSpread();\r\n    }\r\n\r\n    /**\r\n     * @dev When sbtStrikePrice and callStrikePrice have different remainder of 2,\r\n     * decrease callStrikePrice by 1 to avoid invalid line segment for register new bond\r\n     */\r\n    function _adjustPrice(uint64 sbtStrikePrice, uint256 callStrikePrice)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return callStrikePrice.sub(callStrikePrice.sub(sbtStrikePrice) % 2);\r\n    }\r\n\r\n    function changeSpread() public virtual override {}\r\n\r\n    function _sendTokens(address user, uint256 amount) internal virtual {}\r\n\r\n    function _reserveAsset(uint256 reserveAmountRatioE8) internal virtual {}\r\n\r\n    function _issueBonds(uint256 bondgroupID, uint256 amount) internal virtual {}\r\n\r\n    function getCollateralAddress() external view virtual override returns (address) {}\r\n\r\n    function _applyDecimalGap(uint256 amount, bool isDiv) internal view virtual returns (uint256) {}\r\n\r\n    function getCollateralDecimal() external view virtual override returns (int16) {}\r\n\r\n    function getReserveAddress() external view virtual returns (address) {}\r\n\r\n    function getCollateralAmount() public view virtual override returns (uint256) {}\r\n\r\n    // Reward functions\r\n    /**\r\n     * @dev Update reward amount, then update balance\r\n     */\r\n    function _updateBalanceData(address owner, int256 amount) internal {\r\n        BalanceData memory balanceData = balance[owner];\r\n        balanceData.rewardAmount = _calcNextReward(balanceData, currentTerm);\r\n        balanceData.term = uint64(currentTerm);\r\n        if (amount < 0) {\r\n            balanceData.balance = uint256(balanceData.balance)\r\n                .sub(uint256(amount * -1))\r\n                .toUint128();\r\n        } else {\r\n            balanceData.balance = uint256(balanceData.balance).add(uint256(amount)).toUint128();\r\n        }\r\n        balance[owner] = balanceData;\r\n    }\r\n\r\n    function _updateBalanceDataForLiquidityMove(\r\n        address owner,\r\n        uint256 addAmount,\r\n        uint256 removeAmount,\r\n        uint256 term\r\n    ) internal {\r\n        BalanceData memory balanceData = balance[owner];\r\n        // Update reward amount before addliquidity\r\n        if (addAmount != 0) {\r\n            balanceData.rewardAmount = _calcNextReward(balanceData, term);\r\n            balanceData.term = uint64(term);\r\n            balanceData.balance = balanceData.balance = uint256(balanceData.balance)\r\n                .add(uint256(addAmount))\r\n                .toUint128();\r\n        }\r\n        // Update reward amount after addliquidity\r\n        balanceData.rewardAmount = _calcNextReward(balanceData, currentTerm);\r\n        balanceData.term = uint64(currentTerm);\r\n        // Update balance if remove liquidity\r\n        if (removeAmount != 0) {\r\n            balanceData.balance = uint256(balanceData.balance).sub(removeAmount).toUint128();\r\n        }\r\n        balance[owner] = balanceData;\r\n    }\r\n\r\n    /**\r\n     * @dev This function is called before change balance of share token\r\n     * @param term Reward amount is calculated from next term after this function is called to  term `term`\r\n     */\r\n    function _calcNextReward(BalanceData memory balanceData, uint256 term)\r\n        internal\r\n        view\r\n        returns (uint64 rewardAmount)\r\n    {\r\n        rewardAmount = balanceData.rewardAmount;\r\n        if (balanceData.balance > 0 && balanceData.term < term) {\r\n            uint64 index = uint64(totalRewards.length - 1);\r\n            uint64 referenceTerm = totalRewards[index].term;\r\n            uint64 rewardTotal = totalRewards[index].value;\r\n\r\n            for (uint256 i = term; i > balanceData.term; i--) {\r\n                if (i < referenceTerm) {\r\n                    // If i is smaller than the term in which total reward amount is changed, update total reward amount\r\n                    index -= 1;\r\n                    rewardTotal = totalRewards[index].value;\r\n                    referenceTerm = totalRewards[index].term;\r\n                }\r\n                // Reward amount is calculated by `total reward amount * user balance / total share`\r\n                rewardAmount = uint256(rewardAmount)\r\n                    .add(\r\n                    (uint256(rewardTotal).mul(balanceData.balance)).div(shareData[i].totalShare)\r\n                )\r\n                    .toUint64();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice update reward amount and transfer reward token, then change reward amount to 0\r\n     */\r\n    function claimReward() public override {\r\n        BalanceData memory userData = balance[msg.sender];\r\n        userData.rewardAmount = _calcNextReward(userData, currentTerm);\r\n        userData.term = uint64(currentTerm);\r\n        require(userData.rewardAmount > 0, \"No Reward\");\r\n        uint256 rewardAmount = userData.rewardAmount;\r\n        userData.rewardAmount = 0;\r\n        balance[msg.sender] = userData;\r\n        REWARD_TOKEN.safeTransfer(msg.sender, rewardAmount);\r\n    }\r\n\r\n    // ERC20 functions\r\n\r\n    /**\r\n     * @param amount If this value is uint256(-1) infinite approve\r\n     */\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        if (amount == uint256(-1)) {\r\n            amount = uint128(-1);\r\n        }\r\n        allowances[msg.sender][spender] = amount.toUint128();\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferToken(msg.sender, recipient, amount.toUint128());\r\n    }\r\n\r\n    /**\r\n     * @notice If allowance amount is uint128(-1), allowance amount is not updated\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        uint128 currentAllowance = allowances[sender][msg.sender];\r\n        if (currentAllowance < amount) {\r\n            return false;\r\n        }\r\n        // Skip if infinity approve\r\n        if (currentAllowance != uint128(-1)) {\r\n            allowances[sender][msg.sender] = uint256(allowances[sender][msg.sender])\r\n                .sub(amount)\r\n                .toUint128();\r\n        }\r\n        _transferToken(sender, recipient, amount.toUint128());\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Balance is changed by `_updateBalanceData` to reflect correct reward amount\r\n     */\r\n    function _transferToken(\r\n        address from,\r\n        address to,\r\n        uint128 amount\r\n    ) internal returns (bool) {\r\n        if (balance[from].balance < amount) {\r\n            return false;\r\n        }\r\n        _updateBalanceData(from, -1 * int256(amount));\r\n        _updateBalanceData(to, int256(amount));\r\n        emit Transfer(from, to, uint256(amount));\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address user) public view override returns (uint256) {\r\n        return balance[user].balance;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return uint256(shareData[currentTerm].totalShare).sub(totalUnremovedTokens[currentTerm]);\r\n    }\r\n\r\n    function getLiquidityReservationData(address user)\r\n        public\r\n        view\r\n        returns (\r\n            uint128 receivedCollateralTerm,\r\n            uint128 receivedCollateralAmount,\r\n            uint128 removeTokenTerm,\r\n            uint128 removeTokenAmount\r\n        )\r\n    {\r\n        return (\r\n            receivedCollaterals[user].term,\r\n            receivedCollaterals[user].value,\r\n            unremovedTokens[user].term,\r\n            unremovedTokens[user].value\r\n        );\r\n    }\r\n\r\n    function getCurrentStatus()\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint256 term,\r\n            int16 feeBase,\r\n            uint32 uncheckbondGroupId,\r\n            uint64 unit,\r\n            uint64 trancheTime,\r\n            bool isDanger\r\n        )\r\n    {\r\n        return (\r\n            currentTerm,\r\n            currentFeeBase,\r\n            startBondGroupId,\r\n            priceUnit,\r\n            lastTrancheTime,\r\n            isTotalSupplyDanger\r\n        );\r\n    }\r\n\r\n    function getLiquidationData(uint256 term)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            bool isLiquidated,\r\n            uint32 liquidatedBondGroupID,\r\n            uint32 endBondGroupId\r\n        )\r\n    {\r\n        if (term == 0) {\r\n            term = currentTerm;\r\n        }\r\n        isLiquidated = liquidationData[term].isLiquidated;\r\n        liquidatedBondGroupID = liquidationData[term].liquidatedBondGroupID;\r\n        endBondGroupId = liquidationData[term].endBondGroupId;\r\n    }\r\n\r\n    function totalShareData(uint256 term)\r\n        public\r\n        view\r\n        override\r\n        returns (uint128 totalShare, uint128 totalCollateralPerToken)\r\n    {\r\n        if (term == 0) {\r\n            term = currentTerm;\r\n        }\r\n        return (shareData[term].totalShare, shareData[term].totalCollateralPerToken);\r\n    }\r\n\r\n    function getBondGroupIDFromTermAndPrice(uint256 term, uint256 price)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 bondGroupID)\r\n    {\r\n        price = STRATEGY.calcRoundPrice(price, priceUnit, 1);\r\n\r\n        if (term == 0) {\r\n            term = currentTerm;\r\n        }\r\n        return strikePriceToBondGroup[term][price];\r\n    }\r\n\r\n    function getInfo()\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            address bondMaker,\r\n            address strategy,\r\n            address dotc,\r\n            address bondPricerAddress,\r\n            address oracleAddress,\r\n            address rewardTokenAddress,\r\n            address registratorAddress,\r\n            address owner,\r\n            bool reverseOracle,\r\n            uint64 basePriceUnit,\r\n            uint128 maxSupply\r\n        )\r\n    {\r\n        return (\r\n            address(BONDMAKER),\r\n            address(STRATEGY),\r\n            address(DOTC),\r\n            address(BOND_PRICER),\r\n            address(ORACLE),\r\n            address(REWARD_TOKEN),\r\n            address(BOND_REGISTRATOR),\r\n            OWNER,\r\n            REVERSE_ORACLE,\r\n            BASE_PRICE_UNIT,\r\n            uint128(uint128(-1) / (10**uint256(MAX_SUPPLY_DENUMERATOR)))\r\n        );\r\n    }\r\n\r\n    function getTermInfo(uint256 term)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint64 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 SBTID\r\n        )\r\n    {\r\n        if (term == 0) {\r\n            term = currentTerm;\r\n        }\r\n        return (termInfo[term].maturity, termInfo[term].strikePrice, termInfo[term].SBTId);\r\n    }\r\n\r\n    /**\r\n     * @notice return user's balance including unsettled share token\r\n     */\r\n    function getExpectedBalance(address user)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 expectedBalance)\r\n    {\r\n        expectedBalance = balance[user].balance;\r\n            if (currentTerm > receivedCollaterals[msg.sender].term) {\r\n                expectedBalance += _applyDecimalGap(\r\n                    uint256(receivedCollaterals[msg.sender].value).mul(10**decimals).div(\r\n                        uint256(\r\n                            shareData[receivedCollaterals[msg.sender].term + 1]\r\n                                .totalCollateralPerToken\r\n                        )\r\n                    ),\r\n                    true\r\n                );\r\n            }\r\n    }\r\n\r\n    /**\r\n     * @notice Return current phase of aggregator\r\n     */\r\n    function getCurrentPhase() public view override returns (AggregatorPhase) {\r\n        if (currentTerm == 0) {\r\n            return AggregatorPhase.BEFORE_START;\r\n        } else if (block.timestamp <= termInfo[currentTerm].maturity) {\r\n            if (block.timestamp <= lastTrancheTime + COOLTIME) {\r\n                return AggregatorPhase.COOL_TIME;\r\n            }\r\n            return AggregatorPhase.ACTIVE;\r\n        } else if (\r\n            block.timestamp > termInfo[currentTerm].maturity &&\r\n            !liquidationData[currentTerm].isLiquidated\r\n        ) {\r\n            return AggregatorPhase.AFTER_MATURITY;\r\n        }\r\n        return AggregatorPhase.EXPIRED;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate expected reward amount at this point\r\n     */\r\n    function getRewardAmount(address user) public view override returns (uint64) {\r\n        return _calcNextReward(balance[user], currentTerm);\r\n    }\r\n\r\n    function getTotalRewards() public view override returns (TotalReward[] memory) {\r\n        return totalRewards;\r\n    }\r\n\r\n    function isTotalSupplySafe() public view override returns (bool) {\r\n        return !isTotalSupplyDanger;\r\n    }\r\n\r\n    function getTotalUnmovedAssets() public view override returns (uint256, uint256) {\r\n        return (totalReceivedCollateral[currentTerm], totalUnremovedTokens[currentTerm]);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return allowances[owner][spender];\r\n    }\r\n\r\n    function getCollateralPerToken(uint256 term) public view override returns (uint256) {\r\n        return shareData[term].totalCollateralPerToken;\r\n    }\r\n\r\n    function getBondGroupIdFromStrikePrice(uint256 term, uint256 strikePrice)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return strikePriceToBondGroup[term][strikePrice];\r\n    }\r\n\r\n    function getBalanceData(address user)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint128 amount,\r\n            uint64 term,\r\n            uint64 rewardAmount\r\n        )\r\n    {\r\n        return (balance[user].balance, balance[user].term, balance[user].rewardAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Get suitable bond groups for current price\r\n     */\r\n    function getIssuableBondGroups() public view override returns (uint256[] memory) {\r\n        return issuableBondGroupIds[currentTerm];\r\n    }\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/bondMaker/BondMakerCollateralizedEthInterface.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ninterface BondMakerCollateralizedEthInterface is BondMakerInterface {\r\n    function issueNewBonds(uint256 bondGroupID) external payable returns (uint256 amount);\r\n}\r\n\r\n// File: contracts/BondToken_and_GDOTC/util/TransferETH.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\nabstract contract TransferETH is TransferETHInterface {\r\n    receive() external payable override {\r\n        emit LogTransferETH(msg.sender, address(this), msg.value);\r\n    }\r\n\r\n    function _hasSufficientBalance(uint256 amount) internal view returns (bool ok) {\r\n        address thisContract = address(this);\r\n        return amount <= thisContract.balance;\r\n    }\r\n\r\n    /**\r\n     * @notice transfer `amount` ETH to the `recipient` account with emitting log\r\n     */\r\n    function _transferETH(\r\n        address payable recipient,\r\n        uint256 amount,\r\n        string memory errorMessage\r\n    ) internal {\r\n        require(_hasSufficientBalance(amount), errorMessage);\r\n        (bool success, ) = recipient.call{value: amount}(\"\"); // solhint-disable-line avoid-low-level-calls\r\n        require(success, \"transferring Ether failed\");\r\n        emit LogTransferETH(address(this), recipient, amount);\r\n    }\r\n\r\n    function _transferETH(address payable recipient, uint256 amount) internal {\r\n        _transferETH(recipient, amount, \"TransferETH: transfer amount exceeds balance\");\r\n    }\r\n}\r\n\r\n// File: contracts/SimpleAggregator/ReserveETH.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ncontract ReserveEth is TransferETH {\r\n    address owner;\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Error: Only owner can execute this function\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Send ETH to user\r\n     * Only aggregator can call this function\r\n     */\r\n    function sendAsset(address payable user, uint256 amount) public onlyOwner {\r\n        _transferETH(user, amount);\r\n    }\r\n}\r\n\r\n// File: contracts/SimpleAggregator/SimpleAggregatorCollateralizedEth.sol\r\n\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SimpleAggregatorCollateralizedEth is SimpleAggregator, TransferETH {\r\n    using SafeMath for uint256;\r\n    ReserveEth internal immutable reserveEth;\r\n    uint16 internal constant DECIMAL_GAP = 10;\r\n\r\n    constructor(\r\n        LatestPriceOracleInterface _ethOracle,\r\n        BondPricerWithAcceptableMaturity _pricer,\r\n        SimpleStrategyInterface strategy,\r\n        ERC20 _rewardToken,\r\n        BondRegistratorInterface _registrator,\r\n        ExchangeInterface exchangeAddress,\r\n        VolatilityOracleInterface _volOracle,\r\n        uint64 _priceUnit,\r\n        uint64 _firstRewardRate\r\n    )\r\n        SimpleAggregator(\r\n            _ethOracle,\r\n            _pricer,\r\n            strategy,\r\n            _rewardToken,\r\n            _registrator,\r\n            exchangeAddress,\r\n            _priceUnit,\r\n            _firstRewardRate,\r\n            false,\r\n            _volOracle\r\n        )\r\n    {\r\n        BondMakerInterface _bondMaker = exchangeAddress.bondMakerAddress();\r\n        int16 feeBaseE4 = strategy.getCurrentSpread(msg.sender, address(_ethOracle), false);\r\n        currentFeeBase = feeBaseE4;\r\n        exchangeAddress.createVsBondPool(_bondMaker, _volOracle, _pricer, _pricer, feeBaseE4);\r\n        exchangeAddress.createVsEthPool(_ethOracle, _pricer, feeBaseE4, true);\r\n        exchangeAddress.createVsEthPool(_ethOracle, _pricer, feeBaseE4, false);\r\n\r\n        reserveEth = new ReserveEth();\r\n    }\r\n\r\n    function changeSpread() public override {\r\n        int16 _currentFeeBase = STRATEGY.getCurrentSpread(OWNER, address(ORACLE), false);\r\n\r\n        require(_currentFeeBase <= 1000 && _currentFeeBase >= 5, \"Invalid feebase\");\r\n        bytes32 poolIDETHSell = DOTC.generateVsEthPoolID(address(this), true);\r\n        bytes32 poolIDETHBuy = DOTC.generateVsEthPoolID(address(this), false);\r\n\r\n        bytes32 poolIDBond = DOTC.generateVsBondPoolID(address(this), address(BONDMAKER));\r\n\r\n        DOTC.updateVsEthPool(poolIDETHSell, ORACLE, BOND_PRICER, _currentFeeBase);\r\n\r\n        DOTC.updateVsEthPool(poolIDETHBuy, ORACLE, BOND_PRICER, _currentFeeBase);\r\n\r\n        DOTC.updateVsBondPool(poolIDBond, volOracle, BOND_PRICER, BOND_PRICER, _currentFeeBase);\r\n        currentFeeBase = _currentFeeBase;\r\n    }\r\n\r\n    /**\r\n     * @notice Receive ETH, then call _addLiquidity\r\n     */\r\n    function addLiquidity() external payable isSafeSupply returns (bool success) {\r\n        success = _addLiquidity(msg.value);\r\n    }\r\n\r\n    function _sendTokens(address user, uint256 amount) internal override {\r\n        reserveEth.sendAsset(payable(user), amount);\r\n    }\r\n\r\n    function _reserveAsset(uint256 collateralPerTokenE8) internal override {\r\n        uint256 amount = _applyDecimalGap(\r\n            uint256(totalUnremovedTokens[currentTerm]).mul(collateralPerTokenE8).div(10**decimals),\r\n            false\r\n        );\r\n        _transferETH(address(reserveEth), amount);\r\n    }\r\n\r\n    function _issueBonds(uint256 bondgroupID, uint256 amount) internal override {\r\n        BondMakerCollateralizedEthInterface bm = BondMakerCollateralizedEthInterface(\r\n            address(BONDMAKER)\r\n        );\r\n        bm.issueNewBonds{value: amount.mul(10**DECIMAL_GAP).mul(1002).div(1000)}(bondgroupID);\r\n    }\r\n\r\n    function getCollateralAddress() external pure override returns (address) {\r\n        return address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Decimal gap between ETH and share token is 10\r\n     */\r\n    function _applyDecimalGap(uint256 amount, bool isDiv) internal pure override returns (uint256) {\r\n        if (isDiv) {\r\n            return amount / 10**DECIMAL_GAP;\r\n        } else {\r\n            return amount * 10**DECIMAL_GAP;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get available collateral amount in this term\r\n     */\r\n    function getCollateralAmount() public view override returns (uint256) {\r\n        return address(this).balance.sub(totalReceivedCollateral[currentTerm]);\r\n    }\r\n\r\n    function getCollateralDecimal() external pure override returns (int16) {\r\n        return 18;\r\n    }\r\n\r\n    function getReserveAddress() external view override returns (address) {\r\n        return address(reserveEth);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract LatestPriceOracleInterface\",\"name\":\"_ethOracle\",\"type\":\"address\"},{\"internalType\":\"contract BondPricerWithAcceptableMaturity\",\"name\":\"_pricer\",\"type\":\"address\"},{\"internalType\":\"contract SimpleStrategyInterface\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"contract BondRegistratorInterface\",\"name\":\"_registrator\",\"type\":\"address\"},{\"internalType\":\"contract ExchangeInterface\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"contract VolatilityOracleInterface\",\"name\":\"_volOracle\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_priceUnit\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_firstRewardRate\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogTransferETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"SetAddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"SetRemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"SettleLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"issueBondGroupId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"issueAmount\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"burnBondGroupId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"burnAmount\",\"type\":\"uint64\"}],\"name\":\"TrancheBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"term\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"int16\",\"name\":\"newFeeBase\",\"type\":\"int16\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"}],\"name\":\"UpdateMaturity\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addSuitableBondGroup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bondGroupID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeSpread\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalanceData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"term\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"rewardAmount\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getBondGroupIDFromTermAndPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bondGroupID\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"}],\"name\":\"getBondGroupIdFromStrikePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollateralAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollateralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollateralDecimal\",\"outputs\":[{\"internalType\":\"int16\",\"name\":\"\",\"type\":\"int16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"getCollateralPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPhase\",\"outputs\":[{\"internalType\":\"enum SimpleAggregatorInterface.AggregatorPhase\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"internalType\":\"int16\",\"name\":\"feeBase\",\"type\":\"int16\"},{\"internalType\":\"uint32\",\"name\":\"uncheckbondGroupId\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"unit\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"trancheTime\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isDanger\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getExpectedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bondMaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dotc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bondPricerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registratorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"reverseOracle\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"basePriceUnit\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"maxSupply\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIssuableBondGroups\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"getLiquidationData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isLiquidated\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"liquidatedBondGroupID\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endBondGroupId\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLiquidityReservationData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"receivedCollateralTerm\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"receivedCollateralAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"removeTokenTerm\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"removeTokenAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserveAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRewardAmount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"getTermInfo\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"solidStrikePrice\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"SBTID\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRewards\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"term\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"value\",\"type\":\"uint64\"}],\"internalType\":\"struct SimpleAggregatorInterface.TotalReward[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalUnmovedAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTotalSupplySafe\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hintID\",\"type\":\"uint256\"}],\"name\":\"liquidateBonds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renewMaturity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settleTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unsentETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unsentToken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"totalShareData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"totalShare\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalCollateralPerToken\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trancheBonds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateStartBondGroupId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"rewardRate\",\"type\":\"uint64\"}],\"name\":\"updateTotalReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SimpleAggregatorCollateralizedEth","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006e33f11625b2c8b7270cf8e0319b8b9ffb8f086d00000000000000000000000042b210ea759a37fc7340091f22728161466018e60000000000000000000000003edcc3abef20a427710f6c951fadefd8afa066ba000000000000000000000000ab37e1358b639fd877f015027bb62d3ddaa7557e000000000000000000000000d74e84e6064917f7547c7ae37e09df05c318244e0000000000000000000000002f84206b5ed3eb855c886414f3905115dd166614000000000000000000000000c8bbb8d57cebf834dc429ec4d65dd23ed0d65a87000000000000000000000000000000000000000000000000000000003b9aca00000000000000000000000000000000000000000000000000000000174876e800","EVMVersion":"constantinople","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a3f1b0f51a80e3ef641469844edb0b8dd0ae43965342211bbeb4db6830ba72c6"}]}