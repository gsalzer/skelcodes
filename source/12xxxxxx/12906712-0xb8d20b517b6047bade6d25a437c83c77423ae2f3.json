{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-04-08\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.2;\r\n\r\ninterface IERC20 {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function symbol() external view returns (string memory);\r\n}\r\n\r\ninterface ICurveRegistry {\r\n  function get_pool_from_lp_token(address arg0) external view returns (address);\r\n\r\n  function get_underlying_coins(address arg0)\r\n    external\r\n    view\r\n    returns (address[8] memory);\r\n\r\n  function get_virtual_price_from_lp_token(address arg0)\r\n    external\r\n    view\r\n    returns (uint256);\r\n}\r\n\r\ninterface ICryptoPool {\r\n  function balances(uint256) external view returns (uint256);\r\n\r\n  function price_oracle(uint256) external view returns (uint256);\r\n\r\n  function coins(uint256) external view returns (address);\r\n}\r\n\r\ninterface ILp {\r\n  function totalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface IOracle {\r\n  function getPriceUsdcRecommended(address tokenAddress)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function usdcAddress() external view returns (address);\r\n}\r\n\r\ninterface IYearnAddressesProvider {\r\n  function addressById(string memory) external view returns (address);\r\n}\r\n\r\ninterface ICurveAddressesProvider {\r\n  function get_registry() external view returns (address);\r\n\r\n  function get_address(uint256) external view returns (address);\r\n}\r\n\r\ninterface ICalculationsChainlink {\r\n  function oracleNamehashes(address) external view returns (bytes32);\r\n}\r\n\r\ncontract CalculationsCurve {\r\n  address public ownerAddress;\r\n  address public yearnAddressesProviderAddress;\r\n  address public curveAddressesProviderAddress;\r\n  IYearnAddressesProvider internal yearnAddressesProvider;\r\n  ICurveAddressesProvider internal curveAddressesProvider;\r\n\r\n  constructor(\r\n    address _yearnAddressesProviderAddress,\r\n    address _curveAddressesProviderAddress\r\n  ) {\r\n    curveAddressesProviderAddress = _curveAddressesProviderAddress;\r\n    yearnAddressesProviderAddress = _yearnAddressesProviderAddress;\r\n    ownerAddress = msg.sender;\r\n    yearnAddressesProvider = IYearnAddressesProvider(\r\n      _yearnAddressesProviderAddress\r\n    );\r\n    curveAddressesProvider = ICurveAddressesProvider(\r\n      _curveAddressesProviderAddress\r\n    );\r\n  }\r\n\r\n  function oracle() internal view returns (IOracle) {\r\n    return IOracle(yearnAddressesProvider.addressById(\"ORACLE\"));\r\n  }\r\n\r\n  function curveRegistry() internal view returns (ICurveRegistry) {\r\n    return ICurveRegistry(curveAddressesProvider.get_registry());\r\n  }\r\n\r\n  function getCurvePriceUsdc(address lpAddress) public view returns (uint256) {\r\n    if (isLpCryptoPool(lpAddress)) {\r\n      return cryptoPoolLpPriceUsdc(lpAddress);\r\n    }\r\n    uint256 basePrice = getBasePrice(lpAddress);\r\n    uint256 virtualPrice = getVirtualPrice(lpAddress);\r\n    IERC20 usdc = IERC20(oracle().usdcAddress());\r\n    uint256 decimals = usdc.decimals();\r\n    uint256 decimalsAdjustment = 18 - decimals;\r\n    uint256 priceUsdc = (virtualPrice * basePrice * (10**decimalsAdjustment)) /\r\n      10**(decimalsAdjustment + 18);\r\n    return priceUsdc;\r\n  }\r\n\r\n  function cryptoPoolLpTotalValueUsdc(address lpAddress)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    address poolAddress = curveRegistry().get_pool_from_lp_token(lpAddress);\r\n\r\n\r\n      address[] memory underlyingTokensAddresses\r\n     = cryptoPoolUnderlyingTokensAddressesByPoolAddress(poolAddress);\r\n    uint256 totalValue;\r\n    for (\r\n      uint256 tokenIdx;\r\n      tokenIdx < underlyingTokensAddresses.length;\r\n      tokenIdx++\r\n    ) {\r\n      uint256 tokenValueUsdc = cryptoPoolTokenAmountUsdc(poolAddress, tokenIdx);\r\n      totalValue += tokenValueUsdc;\r\n    }\r\n    return totalValue;\r\n  }\r\n\r\n  function cryptoPoolLpPriceUsdc(address lpAddress)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint256 totalValueUsdc = cryptoPoolLpTotalValueUsdc(lpAddress);\r\n    uint256 totalSupply = ILp(lpAddress).totalSupply();\r\n    uint256 priceUsdc = (totalValueUsdc * 10**18) / totalSupply;\r\n    return priceUsdc;\r\n  }\r\n\r\n  struct TokenAmount {\r\n    address tokenAddress;\r\n    string tokenSymbol;\r\n    uint256 amountUsdc;\r\n  }\r\n\r\n  function cryptoPoolTokenAmountsUsdc(address poolAddress)\r\n    public\r\n    view\r\n    returns (TokenAmount[] memory)\r\n  {\r\n\r\n      address[] memory underlyingTokensAddresses\r\n     = cryptoPoolUnderlyingTokensAddressesByPoolAddress(poolAddress);\r\n    TokenAmount[] memory _tokenAmounts = new TokenAmount[](\r\n      underlyingTokensAddresses.length\r\n    );\r\n    for (\r\n      uint256 tokenIdx;\r\n      tokenIdx < underlyingTokensAddresses.length;\r\n      tokenIdx++\r\n    ) {\r\n      address tokenAddress = underlyingTokensAddresses[tokenIdx];\r\n      string memory tokenSymbol = IERC20(tokenAddress).symbol();\r\n      uint256 amountUsdc = cryptoPoolTokenAmountUsdc(poolAddress, tokenIdx);\r\n      _tokenAmounts[tokenIdx] = TokenAmount({\r\n        tokenAddress: tokenAddress,\r\n        tokenSymbol: tokenSymbol,\r\n        amountUsdc: amountUsdc\r\n      });\r\n    }\r\n    return _tokenAmounts;\r\n  }\r\n\r\n  function cryptoPoolTokenAmountUsdc(address poolAddress, uint256 tokenIdx)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    ICryptoPool pool = ICryptoPool(poolAddress);\r\n    address tokenAddress = pool.coins(tokenIdx);\r\n    uint8 decimals = IERC20(tokenAddress).decimals();\r\n    uint256 tokenPrice;\r\n    if (tokenIdx == 0) {\r\n      tokenPrice = 1 * 10**18;\r\n    } else {\r\n      tokenPrice = pool.price_oracle(tokenIdx - 1);\r\n    }\r\n    uint256 tokenBalance = pool.balances(tokenIdx) * 10**(18 - decimals);\r\n    uint256 tokenValueUsdc = (tokenPrice * tokenBalance) / 10**18 / 10**12;\r\n    return tokenValueUsdc;\r\n  }\r\n\r\n  function cryptoPoolUnderlyingTokensAddressesByPoolAddress(address poolAddress)\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n  {\r\n    uint256 numberOfTokens;\r\n    address[] memory _tokensAddresses = new address[](8);\r\n    for (uint256 coinIdx; coinIdx < 8; coinIdx++) {\r\n      (bool success, bytes memory data) = address(poolAddress).staticcall(\r\n        abi.encodeWithSignature(\"coins(uint256)\", coinIdx)\r\n      );\r\n      if (success) {\r\n        address tokenAddress = abi.decode(data, (address));\r\n        _tokensAddresses[coinIdx] = tokenAddress;\r\n        numberOfTokens++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    bytes memory encodedAddresses = abi.encode(_tokensAddresses);\r\n    assembly {\r\n      mstore(add(encodedAddresses, 0x40), numberOfTokens)\r\n    }\r\n    address[] memory filteredAddresses = abi.decode(\r\n      encodedAddresses,\r\n      (address[])\r\n    );\r\n    return filteredAddresses;\r\n  }\r\n\r\n  function getBasePrice(address lpAddress) public view returns (uint256) {\r\n    address poolAddress = curveRegistry().get_pool_from_lp_token(lpAddress);\r\n    address underlyingCoinAddress = getUnderlyingCoinFromPool(poolAddress);\r\n    uint256 basePriceUsdc = oracle().getPriceUsdcRecommended(\r\n      underlyingCoinAddress\r\n    );\r\n    return basePriceUsdc;\r\n  }\r\n\r\n  function getVirtualPrice(address lpAddress) public view returns (uint256) {\r\n    return curveRegistry().get_virtual_price_from_lp_token(lpAddress);\r\n  }\r\n\r\n  function isCurveLpToken(address lpAddress) public view returns (bool) {\r\n    address poolAddress = curveRegistry().get_pool_from_lp_token(lpAddress);\r\n    bool tokenHasCurvePool = poolAddress != address(0);\r\n    return tokenHasCurvePool;\r\n  }\r\n\r\n  function isLpCryptoPool(address lpAddress) public view returns (bool) {\r\n    address poolAddress = curveRegistry().get_pool_from_lp_token(lpAddress);\r\n    (bool success, ) = address(poolAddress).staticcall(\r\n      abi.encodeWithSignature(\"price_oracle(uint256)\", 0)\r\n    );\r\n    return success;\r\n  }\r\n\r\n  function isPoolCryptoPool(address poolAddress) public view returns (bool) {\r\n    (bool success, ) = address(poolAddress).staticcall(\r\n      abi.encodeWithSignature(\"price_oracle(uint256)\", 0)\r\n    );\r\n    return success;\r\n  }\r\n\r\n  function isBasicToken(address tokenAddress) public view returns (bool) {\r\n    return\r\n      ICalculationsChainlink(\r\n        yearnAddressesProvider.addressById(\"CALCULATIONS_CHAINLINK\")\r\n      ).oracleNamehashes(tokenAddress) != bytes32(0);\r\n  }\r\n\r\n  function getUnderlyingCoinFromPool(address poolAddress)\r\n    public\r\n    view\r\n    returns (address)\r\n  {\r\n    address[8] memory coins = curveRegistry().get_underlying_coins(poolAddress);\r\n\r\n    // Look for preferred coins (basic coins)\r\n    address preferredCoinAddress;\r\n    for (uint256 coinIdx = 0; coinIdx < 8; coinIdx++) {\r\n      address coinAddress = coins[coinIdx];\r\n      if (isBasicToken(coinAddress)) {\r\n        preferredCoinAddress = coinAddress;\r\n        break;\r\n      } else if (coinAddress != address(0)) {\r\n        preferredCoinAddress = coinAddress;\r\n      }\r\n      // Found preferred coin and we're at the end of the token array\r\n      if (\r\n        (preferredCoinAddress != address(0) && coinAddress == address(0)) ||\r\n        coinIdx == 7\r\n      ) {\r\n        break;\r\n      }\r\n    }\r\n    return preferredCoinAddress;\r\n  }\r\n\r\n  function getPriceUsdc(address assetAddress) public view returns (uint256) {\r\n    if (isCurveLpToken(assetAddress)) {\r\n      return getCurvePriceUsdc(assetAddress);\r\n    }\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   * Allow storage slots to be manually updated\r\n   */\r\n  function updateSlot(bytes32 slot, bytes32 value) external {\r\n    require(msg.sender == ownerAddress, \"Ownable: Admin only\");\r\n    assembly {\r\n      sstore(slot, value)\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yearnAddressesProviderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveAddressesProviderAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"cryptoPoolLpPriceUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"cryptoPoolLpTotalValueUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdx\",\"type\":\"uint256\"}],\"name\":\"cryptoPoolTokenAmountUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"cryptoPoolTokenAmountsUsdc\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct CalculationsCurve.TokenAmount[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"cryptoPoolUnderlyingTokensAddressesByPoolAddress\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveAddressesProviderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"getBasePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"getCurvePriceUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"getPriceUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"getUnderlyingCoinFromPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"getVirtualPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"isBasicToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"isCurveLpToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"isLpCryptoPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"isPoolCryptoPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"updateSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearnAddressesProviderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CalculationsCurve","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009be19ee7bc4099d62737a7255f5c227fbcd6db930000000000000000000000000000000022d53366457f9d5e68ec105046fc4383","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8f334b2b063219195db08fd8f0674ffcf7bb5efa4e5e8cc08df43ce4fa51ec29"}]}