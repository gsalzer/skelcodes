{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.8.0;\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ninterface INBU_WETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IERC20Permit {\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\ncontract NimbusERC20P2P_V1 {    \r\n    struct Trade {\r\n        address initiator;\r\n        address counterparty;\r\n        address proposedAsset;\r\n        uint proposedAmount;\r\n        address askedAsset;\r\n        uint askedAmount;\r\n        uint deadline;\r\n        uint status; //0: Active, 1: success, 2: canceled, 3: withdrawn\r\n    }\r\n\r\n    enum TradeState {\r\n        Active,\r\n        Succeeded,\r\n        Canceled,\r\n        Withdrawn,\r\n        Overdue\r\n    }\r\n\r\n    INBU_WETH public immutable NBU_WETH;\r\n\r\n    uint public tradeCount;\r\n    mapping(uint => Trade) public trades;\r\n    mapping(address => uint[]) private _userTrades;\r\n\r\n    event NewTrade(address proposedAsset, uint proposedAmount, address askedAsset, uint askedAmount, uint deadline, uint tradeId);\r\n    event SupportTrade(uint tradeId, address counterparty);\r\n    event CancelTrade(uint tradeId);\r\n    event WithdrawOverdueAsset(uint tradeId);\r\n    \r\n    constructor(address nbuWeth) {\r\n        require(Address.isContract(nbuWeth), \"NimbusERC20P2P_V1: Not contract\");\r\n        NBU_WETH = INBU_WETH(nbuWeth);\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == address(NBU_WETH)); // only accept ETH via fallback from the NBU_WETH contract\r\n    }\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, 'NimbusERC20P2P_V1: locked');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    function createTrade(address proposedAsset, uint proposedAmount, address askedAsset, uint askedAmount, uint deadline) external returns (uint tradeId) {\r\n        require(Address.isContract(proposedAsset) && Address.isContract(askedAsset), \"NimbusERC20P2P_V1: Not contracts\");\r\n        TransferHelper.safeTransferFrom(proposedAsset, msg.sender, address(this), proposedAmount);\r\n        tradeId = _createTrade(proposedAsset, proposedAmount, askedAsset, askedAmount, deadline);   \r\n    }\r\n\r\n    function createTradeETH(address askedAsset, uint askedAmount, uint deadline) payable external returns (uint tradeId) {\r\n        require(Address.isContract(askedAsset), \"NimbusERC20P2P_V1: Not contract\");\r\n        NBU_WETH.deposit{value: msg.value}();\r\n        tradeId = _createTrade(address(NBU_WETH), msg.value, askedAsset, askedAmount, deadline);   \r\n    }\r\n\r\n    function createTradeWithPermit(address proposedAsset, uint proposedAmount, address askedAsset, uint askedAmount, uint deadline, uint permitDeadline, uint8 v, bytes32 r, bytes32 s) external returns (uint tradeId) {\r\n        require(Address.isContract(proposedAsset) && Address.isContract(askedAsset), \"NimbusERC20P2P_V1: Not contracts\");\r\n        IERC20Permit(proposedAsset).permit(msg.sender, address(this), proposedAmount, permitDeadline, v, r, s);\r\n        TransferHelper.safeTransferFrom(proposedAsset, msg.sender, address(this), proposedAmount);\r\n        tradeId = _createTrade(proposedAsset, proposedAmount, askedAsset, askedAmount, deadline);   \r\n    }\r\n\r\n\r\n    function supportTrade(uint tradeId) external lock {\r\n        require(tradeCount >= tradeId && tradeId > 0, \"NimbusERC20P2P_V1: invalid trade id\");\r\n        Trade storage trade = trades[tradeId];\r\n        require(trade.status == 0 && trade.deadline > block.timestamp, \"NimbusERC20P2P_V1: not active trade\");\r\n\r\n        TransferHelper.safeTransferFrom(trade.askedAsset, msg.sender, trade.initiator, trade.askedAmount);\r\n        _supportTrade(tradeId);\r\n    }\r\n\r\n    function supportTradeETH(uint tradeId) payable external lock {\r\n        require(tradeCount >= tradeId && tradeId > 0, \"NimbusERC20P2P_V1: invalid trade id\");\r\n        Trade storage trade = trades[tradeId];\r\n        require(trade.status == 0 && trade.deadline > block.timestamp, \"NimbusERC20P2P_V1: not active trade\");\r\n        require(msg.value >= trade.askedAmount, \"NimbusERC20P2P_V1: Not enough ETH sent\");\r\n        require(trade.askedAsset == address(NBU_WETH), \"NimbusERC20P2P_V1: ERC20 trade\");\r\n\r\n        TransferHelper.safeTransferETH(trade.initiator, trade.askedAmount);\r\n        if (msg.value > trade.askedAmount) TransferHelper.safeTransferETH(msg.sender, msg.value - trade.askedAmount);\r\n        _supportTrade(tradeId);\r\n    }\r\n\r\n    function supportTradeWithPermit(uint tradeId, uint permitDeadline, uint8 v, bytes32 r, bytes32 s) external lock {\r\n        require(tradeCount >= tradeId && tradeId > 0, \"NimbusERC20P2P_V1: invalid trade id\");\r\n        Trade storage trade = trades[tradeId];\r\n        require(trade.status == 0 && trade.deadline > block.timestamp, \"NimbusERC20P2P_V1: not active trade\");\r\n\r\n        IERC20Permit(trade.askedAsset).permit(msg.sender, address(this), trade.askedAmount, permitDeadline, v, r, s);\r\n        TransferHelper.safeTransferFrom(trade.askedAsset, msg.sender, trade.initiator, trade.askedAmount);\r\n        _supportTrade(tradeId);\r\n    }\r\n\r\n    function cancelTrade(uint tradeId) external lock { \r\n        require(tradeCount >= tradeId && tradeId > 0, \"NimbusERC20P2P_V1: invalid trade id\");\r\n        Trade storage trade = trades[tradeId];\r\n        require(trade.initiator == msg.sender, \"NimbusERC20P2P_V1: not allowed\");\r\n        require(trade.status == 0 && trade.deadline > block.timestamp, \"NimbusERC20P2P_V1: not active trade\");\r\n        trade.status = 2;\r\n\r\n        if (trade.proposedAsset != address(NBU_WETH)) {\r\n            TransferHelper.safeTransfer(trade.proposedAsset, msg.sender, trade.proposedAmount);\r\n        } else {\r\n            NBU_WETH.withdraw(trade.proposedAmount);\r\n            TransferHelper.safeTransferETH(msg.sender, trade.proposedAmount);\r\n        }\r\n\r\n        emit CancelTrade(tradeId);\r\n    }\r\n\r\n    function withdrawOverdueAsset(uint tradeId) external lock { \r\n        require(tradeCount >= tradeId && tradeId > 0, \"NimbusERC20P2P_V1: invalid trade id\");\r\n        Trade storage trade = trades[tradeId];\r\n        require(trade.initiator == msg.sender, \"NimbusERC20P2P_V1: not allowed\");\r\n        require(trade.status == 0 && trade.deadline < block.timestamp, \"NimbusERC20P2P_V1: not available for withdrawal\");\r\n\r\n        if (trade.proposedAsset != address(NBU_WETH)) {\r\n            TransferHelper.safeTransfer(trade.proposedAsset, msg.sender, trade.proposedAmount);\r\n        } else {\r\n            NBU_WETH.withdraw(trade.proposedAmount);\r\n            TransferHelper.safeTransferETH(msg.sender, trade.proposedAmount);\r\n        }\r\n\r\n        trade.status = 3;\r\n\r\n        emit WithdrawOverdueAsset(tradeId);\r\n    }\r\n\r\n    function state(uint tradeId) public view returns (TradeState) {\r\n        require(tradeCount >= tradeId && tradeId > 0, \"NimbusERC20P2P_V1: invalid trade id\");\r\n        Trade storage trade = trades[tradeId];\r\n        if (trade.status == 1) {\r\n            return TradeState.Succeeded;\r\n        } else if (trade.status == 2 || trade.status == 3) {\r\n            return TradeState(trade.status);\r\n        } else if (trade.deadline < block.timestamp) {\r\n            return TradeState.Overdue;\r\n        } else {\r\n            return TradeState.Active;\r\n        }\r\n    }\r\n\r\n    function userTrades(address user) public view returns (uint[] memory) {\r\n        return _userTrades[user];\r\n    }\r\n\r\n\r\n\r\n    function _createTrade(address proposedAsset, uint proposedAmount, address askedAsset, uint askedAmount, uint deadline) private returns (uint tradeId) { \r\n        require(askedAsset != proposedAsset, \"NimbusERC20P2P_V1: asked asset can't be equal to proposed asset\");\r\n        require(proposedAmount > 0, \"NimbusERC20P2P_V1: zero proposed amount\");\r\n        require(askedAmount > 0, \"NimbusERC20P2P_V1: zero asked amount\");\r\n        require(deadline > block.timestamp, \"NimbusERC20P2P_V1: incorrect deadline\");\r\n        tradeId = ++tradeCount;\r\n        Trade storage trade = trades[tradeId];\r\n        trade.initiator = msg.sender;\r\n        trade.proposedAsset = proposedAsset;\r\n        trade.proposedAmount = proposedAmount;\r\n        trade.askedAsset = askedAsset;\r\n        trade.askedAmount = askedAmount;\r\n        trade.deadline = deadline;\r\n        \r\n        _userTrades[msg.sender].push(tradeId);\r\n        \r\n        emit NewTrade(proposedAsset, proposedAmount, askedAsset, askedAmount, deadline, tradeId);\r\n    }\r\n\r\n    function _supportTrade(uint tradeId) private { \r\n        Trade storage trade = trades[tradeId];\r\n\r\n        if (trade.proposedAsset != address(NBU_WETH)) {\r\n            TransferHelper.safeTransfer(trade.proposedAsset, msg.sender, trade.proposedAmount);\r\n        } else {\r\n            NBU_WETH.withdraw(trade.proposedAmount);\r\n            TransferHelper.safeTransferETH(msg.sender, trade.proposedAmount);\r\n        }\r\n        trade.counterparty = msg.sender;\r\n        trade.status = 1;\r\n        emit SupportTrade(tradeId, msg.sender);\r\n    }\r\n }","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nbuWeth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"name\":\"CancelTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposedAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"askedAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"askedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"name\":\"NewTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"counterparty\",\"type\":\"address\"}],\"name\":\"SupportTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"name\":\"WithdrawOverdueAsset\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NBU_WETH\",\"outputs\":[{\"internalType\":\"contract INBU_WETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"name\":\"cancelTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposedAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"askedAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"askedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"createTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"askedAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"askedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"createTradeETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposedAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"askedAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"askedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"permitDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"createTradeWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum NimbusERC20P2P_V1.TradeState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"name\":\"supportTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"name\":\"supportTradeETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"permitDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"supportTradeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"trades\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"counterparty\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposedAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"askedAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"askedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userTrades\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeId\",\"type\":\"uint256\"}],\"name\":\"withdrawOverdueAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"NimbusERC20P2P_V1","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000000bcd83df58a1bfd25b1347f9c9da1b7118b648a6","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7e416783160a103511778d6538cc1e4742f0873cdacab6e64d8eab71a06f4f03"}]}