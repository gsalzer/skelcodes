{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: Apache License, Version 2.0\n\npragma solidity 0.7.6;\n\n\n\n// Part: Address\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// Part: IERC165\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// Part: IERC20\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// Part: ReentrancyGuard\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n// Part: SafeMath\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n// Part: IERC1155\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n\n// Part: IStarNFT\n\n/**\n * @title IStarNFT\n * @author Galaxy Protocol\n *\n * Interface for operating with StarNFTs.\n */\ninterface IStarNFT is IERC1155 {\n    /* ============ Events =============== */\n    event PowahUpdated(uint256 indexed id, uint256 indexed oldPoints, uint256 indexed newPoints);\n\n    /* ============ Functions ============ */\n\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function starInfo(uint256) external view returns (uint128 powah, uint128 mintBlock, address originator);\n    function quasarInfo(uint256) external view returns (uint128 mintBlock, IERC20 stakeToken, uint256 amount, uint256 campaignID);\n    function superInfo(uint256) external view returns (uint128 mintBlock, IERC20[] memory stakeToken, uint256[] memory amount, uint256 campaignID);\n\n    // mint\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n\n    // asset-backing mint\n    function mintQuasar(address account, uint256 powah, uint256 cid, IERC20 stakeToken, uint256 amount) external returns (uint256);\n    function burnQuasar(address account, uint256 id) external;\n\n    // asset-backing forge\n    function mintSuper(address account, uint256 powah, uint256 campaignID, IERC20[] calldata stakeTokens, uint256[] calldata amounts) external returns (uint256);\n    function burnSuper(address account, uint256 id) external;\n    // update\n    function updatePowah(address owner, uint256 id, uint256 powah) external;\n}\n\n// File: SpaceStation.sol\n\n/**\n * @title SpaceStation\n * @author Galaxy Protocol\n *\n * Campaign contract that allows privileged DAOs to initiate campaigns for members to claim StarNFTs.\n */\ncontract SpaceStation is ReentrancyGuard {\n    using Address for address;\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n    event EventClaim(uint256 _cid, address _sender);\n    event EventStakeIn(uint256 _cid, address _sender, uint256 _stakeAmount, address _erc20);\n    event EventStakeOut(address _starNFT, uint256 _nftID);\n    event EventForgeNoStake(uint256 _cid, address _sender, address _starNFT, uint256[] _nftIDs);\n    event EventForgeWithStake(uint256 _cid, address _sender, address _starNFT, uint256[] _nftIDs, uint256 _stakeAmount, address _erc20);\n\n    /* ============ Modifiers ============ */\n    /**\n     * Throws if the address is not a validated starNFT contract\n     */\n    modifier onlyStarNFT(IStarNFT _starNFTAddress)  {\n        require(_starNFTs[_starNFTAddress], \"Invalid Star NFT contract address\");\n        _;\n    }\n    /**\n     * Throws if the sender is not the manager\n     */\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    /**\n     * Throws if the sender is not the Treasury's manager\n     */\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    /**\n     * Throws if the contract paused\n     */\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n\n    /* ============ Enums ================ */\n\n    // Operation a user could interact with Galaxy per campaign of DAO\n    enum Operation {\n        Default,\n        Claim,\n        StakeIn,\n        StakeOut,\n        Forge\n    }\n\n    /* ============ Structs ============ */\n\n    struct CampaignStakeConfig {\n        address erc20;                  // Address of token being staked\n        uint256 minStakeAmount;         // Minimum amount of token to stake required, included\n        uint256 maxStakeAmount;         // Maximum amount of token to stake required, included\n        uint256 lockBlockNum;           // To indicate when token lock-up period is met\n        bool burnRequired;              // Require NFT burnt if staked out\n        bool isEarlyStakeOutAllowed;    // Whether early stake out is allowed or not\n        uint256 earlyStakeOutFine;      // If early stake out is allowed, the applied penalty\n    }\n\n    struct CampaignFeeConfig {\n        address erc20;                 // Address of token asset if required\n        uint256 erc20Fee;              // Amount of token if required\n        uint256 networkFee;            // Amount of fee per network\n        bool isActive;                 // Indicate whether this campaign exists and is active\n    }\n\n    /* ============ State Variables ============ */\n\n    // The manager which has privilege to add, remove starNFT address, control treasury.\n    address public manager;\n    address public treasury_manager;\n\n    // Mapping that stores all stake requirement for a given activated campaign.\n    mapping(uint256 => CampaignStakeConfig) public campaignStakeConfigs;\n\n    // Mapping that stores all fee requirements per Operation for a given activated campaign.\n    // If no fee is required at all, Operation(DEFAULT) should set to all zero values.\n    // Operation(DEFAULT) should always exist.\n    mapping(uint256 => mapping(Operation => CampaignFeeConfig)) public campaignFeeConfigs;\n\n    // Set that contains all validated starNFT contract addresses\n    mapping(IStarNFT => bool) private _starNFTs;\n\n    // Mapping that records fees totals owned by galaxy-treasury,\n    // Separate from escrow backed-asset from users.\n    uint256 public galaxyTreasuryNetwork;\n    mapping(address => uint256) public galaxyTreasuryERC20;\n    // contract is initialized\n    bool public initialized;\n    // contract is paused\n    bool public paused;\n\n\n    /* ============ Constructor ============ */\n\n    constructor() {}\n\n    function initialize(address _manager, address _treasury_manager) external {\n        require(!initialized, \"Contract already initialized\");\n        if (_manager != address(0)) {\n            manager = _manager;\n        } else {\n            // `manager` defaults to msg.sender on construction if no valid manager address passed in.\n            manager = msg.sender;\n        }\n        if (_treasury_manager != address(0)) {\n            treasury_manager = _treasury_manager;\n        } else {\n            // `treasury_manager` defaults to msg.sender on construction if no valid treasury_manager address passed in.\n            treasury_manager = msg.sender;\n        }\n        initialized = true;\n    }\n\n    /* ============ External Functions ============ */\n\n    function activateCampaign(\n        uint256 _cid,\n        Operation[] calldata _op,\n        uint256[] calldata _networkFee,\n        uint256[] calldata _erc20Fee,\n        address[] calldata _erc20\n    ) external onlyManager {\n        _setFees(_cid, _op, _networkFee, _erc20Fee, _erc20);\n    }\n\n    /**\n     * Expire a non-stake campaign. Those with asset-backed quasar_nft campaigns won't get touched.\n     * NOTE: should only reset non-stake campaigns.\n     */\n    function expireCampaign(uint256 _cid, Operation[] calldata _op) external onlyManager {\n        require(_op.length > 0, \"Array(_op) should not be empty.\");\n        for (uint256 i = 0; i < _op.length; i++) {\n            delete campaignFeeConfigs[_cid][_op[i]];\n        }\n    }\n\n\n    /**\n     * Activate a stake campaign.\n     * @param _params bytes1: Bitwise params for stake requirements\n     * {\n     *   burnRequired,         // First bit, Require NFT burnt if staked out\n     *   earlyStakeOutFine     // Second bit, Whether early stake out is allowed or not\n     * }\n     * 0b00000000 0x00  => false, false\n     * 0b01000000 0x40  => false, true\n     * 0b10000000 0x80  => true, false\n     * 0b11000000 0xc0  => true, true\n     */\n    function activateStakeCampaign(\n        uint256 _cid,\n        address _stakeErc20,\n        uint256 _minStakeAmount,\n        uint256 _maxStakeAmount,\n        uint256 _lockBlockNum,\n        bytes1 _params,\n        uint256 _earlyStakeOutFine,\n        Operation[] calldata _op,\n        uint256[] calldata _networkFee,\n        uint256[] calldata _erc20Fee,\n        address[] calldata _erc20\n    ) external onlyManager {\n        require(_stakeErc20 != address(0), \"Stake Token must not be null address\");\n        require(_minStakeAmount > 0, \"Min stake amount should be greater than 0 for stake campaign\");\n        require(_minStakeAmount <= _maxStakeAmount, \"StakeAmount min should less than or equal to max\");\n\n        _setFees(_cid, _op, _networkFee, _erc20Fee, _erc20);\n\n        _setStake(_cid, _stakeErc20, _minStakeAmount, _maxStakeAmount, _lockBlockNum, _params, _earlyStakeOutFine);\n    }\n\n    function claim(uint256 _cid) external payable onlyNoPaused {\n        _payFees(_cid, Operation.Claim);\n        emit EventClaim(_cid, msg.sender);\n    }\n\n    function stakeIn(uint256 _cid, uint256 stakeAmount) external payable nonReentrant onlyNoPaused {\n        _payFees(_cid, Operation.StakeIn);\n        _stakeIn(_cid, stakeAmount);\n        emit EventStakeIn(_cid, msg.sender, stakeAmount, campaignStakeConfigs[_cid].erc20);\n    }\n\n    // CALL STAR_NFT*\n    function stakeOutQuasar(IStarNFT _starNFT, uint256 _nftID) external payable onlyStarNFT(_starNFT) nonReentrant {\n        require(_starNFT.isOwnerOf(msg.sender, _nftID), \"Must be owner of this Quasar NFT\");\n        // 1.1 get info, make sure nft has backing-asset\n        (uint256 _mintBlock, IERC20 _stakeToken, uint256 _amount, uint256 _cid) = _starNFT.quasarInfo(_nftID);\n        require(address(_stakeToken) != address(0), \"Backing-asset token must not be null address\");\n        require(_amount > 0, \"Backing-asset amount must be greater than 0\");\n        // 2. check early stake out fine if applies\n        _payFine(_cid, _mintBlock);\n        // 3. pay fee\n        _payFees(_cid, Operation.StakeOut);\n        // 4. transfer back (backed asset)\n        require(_stakeToken.transfer(msg.sender, _amount), \"Stake out transfer assert back failed\");\n        // 5. postStakeOut (quasar->star nft; burn quasar)\n        if (campaignStakeConfigs[_cid].burnRequired) {\n            _starNFT.burn(msg.sender, _nftID);\n        } else {\n            _starNFT.burnQuasar(msg.sender, _nftID);\n        }\n        emit EventStakeOut(address(_starNFT), _nftID);\n    }\n\n    function stakeOutSuper(IStarNFT _starNFT, uint256 _nftID) external payable onlyStarNFT(_starNFT) nonReentrant {\n        require(_starNFT.isOwnerOf(msg.sender, _nftID), \"Must be owner of this Super NFT\");\n        // 1.1 get info, make sure nft has backing-asset\n        (uint256 _mintBlock, IERC20[] memory _stakeToken, uint256[] memory _amount, uint256 _cid) = IStarNFT(_starNFT).superInfo(_nftID);\n        require(_stakeToken.length > 0, \"Array(_stakeToken) should not be empty.\");\n        require(_stakeToken.length == _amount.length, \"Array(_amount) length mismatch\");\n        // 2. check early stake out fine if applies\n        _payFine(_cid, _mintBlock);\n        // 3. pay fee\n        _payFees(_cid, Operation.StakeOut);\n        // 4. transfer back (backed asset)\n        for (uint256 i = 0; i < _stakeToken.length; i++) {\n            require(address(_stakeToken[i]) != address(0), \"Backing-asset token must not be null address\");\n            require(_amount[i] > 0, \"Backing-asset amount must be greater than 0\");\n            require(_stakeToken[i].transfer(msg.sender, _amount[i]), \"Stake out transfer assert back failed\");\n        }\n        // 5. postStakeOut (super->star nft; burn super)\n        if (campaignStakeConfigs[_cid].burnRequired) {\n            _starNFT.burn(msg.sender, _nftID);\n        } else {\n            _starNFT.burnSuper(msg.sender, _nftID);\n        }\n        emit EventStakeOut(address(_starNFT), _nftID);\n    }\n\n    function forgeNoStake(uint256 _cid, IStarNFT _starNFT, uint256[] calldata _nftIDs) external payable onlyStarNFT(_starNFT) nonReentrant onlyNoPaused {\n        for (uint i = 0; i < _nftIDs.length; i++) {\n            require(_starNFT.isOwnerOf(msg.sender, _nftIDs[i]), \"Not the owner\");\n        }\n        _payFees(_cid, Operation.Forge);\n        _starNFT.burnBatch(msg.sender, _nftIDs);\n        emit EventForgeNoStake(_cid, msg.sender, address(_starNFT), _nftIDs);\n    }\n\n    function forgeStake(uint256 _cid, IStarNFT _starNFT, uint256[] calldata _nftIDs, uint256 stakeAmount) external payable onlyStarNFT(_starNFT) nonReentrant onlyNoPaused {\n        for (uint i = 0; i < _nftIDs.length; i++) {\n            require(_starNFT.isOwnerOf(msg.sender, _nftIDs[i]), \"Not the owner\");\n        }\n        _payFees(_cid, Operation.Forge);\n        _stakeIn(_cid, stakeAmount);\n        _starNFT.burnBatch(msg.sender, _nftIDs);\n        emit EventForgeWithStake(_cid, msg.sender, address(_starNFT), _nftIDs, stakeAmount, campaignStakeConfigs[_cid].erc20);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n\n    /**\n     * PRIVILEGED MODULE FUNCTION. Function that adds a validated starNFT address.\n     */\n    function addValidatedStarNFTAddress(IStarNFT _starNFT) external onlyManager {\n        require(address(_starNFT) != address(0), \"Validate StarNFT contract must not be null address\");\n        _starNFTs[_starNFT] = true;\n    }\n    /**\n     * PRIVILEGED MODULE FUNCTION. Function that removes a validated starNFT address.\n     */\n    function removeValidatedStarNFTAddress(IStarNFT _starNFT) external onlyManager {\n        require(address(_starNFT) != address(0), \"Invalidate StarNFT contract must not be null address\");\n        _starNFTs[_starNFT] = false;\n    }\n\n    /**\n     * PRIVILEGED MODULE FUNCTION. Function that withdraw fees[network] total owned by galaxy-treasury to manager.\n     */\n    function networkWithdraw() external onlyTreasuryManager {\n        // get the amount of Ether/BNB fees stored in this contract owned by galaxy-treasury\n        uint256 amount = galaxyTreasuryNetwork;\n        require(amount > 0, \"Treasury of network should be greater than 0\");\n\n        // modify state first\n        galaxyTreasuryNetwork = 0;\n        // send Ether/BNB fees to manager\n        // Manager can receive Ether/BNB since the address of manager is payable\n        (bool success,) = manager.call{value : amount}(\"\");\n        require(success, \"Failed to send Ether/BNB fees to treasury manager\");\n    }\n\n    /**\n     * PRIVILEGED MODULE FUNCTION. Function that withdraw fees[erc20] total owned by galaxy-treasury to manager.\n     */\n    function erc20Withdraw(address erc20) external onlyTreasuryManager nonReentrant {\n        // get the amount of erc20 fees stored in this contract owned by galaxy-treasury\n        uint256 amount = galaxyTreasuryERC20[erc20];\n        require(amount > 0, \"Treasury of ERC20 should be greater than 0\");\n\n        // modify state first\n        galaxyTreasuryERC20[erc20] = 0;\n        // send erc20 fees to manager\n        require(IERC20(erc20).transfer(manager, amount), \"Failed to send Erc20 fees to treasury manager\");\n    }\n\n    /**\n      * @dev stake out quasar in emergency mode\n      */\n    function emergencyWithdrawQuasar(IStarNFT _starNFT, uint256 _nftID) external onlyStarNFT(_starNFT) nonReentrant {\n        require(paused, \"Not paused\");\n        require(_starNFT.isOwnerOf(msg.sender, _nftID), \"Must be owner of this Quasar NFT\");\n        // 1.1 get info, make sure nft has backing-asset\n        (uint256 _mintBlock, IERC20 _stakeToken, uint256 _amount, uint256 _cid) = _starNFT.quasarInfo(_nftID);\n        require(address(_stakeToken) != address(0), \"Backing-asset token must not be null address\");\n        require(_amount > 0, \"Backing-asset amount must be greater than 0\");\n        // 4. transfer back (backed asset)\n        require(_stakeToken.transfer(msg.sender, _amount), \"Stake out transfer assert back failed\");\n        // 5. postStakeOut (quasar->star nft; burn quasar)\n        if (campaignStakeConfigs[_cid].burnRequired) {\n            _starNFT.burn(msg.sender, _nftID);\n        } else {\n            _starNFT.burnQuasar(msg.sender, _nftID);\n        }\n        emit EventStakeOut(address(_starNFT), _nftID);\n    }\n\n    /**\n      * @dev stake out super in emergency mode\n      */\n    function emergencyWithdrawSuper(IStarNFT _starNFT, uint256 _nftID) external onlyStarNFT(_starNFT) nonReentrant {\n        require(paused, \"Not paused\");\n        require(_starNFT.isOwnerOf(msg.sender, _nftID), \"Must be owner of this Super NFT\");\n        // 1.1 get info, make sure nft has backing-asset\n        (uint256 _mintBlock, IERC20[] memory _stakeToken, uint256[] memory _amount, uint256 _cid) = IStarNFT(_starNFT).superInfo(_nftID);\n        require(_stakeToken.length > 0, \"Array(_stakeToken) should not be empty.\");\n        require(_stakeToken.length == _amount.length, \"Array(_amount) length mismatch\");\n        // 4. transfer back (backed asset)\n        for (uint256 i = 0; i < _stakeToken.length; i++) {\n            require(address(_stakeToken[i]) != address(0), \"Backing-asset token must not be null address\");\n            require(_amount[i] > 0, \"Backing-asset amount must be greater than 0\");\n            require(_stakeToken[i].transfer(msg.sender, _amount[i]), \"Stake out transfer assert back failed\");\n        }\n        // 5. postStakeOut (super->star nft; burn super)\n        if (campaignStakeConfigs[_cid].burnRequired) {\n            _starNFT.burn(msg.sender, _nftID);\n        } else {\n            _starNFT.burnSuper(msg.sender, _nftID);\n        }\n        emit EventStakeOut(address(_starNFT), _nftID);\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    function stakeOutInfo(IStarNFT _starNFTAddress, uint256 _nft_id) external onlyStarNFT(_starNFTAddress) view returns (\n        bool _allowStakeOut,\n        uint256 _allowBlock,\n        bool _requireBurn,\n        uint256 _earlyStakeOutFine,\n        uint256 _noFineBlock\n    ) {\n        (uint256 _createBlock, IERC20 _stakeToken, uint256 _amount, uint256 _cid) = _starNFTAddress.quasarInfo(_nft_id);\n        if (address(_stakeToken) == address(0)) {\n            // no asset\n            return (false, 0, false, 0, 0);\n        }\n        _requireBurn = campaignStakeConfigs[_cid].burnRequired;\n        //        uint256 lockBlockNum = campaignStakeConfigs[_cid].lockBlockNum;\n        if (block.number >= campaignStakeConfigs[_cid].lockBlockNum.add(_createBlock)) {\n            return (true, 0, _requireBurn, 0, 0);\n        }\n        _allowBlock = campaignStakeConfigs[_cid].lockBlockNum + _createBlock;\n        if (!campaignStakeConfigs[_cid].isEarlyStakeOutAllowed) {\n            // not allow early stakeout\n            return (false, _allowBlock, _requireBurn, 0, 0);\n        }\n        _allowStakeOut = true;\n        _allowBlock = _createBlock;\n        _noFineBlock = _createBlock + campaignStakeConfigs[_cid].lockBlockNum;\n        _earlyStakeOutFine = _noFineBlock\n        .sub(block.number)\n        .mul(10000)\n        .mul(campaignStakeConfigs[_cid].earlyStakeOutFine)\n        .div(campaignStakeConfigs[_cid].lockBlockNum)\n        .div(10000);\n    }\n\n    function superStakeOutInfo(IStarNFT _starNFTAddress, uint256 _nft_id) external onlyStarNFT(_starNFTAddress) view returns (\n        bool _allowStakeOut,\n        uint256 _allowBlock,\n        bool _requireBurn,\n        uint256 _earlyStakeOutFine,\n        uint256 _noFineBlock\n    ) {\n        (uint256 _createBlock, IERC20[] memory _stakeToken, , uint256 _cid) = _starNFTAddress.superInfo(_nft_id);\n        if (_stakeToken.length == 0) {\n            // no asset\n            return (false, 0, false, 0, 0);\n        }\n        _requireBurn = campaignStakeConfigs[_cid].burnRequired;\n        //        uint256 lockBlockNum = campaignStakeConfigs[_cid].lockBlockNum;\n        if (block.number >= campaignStakeConfigs[_cid].lockBlockNum.add(_createBlock)) {\n            return (true, 0, _requireBurn, 0, 0);\n        }\n        _allowBlock = campaignStakeConfigs[_cid].lockBlockNum + _createBlock;\n        if (!campaignStakeConfigs[_cid].isEarlyStakeOutAllowed) {\n            // not allow early stakeout\n            return (false, _allowBlock, _requireBurn, 0, 0);\n        }\n        _allowStakeOut = true;\n        _allowBlock = _createBlock;\n        _noFineBlock = _createBlock + campaignStakeConfigs[_cid].lockBlockNum;\n        _earlyStakeOutFine = _noFineBlock\n        .sub(block.number)\n        .mul(10000)\n        .mul(campaignStakeConfigs[_cid].earlyStakeOutFine)\n        .div(campaignStakeConfigs[_cid].lockBlockNum)\n        .div(10000);\n    }\n\n    function isValidatedStarNFTAddress(IStarNFT _starNFT) external returns (bool) {\n        return _starNFTs[_starNFT];\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _setFees(\n        uint256 _cid,\n        Operation[] calldata _op,\n        uint256[] calldata _networkFee,\n        uint256[] calldata _erc20Fee,\n        address[] calldata _erc20\n    ) private {\n        require(_op.length > 0, \"Array(_op) should not be empty.\");\n        // Don't use validate arrays because empty arrays are valid\n        require(_op.length == _networkFee.length, \"Array(_networkFee) length mismatch\");\n        require(_op.length == _erc20Fee.length, \"Array(_erc20Fee) length mismatch\");\n        require(_op.length == _erc20.length, \"Array(_erc20) length mismatch\");\n\n        for (uint256 i = 0; i < _op.length; i++) {\n            require((_erc20[i] == address(0) && _erc20Fee[i] == 0) || (_erc20[i] != address(0) && _erc20Fee[i] != 0), \"Invalid erc20 fee requirement arguments\");\n            campaignFeeConfigs[_cid][_op[i]] = CampaignFeeConfig(_erc20[i], _erc20Fee[i], _networkFee[i], true);\n        }\n    }\n\n    function _setStake(\n        uint256 _cid,\n        address _erc20,\n        uint256 _minStakeAmount,\n        uint256 _maxStakeAmount,\n        uint256 _lockBlockNum,\n        bytes1 _params,\n        uint256 _earlyStakeOutFine\n    ) private {\n        campaignStakeConfigs[_cid] = CampaignStakeConfig(\n            _erc20,\n            _minStakeAmount,\n            _maxStakeAmount,\n            _lockBlockNum,\n            _params & bytes1(0x80) != 0,\n            _params & bytes1(0x40) != 0,\n            _earlyStakeOutFine\n        );\n    }\n\n    function _payFees(uint256 _cid, Operation _op) private {\n        require(campaignFeeConfigs[_cid][Operation.Default].isActive, \"Operation(DEFAULT) should be activated\");\n\n        // 0. which fee record to use\n        Operation op_key = campaignFeeConfigs[_cid][_op].isActive ? _op : Operation.Default;\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid][op_key];\n        // 1. pay network_fee if needed\n        require(msg.value >= feeConf.networkFee, \"Invalid msg.value sent for networkFee\");\n        galaxyTreasuryNetwork = galaxyTreasuryNetwork.add(msg.value);\n        // 2. pay erc20_fee if needed\n        if (feeConf.erc20Fee > 0) {\n            // user wallet transfer <erc20> of <feeConf.erc20Fee> to <this contract>.\n            require(IERC20(feeConf.erc20).transferFrom(msg.sender, address(this), feeConf.erc20Fee), \"Transfer erc20_fee failed\");\n            galaxyTreasuryERC20[feeConf.erc20] = galaxyTreasuryERC20[feeConf.erc20].add(feeConf.erc20Fee);\n        }\n    }\n\n    function _payFine(uint256 _cid, uint256 _mintBlock) private {\n        uint256 lockBlockNum = campaignStakeConfigs[_cid].lockBlockNum;\n        // 1.2 only need to check early-stake-out config if lock up time has not been met yet\n        if (block.number < _mintBlock + lockBlockNum) {\n            require(campaignStakeConfigs[_cid].isEarlyStakeOutAllowed, \"Early stake out not allowed\");\n            // calc fine if allow early stake out\n            uint256 _fine = (_mintBlock + lockBlockNum)\n            .sub(block.number)\n            .mul(10000)\n            .mul(campaignStakeConfigs[_cid].earlyStakeOutFine)\n            .div(lockBlockNum)\n            .div(10000);\n            // Fine will be adding to treasury with networkFee in _payFees() if applies.\n            require(msg.value >= campaignFeeConfigs[_cid][Operation.StakeOut].networkFee.add(_fine), \"Insufficient fine\");\n        }\n    }\n\n    function _stakeIn(uint256 _cid, uint256 stakeAmount) private {\n        // Stake in if needed\n        require(campaignStakeConfigs[_cid].erc20 != address(0), \"Stake campaign should be activated\");\n        require(stakeAmount >= campaignStakeConfigs[_cid].minStakeAmount, \"StakeAmount should >= minStakeAmount\");\n        require(stakeAmount <= campaignStakeConfigs[_cid].maxStakeAmount, \"StakeAmount should <= maxStakeAmount\");\n        // transfer <erc20> of <stakeAmount> to <this contract> from user wallet.\n        require(IERC20(campaignStakeConfigs[_cid].erc20).transferFrom(msg.sender, address(this), stakeAmount), \"Stake in erc20 failed\");\n\n    }\n\n    /**\n     * Due to reason error bloat, internal functions are used to reduce bytecode size\n     */\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, \"Only manager can call\");\n    }\n\n    function _validateOnlyTreasuryManager() internal view {\n        require(msg.sender == treasury_manager, \"Only treasury manager can call\");\n    }\n\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, \"Contract paused\");\n    }\n}\n","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"EventClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_nftIDs\",\"type\":\"uint256[]\"}],\"name\":\"EventForgeNoStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_nftIDs\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"}],\"name\":\"EventForgeWithStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"}],\"name\":\"EventStakeIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"}],\"name\":\"EventStakeOut\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"internalType\":\"enum SpaceStation.Operation[]\",\"name\":\"_op\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_networkFee\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_erc20Fee\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_erc20\",\"type\":\"address[]\"}],\"name\":\"activateCampaign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_stakeErc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockBlockNum\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"_params\",\"type\":\"bytes1\"},{\"internalType\":\"uint256\",\"name\":\"_earlyStakeOutFine\",\"type\":\"uint256\"},{\"internalType\":\"enum SpaceStation.Operation[]\",\"name\":\"_op\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_networkFee\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_erc20Fee\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_erc20\",\"type\":\"address[]\"}],\"name\":\"activateStakeCampaign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"}],\"name\":\"addValidatedStarNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"enum SpaceStation.Operation\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"campaignFeeConfigs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"erc20Fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"networkFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"campaignStakeConfigs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockBlockNum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"burnRequired\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEarlyStakeOutAllowed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"earlyStakeOutFine\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawQuasar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawSuper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"}],\"name\":\"erc20Withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"internalType\":\"enum SpaceStation.Operation[]\",\"name\":\"_op\",\"type\":\"uint8[]\"}],\"name\":\"expireCampaign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_nftIDs\",\"type\":\"uint256[]\"}],\"name\":\"forgeNoStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_nftIDs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"forgeStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"galaxyTreasuryERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"galaxyTreasuryNetwork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury_manager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"}],\"name\":\"isValidatedStarNFTAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"}],\"name\":\"removeValidatedStarNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"stakeIn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFTAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nft_id\",\"type\":\"uint256\"}],\"name\":\"stakeOutInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_allowStakeOut\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_allowBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_requireBurn\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_earlyStakeOutFine\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_noFineBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"}],\"name\":\"stakeOutQuasar\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"}],\"name\":\"stakeOutSuper\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFTAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nft_id\",\"type\":\"uint256\"}],\"name\":\"superStakeOutInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_allowStakeOut\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_allowBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_requireBurn\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_earlyStakeOutFine\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_noFineBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury_manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SpaceStation","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}