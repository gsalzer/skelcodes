{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error. This contract is based\r\n * on the source code at https://goo.gl/iyQsmU.\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _a Minuend number.\r\n   * @param _b Subtrahend number.\r\n   */\r\n  function sub(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, throws on overflow.\r\n   * @param _a Number.\r\n   * @param _b Number.\r\n   */\r\n  function add(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    uint256 c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\ninterface ERC20 {\r\n\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name);\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token.\r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol);\r\n\r\n  /**\r\n   * @dev Returns the number of decimals the token uses.\r\n   */\r\n  function decimals()\r\n    external\r\n    view\r\n    returns (uint8 _decimals);\r\n\r\n  /**\r\n   * @dev Returns the total token supply.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256 _totalSupply);\r\n\r\n  /**\r\n   * @dev Returns the account balance of another account with address _owner.\r\n   * @param _owner The address from which the balance will be retrieved.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 _balance);\r\n\r\n  /**\r\n   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\r\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\r\n   * @param _to The address of the recipient.\r\n   * @param _value The amount of token to be transferred.\r\n   */\r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    external\r\n    returns (bool _success);\r\n\r\n  /**\r\n   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\r\n   * Transfer event.\r\n   * @param _from The address of the sender.\r\n   * @param _to The address of the recipient.\r\n   * @param _value The amount of token to be transferred.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    external\r\n    returns (bool _success);\r\n\r\n  /**\r\n   * @dev Allows _spender to withdraw from your account multiple times, up to\r\n   * the _value amount. If this function is called again it overwrites the current\r\n   * allowance with _value.\r\n   * @param _spender The address of the account able to transfer the tokens.\r\n   * @param _value The amount of tokens to be approved for transfer.\r\n   */\r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    external\r\n    returns (bool _success);\r\n\r\n  /**\r\n   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\r\n   * @param _owner The address of the account owning tokens.\r\n   * @param _spender The address of the account able to transfer the tokens.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 _remaining);\r\n\r\n  /**\r\n   * @dev Triggers when tokens are transferred, including zero value transfers.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _value\r\n  );\r\n\r\n  /**\r\n   * @dev Triggers on any successful call to approve(address _spender, uint256 _value).\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _spender,\r\n    uint256 _value\r\n  );\r\n\r\n}\r\n\r\ncontract Token is\r\n  ERC20\r\n{\r\n  using SafeMath for uint256;\r\n\r\n  /*\r\n   * Token name.\r\n   */\r\n  string internal tokenName;\r\n\r\n  /*\r\n   * Token symbol.\r\n   */\r\n   \r\n  string internal tokenSymbol;\r\n\r\n  /*\r\n   * Number of decimals.\r\n   */\r\n  uint8 internal tokenDecimals;\r\n\r\n  /*\r\n   * Total supply of tokens.\r\n   */\r\n  uint256 internal tokenTotalSupply;\r\n\r\n  /*\r\n   * Balance information map.\r\n   */\r\n  mapping (address => uint256) internal balances;\r\n\r\n  /*\r\n   * Token allowance mapping.\r\n   */\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  /*\r\n   * dev Trigger when tokens are transferred, including zero value transfers.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _value\r\n  );\r\n\r\n  /*\r\n   * dev Trigger on any successful call to approve(address _spender, uint256 _value).\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _spender,\r\n    uint256 _value\r\n  );\r\n\r\n  /*\r\n   * dev Returns the name of the token.\r\n   */\r\n  function name()\r\n    public\r\n    view\r\n    override \r\n    returns (string memory _name)\r\n  {\r\n    _name = tokenName;\r\n  }\r\n\r\n  /*\r\n   * dev Returns the symbol of the token.\r\n   */\r\n  function symbol()\r\n    public\r\n    view\r\n    override \r\n    returns (string memory _symbol)\r\n  {\r\n    _symbol = tokenSymbol;\r\n  }\r\n\r\n  /*\r\n   * dev Returns the number of decimals the token uses.\r\n   */\r\n  function decimals()\r\n    public\r\n    view\r\n    override \r\n    returns (uint8 _decimals)\r\n  {\r\n    _decimals = tokenDecimals;\r\n  }\r\n\r\n  /*\r\n   * dev Returns the total token supply.\r\n   */\r\n  function totalSupply()\r\n    public\r\n    view\r\n    override \r\n    returns (uint256 _totalSupply)\r\n  {\r\n    _totalSupply = tokenTotalSupply;\r\n  }\r\n\r\n  /*\r\n   * dev Returns the account balance of another account with address _owner.\r\n   * param _owner The address from which the balance will be retrieved.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    public\r\n    view\r\n    override \r\n    returns (uint256 _balance)\r\n  {\r\n    _balance = balances[_owner];\r\n  }\r\n\r\n  /*\r\n   * dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\r\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\r\n   * param _to The address of the recipient.\r\n   * param _value The amount of token to be transferred.\r\n   */\r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    override \r\n    returns (bool _success)\r\n  {\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n\r\n    emit Transfer(msg.sender, _to, _value);\r\n    _success = true;\r\n  }\r\n\r\n  /*\r\n   * dev Allows _spender to withdraw from your account multiple times, up to the _value amount. If\r\n   * this function is called again it overwrites the current allowance with _value.\r\n   * param _spender The address of the account able to transfer the tokens.\r\n   * param _value The amount of tokens to be approved for transfer.\r\n   */\r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    public\r\n    override \r\n    returns (bool _success)\r\n  {\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n\r\n    emit Approval(msg.sender, _spender, _value);\r\n    _success = true;\r\n  }\r\n\r\n  /*\r\n   * dev Returns the amount which _spender is still allowed to withdraw from _owner.\r\n   * param _owner The address of the account owning tokens.\r\n   * param _spender The address of the account able to transfer the tokens.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n  )\r\n    external\r\n    view\r\n    override \r\n    returns (uint256 _remaining)\r\n  {\r\n    _remaining = allowed[_owner][_spender];\r\n  }\r\n\r\n  /*\r\n   * dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\r\n   * Transfer event.\r\n   * param _from The address of the sender.\r\n   * param _to The address of the recipient.\r\n   * param _value The amount of token to be transferred.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    override \r\n    returns (bool _success)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n    emit Transfer(_from, _to, _value);\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\ncontract DATBOI is Token {\r\n\r\n  uint256 public buyPrice = 10000000;\r\n  address payable public owner;\r\n  uint256 public datboiSupply = 100000000000;\r\n  \r\n  constructor()\r\n    payable public\r\n  {\r\n    tokenName = \"DatBoi\";\r\n    tokenSymbol = \"DATBOI\";\r\n    tokenDecimals = 18;\r\n    // 18 decimals is the strongly suggested default\r\n    tokenTotalSupply = datboiSupply * 10 ** uint256(tokenDecimals);\r\n    balances[msg.sender] = tokenTotalSupply; // Give the owner of the contract the whole balance\r\n    owner = msg.sender;\r\n  }\r\n  \r\n    fallback() payable external {\r\n        \r\n        uint amount = msg.value * buyPrice;                    // calculates the amount, made it so you can get many BOIS but to get MANY BOIS you have to spend ETH and not WEI\r\n        uint amountRaised;                                     \r\n        amountRaised += msg.value;                            //many thanks bois, couldnt do it without all the bois\r\n        require(balances[owner] >= amount);               // checks if it has enough to sell\r\n        require(msg.value <  (1+ 10**18) );\r\n        balances[msg.sender] += amount;                  // adds the amount to buyer's balance\r\n        balances[owner] -= amount;                        // sends ETH to DatBoiCoinMint\r\n        Transfer(owner, msg.sender, amount);               // execute an event reflecting the change\r\n        owner.transfer(amountRaised);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"datboiSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DATBOI","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d6bf45b92d62b78b285585cc36b300d0f73d5649c4dd9722c8c2e9ea000f08d6"}]}