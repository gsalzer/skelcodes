{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/claims/Incidents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../../abstract/MasterAware.sol\\\";\\nimport \\\"../../interfaces/IClaimsData.sol\\\";\\nimport \\\"../../interfaces/IClaimsReward.sol\\\";\\nimport \\\"../../interfaces/IIncidents.sol\\\";\\nimport \\\"../../interfaces/IMCR.sol\\\";\\nimport \\\"../../interfaces/IMemberRoles.sol\\\";\\nimport \\\"../../interfaces/IPool.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../../interfaces/IQuotationData.sol\\\";\\nimport \\\"../../interfaces/ITokenController.sol\\\";\\n\\ncontract Incidents is IIncidents, MasterAware {\\n  using SafeERC20 for IERC20;\\n  using SafeMath for uint;\\n\\n  struct Incident {\\n    address productId;\\n    uint32 date;\\n    uint priceBefore;\\n  }\\n\\n  // contract identifiers\\n  enum ID {CD, CR, QD, TC, MR, P1, PS, MC}\\n\\n  mapping(uint => address payable) public internalContracts;\\n\\n  Incident[] public incidents;\\n\\n  // product id => underlying token (ex. yDAI -> DAI)\\n  mapping(address => address) public underlyingToken;\\n\\n  // product id => covered token (ex. 0xc7ed.....1 -> yDAI)\\n  mapping(address => address) public coveredToken;\\n\\n  // claim id => payout amount\\n  mapping(uint => uint) public claimPayout;\\n\\n  // product id => accumulated burn amount\\n  mapping(address => uint) public accumulatedBurn;\\n\\n  // burn ratio in bps, ex 2000 for 20%\\n  uint public BURN_RATIO;\\n\\n  // burn ratio in bps\\n  uint public DEDUCTIBLE_RATIO;\\n\\n  uint constant BASIS_PRECISION = 10000;\\n\\n  event ProductAdded(\\n    address indexed productId,\\n    address indexed coveredToken,\\n    address indexed underlyingToken\\n  );\\n\\n  event IncidentAdded(\\n    address indexed productId,\\n    uint incidentDate,\\n    uint priceBefore\\n  );\\n\\n  modifier onlyAdvisoryBoard {\\n    uint abRole = uint(IMemberRoles.Role.AdvisoryBoard);\\n    require(\\n      memberRoles().checkRole(msg.sender, abRole),\\n      \\\"Incidents: Caller is not an advisory board member\\\"\\n    );\\n    _;\\n  }\\n\\n  function initialize() external {\\n    require(BURN_RATIO == 0, \\\"Already initialized\\\");\\n    BURN_RATIO = 2000;\\n    DEDUCTIBLE_RATIO = 9000;\\n  }\\n\\n  function addProducts(\\n    address[] calldata _productIds,\\n    address[] calldata _coveredTokens,\\n    address[] calldata _underlyingTokens\\n  ) external onlyAdvisoryBoard {\\n\\n    require(\\n      _productIds.length == _coveredTokens.length,\\n      \\\"Incidents: Protocols and covered tokens lengths differ\\\"\\n    );\\n\\n    require(\\n      _productIds.length == _underlyingTokens.length,\\n      \\\"Incidents: Protocols and underyling tokens lengths differ\\\"\\n    );\\n\\n    for (uint i = 0; i < _productIds.length; i++) {\\n      address id = _productIds[i];\\n\\n      require(coveredToken[id] == address(0), \\\"Incidents: covered token is already set\\\");\\n      require(underlyingToken[id] == address(0), \\\"Incidents: underlying token is already set\\\");\\n\\n      coveredToken[id] = _coveredTokens[i];\\n      underlyingToken[id] = _underlyingTokens[i];\\n      emit ProductAdded(id, _coveredTokens[i], _underlyingTokens[i]);\\n    }\\n  }\\n\\n  function incidentCount() external view returns (uint) {\\n    return incidents.length;\\n  }\\n\\n  function addIncident(\\n    address productId,\\n    uint incidentDate,\\n    uint priceBefore\\n  ) external onlyGovernance {\\n    address underlying = underlyingToken[productId];\\n    require(underlying != address(0), \\\"Incidents: Unsupported product\\\");\\n\\n    Incident memory incident = Incident(productId, uint32(incidentDate), priceBefore);\\n    incidents.push(incident);\\n\\n    emit IncidentAdded(productId, incidentDate, priceBefore);\\n  }\\n\\n  function redeemPayoutForMember(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount,\\n    address member\\n  ) external onlyInternal returns (uint claimId, uint payoutAmount, address payoutToken) {\\n    (claimId, payoutAmount, payoutToken) = _redeemPayout(coverId, incidentId, coveredTokenAmount, member);\\n  }\\n\\n  function redeemPayout(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount\\n  ) external returns (uint claimId, uint payoutAmount, address payoutToken) {\\n    (claimId, payoutAmount, payoutToken) = _redeemPayout(coverId, incidentId, coveredTokenAmount, msg.sender);\\n  }\\n\\n  function _redeemPayout(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount,\\n    address coverOwner\\n  ) internal returns (uint claimId, uint payoutAmount, address coverAsset) {\\n    IQuotationData qd = quotationData();\\n    Incident memory incident = incidents[incidentId];\\n    uint sumAssured;\\n    bytes4 currency;\\n\\n    {\\n      address productId;\\n      address _coverOwner;\\n\\n      (/* id */, _coverOwner, productId,\\n       currency, sumAssured, /* premiumNXM */\\n      ) = qd.getCoverDetailsByCoverID1(coverId);\\n\\n      // check ownership and covered protocol\\n      require(coverOwner == _coverOwner, \\\"Incidents: Not cover owner\\\");\\n      require(productId == incident.productId, \\\"Incidents: Bad incident id\\\");\\n    }\\n\\n    {\\n      uint coverPeriod = uint(qd.getCoverPeriod(coverId)).mul(1 days);\\n      uint coverExpirationDate = qd.getValidityOfCover(coverId);\\n      uint coverStartDate = coverExpirationDate.sub(coverPeriod);\\n\\n      // check cover validity\\n      require(coverStartDate <= incident.date, \\\"Incidents: Cover start date is after the incident\\\");\\n      require(coverExpirationDate >= incident.date, \\\"Incidents: Cover end date is before the incident\\\");\\n\\n      // check grace period\\n      uint gracePeriod = tokenController().claimSubmissionGracePeriod();\\n      require(coverExpirationDate.add(gracePeriod) >= block.timestamp, \\\"Incidents: Grace period has expired\\\");\\n    }\\n\\n    {\\n      // assumes 18 decimals (eth & dai)\\n      uint decimalPrecision = 1e18;\\n      uint maxAmount;\\n\\n      // sumAssured is currently stored without decimals\\n      uint coverAmount = sumAssured.mul(decimalPrecision);\\n\\n      {\\n        // max amount check\\n        uint deductiblePriceBefore = incident.priceBefore.mul(DEDUCTIBLE_RATIO).div(BASIS_PRECISION);\\n        maxAmount = coverAmount.mul(decimalPrecision).div(deductiblePriceBefore);\\n        require(coveredTokenAmount <= maxAmount, \\\"Incidents: Amount exceeds sum assured\\\");\\n      }\\n\\n      // payoutAmount = coveredTokenAmount / maxAmount * coverAmount\\n      //              = coveredTokenAmount * coverAmount / maxAmount\\n      payoutAmount = coveredTokenAmount.mul(coverAmount).div(maxAmount);\\n    }\\n\\n    {\\n      ITokenController tc = tokenController();\\n      // mark cover as having a successful claim\\n      tc.markCoverClaimOpen(coverId);\\n      tc.markCoverClaimClosed(coverId, true);\\n\\n      // create the claim\\n      IClaimsData cd = claimsData();\\n      claimId = cd.actualClaimLength();\\n      cd.addClaim(claimId, coverId, coverOwner, now);\\n      cd.callClaimEvent(coverId, coverOwner, claimId, now);\\n      cd.setClaimStatus(claimId, 14);\\n      qd.changeCoverStatusNo(coverId, uint8(IQuotationData.CoverStatus.ClaimAccepted));\\n\\n      claimPayout[claimId] = payoutAmount;\\n    }\\n\\n    coverAsset = claimsReward().getCurrencyAssetAddress(currency);\\n\\n    _sendPayoutAndPushBurn(\\n      incident.productId,\\n      address(uint160(coverOwner)),\\n      coveredTokenAmount,\\n      coverAsset,\\n      payoutAmount\\n    );\\n\\n    qd.subFromTotalSumAssured(currency, sumAssured);\\n    qd.subFromTotalSumAssuredSC(incident.productId, currency, sumAssured);\\n\\n    mcr().updateMCRInternal(pool().getPoolValueInEth(), true);\\n\\n    claimsReward().unlockCoverNote(coverId);\\n  }\\n\\n  function pushBurns(address productId, uint maxIterations) external {\\n\\n    uint burnAmount = accumulatedBurn[productId];\\n    delete accumulatedBurn[productId];\\n\\n    require(burnAmount > 0, \\\"Incidents: No burns to push\\\");\\n    require(maxIterations >= 30, \\\"Incidents: Pass at least 30 iterations\\\");\\n\\n    IPooledStaking ps = pooledStaking();\\n    ps.pushBurn(productId, burnAmount);\\n    ps.processPendingActions(maxIterations);\\n  }\\n\\n  function withdrawAsset(address asset, address destination, uint amount) external onlyGovernance {\\n    IERC20 token = IERC20(asset);\\n    uint balance = token.balanceOf(address(this));\\n    uint transferAmount = amount > balance ? balance : amount;\\n    token.safeTransfer(destination, transferAmount);\\n  }\\n\\n  function _sendPayoutAndPushBurn(\\n    address productId,\\n    address payable coverOwner,\\n    uint coveredTokenAmount,\\n    address coverAsset,\\n    uint payoutAmount\\n  ) internal {\\n\\n    address _coveredToken = coveredToken[productId];\\n\\n    // pull depegged tokens\\n    IERC20(_coveredToken).safeTransferFrom(msg.sender, address(this), coveredTokenAmount);\\n\\n    IPool p1 = pool();\\n\\n    // send the payoutAmount\\n    {\\n      address payable payoutAddress = memberRoles().getClaimPayoutAddress(coverOwner);\\n      bool success = p1.sendClaimPayout(coverAsset, payoutAddress, payoutAmount);\\n      require(success, \\\"Incidents: Payout failed\\\");\\n    }\\n\\n    {\\n      // burn\\n      uint decimalPrecision = 1e18;\\n      uint assetPerNxm = p1.getTokenPrice(coverAsset);\\n      uint maxBurnAmount = payoutAmount.mul(decimalPrecision).div(assetPerNxm);\\n      uint burnAmount = maxBurnAmount.mul(BURN_RATIO).div(BASIS_PRECISION);\\n\\n      accumulatedBurn[productId] = accumulatedBurn[productId].add(burnAmount);\\n    }\\n  }\\n\\n  function claimsData() internal view returns (IClaimsData) {\\n    return IClaimsData(internalContracts[uint(ID.CD)]);\\n  }\\n\\n  function claimsReward() internal view returns (IClaimsReward) {\\n    return IClaimsReward(internalContracts[uint(ID.CR)]);\\n  }\\n\\n  function quotationData() internal view returns (IQuotationData) {\\n    return IQuotationData(internalContracts[uint(ID.QD)]);\\n  }\\n\\n  function tokenController() internal view returns (ITokenController) {\\n    return ITokenController(internalContracts[uint(ID.TC)]);\\n  }\\n\\n  function memberRoles() internal view returns (IMemberRoles) {\\n    return IMemberRoles(internalContracts[uint(ID.MR)]);\\n  }\\n\\n  function pool() internal view returns (IPool) {\\n    return IPool(internalContracts[uint(ID.P1)]);\\n  }\\n\\n  function pooledStaking() internal view returns (IPooledStaking) {\\n    return IPooledStaking(internalContracts[uint(ID.PS)]);\\n  }\\n\\n  function mcr() internal view returns (IMCR) {\\n    return IMCR(internalContracts[uint(ID.MC)]);\\n  }\\n\\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\\n\\n    if (code == \\\"BURNRATE\\\") {\\n      require(value <= BASIS_PRECISION, \\\"Incidents: Burn ratio cannot exceed 10000\\\");\\n      BURN_RATIO = value;\\n      return;\\n    }\\n\\n    if (code == \\\"DEDUCTIB\\\") {\\n      require(value <= BASIS_PRECISION, \\\"Incidents: Deductible ratio cannot exceed 10000\\\");\\n      DEDUCTIBLE_RATIO = value;\\n      return;\\n    }\\n\\n    revert(\\\"Incidents: Invalid parameter\\\");\\n  }\\n\\n  function changeDependentContractAddress() external {\\n    INXMMaster master = INXMMaster(master);\\n    internalContracts[uint(ID.CD)] = master.getLatestAddress(\\\"CD\\\");\\n    internalContracts[uint(ID.CR)] = master.getLatestAddress(\\\"CR\\\");\\n    internalContracts[uint(ID.QD)] = master.getLatestAddress(\\\"QD\\\");\\n    internalContracts[uint(ID.TC)] = master.getLatestAddress(\\\"TC\\\");\\n    internalContracts[uint(ID.MR)] = master.getLatestAddress(\\\"MR\\\");\\n    internalContracts[uint(ID.P1)] = master.getLatestAddress(\\\"P1\\\");\\n    internalContracts[uint(ID.PS)] = master.getLatestAddress(\\\"PS\\\");\\n    internalContracts[uint(ID.MC)] = master.getLatestAddress(\\\"MC\\\");\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/MasterAware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../interfaces/INXMMaster.sol\\\";\\n\\ncontract MasterAware {\\n\\n  INXMMaster public master;\\n\\n  modifier onlyMember {\\n    require(master.isMember(msg.sender), \\\"Caller is not a member\\\");\\n    _;\\n  }\\n\\n  modifier onlyInternal {\\n    require(master.isInternal(msg.sender), \\\"Caller is not an internal contract\\\");\\n    _;\\n  }\\n\\n  modifier onlyMaster {\\n    if (address(master) != address(0)) {\\n      require(address(master) == msg.sender, \\\"Not master\\\");\\n    }\\n    _;\\n  }\\n\\n  modifier onlyGovernance {\\n    require(\\n      master.checkIsAuthToGoverned(msg.sender),\\n      \\\"Caller is not authorized to govern\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier whenPaused {\\n    require(master.isPause(), \\\"System is not paused\\\");\\n    _;\\n  }\\n\\n  modifier whenNotPaused {\\n    require(!master.isPause(), \\\"System is paused\\\");\\n    _;\\n  }\\n\\n  function changeDependentContractAddress() external;\\n\\n  function changeMasterAddress(address masterAddress) public onlyMaster {\\n    master = INXMMaster(masterAddress);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaimsData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaimsData {\\n\\n  function pendingClaimStart() external view returns (uint);\\n  function claimDepositTime() external view returns (uint);\\n  function maxVotingTime() external view returns (uint);\\n  function minVotingTime() external view returns (uint);\\n  function payoutRetryTime() external view returns (uint);\\n  function claimRewardPerc() external view returns (uint);\\n  function minVoteThreshold() external view returns (uint);\\n  function maxVoteThreshold() external view returns (uint);\\n  function majorityConsensus() external view returns (uint);\\n  function pauseDaysCA() external view returns (uint);\\n\\n  function userClaimVotePausedOn(address) external view returns (uint);\\n\\n  function setpendingClaimStart(uint _start) external;\\n\\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external;\\n\\n  function setUserClaimVotePausedOn(address user) external;\\n\\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external;\\n\\n\\n  function setClaimRewardDetail(\\n    uint claimid,\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  ) external;\\n\\n  function setRewardClaimed(uint _voteid, bool claimed) external;\\n\\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external;\\n\\n  function addClaim(\\n    uint _claimId,\\n    uint _coverId,\\n    address _from,\\n    uint _nowtime\\n  ) external;\\n\\n  function addVote(\\n    address _voter,\\n    uint _tokens,\\n    uint claimId,\\n    int8 _verdict\\n  ) external;\\n\\n  function addClaimVoteCA(uint _claimId, uint _voteid) external;\\n\\n  function setUserClaimVoteCA(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  ) external;\\n\\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external;\\n\\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external;\\n\\n  function addClaimVotemember(uint _claimId, uint _voteid) external;\\n\\n  function setUserClaimVoteMember(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  ) external;\\n\\n  function updateState12Count(uint _claimId, uint _cnt) external;\\n\\n  function setClaimStatus(uint _claimId, uint _stat) external;\\n\\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external;\\n\\n  function setClaimAtEmergencyPause(\\n    uint _coverId,\\n    uint _dateUpd,\\n    bool _submit\\n  ) external;\\n\\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external;\\n\\n\\n  function setFirstClaimIndexToSubmitAfterEP(\\n    uint _firstClaimIndexToSubmit\\n  ) external;\\n\\n\\n  function setPendingClaimDetails(\\n    uint _claimId,\\n    uint _pendingTime,\\n    bool _voting\\n  ) external;\\n\\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external;\\n\\n  function setFirstClaimIndexToStartVotingAfterEP(\\n    uint _claimStartVotingFirstIndex\\n  ) external;\\n\\n  function callVoteEvent(\\n    address _userAddress,\\n    uint _claimId,\\n    bytes4 _typeOf,\\n    uint _tokens,\\n    uint _submitDate,\\n    int8 _verdict\\n  ) external;\\n\\n  function callClaimEvent(\\n    uint _coverId,\\n    address _userAddress,\\n    uint _claimId,\\n    uint _datesubmit\\n  ) external;\\n\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n\\n  function getClaimOfEmergencyPauseByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    uint dateUpd,\\n    bool submit\\n  );\\n\\n  function getAllClaimsByIndex(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  );\\n\\n  function getUserClaimVoteCA(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote);\\n\\n  function getUserClaimVoteMember(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote);\\n\\n  function getAllVoteLength() external view returns (uint voteCount);\\n\\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno);\\n\\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV);\\n\\n  function getClaimState12Count(uint _claimId) external view returns (uint num);\\n\\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd);\\n\\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr);\\n\\n\\n  function getClaimsTokenCA(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  );\\n\\n  function getClaimsTokenMV(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  );\\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt);\\n\\n  function getMemberClaimVotesToken(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint cnt);\\n\\n  function getVoteDetails(uint _voteid)\\n  external view\\n  returns (\\n    uint tokens,\\n    uint claimId,\\n    int8 verdict,\\n    bool rewardClaimed\\n  );\\n\\n  function getVoterVote(uint _voteid) external view returns (address voter);\\n\\n  function getClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  );\\n\\n  function getClaimVoteLength(\\n    uint _claimId,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint len);\\n\\n  function getVoteVerdict(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (int8 ver);\\n\\n  function getVoteToken(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint tok);\\n\\n  function getVoteVoter(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (address voter);\\n\\n  function getUserClaimCount(address _add) external view returns (uint len);\\n\\n  function getClaimLength() external view returns (uint len);\\n\\n  function actualClaimLength() external view returns (uint len);\\n\\n\\n  function getClaimFromNewStart(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverid,\\n    uint claimId,\\n    int8 voteCA,\\n    int8 voteMV,\\n    uint statusnumber\\n  );\\n\\n  function getUserClaimByIndex(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint status,\\n    uint coverid,\\n    uint claimId\\n  );\\n\\n  function getAllVotesForClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint[] memory ca,\\n    uint[] memory mv\\n  );\\n\\n\\n  function getTokensClaim(\\n    address _of,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint tokens\\n  );\\n\\n  function getRewardDistributedIndex(\\n    address _voter\\n  )\\n  external\\n  view\\n  returns (\\n    uint lastCAvoteIndex,\\n    uint lastMVvoteIndex\\n  );\\n\\n  function getClaimRewardDetail(\\n    uint claimid\\n  )\\n  external\\n  view\\n  returns (\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  );\\n\\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid);\\n\\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token);\\n\\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token);\\n\\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint);\\n\\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint);\\n\\n  function getVoteAddressCALength(address _voter) external view returns (uint);\\n\\n  function getVoteAddressMemberLength(address _voter) external view returns (uint);\\n\\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict);\\n\\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len);\\n\\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit);\\n\\n  function getLengthOfClaimVotingPause() external view returns (uint len);\\n\\n  function getPendingClaimDetailsByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint pendingTime,\\n    bool voting\\n  );\\n\\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaimsReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaimsReward {\\n\\n  /// @dev Decides the next course of action for a given claim.\\n  function changeClaimStatus(uint claimid) external;\\n\\n  function getCurrencyAssetAddress(bytes4 currency) external view returns (address);\\n\\n  function getRewardToBeGiven(\\n    uint check,\\n    uint voteid,\\n    uint flag\\n  )\\n  external\\n  view\\n  returns (\\n    uint tokenCalculated,\\n    bool lastClaimedCheck,\\n    uint tokens,\\n    uint perc\\n  );\\n\\n  function upgrade(address _newAdd) external;\\n\\n  function getRewardToBeDistributedByUser(address _add) external view returns (uint total);\\n\\n  function getRewardAndClaimedStatus(uint check, uint claimId) external view returns (uint reward, bool claimed);\\n\\n  function claimAllPendingReward(uint records) external;\\n\\n  function getAllPendingRewardOfUser(address _add) external view returns (uint);\\n\\n  function unlockCoverNote(uint coverId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIncidents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IIncidents {\\n\\n  function underlyingToken(address) external view returns (address);\\n\\n  function coveredToken(address) external view returns (address);\\n\\n  function claimPayout(uint) external view returns (uint);\\n\\n  function incidentCount() external view returns (uint);\\n\\n  function addIncident(\\n    address productId,\\n    uint incidentDate,\\n    uint priceBefore\\n  ) external;\\n\\n  function redeemPayoutForMember(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount,\\n    address member\\n  ) external returns (uint claimId, uint payoutAmount, address payoutToken);\\n\\n  function redeemPayout(\\n    uint coverId,\\n    uint incidentId,\\n    uint coveredTokenAmount\\n  ) external returns (uint claimId, uint payoutAmount, address payoutToken);\\n\\n  function pushBurns(address productId, uint maxIterations) external;\\n\\n  function withdrawAsset(address asset, address destination, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMCR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IMCR {\\n\\n  function updateMCRInternal(uint poolValueInEth, bool forceUpdate) external;\\n  function getMCR() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMemberRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IMemberRoles {\\n\\n  enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\\n\\n  function payJoiningFee(address _userAddress) external payable;\\n\\n  function switchMembership(address _newAddress) external;\\n\\n  function switchMembershipOf(address member, address _newAddress) external;\\n\\n  function swapOwner(address _newOwnerAddress) external;\\n\\n  function kycVerdict(address payable _userAddress, bool verdict) external;\\n\\n  function getClaimPayoutAddress(address payable _member) external view returns (address payable);\\n\\n  function setClaimPayoutAddress(address payable _address) external;\\n\\n  function totalRoles() external view returns (uint256);\\n\\n  function changeAuthorized(uint _roleId, address _newAuthorized) external;\\n\\n  function members(uint _memberRoleId) external view returns (uint, address[] memory memberArray);\\n\\n  function numberOfMembers(uint _memberRoleId) external view returns (uint);\\n\\n  function authorized(uint _memberRoleId) external view returns (address);\\n\\n  function roles(address _memberAddress) external view returns (uint[] memory);\\n\\n  function checkRole(address _memberAddress, uint _roleId) external view returns (bool);\\n\\n  function getMemberLengthForAllRoles() external view returns (uint[] memory totalMembers);\\n\\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool);\\n\\n  function membersLength(uint _memberRoleId) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./IPriceFeedOracle.sol\\\";\\n\\ninterface IPool {\\n  function sellNXM(uint tokenAmount, uint minEthOut) external;\\n\\n  function sellNXMTokens(uint tokenAmount) external returns (bool);\\n\\n  function minPoolEth() external returns (uint);\\n\\n  function transferAssetToSwapOperator(address asset, uint amount) external;\\n\\n  function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) external;\\n\\n  function getAssetDetails(address _asset) external view returns (\\n    uint112 min,\\n    uint112 max,\\n    uint32 lastAssetSwapTime,\\n    uint maxSlippageRatio\\n  );\\n\\n  function sendClaimPayout (\\n    address asset,\\n    address payable payoutAddress,\\n    uint amount\\n  ) external returns (bool success);\\n\\n  function transferAsset(\\n    address asset,\\n    address payable destination,\\n    uint amount\\n  ) external;\\n\\n  function upgradeCapitalPool(address payable newPoolAddress) external;\\n\\n  function priceFeedOracle() external view returns (IPriceFeedOracle);\\n\\n  function getPoolValueInEth() external view returns (uint);\\n\\n\\n  function transferAssetFrom(address asset, address from, uint amount) external;\\n\\n  function getEthForNXM(uint nxmAmount) external view returns (uint ethAmount);\\n\\n  function calculateEthForNXM(\\n    uint nxmAmount,\\n    uint currentTotalAssetValue,\\n    uint mcrEth\\n  ) external pure returns (uint);\\n\\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);\\n\\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) external pure returns (uint tokenPrice);\\n\\n  function getTokenPrice(address asset) external view returns (uint tokenPrice);\\n\\n  function getMCRRatio() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPooledStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IPooledStaking {\\n\\n  function accumulateReward(address contractAddress, uint amount) external;\\n\\n  function pushBurn(address contractAddress, uint amount) external;\\n\\n  function hasPendingActions() external view returns (bool);\\n\\n  function processPendingActions(uint maxIterations) external returns (bool finished);\\n\\n  function contractStake(address contractAddress) external view returns (uint);\\n\\n  function stakerReward(address staker) external view returns (uint);\\n\\n  function stakerDeposit(address staker) external view returns (uint);\\n\\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\\n\\n  function withdraw(uint amount) external;\\n\\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\\n\\n  function withdrawReward(address stakerAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQuotationData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IQuotationData {\\n\\n  function authQuoteEngine() external view returns (address);\\n  function stlp() external view returns (uint);\\n  function stl() external view returns (uint);\\n  function pm() external view returns (uint);\\n  function minDays() external view returns (uint);\\n  function tokensRetained() external view returns (uint);\\n  function kycAuthAddress() external view returns (address);\\n\\n  function refundEligible(address) external view returns (bool);\\n  function holdedCoverIDStatus(uint) external view returns (uint);\\n  function timestampRepeated(uint) external view returns (bool);\\n\\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\\n\\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function setTimestampRepeated(uint _timestamp) external;\\n\\n  /// @dev Creates a blank new cover.\\n  function addCover(\\n    uint16 _coverPeriod,\\n    uint _sumAssured,\\n    address payable _userAddress,\\n    bytes4 _currencyCode,\\n    address _scAddress,\\n    uint premium,\\n    uint premiumNXM\\n  ) external;\\n\\n\\n  function addHoldCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod\\n  ) external;\\n\\n  function setRefundEligible(address _add, bool status) external;\\n\\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external;\\n\\n  function setKycAuthAddress(address _add) external;\\n\\n  function changeAuthQuoteEngine(address _add) external;\\n\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n\\n  function getProductDetails()\\n  external\\n  view\\n  returns (\\n    uint _minDays,\\n    uint _pm,\\n    uint _stl,\\n    uint _stlp\\n  );\\n\\n  function getCoverLength() external view returns (uint len);\\n\\n  function getAuthQuoteEngine() external view returns (address _add);\\n\\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount);\\n\\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover);\\n\\n  function getUserCoverLength(address _add) external view returns (uint len);\\n\\n  function getCoverStatusNo(uint _cid) external view returns (uint8);\\n\\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp);\\n\\n  function getCoverSumAssured(uint _cid) external view returns (uint sa);\\n\\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr);\\n\\n  function getValidityOfCover(uint _cid) external view returns (uint date);\\n\\n  function getscAddressOfCover(uint _cid) external view returns (uint, address);\\n\\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add);\\n\\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM);\\n\\n  function getCoverDetailsByCoverID1(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    address _memberAddress,\\n    address _scAddress,\\n    bytes4 _currencyCode,\\n    uint _sumAssured,\\n    uint premiumNXM\\n  );\\n\\n  function getCoverDetailsByCoverID2(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    uint8 status,\\n    uint sumAssured,\\n    uint16 coverPeriod,\\n    uint validUntil\\n  );\\n\\n  function getHoldedCoverDetailsByID1(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint16 coverPeriod\\n  );\\n\\n  function getUserHoldedCoverLength(address _add) external view returns (uint);\\n\\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint);\\n\\n  function getHoldedCoverDetailsByID2(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address payable memberAddress,\\n    uint[] memory coverDetails\\n  );\\n\\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount);\\n\\n  function changeCoverStatusNo(uint _cid, uint8 _stat) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface ITokenController {\\n\\n  function coverInfo(uint id) external view returns (uint16 claimCount, bool hasOpenClaim, bool hasAcceptedClaim);\\n\\n  function claimSubmissionGracePeriod() external view returns (uint);\\n\\n  function withdrawCoverNote(\\n    address _of,\\n    uint[] calldata _coverIds,\\n    uint[] calldata _indexes\\n  ) external;\\n\\n  function markCoverClaimOpen(uint coverId) external;\\n\\n  function markCoverClaimClosed(uint coverId, bool isAccepted) external;\\n\\n  function changeOperator(address _newOperator) external;\\n\\n  function operatorTransfer(address _from, address _to, uint _value) external returns (bool);\\n\\n  function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external;\\n\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time) external returns (bool);\\n\\n  function mintCoverNote(\\n    address _of,\\n    bytes32 _reason,\\n    uint256 _amount,\\n    uint256 _time\\n  ) external;\\n\\n  function extendClaimAssessmentLock(uint256 _time) external;\\n\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time) external returns (bool);\\n\\n  function increaseClaimAssessmentLock(uint256 _amount) external;\\n\\n  function burnFrom(address _of, uint amount) external returns (bool);\\n\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) external;\\n\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function addToWhitelist(address _member) external;\\n\\n  function removeFromWhitelist(address _member) external;\\n\\n  function mint(address _member, uint _amount) external;\\n\\n  function lockForMemberVote(address _of, uint _days) external;\\n  function withdrawClaimAssessmentTokens(address _of) external;\\n\\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons);\\n\\n  function getLockedTokensValidity(address _of, bytes32 reason) external view returns (uint256 validity);\\n\\n  function getUnlockableTokens(address _of) external view returns (uint256 unlockableTokens);\\n\\n  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\\n  external\\n  view\\n  returns (uint256 amount, uint256 validity);\\n\\n  function tokensUnlockable(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) external view returns (uint256 amount);\\n  function totalBalanceOf(address _of) external view returns (uint256 amount);\\n\\n  function totalLockedBalance(address _of) external view returns (uint256 amount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INXMMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface INXMMaster {\\n\\n  function tokenAddress() external view returns (address);\\n\\n  function owner() external view returns (address);\\n\\n  function pauseTime() external view returns (uint);\\n\\n  function masterInitialized() external view returns (bool);\\n\\n  function isInternal(address _add) external view returns (bool);\\n\\n  function isPause() external view returns (bool check);\\n\\n  function isOwner(address _add) external view returns (bool);\\n\\n  function isMember(address _add) external view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\\n\\n  function updatePauseTime(uint _time) external;\\n\\n  function dAppLocker() external view returns (address _add);\\n\\n  function dAppToken() external view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceFeedOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IPriceFeedOracle {\\n\\n  function daiAddress() external view returns (address);\\n  function stETH() external view returns (address);\\n  function ETH() external view returns (address);\\n\\n  function getAssetToEthRate(address asset) external view returns (uint);\\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint);\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"productId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incidentDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceBefore\",\"type\":\"uint256\"}],\"name\":\"IncidentAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"productId\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"coveredToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"}],\"name\":\"ProductAdded\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"BURN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEDUCTIBLE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accumulatedBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"productId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"incidentDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceBefore\",\"type\":\"uint256\"}],\"name\":\"addIncident\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_productIds\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_coveredTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_underlyingTokens\",\"type\":\"address[]\"}],\"name\":\"addProducts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"coveredToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"incidentCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"incidents\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"productId\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"date\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"priceBefore\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"internalContracts\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"productId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxIterations\",\"type\":\"uint256\"}],\"name\":\"pushBurns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incidentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coveredTokenAmount\",\"type\":\"uint256\"}],\"name\":\"redeemPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"payoutToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incidentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coveredTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"redeemPayoutForMember\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"payoutToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"code\",\"type\":\"bytes8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateUintParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Incidents","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}