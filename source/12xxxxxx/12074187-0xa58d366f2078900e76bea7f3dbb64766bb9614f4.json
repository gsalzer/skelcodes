{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.7.4;\r\n\r\n\r\ninterface ITrollbox {\r\n    function withdrawWinnings(uint voterId) external;\r\n    function updateAccount(uint voterId, uint tournamentId, uint roundId) external;\r\n    function isSynced(uint voterId, uint tournamentId, uint roundId) external view returns (bool);\r\n    function roundAlreadyResolved(uint tournamentId, uint roundId) external view returns (bool);\r\n    function resolveRound(uint tournamentId, uint roundId, uint winningOption) external;\r\n    function getCurrentRoundId(uint tournamentId) external view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface KeeperCompatibleInterface {\r\n\r\n  /**\r\n   * @notice method that is simulated by the keepers to see if any work actually\r\n   * needs to be performed. This method does does not actually need to be\r\n   * executable, and since it is only ever simulated it can consume lots of gas.\r\n   * @dev To ensure that it is never called, you may want to add the\r\n   * cannotExecute modifier from KeeperBase to your implementation of this\r\n   * method.\r\n   * @param checkData specified in the upkeep registration so it is always the\r\n   * same for a registered upkeep. This can easily be broken down into specific\r\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\r\n   * same contract and easily differentiated by the contract.\r\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\r\n   * performUpkeep or not.\r\n   * @return performData bytes that the keeper should call performUpkeep with, if\r\n   * upkeep is needed. If you would like to encode data to decode later, try\r\n   * `abi.encode`.\r\n   */\r\n  function checkUpkeep(\r\n    bytes calldata checkData\r\n  )\r\n    external\r\n    returns (\r\n      bool upkeepNeeded,\r\n      bytes memory performData\r\n    );\r\n  /**\r\n   * @notice method that is actually executed by the keepers, via the registry.\r\n   * The data returned by the checkUpkeep simulation will be passed into\r\n   * this method to actually be executed.\r\n   * @dev The input to this method should not be trusted, and the caller of the\r\n   * method should not even be restricted to any single registry. Anyone should\r\n   * be able call it, and the input should be validated, there is no guarantee\r\n   * that the data passed in is the performData returned from checkUpkeep. This\r\n   * could happen due to malicious keepers, racing keepers, or simply a state\r\n   * change while the performUpkeep transaction is waiting for confirmation.\r\n   * Always validate the data passed in.\r\n   * @param performData is the data which was passed back from the checkData\r\n   * simulation. If it is encoded, it can easily be decoded into other types by\r\n   * calling `abi.decode`. This data should not be trusted, and should be\r\n   * validated against the contract's current state.\r\n   */\r\n  function performUpkeep(\r\n    bytes calldata performData\r\n  ) external;\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\ncontract ChainLinkOracle2 is KeeperCompatibleInterface {\r\n\r\n    struct Proposal {\r\n        uint id;\r\n        uint time;\r\n        bool confirmed;\r\n        uint roundId;\r\n        uint winnerIndex;\r\n        uint challengeWinnerIndex;\r\n        address challenger;\r\n        bytes32 challengeEvidence;\r\n        bytes32 confirmationEvidence;\r\n    }\r\n\r\n    mapping (bytes32 => address) public feedMap; // ticker symbol => price aggregator address\r\n    mapping (bytes32 => int) public prices; // symbol => price\r\n    mapping (uint => Proposal) public proposals;\r\n\r\n    address public management;\r\n    ITrollbox public trollbox;\r\n    IERC20 public token;\r\n\r\n    int constant public PRECISION = 1000000;\r\n    uint public numProposals = 0;\r\n    uint public challengeDeposit = 0;\r\n    uint public challengePeriodSeconds = 60 * 60 * 24;\r\n    uint public tournamentId = 1;\r\n    uint public startingRoundId = 0;\r\n\r\n    bytes32[] public tickerSymbols;\r\n\r\n    // mgmt events\r\n    event FeedUpdated(bytes32 indexed key, address indexed feedAddr);\r\n    event ManagementUpdated(address oldManagement, address newManagement);\r\n    event DepositUpdated(uint oldDeposit, uint newDeposit);\r\n    event ChallengePeriodUpdated(uint oldPeriod, uint newPeriod);\r\n    event TickerSymbolsUpdated(bytes32[] oldKeys, bytes32[] newKeys, int[] newPrices);\r\n\r\n    // winner events\r\n    event WinnerProposed(uint indexed roundId, uint indexed proposalId, uint winnerIndex, int[] prices);\r\n    event WinnerConfirmed(uint indexed roundId, uint indexed proposalId, int[] prices);\r\n\r\n    // challenger events\r\n    event ChallengeMade(uint indexed proposalId, address indexed challenger, uint indexed claimedWinner, bytes32 evidence);\r\n    event ChallengerSlashed(uint indexed proposalId, address indexed challenger, uint indexed slashAmount, bytes32 evidence);\r\n    event ChallengerVindicated(uint indexed proposalId, address indexed challenger, bytes32 evidence);\r\n\r\n    modifier managementOnly() {\r\n        require (msg.sender == management, 'Only management may call this');\r\n        _;\r\n    }\r\n\r\n    modifier latestProposalConfirmed() {\r\n        require (proposals[numProposals].confirmed == true || numProposals == 0, 'Unconfirmed proposal present');\r\n        _;\r\n    }\r\n\r\n    constructor(address mgmt, address trollboxAddr, address tokenAddr, uint tournament, uint roundId, bytes32[] memory initialSymbols, int[] memory initialPrices) {\r\n        management = mgmt;\r\n        trollbox = ITrollbox(trollboxAddr);\r\n        token = IERC20(tokenAddr);\r\n        tournamentId = tournament;\r\n        startingRoundId = roundId;\r\n        tickerSymbols = initialSymbols;\r\n        setPricesInternal(initialPrices);\r\n    }\r\n\r\n    function setManagement(address newMgmt) public managementOnly {\r\n        address oldMgmt = management;\r\n        management = newMgmt;\r\n        emit ManagementUpdated(oldMgmt, newMgmt);\r\n    }\r\n\r\n    function setChallengeDeposit(uint newDeposit) public managementOnly latestProposalConfirmed {\r\n        uint oldDeposit = challengeDeposit;\r\n        challengeDeposit = newDeposit;\r\n        emit DepositUpdated(oldDeposit, newDeposit);\r\n    }\r\n\r\n    function setChallengePeriod(uint newPeriod) public managementOnly latestProposalConfirmed {\r\n        uint oldPeriod = challengePeriodSeconds;\r\n        challengePeriodSeconds = newPeriod;\r\n        emit ChallengePeriodUpdated(oldPeriod, newPeriod);\r\n    }\r\n\r\n    function setPricesInternal(int[] memory newPrices) internal {\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            prices[tickerSymbols[i]] = newPrices[i];\r\n        }\r\n    }\r\n\r\n    function getTickerSymbols() public view returns (bytes32[] memory) {\r\n        return tickerSymbols;\r\n    }\r\n\r\n    function getCurrentRoundId() public view returns (uint) {\r\n        if (numProposals == 0) {\r\n            return startingRoundId;\r\n        } else {\r\n            return proposals[numProposals].roundId;\r\n        }\r\n    }\r\n\r\n    function setTickerSymbols(bytes32[] memory newKeys, int[] memory newPrices) public managementOnly latestProposalConfirmed {\r\n        bytes32[] memory oldKeys = tickerSymbols;\r\n        tickerSymbols = newKeys;\r\n        setPricesInternal(newPrices);\r\n        // test that this function does not fail before setting\r\n        getWinner();\r\n        emit TickerSymbolsUpdated(oldKeys, newKeys, newPrices);\r\n    }\r\n\r\n    function addFeed(bytes32 key, address feedAddr) public managementOnly {\r\n        feedMap[key] = feedAddr;\r\n        emit FeedUpdated(key, feedAddr);\r\n    }\r\n\r\n    function getWinner() public view returns (int[] memory, uint) {\r\n        int256 maxPriceDiff = -100 * PRECISION;\r\n        uint winnerIndex = 0;\r\n        int[] memory pricesLocal = new int[](tickerSymbols.length);\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            bytes32 key = tickerSymbols[i];\r\n            int priceBefore = prices[key];\r\n            address feedAddr = feedMap[key];\r\n            require(feedAddr != address(0), 'Must set feed for all ticker symbols');\r\n            AggregatorV3Interface chainlink = AggregatorV3Interface(feedAddr);\r\n            (,int256 priceNow,,,) = chainlink.latestRoundData();\r\n            pricesLocal[i] = priceNow;\r\n            int256 priceDiff = ((priceNow - priceBefore) * PRECISION) / priceBefore;\r\n            if (priceDiff > maxPriceDiff) {\r\n                maxPriceDiff = priceDiff;\r\n                // add one to index to account for 1 based indexing on Trollbox contract\r\n                winnerIndex = i + 1;\r\n            }\r\n        }\r\n        return (pricesLocal, winnerIndex);\r\n    }\r\n\r\n    function proposeWinner() public latestProposalConfirmed {\r\n        uint roundId = getCurrentRoundId() + 1;\r\n        require(trollbox.roundAlreadyResolved(tournamentId, roundId) == false, 'Round already resolve');\r\n        require(trollbox.getCurrentRoundId(tournamentId) > roundId + 1, 'Round not ready to resolve');\r\n        Proposal storage proposal = proposals[++numProposals];\r\n        proposal.id = numProposals;\r\n        proposal.time = block.timestamp;\r\n        proposal.roundId = roundId;\r\n        (int[] memory newPrices, uint winnerIndex) = getWinner();\r\n        setPricesInternal(newPrices);\r\n        proposal.winnerIndex = winnerIndex;\r\n        emit WinnerProposed(roundId, numProposals, proposal.winnerIndex, newPrices);\r\n    }\r\n\r\n    function challengeWinner(uint claimedWinner, bytes32 evidence) public {\r\n        token.transferFrom(msg.sender, address(this), challengeDeposit);\r\n        Proposal storage proposal = proposals[numProposals];\r\n        require(proposal.challenger == address(0), 'Proposal already challenged');\r\n        require(claimedWinner != proposal.winnerIndex, 'Must claim different winner than proposed winner');\r\n        require(block.timestamp - proposal.time < challengePeriodSeconds, 'Challenge period has passed');\r\n        proposal.challenger = msg.sender;\r\n        proposal.challengeWinnerIndex = claimedWinner;\r\n        proposal.challengeEvidence = evidence;\r\n        emit ChallengeMade(numProposals, msg.sender, claimedWinner, evidence);\r\n    }\r\n\r\n    function confirmWinnerUnchallenged() public {\r\n        Proposal memory proposal = proposals[numProposals];\r\n        require(proposal.challenger == address(0), 'Proposal has been challenged');\r\n        require(block.timestamp - proposal.time > challengePeriodSeconds, 'Challenge period has not passed');\r\n        confirmWinnerInternal();\r\n    }\r\n\r\n    function confirmWinnerChallenged(uint chosenWinnerIndex, int[] memory localPrices, bytes32 evidence) public managementOnly {\r\n        Proposal storage proposal = proposals[numProposals];\r\n        require(proposal.challenger != address(0), 'Proposal has not been challenged');\r\n        require(chosenWinnerIndex <= tickerSymbols.length, 'Winner index out of range');\r\n        require(chosenWinnerIndex > 0, 'Winner index must be positive');\r\n        require(localPrices.length == tickerSymbols.length, 'Must specify prices for all ticker symbols');\r\n\r\n        // set official winner\r\n        proposal.winnerIndex = chosenWinnerIndex;\r\n        proposal.confirmationEvidence = evidence;\r\n\r\n        // record prices\r\n        setPricesInternal(localPrices);\r\n\r\n        confirmWinnerInternal();\r\n\r\n        // if challenger failed, slash their deposit\r\n        if (chosenWinnerIndex != proposal.challengeWinnerIndex) {\r\n            token.transfer(address(0), challengeDeposit);\r\n            emit ChallengerSlashed(numProposals, proposal.challenger, challengeDeposit, evidence);\r\n        // else send it back to them\r\n        } else {\r\n            token.transfer(proposal.challenger, challengeDeposit);\r\n            emit ChallengerVindicated(numProposals, proposal.challenger, evidence);\r\n        }\r\n    }\r\n\r\n    function confirmWinnerInternal() internal {\r\n        Proposal storage proposal = proposals[numProposals];\r\n        require(proposal.id == numProposals, 'Invalid proposalId');\r\n        require(proposal.confirmed == false, 'Already confirmed proposal');\r\n        proposal.confirmed = true;\r\n        int[] memory pricesLocal = new int[](tickerSymbols.length);\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            pricesLocal[i] = prices[tickerSymbols[i]];\r\n        }\r\n        emit WinnerConfirmed(proposal.roundId, proposal.id, pricesLocal);\r\n        trollbox.resolveRound(tournamentId, proposal.roundId, proposal.winnerIndex);\r\n    }\r\n\r\n    // K3PR functions\r\n    function checkUpkeep(bytes calldata checkData) external view override returns (bool, bytes memory) {\r\n        Proposal storage currentProposal = proposals[numProposals];\r\n        // if it's confirmed, we may need to propose a new one\r\n        if (currentProposal.confirmed || numProposals == 0) {\r\n            uint roundId = getCurrentRoundId() + 1;\r\n            bool roundAlreadyResolved = trollbox.roundAlreadyResolved(tournamentId, roundId);\r\n            bool roundResolvable = trollbox.getCurrentRoundId(tournamentId) > roundId + 1;\r\n            return (!roundAlreadyResolved && roundResolvable, abi.encode(false));\r\n        // otherwise if there is no challenger\r\n        } else {\r\n            bool unchallenged = currentProposal.challenger == address(0);\r\n            bool pastChallengePeriod = block.timestamp - currentProposal.time > challengePeriodSeconds;\r\n            return (unchallenged && pastChallengePeriod, abi.encode(true));\r\n        }\r\n    }\r\n\r\n    function performUpkeep(bytes calldata performData) external override {\r\n        bool confirm = abi.decode(performData, (bool));\r\n        // confirm\r\n        if (confirm) {\r\n            confirmWinnerUnchallenged();\r\n        // propose\r\n        } else {\r\n            proposeWinner();\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trollboxAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tournament\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"initialSymbols\",\"type\":\"bytes32[]\"},{\"internalType\":\"int256[]\",\"name\":\"initialPrices\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"claimedWinner\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"evidence\",\"type\":\"bytes32\"}],\"name\":\"ChallengeMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"ChallengePeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"slashAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"evidence\",\"type\":\"bytes32\"}],\"name\":\"ChallengerSlashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"evidence\",\"type\":\"bytes32\"}],\"name\":\"ChallengerVindicated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"DepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feedAddr\",\"type\":\"address\"}],\"name\":\"FeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManagement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManagement\",\"type\":\"address\"}],\"name\":\"ManagementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"oldKeys\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"newKeys\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"newPrices\",\"type\":\"int256[]\"}],\"name\":\"TickerSymbolsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"prices\",\"type\":\"int256[]\"}],\"name\":\"WinnerConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winnerIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"prices\",\"type\":\"int256[]\"}],\"name\":\"WinnerProposed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"feedAddr\",\"type\":\"address\"}],\"name\":\"addFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengePeriodSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedWinner\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"evidence\",\"type\":\"bytes32\"}],\"name\":\"challengeWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chosenWinnerIndex\",\"type\":\"uint256\"},{\"internalType\":\"int256[]\",\"name\":\"localPrices\",\"type\":\"int256[]\"},{\"internalType\":\"bytes32\",\"name\":\"evidence\",\"type\":\"bytes32\"}],\"name\":\"confirmWinnerChallenged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmWinnerUnchallenged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"feedMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentRoundId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTickerSymbols\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWinner\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winnerIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengeWinnerIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"challengeEvidence\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"confirmationEvidence\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposeWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"setChallengeDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"setChallengePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"newKeys\",\"type\":\"bytes32[]\"},{\"internalType\":\"int256[]\",\"name\":\"newPrices\",\"type\":\"int256[]\"}],\"name\":\"setTickerSymbols\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingRoundId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tickerSymbols\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tournamentId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trollbox\",\"outputs\":[{\"internalType\":\"contract ITrollbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ChainLinkOracle2","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b000000000000000000000000ea6556e350cd0c61452a26ab34e69ebf6f1808ba00000000000000000000000045080a6531d671ddff20db42f93792a489685e320000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000000a4c494e4b0000000000000000000000000000000000000000000000000000000057425443000000000000000000000000000000000000000000000000000000004441490000000000000000000000000000000000000000000000000000000000554e4900000000000000000000000000000000000000000000000000000000004d4b520000000000000000000000000000000000000000000000000000000000434f4d5000000000000000000000000000000000000000000000000000000000554d4100000000000000000000000000000000000000000000000000000000005946490000000000000000000000000000000000000000000000000000000000534e58000000000000000000000000000000000000000000000000000000000052454e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000aab64b5f000000000000000000000000000000000000000000000000000005615c9654090000000000000000000000000000000000000000000000000000000005f767a000000000000000000000000000000000000000000000000000000000b8ea8e4b000000000000000000000000000000000000000299560dbcda18b349173080000000000000000000000000000000000000000000000000000000000a4ce553d0000000000000000000000000000000000000000007cc0f0b730f358b63c8c000000000000000000000000000000000000000000000000000000003437962457700000000000000000000000000000000000000000000000000000000748225390000000000000000000000000000000000000000000000000000000006a74e17","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1c9f85e3aab1e4b293ad3961628319593dc10c65c440273ec1a9cce734bff71e"}]}