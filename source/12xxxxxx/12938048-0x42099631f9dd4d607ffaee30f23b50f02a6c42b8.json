{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/0xerc1155/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\ninterface IERC1155 {\\n  /****************************************|\\n  |                 Events                 |\\n  |_______________________________________*/\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferSingle(\\n    address indexed _operator,\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 _id,\\n    uint256 _amount\\n  );\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferBatch(\\n    address indexed _operator,\\n    address indexed _from,\\n    address indexed _to,\\n    uint256[] _ids,\\n    uint256[] _amounts\\n  );\\n\\n  /**\\n   * @dev MUST emit when an approval is updated\\n   */\\n  event ApprovalForAll(\\n    address indexed _owner,\\n    address indexed _operator,\\n    bool _approved\\n  );\\n\\n  /****************************************|\\n  |                Functions               |\\n  |_______________________________________*/\\n\\n  /**\\n   * @notice Transfers amount of an _id from the _from address to the _to address specified\\n   * @dev MUST emit TransferSingle event on success\\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   * @param _from    Source address\\n   * @param _to      Target address\\n   * @param _id      ID of the token type\\n   * @param _amount  Transfered amount\\n   * @param _data    Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _id,\\n    uint256 _amount,\\n    bytes calldata _data\\n  ) external;\\n\\n  /**\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n   * @dev MUST emit TransferBatch event on success\\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if length of `_ids` is not the same as length of `_amounts`\\n   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\n   * @param _from     Source addresses\\n   * @param _to       Target addresses\\n   * @param _ids      IDs of each token type\\n   * @param _amounts  Transfer amounts per token type\\n   * @param _data     Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeBatchTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256[] calldata _ids,\\n    uint256[] calldata _amounts,\\n    bytes calldata _data\\n  ) external;\\n\\n  /**\\n   * @notice Get the balance of an account's Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return        The _owner's balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller's tokens\\n   * @dev MUST emit the ApprovalForAll event on success\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return isOperator True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator)\\n    external\\n    view\\n    returns (bool isOperator);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev ERC-1155 interface for accepting safe transfers.\\n */\\ninterface IERC1155TokenReceiver {\\n  /**\\n   * @notice Handle the receipt of a single ERC1155 token type\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value MUST result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _id        The id of the token being transferred\\n   * @param _amount    The amount of tokens being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   */\\n  function onERC1155Received(\\n    address _operator,\\n    address _from,\\n    uint256 _id,\\n    uint256 _amount,\\n    bytes calldata _data\\n  ) external returns (bytes4);\\n\\n  /**\\n   * @notice Handle the receipt of multiple ERC1155 token types\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value WILL result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _ids       An array containing ids of each token being transferred\\n   * @param _amounts   An array containing amounts of each token being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   */\\n  function onERC1155BatchReceived(\\n    address _operator,\\n    address _from,\\n    uint256[] calldata _ids,\\n    uint256[] calldata _amounts,\\n    bytes calldata _data\\n  ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/tokens/ERC1155/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport '../../interfaces/IERC1155TokenReceiver.sol';\\nimport '../../utils/ERC165.sol';\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC165, IERC1155TokenReceiver {\\n  function onERC1155Received(\\n    address,\\n    address,\\n    uint256,\\n    uint256,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC1155Received.selector;\\n  }\\n\\n  function onERC1155BatchReceived(\\n    address,\\n    address,\\n    uint256[] memory,\\n    uint256[] memory,\\n    bytes memory\\n  ) public virtual override returns (bytes4) {\\n    return this.onERC1155BatchReceived.selector;\\n  }\\n\\n  function supportsInterface(bytes4 _interfaceID)\\n    public\\n    pure\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    if (_interfaceID == type(IERC1155TokenReceiver).interfaceId) {\\n      return true;\\n    }\\n    return super.supportsInterface(_interfaceID);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT AND Apache-2.0\\npragma solidity 0.7.6;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n  // Default hash for EOA accounts returned by extcodehash\\n  bytes32 internal constant ACCOUNT_HASH =\\n    0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract.\\n   * @param _address address of the account to check\\n   * @return Whether the target address is a contract\\n   */\\n  function isContract(address _address) internal view returns (bool) {\\n    bytes32 codehash;\\n\\n    // Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address or if it has a non-zero code hash or account hash\\n    assembly {\\n      codehash := extcodehash(_address)\\n    }\\n    return (codehash != 0x0 && codehash != ACCOUNT_HASH);\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.call(data);\\n\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0xerc1155/utils/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\nabstract contract ERC165 {\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID`\\n   */\\n  function supportsInterface(bytes4 _interfaceID)\\n    public\\n    pure\\n    virtual\\n    returns (bool)\\n  {\\n    return _interfaceID == this.supportsInterface.selector;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/src/cfolio/CFolioItemBridge.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nimport '../../0xerc1155/interfaces/IERC1155.sol';\\nimport '../../0xerc1155/tokens/ERC1155/ERC1155Holder.sol';\\nimport '../../0xerc1155/utils/Address.sol';\\n\\nimport '../token/interfaces/IWOWSCryptofolio.sol';\\nimport '../token/interfaces/IWOWSERC1155.sol';\\nimport '../utils/AddressBook.sol';\\nimport '../utils/interfaces/IAddressRegistry.sol';\\nimport '../utils/TokenIds.sol';\\n\\nimport './interfaces/ICFolioItemBridge.sol';\\nimport './interfaces/ICFolioItemHandler.sol';\\n\\n/**\\n * @dev Minimalistic ERC1155 Holder for use only with WOWSCryptofolio\\n *\\n * This contract receives CFIs from the sftHolder contract for a\\n * CFolio and performs all required Handle actions.\\n */\\ncontract CFolioItemBridge is ICFolioItemBridge, ERC1155Holder {\\n  using TokenIds for uint256;\\n  using Address for address;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Routing\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  // SFT contract\\n  IAddressRegistry private immutable _addressRegistry;\\n\\n  // SFT contract\\n  IWOWSERC1155 private immutable _sftHolder;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Constants\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  bytes4 internal constant ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  // Our balances\\n  mapping(uint256 => address) private _owners;\\n\\n  // Operator Functions\\n  mapping(address => mapping(address => bool)) private _operators;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Events\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  event BridgeTransfer(\\n    address indexed _operator,\\n    address indexed _from,\\n    address indexed _to,\\n    uint256[] _ids,\\n    uint256[] _amounts\\n  );\\n\\n  /**\\n   * @dev MUST emit when an approval is updated\\n   */\\n  event BridgeApproval(\\n    address indexed _owner,\\n    address indexed _operator,\\n    bool _approved\\n  );\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Initialization\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Construct the contract\\n   *\\n   * @param addressRegistry Registry containing our system addresses\\n   *\\n   */\\n  constructor(IAddressRegistry addressRegistry) {\\n    _addressRegistry = addressRegistry;\\n\\n    // The SFTHolder contract\\n    _sftHolder = IWOWSERC1155(\\n      addressRegistry.getRegistryEntry(AddressBook.SFT_HOLDER)\\n    );\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Implementation of minimal IERC1155\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev See {ICFolioItemBridge-safeBatchTransferFrom}\\n   */\\n  function safeBatchTransferFrom(\\n    address from,\\n    address to,\\n    uint256[] memory tokenIds,\\n    uint256[] memory amounts,\\n    bytes memory\\n  ) external override {\\n    // Validate parameters\\n    require(\\n      (msg.sender == from) || isApprovedForAll(from, msg.sender),\\n      'CFIB: Not approved'\\n    );\\n    require(to != address(0), 'CFIB: Invalid recipient');\\n    require(tokenIds.length == amounts.length, 'CFIB: Length mismatch');\\n\\n    // Transfer\\n    uint256 length = tokenIds.length;\\n    for (uint256 i = 0; i < length; ++i) {\\n      require(_owners[tokenIds[i]] == from, 'CFIB: Not owner');\\n      _owners[tokenIds[i]] = to;\\n    }\\n    _onTransfer(address(this), from, to, tokenIds, amounts);\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemBridge-burnBatch}\\n   */\\n  function burnBatch(\\n    address from,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata amounts\\n  ) external override {\\n    // Validate parameters\\n    require(\\n      from == msg.sender || isApprovedForAll(from, msg.sender),\\n      'CFIB: Not approved'\\n    );\\n    require(tokenIds.length == amounts.length, 'CFIB: Length mismatch');\\n\\n    // Transfer\\n    uint256 length = tokenIds.length;\\n    for (uint256 i = 0; i < length; ++i) {\\n      require(_owners[tokenIds[i]] == from, 'CFIB: Not owner');\\n      _owners[tokenIds[i]] = address(0);\\n    }\\n    _onTransfer(address(this), from, address(0), tokenIds, amounts);\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemBridge-setApprovalForAll}\\n   */\\n  function setApprovalForAll(address _operator, bool _approved)\\n    external\\n    override\\n  {\\n    // Update operator status\\n    _operators[msg.sender][_operator] = _approved;\\n    emit BridgeApproval(msg.sender, _operator, _approved);\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemBridge-isApprovedForAll}\\n   */\\n  function isApprovedForAll(address _owner, address _operator)\\n    public\\n    view\\n    override\\n    returns (bool isOperator)\\n  {\\n    return _operators[_owner][_operator];\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemBridge-balanceOf}\\n   */\\n  function balanceOf(address account, uint256 tokenId)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return _owners[tokenId] == account ? 1 : 0;\\n  }\\n\\n  /**\\n   * @dev See {ICFolioItemBridge-balanceOfBatch}\\n   */\\n  function balanceOfBatch(address[] memory accounts, uint256[] memory tokenIds)\\n    external\\n    view\\n    override\\n    returns (uint256[] memory)\\n  {\\n    require(accounts.length == tokenIds.length, 'CFIB: Length mismatch');\\n\\n    // Variables\\n    uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n    // Iterate over each account and token ID\\n    for (uint256 i = 0; i < accounts.length; ++i) {\\n      batchBalances[i] = _owners[tokenIds[i]] == accounts[i] ? 1 : 0;\\n    }\\n\\n    return batchBalances;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Implementation of {IERC1155TokenReceiver} via {ERC1155Holder}\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev See {IERC1155TokenReceiver-onERC1155Received}\\n   */\\n  function onERC1155Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    uint256 amount,\\n    bytes calldata data\\n  ) public override returns (bytes4) {\\n    // Handle tokens\\n    uint256[] memory tokenIds = new uint256[](1);\\n    tokenIds[0] = tokenId;\\n    uint256[] memory amounts = new uint256[](1);\\n    amounts[0] = amount;\\n    _onTokensReceived(operator, tokenIds, amounts, data);\\n\\n    // Call ancestor\\n    return super.onERC1155Received(operator, from, tokenId, amount, data);\\n  }\\n\\n  /**\\n   * @dev See {IERC1155TokenReceiver-onERC1155BatchReceived}\\n   */\\n  function onERC1155BatchReceived(\\n    address operator,\\n    address from,\\n    uint256[] memory tokenIds,\\n    uint256[] memory amounts,\\n    bytes calldata data\\n  ) public override returns (bytes4) {\\n    // Handle tokens\\n    _onTokensReceived(operator, tokenIds, amounts, data);\\n\\n    // Call ancestor\\n    return\\n      super.onERC1155BatchReceived(operator, from, tokenIds, amounts, data);\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Internal details\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  function _onTransfer(\\n    address operator,\\n    address from,\\n    address to,\\n    uint256[] memory tokenIds,\\n    uint256[] memory amounts\\n  ) private {\\n    uint256 tokenId;\\n    // Verify that recipient is null or a cFolio\\n    if (to != address(0)) {\\n      tokenId = _sftHolder.addressToTokenId(to);\\n      require(\\n        tokenId != uint256(-1) && tokenId.isBaseCard(),\\n        'CFIB: Only baseCard'\\n      );\\n    }\\n\\n    // Count SFT tokenIds\\n    uint256 length = tokenIds.length;\\n    uint256 numUniqueCFolioHandlers = 0;\\n    address[] memory uniqueCFolioHandlers = new address[](length);\\n    address[] memory cFolioHandlers = new address[](length);\\n\\n    // Invoke callbacks / count SFTs\\n    for (uint256 i = 0; i < length; ++i) {\\n      tokenId = tokenIds[i];\\n      require(tokenId.isCFolioCard(), 'CFIB: Only cfolioItems');\\n\\n      // CFolio SFTs always have one tradefloor / 1 CFolio dummy\\n      // which is needed to notify the CFolioHandler on SFT burn\\n      address cfolio = _sftHolder.tokenIdToAddress(tokenId.toSftTokenId());\\n      require(cfolio != address(0), 'CFIB: Invalid cfolio');\\n\\n      address cFolioHandler = IWOWSCryptofolio(cfolio)._tradefloors(0);\\n\\n      uint256 iter = numUniqueCFolioHandlers;\\n      while (iter > 0 && uniqueCFolioHandlers[iter - 1] != cFolioHandler)\\n        --iter;\\n      if (iter == 0) {\\n        require(cFolioHandler != address(0), 'Invalid CFH address');\\n        uniqueCFolioHandlers[numUniqueCFolioHandlers++] = cFolioHandler;\\n      }\\n      cFolioHandlers[i] = cFolioHandler;\\n    }\\n\\n    // On Burn we need to transfer SFT ownership back\\n    if (to == address(0)) {\\n      IERC1155(address(_sftHolder)).safeBatchTransferFrom(\\n        address(this),\\n        msg.sender,\\n        tokenIds,\\n        amounts,\\n        ''\\n      );\\n    } else if (to.isContract()) {\\n      bytes4 retval = IERC1155TokenReceiver(to).onERC1155BatchReceived(\\n        msg.sender,\\n        from,\\n        tokenIds,\\n        amounts,\\n        ''\\n      );\\n      require(retval == ERC1155_BATCH_RECEIVED_VALUE, 'CFIB: CallOn failed');\\n    }\\n\\n    // Handle CFolioItem transfers only if we are not migrating\\n    // Migration takes place if we are called from tradeFloor.\\n    // Remove the following condition if everything is migrated\\n    if (\\n      operator !=\\n      _addressRegistry.getRegistryEntry(AddressBook.TRADE_FLOOR_PROXY)\\n    )\\n      for (uint256 i = 0; i < numUniqueCFolioHandlers; ++i) {\\n        ICFolioItemHandler(uniqueCFolioHandlers[i]).onCFolioItemsTransferedFrom(\\n            from,\\n            to,\\n            tokenIds,\\n            cFolioHandlers\\n          );\\n      }\\n\\n    emit BridgeTransfer(msg.sender, from, to, tokenIds, amounts);\\n  }\\n\\n  /**\\n   * @dev SFT token arrived, provide an NFT\\n   */\\n  function _onTokensReceived(\\n    address operator,\\n    uint256[] memory tokenIds,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) private {\\n    // We only support tokens from our SFT Holder contract\\n    require(msg.sender == address(_sftHolder), 'CFIB: Invalid');\\n\\n    // Validate parameters\\n    require(tokenIds.length == amounts.length, 'CFIB: Lengths mismatch');\\n    require(data.length == 20, 'CFIB: Destination invalid');\\n\\n    address sftRecipient = _getAddress(data);\\n    require(sftRecipient != address(0), 'CFIB: Invalid data address');\\n\\n    // Update state\\n    for (uint256 i = 0; i < tokenIds.length; ++i) {\\n      // Validate params\\n      require(amounts[i] == 1, 'CFIB: Amount invalid');\\n      uint256 tokenId = tokenIds[i];\\n      // Mint a token\\n      require(_owners[tokenId] == address(0), 'CFIB: already minted');\\n      _owners[tokenId] = sftRecipient;\\n    }\\n    _onTransfer(operator, address(0), sftRecipient, tokenIds, amounts);\\n  }\\n\\n  /**\\n   * @dev Get the address from the user data parameter\\n   *\\n   * @param data Per ERC-1155, the data parameter is additional data with no\\n   * specified format, and is sent unaltered in the call to\\n   * {IERC1155Receiver-onERC1155Received} on the receiver of the minted token.\\n   */\\n  function _getAddress(bytes memory data) public pure returns (address addr) {\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      addr := mload(add(data, 20))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/src/cfolio/interfaces/ICFolioItemBridge.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @dev Interface to C-folio item bridge\\n */\\ninterface ICFolioItemBridge {\\n  /**\\n   * @notice Send multiple types of tokens from the _from address to the _to address (with safety call)\\n   * @param from     Source addresses\\n   * @param to       Target addresses\\n   * @param tokenIds IDs of each token type\\n   * @param amounts  Transfer amounts per token type\\n   */\\n  function safeBatchTransferFrom(\\n    address from,\\n    address to,\\n    uint256[] memory tokenIds,\\n    uint256[] memory amounts,\\n    bytes memory\\n  ) external;\\n\\n  /**\\n   * @notice Burn multiple types of tokens from the from\\n   * @param from     Source addresses\\n   * @param tokenIds IDs of each token type\\n   * @param amounts  Transfer amounts per token type\\n   */\\n  function burnBatch(\\n    address from,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller's tokens\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return isOperator True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator)\\n    external\\n    view\\n    returns (bool isOperator);\\n\\n  /**\\n   * @notice Get the balance of single account/token pair\\n   * @param account The address of the token holders\\n   * @param tokenId ID of the token\\n   * @return        The account's balance (0 or 1)\\n   */\\n  function balanceOf(address account, uint256 tokenId)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param accounts The addresses of the token holders\\n   * @param tokenIds ID of the Tokens\\n   * @return         The accounts's balances (0 or 1)\\n   */\\n  function balanceOfBatch(address[] memory accounts, uint256[] memory tokenIds)\\n    external\\n    view\\n    returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/src/cfolio/interfaces/ICFolioItemHandler.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nimport '../../token/interfaces/ICFolioItemCallback.sol';\\n\\n/**\\n * @dev Interface to C-folio item contracts\\n */\\ninterface ICFolioItemHandler is ICFolioItemCallback {\\n  /**\\n   * @dev Called when a SFT tokens grade needs re-evaluation\\n   *\\n   * @param tokenId The ERC-1155 token ID. Rate is in 1E6 convention: 1E6 = 100%\\n   * @param newRate The new value rate\\n   */\\n  function sftUpgrade(uint256 tokenId, uint32 newRate) external;\\n\\n  /**\\n   * @dev Called from SFTMinter after an Investment SFT is minted\\n   *\\n   * @param payer The approved address to get investment from\\n   * @param sftTokenId The sftTokenId whose c-folio is the owner of investment\\n   * @param amounts The amounts of invested assets\\n   */\\n  function setupCFolio(\\n    address payer,\\n    uint256 sftTokenId,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Asset access\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Adds investments into a cFolioItem SFT\\n   *\\n   * Transfers amounts of assets from users wallet to the contract. In general,\\n   * an Approval call is required before the function is called.\\n   *\\n   * @param baseTokenId cFolio tokenId, must be unlocked, or -1\\n   * @param tokenId cFolioItem tokenId, must be unlocked if not in unlocked cFolio\\n   * @param amounts Investment amounts, implementation specific\\n   */\\n  function deposit(\\n    uint256 baseTokenId,\\n    uint256 tokenId,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @dev Removes investments from a cFolioItem SFT\\n   *\\n   * Withdrawn token are transfered back to msg.sender.\\n   *\\n   * @param baseTokenId cFolio tokenId, must be unlocked, or -1\\n   * @param tokenId cFolioItem tokenId, must be unlocked if not in unlocked cFolio\\n   * @param amounts Investment amounts, implementation specific\\n   */\\n  function withdraw(\\n    uint256 baseTokenId,\\n    uint256 tokenId,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @dev Get the rewards collected by an SFT base card\\n   *\\n   * @param recipient Recipient of the rewards (- fees)\\n   * @param tokenId SFT base card tokenId, must be unlocked\\n   */\\n  function getRewards(address recipient, uint256 tokenId) external;\\n\\n  /**\\n   * @dev Get amounts (handler specific) for a cfolioItem\\n   *\\n   * @param cfolioItem address of CFolioItem contract\\n   */\\n  function getAmounts(address cfolioItem)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  /**\\n   * @dev Get information obout the rewardFarm\\n   *\\n   * @param tokenIds List of basecard tokenIds\\n   * @return bytes of uint256[]: total, rewardDur, rewardRateForDur, [share, earned]\\n   */\\n  function getRewardInfo(uint256[] calldata tokenIds)\\n    external\\n    view\\n    returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/ICFolioItemCallback.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @dev Interface to receive callbacks when minted tokens are burnt\\n */\\ninterface ICFolioItemCallback {\\n  /**\\n   * @dev Called when a TradeFloor CFolioItem is transfered\\n   *\\n   * In case of mint `from` is address(0).\\n   * In case of burn `to` is address(0).\\n   *\\n   * cfolioHandlers are passed to let each cfolioHandler filter for its own\\n   * token. This eliminates the need for creating separate lists.\\n   *\\n   * @param from The account sending the token\\n   * @param to The account receiving the token\\n   * @param tokenIds The ERC-1155 token IDs\\n   * @param cfolioHandlers cFolioItem handlers\\n   */\\n  function onCFolioItemsTransferedFrom(\\n    address from,\\n    address to,\\n    uint256[] calldata tokenIds,\\n    address[] calldata cfolioHandlers\\n  ) external;\\n\\n  /**\\n   * @dev Append data we use later for hashing\\n   *\\n   * @param cfolioItem The token ID of the c-folio item\\n   * @param current The current data being hashes\\n   *\\n   * @return The current data, with internal data appended\\n   */\\n  function appendHash(address cfolioItem, bytes calldata current)\\n    external\\n    view\\n    returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSCryptofolio.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Cryptofolio interface\\n */\\ninterface IWOWSCryptofolio {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Initialization\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Initialize the deployed contract after creation\\n   *\\n   * This is a one time call which sets _deployer to msg.sender.\\n   * Subsequent calls reverts.\\n   */\\n  function initialize() external;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getters\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Return tradefloor at given index\\n   *\\n   * @param index The 0-based index in the tradefloor array\\n   *\\n   * @return The address of the tradefloor and position index\\n   */\\n  function _tradefloors(uint256 index) external view returns (address);\\n\\n  /**\\n   * @dev Return array of cryptofolio item token IDs\\n   *\\n   * The token IDs belong to the contract TradeFloor.\\n   *\\n   * @param tradefloor The TradeFloor that items belong to\\n   *\\n   * @return tokenIds The token IDs in scope of operator\\n   * @return idsLength The number of valid token IDs\\n   */\\n  function getCryptofolio(address tradefloor)\\n    external\\n    view\\n    returns (uint256[] memory tokenIds, uint256 idsLength);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Set the owner of the underlying NFT\\n   *\\n   * This function is called if ownership of the parent NFT has changed.\\n   *\\n   * The new owner gets allowance to transfer cryptofolio items. The new owner\\n   * is allowed to transfer / burn cryptofolio items. Make sure that allowance\\n   * is removed from previous owner.\\n   *\\n   * @param owner The new owner of the underlying NFT, or address(0) if the\\n   * underlying NFT is being burned\\n   */\\n  function setOwner(address owner) external;\\n\\n  /**\\n   * @dev Allow owner (of parent NFT) to approve external operators to transfer\\n   * our cryptofolio items\\n   *\\n   * The NFT owner is allowed to approve operator to handle cryptofolios.\\n   *\\n   * @param operator The operator\\n   * @param allow True to approve for all NFTs, false to revoke approval\\n   */\\n  function setApprovalForAll(address operator, bool allow) external;\\n\\n  /**\\n   * @dev Burn all cryptofolio items\\n   *\\n   * In case an underlying NFT is burned, we also burn the cryptofolio.\\n   */\\n  function burn() external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSERC1155.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Cryptofolio interface\\n */\\ninterface IWOWSERC1155 {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getters\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Check if the specified address is a known tradefloor\\n   *\\n   * @param account The address to check\\n   *\\n   * @return True if the address is a known tradefloor, false otherwise\\n   */\\n  function isTradeFloor(address account) external view returns (bool);\\n\\n  /**\\n   * @dev Get the token ID of a given address\\n   *\\n   * A cross check is required because token ID 0 is valid.\\n   *\\n   * @param tokenAddress The address to convert to a token ID\\n   *\\n   * @return The token ID on success, or uint256(-1) if `tokenAddress` does not\\n   * belong to a token ID\\n   */\\n  function addressToTokenId(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Get the address for a given token ID\\n   *\\n   * @param tokenId The token ID to convert\\n   *\\n   * @return The address, or address(0) in case the token ID does not belong\\n   * to an NFT\\n   */\\n  function tokenIdToAddress(uint256 tokenId) external view returns (address);\\n\\n  /**\\n   * @dev Get the next mintable token ID for the specified card\\n   *\\n   * @param level The level of the card\\n   * @param cardId The ID of the card\\n   *\\n   * @return bool True if a free token ID was found, false otherwise\\n   * @return uint256 The first free token ID if one was found, or invalid otherwise\\n   */\\n  function getNextMintableTokenId(uint8 level, uint8 cardId)\\n    external\\n    view\\n    returns (bool, uint256);\\n\\n  /**\\n   * @dev Return the next mintable custom token ID\\n   */\\n  function getNextMintableCustomToken() external view returns (uint256);\\n\\n  /**\\n   * @dev Return the level and the mint timestamp of tokenId\\n   *\\n   * @param tokenId The tokenId to query\\n   *\\n   * @return mintTimestamp The timestamp token was minted\\n   * @return level The level token belongs to\\n   */\\n  function getTokenData(uint256 tokenId)\\n    external\\n    view\\n    returns (uint64 mintTimestamp, uint8 level);\\n\\n  /**\\n   * @dev Return all tokenIds owned by account\\n   */\\n  function getTokenIds(address account)\\n    external\\n    view\\n    returns (uint256[] memory);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Set the base URI for either predefined cards or custom cards\\n   * which don't have it's own URI.\\n   *\\n   * The resulting uri is baseUri+[hex(tokenId)] + '.json'. where\\n   * tokenId will be reduces to upper 16 bit (>> 16) before building the hex string.\\n   *\\n   */\\n  function setBaseMetadataURI(string memory baseContractMetadata) external;\\n\\n  /**\\n   * @dev Set the contracts metadata URI\\n   *\\n   * @param contractMetadataURI The URI which point to the contract metadata file.\\n   */\\n  function setContractMetadataURI(string memory contractMetadataURI) external;\\n\\n  /**\\n   * @dev Set the URI for a custom card\\n   *\\n   * @param tokenId The token ID whose URI is being set.\\n   * @param customURI The URI which point to an unique metadata file.\\n   */\\n  function setCustomURI(uint256 tokenId, string memory customURI) external;\\n\\n  /**\\n   * @dev Each custom card has its own level. Level will be used when\\n   * calculating rewards and raiding power.\\n   *\\n   * @param tokenId The ID of the token whose level is being set\\n   * @param cardLevel The new level of the specified token\\n   */\\n  function setCustomCardLevel(uint256 tokenId, uint8 cardLevel) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/AddressBook.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2020-2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nlibrary AddressBook {\\n  bytes32 public constant DEPLOYER = 'DEPLOYER';\\n  bytes32 public constant TEAM_WALLET = 'TEAM_WALLET';\\n  bytes32 public constant MARKETING_WALLET = 'MARKETING_WALLET';\\n  bytes32 public constant UNISWAP_V2_ROUTER02 = 'UNISWAP_V2_ROUTER02';\\n  bytes32 public constant WETH_WOWS_STAKE_FARM = 'WETH_WOWS_STAKE_FARM';\\n  bytes32 public constant WOWS_TOKEN = 'WOWS_TOKEN';\\n  bytes32 public constant UNISWAP_V2_PAIR = 'UNISWAP_V2_PAIR';\\n  bytes32 public constant WOWS_BOOSTER = 'WOWS_BOOSTER';\\n  bytes32 public constant REWARD_HANDLER = 'REWARD_HANDLER';\\n  bytes32 public constant SFT_MINTER = 'SFT_MINTER';\\n  bytes32 public constant SFT_HOLDER = 'SFT_HOLDER';\\n  bytes32 public constant CFOLIOITEM_BRIDGE_PROXY = 'CFOLIOITEM_BRIDGE_PROXY';\\n  bytes32 public constant BOIS_REWARDS = 'BOIS_REWARDS';\\n  bytes32 public constant WOLVES_REWARDS = 'WOLVES_REWARDS';\\n  bytes32 public constant SFT_EVALUATOR_PROXY = 'SFT_EVALUATOR_PROXY';\\n  bytes32 public constant TRADE_FLOOR_PROXY = 'TRADE_FLOOR_PROXY';\\n  bytes32 public constant CURVE_Y_TOKEN = 'CURVE_Y_TOKEN';\\n  bytes32 public constant CURVE_Y_DEPOSIT = 'CURVE_Y_DEPOSIT';\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/TokenIds.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See LICENSE.txt for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nlibrary TokenIds {\\n  // 128 bit underlying hash\\n  uint256 public constant HASH_MASK = (1 << 128) - 1;\\n\\n  function isBaseCard(uint256 tokenId) internal pure returns (bool) {\\n    return (tokenId & HASH_MASK) < (1 << 64);\\n  }\\n\\n  function isStockCard(uint256 tokenId) internal pure returns (bool) {\\n    return (tokenId & HASH_MASK) < (1 << 32);\\n  }\\n\\n  function isCFolioCard(uint256 tokenId) internal pure returns (bool) {\\n    return\\n      (tokenId & HASH_MASK) >= (1 << 64) && (tokenId & HASH_MASK) < (1 << 128);\\n  }\\n\\n  function toSftTokenId(uint256 tokenId) internal pure returns (uint256) {\\n    return tokenId & HASH_MASK;\\n  }\\n\\n  function maskHash(uint256 tokenId) internal pure returns (uint256) {\\n    return tokenId & ~HASH_MASK;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/src/utils/interfaces/IAddressRegistry.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\ninterface IAddressRegistry {\\n  /**\\n   * @dev Set an abitrary key / address pair into the registry\\n   */\\n  function setRegistryEntry(bytes32 _key, address _location) external;\\n\\n  /**\\n   * @dev Get a registry enty with by key, returns 0 address if not existing\\n   */\\n  function getRegistryEntry(bytes32 _key) external view returns (address);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"BridgeApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"BridgeTransfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"_getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isOperator\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"CFolioItemBridge","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000945466656995c9309ff66e05b4c268558bec964e","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}