{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/governance/votingPowerStrategy/EpochVotingPowerStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\\n\\nimport {IVotingPowerStrategy} from '../../interfaces/governance/IVotingPowerStrategy.sol';\\nimport {IKyberGovernance} from '../../interfaces/governance/IKyberGovernance.sol';\\nimport {IKyberStaking} from '../../interfaces/staking/IKyberStaking.sol';\\nimport {EpochUtils} from '../../misc/EpochUtils.sol';\\n\\n/**\\n * @title Voting Power Strategy contract based on epoch mechanism\\n * @dev Smart contract containing logic to measure users' relative power to vote.\\n **/\\ncontract EpochVotingPowerStrategy is IVotingPowerStrategy, EpochUtils {\\n  using SafeMath for uint256;\\n\\n  uint256 public constant MAX_PROPOSAL_PER_EPOCH = 10;\\n  IKyberStaking public immutable staking;\\n  IKyberGovernance public immutable governance;\\n\\n  mapping(uint256 => uint256[]) internal epochProposals;\\n\\n  /**\\n   * @dev Constructor, register tokens used for Voting and Proposition Powers.\\n   * @param _governance The address of governance contract.\\n   * @param _staking The address of the knc staking contract.\\n   **/\\n  constructor(IKyberGovernance _governance, IKyberStaking _staking)\\n    EpochUtils(_staking.epochPeriodInSeconds(), _staking.firstEpochStartTime())\\n  {\\n    staking = _staking;\\n    governance = _governance;\\n  }\\n\\n  modifier onlyStaking() {\\n    require(msg.sender == address(staking), 'only staking');\\n    _;\\n  }\\n\\n  modifier onlyGovernance() {\\n    require(msg.sender == address(governance), 'only governance');\\n    _;\\n  }\\n\\n  /**\\n   * @dev stores proposalIds per epoch mapping, so when user withdraws,\\n   * voting power strategy is aware of which proposals are affected\\n   */\\n  function handleProposalCreation(\\n    uint256 proposalId,\\n    uint256 startTime,\\n    uint256 /*endTime*/\\n  ) external override onlyGovernance {\\n    uint256 epoch = getEpochNumber(startTime);\\n\\n    epochProposals[epoch].push(proposalId);\\n  }\\n\\n  /**\\n   * @dev remove proposalId from proposalIds per epoch mapping, so when user withdraws,\\n   * voting power strategy is aware of which proposals are affected\\n   */\\n  function handleProposalCancellation(uint256 proposalId) external override onlyGovernance {\\n    IKyberGovernance.ProposalWithoutVote memory proposal = governance.getProposalById(proposalId);\\n    uint256 epoch = getEpochNumber(proposal.startTime);\\n\\n    uint256[] storage proposalIds = epochProposals[epoch];\\n    for (uint256 i = 0; i < proposalIds.length; i++) {\\n      if (proposalIds[i] == proposalId) {\\n        // remove this proposalId out of list\\n        proposalIds[i] = proposalIds[proposalIds.length - 1];\\n        proposalIds.pop();\\n        break;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev assume that governance check start and end time\\n   * @dev call to init data if needed, and return voter's voting power\\n   * @dev proposalId, choice: unused param for future usage\\n   */\\n  function handleVote(\\n    address voter,\\n    uint256, /*proposalId*/\\n    uint256 /*choice*/\\n  ) external override onlyGovernance returns (uint256 votingPower) {\\n    (uint256 stake, uint256 dStake, address representative) = staking\\n      .initAndReturnStakerDataForCurrentEpoch(voter);\\n    return representative == voter ? stake.add(dStake) : dStake;\\n  }\\n\\n  /**\\n   * @dev handle user withdraw from staking contract\\n   * @dev notice for governance that voting power for proposalIds in current epoch is changed\\n   */\\n  function handleWithdrawal(\\n    address user,\\n    uint256 /*reduceAmount*/\\n  ) external override onlyStaking {\\n    uint256 currentEpoch = getCurrentEpochNumber();\\n    (uint256 stake, uint256 dStake, address representative) = staking.getStakerData(\\n      user,\\n      currentEpoch\\n    );\\n    uint256 votingPower = representative == user ? stake.add(dStake) : dStake;\\n    governance.handleVotingPowerChanged(user, votingPower, epochProposals[currentEpoch]);\\n  }\\n\\n  /**\\n   * @dev call to get voter's voting power given timestamp\\n   * @dev only for reading purpose. when submitVote, should call handleVote instead\\n   */\\n  function getVotingPower(address voter, uint256 timestamp)\\n    external\\n    override\\n    view\\n    returns (uint256 votingPower)\\n  {\\n    uint256 currentEpoch = getEpochNumber(timestamp);\\n    (uint256 stake, uint256 dStake, address representative) = staking.getStakerData(\\n      voter,\\n      currentEpoch\\n    );\\n    votingPower = representative == voter ? stake.add(dStake) : dStake;\\n  }\\n\\n  /**\\n   * @dev validate that a proposal is suitable for epoch mechanism\\n   */\\n  function validateProposalCreation(uint256 startTime, uint256 endTime)\\n    external\\n    override\\n    view\\n    returns (bool)\\n  {\\n    /// start in the past\\n    if (startTime < block.timestamp) {\\n      return false;\\n    }\\n    uint256 startEpoch = getEpochNumber(startTime);\\n    /// proposal must start and end within an epoch\\n    if (startEpoch != getEpochNumber(endTime)) {\\n      return false;\\n    }\\n    /// proposal must be current or next epoch\\n    if (startEpoch > getCurrentEpochNumber().add(1)) {\\n      return false;\\n    }\\n    /// too many proposals\\n    if (epochProposals[startEpoch].length >= MAX_PROPOSAL_PER_EPOCH) {\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  function getMaxVotingPower() external override view returns (uint256) {\\n    return staking.kncToken().totalSupply();\\n  }\\n\\n  function getListProposalIds(uint256 epoch) external view returns (uint256[] memory proposalIds) {\\n    return epochProposals[epoch];\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IVotingPowerStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IWithdrawHandler} from '../staking/IWithdrawHandler.sol';\\n\\ninterface IVotingPowerStrategy is IWithdrawHandler {\\n  /**\\n   * @dev call by governance when create a proposal\\n   */\\n  function handleProposalCreation(\\n    uint256 proposalId,\\n    uint256 startTime,\\n    uint256 endTime\\n  ) external;\\n\\n  /**\\n   * @dev call by governance when cancel a proposal\\n   */\\n  function handleProposalCancellation(uint256 proposalId) external;\\n\\n  /**\\n   * @dev call by governance when submitting a vote\\n   * @param choice: unused param for future usage\\n   * @return votingPower of voter\\n   */\\n  function handleVote(\\n    address voter,\\n    uint256 proposalId,\\n    uint256 choice\\n  ) external returns (uint256 votingPower);\\n\\n  /**\\n   * @dev get voter's voting power given timestamp\\n   * @dev for reading purposes and validating voting power for creating/canceling proposal in the furture\\n   * @dev when submitVote, should call 'handleVote' instead\\n   */\\n  function getVotingPower(address voter, uint256 timestamp)\\n    external\\n    view\\n    returns (uint256 votingPower);\\n\\n  /**\\n   * @dev validate that startTime and endTime are suitable for calculating voting power\\n   * @dev with current version, startTime and endTime must be in the sameEpcoh\\n   */\\n  function validateProposalCreation(uint256 startTime, uint256 endTime)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev getMaxVotingPower at current time\\n   * @dev call by governance when creating a proposal\\n   */\\n  function getMaxVotingPower() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IKyberGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IExecutorWithTimelock} from './IExecutorWithTimelock.sol';\\nimport {IVotingPowerStrategy} from './IVotingPowerStrategy.sol';\\n\\ninterface IKyberGovernance {\\n  enum ProposalState {\\n    Pending,\\n    Canceled,\\n    Active,\\n    Failed,\\n    Succeeded,\\n    Queued,\\n    Expired,\\n    Executed,\\n    Finalized\\n  }\\n  enum ProposalType {Generic, Binary}\\n\\n  /// For Binary proposal, optionBitMask is 0/1/2\\n  /// For Generic proposal, optionBitMask is bitmask of voted options\\n  struct Vote {\\n    uint32 optionBitMask;\\n    uint224 votingPower;\\n  }\\n\\n  struct ProposalWithoutVote {\\n    uint256 id;\\n    ProposalType proposalType;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    IVotingPowerStrategy strategy;\\n    address[] targets;\\n    uint256[] weiValues;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    string[] options;\\n    uint256[] voteCounts;\\n    uint256 totalVotes;\\n    uint256 maxVotingPower;\\n    uint256 startTime;\\n    uint256 endTime;\\n    uint256 executionTime;\\n    string link;\\n    bool executed;\\n    bool canceled;\\n  }\\n\\n  struct Proposal {\\n    ProposalWithoutVote proposalData;\\n    mapping(address => Vote) votes;\\n  }\\n\\n  struct BinaryProposalParams {\\n    address[] targets;\\n    uint256[] weiValues;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n  }\\n\\n  /**\\n   * @dev emitted when a new binary proposal is created\\n   * @param proposalId id of the binary proposal\\n   * @param creator address of the creator\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param weiValues list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used\\n   *     when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty,\\n   *     calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget,\\n   *    else calls the target\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   * @param maxVotingPower max voting power for this proposal\\n   **/\\n  event BinaryProposalCreated(\\n    uint256 proposalId,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    IVotingPowerStrategy indexed strategy,\\n    address[] targets,\\n    uint256[] weiValues,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    bool[] withDelegatecalls,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string link,\\n    uint256 maxVotingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a new generic proposal is created\\n   * @param proposalId id of the generic proposal\\n   * @param creator address of the creator\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param options list of proposal vote options\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   * @param maxVotingPower max voting power for this proposal\\n   **/\\n  event GenericProposalCreated(\\n    uint256 proposalId,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    IVotingPowerStrategy indexed strategy,\\n    string[] options,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string link,\\n    uint256 maxVotingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a proposal is canceled\\n   * @param proposalId id of the proposal\\n   **/\\n  event ProposalCanceled(uint256 proposalId);\\n\\n  /**\\n   * @dev emitted when a proposal is queued\\n   * @param proposalId id of the proposal\\n   * @param executionTime time when proposal underlying transactions can be executed\\n   * @param initiatorQueueing address of the initiator of the queuing transaction\\n   **/\\n  event ProposalQueued(\\n    uint256 indexed proposalId,\\n    uint256 executionTime,\\n    address indexed initiatorQueueing\\n  );\\n  /**\\n   * @dev emitted when a proposal is executed\\n   * @param proposalId id of the proposal\\n   * @param initiatorExecution address of the initiator of the execution transaction\\n   **/\\n  event ProposalExecuted(uint256 proposalId, address indexed initiatorExecution);\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @param voteOptions vote options selected by voter\\n   * @param votingPower Power of the voter/vote\\n   **/\\n  event VoteEmitted(\\n    uint256 indexed proposalId,\\n    address indexed voter,\\n    uint32 indexed voteOptions,\\n    uint224 votingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @param voteOptions vote options selected by voter\\n   * @param oldVotingPower Old power of the voter/vote\\n   * @param newVotingPower New power of the voter/vote\\n   **/\\n  event VotingPowerChanged(\\n    uint256 indexed proposalId,\\n    address indexed voter,\\n    uint32 indexed voteOptions,\\n    uint224 oldVotingPower,\\n    uint224 newVotingPower\\n  );\\n\\n  event DaoOperatorTransferred(address indexed newDaoOperator);\\n\\n  event ExecutorAuthorized(address indexed executor);\\n\\n  event ExecutorUnauthorized(address indexed executor);\\n\\n  event VotingPowerStrategyAuthorized(address indexed strategy);\\n\\n  event VotingPowerStrategyUnauthorized(address indexed strategy);\\n\\n  /**\\n   * @dev Function is triggered when users withdraw from staking and change voting power\\n   */\\n  function handleVotingPowerChanged(\\n    address staker,\\n    uint256 newVotingPower,\\n    uint256[] calldata proposalIds\\n  ) external;\\n\\n  /**\\n   * @dev Creates a Binary Proposal (needs to be validated by the Proposal Validator)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy voting power strategy of the proposal\\n   * @param executionParams data for execution, includes\\n   *   targets list of contracts called by proposal's associated transactions\\n   *   weiValues list of value in wei for each proposal's associated transaction\\n   *   signatures list of function signatures (can be empty)\\n   *        to be used when created the callData\\n   *   calldatas list of calldatas: if associated signature empty,\\n   *        calldata ready, else calldata is arguments\\n   *   withDelegatecalls boolean, true = transaction delegatecalls the taget,\\n   *        else calls the target\\n   * @param startTime start timestamp to allow vote\\n   * @param endTime end timestamp of the proposal\\n   * @param link link to the proposal description\\n   **/\\n  function createBinaryProposal(\\n    IExecutorWithTimelock executor,\\n    IVotingPowerStrategy strategy,\\n    BinaryProposalParams memory executionParams,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string memory link\\n  ) external returns (uint256 proposalId);\\n\\n  /**\\n   * @dev Creates a Generic Proposal\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param options list of proposal vote options\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   **/\\n  function createGenericProposal(\\n    IExecutorWithTimelock executor,\\n    IVotingPowerStrategy strategy,\\n    string[] memory options,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string memory link\\n  ) external returns (uint256 proposalId);\\n\\n  /**\\n   * @dev Cancels a Proposal,\\n   * either at anytime by guardian\\n   * or when proposal is Pending/Active and threshold no longer reached\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Queue the proposal (If Proposal Succeeded)\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Execute the proposal (If Proposal Queued)\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable;\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param optionBitMask vote option(s) selected\\n   **/\\n  function submitVote(uint256 proposalId, uint256 optionBitMask) external;\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param choice the bit mask of voted options\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    uint256 choice,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] calldata executors) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] calldata executors) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized strategies\\n   * @param strategies list of new addresses to be authorized strategies\\n   **/\\n  function authorizeVotingPowerStrategies(address[] calldata strategies) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized strategies\\n   * @param strategies list of addresses to be removed as authorized strategies\\n   **/\\n  function unauthorizeVotingPowerStrategies(address[] calldata strategies) external;\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) external view returns (bool);\\n\\n  /**\\n   * @dev Returns whether an address is an authorized strategy\\n   * @param strategy address to evaluate as authorized strategy\\n   * @return true if authorized\\n   **/\\n  function isVotingPowerStrategyAuthorized(address strategy) external view returns (bool);\\n\\n  /**\\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\\n   * @return The address of the guardian\\n   **/\\n  function getDaoOperator() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVote memory object\\n   **/\\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVote memory);\\n\\n  /**\\n   * @dev Getter of the vote data of a proposal by id\\n   * including totalVotes, voteCounts and options\\n   * @param proposalId id of the proposal\\n   * @return (totalVotes, voteCounts, options)\\n   **/\\n  function getProposalVoteDataById(uint256 proposalId)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256[] memory,\\n      string[] memory\\n    );\\n\\n  /**\\n   * @dev Getter of the Vote of a voter about a proposal\\n   * Note: Vote is a struct: ({uint32 bitOptionMask, uint224 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote memory object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter)\\n    external\\n    view\\n    returns (Vote memory);\\n\\n  /**\\n   * @dev Get the current state of a proposal\\n   * @param proposalId id of the proposal\\n   * @return The current state if the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IKyberStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {IEpochUtils} from './IEpochUtils.sol';\\n\\ninterface IKyberStaking is IEpochUtils {\\n  event Delegated(\\n    address indexed staker,\\n    address indexed representative,\\n    uint256 indexed epoch,\\n    bool isDelegated\\n  );\\n  event Deposited(uint256 curEpoch, address indexed staker, uint256 amount);\\n  event Withdraw(uint256 indexed curEpoch, address indexed staker, uint256 amount);\\n\\n  function initAndReturnStakerDataForCurrentEpoch(address staker)\\n    external\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    );\\n\\n  function deposit(uint256 amount) external;\\n\\n  function delegate(address dAddr) external;\\n\\n  function withdraw(uint256 amount) external;\\n\\n  /**\\n   * @notice return combine data (stake, delegatedStake, representative) of a staker\\n   * @dev allow to get staker data up to current epoch + 1\\n   */\\n  function getStakerData(address staker, uint256 epoch)\\n    external\\n    view\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    );\\n\\n  function getLatestStakerData(address staker)\\n    external\\n    view\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    );\\n\\n  /**\\n   * @notice return raw data of a staker for an epoch\\n   *         WARN: should be used only for initialized data\\n   *          if data has not been initialized, it will return all 0\\n   *          pool master shouldn't use this function to compute/distribute rewards of pool members\\n   */\\n  function getStakerRawData(address staker, uint256 epoch)\\n    external\\n    view\\n    returns (\\n      uint256 stake,\\n      uint256 delegatedStake,\\n      address representative\\n    );\\n\\n  function kncToken() external view returns (IERC20);\\n}\\n\"\r\n    },\r\n    \"contracts/misc/EpochUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\n\\nimport '../interfaces/staking/IEpochUtils.sol';\\n\\ncontract EpochUtils is IEpochUtils {\\n  using SafeMath for uint256;\\n\\n  uint256 public immutable override epochPeriodInSeconds;\\n  uint256 public immutable override firstEpochStartTime;\\n\\n  constructor(uint256 _epochPeriod, uint256 _startTime) {\\n    require(_epochPeriod > 0, 'ctor: epoch period is 0');\\n\\n    epochPeriodInSeconds = _epochPeriod;\\n    firstEpochStartTime = _startTime;\\n  }\\n\\n  function getCurrentEpochNumber() public override view returns (uint256) {\\n    return getEpochNumber(block.timestamp);\\n  }\\n\\n  function getEpochNumber(uint256 currentTime) public override view returns (uint256) {\\n    if (currentTime < firstEpochStartTime || epochPeriodInSeconds == 0) {\\n      return 0;\\n    }\\n    // ((currentTime - firstEpochStartTime) / epochPeriodInSeconds) + 1;\\n    return ((currentTime.sub(firstEpochStartTime)).div(epochPeriodInSeconds)).add(1);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IWithdrawHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/**\\n * @title Interface for callbacks hooks when user withdraws from staking contract\\n */\\ninterface IWithdrawHandler {\\n  function handleWithdrawal(address staker, uint256 reduceAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IKyberGovernance} from './IKyberGovernance.sol';\\n\\ninterface IExecutorWithTimelock {\\n  /**\\n   * @dev emitted when a new pending admin is set\\n   * @param newPendingAdmin address of the new pending admin\\n   **/\\n  event NewPendingAdmin(address newPendingAdmin);\\n\\n  /**\\n   * @dev emitted when a new admin is set\\n   * @param newAdmin address of the new admin\\n   **/\\n  event NewAdmin(address newAdmin);\\n\\n  /**\\n   * @dev emitted when a new delay (between queueing and execution) is set\\n   * @param delay new delay\\n   **/\\n  event NewDelay(uint256 delay);\\n\\n  /**\\n   * @dev emitted when a new (trans)action is Queued.\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event QueuedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event CancelledAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @param resultData the actual callData used on the target\\n   **/\\n  event ExecutedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall,\\n    bytes resultData\\n  );\\n\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external payable returns (bytes memory);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Getter of grace period constant\\n   * @return grace period in seconds\\n   **/\\n  function GRACE_PERIOD() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of minimum delay constant\\n   * @return minimum delay in seconds\\n   **/\\n  function MINIMUM_DELAY() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of maximum delay constant\\n   * @return maximum delay in seconds\\n   **/\\n  function MAXIMUM_DELAY() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IEpochUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\ninterface IEpochUtils {\\n  function epochPeriodInSeconds() external view returns (uint256);\\n\\n  function firstEpochStartTime() external view returns (uint256);\\n\\n  function getCurrentEpochNumber() external view returns (uint256);\\n\\n  function getEpochNumber(uint256 timestamp) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IKyberGovernance\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"contract IKyberStaking\",\"name\":\"_staking\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"MAX_PROPOSAL_PER_EPOCH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochPeriodInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstEpochStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"}],\"name\":\"getEpochNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getListProposalIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"proposalIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxVotingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getVotingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"votingPower\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract IKyberGovernance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"handleProposalCancellation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"handleProposalCreation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"handleVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"votingPower\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"handleWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"contract IKyberStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"validateProposalCreation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EpochVotingPowerStrategy","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000007ec8fcc26be7e9e85b57e73083e5fe0550d8a7fe000000000000000000000000eadb96f1623176144eba2b24e35325220972b3bd","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}