{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\n\r\nlibrary AddressUtils {\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    \r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC721Receiver {\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\r\n}\r\n\r\n\r\ncontract ERC721Interface {\r\n    // events\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    // interface\r\n    function balanceOf(address _owner) public view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) public view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function approve(address _approved, uint256 _tokenId) public;\r\n    function setApprovalForAll(address _operator, bool _approved) public;\r\n    function getApproved(uint256 _tokenId) public view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n}\r\n\r\ncontract ERC721 is ERC721Interface {\r\n    using SafeMath for uint256;\r\n    using AddressUtils for address;\r\n\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    mapping(uint256 => address) internal tokenOwner;\r\n\r\n    mapping (address => uint256) internal ownedTokensCount;\r\n\r\n    mapping (uint256 => address) internal tokenApprovals;\r\n\r\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        require(isApprovedOrOwner(msg.sender, _tokenId));\r\n        _;\r\n    }\r\n\r\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(_tokenId);\r\n        return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return ownedTokensCount[_owner];\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = tokenOwner[_tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public {\r\n        if (_to.isContract()) {\r\n            bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, data);\r\n            require(retval == ERC721_RECEIVED);\r\n        }\r\n        transferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function clearApproval(address _owner, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _owner);\r\n        if (tokenApprovals[_tokenId] != address(0)) {\r\n            tokenApprovals[_tokenId] = address(0);\r\n            emit Approval(_owner, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _from);\r\n        ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n        tokenOwner[_tokenId] = address(0);\r\n    }\r\n\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        require(tokenOwner[_tokenId] == address(0));\r\n        tokenOwner[_tokenId] = _to;\r\n        ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) public {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_approved != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        if (getApproved(_tokenId) != address(0) || _approved != address(0)) {\r\n            tokenApprovals[_tokenId] = _approved;\r\n            emit Approval(owner, _approved, _tokenId);\r\n        }\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public {\r\n        require(_operator != msg.sender);\r\n        operatorApprovals[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    function onERC721Received(address, uint256, bytes) public returns (bytes4) {\r\n        return ERC721_RECEIVED;\r\n    }\r\n}\r\n\r\n\r\ncontract AuctionEngine {\r\n    using SafeMath for uint256;\r\n    using AddressUtils for address;\r\n    \r\n    // event AuctionCreated(uint256 _index, address _creator, address _asset, address _token);\r\n    event AuctionCreated(uint256 _index, address _creator, address _asset);\r\n    event AuctionBid(uint256 _index, address _bidder, uint256 amount);\r\n    event Claim(uint256 auctionIndex, address claimer);\r\n\r\n    enum Status { pending, active, finished }\r\n    struct Auction {\r\n        address assetAddress;\r\n        uint256 assetId;\r\n\r\n        address creator;\r\n        address paymentWallet;\r\n        \r\n        uint256 startTime;\r\n        uint256 duration;\r\n        uint256 currentBidAmount;\r\n        address currentBidOwner;\r\n        uint256 bidCount;\r\n    }\r\n    Auction[] private auctions;\r\n\r\n    function createAuction(address _assetAddress,\r\n                           uint256 _assetId,\r\n                           address _paymentWallet,\r\n                           uint256 _startPrice, \r\n                           uint256 _startTime, \r\n                           uint256 _duration) public returns (uint256) {\r\n        \r\n        require(_assetAddress.isContract());\r\n        ERC721 asset = ERC721(_assetAddress);\r\n        require(asset.ownerOf(_assetId) == msg.sender);\r\n        require(asset.getApproved(_assetId) == address(this));\r\n        \r\n        if (_startTime == 0) { _startTime = now; }\r\n        \r\n        Auction memory auction = Auction({\r\n            creator: msg.sender,\r\n            assetAddress: _assetAddress,\r\n            assetId: _assetId,\r\n            paymentWallet: _paymentWallet,\r\n            startTime: _startTime,\r\n            duration: _duration,\r\n            currentBidAmount: _startPrice,\r\n            currentBidOwner: address(0),\r\n            bidCount: 0\r\n        });\r\n        uint256 index = auctions.push(auction) - 1;\r\n\r\n        emit AuctionCreated(index, auction.creator, auction.assetAddress);\r\n        \r\n        return index;\r\n    }\r\n\r\n    function bid(uint256 auctionIndex) public payable returns (bool) {\r\n        Auction storage auction = auctions[auctionIndex];\r\n        require(auction.creator != address(0));\r\n        require(isActive(auctionIndex));\r\n        \r\n        if (msg.value > auction.currentBidAmount) {\r\n            // refund last highest bidder\r\n            if (auction.currentBidOwner != address(0)) {\r\n                auction.currentBidOwner.transfer(auction.currentBidAmount);\r\n            }\r\n            \r\n            auction.currentBidAmount = msg.value;\r\n            auction.currentBidOwner = msg.sender;\r\n            auction.bidCount = auction.bidCount.add(1);\r\n            \r\n            emit AuctionBid(auctionIndex, msg.sender, msg.value);\r\n            return true;\r\n        } else if (msg.value <= auction.currentBidAmount) {\r\n            msg.sender.transfer(msg.value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getTotalAuctions() public view returns (uint256) { return auctions.length; }\r\n\r\n    function isActive(uint256 index) public view returns (bool) { return getStatus(index) == Status.active; }\r\n    \r\n    function isFinished(uint256 index) public view returns (bool) { return getStatus(index) == Status.finished; }\r\n    \r\n    function getStatus(uint256 index) public view returns (Status) {\r\n        Auction storage auction = auctions[index];\r\n        if (now < auction.startTime) {\r\n            return Status.pending;\r\n        } else if (now < auction.startTime.add(auction.duration)) {\r\n            return Status.active;\r\n        } else {\r\n            return Status.finished;\r\n        }\r\n    }\r\n\r\n    function getCurrentBidOwner(uint256 auctionIndex) public view returns (address) { return auctions[auctionIndex].currentBidOwner; }\r\n    \r\n    function getPaymentWallet(uint256 auctionIndex) public view returns (address) { return auctions[auctionIndex].paymentWallet; }\r\n    \r\n    function getCurrentBidAmount(uint256 auctionIndex) public view returns (uint256) { return auctions[auctionIndex].currentBidAmount; }\r\n\r\n    function getBidCount(uint256 auctionIndex) public view returns (uint256) { return auctions[auctionIndex].bidCount; }\r\n\r\n    function getWinner(uint256 auctionIndex) public view returns (address) {\r\n        require(isFinished(auctionIndex));\r\n        return auctions[auctionIndex].currentBidOwner;\r\n    }    \r\n\r\n    function claimTokens(uint256 auctionIndex) public { \r\n        require(isFinished(auctionIndex));\r\n        Auction storage auction = auctions[auctionIndex];\r\n        \r\n        require(auction.creator == msg.sender);\r\n        auction.paymentWallet.transfer(auction.currentBidAmount);\r\n\r\n        emit Claim(auctionIndex, auction.creator);\r\n    }\r\n\r\n    function claimAsset(uint256 auctionIndex) public {\r\n        require(isFinished(auctionIndex));\r\n        Auction storage auction = auctions[auctionIndex];\r\n        \r\n        address winner = getWinner(auctionIndex);\r\n        require(winner == msg.sender);\r\n        \r\n        ERC721 asset = ERC721(auction.assetAddress);\r\n        asset.transferFrom(auction.creator, winner, auction.assetId);\r\n\r\n        emit Claim(auctionIndex, winner);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_assetAddress\",\"type\":\"address\"},{\"name\":\"_assetId\",\"type\":\"uint256\"},{\"name\":\"_paymentWallet\",\"type\":\"address\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalAuctions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getCurrentBidAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getBidCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getCurrentBidOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getPaymentWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AuctionBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"Claim\",\"type\":\"event\"}]","ContractName":"AuctionEngine","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://430f6a8140a05f0e6d691e7af326f26604e9456b5b3121ba54f1f14ffaeda56c"}]}