{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.6;\r\n\r\ninterface ICalculationsCurve {\r\n  function isCurveLpToken(address) external view returns (bool);\r\n}\r\n\r\ninterface IV2Vault {\r\n  function token() external view returns (address);\r\n}\r\n\r\ninterface IAddressesGenerator {\r\n  function assetsAddresses() external view returns (address[] memory);\r\n}\r\n\r\ninterface ICurveAddressesProvider {\r\n  function max_id() external view returns (uint256);\r\n\r\n  function get_registry() external view returns (address);\r\n\r\n  function get_address(uint256) external view returns (address);\r\n}\r\n\r\ninterface IGaugeController {\r\n  function n_gauges() external view returns (uint256);\r\n  \r\n  function gauges(uint256) external view returns (address);\r\n}\r\n\r\ninterface IMetapoolFactory {\r\n  function get_underlying_coins(address)\r\n    external\r\n    view\r\n    returns (address[8] memory);\r\n}\r\n\r\ninterface IRegistry {\r\n  function get_pool_from_lp_token(address) external view returns (address);\r\n  \r\n  function gauge_controller() external view returns (address);\r\n\r\n  function get_underlying_coins(address)\r\n    external\r\n    view\r\n    returns (address[8] memory);\r\n\r\n  function get_gauges(address) external view returns (address[10] memory);\r\n  \r\n  function pool_count() external view returns (uint256);\r\n  \r\n  function pool_list(uint256) external view returns (address);\r\n  \r\n  function coin_count() external view returns (uint256);\r\n  \r\n  function get_coin(uint256) external view returns (address);\r\n  \r\n  function get_lp_token(address) external view returns (address);\r\n}\r\n\r\ninterface IYearnAddressesProvider {\r\n    function addressById(string memory) external view returns (address);\r\n}\r\n\r\ncontract CurveAddressesHelper {\r\n  address public yearnAddressesProviderAddress;\r\n  address public curveAddressesProviderAddress;\r\n  \r\n  IYearnAddressesProvider internal yearnAddressesProvider;\r\n  ICurveAddressesProvider internal curveAddressesProvider;\r\n\r\n  constructor(\r\n    address _yearnAddressesProviderAddress,\r\n    address _curveAddressesProviderAddress\r\n  ) {\r\n    curveAddressesProviderAddress = _curveAddressesProviderAddress;\r\n    yearnAddressesProviderAddress = _yearnAddressesProviderAddress;\r\n    yearnAddressesProvider = IYearnAddressesProvider(_yearnAddressesProviderAddress);\r\n    curveAddressesProvider = ICurveAddressesProvider(_curveAddressesProviderAddress);\r\n  }\r\n\r\n  function registryAddress() public view returns (address) {\r\n    return curveAddressesProvider.get_registry();\r\n  }\r\n\r\n  function metapoolFactoryAddress() public view returns (address) {\r\n    return curveAddressesProvider.get_address(3);\r\n  }\r\n\r\n  function registry() internal view returns (IRegistry) {\r\n    return IRegistry(registryAddress());\r\n  }\r\n\r\n  function underlyingTokensAddressesFromLpAddress(address lpAddress)\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n  {\r\n    address[] memory underlyingTokensAddresses = new address[](16);\r\n    uint256 currentIdx;\r\n    address[8] memory registryUnderlyingTokensAddresses =\r\n      registryTokensAddressesFromLpAddress(lpAddress);\r\n    address[8] memory metapoolUnderlyingTokensAddresses =\r\n      metapoolTokensAddressesFromLpAddress(lpAddress);\r\n    for (\r\n      uint256 tokenIdx;\r\n      tokenIdx < registryUnderlyingTokensAddresses.length;\r\n      tokenIdx++\r\n    ) {\r\n      address tokenAddress = registryUnderlyingTokensAddresses[tokenIdx];\r\n      if (tokenAddress != address(0)) {\r\n        underlyingTokensAddresses[currentIdx] = tokenAddress;\r\n        currentIdx++;\r\n      }\r\n    }\r\n    for (\r\n      uint256 tokenIdx;\r\n      tokenIdx < metapoolUnderlyingTokensAddresses.length;\r\n      tokenIdx++\r\n    ) {\r\n      address tokenAddress = metapoolUnderlyingTokensAddresses[tokenIdx];\r\n      if (tokenAddress != address(0)) {\r\n        underlyingTokensAddresses[currentIdx] = tokenAddress;\r\n        currentIdx++;\r\n      }\r\n    }\r\n    bytes memory encodedAddresses = abi.encode(underlyingTokensAddresses);\r\n    assembly {\r\n      mstore(add(encodedAddresses, 0x40), currentIdx)\r\n    }\r\n    address[] memory filteredAddresses =\r\n      abi.decode(encodedAddresses, (address[]));\r\n    return filteredAddresses;\r\n  }\r\n\r\n  function registryTokensAddressesFromLpAddress(address lpAddress)\r\n    public\r\n    view\r\n    returns (address[8] memory)\r\n  {\r\n    address[8] memory tokensAddresses =\r\n      registry().get_underlying_coins(lpAddress);\r\n    return tokensAddresses;\r\n  }\r\n\r\n  function metapoolTokensAddressesFromLpAddress(address lpAddress)\r\n    public\r\n    view\r\n    returns (address[8] memory)\r\n  {\r\n    address[8] memory tokensAddresses =\r\n      IMetapoolFactory(metapoolFactoryAddress()).get_underlying_coins(\r\n        lpAddress\r\n      );\r\n    return tokensAddresses;\r\n  }\r\n\r\n  function poolAddressFromLpAddress(address lpAddress)\r\n    public\r\n    view\r\n    returns (address)\r\n  {\r\n    address[8] memory metapoolTokensAddresses =\r\n      metapoolTokensAddressesFromLpAddress(lpAddress);\r\n    for (uint256 tokenIdx; tokenIdx < 8; tokenIdx++) {\r\n      address tokenAddress = metapoolTokensAddresses[tokenIdx];\r\n      if (tokenAddress != address(0)) {\r\n        return lpAddress;\r\n      }\r\n    }\r\n    return registry().get_pool_from_lp_token(lpAddress);\r\n  }\r\n\r\n  function gaugeAddressesFromLpAddress(address lpAddress)\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n  {\r\n    address poolAddress = poolAddressFromLpAddress(lpAddress);\r\n    address[] memory gaugeAddresses =\r\n      gaugeAddressesFromPoolAddress(poolAddress);\r\n    return gaugeAddresses;\r\n  }\r\n  \r\n  function gaugeAddressesFromPoolAddress(address poolAddress)\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n  {\r\n    address[10] memory _gaugesAddresses = registry().get_gauges(poolAddress);\r\n    address[] memory filteredGaugesAddresses = new address[](10);\r\n    uint256 numberOfGauges;\r\n    for (uint256 gaugeIdx; gaugeIdx < _gaugesAddresses.length; gaugeIdx++) {\r\n      address gaugeAddress = _gaugesAddresses[gaugeIdx];\r\n      if (gaugeAddress == address(0)) {\r\n        break;\r\n      }\r\n      filteredGaugesAddresses[gaugeIdx] = gaugeAddress;\r\n      numberOfGauges++;\r\n    }\r\n    bytes memory encodedAddresses = abi.encode(filteredGaugesAddresses);\r\n    assembly {\r\n      mstore(add(encodedAddresses, 0x40), numberOfGauges)\r\n    }\r\n    filteredGaugesAddresses = abi.decode(encodedAddresses, (address[]));\r\n    return filteredGaugesAddresses;\r\n  }\r\n\r\n  function yearnGaugesAddresses()\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n  {\r\n    uint256 gaugesLength;\r\n    address[] memory _yearnPoolsAddresses = yearnPoolsAddresses();\r\n    address[] memory _yearnGaugesAddresses =\r\n      new address[](_yearnPoolsAddresses.length * 8);\r\n    for (\r\n      uint256 poolIdx = 0;\r\n      poolIdx < _yearnPoolsAddresses.length;\r\n      poolIdx++\r\n    ) {\r\n      address poolAddress = _yearnPoolsAddresses[poolIdx];\r\n      address[] memory _gaugesAddresses = gaugeAddressesFromPoolAddress(poolAddress);\r\n      for (uint256 gaugeIdx; gaugeIdx < _gaugesAddresses.length; gaugeIdx++) {\r\n        address gaugeAddress = _gaugesAddresses[gaugeIdx];\r\n        _yearnGaugesAddresses[gaugesLength] = gaugeAddress;\r\n        gaugesLength++;\r\n      }\r\n    }\r\n    bytes memory encodedAddresses = abi.encode(_yearnGaugesAddresses);\r\n    assembly {\r\n        mstore(add(encodedAddresses, 0x40), gaugesLength)\r\n    }\r\n    address[] memory filteredAddresses =\r\n        abi.decode(encodedAddresses, (address[]));\r\n    return filteredAddresses;\r\n  }\r\n\r\n  function lpsAddresses() external view returns (address[] memory) {\r\n    address[] memory _poolsAddresses = poolsAddresses();\r\n    uint256 numberOfPools = _poolsAddresses.length;\r\n    address[] memory _lpsAddresses = new address[](numberOfPools);\r\n    for (uint256 poolIdx; poolIdx < numberOfPools; poolIdx++) {\r\n        address poolAddress = _poolsAddresses[poolIdx];\r\n        _lpsAddresses[poolIdx] = registry().get_lp_token(poolAddress);\r\n    }\r\n    return _lpsAddresses;\r\n  }\r\n  \r\n  function gaugesAddresses() external view returns (address[] memory) {\r\n    IGaugeController gaugeController = IGaugeController(registry().gauge_controller());\r\n    uint256 numberOfGauges = gaugeController.n_gauges();\r\n    address[] memory _gaugesAddresses = new address[](numberOfGauges);\r\n    for (uint256 gaugeIdx; gaugeIdx < numberOfGauges; gaugeIdx++) {\r\n        _gaugesAddresses[gaugeIdx] = gaugeController.gauges(gaugeIdx);\r\n    }\r\n    return _gaugesAddresses;\r\n  }\r\n\r\n  function coinsAddresses() external view returns (address[] memory) {\r\n    uint256 numberOfCoins = registry().coin_count();\r\n    address[] memory _coinsAddresses = new address[](numberOfCoins);\r\n    for (uint256 coinIdx; coinIdx < numberOfCoins; coinIdx++) {\r\n        _coinsAddresses[coinIdx] = registry().get_coin(coinIdx);\r\n    }\r\n    return _coinsAddresses;\r\n  }\r\n\r\n  function poolsAddresses() public view returns (address[] memory) {\r\n    uint256 numberOfPools = registry().pool_count();\r\n    address[] memory _poolsAddresses = new address[](numberOfPools);\r\n    for (uint256 poolIdx; poolIdx < numberOfPools; poolIdx++) {\r\n        _poolsAddresses[poolIdx] = registry().pool_list(poolIdx);\r\n    }\r\n    return _poolsAddresses;\r\n  }\r\n\r\n  function yearnPoolsAddresses() public view returns (address[] memory) {\r\n    address[] memory _yearnLpsAddresses = yearnLpsAddresses();\r\n    address[] memory _yearnPoolsAddresses =\r\n      new address[](_yearnLpsAddresses.length);\r\n    for (uint256 lpIdx = 0; lpIdx < _yearnLpsAddresses.length; lpIdx++) {\r\n      address lpAddress = _yearnLpsAddresses[lpIdx];\r\n      address poolAddress = poolAddressFromLpAddress(lpAddress);\r\n      _yearnPoolsAddresses[lpIdx] = poolAddress;\r\n    }\r\n    return _yearnPoolsAddresses;\r\n  }\r\n  \r\n  function getAddress(string memory _address) public view returns (address) {\r\n    return yearnAddressesProvider.addressById(_address);\r\n  }\r\n  \r\n  function yearnVaultsAddresses() internal view returns (address[] memory) {\r\n    address[] memory vaultsAddresses =\r\n      IAddressesGenerator(getAddress(\"ADDRESSES_GENERATOR_V2_VAULTS\")).assetsAddresses();\r\n    uint256 currentIdx = 0;\r\n    for (uint256 vaultIdx = 0; vaultIdx < vaultsAddresses.length; vaultIdx++) {\r\n      address vaultAddress = vaultsAddresses[vaultIdx];\r\n      bool isCurveLpVault =\r\n        ICalculationsCurve(getAddress(\"CALCULATIONS_CURVE\")).isCurveLpToken(\r\n          IV2Vault(vaultAddress).token()\r\n        );\r\n      if (isCurveLpVault) {\r\n        vaultsAddresses[currentIdx] = vaultAddress;\r\n        currentIdx++;\r\n      }\r\n    }\r\n    bytes memory encodedVaultsAddresses = abi.encode(vaultsAddresses);\r\n    assembly {\r\n      mstore(add(encodedVaultsAddresses, 0x40), currentIdx)\r\n    }\r\n    address[] memory filteredVaultsAddresses =\r\n      abi.decode(encodedVaultsAddresses, (address[]));\r\n    return filteredVaultsAddresses;\r\n  }\r\n\r\n  function yearnLpsAddresses() public view returns (address[] memory) {\r\n    address[] memory _vaultsAddresses = yearnVaultsAddresses();\r\n    address[] memory _lpsAddresses = new address[](_vaultsAddresses.length);\r\n    for (uint256 vaultIdx = 0; vaultIdx < _vaultsAddresses.length; vaultIdx++) {\r\n      address vaultAddress = _vaultsAddresses[vaultIdx];\r\n      IV2Vault vault = IV2Vault(vaultAddress);\r\n      address lpTokenAddress = vault.token();\r\n      _lpsAddresses[vaultIdx] = lpTokenAddress;\r\n    }\r\n    return _lpsAddresses;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yearnAddressesProviderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveAddressesProviderAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"coinsAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveAddressesProviderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"gaugeAddressesFromLpAddress\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"gaugeAddressesFromPoolAddress\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugesAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_address\",\"type\":\"string\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpsAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metapoolFactoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"metapoolTokensAddressesFromLpAddress\",\"outputs\":[{\"internalType\":\"address[8]\",\"name\":\"\",\"type\":\"address[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"poolAddressFromLpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolsAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"registryTokensAddressesFromLpAddress\",\"outputs\":[{\"internalType\":\"address[8]\",\"name\":\"\",\"type\":\"address[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"name\":\"underlyingTokensAddressesFromLpAddress\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearnAddressesProviderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearnGaugesAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearnLpsAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearnPoolsAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CurveAddressesHelper","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009be19ee7bc4099d62737a7255f5c227fbcd6db930000000000000000000000000000000022d53366457f9d5e68ec105046fc4383","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://dd1d2d02cf9049d1e5e3d6bee77b3f85dfe178df45756d12571edfc09e44091f"}]}