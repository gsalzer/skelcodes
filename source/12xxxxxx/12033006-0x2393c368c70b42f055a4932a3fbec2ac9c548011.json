{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.11\r\n\"\"\"\r\n@title Curve Registry Exchange Contract\r\n@license MIT\r\n@author Curve.Fi\r\n@notice Find pools, query exchange rates and perform swaps\r\n\"\"\"\r\n\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface AddressProvider:\r\n    def admin() -> address: view\r\n    def get_registry() -> address: view\r\n    def get_address(idx: uint256) -> address: view\r\n\r\ninterface CurvePool:\r\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\r\n    def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\r\n    def get_dy(i: int128, j: int128, amount: uint256) -> uint256: view\r\n    def get_dy_underlying(i: int128, j: int128, amount: uint256) -> uint256: view\r\n\r\ninterface Registry:\r\n    def address_provider() -> address: view\r\n    def get_A(_pool: address) -> uint256: view\r\n    def get_fees(_pool: address) -> uint256[2]: view\r\n    def get_coin_indices(_pool: address, _from: address, _to: address) -> (int128, int128, bool): view\r\n    def get_n_coins(_pool: address) -> uint256[2]: view\r\n    def get_balances(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_underlying_balances(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_rates(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_decimals(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_underlying_decimals(_pool: address) -> uint256[MAX_COINS]: view\r\n    def find_pool_for_coins(_from: address, _to: address, i: uint256) -> address: view\r\n    def get_lp_token(_pool: address) -> address: view\r\n\r\ninterface Calculator:\r\n    def get_dx(n_coins: uint256, balances: uint256[MAX_COINS], amp: uint256, fee: uint256,\r\n               rates: uint256[MAX_COINS], precisions: uint256[MAX_COINS],\r\n               i: int128, j: int128, dx: uint256) -> uint256: view\r\n    def get_dy(n_coins: uint256, balances: uint256[MAX_COINS], amp: uint256, fee: uint256,\r\n               rates: uint256[MAX_COINS], precisions: uint256[MAX_COINS],\r\n               i: int128, j: int128, dx: uint256[CALC_INPUT_SIZE]) -> uint256[CALC_INPUT_SIZE]: view\r\n\r\n\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    receiver: indexed(address)\r\n    pool: indexed(address)\r\n    token_sold: address\r\n    token_bought: address\r\n    amount_sold: uint256\r\n    amount_bought: uint256\r\n\r\n\r\nETH_ADDRESS: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nMAX_COINS: constant(int128) = 8\r\nCALC_INPUT_SIZE: constant(uint256) = 100\r\n\r\n\r\naddress_provider: AddressProvider\r\nregistry: public(address)\r\nfactory_registry: public(address)\r\n\r\ndefault_calculator: public(address)\r\nis_killed: public(bool)\r\npool_calculator: HashMap[address, address]\r\n\r\nis_approved: HashMap[address, HashMap[address, bool]]\r\n\r\n\r\n@external\r\ndef __init__(_address_provider: address, _calculator: address):\r\n    \"\"\"\r\n    @notice Constructor function\r\n    \"\"\"\r\n    self.address_provider = AddressProvider(_address_provider)\r\n    self.registry = AddressProvider(_address_provider).get_registry()\r\n    self.factory_registry = AddressProvider(_address_provider).get_address(3)\r\n    self.default_calculator = _calculator\r\n\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    pass\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_exchange_amount(\r\n    _registry: address,\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins received in an exchange\r\n    @param _registry Registry address\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_from` to be sent\r\n    @return Quantity of `_to` to be received\r\n    \"\"\"\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    i, j, is_underlying = Registry(_registry).get_coin_indices(_pool, _from, _to) # dev: no market\r\n\r\n    if is_underlying:\r\n        return CurvePool(_pool).get_dy_underlying(i, j, _amount)\r\n\r\n    return CurvePool(_pool).get_dy(i, j, _amount)\r\n\r\n\r\n@internal\r\ndef _exchange(\r\n    _registry: address,\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _sender: address,\r\n    _receiver: address,\r\n) -> uint256:\r\n\r\n    assert not self.is_killed\r\n\r\n    initial_balance: uint256 = 0\r\n    eth_amount: uint256 = 0\r\n    received_amount: uint256 = 0\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    i, j, is_underlying = Registry(_registry).get_coin_indices(_pool, _from, _to)  # dev: no market\r\n\r\n    # record initial balance\r\n    if _to == ETH_ADDRESS:\r\n        initial_balance = self.balance\r\n    else:\r\n        initial_balance = ERC20(_to).balanceOf(self)\r\n\r\n    # perform / verify input transfer\r\n    if _from == ETH_ADDRESS:\r\n        eth_amount = _amount\r\n    else:\r\n        response: Bytes[32] = raw_call(\r\n            _from,\r\n            concat(\r\n                method_id(\"transferFrom(address,address,uint256)\"),\r\n                convert(_sender, bytes32),\r\n                convert(self, bytes32),\r\n                convert(_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    # approve input token\r\n    if not self.is_approved[_from][_pool]:\r\n        response: Bytes[32] = raw_call(\r\n            _from,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(_pool, bytes32),\r\n                convert(MAX_UINT256, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n        self.is_approved[_from][_pool] = True\r\n\r\n    # perform coin exchange\r\n    if is_underlying:\r\n        CurvePool(_pool).exchange_underlying(i, j, _amount, _expected, value=eth_amount)\r\n    else:\r\n        CurvePool(_pool).exchange(i, j, _amount, _expected, value=eth_amount)\r\n\r\n    # perform output transfer\r\n    if _to == ETH_ADDRESS:\r\n        received_amount = self.balance - initial_balance\r\n        raw_call(_receiver, b\"\", value=received_amount)\r\n    else:\r\n        received_amount = ERC20(_to).balanceOf(self) - initial_balance\r\n        response: Bytes[32] = raw_call(\r\n            _to,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(_receiver, bytes32),\r\n                convert(received_amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    log TokenExchange(_sender, _receiver, _pool, _from, _to, _amount, received_amount)\r\n\r\n    return received_amount\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef exchange_with_best_rate(\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange using the pool that offers the best rate\r\n    @dev Prior to calling this function, the caller must approve\r\n         this contract to transfer `_amount` coins from `_from`\r\n         Does NOT check rates in factory-deployed pools\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @param _expected Minimum quantity of `_from` received\r\n           in order for the transaction to succeed\r\n    @param _receiver Address to transfer the received tokens to\r\n    @return uint256 Amount received\r\n    \"\"\"\r\n    if _from == ETH_ADDRESS:\r\n        assert _amount == msg.value, \"Incorrect ETH amount\"\r\n    else:\r\n        assert msg.value == 0, \"Incorrect ETH amount\"\r\n\r\n    registry: address = self.registry\r\n    best_pool: address = ZERO_ADDRESS\r\n    max_dy: uint256 = 0\r\n    for i in range(65536):\r\n        pool: address = Registry(registry).find_pool_for_coins(_from, _to, i)\r\n        if pool == ZERO_ADDRESS:\r\n            break\r\n        dy: uint256 = self._get_exchange_amount(registry, pool, _from, _to, _amount)\r\n        if dy > max_dy:\r\n            best_pool = pool\r\n            max_dy = dy\r\n\r\n    return self._exchange(registry, best_pool, _from, _to, _amount, _expected, msg.sender, _receiver)\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef exchange(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange using a specific pool\r\n    @dev Prior to calling this function, the caller must approve\r\n         this contract to transfer `_amount` coins from `_from`\r\n         Works for both regular and factory-deployed pools\r\n    @param _pool Address of the pool to use for the swap\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @param _expected Minimum quantity of `_from` received\r\n           in order for the transaction to succeed\r\n    @param _receiver Address to transfer the received tokens to\r\n    @return uint256 Amount received\r\n    \"\"\"\r\n    if _from == ETH_ADDRESS:\r\n        assert _amount == msg.value, \"Incorrect ETH amount\"\r\n    else:\r\n        assert msg.value == 0, \"Incorrect ETH amount\"\r\n\r\n    registry: address = self.registry\r\n    if Registry(registry).get_lp_token(_pool) == ZERO_ADDRESS:\r\n        registry = self.factory_registry\r\n    return self._exchange(registry, _pool, _from, _to, _amount, _expected, msg.sender, _receiver)\r\n\r\n\r\n@view\r\n@external\r\ndef get_best_rate(_from: address, _to: address, _amount: uint256) -> (address, uint256):\r\n    \"\"\"\r\n    @notice Find the pool offering the best rate for a given swap.\r\n    @dev Checks rates for regular and factory pools\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @return Pool address, amount received\r\n    \"\"\"\r\n    best_pool: address = ZERO_ADDRESS\r\n    max_dy: uint256 = 0\r\n    for registry in [self.registry, self.factory_registry]:\r\n        for i in range(65536):\r\n            pool: address = Registry(registry).find_pool_for_coins(_from, _to, i)\r\n            if pool == ZERO_ADDRESS:\r\n                break\r\n\r\n            dy: uint256 = self._get_exchange_amount(registry, pool, _from, _to, _amount)\r\n            if dy > max_dy:\r\n                best_pool = pool\r\n                max_dy = dy\r\n\r\n    return best_pool, max_dy\r\n\r\n\r\n@view\r\n@external\r\ndef get_exchange_amount(_pool: address, _from: address, _to: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins received in an exchange\r\n    @dev Works for both regular and factory-deployed pools\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_from` to be sent\r\n    @return Quantity of `_to` to be received\r\n    \"\"\"\r\n    registry: address = self.registry\r\n    if Registry(registry).get_lp_token(_pool) == ZERO_ADDRESS:\r\n        registry = self.factory_registry\r\n    return self._get_exchange_amount(registry, _pool, _from, _to, _amount)\r\n\r\n\r\n@view\r\n@external\r\ndef get_input_amount(_pool: address, _from: address, _to: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins required to receive the given amount in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_to` to be received\r\n    @return Quantity of `_from` to be sent\r\n    \"\"\"\r\n    registry: address = self.registry\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    i, j, is_underlying = Registry(registry).get_coin_indices(_pool, _from, _to)\r\n    amp: uint256 = Registry(registry).get_A(_pool)\r\n    fee: uint256 = Registry(registry).get_fees(_pool)[0]\r\n\r\n    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    n_coins: uint256 = Registry(registry).get_n_coins(_pool)[convert(is_underlying, uint256)]\r\n    if is_underlying:\r\n        balances = Registry(registry).get_underlying_balances(_pool)\r\n        decimals = Registry(registry).get_underlying_decimals(_pool)\r\n        for x in range(MAX_COINS):\r\n            if x == n_coins:\r\n                break\r\n            rates[x] = 10**18\r\n    else:\r\n        balances = Registry(registry).get_balances(_pool)\r\n        decimals = Registry(registry).get_decimals(_pool)\r\n        rates = Registry(registry).get_rates(_pool)\r\n\r\n    for x in range(MAX_COINS):\r\n        if x == n_coins:\r\n            break\r\n        decimals[x] = 10 ** (18 - decimals[x])\r\n\r\n    calculator: address = self.pool_calculator[_pool]\r\n    if calculator == ZERO_ADDRESS:\r\n        calculator = self.default_calculator\r\n    return Calculator(calculator).get_dx(n_coins, balances, amp, fee, rates, decimals, i, j, _amount)\r\n\r\n\r\n@view\r\n@external\r\ndef get_exchange_amounts(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amounts: uint256[CALC_INPUT_SIZE]\r\n) -> uint256[CALC_INPUT_SIZE]:\r\n    \"\"\"\r\n    @notice Get the current number of coins required to receive the given amount in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amounts Quantity of `_to` to be received\r\n    @return Quantity of `_from` to be sent\r\n    \"\"\"\r\n    registry: address = self.registry\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n\r\n    amp: uint256 = Registry(registry).get_A(_pool)\r\n    fee: uint256 = Registry(registry).get_fees(_pool)[0]\r\n    i, j, is_underlying = Registry(registry).get_coin_indices(_pool, _from, _to)\r\n    n_coins: uint256 = Registry(registry).get_n_coins(_pool)[convert(is_underlying, uint256)]\r\n\r\n    if is_underlying:\r\n        balances = Registry(registry).get_underlying_balances(_pool)\r\n        decimals = Registry(registry).get_underlying_decimals(_pool)\r\n        for x in range(MAX_COINS):\r\n            if x == n_coins:\r\n                break\r\n            rates[x] = 10**18\r\n    else:\r\n        balances = Registry(registry).get_balances(_pool)\r\n        decimals = Registry(registry).get_decimals(_pool)\r\n        rates = Registry(registry).get_rates(_pool)\r\n\r\n    for x in range(MAX_COINS):\r\n        if x == n_coins:\r\n            break\r\n        decimals[x] = 10 ** (18 - decimals[x])\r\n\r\n    calculator: address = self.pool_calculator[_pool]\r\n    if calculator == ZERO_ADDRESS:\r\n        calculator = self.default_calculator\r\n    return Calculator(calculator).get_dy(n_coins, balances, amp, fee, rates, decimals, i, j, _amounts)\r\n\r\n\r\n@view\r\n@external\r\ndef get_calculator(_pool: address) -> address:\r\n    \"\"\"\r\n    @notice Set calculator contract\r\n    @dev Used to calculate `get_dy` for a pool\r\n    @param _pool Pool address\r\n    @return `CurveCalc` address\r\n    \"\"\"\r\n    calculator: address = self.pool_calculator[_pool]\r\n    if calculator == ZERO_ADDRESS:\r\n        return self.default_calculator\r\n    else:\r\n        return calculator\r\n\r\n\r\n@external\r\ndef update_registry_address() -> bool:\r\n    \"\"\"\r\n    @notice Update registry address\r\n    @dev The registry address is kept in storage to reduce gas costs.\r\n         If a new registry is deployed this function should be called\r\n         to update the local address from the address provider.\r\n    @return bool success\r\n    \"\"\"\r\n    address_provider: address = self.address_provider.address\r\n    self.registry = AddressProvider(address_provider).get_registry()\r\n    self.factory_registry = AddressProvider(address_provider).get_address(3)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_calculator(_pool: address, _calculator: address) -> bool:\r\n    \"\"\"\r\n    @notice Set calculator contract\r\n    @dev Used to calculate `get_dy` for a pool\r\n    @param _pool Pool address\r\n    @param _calculator `CurveCalc` address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    self.pool_calculator[_pool] = _calculator\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_default_calculator(_calculator: address) -> bool:\r\n    \"\"\"\r\n    @notice Set default calculator contract\r\n    @dev Used to calculate `get_dy` for a pool\r\n    @param _calculator `CurveCalc` address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    self.default_calculator = _calculator\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef claim_balance(_token: address) -> bool:\r\n    \"\"\"\r\n    @notice Transfer an ERC20 or ETH balance held by this contract\r\n    @dev The entire balance is transferred to the owner\r\n    @param _token Token address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    if _token == ETH_ADDRESS:\r\n        raw_call(msg.sender, b\"\", value=self.balance)\r\n    else:\r\n        amount: uint256 = ERC20(_token).balanceOf(self)\r\n        response: Bytes[32] = raw_call(\r\n            _token,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(msg.sender, bytes32),\r\n                convert(amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_killed(_is_killed: bool) -> bool:\r\n    \"\"\"\r\n    @notice Kill or unkill the contract\r\n    @param _is_killed Killed status of the contract\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n    self.is_killed = _is_killed\r\n\r\n    return True","ABI":"[{\"name\":\"TokenExchange\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"pool\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_sold\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token_bought\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_address_provider\",\"type\":\"address\"},{\"name\":\"_calculator\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_with_best_rate\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_with_best_rate\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_best_rate\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":395840312},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_exchange_amount\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":5104},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_input_amount\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":15358},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_exchange_amounts\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[100]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[100]\"}],\"gas\":17925},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_calculator\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2429},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_registry_address\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":72066},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_calculator\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_calculator\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":37159},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_default_calculator\",\"inputs\":[{\"name\":\"_calculator\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":36974},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_balance\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":37798},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":37034},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"registry\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1538},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory_registry\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1568},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"default_calculator\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":1598},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1628}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.11","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000000000000022d53366457f9d5e68ec105046fc43830000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}