{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.5;\r\n\r\ninterface IERC721 {\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC721Metadata {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n/**\r\n * Based on: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n    mapping(uint256 => address) private _owners;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function balanceOf(address owner)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            owner != address(0),\r\n            \"ERC721: balance query for the zero address\"\r\n        );\r\n        return _balances[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        address owner = _owners[tokenId];\r\n        require(\r\n            owner != address(0),\r\n            \"ERC721: owner query for nonexistent token\"\r\n        );\r\n        return owner;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (string memory)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721Metadata: URI query for nonexistent token\"\r\n        );\r\n\r\n        string memory baseURI = _baseURI();\r\n        return\r\n            bytes(baseURI).length > 0\r\n                ? string(abi.encodePacked(baseURI, tokenId))\r\n                : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\r\n     * in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721: approved query for nonexistent token\"\r\n        );\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved)\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(operator != msg.sender, \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(\r\n            _isApprovedOrOwner(msg.sender, tokenId),\r\n            \"ERC721: transfer caller is not owner nor approved\"\r\n        );\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(\r\n            _isApprovedOrOwner(msg.sender, tokenId),\r\n            \"ERC721: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(from, to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721: operator query for nonexistent token\"\r\n        );\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner ||\r\n            getApproved(tokenId) == spender ||\r\n            isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(\r\n            ERC721.ownerOf(tokenId) == from,\r\n            \"ERC721: transfer of token that is not own\"\r\n        );\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (isContract(to)) {\r\n            try\r\n                IERC721Receiver(to).onERC721Received(\r\n                    msg.sender,\r\n                    from,\r\n                    tokenId,\r\n                    _data\r\n                )\r\n            returns (bytes4 retval) {\r\n                return retval == IERC721Receiver(to).onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\r\n                        \"ERC721: transfer to non ERC721Receiver implementer\"\r\n                    );\r\n                } else {\r\n                    // solhint-disable-next-line no-inline-assembly\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7f6a1666fac8ecff5dd467d0938069bc221ea9e0/contracts/utils/Address.sol\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Editions.sol\r\n\r\n\r\n/**\r\n * @title Editions\r\n * @author MirrorXYZ\r\n */\r\ncontract Editions is ERC721 {\r\n    // ============ Constants ============\r\n\r\n    string public constant name = \"Mirror Editions V2\";\r\n    string public constant symbol = \"EDITIONS_V2\";\r\n\r\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\r\n    uint256 internal constant REENTRANCY_ENTERED = 2;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Edition {\r\n        // The maximum number of tokens that can be sold.\r\n        uint256 quantity;\r\n        // The price at which each token will be sold, in ETH.\r\n        uint256 price;\r\n        // The account that will receive sales revenue.\r\n        address payable fundingRecipient;\r\n        // The number of tokens sold so far.\r\n        uint256 numSold;\r\n        // The content hash of the image being presented.\r\n        bytes32 contentHash;\r\n    }\r\n\r\n    // A subset of Edition, for efficient production of multiple editions.\r\n    struct EditionTier {\r\n        // The maximum number of tokens that can be sold.\r\n        uint256 quantity;\r\n        // The price at which each token will be sold, in ETH.\r\n        uint256 price;\r\n        bytes32 contentHash;\r\n    }\r\n\r\n    mapping(address => uint256) public fundingBalance;\r\n\r\n    // ============ Immutable Storage ============\r\n\r\n    // Fee updates take 2 days to take place, giving creators time to withdraw.\r\n    uint256 public immutable feeUpdateTimelock;\r\n\r\n    // ============ Mutable Storage ============\r\n\r\n    string internal baseURI;\r\n    // Mapping of edition id to descriptive data.\r\n    mapping(uint256 => Edition) public editions;\r\n    // Mapping of token id to edition id.\r\n    mapping(uint256 => uint256) public tokenToEdition;\r\n    // The amount of funds that have already been withdrawn for a given edition.\r\n    mapping(uint256 => uint256) public withdrawnForEdition;\r\n    // `nextTokenId` increments with each token purchased, globally across all editions.\r\n    uint256 private nextTokenId;\r\n    // Editions start at 1, in order that unsold tokens don't map to the first edition.\r\n    uint256 private nextEditionId = 1;\r\n    // Withdrawals include a fee, specified as a percentage.\r\n    uint16 public feePercent;\r\n    // The address that holds fees.\r\n    address payable public treasury;\r\n    uint256 public feesAccrued;\r\n    // Timelock information.\r\n    uint256 public nextFeeUpdateTime;\r\n    uint16 public nextFeePercent;\r\n    // Reentrancy\r\n    uint256 internal reentrancyStatus;\r\n\r\n    address public owner;\r\n    address public nextOwner;\r\n\r\n    // ============ Events ============\r\n\r\n    event EditionCreated(\r\n        uint256 quantity,\r\n        uint256 price,\r\n        address fundingRecipient,\r\n        uint256 indexed editionId,\r\n        bytes32 contentHash\r\n    );\r\n\r\n    event EditionPurchased(\r\n        uint256 indexed editionId,\r\n        uint256 indexed tokenId,\r\n        // `numSold` at time of purchase represents the \"serial number\" of the NFT.\r\n        uint256 numSold,\r\n        uint256 amountPaid,\r\n        // The account that paid for and received the NFT.\r\n        address indexed buyer\r\n    );\r\n\r\n    event FundsWithdrawn(\r\n        address fundingRecipient,\r\n        uint256 amountWithdrawn,\r\n        uint256 feeAmount\r\n    );\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    event FeesWithdrawn(uint256 feesAccrued, address sender);\r\n\r\n    event FeeUpdateQueued(uint256 newFee, address sender);\r\n\r\n    event FeeUpdated(uint256 feePercent, address sender);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(reentrancyStatus != REENTRANCY_ENTERED, \"Reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        reentrancyStatus = REENTRANCY_ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        reentrancyStatus = REENTRANCY_NOT_ENTERED;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"caller is not the owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyNextOwner() {\r\n        require(isNextOwner(), \"current owner must set caller as next owner.\");\r\n        _;\r\n    }\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        string memory baseURI_,\r\n        address payable treasury_,\r\n        uint16 initialFee,\r\n        uint256 feeUpdateTimelock_,\r\n        address owner_\r\n    ) {\r\n        baseURI = baseURI_;\r\n        treasury = treasury_;\r\n        feePercent = initialFee;\r\n        feeUpdateTimelock = feeUpdateTimelock_;\r\n        owner = owner_;\r\n    }\r\n\r\n    // ============ Edition Methods ============\r\n\r\n    function createEditionTiers(\r\n        EditionTier[] memory tiers,\r\n        address payable fundingRecipient\r\n    ) external nonReentrant {\r\n        // Execute a loop that creates editions.\r\n        for (uint8 i = 0; i < tiers.length; i++) {\r\n            uint256 quantity = tiers[i].quantity;\r\n            uint256 price = tiers[i].price;\r\n            bytes32 contentHash = tiers[i].contentHash;\r\n\r\n            editions[nextEditionId] = Edition({\r\n                quantity: quantity,\r\n                price: price,\r\n                fundingRecipient: fundingRecipient,\r\n                numSold: 0,\r\n                contentHash: contentHash\r\n            });\r\n\r\n            emit EditionCreated(\r\n                quantity,\r\n                price,\r\n                fundingRecipient,\r\n                nextEditionId,\r\n                contentHash\r\n            );\r\n\r\n            nextEditionId++;\r\n        }\r\n    }\r\n\r\n    function createEdition(\r\n        // The number of tokens that can be minted and sold.\r\n        uint256 quantity,\r\n        // The price to purchase a token.\r\n        uint256 price,\r\n        // The account that should receive the revenue.\r\n        address payable fundingRecipient,\r\n        // Content hash is emitted in the event, for UI convenience.\r\n        bytes32 contentHash\r\n    ) external nonReentrant {\r\n        editions[nextEditionId] = Edition({\r\n            quantity: quantity,\r\n            price: price,\r\n            fundingRecipient: fundingRecipient,\r\n            numSold: 0,\r\n            contentHash: contentHash\r\n        });\r\n\r\n        emit EditionCreated(\r\n            quantity,\r\n            price,\r\n            fundingRecipient,\r\n            nextEditionId,\r\n            contentHash\r\n        );\r\n\r\n        nextEditionId++;\r\n    }\r\n\r\n    function buyEdition(uint256 editionId) external payable nonReentrant {\r\n        // Check that the edition exists. Note: this is redundant\r\n        // with the next check, but it is useful for clearer error messaging.\r\n        require(editions[editionId].quantity > 0, \"Edition does not exist\");\r\n        // Check that there are still tokens available to purchase.\r\n        require(\r\n            editions[editionId].numSold < editions[editionId].quantity,\r\n            \"This edition is already sold out.\"\r\n        );\r\n        // Check that the sender is paying the correct amount.\r\n        require(\r\n            msg.value >= editions[editionId].price,\r\n            \"Must send enough to purchase the edition.\"\r\n        );\r\n        // Increment the number of tokens sold for this edition.\r\n        editions[editionId].numSold++;\r\n        fundingBalance[editions[editionId].fundingRecipient] += msg.value;\r\n        // Mint a new token for the sender, using the `nextTokenId`.\r\n        _mint(msg.sender, nextTokenId);\r\n        // Store the mapping of token id to the edition being purchased.\r\n        tokenToEdition[nextTokenId] = editionId;\r\n\r\n        emit EditionPurchased(\r\n            editionId,\r\n            nextTokenId,\r\n            editions[editionId].numSold,\r\n            msg.value,\r\n            msg.sender\r\n        );\r\n\r\n        nextTokenId++;\r\n    }\r\n\r\n    // ============ Operational Methods ============\r\n\r\n    function withdrawFunds(address payable fundingRecipient)\r\n        external\r\n        nonReentrant\r\n    {\r\n        uint256 remaining = fundingBalance[fundingRecipient];\r\n        fundingBalance[fundingRecipient] = 0;\r\n\r\n        if (feePercent > 0) {\r\n            // Send the amount that was remaining for the edition, to the funding recipient.\r\n            uint256 fee = computeFee(remaining);\r\n            // Allocate fee to the treasury.\r\n            feesAccrued += fee;\r\n            // Send the remainder to the funding recipient.\r\n            _sendFunds(fundingRecipient, remaining - fee);\r\n            emit FundsWithdrawn(fundingRecipient, remaining - fee, fee);\r\n        } else {\r\n            _sendFunds(fundingRecipient, remaining);\r\n            emit FundsWithdrawn(fundingRecipient, remaining, 0);\r\n        }\r\n    }\r\n\r\n    function computeFee(uint256 _amount) public view returns (uint256) {\r\n        return (_amount * feePercent) / 100;\r\n    }\r\n\r\n    // ============ Admin Methods ============\r\n\r\n    function withdrawFees() public {\r\n        _sendFunds(treasury, feesAccrued);\r\n        emit FeesWithdrawn(feesAccrued, msg.sender);\r\n        feesAccrued = 0;\r\n    }\r\n\r\n    function updateTreasury(address payable newTreasury) public {\r\n        require(msg.sender == treasury, \"Only available to current treasury\");\r\n        treasury = newTreasury;\r\n    }\r\n\r\n    function queueFeeUpdate(uint16 newFee) public {\r\n        require(msg.sender == treasury, \"Only available to treasury\");\r\n        nextFeeUpdateTime = block.timestamp + feeUpdateTimelock;\r\n        nextFeePercent = newFee;\r\n        emit FeeUpdateQueued(newFee, msg.sender);\r\n    }\r\n\r\n    function executeFeeUpdate() public {\r\n        require(msg.sender == treasury, \"Only available to current treasury\");\r\n        require(\r\n            block.timestamp >= nextFeeUpdateTime,\r\n            \"Timelock hasn't elapsed\"\r\n        );\r\n        feePercent = nextFeePercent;\r\n        nextFeePercent = 0;\r\n        nextFeeUpdateTime = 0;\r\n        emit FeeUpdated(feePercent, msg.sender);\r\n    }\r\n\r\n    function changeBaseURI(string memory baseURI_) public onlyOwner {\r\n        baseURI = baseURI_;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == owner;\r\n    }\r\n\r\n    function isNextOwner() public view returns (bool) {\r\n        return msg.sender == nextOwner;\r\n    }\r\n\r\n    function transferOwnership(address nextOwner_) external onlyOwner {\r\n        require(nextOwner_ != address(0), \"Next owner is the zero address.\");\r\n\r\n        nextOwner = nextOwner_;\r\n    }\r\n\r\n    function cancelOwnershipTransfer() external onlyOwner {\r\n        delete nextOwner;\r\n    }\r\n\r\n    function acceptOwnership() external onlyNextOwner {\r\n        delete nextOwner;\r\n\r\n        emit OwnershipTransferred(owner, msg.sender);\r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function renounceOwnership() external onlyOwner {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n\r\n    // ============ NFT Methods ============\r\n\r\n    // Returns e.g. https://mirror-api.com/editions/[editionId]/[tokenId]\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (string memory)\r\n    {\r\n        // If the token does not map to an edition, it'll be 0.\r\n        require(tokenToEdition[tokenId] > 0, \"Token has not been sold yet\");\r\n        // Concatenate the components, baseURI, editionId and tokenId, to create URI.\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    baseURI,\r\n                    _toString(tokenToEdition[tokenId]),\r\n                    \"/\",\r\n                    _toString(tokenId)\r\n                )\r\n            );\r\n    }\r\n\r\n    // The hash of the given content for the NFT. Can be used\r\n    // for IPFS storage, verifying authenticity, etc.\r\n    function contentHash(uint256 tokenId) public view returns (bytes32) {\r\n        // If the token does not map to an edition, it'll be 0.\r\n        require(tokenToEdition[tokenId] > 0, \"Token has not been sold yet\");\r\n        // Concatenate the components, baseURI, editionId and tokenId, to create URI.\r\n        return editions[tokenToEdition[tokenId]].contentHash;\r\n    }\r\n\r\n    // Returns e.g. https://mirror-api.com/editions/metadata\r\n    function contractURI() public view returns (string memory) {\r\n        // Concatenate the components, baseURI, editionId and tokenId, to create URI.\r\n        return string(abi.encodePacked(baseURI, \"metadata\"));\r\n    }\r\n\r\n    function getRoyaltyRecipient(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        require(tokenToEdition[tokenId] > 0, \"Token has not been minted yet\");\r\n        return editions[tokenToEdition[tokenId]].fundingRecipient;\r\n    }\r\n\r\n    function setRoyaltyRecipient(\r\n        uint256 editionId,\r\n        address payable newFundingRecipient\r\n    ) public {\r\n        require(\r\n            editions[editionId].fundingRecipient == msg.sender,\r\n            \"Only current fundingRecipient can modify its value\"\r\n        );\r\n\r\n        editions[editionId].fundingRecipient = newFundingRecipient;\r\n    }\r\n\r\n    // ============ Private Methods ============\r\n\r\n    function _sendFunds(address payable recipient, uint256 amount) private {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Insufficient balance for send\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Unable to send value: recipient may have reverted\");\r\n    }\r\n\r\n    // From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\r\n    function _toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"treasury_\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"initialFee\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"feeUpdateTimelock_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundingRecipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"contentHash\",\"type\":\"bytes32\"}],\"name\":\"EditionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"EditionPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"FeeUpdateQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"FeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feesAccrued\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"FeesWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundingRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"}],\"name\":\"buyEdition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"changeBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"computeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"contentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"fundingRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"contentHash\",\"type\":\"bytes32\"}],\"name\":\"createEdition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"contentHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct Editions.EditionTier[]\",\"name\":\"tiers\",\"type\":\"tuple[]\"},{\"internalType\":\"address payable\",\"name\":\"fundingRecipient\",\"type\":\"address\"}],\"name\":\"createEditionTiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"editions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"fundingRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numSold\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"contentHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeFeeUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeUpdateTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fundingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextFeePercent\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextFeeUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newFee\",\"type\":\"uint16\"}],\"name\":\"queueFeeUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"newFundingRecipient\",\"type\":\"address\"}],\"name\":\"setRoyaltyRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenToEdition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"updateTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"fundingRecipient\",\"type\":\"address\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawnForEdition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Editions","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000d5ca42b27f5b37da1b08dba71a53056b0c9392040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002a3000000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b57000000000000000000000000000000000000000000000000000000000000002368747470733a2f2f6d6972726f722d6170692e636f6d2f65646974696f6e732f76322f0000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d7c20a8f3da38ccd4c4b81eade51e3acaf64c837f6d7237e73b8883537cb16ee"}]}