{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Copied and adjusted from OpenZeppelin\\r\\n// Adjustments:\\r\\n// - modifications to support ERC-677\\r\\n// - removed require messages to save space\\r\\n// - removed unnecessary require statements\\r\\n// - removed GSN Context\\r\\n// - upgraded to 0.8 to drop SafeMath\\r\\n// - let name() and symbol() be implemented by subclass\\r\\n// - infinite allowance support, with 2^255 and above considered infinite\\r\\n\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IERC677Receiver.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the `IERC20` interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\r\\n * For a generic mechanism see `ERC20Mintable`.\\r\\n *\\r\\n * *For a detailed writeup see our guide [How to implement supply\\r\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn\\u0027t required by the specification.\\r\\n *\\r\\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See `IERC20.approve`.\\r\\n */\\r\\n\\r\\nabstract contract ERC20 is IERC20 {\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    uint8 public override decimals;\\r\\n\\r\\n    constructor(uint8 _decimals) {\\r\\n        decimals = _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.totalSupply`.\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.balanceOf`.\\r\\n     */\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.transfer`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.allowance`.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.approve`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) public override returns (bool) {\\r\\n        _approve(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.transferFrom`.\\r\\n     *\\r\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `value`.\\r\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\r\\n        if (currentAllowance \\u003c (1 \\u003c\\u003c 255)){\\r\\n            // Only decrease the allowance if it was not set to \\u0027infinite\\u0027\\r\\n            // Documented in /doc/infiniteallowance.md\\r\\n            _approve(sender, msg.sender, currentAllowance - amount);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to `transfer`, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(recipient != address(0));\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] -= amount;\\r\\n        _balances[recipient] += amount;\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    // ERC-677 functionality, can be useful for swapping and wrapping tokens\\r\\n    function transferAndCall(address recipient, uint amount, bytes calldata data) public returns (bool) {\\r\\n        bool success = transfer(recipient, amount);\\r\\n        if (success){\\r\\n            success = IERC677Receiver(recipient).onTokenTransfer(msg.sender, amount, data);\\r\\n        }\\r\\n        return success;\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a `Transfer` event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address recipient, uint256 amount) internal virtual {\\r\\n        require(recipient != address(0));\\r\\n\\r\\n        _beforeTokenTransfer(address(0), recipient, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[recipient] += amount;\\r\\n        emit Transfer(address(0), recipient, amount);\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a `Transfer` event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _totalSupply -= amount;\\r\\n        _balances[account] -= amount;\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 value) internal {\\r\\n        _allowances[owner][spender] = value;\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual internal {\\r\\n    }\\r\\n}\"},\"ERC20Recoverable.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\r\\n*\\r\\n* MIT License with Automated License Fee Payments\\r\\n*\\r\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\r\\n*\\r\\n* Permission is hereby granted to any person obtaining a copy of this software\\r\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\r\\n* without restriction, including without limitation the rights to use, copy,\\r\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\r\\n* Software, and to permit persons to whom the Software is furnished to do so,\\r\\n* subject to the following conditions:\\r\\n*\\r\\n* - The above copyright notice and this permission notice shall be included in\\r\\n*   all copies or substantial portions of the Software.\\r\\n* - All automated license fee payments integrated into this and related Software\\r\\n*   are preserved.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n* SOFTWARE.\\r\\n*/\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Recoverable\\r\\n * In case of tokens that represent real-world assets such as shares of a company, one needs a way\\r\\n * to handle lost private keys. With physical certificates, courts can declare share certificates as\\r\\n * invalid so the company can issue replacements. Here, we want a solution that does not depend on\\r\\n * third parties to resolve such cases. Instead, when someone has lost a private key, he can use the\\r\\n * declareLost function to post a deposit and claim that the shares assigned to a specific address are\\r\\n * lost. To prevent front running, a commit reveal scheme is used. If he actually is the owner of the shares,\\r\\n * he needs to wait for a certain period and can then reclaim the lost shares as well as the deposit.\\r\\n * If he is an attacker trying to claim shares belonging to someone else, he risks losing the deposit\\r\\n * as it can be claimed at anytime by the rightful owner.\\r\\n * Furthermore, if \\\"getClaimDeleter\\\" is defined in the subclass, the returned address is allowed to\\r\\n * delete claims, returning the collateral. This can help to prevent obvious cases of abuse of the claim\\r\\n * function.\\r\\n */\\r\\n\\r\\nabstract contract ERC20Recoverable is ERC20 {\\r\\n\\r\\n    // A struct that represents a claim made\\r\\n    struct Claim {\\r\\n        address claimant; // the person who created the claim\\r\\n        uint256 collateral; // the amount of collateral deposited\\r\\n        uint256 timestamp;  // the timestamp of the block in which the claim was made\\r\\n        address currencyUsed; // The currency (XCHF) can be updated, we record the currency used for every request\\r\\n    }\\r\\n\\r\\n    uint256 public constant claimPeriod = 180 days;\\r\\n\\r\\n    mapping(address =\\u003e Claim) public claims; // there can be at most one claim per address, here address is claimed address\\r\\n    mapping(address =\\u003e bool) public recoveryDisabled; // disable claimability (e.g. for long term storage)\\r\\n\\r\\n    // ERC-20 token that can be used as collateral or 0x0 if disabled\\r\\n    address public customCollateralAddress;\\r\\n    uint256 public customCollateralRate;\\r\\n\\r\\n    /**\\r\\n     * Returns the collateral rate for the given collateral type and 0 if that type\\r\\n     * of collateral is not accepted. By default, only the token itself is accepted at\\r\\n     * a rate of 1:1.\\r\\n     *\\r\\n     * Subclasses should override this method if they want to add additional types of\\r\\n     * collateral.\\r\\n     */\\r\\n    function getCollateralRate(address collateralType) public virtual view returns (uint256) {\\r\\n        if (collateralType == address(this)) {\\r\\n            return 1;\\r\\n        } else if (collateralType == customCollateralAddress) {\\r\\n            return customCollateralRate;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Allows subclasses to set a custom collateral besides the token itself.\\r\\n     * The collateral must be an ERC-20 token that returns true on successful transfers and\\r\\n     * throws an exception or returns false on failure.\\r\\n     * Also, do not forget to multiply the rate in accordance with the number of decimals of the collateral.\\r\\n     * For example, rate should be 7*10**18 for 7 units of a collateral with 18 decimals.\\r\\n     */\\r\\n    function _setCustomClaimCollateral(address collateral, uint256 rate) internal {\\r\\n        customCollateralAddress = collateral;\\r\\n        if (customCollateralAddress == address(0)) {\\r\\n            customCollateralRate = 0; // disabled\\r\\n        } else {\\r\\n            require(rate \\u003e 0, \\\"zero\\\");\\r\\n            customCollateralRate = rate;\\r\\n        }\\r\\n        emit CustomClaimCollateralChanged(collateral, rate);\\r\\n    }\\r\\n\\r\\n    function getClaimDeleter() virtual public view returns (address);\\r\\n\\r\\n    function setRecoverable(bool enabled) public {\\r\\n        recoveryDisabled[msg.sender] = !enabled;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Some users might want to disable claims for their address completely.\\r\\n     * For example if they use a deep cold storage solution or paper wallet.\\r\\n     */\\r\\n    function isRecoveryEnabled(address target) public view returns (bool) {\\r\\n        return !recoveryDisabled[target];\\r\\n    }\\r\\n\\r\\n    event ClaimMade(address indexed lostAddress, address indexed claimant, uint256 balance);\\r\\n    event ClaimCleared(address indexed lostAddress, uint256 collateral);\\r\\n    event ClaimDeleted(address indexed lostAddress, address indexed claimant, uint256 collateral);\\r\\n    event ClaimResolved(address indexed lostAddress, address indexed claimant, uint256 collateral);\\r\\n    event CustomClaimCollateralChanged(address newCustomCollateralAddress, uint256 newCustomCollareralRate);\\r\\n\\r\\n  /** Anyone can declare that the private key to a certain address was lost by calling declareLost\\r\\n    * providing a deposit/collateral. There are three possibilities of what can happen with the claim:\\r\\n    * 1) The claim period expires and the claimant can get the deposit and the shares back by calling recover\\r\\n    * 2) The \\\"lost\\\" private key is used at any time to call clearClaim. In that case, the claim is deleted and\\r\\n    *    the deposit sent to the shareholder (the owner of the private key). It is recommended to call recover\\r\\n    *    whenever someone transfers funds to let claims be resolved automatically when the \\\"lost\\\" private key is\\r\\n    *    used again.\\r\\n    * 3) The owner deletes the claim and assigns the deposit to the claimant. This is intended to be used to resolve\\r\\n    *    disputes. Generally, using this function implies that you have to trust the issuer of the tokens to handle\\r\\n    *    the situation well. As a rule of thumb, the contract owner should assume the owner of the lost address to be the\\r\\n    *    rightful owner of the deposit.\\r\\n    * It is highly recommended that the owner observes the claims made and informs the owners of the claimed addresses\\r\\n    * whenever a claim is made for their address (this of course is only possible if they are known to the owner, e.g.\\r\\n    * through a shareholder register).\\r\\n    */\\r\\n    function declareLost(address collateralType, address lostAddress) public {\\r\\n        require(isRecoveryEnabled(lostAddress), \\\"disabled\\\");\\r\\n        uint256 collateralRate = getCollateralRate(collateralType);\\r\\n        require(collateralRate \\u003e 0, \\\"bad collateral\\\");\\r\\n        address claimant = msg.sender;\\r\\n        uint256 balance = balanceOf(lostAddress);\\r\\n        uint256 collateral = balance * collateralRate;\\r\\n        IERC20 currency = IERC20(collateralType);\\r\\n        require(balance \\u003e 0, \\\"empty\\\");\\r\\n        require(claims[lostAddress].collateral == 0, \\\"already claimed\\\");\\r\\n        require(currency.transferFrom(claimant, address(this), collateral));\\r\\n\\r\\n        claims[lostAddress] = Claim({\\r\\n            claimant: claimant,\\r\\n            collateral: collateral,\\r\\n            timestamp: block.timestamp,\\r\\n            currencyUsed: collateralType\\r\\n        });\\r\\n\\r\\n        emit ClaimMade(lostAddress, claimant, balance);\\r\\n    }\\r\\n\\r\\n    function getClaimant(address lostAddress) public view returns (address) {\\r\\n        return claims[lostAddress].claimant;\\r\\n    }\\r\\n\\r\\n    function getCollateral(address lostAddress) public view returns (uint256) {\\r\\n        return claims[lostAddress].collateral;\\r\\n    }\\r\\n\\r\\n    function getCollateralType(address lostAddress) public view returns (address) {\\r\\n        return claims[lostAddress].currencyUsed;\\r\\n    }\\r\\n\\r\\n    function getTimeStamp(address lostAddress) public view returns (uint256) {\\r\\n        return claims[lostAddress].timestamp;\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) override virtual public returns (bool) {\\r\\n        require(super.transfer(recipient, amount));\\r\\n        clearClaim();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Clears a claim after the key has been found again and assigns the collateral to the \\\"lost\\\" address.\\r\\n     * This is the price an adverse claimer pays for filing a false claim and makes it risky to do so.\\r\\n     */\\r\\n    function clearClaim() public {\\r\\n        if (claims[msg.sender].collateral != 0) {\\r\\n            uint256 collateral = claims[msg.sender].collateral;\\r\\n            IERC20 currency = IERC20(claims[msg.sender].currencyUsed);\\r\\n            delete claims[msg.sender];\\r\\n            require(currency.transfer(msg.sender, collateral));\\r\\n            emit ClaimCleared(msg.sender, collateral);\\r\\n        }\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * After the claim period has passed, the claimant can call this function to send the\\r\\n    * tokens on the lost address as well as the collateral to himself.\\r\\n    */\\r\\n    function recover(address lostAddress) public {\\r\\n        Claim memory claim = claims[lostAddress];\\r\\n        uint256 collateral = claim.collateral;\\r\\n        IERC20 currency = IERC20(claim.currencyUsed);\\r\\n        require(collateral != 0, \\\"not found\\\");\\r\\n        require(claim.claimant == msg.sender, \\\"not claimant\\\");\\r\\n        require(claim.timestamp + claimPeriod \\u003c= block.timestamp, \\\"too early\\\");\\r\\n        address claimant = claim.claimant;\\r\\n        delete claims[lostAddress];\\r\\n        require(currency.transfer(claimant, collateral));\\r\\n        _transfer(lostAddress, claimant, balanceOf(lostAddress));\\r\\n        emit ClaimResolved(lostAddress, claimant, collateral);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * This function is to be executed by the claim deleter only in case a dispute needs to be resolved manually.\\r\\n     */\\r\\n    function deleteClaim(address lostAddress) public {\\r\\n        require(msg.sender == getClaimDeleter(), \\\"no access\\\");\\r\\n        Claim memory claim = claims[lostAddress];\\r\\n        IERC20 currency = IERC20(claim.currencyUsed);\\r\\n        require(claim.collateral != 0, \\\"not found\\\");\\r\\n        delete claims[lostAddress];\\r\\n        require(currency.transfer(claim.claimant, claim.collateral));\\r\\n        emit ClaimDeleted(lostAddress, claim.claimant, claim.collateral);\\r\\n    }\\r\\n\\r\\n}\"},\"IERC20.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: MIT\\r\\n*\\r\\n* Copyright (c) 2016-2019 zOS Global Limited\\r\\n*\\r\\n*/\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see `ERC20Detailed`.\\r\\n */\\r\\n\\r\\ninterface IERC20 {\\r\\n\\r\\n    // Optional functions\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when `approve` or `transferFrom` are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to `approve`. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"IERC677Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\ninterface IERC677Receiver {\\r\\n    \\r\\n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\\r\\n\\r\\n}\"},\"IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\ninterface IOwnable {\\r\\n\\r\\n    function owner() external returns (address);\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(this.owner() == msg.sender, \\\"not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n//\\r\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\r\\n//\\r\\n// Modifications:\\r\\n// - Replaced Context._msgSender() with msg.sender\\r\\n// - Made leaner\\r\\n// - Extracted interface\\r\\n\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./IOwnable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is IOwnable {\\r\\n\\r\\n    address public override owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        emit OwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n}\"},\"Shares.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\r\\n*\\r\\n* MIT License with Automated License Fee Payments\\r\\n*\\r\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\r\\n*\\r\\n* Permission is hereby granted to any person obtaining a copy of this software\\r\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\r\\n* without restriction, including without limitation the rights to use, copy,\\r\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\r\\n* Software, and to permit persons to whom the Software is furnished to do so,\\r\\n* subject to the following conditions:\\r\\n*\\r\\n* - The above copyright notice and this permission notice shall be included in\\r\\n*   all copies or substantial portions of the Software.\\r\\n* - All automated license fee payments integrated into this and related Software\\r\\n*   are preserved.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n* SOFTWARE.\\r\\n*/\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./ERC20Recoverable.sol\\\";\\r\\nimport \\\"./IERC677Receiver.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title CompanyName AG Shares\\r\\n * @author Luzius Meisser, luzius@aktionariat.com\\r\\n *\\r\\n * These tokens are uncertified shares (Wertrechte according to the Swiss code of obligations),\\r\\n * with this smart contract serving as onwership registry (Wertrechtebuch), but not as shareholder\\r\\n * registry, which is kept separate and run by the company. This is equivalent to the traditional system\\r\\n * of having physical share certificates kept at home by the shareholders and a shareholder registry run by\\r\\n * the company. Just like with physical certificates, the owners of the tokens are the owners of the shares.\\r\\n * However, in order to exercise their rights (for example receive a dividend), shareholders must register\\r\\n * with the company. For example, in case the company pays out a dividend to a previous shareholder because\\r\\n * the current shareholder did not register, the company cannot be held liable for paying the dividend to\\r\\n * the \\\"wrong\\\" shareholder. In relation to the company, only the registered shareholders count as such.\\r\\n * Registration requires setting up an account with ledgy.com providing your name and address and proving\\r\\n * ownership over your addresses.\\r\\n * @notice The main addition is a functionality that allows the user to claim that the key for a certain address is lost.\\r\\n * @notice In order to prevent malicious attempts, a collateral needs to be posted.\\r\\n * @notice The contract owner can delete claims in case of disputes.\\r\\n */\\r\\ncontract Shares is ERC20Recoverable, Ownable {\\r\\n\\r\\n    string public override name;\\r\\n    string public override symbol;\\r\\n    string public terms;\\r\\n\\r\\n    uint256 public totalShares = 0; // total number of shares, maybe not all tokenized\\r\\n    uint256 public invalidTokens = 0;\\r\\n\\r\\n    event Announcement(string message);\\r\\n    event TokensDeclaredInvalid(address indexed holder, uint256 amount, string message);\\r\\n    event SubRegisterRecognized(address contractAddress);\\r\\n\\r\\n    constructor(string memory _symbol, string memory _name, string memory _terms, uint256 _totalShares) ERC20(0) Ownable() {\\r\\n        symbol = _symbol;\\r\\n        name = _name;\\r\\n        totalShares = _totalShares;\\r\\n        terms = _terms;\\r\\n    }\\r\\n\\r\\n    function setName(string memory _symbol, string memory _name) public onlyOwner {\\r\\n        symbol = _symbol;\\r\\n        name = _name;\\r\\n    }\\r\\n\\r\\n    function setTerms(string memory _terms) public onlyOwner {\\r\\n        terms = _terms;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Declares the number of total shares, including those that have not been tokenized and those\\r\\n     * that are held by the company itself. This number can be substiantially higher than totalSupply()\\r\\n     * in case not all shares have been tokenized. Also, it can be lower than totalSupply() in case some\\r\\n     * tokens have become invalid.\\r\\n     */\\r\\n    function setTotalShares(uint256 _newTotalShares) public onlyOwner() {\\r\\n        require(_newTotalShares \\u003e= totalValidSupply(), \\\"below supply\\\");\\r\\n        totalShares = _newTotalShares;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Sometimes, tokens are held by other smart contracts that serve as registers themselves. These could\\r\\n     * be our draggable contract, it could be a bridget to another blockchain, or it could be an address\\r\\n     * that belongs to a recognized custodian.\\r\\n     * We assume that the number of sub registers stays limited, such that they are safe to iterate.\\r\\n     * Subregisters should always have the same number of decimals as the main register and their total\\r\\n     * balance must not exceed the number of tokens assigned to the subregister.\\r\\n     * In order to preserve FIFO-rules meaningfully, subregisters should be empty when added or removed.\\r\\n     */\\r\\n    function recognizeSubRegister(address contractAddress) public onlyOwner () {\\r\\n        emit SubRegisterRecognized(contractAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Allows the issuer to make public announcements that are visible on the blockchain.\\r\\n     */\\r\\n    function announcement(string calldata message) external onlyOwner() {\\r\\n        emit Announcement(message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * See parent method for collateral requirements.\\r\\n     */\\r\\n    function setCustomClaimCollateral(address collateral, uint256 rate) public onlyOwner() {\\r\\n        super._setCustomClaimCollateral(collateral, rate);\\r\\n    }\\r\\n\\r\\n    function getClaimDeleter() public override view returns (address) {\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Signals that the indicated tokens have been declared invalid (e.g. by a court ruling in accordance\\r\\n     * with article 973g of the Swiss Code of Obligations) and got detached from\\r\\n     * the underlying shares. Invalid tokens do not carry any shareholder rights any more.\\r\\n     *\\r\\n     * This function is purely declarative. It does not technically immobilize the affected tokens as\\r\\n     * that would give the issuer too much power.\\r\\n     */\\r\\n    function declareInvalid(address holder, uint256 amount, string calldata message) external onlyOwner() {\\r\\n        uint256 holderBalance = balanceOf(holder);\\r\\n        require(amount \\u003c= holderBalance);\\r\\n        invalidTokens += amount;\\r\\n        emit TokensDeclaredInvalid(holder, amount, message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * The total number of valid tokens in circulation. In case some tokens have been declared invalid, this\\r\\n     * number might be lower than totalSupply(). Also, it will always be lower than or equal to totalShares().\\r\\n     */\\r\\n    function totalValidSupply() public view returns (uint256) {\\r\\n        return totalSupply() - invalidTokens;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Allows the company to tokenize shares. If these shares are newly created, setTotalShares must be\\r\\n     * called first in order to adjust the total number of shares.\\r\\n     */\\r\\n    function mint(address shareholder, uint256 _amount) public onlyOwner() {\\r\\n        _mint(shareholder, _amount);\\r\\n    }\\r\\n\\r\\n    function mintAndCall(address shareholder, address callee, uint256 amount, bytes calldata data) public {\\r\\n        mint(callee, amount);\\r\\n        IERC677Receiver(callee).onTokenTransfer(shareholder, amount, data);\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 amount) internal override {\\r\\n        require(totalValidSupply() + amount \\u003c= totalShares, \\\"There can\\u0027t be fewer shares than valid tokens\\\");\\r\\n        super._mint(account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfers _amount tokens to the company and burns them.\\r\\n     * The meaning of this operation depends on the circumstances and the fate of the shares does\\r\\n     * not necessarily follow the fate of the tokens. For example, the company itself might call\\r\\n     * this function to implement a formal decision to destroy some of the outstanding shares.\\r\\n     * Also, this function might be called by an owner to return the shares to the company and\\r\\n     * get them back in another form under an according agreement (e.g. printed certificates or\\r\\n     * tokens on a different blockchain). It is not recommended to call this function without\\r\\n     * having agreed with the company on the further fate of the shares in question.\\r\\n     */\\r\\n    function burn(uint256 _amount) public {\\r\\n        require(_amount \\u003c= balanceOf(msg.sender), \\\"Not enough shares available\\\");\\r\\n        _transfer(msg.sender, address(this), _amount);\\r\\n        _burn(address(this), _amount);\\r\\n    }\\r\\n\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_terms\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_totalShares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Announcement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ClaimMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCustomCollateralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomCollareralRate\",\"type\":\"uint256\"}],\"name\":\"CustomClaimCollateralChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"SubRegisterRecognized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"TokensDeclaredInvalid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"announcement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyUsed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customCollateralAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customCollateralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"declareInvalid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"declareLost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"deleteClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimDeleter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getClaimant\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getCollateralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getCollateralType\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invalidTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"isRecoveryEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mintAndCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"recognizeSubRegister\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"recoveryDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setCustomClaimCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setRecoverable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_terms\",\"type\":\"string\"}],\"name\":\"setTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTotalShares\",\"type\":\"uint256\"}],\"name\":\"setTotalShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalValidSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Shares","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000004504f5741000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011487964726f706f77657220426f6e642041000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001868747470733a2f2f66726967672d67726f75702e636f6d2f0000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d11ce9741a2efb7bd461b998abd721462778c8635e3fa1ac24ed0cd6956b3d87"}]}