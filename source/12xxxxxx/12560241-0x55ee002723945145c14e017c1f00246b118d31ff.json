{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\n// Sources flattened with hardhat v2.0.5 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol@v3.3.0\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Upgradeable {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol@v3.3.0\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMathUpgradeable {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol@v3.3.0\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) =\r\n            target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol@v3.3.0\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20Upgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n    using AddressUpgradeable for address;\r\n\r\n    function safeTransfer(\r\n        IERC20Upgradeable token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20Upgradeable token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20Upgradeable token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20Upgradeable token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance =\r\n            token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20Upgradeable token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance =\r\n            token.allowance(address(this), spender).sub(\r\n                value,\r\n                \"SafeERC20: decreased allowance below zero\"\r\n            );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data)\r\n        private\r\n    {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata =\r\n            address(token).functionCall(\r\n                data,\r\n                \"SafeERC20: low-level call failed\"\r\n            );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File contracts/interface/IInterestRateModelInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title dForce Lending Protocol's InterestRateModel Interface.\r\n * @author dForce Team.\r\n */\r\ninterface IInterestRateModelInterface {\r\n    function isInterestRateModel() external view returns (bool);\r\n\r\n    /**\r\n     * @dev Calculates the current borrow interest rate per block.\r\n     * @param cash The total amount of cash the market has.\r\n     * @param borrows The total amount of borrows the market has.\r\n     * @param reserves The total amnount of reserves the market has.\r\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18).\r\n     */\r\n    function getBorrowRate(\r\n        uint256 cash,\r\n        uint256 borrows,\r\n        uint256 reserves\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Calculates the current supply interest rate per block.\r\n     * @param cash The total amount of cash the market has.\r\n     * @param borrows The total amount of borrows the market has.\r\n     * @param reserves The total amnount of reserves the market has.\r\n     * @param reserveRatio The current reserve factor the market has.\r\n     * @return The supply rate per block (as a percentage, and scaled by 1e18).\r\n     */\r\n    function getSupplyRate(\r\n        uint256 cash,\r\n        uint256 borrows,\r\n        uint256 reserves,\r\n        uint256 reserveRatio\r\n    ) external view returns (uint256);\r\n}\r\n\r\n// File contracts/interface/IControllerInterface.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IControllerAdminInterface {\r\n    /// @notice Emitted when an admin supports a market\r\n    event MarketAdded(\r\n        address iToken,\r\n        uint256 collateralFactor,\r\n        uint256 borrowFactor,\r\n        uint256 supplyCapacity,\r\n        uint256 borrowCapacity,\r\n        uint256 distributionFactor\r\n    );\r\n\r\n    function _addMarket(\r\n        address _iToken,\r\n        uint256 _collateralFactor,\r\n        uint256 _borrowFactor,\r\n        uint256 _supplyCapacity,\r\n        uint256 _borrowCapacity,\r\n        uint256 _distributionFactor\r\n    ) external;\r\n\r\n    /// @notice Emitted when new price oracle is set\r\n    event NewPriceOracle(address oldPriceOracle, address newPriceOracle);\r\n\r\n    function _setPriceOracle(address newOracle) external;\r\n\r\n    /// @notice Emitted when close factor is changed by admin\r\n    event NewCloseFactor(\r\n        uint256 oldCloseFactorMantissa,\r\n        uint256 newCloseFactorMantissa\r\n    );\r\n\r\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external;\r\n\r\n    /// @notice Emitted when liquidation incentive is changed by admin\r\n    event NewLiquidationIncentive(\r\n        uint256 oldLiquidationIncentiveMantissa,\r\n        uint256 newLiquidationIncentiveMantissa\r\n    );\r\n\r\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)\r\n        external;\r\n\r\n    /// @notice Emitted when iToken's collateral factor is changed by admin\r\n    event NewCollateralFactor(\r\n        address iToken,\r\n        uint256 oldCollateralFactorMantissa,\r\n        uint256 newCollateralFactorMantissa\r\n    );\r\n\r\n    function _setCollateralFactor(\r\n        address iToken,\r\n        uint256 newCollateralFactorMantissa\r\n    ) external;\r\n\r\n    /// @notice Emitted when iToken's borrow factor is changed by admin\r\n    event NewBorrowFactor(\r\n        address iToken,\r\n        uint256 oldBorrowFactorMantissa,\r\n        uint256 newBorrowFactorMantissa\r\n    );\r\n\r\n    function _setBorrowFactor(address iToken, uint256 newBorrowFactorMantissa)\r\n        external;\r\n\r\n    /// @notice Emitted when iToken's borrow capacity is changed by admin\r\n    event NewBorrowCapacity(\r\n        address iToken,\r\n        uint256 oldBorrowCapacity,\r\n        uint256 newBorrowCapacity\r\n    );\r\n\r\n    function _setBorrowCapacity(address iToken, uint256 newBorrowCapacity)\r\n        external;\r\n\r\n    /// @notice Emitted when iToken's supply capacity is changed by admin\r\n    event NewSupplyCapacity(\r\n        address iToken,\r\n        uint256 oldSupplyCapacity,\r\n        uint256 newSupplyCapacity\r\n    );\r\n\r\n    function _setSupplyCapacity(address iToken, uint256 newSupplyCapacity)\r\n        external;\r\n\r\n    /// @notice Emitted when pause guardian is changed by admin\r\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n    function _setPauseGuardian(address newPauseGuardian) external;\r\n\r\n    /// @notice Emitted when mint is paused/unpaused by admin or pause guardian\r\n    event MintPaused(address iToken, bool paused);\r\n\r\n    function _setMintPaused(address iToken, bool paused) external;\r\n\r\n    function _setAllMintPaused(bool paused) external;\r\n\r\n    /// @notice Emitted when redeem is paused/unpaused by admin or pause guardian\r\n    event RedeemPaused(address iToken, bool paused);\r\n\r\n    function _setRedeemPaused(address iToken, bool paused) external;\r\n\r\n    function _setAllRedeemPaused(bool paused) external;\r\n\r\n    /// @notice Emitted when borrow is paused/unpaused by admin or pause guardian\r\n    event BorrowPaused(address iToken, bool paused);\r\n\r\n    function _setBorrowPaused(address iToken, bool paused) external;\r\n\r\n    function _setAllBorrowPaused(bool paused) external;\r\n\r\n    /// @notice Emitted when transfer is paused/unpaused by admin or pause guardian\r\n    event TransferPaused(bool paused);\r\n\r\n    function _setTransferPaused(bool paused) external;\r\n\r\n    /// @notice Emitted when seize is paused/unpaused by admin or pause guardian\r\n    event SeizePaused(bool paused);\r\n\r\n    function _setSeizePaused(bool paused) external;\r\n\r\n    function _setiTokenPaused(address iToken, bool paused) external;\r\n\r\n    function _setProtocolPaused(bool paused) external;\r\n\r\n    event NewRewardDistributor(\r\n        address oldRewardDistributor,\r\n        address _newRewardDistributor\r\n    );\r\n\r\n    function _setRewardDistributor(address _newRewardDistributor) external;\r\n}\r\n\r\ninterface IControllerPolicyInterface {\r\n    function beforeMint(\r\n        address iToken,\r\n        address account,\r\n        uint256 mintAmount\r\n    ) external;\r\n\r\n    function afterMint(\r\n        address iToken,\r\n        address minter,\r\n        uint256 mintAmount,\r\n        uint256 mintedAmount\r\n    ) external;\r\n\r\n    function beforeRedeem(\r\n        address iToken,\r\n        address redeemer,\r\n        uint256 redeemAmount\r\n    ) external;\r\n\r\n    function afterRedeem(\r\n        address iToken,\r\n        address redeemer,\r\n        uint256 redeemAmount,\r\n        uint256 redeemedAmount\r\n    ) external;\r\n\r\n    function beforeBorrow(\r\n        address iToken,\r\n        address borrower,\r\n        uint256 borrowAmount\r\n    ) external;\r\n\r\n    function afterBorrow(\r\n        address iToken,\r\n        address borrower,\r\n        uint256 borrowedAmount\r\n    ) external;\r\n\r\n    function beforeRepayBorrow(\r\n        address iToken,\r\n        address payer,\r\n        address borrower,\r\n        uint256 repayAmount\r\n    ) external;\r\n\r\n    function afterRepayBorrow(\r\n        address iToken,\r\n        address payer,\r\n        address borrower,\r\n        uint256 repayAmount\r\n    ) external;\r\n\r\n    function beforeLiquidateBorrow(\r\n        address iTokenBorrowed,\r\n        address iTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 repayAmount\r\n    ) external;\r\n\r\n    function afterLiquidateBorrow(\r\n        address iTokenBorrowed,\r\n        address iTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 repaidAmount,\r\n        uint256 seizedAmount\r\n    ) external;\r\n\r\n    function beforeSeize(\r\n        address iTokenBorrowed,\r\n        address iTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 seizeAmount\r\n    ) external;\r\n\r\n    function afterSeize(\r\n        address iTokenBorrowed,\r\n        address iTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 seizedAmount\r\n    ) external;\r\n\r\n    function beforeTransfer(\r\n        address iToken,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function afterTransfer(\r\n        address iToken,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function beforeFlashloan(\r\n        address iToken,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function afterFlashloan(\r\n        address iToken,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n}\r\n\r\ninterface IControllerAccountEquityInterface {\r\n    function calcAccountEquity(address account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address iTokenBorrowed,\r\n        address iTokenCollateral,\r\n        uint256 actualRepayAmount\r\n    ) external view returns (uint256);\r\n}\r\n\r\ninterface IControllerAccountInterface {\r\n    function hasEnteredMarket(address account, address iToken)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function getEnteredMarkets(address account)\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /// @notice Emitted when an account enters a market\r\n    event MarketEntered(address iToken, address account);\r\n\r\n    function enterMarkets(address[] calldata iTokens)\r\n        external\r\n        returns (bool[] memory);\r\n\r\n    /// @notice Emitted when an account exits a market\r\n    event MarketExited(address iToken, address account);\r\n\r\n    function exitMarkets(address[] calldata iTokens)\r\n        external\r\n        returns (bool[] memory);\r\n\r\n    /// @notice Emitted when an account add a borrow asset\r\n    event BorrowedAdded(address iToken, address account);\r\n\r\n    /// @notice Emitted when an account remove a borrow asset\r\n    event BorrowedRemoved(address iToken, address account);\r\n\r\n    function hasBorrowed(address account, address iToken)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function getBorrowedAssets(address account)\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n}\r\n\r\ninterface IControllerInterface is\r\n    IControllerAdminInterface,\r\n    IControllerPolicyInterface,\r\n    IControllerAccountEquityInterface,\r\n    IControllerAccountInterface\r\n{\r\n    /**\r\n     * @notice Security checks when updating the comptroller of a market, always expect to return true.\r\n     */\r\n    function isController() external view returns (bool);\r\n\r\n    /**\r\n     * @notice Return all of the iTokens\r\n     * @return The list of iToken addresses\r\n     */\r\n    function getAlliTokens() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Check whether a iToken is listed in controller\r\n     * @param _iToken The iToken to check for\r\n     * @return true if the iToken is listed otherwise false\r\n     */\r\n    function hasiToken(address _iToken) external view returns (bool);\r\n}\r\n\r\n// File contracts/interface/IiToken.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IiToken {\r\n    function isSupported() external returns (bool);\r\n\r\n    function isiToken() external returns (bool);\r\n\r\n    //----------------------------------\r\n    //********* User Interface *********\r\n    //----------------------------------\r\n    function mint(address recipient, uint256 mintAmount) external;\r\n\r\n    function redeem(address from, uint256 redeemTokens) external;\r\n\r\n    function redeemUnderlying(address from, uint256 redeemAmount) external;\r\n\r\n    function borrow(uint256 borrowAmount) external;\r\n\r\n    function repayBorrow(uint256 repayAmount) external;\r\n\r\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external;\r\n\r\n    function liquidateBorrow(\r\n        address borrower,\r\n        uint256 repayAmount,\r\n        address iTokenCollateral\r\n    ) external;\r\n\r\n    function flashloan(\r\n        address recipient,\r\n        uint256 loanAmount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function seize(\r\n        address _liquidator,\r\n        address _borrower,\r\n        uint256 _seizeTokens\r\n    ) external;\r\n\r\n    function updateInterest() external returns (bool);\r\n\r\n    function controller() external view returns (address);\r\n\r\n    function exchangeRateCurrent() external returns (uint256);\r\n\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n    function totalBorrowsCurrent() external returns (uint256);\r\n\r\n    function totalBorrows() external view returns (uint256);\r\n\r\n    function borrowBalanceCurrent(address _user) external returns (uint256);\r\n\r\n    function borrowBalanceStored(address _user) external view returns (uint256);\r\n\r\n    function borrowIndex() external view returns (uint256);\r\n\r\n    function getAccountSnapshot(address _account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function borrowRatePerBlock() external view returns (uint256);\r\n\r\n    function supplyRatePerBlock() external view returns (uint256);\r\n\r\n    function getCash() external view returns (uint256);\r\n\r\n    //----------------------------------\r\n    //********* Owner Actions **********\r\n    //----------------------------------\r\n\r\n    function _setNewReserveRatio(uint256 _newReserveRatio) external;\r\n\r\n    function _setNewFlashloanFeeRatio(uint256 _newFlashloanFeeRatio) external;\r\n\r\n    function _setNewProtocolFeeRatio(uint256 _newProtocolFeeRatio) external;\r\n\r\n    function _setController(IControllerInterface _newController) external;\r\n\r\n    function _setInterestRateModel(\r\n        IInterestRateModelInterface _newInterestRateModel\r\n    ) external;\r\n\r\n    function _withdrawReserves(uint256 _withdrawAmount) external;\r\n}\r\n\r\n// File contracts/interface/IRewardDistributorV3.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IRewardDistributorV3 {\r\n    function _setRewardToken(address newRewardToken) external;\r\n\r\n    /// @notice Emitted reward token address is changed by admin\r\n    event NewRewardToken(address oldRewardToken, address newRewardToken);\r\n\r\n    function _addRecipient(address _iToken, uint256 _distributionFactor)\r\n        external;\r\n\r\n    event NewRecipient(address iToken, uint256 distributionFactor);\r\n\r\n    /// @notice Emitted when mint is paused/unpaused by admin\r\n    event Paused(bool paused);\r\n\r\n    function _pause() external;\r\n\r\n    function _unpause(\r\n        address[] calldata _borrowiTokens,\r\n        uint256[] calldata _borrowSpeeds,\r\n        address[] calldata _supplyiTokens,\r\n        uint256[] calldata _supplySpeeds\r\n    ) external;\r\n\r\n    /// @notice Emitted when Global Distribution speed for both supply and borrow are updated\r\n    event GlobalDistributionSpeedsUpdated(\r\n        uint256 borrowSpeed,\r\n        uint256 supplySpeed\r\n    );\r\n\r\n    /// @notice Emitted when iToken's Distribution borrow speed is updated\r\n    event DistributionBorrowSpeedUpdated(address iToken, uint256 borrowSpeed);\r\n\r\n    /// @notice Emitted when iToken's Distribution supply speed is updated\r\n    event DistributionSupplySpeedUpdated(address iToken, uint256 supplySpeed);\r\n\r\n    /// @notice Emitted when iToken's Distribution factor is changed by admin\r\n    event NewDistributionFactor(\r\n        address iToken,\r\n        uint256 oldDistributionFactorMantissa,\r\n        uint256 newDistributionFactorMantissa\r\n    );\r\n\r\n    function updateDistributionState(address _iToken, bool _isBorrow) external;\r\n\r\n    function updateReward(\r\n        address _iToken,\r\n        address _account,\r\n        bool _isBorrow\r\n    ) external;\r\n\r\n    function updateRewardBatch(\r\n        address[] memory _holders,\r\n        address[] memory _iTokens\r\n    ) external;\r\n\r\n    function claimReward(address[] memory _holders, address[] memory _iTokens)\r\n        external;\r\n\r\n    function claimAllReward(address[] memory _holders) external;\r\n\r\n    /// @notice Emitted when reward of amount is distributed into account\r\n    event RewardDistributed(\r\n        address iToken,\r\n        address account,\r\n        uint256 amount,\r\n        uint256 accountIndex\r\n    );\r\n}\r\n\r\n// File contracts/interface/IPriceOracle.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IPriceOracle {\r\n    /**\r\n     * @notice Get the underlying price of a iToken asset\r\n     * @param _iToken The iToken to get the underlying price of\r\n     * @return The underlying asset price mantissa (scaled by 1e18).\r\n     *  Zero means the price is unavailable.\r\n     */\r\n    function getUnderlyingPrice(address _iToken)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Get the price of a underlying asset\r\n     * @param _iToken The iToken to get the underlying price of\r\n     * @return The underlying asset price mantissa (scaled by 1e18).\r\n     *  Zero means the price is unavailable and whether the price is valid.\r\n     */\r\n    function getUnderlyingPriceAndStatus(address _iToken)\r\n        external\r\n        view\r\n        returns (uint256, bool);\r\n}\r\n\r\n// File contracts/library/Initializable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(\r\n            !_initialized,\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n\r\n        _;\r\n\r\n        _initialized = true;\r\n    }\r\n}\r\n\r\n// File contracts/library/Ownable.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {_setPendingOwner} and {_acceptOwner}.\r\n */\r\ncontract Ownable {\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    address payable public owner;\r\n\r\n    /**\r\n     * @dev Returns the address of the current pending owner.\r\n     */\r\n    address payable public pendingOwner;\r\n\r\n    event NewOwner(address indexed previousOwner, address indexed newOwner);\r\n    event NewPendingOwner(\r\n        address indexed oldPendingOwner,\r\n        address indexed newPendingOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"onlyOwner: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal {\r\n        owner = msg.sender;\r\n        emit NewOwner(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Base on the inputing parameter `newPendingOwner` to check the exact error reason.\r\n     * @dev Transfer contract control to a new owner. The newPendingOwner must call `_acceptOwner` to finish the transfer.\r\n     * @param newPendingOwner New pending owner.\r\n     */\r\n    function _setPendingOwner(address payable newPendingOwner)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            newPendingOwner != address(0) && newPendingOwner != pendingOwner,\r\n            \"_setPendingOwner: New owenr can not be zero address and owner has been set!\"\r\n        );\r\n\r\n        // Gets current owner.\r\n        address oldPendingOwner = pendingOwner;\r\n\r\n        // Sets new pending owner.\r\n        pendingOwner = newPendingOwner;\r\n\r\n        emit NewPendingOwner(oldPendingOwner, newPendingOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Accepts the admin rights, but only for pendingOwenr.\r\n     */\r\n    function _acceptOwner() external {\r\n        require(\r\n            msg.sender == pendingOwner,\r\n            \"_acceptOwner: Only for pending owner!\"\r\n        );\r\n\r\n        // Gets current values for events.\r\n        address oldOwner = owner;\r\n        address oldPendingOwner = pendingOwner;\r\n\r\n        // Set the new contract owner.\r\n        owner = pendingOwner;\r\n\r\n        // Clear the pendingOwner.\r\n        pendingOwner = address(0);\r\n\r\n        emit NewOwner(oldOwner, owner);\r\n        emit NewPendingOwner(oldPendingOwner, pendingOwner);\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File contracts/library/SafeRatioMath.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary SafeRatioMath {\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    uint256 private constant BASE = 10**18;\r\n    uint256 private constant DOUBLE = 10**36;\r\n\r\n    function divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x.add(y.sub(1)).div(y);\r\n    }\r\n\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x.mul(y).div(BASE);\r\n    }\r\n\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x.mul(BASE).div(y);\r\n    }\r\n\r\n    function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x.mul(BASE).add(y.sub(1)).div(y);\r\n    }\r\n\r\n    function tmul(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 z\r\n    ) internal pure returns (uint256 result) {\r\n        result = x.mul(y).mul(z).div(DOUBLE);\r\n    }\r\n\r\n    function rpow(\r\n        uint256 x,\r\n        uint256 n,\r\n        uint256 base\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch x\r\n                case 0 {\r\n                    switch n\r\n                        case 0 {\r\n                            z := base\r\n                        }\r\n                        default {\r\n                            z := 0\r\n                        }\r\n                }\r\n                default {\r\n                    switch mod(n, 2)\r\n                        case 0 {\r\n                            z := base\r\n                        }\r\n                        default {\r\n                            z := x\r\n                        }\r\n                    let half := div(base, 2) // for rounding.\r\n\r\n                    for {\r\n                        n := div(n, 2)\r\n                    } n {\r\n                        n := div(n, 2)\r\n                    } {\r\n                        let xx := mul(x, x)\r\n                        if iszero(eq(div(xx, x), x)) {\r\n                            revert(0, 0)\r\n                        }\r\n                        let xxRound := add(xx, half)\r\n                        if lt(xxRound, xx) {\r\n                            revert(0, 0)\r\n                        }\r\n                        x := div(xxRound, base)\r\n                        if mod(n, 2) {\r\n                            let zx := mul(z, x)\r\n                            if and(\r\n                                iszero(iszero(x)),\r\n                                iszero(eq(div(zx, x), z))\r\n                            ) {\r\n                                revert(0, 0)\r\n                            }\r\n                            let zxRound := add(zx, half)\r\n                            if lt(zxRound, zx) {\r\n                                revert(0, 0)\r\n                            }\r\n                            z := div(zxRound, base)\r\n                        }\r\n                    }\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol@v3.3.0\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSetUpgradeable {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index)\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        require(\r\n            set._values.length > index,\r\n            \"EnumerableSet: index out of bounds\"\r\n        );\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n// File contracts/interface/IRewardDistributor.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IRewardDistributor {\r\n    function _setRewardToken(address newRewardToken) external;\r\n\r\n    /// @notice Emitted reward token address is changed by admin\r\n    event NewRewardToken(address oldRewardToken, address newRewardToken);\r\n\r\n    function _addRecipient(address _iToken, uint256 _distributionFactor)\r\n        external;\r\n\r\n    event NewRecipient(address iToken, uint256 distributionFactor);\r\n\r\n    /// @notice Emitted when mint is paused/unpaused by admin\r\n    event Paused(bool paused);\r\n\r\n    function _pause() external;\r\n\r\n    function _unpause(uint256 _borrowSpeed, uint256 _supplySpeed) external;\r\n\r\n    /// @notice Emitted when Global Distribution speed for both supply and borrow are updated\r\n    event GlobalDistributionSpeedsUpdated(\r\n        uint256 borrowSpeed,\r\n        uint256 supplySpeed\r\n    );\r\n\r\n    function _setGlobalDistributionSpeeds(\r\n        uint256 borrowSpeed,\r\n        uint256 supplySpeed\r\n    ) external;\r\n\r\n    /// @notice Emitted when iToken's Distribution speed is updated\r\n    event DistributionSpeedsUpdated(\r\n        address iToken,\r\n        uint256 borrowSpeed,\r\n        uint256 supplySpeed\r\n    );\r\n\r\n    function updateDistributionSpeed() external;\r\n\r\n    /// @notice Emitted when iToken's Distribution factor is changed by admin\r\n    event NewDistributionFactor(\r\n        address iToken,\r\n        uint256 oldDistributionFactorMantissa,\r\n        uint256 newDistributionFactorMantissa\r\n    );\r\n\r\n    function _setDistributionFactors(\r\n        address[] calldata iToken,\r\n        uint256[] calldata distributionFactors\r\n    ) external;\r\n\r\n    function updateDistributionState(address _iToken, bool _isBorrow) external;\r\n\r\n    function updateReward(\r\n        address _iToken,\r\n        address _account,\r\n        bool _isBorrow\r\n    ) external;\r\n\r\n    function updateRewardBatch(\r\n        address[] memory _holders,\r\n        address[] memory _iTokens\r\n    ) external;\r\n\r\n    function claimReward(address[] memory _holders, address[] memory _iTokens)\r\n        external;\r\n\r\n    function claimAllReward(address[] memory _holders) external;\r\n\r\n    /// @notice Emitted when reward of amount is distributed into account\r\n    event RewardDistributed(\r\n        address iToken,\r\n        address account,\r\n        uint256 amount,\r\n        uint256 accountIndex\r\n    );\r\n}\r\n\r\n// File contracts/Controller.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title dForce's lending controller Contract\r\n * @author dForce\r\n */\r\ncontract Controller is Initializable, Ownable, IControllerInterface {\r\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\r\n    using SafeRatioMath for uint256;\r\n    using SafeMathUpgradeable for uint256;\r\n    using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n    /// @dev EnumerableSet of all iTokens\r\n    EnumerableSetUpgradeable.AddressSet internal iTokens;\r\n\r\n    struct Market {\r\n        /*\r\n         *  Multiplier representing the most one can borrow against their collateral in this market.\r\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\r\n         *  Must be in [0, 0.9], and stored as a mantissa.\r\n         */\r\n        uint256 collateralFactorMantissa;\r\n        /*\r\n         *  Multiplier representing the most one can borrow the asset.\r\n         *  For instance, 0.5 to allow borrowing this asset 50% * collateral value * collateralFactor.\r\n         *  When calculating equity, 0.5 with 100 borrow balance will produce 200 borrow value\r\n         *  Must be between (0, 1], and stored as a mantissa.\r\n         */\r\n        uint256 borrowFactorMantissa;\r\n        /*\r\n         *  The borrow capacity of the asset, will be checked in beforeBorrow()\r\n         *  -1 means there is no limit on the capacity\r\n         *  0 means the asset can not be borrowed any more\r\n         */\r\n        uint256 borrowCapacity;\r\n        /*\r\n         *  The supply capacity of the asset, will be checked in beforeMint()\r\n         *  -1 means there is no limit on the capacity\r\n         *  0 means the asset can not be supplied any more\r\n         */\r\n        uint256 supplyCapacity;\r\n        // Whether market's mint is paused\r\n        bool mintPaused;\r\n        // Whether market's redeem is paused\r\n        bool redeemPaused;\r\n        // Whether market's borrow is paused\r\n        bool borrowPaused;\r\n    }\r\n\r\n    /// @notice Mapping of iTokens to corresponding markets\r\n    mapping(address => Market) public markets;\r\n\r\n    struct AccountData {\r\n        // Account's collateral assets\r\n        EnumerableSetUpgradeable.AddressSet collaterals;\r\n        // Account's borrowed assets\r\n        EnumerableSetUpgradeable.AddressSet borrowed;\r\n    }\r\n\r\n    /// @dev Mapping of accounts' data, including collateral and borrowed assets\r\n    mapping(address => AccountData) internal accountsData;\r\n\r\n    /**\r\n     * @notice Oracle to query the price of a given asset\r\n     */\r\n    address public priceOracle;\r\n\r\n    /**\r\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\r\n     */\r\n    uint256 public closeFactorMantissa;\r\n\r\n    // closeFactorMantissa must be strictly greater than this value\r\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\r\n\r\n    // closeFactorMantissa must not exceed this value\r\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    /**\r\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\r\n     */\r\n    uint256 public liquidationIncentiveMantissa;\r\n\r\n    // liquidationIncentiveMantissa must be no less than this value\r\n    uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\r\n\r\n    // liquidationIncentiveMantissa must be no greater than this value\r\n    uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\r\n\r\n    // collateralFactorMantissa must not exceed this value\r\n    uint256 internal constant collateralFactorMaxMantissa = 1e18; // 1.0\r\n\r\n    // borrowFactorMantissa must not exceed this value\r\n    uint256 internal constant borrowFactorMaxMantissa = 1e18; // 1.0\r\n\r\n    /**\r\n     * @notice Guardian who can pause mint/borrow/liquidate/transfer in case of emergency\r\n     */\r\n    address public pauseGuardian;\r\n\r\n    /// @notice whether global transfer is paused\r\n    bool public transferPaused;\r\n\r\n    /// @notice whether global seize is paused\r\n    bool public seizePaused;\r\n\r\n    /**\r\n     * @notice the address of reward distributor\r\n     */\r\n    address public rewardDistributor;\r\n\r\n    /**\r\n     * @dev Check if called by owner or pauseGuardian, and only owner can unpause\r\n     */\r\n    modifier checkPauser(bool _paused) {\r\n        require(\r\n            msg.sender == owner || (msg.sender == pauseGuardian && _paused),\r\n            \"Only owner and guardian can pause and only owner can unpause\"\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes the contract.\r\n     */\r\n    function initialize() external initializer {\r\n        __Ownable_init();\r\n    }\r\n\r\n    /*********************************/\r\n    /******** Security Check *********/\r\n    /*********************************/\r\n\r\n    /**\r\n     * @notice Ensure this is a Controller contract.\r\n     */\r\n    function isController() external view override returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /*********************************/\r\n    /******** Admin Operations *******/\r\n    /*********************************/\r\n\r\n    /**\r\n     * @notice Admin function to add iToken into supported markets\r\n     * Checks if the iToken already exsits\r\n     * Will `revert()` if any check fails\r\n     * @param _iToken The _iToken to add\r\n     * @param _collateralFactor The _collateralFactor of _iToken\r\n     * @param _borrowFactor The _borrowFactor of _iToken\r\n     * @param _supplyCapacity The _supplyCapacity of _iToken\r\n     * @param _distributionFactor The _distributionFactor of _iToken\r\n     */\r\n    function _addMarket(\r\n        address _iToken,\r\n        uint256 _collateralFactor,\r\n        uint256 _borrowFactor,\r\n        uint256 _supplyCapacity,\r\n        uint256 _borrowCapacity,\r\n        uint256 _distributionFactor\r\n    ) external override onlyOwner {\r\n        require(IiToken(_iToken).isSupported(), \"Token is not supported\");\r\n\r\n        // Market must not have been listed, EnumerableSet.add() will return false if it exsits\r\n        require(iTokens.add(_iToken), \"Token has already been listed\");\r\n\r\n        require(\r\n            _collateralFactor <= collateralFactorMaxMantissa,\r\n            \"Collateral factor invalid\"\r\n        );\r\n\r\n        require(\r\n            _borrowFactor > 0 && _borrowFactor <= borrowFactorMaxMantissa,\r\n            \"Borrow factor invalid\"\r\n        );\r\n\r\n        // Its value will be taken into account when calculate account equity\r\n        // Check if the price is available for the calculation\r\n        require(\r\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iToken) != 0,\r\n            \"Underlying price is unavailable\"\r\n        );\r\n\r\n        markets[_iToken] = Market({\r\n            collateralFactorMantissa: _collateralFactor,\r\n            borrowFactorMantissa: _borrowFactor,\r\n            borrowCapacity: _borrowCapacity,\r\n            supplyCapacity: _supplyCapacity,\r\n            mintPaused: false,\r\n            redeemPaused: false,\r\n            borrowPaused: false\r\n        });\r\n\r\n        IRewardDistributor(rewardDistributor)._addRecipient(\r\n            _iToken,\r\n            _distributionFactor\r\n        );\r\n\r\n        emit MarketAdded(\r\n            _iToken,\r\n            _collateralFactor,\r\n            _borrowFactor,\r\n            _supplyCapacity,\r\n            _borrowCapacity,\r\n            _distributionFactor\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Sets price oracle\r\n     * @dev Admin function to set price oracle\r\n     * @param _newOracle New oracle contract\r\n     */\r\n    function _setPriceOracle(address _newOracle) external override onlyOwner {\r\n        address _oldOracle = priceOracle;\r\n        require(\r\n            _newOracle != address(0) && _newOracle != _oldOracle,\r\n            \"Oracle address invalid\"\r\n        );\r\n        priceOracle = _newOracle;\r\n        emit NewPriceOracle(_oldOracle, _newOracle);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the closeFactor used when liquidating borrows\r\n     * @dev Admin function to set closeFactor\r\n     * @param _newCloseFactorMantissa New close factor, scaled by 1e18\r\n     */\r\n    function _setCloseFactor(uint256 _newCloseFactorMantissa)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _newCloseFactorMantissa >= closeFactorMinMantissa &&\r\n                _newCloseFactorMantissa <= closeFactorMaxMantissa,\r\n            \"Close factor invalid\"\r\n        );\r\n\r\n        uint256 _oldCloseFactorMantissa = closeFactorMantissa;\r\n        closeFactorMantissa = _newCloseFactorMantissa;\r\n        emit NewCloseFactor(_oldCloseFactorMantissa, _newCloseFactorMantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets liquidationIncentive\r\n     * @dev Admin function to set liquidationIncentive\r\n     * @param _newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n     */\r\n    function _setLiquidationIncentive(uint256 _newLiquidationIncentiveMantissa)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _newLiquidationIncentiveMantissa >=\r\n                liquidationIncentiveMinMantissa &&\r\n                _newLiquidationIncentiveMantissa <=\r\n                liquidationIncentiveMaxMantissa,\r\n            \"Liquidation incentive invalid\"\r\n        );\r\n\r\n        uint256 _oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n        liquidationIncentiveMantissa = _newLiquidationIncentiveMantissa;\r\n\r\n        emit NewLiquidationIncentive(\r\n            _oldLiquidationIncentiveMantissa,\r\n            _newLiquidationIncentiveMantissa\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the collateralFactor for a iToken\r\n     * @dev Admin function to set collateralFactor for a iToken\r\n     * @param _iToken The token to set the factor on\r\n     * @param _newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n     */\r\n    function _setCollateralFactor(\r\n        address _iToken,\r\n        uint256 _newCollateralFactorMantissa\r\n    ) external override onlyOwner {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        require(\r\n            _newCollateralFactorMantissa <= collateralFactorMaxMantissa,\r\n            \"Collateral factor invalid\"\r\n        );\r\n\r\n        // Its value will be taken into account when calculate account equity\r\n        // Check if the price is available for the calculation\r\n        require(\r\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iToken) != 0,\r\n            \"Failed to set collateral factor, underlying price is unavailable\"\r\n        );\r\n\r\n        Market storage _market = markets[_iToken];\r\n        uint256 _oldCollateralFactorMantissa = _market.collateralFactorMantissa;\r\n        _market.collateralFactorMantissa = _newCollateralFactorMantissa;\r\n\r\n        emit NewCollateralFactor(\r\n            _iToken,\r\n            _oldCollateralFactorMantissa,\r\n            _newCollateralFactorMantissa\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the borrowFactor for a iToken\r\n     * @dev Admin function to set borrowFactor for a iToken\r\n     * @param _iToken The token to set the factor on\r\n     * @param _newBorrowFactorMantissa The new borrow factor, scaled by 1e18\r\n     */\r\n    function _setBorrowFactor(address _iToken, uint256 _newBorrowFactorMantissa)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        require(\r\n            _newBorrowFactorMantissa > 0 &&\r\n                _newBorrowFactorMantissa <= borrowFactorMaxMantissa,\r\n            \"Borrow factor invalid\"\r\n        );\r\n\r\n        // Its value will be taken into account when calculate account equity\r\n        // Check if the price is available for the calculation\r\n        require(\r\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iToken) != 0,\r\n            \"Failed to set borrow factor, underlying price is unavailable\"\r\n        );\r\n\r\n        Market storage _market = markets[_iToken];\r\n        uint256 _oldBorrowFactorMantissa = _market.borrowFactorMantissa;\r\n        _market.borrowFactorMantissa = _newBorrowFactorMantissa;\r\n\r\n        emit NewBorrowFactor(\r\n            _iToken,\r\n            _oldBorrowFactorMantissa,\r\n            _newBorrowFactorMantissa\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the borrowCapacity for a iToken\r\n     * @dev Admin function to set borrowCapacity for a iToken\r\n     * @param _iToken The token to set the capacity on\r\n     * @param _newBorrowCapacity The new borrow capacity\r\n     */\r\n    function _setBorrowCapacity(address _iToken, uint256 _newBorrowCapacity)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        Market storage _market = markets[_iToken];\r\n        uint256 oldBorrowCapacity = _market.borrowCapacity;\r\n        _market.borrowCapacity = _newBorrowCapacity;\r\n\r\n        emit NewBorrowCapacity(_iToken, oldBorrowCapacity, _newBorrowCapacity);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the supplyCapacity for a iToken\r\n     * @dev Admin function to set supplyCapacity for a iToken\r\n     * @param _iToken The token to set the capacity on\r\n     * @param _newSupplyCapacity The new supply capacity\r\n     */\r\n    function _setSupplyCapacity(address _iToken, uint256 _newSupplyCapacity)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        Market storage _market = markets[_iToken];\r\n        uint256 oldSupplyCapacity = _market.supplyCapacity;\r\n        _market.supplyCapacity = _newSupplyCapacity;\r\n\r\n        emit NewSupplyCapacity(_iToken, oldSupplyCapacity, _newSupplyCapacity);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the pauseGuardian\r\n     * @dev Admin function to set pauseGuardian\r\n     * @param _newPauseGuardian The new pause guardian\r\n     */\r\n    function _setPauseGuardian(address _newPauseGuardian)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        address _oldPauseGuardian = pauseGuardian;\r\n\r\n        require(\r\n            _newPauseGuardian != address(0) &&\r\n                _newPauseGuardian != _oldPauseGuardian,\r\n            \"Pause guardian address invalid\"\r\n        );\r\n\r\n        pauseGuardian = _newPauseGuardian;\r\n\r\n        emit NewPauseGuardian(_oldPauseGuardian, _newPauseGuardian);\r\n    }\r\n\r\n    /**\r\n     * @notice pause/unpause mint() for all iTokens\r\n     * @dev Admin function, only owner and pauseGuardian can call this\r\n     * @param _paused whether to pause or unpause\r\n     */\r\n    function _setAllMintPaused(bool _paused)\r\n        external\r\n        override\r\n        checkPauser(_paused)\r\n    {\r\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\r\n        uint256 _len = _iTokens.length();\r\n\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _setMintPausedInternal(_iTokens.at(i), _paused);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice pause/unpause mint() for the iToken\r\n     * @dev Admin function, only owner and pauseGuardian can call this\r\n     * @param _iToken The iToken to pause/unpause\r\n     * @param _paused whether to pause or unpause\r\n     */\r\n    function _setMintPaused(address _iToken, bool _paused)\r\n        external\r\n        override\r\n        checkPauser(_paused)\r\n    {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        _setMintPausedInternal(_iToken, _paused);\r\n    }\r\n\r\n    function _setMintPausedInternal(address _iToken, bool _paused) internal {\r\n        markets[_iToken].mintPaused = _paused;\r\n        emit MintPaused(_iToken, _paused);\r\n    }\r\n\r\n    /**\r\n     * @notice pause/unpause redeem() for all iTokens\r\n     * @dev Admin function, only owner and pauseGuardian can call this\r\n     * @param _paused whether to pause or unpause\r\n     */\r\n    function _setAllRedeemPaused(bool _paused)\r\n        external\r\n        override\r\n        checkPauser(_paused)\r\n    {\r\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\r\n        uint256 _len = _iTokens.length();\r\n\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _setRedeemPausedInternal(_iTokens.at(i), _paused);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice pause/unpause redeem() for the iToken\r\n     * @dev Admin function, only owner and pauseGuardian can call this\r\n     * @param _iToken The iToken to pause/unpause\r\n     * @param _paused whether to pause or unpause\r\n     */\r\n    function _setRedeemPaused(address _iToken, bool _paused)\r\n        external\r\n        override\r\n        checkPauser(_paused)\r\n    {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        _setRedeemPausedInternal(_iToken, _paused);\r\n    }\r\n\r\n    function _setRedeemPausedInternal(address _iToken, bool _paused) internal {\r\n        markets[_iToken].redeemPaused = _paused;\r\n        emit RedeemPaused(_iToken, _paused);\r\n    }\r\n\r\n    /**\r\n     * @notice pause/unpause borrow() for all iTokens\r\n     * @dev Admin function, only owner and pauseGuardian can call this\r\n     * @param _paused whether to pause or unpause\r\n     */\r\n    function _setAllBorrowPaused(bool _paused)\r\n        external\r\n        override\r\n        checkPauser(_paused)\r\n    {\r\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\r\n        uint256 _len = _iTokens.length();\r\n\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _setBorrowPausedInternal(_iTokens.at(i), _paused);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice pause/unpause borrow() for the iToken\r\n     * @dev Admin function, only owner and pauseGuardian can call this\r\n     * @param _iToken The iToken to pause/unpause\r\n     * @param _paused whether to pause or unpause\r\n     */\r\n    function _setBorrowPaused(address _iToken, bool _paused)\r\n        external\r\n        override\r\n        checkPauser(_paused)\r\n    {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        _setBorrowPausedInternal(_iToken, _paused);\r\n    }\r\n\r\n    function _setBorrowPausedInternal(address _iToken, bool _paused) internal {\r\n        markets[_iToken].borrowPaused = _paused;\r\n        emit BorrowPaused(_iToken, _paused);\r\n    }\r\n\r\n    /**\r\n     * @notice pause/unpause global transfer()\r\n     * @dev Admin function, only owner and pauseGuardian can call this\r\n     * @param _paused whether to pause or unpause\r\n     */\r\n    function _setTransferPaused(bool _paused)\r\n        external\r\n        override\r\n        checkPauser(_paused)\r\n    {\r\n        _setTransferPausedInternal(_paused);\r\n    }\r\n\r\n    function _setTransferPausedInternal(bool _paused) internal {\r\n        transferPaused = _paused;\r\n        emit TransferPaused(_paused);\r\n    }\r\n\r\n    /**\r\n     * @notice pause/unpause global seize()\r\n     * @dev Admin function, only owner and pauseGuardian can call this\r\n     * @param _paused whether to pause or unpause\r\n     */\r\n    function _setSeizePaused(bool _paused)\r\n        external\r\n        override\r\n        checkPauser(_paused)\r\n    {\r\n        _setSeizePausedInternal(_paused);\r\n    }\r\n\r\n    function _setSeizePausedInternal(bool _paused) internal {\r\n        seizePaused = _paused;\r\n        emit SeizePaused(_paused);\r\n    }\r\n\r\n    /**\r\n     * @notice pause/unpause all actions iToken, including mint/redeem/borrow\r\n     * @dev Admin function, only owner and pauseGuardian can call this\r\n     * @param _paused whether to pause or unpause\r\n     */\r\n    function _setiTokenPaused(address _iToken, bool _paused)\r\n        external\r\n        override\r\n        checkPauser(_paused)\r\n    {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        _setiTokenPausedInternal(_iToken, _paused);\r\n    }\r\n\r\n    function _setiTokenPausedInternal(address _iToken, bool _paused) internal {\r\n        Market storage _market = markets[_iToken];\r\n\r\n        _market.mintPaused = _paused;\r\n        emit MintPaused(_iToken, _paused);\r\n\r\n        _market.redeemPaused = _paused;\r\n        emit RedeemPaused(_iToken, _paused);\r\n\r\n        _market.borrowPaused = _paused;\r\n        emit BorrowPaused(_iToken, _paused);\r\n    }\r\n\r\n    /**\r\n     * @notice pause/unpause entire protocol, including mint/redeem/borrow/seize/transfer\r\n     * @dev Admin function, only owner and pauseGuardian can call this\r\n     * @param _paused whether to pause or unpause\r\n     */\r\n    function _setProtocolPaused(bool _paused)\r\n        external\r\n        override\r\n        checkPauser(_paused)\r\n    {\r\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\r\n        uint256 _len = _iTokens.length();\r\n\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            address _iToken = _iTokens.at(i);\r\n\r\n            _setiTokenPausedInternal(_iToken, _paused);\r\n        }\r\n\r\n        _setTransferPausedInternal(_paused);\r\n        _setSeizePausedInternal(_paused);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets Reward Distributor\r\n     * @dev Admin function to set reward distributor\r\n     * @param _newRewardDistributor new reward distributor\r\n     */\r\n    function _setRewardDistributor(address _newRewardDistributor)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        address _oldRewardDistributor = rewardDistributor;\r\n        require(\r\n            _newRewardDistributor != address(0) &&\r\n                _newRewardDistributor != _oldRewardDistributor,\r\n            \"Reward Distributor address invalid\"\r\n        );\r\n\r\n        rewardDistributor = _newRewardDistributor;\r\n        emit NewRewardDistributor(_oldRewardDistributor, _newRewardDistributor);\r\n    }\r\n\r\n    /*********************************/\r\n    /******** Poclicy Hooks **********/\r\n    /*********************************/\r\n\r\n    /**\r\n     * @notice Hook function before iToken `mint()`\r\n     * Checks if the account should be allowed to mint the given iToken\r\n     * Will `revert()` if any check fails\r\n     * @param _iToken The iToken to check the mint against\r\n     * @param _minter The account which would get the minted tokens\r\n     * @param _mintAmount The amount of underlying being minted to iToken\r\n     */\r\n    function beforeMint(\r\n        address _iToken,\r\n        address _minter,\r\n        uint256 _mintAmount\r\n    ) external override {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        Market storage _market = markets[_iToken];\r\n        require(!_market.mintPaused, \"Token mint has been paused\");\r\n\r\n        // Check the iToken's supply capacity, -1 means no limit\r\n        uint256 _totalSupplyUnderlying =\r\n            IERC20Upgradeable(_iToken).totalSupply().rmul(\r\n                IiToken(_iToken).exchangeRateStored()\r\n            );\r\n        require(\r\n            _totalSupplyUnderlying.add(_mintAmount) <= _market.supplyCapacity,\r\n            \"Token supply capacity reached\"\r\n        );\r\n\r\n        // Update the Reward Distribution Supply state and distribute reward to suppplier\r\n        IRewardDistributor(rewardDistributor).updateDistributionState(\r\n            _iToken,\r\n            false\r\n        );\r\n        IRewardDistributor(rewardDistributor).updateReward(\r\n            _iToken,\r\n            _minter,\r\n            false\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function after iToken `mint()`\r\n     * Will `revert()` if any operation fails\r\n     * @param _iToken The iToken being minted\r\n     * @param _minter The account which would get the minted tokens\r\n     * @param _mintAmount The amount of underlying being minted to iToken\r\n     * @param _mintedAmount The amount of iToken being minted\r\n     */\r\n    function afterMint(\r\n        address _iToken,\r\n        address _minter,\r\n        uint256 _mintAmount,\r\n        uint256 _mintedAmount\r\n    ) external override {\r\n        _iToken;\r\n        _minter;\r\n        _mintAmount;\r\n        _mintedAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function before iToken `redeem()`\r\n     * Checks if the account should be allowed to redeem the given iToken\r\n     * Will `revert()` if any check fails\r\n     * @param _iToken The iToken to check the redeem against\r\n     * @param _redeemer The account which would redeem iToken\r\n     * @param _redeemAmount The amount of iToken to redeem\r\n     */\r\n    function beforeRedeem(\r\n        address _iToken,\r\n        address _redeemer,\r\n        uint256 _redeemAmount\r\n    ) external override {\r\n        // _redeemAllowed below will check whether _iToken is listed\r\n\r\n        require(!markets[_iToken].redeemPaused, \"Token redeem has been paused\");\r\n\r\n        _redeemAllowed(_iToken, _redeemer, _redeemAmount);\r\n\r\n        // Update the Reward Distribution Supply state and distribute reward to suppplier\r\n        IRewardDistributor(rewardDistributor).updateDistributionState(\r\n            _iToken,\r\n            false\r\n        );\r\n        IRewardDistributor(rewardDistributor).updateReward(\r\n            _iToken,\r\n            _redeemer,\r\n            false\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function after iToken `redeem()`\r\n     * Will `revert()` if any operation fails\r\n     * @param _iToken The iToken being redeemed\r\n     * @param _redeemer The account which redeemed iToken\r\n     * @param _redeemAmount  The amount of iToken being redeemed\r\n     * @param _redeemedUnderlying The amount of underlying being redeemed\r\n     */\r\n    function afterRedeem(\r\n        address _iToken,\r\n        address _redeemer,\r\n        uint256 _redeemAmount,\r\n        uint256 _redeemedUnderlying\r\n    ) external override {\r\n        _iToken;\r\n        _redeemer;\r\n        _redeemAmount;\r\n        _redeemedUnderlying;\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function before iToken `borrow()`\r\n     * Checks if the account should be allowed to borrow the given iToken\r\n     * Will `revert()` if any check fails\r\n     * @param _iToken The iToken to check the borrow against\r\n     * @param _borrower The account which would borrow iToken\r\n     * @param _borrowAmount The amount of underlying to borrow\r\n     */\r\n    function beforeBorrow(\r\n        address _iToken,\r\n        address _borrower,\r\n        uint256 _borrowAmount\r\n    ) external override {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        Market storage _market = markets[_iToken];\r\n        require(!_market.borrowPaused, \"Token borrow has been paused\");\r\n\r\n        if (!hasBorrowed(_borrower, _iToken)) {\r\n            // Unlike collaterals, borrowed asset can only be added by iToken,\r\n            // rather than enabled by user directly.\r\n            require(msg.sender == _iToken, \"sender must be iToken\");\r\n\r\n            // Have checked _iToken is listed, just add it\r\n            _addToBorrowed(_borrower, _iToken);\r\n        }\r\n\r\n        // Check borrower's equity\r\n        (, uint256 _shortfall, , ) =\r\n            calcAccountEquityWithEffect(_borrower, _iToken, 0, _borrowAmount);\r\n\r\n        require(_shortfall == 0, \"Account has some shortfall\");\r\n\r\n        // Check the iToken's borrow capacity, -1 means no limit\r\n        uint256 _totalBorrows = IiToken(_iToken).totalBorrows();\r\n        require(\r\n            _totalBorrows.add(_borrowAmount) <= _market.borrowCapacity,\r\n            \"Token borrow capacity reached\"\r\n        );\r\n\r\n        // Update the Reward Distribution Borrow state and distribute reward to borrower\r\n        IRewardDistributor(rewardDistributor).updateDistributionState(\r\n            _iToken,\r\n            true\r\n        );\r\n        IRewardDistributor(rewardDistributor).updateReward(\r\n            _iToken,\r\n            _borrower,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function after iToken `borrow()`\r\n     * Will `revert()` if any operation fails\r\n     * @param _iToken The iToken being borrewd\r\n     * @param _borrower The account which borrowed iToken\r\n     * @param _borrowedAmount  The amount of underlying being borrowed\r\n     */\r\n    function afterBorrow(\r\n        address _iToken,\r\n        address _borrower,\r\n        uint256 _borrowedAmount\r\n    ) external override {\r\n        _iToken;\r\n        _borrower;\r\n        _borrowedAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function before iToken `repayBorrow()`\r\n     * Checks if the account should be allowed to repay the given iToken\r\n     * for the borrower. Will `revert()` if any check fails\r\n     * @param _iToken The iToken to verify the repay against\r\n     * @param _payer The account which would repay iToken\r\n     * @param _borrower The account which has borrowed\r\n     * @param _repayAmount The amount of underlying to repay\r\n     */\r\n    function beforeRepayBorrow(\r\n        address _iToken,\r\n        address _payer,\r\n        address _borrower,\r\n        uint256 _repayAmount\r\n    ) external override {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        // Update the Reward Distribution Borrow state and distribute reward to borrower\r\n        IRewardDistributor(rewardDistributor).updateDistributionState(\r\n            _iToken,\r\n            true\r\n        );\r\n        IRewardDistributor(rewardDistributor).updateReward(\r\n            _iToken,\r\n            _borrower,\r\n            true\r\n        );\r\n\r\n        _payer;\r\n        _repayAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function after iToken `repayBorrow()`\r\n     * Will `revert()` if any operation fails\r\n     * @param _iToken The iToken being repaid\r\n     * @param _payer The account which would repay\r\n     * @param _borrower The account which has borrowed\r\n     * @param _repayAmount  The amount of underlying being repaied\r\n     */\r\n    function afterRepayBorrow(\r\n        address _iToken,\r\n        address _payer,\r\n        address _borrower,\r\n        uint256 _repayAmount\r\n    ) external override {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        // Remove _iToken from borrowed list if new borrow balance is 0\r\n        if (IiToken(_iToken).borrowBalanceStored(_borrower) == 0) {\r\n            // Only allow called by iToken as we are going to remove this token from borrower's borrowed list\r\n            require(msg.sender == _iToken, \"sender must be iToken\");\r\n\r\n            // Have checked _iToken is listed, just remove it\r\n            _removeFromBorrowed(_borrower, _iToken);\r\n        }\r\n\r\n        _payer;\r\n        _repayAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function before iToken `liquidateBorrow()`\r\n     * Checks if the account should be allowed to liquidate the given iToken\r\n     * for the borrower. Will `revert()` if any check fails\r\n     * @param _iTokenBorrowed The iToken was borrowed\r\n     * @param _iTokenCollateral The collateral iToken to be liqudate with\r\n     * @param _liquidator The account which would repay the borrowed iToken\r\n     * @param _borrower The account which has borrowed\r\n     * @param _repayAmount The amount of underlying to repay\r\n     */\r\n    function beforeLiquidateBorrow(\r\n        address _iTokenBorrowed,\r\n        address _iTokenCollateral,\r\n        address _liquidator,\r\n        address _borrower,\r\n        uint256 _repayAmount\r\n    ) external override {\r\n        // Tokens must have been listed\r\n        require(\r\n            iTokens.contains(_iTokenBorrowed) &&\r\n                iTokens.contains(_iTokenCollateral),\r\n            \"Tokens have not been listed\"\r\n        );\r\n\r\n        (, uint256 _shortfall, , ) = calcAccountEquity(_borrower);\r\n\r\n        require(_shortfall > 0, \"Account does not have shortfall\");\r\n\r\n        // Only allowed to repay the borrow balance's close factor\r\n        uint256 _borrowBalance =\r\n            IiToken(_iTokenBorrowed).borrowBalanceStored(_borrower);\r\n        uint256 _maxRepay = _borrowBalance.rmul(closeFactorMantissa);\r\n\r\n        require(_repayAmount <= _maxRepay, \"Repay exceeds max repay allowed\");\r\n\r\n        _liquidator;\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function after iToken `liquidateBorrow()`\r\n     * Will `revert()` if any operation fails\r\n     * @param _iTokenBorrowed The iToken was borrowed\r\n     * @param _iTokenCollateral The collateral iToken to be seized\r\n     * @param _liquidator The account which would repay and seize\r\n     * @param _borrower The account which has borrowed\r\n     * @param _repaidAmount  The amount of underlying being repaied\r\n     * @param _seizedAmount  The amount of collateral being seized\r\n     */\r\n    function afterLiquidateBorrow(\r\n        address _iTokenBorrowed,\r\n        address _iTokenCollateral,\r\n        address _liquidator,\r\n        address _borrower,\r\n        uint256 _repaidAmount,\r\n        uint256 _seizedAmount\r\n    ) external override {\r\n        _iTokenBorrowed;\r\n        _iTokenCollateral;\r\n        _liquidator;\r\n        _borrower;\r\n        _repaidAmount;\r\n        _seizedAmount;\r\n\r\n        // Unlike repayBorrow, liquidateBorrow does not allow to repay all borrow balance\r\n        // No need to check whether should remove from borrowed asset list\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function before iToken `seize()`\r\n     * Checks if the liquidator should be allowed to seize the collateral iToken\r\n     * Will `revert()` if any check fails\r\n     * @param _iTokenCollateral The collateral iToken to be seize\r\n     * @param _iTokenBorrowed The iToken was borrowed\r\n     * @param _liquidator The account which has repaid the borrowed iToken\r\n     * @param _borrower The account which has borrowed\r\n     * @param _seizeAmount The amount of collateral iToken to seize\r\n     */\r\n    function beforeSeize(\r\n        address _iTokenCollateral,\r\n        address _iTokenBorrowed,\r\n        address _liquidator,\r\n        address _borrower,\r\n        uint256 _seizeAmount\r\n    ) external override {\r\n        require(!seizePaused, \"Seize has been paused\");\r\n\r\n        // Markets must have been listed\r\n        require(\r\n            iTokens.contains(_iTokenBorrowed) &&\r\n                iTokens.contains(_iTokenCollateral),\r\n            \"Tokens have not been listed\"\r\n        );\r\n\r\n        // Sanity Check the controllers\r\n        require(\r\n            IiToken(_iTokenBorrowed).controller() ==\r\n                IiToken(_iTokenCollateral).controller(),\r\n            \"Controller mismatch between Borrowed and Collateral\"\r\n        );\r\n\r\n        // Update the Reward Distribution Supply state on collateral\r\n        IRewardDistributor(rewardDistributor).updateDistributionState(\r\n            _iTokenCollateral,\r\n            false\r\n        );\r\n\r\n        // Update reward of liquidator and borrower on collateral\r\n        IRewardDistributor(rewardDistributor).updateReward(\r\n            _iTokenCollateral,\r\n            _liquidator,\r\n            false\r\n        );\r\n        IRewardDistributor(rewardDistributor).updateReward(\r\n            _iTokenCollateral,\r\n            _borrower,\r\n            false\r\n        );\r\n\r\n        _seizeAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function after iToken `seize()`\r\n     * Will `revert()` if any operation fails\r\n     * @param _iTokenCollateral The collateral iToken to be seized\r\n     * @param _iTokenBorrowed The iToken was borrowed\r\n     * @param _liquidator The account which has repaid and seized\r\n     * @param _borrower The account which has borrowed\r\n     * @param _seizedAmount  The amount of collateral being seized\r\n     */\r\n    function afterSeize(\r\n        address _iTokenCollateral,\r\n        address _iTokenBorrowed,\r\n        address _liquidator,\r\n        address _borrower,\r\n        uint256 _seizedAmount\r\n    ) external override {\r\n        _iTokenBorrowed;\r\n        _iTokenCollateral;\r\n        _liquidator;\r\n        _borrower;\r\n        _seizedAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function before iToken `transfer()`\r\n     * Checks if the transfer should be allowed\r\n     * Will `revert()` if any check fails\r\n     * @param _iToken The iToken to be transfered\r\n     * @param _from The account to be transfered from\r\n     * @param _to The account to be transfered to\r\n     * @param _amount The amount to be transfered\r\n     */\r\n    function beforeTransfer(\r\n        address _iToken,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external override {\r\n        // _redeemAllowed below will check whether _iToken is listed\r\n\r\n        require(!transferPaused, \"Transfer has been paused\");\r\n\r\n        // Check account equity with this amount to decide whether the transfer is allowed\r\n        _redeemAllowed(_iToken, _from, _amount);\r\n\r\n        // Update the Reward Distribution supply state\r\n        IRewardDistributor(rewardDistributor).updateDistributionState(\r\n            _iToken,\r\n            false\r\n        );\r\n\r\n        // Update reward of from and to\r\n        IRewardDistributor(rewardDistributor).updateReward(\r\n            _iToken,\r\n            _from,\r\n            false\r\n        );\r\n        IRewardDistributor(rewardDistributor).updateReward(_iToken, _to, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function after iToken `transfer()`\r\n     * Will `revert()` if any operation fails\r\n     * @param _iToken The iToken was transfered\r\n     * @param _from The account was transfer from\r\n     * @param _to The account was transfer to\r\n     * @param _amount  The amount was transfered\r\n     */\r\n    function afterTransfer(\r\n        address _iToken,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external override {\r\n        _iToken;\r\n        _from;\r\n        _to;\r\n        _amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function before iToken `flashloan()`\r\n     * Checks if the flashloan should be allowed\r\n     * Will `revert()` if any check fails\r\n     * @param _iToken The iToken to be flashloaned\r\n     * @param _to The account flashloaned transfer to\r\n     * @param _amount The amount to be flashloaned\r\n     */\r\n    function beforeFlashloan(\r\n        address _iToken,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external override {\r\n        // Flashloan share the same pause state with borrow\r\n        require(!markets[_iToken].borrowPaused, \"Token borrow has been paused\");\r\n\r\n        _checkiTokenListed(_iToken);\r\n\r\n        _to;\r\n        _amount;\r\n\r\n        // Update the Reward Distribution Borrow state\r\n        IRewardDistributor(rewardDistributor).updateDistributionState(\r\n            _iToken,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Hook function after iToken `flashloan()`\r\n     * Will `revert()` if any operation fails\r\n     * @param _iToken The iToken was flashloaned\r\n     * @param _to The account flashloan transfer to\r\n     * @param _amount  The amount was flashloaned\r\n     */\r\n    function afterFlashloan(\r\n        address _iToken,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external override {\r\n        _iToken;\r\n        _to;\r\n        _amount;\r\n    }\r\n\r\n    /*********************************/\r\n    /***** Internal  Functions *******/\r\n    /*********************************/\r\n\r\n    function _redeemAllowed(\r\n        address _iToken,\r\n        address _redeemer,\r\n        uint256 _amount\r\n    ) private view {\r\n        _checkiTokenListed(_iToken);\r\n\r\n        // No need to check liquidity if _redeemer has not used _iToken as collateral\r\n        if (!accountsData[_redeemer].collaterals.contains(_iToken)) {\r\n            return;\r\n        }\r\n\r\n        (, uint256 _shortfall, , ) =\r\n            calcAccountEquityWithEffect(_redeemer, _iToken, _amount, 0);\r\n\r\n        require(_shortfall == 0, \"Account has some shortfall\");\r\n    }\r\n\r\n    /**\r\n     * @dev Check if _iToken is listed\r\n     */\r\n    function _checkiTokenListed(address _iToken) private view {\r\n        require(iTokens.contains(_iToken), \"Token has not been listed\");\r\n    }\r\n\r\n    /*********************************/\r\n    /** Account equity calculation ***/\r\n    /*********************************/\r\n\r\n    /**\r\n     * @notice Calculates current account equity\r\n     * @param _account The account to query equity of\r\n     * @return account equity, shortfall, collateral value, borrowed value.\r\n     */\r\n    function calcAccountEquity(address _account)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return calcAccountEquityWithEffect(_account, address(0), 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n     *  Note that `iTokenBalance` is the number of iTokens the account owns in the collateral,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountEquityLocalVars {\r\n        uint256 sumCollateral;\r\n        uint256 sumBorrowed;\r\n        uint256 iTokenBalance;\r\n        uint256 borrowBalance;\r\n        uint256 exchangeRateMantissa;\r\n        uint256 underlyingPrice;\r\n        uint256 collateralValue;\r\n        uint256 borrowValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates current account equity plus some token and amount to effect\r\n     * @param _account The account to query equity of\r\n     * @param _tokenToEffect The token address to add some additional redeeem/borrow\r\n     * @param _redeemAmount The additional amount to redeem\r\n     * @param _borrowAmount The additional amount to borrow\r\n     * @return account euqity, shortfall, collateral value, borrowed value plus the effect.\r\n     */\r\n    function calcAccountEquityWithEffect(\r\n        address _account,\r\n        address _tokenToEffect,\r\n        uint256 _redeemAmount,\r\n        uint256 _borrowAmount\r\n    )\r\n        internal\r\n        view\r\n        virtual\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        AccountEquityLocalVars memory _local;\r\n        AccountData storage _accountData = accountsData[_account];\r\n\r\n        // Calculate value of all collaterals\r\n        // collateralValuePerToken = underlyingPrice * exchangeRate * collateralFactor\r\n        // collateralValue = balance * collateralValuePerToken\r\n        // sumCollateral += collateralValue\r\n        uint256 _len = _accountData.collaterals.length();\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            IiToken _token = IiToken(_accountData.collaterals.at(i));\r\n\r\n            _local.iTokenBalance = IERC20Upgradeable(address(_token)).balanceOf(\r\n                _account\r\n            );\r\n            _local.exchangeRateMantissa = _token.exchangeRateStored();\r\n\r\n            if (_tokenToEffect == address(_token) && _redeemAmount > 0) {\r\n                _local.iTokenBalance = _local.iTokenBalance.sub(_redeemAmount);\r\n            }\r\n\r\n            _local.underlyingPrice = IPriceOracle(priceOracle)\r\n                .getUnderlyingPrice(address(_token));\r\n\r\n            require(\r\n                _local.underlyingPrice != 0,\r\n                \"Invalid price to calculate account equity\"\r\n            );\r\n\r\n            _local.collateralValue = _local\r\n                .iTokenBalance\r\n                .mul(_local.underlyingPrice)\r\n                .rmul(_local.exchangeRateMantissa)\r\n                .rmul(markets[address(_token)].collateralFactorMantissa);\r\n\r\n            _local.sumCollateral = _local.sumCollateral.add(\r\n                _local.collateralValue\r\n            );\r\n        }\r\n\r\n        // Calculate all borrowed value\r\n        // borrowValue = underlyingPrice * underlyingBorrowed / borrowFactor\r\n        // sumBorrowed += borrowValue\r\n        _len = _accountData.borrowed.length();\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            IiToken _token = IiToken(_accountData.borrowed.at(i));\r\n\r\n            _local.borrowBalance = _token.borrowBalanceStored(_account);\r\n\r\n            if (_tokenToEffect == address(_token) && _borrowAmount > 0) {\r\n                _local.borrowBalance = _local.borrowBalance.add(_borrowAmount);\r\n            }\r\n\r\n            _local.underlyingPrice = IPriceOracle(priceOracle)\r\n                .getUnderlyingPrice(address(_token));\r\n\r\n            require(\r\n                _local.underlyingPrice != 0,\r\n                \"Invalid price to calculate account equity\"\r\n            );\r\n\r\n            // borrowFactorMantissa can not be set to 0\r\n            _local.borrowValue = _local\r\n                .borrowBalance\r\n                .mul(_local.underlyingPrice)\r\n                .rdiv(markets[address(_token)].borrowFactorMantissa);\r\n\r\n            _local.sumBorrowed = _local.sumBorrowed.add(_local.borrowValue);\r\n        }\r\n\r\n        // Should never underflow\r\n        return\r\n            _local.sumCollateral > _local.sumBorrowed\r\n                ? (\r\n                    _local.sumCollateral - _local.sumBorrowed,\r\n                    uint256(0),\r\n                    _local.sumCollateral,\r\n                    _local.sumBorrowed\r\n                )\r\n                : (\r\n                    uint256(0),\r\n                    _local.sumBorrowed - _local.sumCollateral,\r\n                    _local.sumCollateral,\r\n                    _local.sumBorrowed\r\n                );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of collateral iToken to seize after repaying an underlying amount\r\n     * @dev Used in liquidation\r\n     * @param _iTokenBorrowed The iToken was borrowed\r\n     * @param _iTokenCollateral The collateral iToken to be seized\r\n     * @param _actualRepayAmount The amount of underlying token liquidator has repaied\r\n     * @return _seizedTokenCollateral amount of iTokenCollateral tokens to be seized\r\n     */\r\n    function liquidateCalculateSeizeTokens(\r\n        address _iTokenBorrowed,\r\n        address _iTokenCollateral,\r\n        uint256 _actualRepayAmount\r\n    ) external view virtual override returns (uint256 _seizedTokenCollateral) {\r\n        /* Read oracle prices for borrowed and collateral assets */\r\n        uint256 _priceBorrowed =\r\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iTokenBorrowed);\r\n        uint256 _priceCollateral =\r\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iTokenCollateral);\r\n        require(\r\n            _priceBorrowed != 0 && _priceCollateral != 0,\r\n            \"Borrowed or Collateral asset price is invalid\"\r\n        );\r\n\r\n        uint256 _valueRepayPlusIncentive =\r\n            _actualRepayAmount.mul(_priceBorrowed).rmul(\r\n                liquidationIncentiveMantissa\r\n            );\r\n\r\n        // Use stored value here as it is view function\r\n        uint256 _exchangeRateMantissa =\r\n            IiToken(_iTokenCollateral).exchangeRateStored();\r\n\r\n        // seizedTokenCollateral = valueRepayPlusIncentive / valuePerTokenCollateral\r\n        // valuePerTokenCollateral = exchangeRateMantissa * priceCollateral\r\n        _seizedTokenCollateral = _valueRepayPlusIncentive\r\n            .rdiv(_exchangeRateMantissa)\r\n            .div(_priceCollateral);\r\n    }\r\n\r\n    /*********************************/\r\n    /*** Account Markets Operation ***/\r\n    /*********************************/\r\n\r\n    /**\r\n     * @notice Returns the markets list the account has entered\r\n     * @param _account The address of the account to query\r\n     * @return _accountCollaterals The markets list the account has entered\r\n     */\r\n    function getEnteredMarkets(address _account)\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory _accountCollaterals)\r\n    {\r\n        AccountData storage _accountData = accountsData[_account];\r\n\r\n        uint256 _len = _accountData.collaterals.length();\r\n        _accountCollaterals = new address[](_len);\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _accountCollaterals[i] = _accountData.collaterals.at(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Add markets to `msg.sender`'s markets list for liquidity calculations\r\n     * @param _iTokens The list of addresses of the iToken markets to be entered\r\n     * @return _results Success indicator for whether each corresponding market was entered\r\n     */\r\n    function enterMarkets(address[] calldata _iTokens)\r\n        external\r\n        override\r\n        returns (bool[] memory _results)\r\n    {\r\n        uint256 _len = _iTokens.length;\r\n\r\n        _results = new bool[](_len);\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _results[i] = _enterMarket(_iTokens[i], msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the account's markets list for liquidity calculations\r\n     * @param _iToken The market to enter\r\n     * @param _account The address of the account to modify\r\n     * @return True if entered successfully, false for non-listed market or other errors\r\n     */\r\n    function _enterMarket(address _iToken, address _account)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // Market not listed, skip it\r\n        if (!iTokens.contains(_iToken)) {\r\n            return false;\r\n        }\r\n\r\n        // add() will return false if iToken is in account's market list\r\n        if (accountsData[_account].collaterals.add(_iToken)) {\r\n            emit MarketEntered(_iToken, _account);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account has entered the market\r\n     * @param _account The address of the account to check\r\n     * @param _iToken The iToken to check against\r\n     * @return True if the account has entered the market, otherwise false.\r\n     */\r\n    function hasEnteredMarket(address _account, address _iToken)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return accountsData[_account].collaterals.contains(_iToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove markets from `msg.sender`'s collaterals for liquidity calculations\r\n     * @param _iTokens The list of addresses of the iToken to exit\r\n     * @return _results Success indicators for whether each corresponding market was exited\r\n     */\r\n    function exitMarkets(address[] calldata _iTokens)\r\n        external\r\n        override\r\n        returns (bool[] memory _results)\r\n    {\r\n        uint256 _len = _iTokens.length;\r\n        _results = new bool[](_len);\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _results[i] = _exitMarket(_iTokens[i], msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the market to the account's markets list for liquidity calculations\r\n     * @param _iToken The market to exit\r\n     * @param _account The address of the account to modify\r\n     * @return True if exit successfully, false for non-listed market or other errors\r\n     */\r\n    function _exitMarket(address _iToken, address _account)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // Market not listed, skip it\r\n        if (!iTokens.contains(_iToken)) {\r\n            return true;\r\n        }\r\n\r\n        // Account has not entered this market, skip it\r\n        if (!accountsData[_account].collaterals.contains(_iToken)) {\r\n            return true;\r\n        }\r\n\r\n        // Get the iToken balance\r\n        uint256 _balance = IERC20Upgradeable(_iToken).balanceOf(_account);\r\n\r\n        // Check account's equity if all balance are redeemed\r\n        // which means iToken can be removed from collaterals\r\n        _redeemAllowed(_iToken, _account, _balance);\r\n\r\n        // Have checked account has entered market before\r\n        accountsData[_account].collaterals.remove(_iToken);\r\n\r\n        emit MarketExited(_iToken, _account);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the asset list the account has borrowed\r\n     * @param _account The address of the account to query\r\n     * @return _borrowedAssets The asset list the account has borrowed\r\n     */\r\n    function getBorrowedAssets(address _account)\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory _borrowedAssets)\r\n    {\r\n        AccountData storage _accountData = accountsData[_account];\r\n\r\n        uint256 _len = _accountData.borrowed.length();\r\n        _borrowedAssets = new address[](_len);\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _borrowedAssets[i] = _accountData.borrowed.at(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the account's borrowed list for equity calculations\r\n     * @param _iToken The iToken of underlying to borrow\r\n     * @param _account The address of the account to modify\r\n     */\r\n    function _addToBorrowed(address _account, address _iToken) internal {\r\n        // add() will return false if iToken is in account's market list\r\n        if (accountsData[_account].borrowed.add(_iToken)) {\r\n            emit BorrowedAdded(_iToken, _account);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account has borrowed the given iToken\r\n     * @param _account The address of the account to check\r\n     * @param _iToken The iToken to check against\r\n     * @return True if the account has borrowed the iToken, otherwise false.\r\n     */\r\n    function hasBorrowed(address _account, address _iToken)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return accountsData[_account].borrowed.contains(_iToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the iToken from the account's borrowed list\r\n     * @param _iToken The iToken to remove\r\n     * @param _account The address of the account to modify\r\n     */\r\n    function _removeFromBorrowed(address _account, address _iToken) internal {\r\n        // remove() will return false if iToken does not exist in account's borrowed list\r\n        if (accountsData[_account].borrowed.remove(_iToken)) {\r\n            emit BorrowedRemoved(_iToken, _account);\r\n        }\r\n    }\r\n\r\n    /*********************************/\r\n    /****** General Information ******/\r\n    /*********************************/\r\n\r\n    /**\r\n     * @notice Return all of the iTokens\r\n     * @return _alliTokens The list of iToken addresses\r\n     */\r\n    function getAlliTokens()\r\n        public\r\n        view\r\n        override\r\n        returns (address[] memory _alliTokens)\r\n    {\r\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\r\n\r\n        uint256 _len = _iTokens.length();\r\n        _alliTokens = new address[](_len);\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _alliTokens[i] = _iTokens.at(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether a iToken is listed in controller\r\n     * @param _iToken The iToken to check for\r\n     * @return true if the iToken is listed otherwise false\r\n     */\r\n    function hasiToken(address _iToken) public view override returns (bool) {\r\n        return iTokens.contains(_iToken);\r\n    }\r\n}\r\n\r\n// File contracts/RewardDistributorV3.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title dForce's lending reward distributor Contract\r\n * @author dForce\r\n */\r\ncontract RewardDistributorV3 is Initializable, Ownable, IRewardDistributorV3 {\r\n    using SafeRatioMath for uint256;\r\n    using SafeMathUpgradeable for uint256;\r\n    using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n    /// @notice the controller\r\n    Controller public controller;\r\n\r\n    /// @notice the global Reward distribution speed\r\n    uint256 public globalDistributionSpeed;\r\n\r\n    /// @notice the Reward distribution speed of each iToken\r\n    mapping(address => uint256) public distributionSpeed;\r\n\r\n    /// @notice the Reward distribution factor of each iToken, 1.0 by default. stored as a mantissa\r\n    mapping(address => uint256) public distributionFactorMantissa;\r\n\r\n    struct DistributionState {\r\n        // Token's last updated index, stored as a mantissa\r\n        uint256 index;\r\n        // The block number the index was last updated at\r\n        uint256 block;\r\n    }\r\n\r\n    /// @notice the Reward distribution supply state of each iToken\r\n    mapping(address => DistributionState) public distributionSupplyState;\r\n    /// @notice the Reward distribution borrow state of each iToken\r\n    mapping(address => DistributionState) public distributionBorrowState;\r\n\r\n    /// @notice the Reward distribution state of each account of each iToken\r\n    mapping(address => mapping(address => uint256))\r\n        public distributionSupplierIndex;\r\n    /// @notice the Reward distribution state of each account of each iToken\r\n    mapping(address => mapping(address => uint256))\r\n        public distributionBorrowerIndex;\r\n\r\n    /// @notice the Reward distributed into each account\r\n    mapping(address => uint256) public reward;\r\n\r\n    /// @notice the Reward token address\r\n    address public rewardToken;\r\n\r\n    /// @notice whether the reward distribution is paused\r\n    bool public paused;\r\n\r\n    /// @notice the Reward distribution speed supply side of each iToken\r\n    mapping(address => uint256) public distributionSupplySpeed;\r\n\r\n    /// @notice the global Reward distribution speed for supply\r\n    uint256 public globalDistributionSupplySpeed;\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the controller.\r\n     */\r\n    modifier onlyController() {\r\n        require(\r\n            address(controller) == msg.sender,\r\n            \"onlyController: caller is not the controller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes the contract.\r\n     */\r\n    function initialize(Controller _controller) external initializer {\r\n        require(\r\n            address(_controller) != address(0),\r\n            \"initialize: controller address should not be zero address!\"\r\n        );\r\n        __Ownable_init();\r\n        controller = _controller;\r\n        paused = true;\r\n    }\r\n\r\n    /**\r\n     * @notice set reward token address\r\n     * @dev Admin function, only owner can call this\r\n     * @param _newRewardToken the address of reward token\r\n     */\r\n    function _setRewardToken(address _newRewardToken)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        address _oldRewardToken = rewardToken;\r\n        require(\r\n            _newRewardToken != address(0) && _newRewardToken != _oldRewardToken,\r\n            \"Reward token address invalid\"\r\n        );\r\n        rewardToken = _newRewardToken;\r\n        emit NewRewardToken(_oldRewardToken, _newRewardToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Add the iToken as receipient\r\n     * @dev Admin function, only controller can call this\r\n     * @param _iToken the iToken to add as recipient\r\n     * @param _distributionFactor the distribution factor of the recipient\r\n     */\r\n    function _addRecipient(address _iToken, uint256 _distributionFactor)\r\n        external\r\n        override\r\n        onlyController\r\n    {\r\n        distributionFactorMantissa[_iToken] = _distributionFactor;\r\n        distributionSupplyState[_iToken] = DistributionState({\r\n            index: 0,\r\n            block: block.number\r\n        });\r\n        distributionBorrowState[_iToken] = DistributionState({\r\n            index: 0,\r\n            block: block.number\r\n        });\r\n\r\n        emit NewRecipient(_iToken, _distributionFactor);\r\n    }\r\n\r\n    /**\r\n     * @notice Pause the reward distribution\r\n     * @dev Admin function, pause will set global speed to 0 to stop the accumulation\r\n     */\r\n    function _pause() external override onlyOwner {\r\n        // Set the global distribution speed to 0 to stop accumulation\r\n        address[] memory _iTokens = controller.getAlliTokens();\r\n        uint256 _len = _iTokens.length;\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _setDistributionBorrowSpeed(_iTokens[i], 0);\r\n            _setDistributionSupplySpeed(_iTokens[i], 0);\r\n        }\r\n\r\n        _refreshGlobalDistributionSpeeds();\r\n\r\n        _setPaused(true);\r\n    }\r\n\r\n    /**\r\n     * @notice Unpause and set distribution speeds\r\n     * @dev Admin function\r\n     * @param _borrowiTokens The borrow asset array\r\n     * @param _borrowSpeeds  The borrow speed array\r\n     * @param _supplyiTokens The supply asset array\r\n     * @param _supplySpeeds  The supply speed array\r\n     */\r\n    function _unpause(\r\n        address[] calldata _borrowiTokens,\r\n        uint256[] calldata _borrowSpeeds,\r\n        address[] calldata _supplyiTokens,\r\n        uint256[] calldata _supplySpeeds\r\n    ) external override onlyOwner {\r\n        _setPaused(false);\r\n\r\n        _setDistributionSpeedsInternal(\r\n            _borrowiTokens,\r\n            _borrowSpeeds,\r\n            _supplyiTokens,\r\n            _supplySpeeds\r\n        );\r\n\r\n        _refreshGlobalDistributionSpeeds();\r\n    }\r\n\r\n    /**\r\n     * @notice Pause/Unpause the reward distribution\r\n     * @dev Admin function\r\n     * @param _paused whether to pause/unpause the distribution\r\n     */\r\n    function _setPaused(bool _paused) internal {\r\n        paused = _paused;\r\n        emit Paused(_paused);\r\n    }\r\n\r\n    /**\r\n     * @notice Set distribution speeds\r\n     * @dev Admin function, will fail when paused\r\n     * @param _borrowiTokens The borrow asset array\r\n     * @param _borrowSpeeds  The borrow speed array\r\n     * @param _supplyiTokens The supply asset array\r\n     * @param _supplySpeeds  The supply speed array\r\n     */\r\n    function _setDistributionSpeeds(\r\n        address[] calldata _borrowiTokens,\r\n        uint256[] calldata _borrowSpeeds,\r\n        address[] calldata _supplyiTokens,\r\n        uint256[] calldata _supplySpeeds\r\n    ) external onlyOwner {\r\n        require(!paused, \"Can not change speeds when paused\");\r\n\r\n        _setDistributionSpeedsInternal(\r\n            _borrowiTokens,\r\n            _borrowSpeeds,\r\n            _supplyiTokens,\r\n            _supplySpeeds\r\n        );\r\n\r\n        _refreshGlobalDistributionSpeeds();\r\n    }\r\n\r\n    function _setDistributionSpeedsInternal(\r\n        address[] memory _borrowiTokens,\r\n        uint256[] memory _borrowSpeeds,\r\n        address[] memory _supplyiTokens,\r\n        uint256[] memory _supplySpeeds\r\n    ) internal {\r\n        _setDistributionBorrowSpeedsInternal(_borrowiTokens, _borrowSpeeds);\r\n        _setDistributionSupplySpeedsInternal(_supplyiTokens, _supplySpeeds);\r\n    }\r\n\r\n    /**\r\n     * @notice Set borrow distribution speeds\r\n     * @dev Admin function, will fail when paused\r\n     * @param _iTokens The borrow asset array\r\n     * @param _borrowSpeeds  The borrow speed array\r\n     */\r\n    function _setDistributionBorrowSpeeds(\r\n        address[] calldata _iTokens,\r\n        uint256[] calldata _borrowSpeeds\r\n    ) external onlyOwner {\r\n        require(!paused, \"Can not change borrow speeds when paused\");\r\n\r\n        _setDistributionBorrowSpeedsInternal(_iTokens, _borrowSpeeds);\r\n\r\n        _refreshGlobalDistributionSpeeds();\r\n    }\r\n\r\n    /**\r\n     * @notice Set supply distribution speeds\r\n     * @dev Admin function, will fail when paused\r\n     * @param _iTokens The supply asset array\r\n     * @param _supplySpeeds The supply speed array\r\n     */\r\n    function _setDistributionSupplySpeeds(\r\n        address[] calldata _iTokens,\r\n        uint256[] calldata _supplySpeeds\r\n    ) external onlyOwner {\r\n        require(!paused, \"Can not change supply speeds when paused\");\r\n\r\n        _setDistributionSupplySpeedsInternal(_iTokens, _supplySpeeds);\r\n\r\n        _refreshGlobalDistributionSpeeds();\r\n    }\r\n\r\n    function _refreshGlobalDistributionSpeeds() internal {\r\n        address[] memory _iTokens = controller.getAlliTokens();\r\n        uint256 _len = _iTokens.length;\r\n        uint256 _borrowSpeed;\r\n        uint256 _supplySpeed;\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _borrowSpeed = _borrowSpeed.add(distributionSpeed[_iTokens[i]]);\r\n            _supplySpeed = _supplySpeed.add(\r\n                distributionSupplySpeed[_iTokens[i]]\r\n            );\r\n        }\r\n\r\n        globalDistributionSpeed = _borrowSpeed;\r\n        globalDistributionSupplySpeed = _supplySpeed;\r\n\r\n        emit GlobalDistributionSpeedsUpdated(_borrowSpeed, _supplySpeed);\r\n    }\r\n\r\n    function _setDistributionBorrowSpeedsInternal(\r\n        address[] memory _iTokens,\r\n        uint256[] memory _borrowSpeeds\r\n    ) internal {\r\n        require(\r\n            _iTokens.length == _borrowSpeeds.length,\r\n            \"Length of _iTokens and _borrowSpeeds mismatch\"\r\n        );\r\n\r\n        uint256 _len = _iTokens.length;\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _setDistributionBorrowSpeed(_iTokens[i], _borrowSpeeds[i]);\r\n        }\r\n    }\r\n\r\n    function _setDistributionSupplySpeedsInternal(\r\n        address[] memory _iTokens,\r\n        uint256[] memory _supplySpeeds\r\n    ) internal {\r\n        require(\r\n            _iTokens.length == _supplySpeeds.length,\r\n            \"Length of _iTokens and _supplySpeeds mismatch\"\r\n        );\r\n\r\n        uint256 _len = _iTokens.length;\r\n        for (uint256 i = 0; i < _len; i++) {\r\n            _setDistributionSupplySpeed(_iTokens[i], _supplySpeeds[i]);\r\n        }\r\n    }\r\n\r\n    function _setDistributionBorrowSpeed(address _iToken, uint256 _borrowSpeed)\r\n        internal\r\n    {\r\n        // iToken must have been listed\r\n        require(controller.hasiToken(_iToken), \"Token has not been listed\");\r\n\r\n        // Update borrow state before updating new speed\r\n        _updateDistributionState(_iToken, true);\r\n\r\n        distributionSpeed[_iToken] = _borrowSpeed;\r\n        emit DistributionBorrowSpeedUpdated(_iToken, _borrowSpeed);\r\n    }\r\n\r\n    function _setDistributionSupplySpeed(address _iToken, uint256 _supplySpeed)\r\n        internal\r\n    {\r\n        // iToken must have been listed\r\n        require(controller.hasiToken(_iToken), \"Token has not been listed\");\r\n\r\n        // Update supply state before updating new speed\r\n        _updateDistributionState(_iToken, false);\r\n\r\n        distributionSupplySpeed[_iToken] = _supplySpeed;\r\n        emit DistributionSupplySpeedUpdated(_iToken, _supplySpeed);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the iToken's  Reward distribution state\r\n     * @dev Will be called every time when the iToken's supply/borrow changes\r\n     * @param _iToken The iToken to be updated\r\n     * @param _isBorrow whether to update the borrow state\r\n     */\r\n    function updateDistributionState(address _iToken, bool _isBorrow)\r\n        external\r\n        override\r\n    {\r\n        // Skip all updates if it is paused\r\n        if (paused) {\r\n            return;\r\n        }\r\n\r\n        _updateDistributionState(_iToken, _isBorrow);\r\n    }\r\n\r\n    function _updateDistributionState(address _iToken, bool _isBorrow)\r\n        internal\r\n    {\r\n        require(controller.hasiToken(_iToken), \"Token has not been listed\");\r\n\r\n        DistributionState storage state =\r\n            _isBorrow\r\n                ? distributionBorrowState[_iToken]\r\n                : distributionSupplyState[_iToken];\r\n\r\n        uint256 _speed =\r\n            _isBorrow\r\n                ? distributionSpeed[_iToken]\r\n                : distributionSupplySpeed[_iToken];\r\n\r\n        uint256 _blockNumber = block.number;\r\n        uint256 _deltaBlocks = _blockNumber.sub(state.block);\r\n\r\n        if (_deltaBlocks > 0 && _speed > 0) {\r\n            uint256 _totalToken =\r\n                _isBorrow\r\n                    ? IiToken(_iToken).totalBorrows()\r\n                    : IERC20Upgradeable(_iToken).totalSupply();\r\n            uint256 _totalDistributed = _speed.mul(_deltaBlocks);\r\n\r\n            // Reward distributed per token since last time\r\n            uint256 _distributedPerToken =\r\n                _totalToken > 0 ? _totalDistributed.rdiv(_totalToken) : 0;\r\n\r\n            state.index = state.index.add(_distributedPerToken);\r\n        }\r\n\r\n        state.block = _blockNumber;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the account's Reward distribution state\r\n     * @dev Will be called every time when the account's supply/borrow changes\r\n     * @param _iToken The iToken to be updated\r\n     * @param _account The account to be updated\r\n     * @param _isBorrow whether to update the borrow state\r\n     */\r\n    function updateReward(\r\n        address _iToken,\r\n        address _account,\r\n        bool _isBorrow\r\n    ) external override {\r\n        // Skip all updates if it is paused\r\n        if (paused) {\r\n            return;\r\n        }\r\n\r\n        _updateReward(_iToken, _account, _isBorrow);\r\n    }\r\n\r\n    function _updateReward(\r\n        address _iToken,\r\n        address _account,\r\n        bool _isBorrow\r\n    ) internal {\r\n        require(_account != address(0), \"Invalid account address!\");\r\n        require(controller.hasiToken(_iToken), \"Token has not been listed\");\r\n\r\n        uint256 _iTokenIndex;\r\n        uint256 _accountIndex;\r\n        uint256 _accountBalance;\r\n        if (_isBorrow) {\r\n            _iTokenIndex = distributionBorrowState[_iToken].index;\r\n            _accountIndex = distributionBorrowerIndex[_iToken][_account];\r\n            _accountBalance = IiToken(_iToken).borrowBalanceStored(_account);\r\n\r\n            // Update the account state to date\r\n            distributionBorrowerIndex[_iToken][_account] = _iTokenIndex;\r\n        } else {\r\n            _iTokenIndex = distributionSupplyState[_iToken].index;\r\n            _accountIndex = distributionSupplierIndex[_iToken][_account];\r\n            _accountBalance = IERC20Upgradeable(_iToken).balanceOf(_account);\r\n\r\n            // Update the account state to date\r\n            distributionSupplierIndex[_iToken][_account] = _iTokenIndex;\r\n        }\r\n\r\n        uint256 _deltaIndex = _iTokenIndex.sub(_accountIndex);\r\n        uint256 _amount = _accountBalance.rmul(_deltaIndex);\r\n\r\n        if (_amount > 0) {\r\n            reward[_account] = reward[_account].add(_amount);\r\n\r\n            emit RewardDistributed(_iToken, _account, _amount, _accountIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update reward accrued in iTokens by the holders regardless of paused or not\r\n     * @param _holders The account to update\r\n     * @param _iTokens The _iTokens to update\r\n     */\r\n    function updateRewardBatch(\r\n        address[] memory _holders,\r\n        address[] memory _iTokens\r\n    ) public override {\r\n        // Update rewards for all _iTokens for holders\r\n        for (uint256 i = 0; i < _iTokens.length; i++) {\r\n            address _iToken = _iTokens[i];\r\n            _updateDistributionState(_iToken, false);\r\n            _updateDistributionState(_iToken, true);\r\n            for (uint256 j = 0; j < _holders.length; j++) {\r\n                _updateReward(_iToken, _holders[j], false);\r\n                _updateReward(_iToken, _holders[j], true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim reward accrued in iTokens by the holders\r\n     * @param _holders The account to claim for\r\n     * @param _iTokens The _iTokens to claim from\r\n     */\r\n    function claimReward(address[] memory _holders, address[] memory _iTokens)\r\n        public\r\n        override\r\n    {\r\n        updateRewardBatch(_holders, _iTokens);\r\n\r\n        // Withdraw all reward for all holders\r\n        for (uint256 j = 0; j < _holders.length; j++) {\r\n            address _account = _holders[j];\r\n            uint256 _reward = reward[_account];\r\n            if (_reward > 0) {\r\n                reward[_account] = 0;\r\n                IERC20Upgradeable(rewardToken).safeTransfer(_account, _reward);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim reward accrued in all iTokens by the holders\r\n     * @param _holders The account to claim for\r\n     */\r\n    function claimAllReward(address[] memory _holders) external override {\r\n        claimReward(_holders, controller.getAlliTokens());\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowSpeed\",\"type\":\"uint256\"}],\"name\":\"DistributionBorrowSpeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplySpeed\",\"type\":\"uint256\"}],\"name\":\"DistributionSupplySpeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowSpeed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplySpeed\",\"type\":\"uint256\"}],\"name\":\"GlobalDistributionSpeedsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDistributionFactorMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDistributionFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"NewDistributionFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldPendingOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"NewPendingOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributionFactor\",\"type\":\"uint256\"}],\"name\":\"NewRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRewardToken\",\"type\":\"address\"}],\"name\":\"NewRewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountIndex\",\"type\":\"uint256\"}],\"name\":\"RewardDistributed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_acceptOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_iToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_distributionFactor\",\"type\":\"uint256\"}],\"name\":\"_addRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_iTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_borrowSpeeds\",\"type\":\"uint256[]\"}],\"name\":\"_setDistributionBorrowSpeeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_borrowiTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_borrowSpeeds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_supplyiTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supplySpeeds\",\"type\":\"uint256[]\"}],\"name\":\"_setDistributionSpeeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_iTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supplySpeeds\",\"type\":\"uint256[]\"}],\"name\":\"_setDistributionSupplySpeeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"_setPendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRewardToken\",\"type\":\"address\"}],\"name\":\"_setRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_borrowiTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_borrowSpeeds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_supplyiTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_supplySpeeds\",\"type\":\"uint256[]\"}],\"name\":\"_unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_holders\",\"type\":\"address[]\"}],\"name\":\"claimAllReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_holders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_iTokens\",\"type\":\"address[]\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract Controller\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionBorrowState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionBorrowerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionSupplierIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionSupplySpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributionSupplyState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalDistributionSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalDistributionSupplySpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Controller\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_iToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBorrow\",\"type\":\"bool\"}],\"name\":\"updateDistributionState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_iToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBorrow\",\"type\":\"bool\"}],\"name\":\"updateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_holders\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_iTokens\",\"type\":\"address[]\"}],\"name\":\"updateRewardBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RewardDistributorV3","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://bd97a79f94743771bafe91bcee081855b01fe940f848d5efb8a53c696c1ce764"}]}