{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\r\n\r\n/**\r\n * @title Interface for EllipticCurve contract.\r\n */\r\ninterface EllipticCurveInterface {\r\n\r\n    function validateSignature(bytes32 message, uint[2] calldata rs, uint[2] calldata Q) external view returns (bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for Register contract.\r\n */\r\ninterface RegisterInterface {\r\n\r\n  function isDeviceMintable(bytes32 hardwareHash) external view returns (bool);\r\n  function getRootDetails(bytes32 root) external view returns (uint256, uint256, uint256, uint256, string memory, string memory, uint256, uint256);\r\n  function mintKong(bytes32[] calldata proof, bytes32 root, bytes32 hardwareHash, address recipient) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Kong Entropy Contract.\r\n *\r\n * @dev   This contract can be presented with signatures for public keys registered in the\r\n *        `Register` contract. The function `submitEntropy()` verifies the validity of the\r\n *        signature using the remotely deployed `EllipticCurve` contract. If the signature\r\n *        is valid, the contract calls the `mintKong()` function of the `Register` contract\r\n *        to mint Kong.\r\n */\r\ncontract KongEntropyMerkle {\r\n\r\n    // Addresses of the contracts `Register` and `EllipticCurve`.\r\n    address public _regAddress;\r\n    address public _eccAddress;\r\n\r\n    // Mapping for minting status of keys.\r\n    mapping(bytes32 => bool) public _mintedKeys;\r\n\r\n    // Emits when submitEntropy() is successfully called.\r\n    event Minted(\r\n        bytes32 hardwareHash,\r\n        bytes32 message,\r\n        uint256 r,\r\n        uint256 s\r\n    );\r\n\r\n    /**\r\n     * @dev The constructor sets the addresses of the contracts `Register` and `EllipticCurve`.\r\n     *\r\n     * @param eccAddress           The address of the EllipticCurve contract.\r\n     * @param regAddress           The address of the Register contract.\r\n     */\r\n    constructor(address eccAddress, address regAddress) public {\r\n\r\n        _eccAddress = eccAddress;\r\n        _regAddress = regAddress;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev `submitEntropy()` can be presented with SECP256R1 signatures of public keys registered\r\n     *      in the `Register` contract. When presented with a valid signature in the expected format,\r\n     *      the contract calls the `mintKong()` function of `Register` to mint Kong token to `to`.\r\n\r\n     *\r\n     * @param merkleProof             Merkle proof for the device.\r\n     * @param merkleRoot              Merkle root the device belongs to.     \r\n     * @param primaryPublicKeyHash    Hash of the primary public key.\r\n     * @param secondaryPublicKeyHash  Hash of the secondary public key.\r\n     * @param hardwareSerial          Hash of the hardwareSerial number.\r\n     * @param tertiaryPublicKeyX      The x-coordinate of the tertiary public key.\r\n     * @param tertiaryPublicKeyY      The y-coordinate of the tertiary public key.\r\n     * @param to                      Recipient.\r\n     * @param blockNumber             Block number of the signed blockhash.\r\n     * @param rs                      The array containing the r & s values fo the signature.\r\n     */\r\n    function submitEntropy(\r\n        bytes32[] memory merkleProof, \r\n        bytes32 merkleRoot, \r\n        bytes32 primaryPublicKeyHash,\r\n        bytes32 secondaryPublicKeyHash,\r\n        bytes32 hardwareSerial,\r\n        uint256 tertiaryPublicKeyX,\r\n        uint256 tertiaryPublicKeyY,\r\n        address to,\r\n        uint256 blockNumber,\r\n        uint256[2] memory rs\r\n    )\r\n        public\r\n    {\r\n\r\n        // Hash the provided tertiary key.\r\n        bytes32 hashedKey = sha256(abi.encodePacked(tertiaryPublicKeyX, tertiaryPublicKeyY));\r\n\r\n        // Hash all the keys in order to calculate the hardwareHash.\r\n        bytes32 hardwareHash = sha256(abi.encodePacked(primaryPublicKeyHash, secondaryPublicKeyHash, hashedKey, hardwareSerial));\r\n\r\n        // Verify that no signature has been submitted before for this key.\r\n        require(_mintedKeys[hardwareHash] == false, 'Already minted.');\r\n\r\n        // Check registry to verify if device is mintable.\r\n        require(RegisterInterface(_regAddress).isDeviceMintable(hardwareHash), 'Minted in registry.');\r\n\r\n        // Get Kong amount; Divide internal representation by 10 ** 19 for cost scaling; perform work in proportion to scaledKongAmount.\r\n        uint256 kongAmount;\r\n        (kongAmount, , , , , , , ) = RegisterInterface(_regAddress).getRootDetails(merkleRoot);\r\n        for (uint i=0; i < kongAmount / uint(10 ** 19); i++) {\r\n            keccak256(abi.encodePacked(blockhash(block.number)));\r\n        }\r\n\r\n        // Validate signature.\r\n        bytes32 messageHash = sha256(abi.encodePacked(to, blockhash(blockNumber)));\r\n        require(_validateSignature(messageHash, rs, tertiaryPublicKeyX, tertiaryPublicKeyY), 'Invalid signature.');\r\n\r\n        // Call minting function in Register contract.\r\n        RegisterInterface(_regAddress).mintKong(merkleProof, merkleRoot, hardwareHash, to);\r\n\r\n        // Update mapping with minted keys.\r\n        _mintedKeys[hardwareHash] = true;\r\n\r\n        // Emit event.\r\n        emit Minted(hardwareHash, messageHash, rs[0], rs[1]);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to validate SECP256R1 signatures.\r\n     *\r\n     * @param message           The hash of the signed message.\r\n     * @param rs                R+S value of the signature.\r\n     * @param publicKeyX        X-coordinate of the publicKey.\r\n     * @param publicKeyY        Y-coordinate of the publicKey.\r\n     */\r\n    function _validateSignature(\r\n        bytes32 message,\r\n        uint256[2] memory rs,\r\n        uint256 publicKeyX,\r\n        uint256 publicKeyY\r\n    )\r\n        internal view returns (bool)\r\n    {\r\n        return EllipticCurveInterface(_eccAddress).validateSignature(message, rs, [publicKeyX, publicKeyY]);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check if a given hardwareHash has been minted or not.\r\n     *\r\n     * @param hardwareHash      The hardwareHash of the device.\r\n     */\r\n    function isDeviceMinted(\r\n        bytes32 hardwareHash\r\n    )\r\n        external view returns (bool)\r\n    {\r\n        return _mintedKeys[hardwareHash];\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"eccAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"regAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hardwareHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"_eccAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_mintedKeys\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_regAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hardwareHash\",\"type\":\"bytes32\"}],\"name\":\"isDeviceMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"primaryPublicKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"secondaryPublicKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"hardwareSerial\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tertiaryPublicKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tertiaryPublicKeyY\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"rs\",\"type\":\"uint256[2]\"}],\"name\":\"submitEntropy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KongEntropyMerkle","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f471789937856d80e589f5996cf8b0511ddd9de4000000000000000000000000388b9a490f08310285f965addcfb08d693972533","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://52b19dd1618c2284b90ce5c1e79366b5e50554c3178e74914f51af47ae425d37"}]}