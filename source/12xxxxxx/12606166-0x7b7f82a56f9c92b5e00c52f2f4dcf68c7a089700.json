{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nabstract contract IERC721 {\r\n    // Required methods\r\n    function totalSupply() public view virtual returns (uint256 total);\r\n\r\n    function balanceOf(address _owner)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        virtual\r\n        returns (address owner);\r\n\r\n    function approve(address _to, uint256 _tokenId) external virtual;\r\n\r\n    function transfer(address _to, uint256 _tokenId) external virtual;\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external virtual;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        virtual\r\n        returns (bool);\r\n}\r\n\r\ncontract KanamitCore is IERC721, Ownable {\r\n    /*** EVENTS ***/\r\n    event Create(address owner, uint256 AssetId, uint256 hashUri, string uri);\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    struct Asset {\r\n        uint256 hashUri;\r\n    }\r\n\r\n    /*** STORAGE ***/\r\n    Asset[] assets;\r\n    mapping(uint256 => address) private AssetIndexToOwner; // map<assetId , addrOwner>\r\n    mapping(address => uint256) private OwnerAssetCount; // map<addrOwner, uintCount>\r\n    mapping(address => mapping(uint256 => uint256)) private OwnerAssets; // map<addrOwner, map<hashUri, assetId> >\r\n    mapping(uint256 => address) private AssetIndexToApproved; //map<assetId, addrApproved>\r\n    mapping(uint256 => uint256) private mapUriAssetId; //map<hashUri, AssetId>\r\n\r\n    constructor() public {\r\n        //初始化第一个元素；addressOwner 为address(0)， uri为空字符\"\"，对应的AssetId为0；\r\n        uint256 hashUri = uint256(keccak256(abi.encodePacked(\"\")));\r\n        Asset memory currAsset = Asset({hashUri: hashUri});\r\n        assets.push(currAsset);\r\n    }\r\n\r\n    /// @dev Assigns ownership of a specific Asset to an address.\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) internal {\r\n        uint256 hashUri = assets[_tokenId].hashUri;\r\n        // Since the number of Assets is capped to 2^32 we can't overflow this\r\n        OwnerAssetCount[_to]++;\r\n        OwnerAssets[_to][hashUri] = _tokenId;\r\n        mapUriAssetId[hashUri] = _tokenId;\r\n        // transfer ownership\r\n        AssetIndexToOwner[_tokenId] = _to;\r\n        // When creating new Assets _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            OwnerAssetCount[_from]--;\r\n            delete OwnerAssets[_from][hashUri];\r\n            // clear any previously approved ownership exchange\r\n            delete AssetIndexToApproved[_tokenId];\r\n        }\r\n        // Emit the transfer event.\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function createAsset(address _owner, string memory _uri)\r\n        public\r\n        onlyOwner()\r\n        returns (uint256)\r\n    {\r\n        uint256 hashUri = uint256(keccak256(abi.encodePacked(_uri)));\r\n        uint256 assetId = getAssetId(_uri);\r\n        address currOwner = getUriOwner(_uri);\r\n\r\n        require(currOwner == address(0), 'asset already mint, found by owner');\r\n        require(assetId == 0, 'asset already mint, found by assetId');\r\n\r\n        Asset memory currAsset = Asset({hashUri: hashUri});\r\n        assets.push(currAsset);\r\n        uint256 newAssetId = assets.length - 1;\r\n\r\n        // It's probably never going to happen, 4 billion cats is A LOT, but\r\n        // let's just be 100% sure we never let this happen.\r\n        require(newAssetId == uint256(uint32(newAssetId)));\r\n\r\n        // emit the create event\r\n        Create(_owner, newAssetId, hashUri, _uri);\r\n\r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        _transfer(address(0), _owner, newAssetId);\r\n\r\n        return newAssetId;\r\n    }\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256(\"name()\")) ^\r\n            bytes4(keccak256(\"symbol()\")) ^\r\n            bytes4(keccak256(\"totalSupply()\")) ^\r\n            bytes4(keccak256(\"balanceOf(address)\")) ^\r\n            bytes4(keccak256(\"ownerOf(uint256)\")) ^\r\n            bytes4(keccak256(\"approve(address,uint256)\")) ^\r\n            bytes4(keccak256(\"transfer(address,uint256)\")) ^\r\n            bytes4(keccak256(\"transferFrom(address,address,uint256)\")) ^\r\n            bytes4(keccak256(\"tokensOfOwner(address)\")) ^\r\n            bytes4(keccak256(\"tokenMetadata(uint256,string)\"));\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return assets.length;\r\n    }\r\n\r\n    function balanceOf(address _owner)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256 count)\r\n    {\r\n        return OwnerAssetCount[_owner];\r\n    }\r\n\r\n    function getAssetId(string memory uri)\r\n        public\r\n        view\r\n        returns (uint256 assetId)\r\n    {\r\n        uint256 hashUri = uint256(keccak256(abi.encodePacked(uri)));\r\n        assetId = mapUriAssetId[hashUri];\r\n    }\r\n\r\n    function getUriOwner(string memory uri)\r\n        public\r\n        view\r\n        returns (address addressOwner)\r\n    {\r\n        uint256 hashUri = uint256(keccak256(abi.encodePacked(uri)));\r\n        uint256 assetId = mapUriAssetId[hashUri];\r\n\r\n        if (assetId == 0) return address(0);\r\n\r\n        return AssetIndexToOwner[assetId];\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (address owner)\r\n    {\r\n        owner = AssetIndexToOwner[_tokenId];\r\n\r\n        require(owner != address(0));\r\n    }\r\n\r\n    function approve(address _to, uint256 _tokenId) external virtual override {\r\n        // Only an owner can grant transfer approval.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Register the approval (replacing any previous approval).\r\n        _approve(_tokenId, _to);\r\n\r\n        // Emit approval event.\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokenId) external virtual override {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any kitties (except very briefly\r\n        // after a gen0 cat is created and before it goes on auction).\r\n        require(_to != address(this));\r\n\r\n        // You can only send your own cat.\r\n        require(_owns(msg.sender, _tokenId), 'only owner can transfer');\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external virtual override {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any kitties (except very briefly\r\n        // after a gen0 cat is created and before it goes on auction).\r\n        require(_to != address(this));\r\n        // Check for approval and valid ownership\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _owns(address _claimant, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return AssetIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        AssetIndexToApproved[_tokenId] = _approved;\r\n    }\r\n\r\n    function _approvedFor(address _claimant, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return AssetIndexToApproved[_tokenId] == _claimant;\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        // DEBUG ONLY\r\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\r\n\r\n        return ((_interfaceID == InterfaceSignature_ERC165) ||\r\n            (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    function getAssetById(uint256 _id) external view returns (uint256 hashUri) {\r\n        Asset storage asset = assets[_id];\r\n\r\n        hashUri = asset.hashUri;\r\n    }\r\n\r\n    function getAsset(address owner, uint256 hashUri)\r\n        external\r\n        view\r\n        returns (uint256 assetId)\r\n    {\r\n        assetId = OwnerAssets[owner][hashUri];\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"AssetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hashUri\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"createAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hashUri\",\"type\":\"uint256\"}],\"name\":\"getAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getAssetById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hashUri\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"getAssetId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"getUriOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addressOwner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KanamitCore","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://03acd495a40585724bdadc6b8dd97eae1fc8ff3436ef952fe4a75d7f0337face"}]}