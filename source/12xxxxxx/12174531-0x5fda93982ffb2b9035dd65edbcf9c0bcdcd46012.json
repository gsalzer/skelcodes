{"status":"1","message":"OK","result":[{"SourceCode":"// Copyright 2020 Opera Norway AS\r\n//\r\n// Redistribution and use in source and binary forms, with or without modification, are permitted\r\n// provided that the following conditions are met:\r\n// 1. Redistributions of source code must retain the above copyright notice, this list of\r\n//    conditions and the following disclaimer.\r\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of\r\n//    conditions and the following disclaimer in the documentation and/or other materials provided\r\n//    with the distribution.\r\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to\r\n//    endorse or promote products derived from this software without specific prior written\r\n//    permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS\r\n// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\r\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\r\n// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n// POSSIBILITY OF SUCH DAMAGE.\r\n\r\npragma solidity 0.6.12;\r\n\r\nabstract contract DaiLike {\r\n    function transferFrom(address src, address dst, uint wad) public virtual;\r\n\r\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\r\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external virtual;\r\n\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n    mapping (address => uint)                      public balanceOf;\r\n    mapping (address => uint)                      public  nonces;\r\n\r\n    string public name;\r\n    string public constant version  = \"1\";\r\n}\r\n\r\ncontract DaiProxy {\r\n    DaiLike public dai;\r\n\r\n    // Auth\r\n    address public owner;\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Proxy/NotAuthorized\");\r\n        _;\r\n    }\r\n\r\n    mapping (address => uint) public relayers;\r\n    modifier onlyRelayer {\r\n        require(relayers[msg.sender] == 1, \"Proxy/InvalidRelayer\");\r\n        _;\r\n    }\r\n    function addRelayer(address relayer_) external onlyOwner {\r\n        require(relayer_ != address(0));\r\n        relayers[relayer_] = 1;\r\n    }\r\n    function removeRelayer(address relayer_) external onlyOwner {\r\n        require(relayer_ != address(0));\r\n        relayers[relayer_] = 0;\r\n    }\r\n\r\n    address public feeRecipient;\r\n    function setFeeRecipient(address feeRecipient_) external onlyOwner {\r\n        require(feeRecipient_ != address(0));\r\n        feeRecipient = feeRecipient_;\r\n    }\r\n\r\n    constructor (DaiLike dai_, address relayer_, address feeRecipient_) public {\r\n        require(address(dai_) != address(0));\r\n        require(relayer_ != address(0));\r\n        require(feeRecipient_ != address(0));\r\n        require(feeRecipient_ != address(this));\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n            keccak256(bytes(name)),\r\n            keccak256(bytes(version)),\r\n            getChainID(),\r\n            address(this)\r\n        ));\r\n\r\n        dai = dai_;\r\n        owner = msg.sender;\r\n        relayers[relayer_] = 1;\r\n        feeRecipient = feeRecipient_;\r\n    }\r\n\r\n    // Safe math helpers, throws on under/overflow\r\n    function safeAdd(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function safeSub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    // EIP712\r\n    string  public constant name    = \"DaiProxy\";\r\n    string  public constant version = \"1.0\";\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    bytes32 public constant TRANSFER_TYPEHASH = keccak256(\"Transfer(address sender,address recipient,uint256 amount,uint256 fee,uint256 expiry,uint256 nonce)\");\r\n\r\n    mapping (address => uint256) public nonces;\r\n\r\n    // Transfer dai from src to dst. Takes both a signature for permit and\r\n    // transfer so they can always be done in one transaction. Permit will\r\n    // only be done when needed.\r\n    // The permit can be revoked by calling the approve() method in the DAI\r\n    // contract.\r\n    function permitAndTransfer(\r\n        address sender, address recipient, uint256 amount, uint256 fee, uint256 expiry,\r\n        uint256 nonce, uint8 v, bytes32 r, bytes32 s,\r\n        uint256 p_nonce, uint8 p_v, bytes32 p_r, bytes32 p_s)\r\n        onlyRelayer external {\r\n\r\n        if (safeAdd(amount, fee) >= dai.allowance(sender, address(this))) {\r\n            dai.permit(sender, address(this), p_nonce, expiry, true, p_v, p_r, p_s);\r\n        }\r\n\r\n        transfer(sender, recipient, amount, fee, expiry, nonce, v, r, s);\r\n    }\r\n\r\n    function transfer(\r\n        address sender, address recipient, uint256 amount, uint256 fee, uint256 expiry,\r\n        uint256 nonce, uint8 v, bytes32 r, bytes32 s)\r\n        onlyRelayer public {\r\n\r\n        bytes32 digest =\r\n            keccak256(abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(TRANSFER_TYPEHASH,\r\n                                     sender,\r\n                                     recipient,\r\n                                     amount,\r\n                                     fee,\r\n                                     expiry,\r\n                                     nonce))\r\n        ));\r\n\r\n        require(sender != address(0), \"Proxy/invalid src address\");\r\n        require(recipient != address(0), \"Proxy/invalid dst address\");\r\n        require(nonce == nonces[sender]++, \"Proxy/invalid nonce\");\r\n        require(safeAdd(amount, fee) <= dai.balanceOf(sender), \"Proxy/insufficient funds\");\r\n        require(sender == ecrecover(digest, v, r, s), \"Proxy/invalid signature\");\r\n        require(expiry == 0 || now <= expiry, \"Proxy/permit-expired\");\r\n\r\n        // Transfer fee to fee recipient\r\n        if (fee > 0) {\r\n            dai.transferFrom(sender, feeRecipient, fee);\r\n        }\r\n        dai.transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function getChainID() private pure returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract DaiLike\",\"name\":\"dai_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRecipient_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relayer_\",\"type\":\"address\"}],\"name\":\"addRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract DaiLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"p_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"p_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"p_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"p_s\",\"type\":\"bytes32\"}],\"name\":\"permitAndTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"relayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relayer_\",\"type\":\"address\"}],\"name\":\"removeRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeRecipient_\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DaiProxy","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000865589261475863444a52bfe8c71ff829ca959730000000000000000000000005903568d7d91980d087c27c30cc5aa2d1d945e61","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a618492c2cc4de3992fc0b94b4969ee896b3f1ad0d2852f4828fdc933ded7f1b"}]}