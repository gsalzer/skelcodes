{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ClaimManagement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20/SafeERC20.sol\\\";\\nimport \\\"./ClaimConfig.sol\\\";\\nimport \\\"./interfaces/ICoverPool.sol\\\";\\nimport \\\"./interfaces/ICoverPoolFactory.sol\\\";\\nimport \\\"./interfaces/IClaimManagement.sol\\\";\\n\\n/**\\n * @title Claim Management for claims filed for a COVER supported coverPool\\n * @author Alan + crypto-pumpkin\\n */\\ncontract ClaimManagement is IClaimManagement, ClaimConfig {\\n  using SafeERC20 for IERC20;\\n\\n  // the redeem delay for a cover when there is a pending claim\\n  uint256 public constant PENDING_CLAIM_REDEEM_DELAY = 10 days;\\n  // coverPool => nonce => Claim[]\\n  mapping(address => mapping(uint256 => Claim[])) private coverPoolClaims;\\n\\n  constructor(\\n    address _feeCurrency,\\n    address _treasury,\\n    address _coverPoolFactory,\\n    address _defaultCVC\\n  ) {\\n    require(_feeCurrency != address(0), \\\"CM: fee cannot be 0\\\");\\n    require(_treasury != address(0), \\\"CM: treasury cannot be 0\\\");\\n    require(_coverPoolFactory != address(0), \\\"CM: factory cannot be 0\\\");\\n    require(_defaultCVC != address(0), \\\"CM: defaultCVC cannot be 0\\\");\\n    feeCurrency = IERC20(_feeCurrency);\\n    treasury = _treasury;\\n    coverPoolFactory = ICoverPoolFactory(_coverPoolFactory);\\n    defaultCVC = _defaultCVC;\\n\\n    initializeOwner();\\n  }\\n\\n  /// @notice File a claim for a Cover Pool, `_incidentTimestamp` must be within allowed time window\\n  function fileClaim(\\n    string calldata _coverPoolName,\\n    bytes32[] calldata _exploitRisks,\\n    uint48 _incidentTimestamp,\\n    string calldata _description,\\n    bool isForceFile\\n  ) external override {\\n    address coverPool = _getCoverPoolAddr(_coverPoolName);\\n    require(coverPool != address(0), \\\"CM: pool not found\\\");\\n    require(block.timestamp - _incidentTimestamp <= coverPoolFactory.defaultRedeemDelay() - TIME_BUFFER, \\\"CM: time passed window\\\");\\n\\n    ICoverPool(coverPool).setNoclaimRedeemDelay(PENDING_CLAIM_REDEEM_DELAY);\\n    uint256 nonce = _getCoverPoolNonce(coverPool);\\n    uint256 claimFee = isForceFile ? forceClaimFee : getCoverPoolClaimFee(coverPool);\\n    feeCurrency.safeTransferFrom(msg.sender, address(this), claimFee);\\n    _updateCoverPoolClaimFee(coverPool);\\n    ClaimState state = isForceFile ? ClaimState.ForceFiled : ClaimState.Filed;\\n    coverPoolClaims[coverPool][nonce].push(Claim({\\n      filedBy: msg.sender,\\n      decidedBy: address(0),\\n      filedTimestamp: uint48(block.timestamp),\\n      incidentTimestamp: _incidentTimestamp,\\n      decidedTimestamp: 0,\\n      description: _description,\\n      state: state,\\n      feePaid: claimFee,\\n      payoutRiskList: _exploitRisks,\\n      payoutRates: new uint256[](_exploitRisks.length)\\n    }));\\n    emit ClaimUpdate(coverPool, state, nonce, coverPoolClaims[coverPool][nonce].length - 1);\\n  }\\n\\n  /**\\n   * @notice Validates whether claim will be passed to CVC to decideClaim\\n   * @param _coverPool address: contract address of the coverPool that COVER supports\\n   * @param _nonce uint256: nonce of the coverPool\\n   * @param _index uint256: index of the claim\\n   * @param _claimIsValid bool: true if claim is valid and passed to CVC, false otherwise\\n   * Emits ClaimUpdate\\n   */\\n  function validateClaim(\\n    address _coverPool,\\n    uint256 _nonce,\\n    uint256 _index,\\n    bool _claimIsValid\\n  ) external override onlyOwner {\\n    Claim storage claim = coverPoolClaims[_coverPool][_nonce][_index];\\n    require(_index < coverPoolClaims[_coverPool][_nonce].length, \\\"CM: bad index\\\");\\n    require(_nonce == _getCoverPoolNonce(_coverPool), \\\"CM: wrong nonce\\\");\\n    require(claim.state == ClaimState.Filed, \\\"CM: claim not filed\\\");\\n    if (_claimIsValid) {\\n      claim.state = ClaimState.Validated;\\n      _resetCoverPoolClaimFee(_coverPool);\\n    } else {\\n      claim.state = ClaimState.Invalidated;\\n      claim.decidedTimestamp = uint48(block.timestamp);\\n      feeCurrency.safeTransfer(treasury, claim.feePaid);\\n      _resetNoclaimRedeemDelay(_coverPool, _nonce);\\n    }\\n    emit ClaimUpdate({\\n      coverPool: _coverPool,\\n      state: claim.state,\\n      nonce: _nonce,\\n      index: _index\\n    });\\n  }\\n\\n  /// @notice Decide whether claim for a coverPool should be accepted(will payout) or denied, ignored _incidentTimestamp == 0\\n  function decideClaim(\\n    address _coverPool,\\n    uint256 _nonce,\\n    uint256 _index,\\n    uint48 _incidentTimestamp,\\n    bool _claimIsAccepted,\\n    bytes32[] calldata _exploitRisks,\\n    uint256[] calldata _payoutRates\\n  ) external override {\\n    require(_exploitRisks.length == _payoutRates.length, \\\"CM: arrays len don't match\\\");\\n    require(isCVCMember(_coverPool, msg.sender), \\\"CM: !cvc\\\");\\n    require(_nonce == _getCoverPoolNonce(_coverPool), \\\"CM: wrong nonce\\\");\\n    Claim storage claim = coverPoolClaims[_coverPool][_nonce][_index];\\n    require(claim.state == ClaimState.Validated || claim.state == ClaimState.ForceFiled, \\\"CM: ! validated or forceFiled\\\");\\n    if (_incidentTimestamp != 0) {\\n      require(claim.filedTimestamp - _incidentTimestamp <= coverPoolFactory.defaultRedeemDelay() - TIME_BUFFER, \\\"CM: time passed window\\\");\\n      claim.incidentTimestamp = _incidentTimestamp;\\n    }\\n\\n    uint256 totalRates = _getTotalNum(_payoutRates);\\n    if (_claimIsAccepted && !_isDecisionWindowPassed(claim)) {\\n      require(totalRates > 0 && totalRates <= 1 ether, \\\"CM: payout % not in (0%, 100%]\\\");\\n      feeCurrency.safeTransfer(claim.filedBy, claim.feePaid);\\n      _resetCoverPoolClaimFee(_coverPool);\\n      claim.state = ClaimState.Accepted;\\n      claim.payoutRiskList = _exploitRisks;\\n      claim.payoutRates = _payoutRates;\\n      ICoverPool(_coverPool).enactClaim(claim.payoutRiskList, claim.payoutRates, claim.incidentTimestamp, _nonce);\\n    } else { // Max decision claim window passed, claim is default to Denied\\n      require(totalRates == 0, \\\"CM: claim denied (default if passed window), but payoutNumerator != 0\\\");\\n      feeCurrency.safeTransfer(treasury, claim.feePaid);\\n      claim.state = ClaimState.Denied;\\n    }\\n    _resetNoclaimRedeemDelay(_coverPool, _nonce);\\n    claim.decidedBy = msg.sender;\\n    claim.decidedTimestamp = uint48(block.timestamp);\\n    emit ClaimUpdate(_coverPool, claim.state, _nonce, _index);\\n  }\\n\\n  function getCoverPoolClaims(address _coverPool, uint256 _nonce, uint256 _index) external view override returns (Claim memory) {\\n    return coverPoolClaims[_coverPool][_nonce][_index];\\n  }\\n\\n  /// @notice Get all claims for coverPool `_coverPool` and nonce `_nonce` in state `_state`\\n  function getAllClaimsByState(address _coverPool, uint256 _nonce, ClaimState _state)\\n    external view override returns (Claim[] memory)\\n  {\\n    Claim[] memory allClaims = coverPoolClaims[_coverPool][_nonce];\\n    uint256 count;\\n    Claim[] memory temp = new Claim[](allClaims.length);\\n    for (uint i = 0; i < allClaims.length; i++) {\\n      if (allClaims[i].state == _state) {\\n        temp[count] = allClaims[i];\\n        count++;\\n      }\\n    }\\n    Claim[] memory claimsByState = new Claim[](count);\\n    for (uint i = 0; i < count; i++) {\\n      claimsByState[i] = temp[i];\\n    }\\n    return claimsByState;\\n  }\\n\\n  /// @notice Get all claims for coverPool `_coverPool` and nonce `_nonce`\\n  function getAllClaimsByNonce(address _coverPool, uint256 _nonce) external view override returns (Claim[] memory) {\\n    return coverPoolClaims[_coverPool][_nonce];\\n  }\\n\\n  /// @notice Get whether a pending claim for coverPool `_coverPool` and nonce `_nonce` exists\\n  function hasPendingClaim(address _coverPool, uint256 _nonce) public view override returns (bool) {\\n    Claim[] memory allClaims = coverPoolClaims[_coverPool][_nonce];\\n    for (uint i = 0; i < allClaims.length; i++) {\\n      ClaimState state = allClaims[i].state;\\n      if (state == ClaimState.Filed || state == ClaimState.ForceFiled || state == ClaimState.Validated) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function _resetNoclaimRedeemDelay(address _coverPool, uint256 _nonce) private {\\n    if (hasPendingClaim(_coverPool, _nonce)) return;\\n    uint256 defaultRedeemDelay = coverPoolFactory.defaultRedeemDelay();\\n    ICoverPool(_coverPool).setNoclaimRedeemDelay(defaultRedeemDelay);\\n  }\\n\\n  function _getCoverPoolAddr(string calldata _coverPoolName) private view returns (address) {\\n    return coverPoolFactory.coverPools(_coverPoolName);\\n  }\\n\\n  function _getCoverPoolNonce(address _coverPool) private view returns (uint256) {\\n    return ICoverPool(_coverPool).claimNonce();\\n  }\\n\\n  // The times passed since the claim was filed has to be less than the max claim decision window\\n  function _isDecisionWindowPassed(Claim memory claim) private view returns (bool) {\\n    return block.timestamp - claim.filedTimestamp > maxClaimDecisionWindow;\\n  }\\n\\n  function _getTotalNum(uint256[] calldata _payoutRates) private pure returns (uint256 _totalRates) {\\n    for (uint256 i = 0; i < _payoutRates.length; i++) {\\n      _totalRates = _totalRates + _payoutRates[i];\\n    }\\n  }\\n} \"\r\n    },\r\n    \"contracts/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) - value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/ClaimConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./utils/Ownable.sol\\\";\\nimport \\\"./interfaces/IClaimConfig.sol\\\";\\nimport \\\"./interfaces/ICoverPool.sol\\\";\\nimport \\\"./interfaces/ICoverPoolFactory.sol\\\";\\n\\n/**\\n * @title Config for ClaimManagement contract\\n * @author Alan + crypto-pumpkin\\n */\\ncontract ClaimConfig is IClaimConfig, Ownable {\\n\\n  IERC20 public override feeCurrency;\\n  address public override treasury;\\n  ICoverPoolFactory public override coverPoolFactory;\\n  address public override defaultCVC; // if not specified, default to this\\n\\n  uint256 internal constant TIME_BUFFER = 1 hours;\\n  // The max time allowed from filing a claim to a decision made, 1 hr buffer for calling\\n  uint256 public override maxClaimDecisionWindow = 7 days - TIME_BUFFER;\\n  uint256 public override baseClaimFee = 50e18;\\n  uint256 public override forceClaimFee = 500e18;\\n  uint256 public override feeMultiplier = 2;\\n\\n  // coverPool => claim fee\\n  mapping(address => uint256) private coverPoolClaimFee;\\n  // coverPool => cvc addresses\\n  mapping(address => address[]) public override cvcMap;\\n\\n  function setTreasury(address _treasury) external override onlyOwner {\\n    require(_treasury != address(0), \\\"CC: treasury cannot be 0\\\");\\n    treasury = _treasury;\\n  }\\n\\n  /// @notice Set max time window allowed to decide a claim after filed\\n  function setMaxClaimDecisionWindow(uint256 _newTimeWindow) external override onlyOwner {\\n    require(_newTimeWindow > 0, \\\"CC: window too short\\\");\\n    maxClaimDecisionWindow = _newTimeWindow;\\n  }\\n\\n  function setDefaultCVC(address _cvc) external override onlyOwner {\\n    require(_cvc != address(0), \\\"CC: default CVC cannot be 0\\\");\\n    defaultCVC = _cvc;\\n  }\\n\\n  /// @notice Add CVC groups for multiple coverPools\\n  function addCVCForPools(address[] calldata _coverPools, address[] calldata _cvcs) external override onlyOwner {\\n    require(_coverPools.length == _cvcs.length, \\\"CC: lengths don't match\\\");\\n    for (uint256 i = 0; i < _coverPools.length; i++) {\\n      _addCVCForPool(_coverPools[i], _cvcs[i]);\\n    }\\n  }\\n\\n  /// @notice Remove CVC groups for multiple coverPools\\n  function removeCVCForPools(address[] calldata _coverPools, address[] calldata _cvcs) external override onlyOwner {\\n    require(_coverPools.length == _cvcs.length, \\\"CC: lengths don't match\\\");\\n    for (uint256 i = 0; i < _coverPools.length; i++) {\\n      _removeCVCForPool(_coverPools[i], _cvcs[i]);\\n    }\\n  }\\n\\n  function setFeeAndCurrency(uint256 _baseClaimFee, uint256 _forceClaimFee, address _currency) external override onlyOwner {\\n    require(_currency != address(0), \\\"CC: feeCurrency cannot be 0\\\");\\n    require(_baseClaimFee > 0, \\\"CC: baseClaimFee <= 0\\\");\\n    require(_forceClaimFee > _baseClaimFee, \\\"CC: force Fee <= base Fee\\\");\\n    baseClaimFee = _baseClaimFee;\\n    forceClaimFee = _forceClaimFee;\\n    feeCurrency = IERC20(_currency);\\n  }\\n\\n  function setFeeMultiplier(uint256 _multiplier) external override onlyOwner {\\n    require(_multiplier >= 1, \\\"CC: multiplier must be >= 1\\\");\\n    feeMultiplier = _multiplier;\\n  }\\n\\n  /// @notice return the whole list so dont need to query by index\\n  function getCVCList(address _coverPool) external view override returns (address[] memory) {\\t\\n    return cvcMap[_coverPool];\\t\\n  }\\n\\n  function isCVCMember(address _coverPool, address _address) public view override returns (bool) {\\n    address[] memory cvcCopy = cvcMap[_coverPool];\\n    if (cvcCopy.length == 0 && _address == defaultCVC) return true;\\n    for (uint256 i = 0; i < cvcCopy.length; i++) {\\n      if (_address == cvcCopy[i]) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function getCoverPoolClaimFee(address _coverPool) public view override returns (uint256) {\\n    return coverPoolClaimFee[_coverPool] < baseClaimFee ? baseClaimFee : coverPoolClaimFee[_coverPool];\\n  }\\n\\n  // Add CVC group for a coverPool if `_cvc` isn't already added\\n  function _addCVCForPool(address _coverPool, address _cvc) private onlyOwner {\\n    address[] memory cvcCopy = cvcMap[_coverPool];\\n    for (uint256 i = 0; i < cvcCopy.length; i++) {\\n      require(cvcCopy[i] != _cvc, \\\"CC: cvc exists\\\");\\n    }\\n    cvcMap[_coverPool].push(_cvc);\\n  }\\n\\n  function _removeCVCForPool(address _coverPool, address _cvc) private {\\n    address[] memory cvcCopy = cvcMap[_coverPool];\\n    uint256 len = cvcCopy.length;\\n    if (len < 1) return; // nothing to remove, no need to revert\\n    for (uint256 i = 0; i < len; i++) {\\n      if (_cvc == cvcCopy[i]) {\\n        cvcMap[_coverPool][i] = cvcCopy[len - 1];\\n        cvcMap[_coverPool].pop();\\n        break;\\n      }\\n    }\\n  }\\n\\n  // Updates fee for coverPool `_coverPool` by multiplying current fee by `feeMultiplier`, capped at `forceClaimFee`\\n  function _updateCoverPoolClaimFee(address _coverPool) internal {\\n    uint256 newFee = getCoverPoolClaimFee(_coverPool) * feeMultiplier;\\n    if (newFee <= forceClaimFee) {\\n      coverPoolClaimFee[_coverPool] = newFee;\\n    }\\n  }\\n\\n  // Resets fee for coverPool `_coverPool` to `baseClaimFee`\\n  function _resetCoverPoolClaimFee(address _coverPool) internal {\\n    coverPoolClaimFee[_coverPool] = baseClaimFee;\\n  }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ICoverPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev CoverPool contract interface. See {CoverPool}.\\n * @author crypto-pumpkin\\n */\\ninterface ICoverPool {\\n  event CoverCreated(address indexed);\\n  event CoverAdded(address indexed _cover, address _acount, uint256 _amount);\\n  event NoclaimRedeemDelayUpdated(uint256 _oldDelay, uint256 _newDelay);\\n  event ClaimEnacted(uint256 _enactedClaimNonce);\\n  event RiskUpdated(bytes32 _risk, bool _isAddRisk);\\n  event PoolStatusUpdated(Status _old, Status _new);\\n  event ExpiryUpdated(uint48 _expiry, string _expiryStr,  Status _status);\\n  event CollateralUpdated(address indexed _collateral, uint256 _mintRatio,  Status _status);\\n\\n  enum Status { Null, Active, Disabled }\\n\\n  struct ExpiryInfo {\\n    string name;\\n    Status status;\\n  }\\n  struct CollateralInfo {\\n    uint256 mintRatio;\\n    Status status;\\n  }\\n  struct ClaimDetails {\\n    uint48 incidentTimestamp;\\n    uint48 claimEnactedTimestamp;\\n    uint256 totalPayoutRate;\\n    bytes32[] payoutRiskList;\\n    uint256[] payoutRates;\\n  }\\n\\n  // state vars\\n  function name() external view returns (string memory);\\n  function extendablePool() external view returns (bool);\\n  function poolStatus() external view returns (Status _status);\\n  /// @notice only active (true) coverPool allows adding more covers (aka. minting more CLAIM and NOCLAIM tokens)\\n  function claimNonce() external view returns (uint256);\\n  function noclaimRedeemDelay() external view returns (uint256);\\n  function addingRiskWIP() external view returns (bool);\\n  function addingRiskIndex() external view returns (uint256);\\n  function activeCovers(uint256 _index) external view returns (address);\\n  function allCovers(uint256 _index) external view returns (address);\\n  function expiries(uint256 _index) external view returns (uint48);\\n  function collaterals(uint256 _index) external view returns (address);\\n  function riskList(uint256 _index) external view returns (bytes32);\\n  function deletedRiskList(uint256 _index) external view returns (bytes32);\\n  function riskMap(bytes32 _risk) external view returns (Status);\\n  function collateralStatusMap(address _collateral) external view returns (uint256 _mintRatio, Status _status);\\n  function expiryInfoMap(uint48 _expiry) external view returns (string memory _name, Status _status);\\n  function coverMap(address _collateral, uint48 _expiry) external view returns (address);\\n\\n  // extra view\\n  function getRiskList() external view returns (bytes32[] memory _riskList);\\n  function getClaimDetails(uint256 _claimNonce) external view returns (ClaimDetails memory);\\n  function getCoverPoolDetails()\\n    external view returns (\\n      address[] memory _collaterals,\\n      uint48[] memory _expiries,\\n      bytes32[] memory _riskList,\\n      bytes32[] memory _deletedRiskList,\\n      address[] memory _allCovers\\n    );\\n\\n  // user action\\n  /// @notice cover must be deployed first\\n  function addCover(\\n    address _collateral,\\n    uint48 _expiry,\\n    address _receiver,\\n    uint256 _colAmountIn,\\n    uint256 _amountOut,\\n    bytes calldata _data\\n  ) external;\\n  function deployCover(address _collateral, uint48 _expiry) external returns (address _coverAddress);\\n\\n  // access restriction - claimManager\\n  function enactClaim(\\n    bytes32[] calldata _payoutRiskList,\\n    uint256[] calldata _payoutRates,\\n    uint48 _incidentTimestamp,\\n    uint256 _coverPoolNonce\\n  ) external;\\n\\n  // CM and dev only\\n  function setNoclaimRedeemDelay(uint256 _noclaimRedeemDelay) external;\\n\\n  // access restriction - dev\\n  function addRisk(string calldata _risk) external returns (bool);\\n  function deleteRisk(string calldata _risk) external;\\n  function setExpiry(uint48 _expiry, string calldata _expiryName, Status _status) external;\\n  function setCollateral(address _collateral, uint256 _mintRatio, Status _status) external;\\n  function setPoolStatus(Status _poolStatus) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ICoverPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev CoverPoolFactory contract interface. See {CoverPoolFactory}.\\n * @author crypto-pumpkin\\n */\\ninterface ICoverPoolFactory {\\n  event CoverPoolCreated(address indexed _addr);\\n  event IntUpdated(string _type, uint256 _old, uint256 _new);\\n  event AddressUpdated(string _type, address indexed _old, address indexed _new);\\n  event PausedStatusUpdated(bool _old, bool _new);\\n\\n  // state vars\\n  function MAX_REDEEM_DELAY() external view returns (uint256);\\n  function defaultRedeemDelay() external view returns (uint256);\\n  // yearlyFeeRate is scaled 1e18\\n  function yearlyFeeRate() external view returns (uint256);\\n  function paused() external view returns (bool);\\n  function responder() external view returns (address);\\n  function coverPoolImpl() external view returns (address);\\n  function coverImpl() external view returns (address);\\n  function coverERC20Impl() external view returns (address);\\n  function treasury() external view returns (address);\\n  function claimManager() external view returns (address);\\n  /// @notice min gas left requirement before continue deployments (when creating new Cover or adding risks to CoverPool)\\n  function deployGasMin() external view returns (uint256);\\n  function coverPoolNames(uint256 _index) external view returns (string memory);\\n  function coverPools(string calldata _coverPoolName) external view returns (address);\\n\\n  // extra view\\n  function getCoverPools() external view returns (address[] memory);\\n  /// @notice return contract address, the contract may not be deployed yet\\n  function getCoverPoolAddress(string calldata _name) external view returns (address);\\n  function getCoverAddress(string calldata _coverPoolName, uint48 _timestamp, address _collateral, uint256 _claimNonce) external view returns (address);\\n  /// @notice _prefix example: \\\"C_CURVE\\\", \\\"C_FUT1\\\", or \\\"NC_\\\"\\n  function getCovTokenAddress(string calldata _coverPoolName, uint48 _expiry, address _collateral, uint256 _claimNonce, string memory _prefix) external view returns (address);\\n\\n  // access restriction - owner (dev) & responder\\n  function setPaused(bool _paused) external;\\n\\n  // access restriction - owner (dev)\\n  function setYearlyFeeRate(uint256 _yearlyFeeRate) external;\\n  function setDefaultRedeemDelay(uint256 _defaultRedeemDelay) external;\\n  function setResponder(address _responder) external;\\n  function setDeployGasMin(uint256 _deployGasMin) external;\\n  /// @dev update Impl will only affect contracts deployed after\\n  function setCoverPoolImpl(address _newImpl) external;\\n  function setCoverImpl(address _newImpl) external;\\n  function setCoverERC20Impl(address _newImpl) external;\\n  function setTreasury(address _address) external;\\n  function setClaimManager(address _address) external;\\n  /**\\n   * @notice Create a new Cover Pool\\n   * @param _name name for pool, e.g. Yearn\\n   * @param _extendablePool open pools allow adding new risk\\n   * @param _riskList risk risks that are covered in this pool\\n   * @param _collateral the collateral of the pool\\n   * @param _mintRatio 18 decimals, in (0, + infinity) the deposit ratio for the collateral the pool, 1.5 means =  1 collateral mints 1.5 CLAIM/NOCLAIM tokens\\n   * @param _expiry expiration date supported for the pool\\n   * @param _expiryString MONTH_DATE_YEAR, used to create covToken symbols only\\n   * \\n   * Emits CoverPoolCreated, add a supported coverPool in COVER\\n   */\\n  function createCoverPool(\\n    string calldata _name,\\n    bool _extendablePool,\\n    string[] calldata _riskList,\\n    address _collateral,\\n    uint256 _mintRatio,\\n    uint48 _expiry,\\n    string calldata _expiryString\\n  ) external returns (address);\\n}  \"\r\n    },\r\n    \"contracts/interfaces/IClaimManagement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ClaimManagement contract interface. See {ClaimManagement}.\\n * @author Alan + crypto-pumpkin\\n */\\ninterface IClaimManagement {\\n  event ClaimUpdate(address indexed coverPool, ClaimState state, uint256 nonce, uint256 index);\\n\\n  enum ClaimState { Filed, ForceFiled, Validated, Invalidated, Accepted, Denied }\\n  struct Claim {\\n    address filedBy; // Address of user who filed claim\\n    address decidedBy; // Address of the CVC who decided claim\\n    uint48 filedTimestamp; // Timestamp of submitted claim\\n    uint48 incidentTimestamp; // Timestamp of the incident the claim is filed for\\n    uint48 decidedTimestamp; // Timestamp when claim outcome is decided\\n    string description;\\n    ClaimState state; // Current state of claim\\n    uint256 feePaid; // Fee paid to file the claim\\n    bytes32[] payoutRiskList;\\n    uint256[] payoutRates; // Numerators of percent to payout\\n  }\\n\\n  function getCoverPoolClaims(address _coverPool, uint256 _nonce, uint256 _index) external view returns (Claim memory);\\n  function getAllClaimsByState(address _coverPool, uint256 _nonce, ClaimState _state) external view returns (Claim[] memory);\\n  function getAllClaimsByNonce(address _coverPool, uint256 _nonce) external view returns (Claim[] memory);\\n  function hasPendingClaim(address _coverPool, uint256 _nonce) external view returns (bool);\\n\\n  function fileClaim(\\n    string calldata _coverPoolName,\\n    bytes32[] calldata _exploitRisks,\\n    uint48 _incidentTimestamp,\\n    string calldata _description,\\n    bool _isForceFile\\n  ) external;\\n  \\n  // @dev Only callable by dev when auditor is voting\\n  function validateClaim(address _coverPool, uint256 _nonce, uint256 _index, bool _claimIsValid) external;\\n\\n  // @dev Only callable by CVC\\n  function decideClaim(\\n    address _coverPool,\\n    uint256 _nonce,\\n    uint256 _index,\\n    uint48 _incidentTimestamp,\\n    bool _claimIsAccepted,\\n    bytes32[] calldata _exploitRisks,\\n    uint256[] calldata _payoutRates\\n  ) external;\\n }\"\r\n    },\r\n    \"contracts/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function totalSupply() external view returns (uint256);\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: No License\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IOwnable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n * @author crypto-pumpkin\\n *\\n * By initialization, the owner account will be the one that called initializeOwner. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Initializable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev COVER: Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function initializeOwner() internal initializer {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IClaimConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20/IERC20.sol\\\";\\nimport \\\"./ICoverPoolFactory.sol\\\";\\n\\n/**\\n * @dev ClaimConfg contract interface. See {ClaimConfig}.\\n * @author Alan + crypto-pumpkin\\n */\\ninterface IClaimConfig {\\n  function treasury() external view returns (address);\\n  function coverPoolFactory() external view returns (ICoverPoolFactory);\\n  function defaultCVC() external view returns (address);\\n  function maxClaimDecisionWindow() external view returns (uint256);\\n  function baseClaimFee() external view returns (uint256);\\n  function forceClaimFee() external view returns (uint256);\\n  function feeMultiplier() external view returns (uint256);\\n  function feeCurrency() external view returns (IERC20);\\n  function cvcMap(address _coverPool, uint256 _idx) external view returns (address);\\n  function getCVCList(address _coverPool) external returns (address[] memory);\\n  function isCVCMember(address _coverPool, address _address) external view returns (bool);\\n  function getCoverPoolClaimFee(address _coverPool) external view returns (uint256);\\n  \\n  // @notice only dev\\n  function setMaxClaimDecisionWindow(uint256 _newTimeWindow) external;\\n  function setTreasury(address _treasury) external;\\n  function addCVCForPools(address[] calldata _coverPools, address[] calldata _cvcs) external;\\n  function removeCVCForPools(address[] calldata _coverPools, address[] calldata _cvcs) external;\\n  function setDefaultCVC(address _cvc) external;\\n  function setFeeAndCurrency(uint256 _baseClaimFee, uint256 _forceClaimFee, address _currency) external;\\n  function setFeeMultiplier(uint256 _multiplier) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface of Ownable\\n */\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n * \\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n * \\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        address self = address(this);\\n        uint256 cs;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { cs := extcodesize(self) }\\n        return cs == 0;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCurrency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_coverPoolFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultCVC\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"coverPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IClaimManagement.ClaimState\",\"name\":\"state\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ClaimUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PENDING_CLAIM_REDEEM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_coverPools\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_cvcs\",\"type\":\"address[]\"}],\"name\":\"addCVCForPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseClaimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coverPoolFactory\",\"outputs\":[{\"internalType\":\"contract ICoverPoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cvcMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coverPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"_incidentTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"_claimIsAccepted\",\"type\":\"bool\"},{\"internalType\":\"bytes32[]\",\"name\":\"_exploitRisks\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_payoutRates\",\"type\":\"uint256[]\"}],\"name\":\"decideClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultCVC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCurrency\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_coverPoolName\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"_exploitRisks\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint48\",\"name\":\"_incidentTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isForceFile\",\"type\":\"bool\"}],\"name\":\"fileClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceClaimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coverPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getAllClaimsByNonce\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"filedBy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"decidedBy\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"filedTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"incidentTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"decidedTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"enum IClaimManagement.ClaimState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"payoutRiskList\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"payoutRates\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IClaimManagement.Claim[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coverPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"enum IClaimManagement.ClaimState\",\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"getAllClaimsByState\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"filedBy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"decidedBy\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"filedTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"incidentTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"decidedTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"enum IClaimManagement.ClaimState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"payoutRiskList\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"payoutRates\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IClaimManagement.Claim[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coverPool\",\"type\":\"address\"}],\"name\":\"getCVCList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coverPool\",\"type\":\"address\"}],\"name\":\"getCoverPoolClaimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coverPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getCoverPoolClaims\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"filedBy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"decidedBy\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"filedTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"incidentTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"decidedTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"enum IClaimManagement.ClaimState\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"payoutRiskList\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"payoutRates\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IClaimManagement.Claim\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coverPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"hasPendingClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coverPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isCVCMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxClaimDecisionWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_coverPools\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_cvcs\",\"type\":\"address[]\"}],\"name\":\"removeCVCForPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cvc\",\"type\":\"address\"}],\"name\":\"setDefaultCVC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseClaimFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_forceClaimFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"}],\"name\":\"setFeeAndCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"}],\"name\":\"setFeeMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTimeWindow\",\"type\":\"uint256\"}],\"name\":\"setMaxClaimDecisionWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coverPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_claimIsValid\",\"type\":\"bool\"}],\"name\":\"validateClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ClaimManagement","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000006bef09f99bf6d92d6486889bdd8a374af151461d0000000000000000000000001cb3391feff3806a6f7fa11b372cb706593047910000000000000000000000007eba9c735f8c1fe0670be69edf61dbfbbb3c76e4","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}