{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity 0.8.2;\r\n\r\n\r\ninterface IPlatformIntegration {\r\n    /**\r\n     * @dev Deposit the given bAsset to Lending platform\r\n     * @param _bAsset bAsset address\r\n     * @param _amount Amount to deposit\r\n     */\r\n    function deposit(\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        bool isTokenFeeCharged\r\n    ) external returns (uint256 quantityDeposited);\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        bool _hasTxFee\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from Lending platform\r\n     */\r\n    function withdraw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount,\r\n        uint256 _totalAmount,\r\n        bool _hasTxFee\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraw given bAsset from the cache\r\n     */\r\n    function withdrawRaw(\r\n        address _receiver,\r\n        address _bAsset,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current balance of the given bAsset\r\n     */\r\n    function checkBalance(address _bAsset) external returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the pToken\r\n     */\r\n    function bAssetToPToken(address _bAsset) external returns (address pToken);\r\n}\r\n\r\nstruct BassetPersonal {\r\n    // Address of the bAsset\r\n    address addr;\r\n    // Address of the bAsset\r\n    address integrator;\r\n    // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\r\n    bool hasTxFee; // takes a byte in storage\r\n    // Status of the bAsset\r\n    BassetStatus status;\r\n}\r\n\r\nstruct BassetData {\r\n    // 1 Basset * ratio / ratioScale == x Masset (relative value)\r\n    // If ratio == 10e8 then 1 bAsset = 10 mAssets\r\n    // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\r\n    uint128 ratio;\r\n    // Amount of the Basset that is held in Collateral\r\n    uint128 vaultBalance;\r\n}\r\n\r\nabstract contract IMasset {\r\n    // Mint\r\n    function mint(\r\n        address _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mintOutput);\r\n\r\n    function mintMulti(\r\n        address[] calldata _inputs,\r\n        uint256[] calldata _inputQuantities,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mintOutput);\r\n\r\n    function getMintOutput(address _input, uint256 _inputQuantity)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 mintOutput);\r\n\r\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 mintOutput);\r\n\r\n    // Swaps\r\n    function swap(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 swapOutput);\r\n\r\n    function getSwapOutput(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity\r\n    ) external view virtual returns (uint256 swapOutput);\r\n\r\n    // Redemption\r\n    function redeem(\r\n        address _output,\r\n        uint256 _mAssetQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 outputQuantity);\r\n\r\n    function redeemMasset(\r\n        uint256 _mAssetQuantity,\r\n        uint256[] calldata _minOutputQuantities,\r\n        address _recipient\r\n    ) external virtual returns (uint256[] memory outputQuantities);\r\n\r\n    function redeemExactBassets(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities,\r\n        uint256 _maxMassetQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mAssetRedeemed);\r\n\r\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 bAssetOutput);\r\n\r\n    function getRedeemExactBassetsOutput(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities\r\n    ) external view virtual returns (uint256 mAssetAmount);\r\n\r\n    // Views\r\n    function getBasket() external view virtual returns (bool, bool);\r\n\r\n    function getBasset(address _token)\r\n        external\r\n        view\r\n        virtual\r\n        returns (BassetPersonal memory personal, BassetData memory data);\r\n\r\n    function getBassets()\r\n        external\r\n        view\r\n        virtual\r\n        returns (BassetPersonal[] memory personal, BassetData[] memory data);\r\n\r\n    function bAssetIndexes(address) external view virtual returns (uint8);\r\n\r\n    // SavingsManager\r\n    function collectInterest() external virtual returns (uint256 swapFeesGained, uint256 newSupply);\r\n\r\n    function collectPlatformInterest()\r\n        external\r\n        virtual\r\n        returns (uint256 mintAmount, uint256 newSupply);\r\n\r\n    // Admin\r\n    function setCacheSize(uint256 _cacheSize) external virtual;\r\n\r\n    function upgradeForgeValidator(address _newForgeValidator) external virtual;\r\n\r\n    function setFees(uint256 _swapFee, uint256 _redemptionFee) external virtual;\r\n\r\n    function setTransferFeesFlag(address _bAsset, bool _flag) external virtual;\r\n\r\n    function migrateBassets(address[] calldata _bAssets, address _newIntegration) external virtual;\r\n}\r\n\r\n// Status of the Basset - has it broken its peg?\r\nenum BassetStatus {\r\n    Default,\r\n    Normal,\r\n    BrokenBelowPeg,\r\n    BrokenAbovePeg,\r\n    Blacklisted,\r\n    Liquidating,\r\n    Liquidated,\r\n    Failed\r\n}\r\n\r\nstruct BasketState {\r\n    bool undergoingRecol;\r\n    bool failed;\r\n}\r\n\r\nstruct InvariantConfig {\r\n    uint256 a;\r\n    WeightLimits limits;\r\n}\r\n\r\nstruct WeightLimits {\r\n    uint128 min;\r\n    uint128 max;\r\n}\r\n\r\nstruct FeederConfig {\r\n    uint256 supply;\r\n    uint256 a;\r\n    WeightLimits limits;\r\n}\r\n\r\nstruct AmpData {\r\n    uint64 initialA;\r\n    uint64 targetA;\r\n    uint64 rampStartTime;\r\n    uint64 rampEndTime;\r\n}\r\n\r\nstruct FeederData {\r\n    uint256 swapFee;\r\n    uint256 redemptionFee;\r\n    uint256 govFee;\r\n    uint256 pendingFees;\r\n    uint256 cacheSize;\r\n    BassetPersonal[] bAssetPersonal;\r\n    BassetData[] bAssetData;\r\n    AmpData ampData;\r\n    WeightLimits weightLimits;\r\n}\r\n\r\nstruct AssetData {\r\n    uint8 idx;\r\n    uint256 amt;\r\n    BassetPersonal personal;\r\n}\r\n\r\nstruct Asset {\r\n    uint8 idx;\r\n    address addr;\r\n    bool exists;\r\n}\r\n\r\nlibrary Root {\r\n    /**\r\n     * @dev Returns the square root of a given number\r\n     * @param x Input\r\n     * @return y Square root of Input\r\n     */\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        if (x == 0) return 0;\r\n        else {\r\n            uint256 xx = x;\r\n            uint256 r = 1;\r\n            if (xx >= 0x100000000000000000000000000000000) {\r\n                xx >>= 128;\r\n                r <<= 64;\r\n            }\r\n            if (xx >= 0x10000000000000000) {\r\n                xx >>= 64;\r\n                r <<= 32;\r\n            }\r\n            if (xx >= 0x100000000) {\r\n                xx >>= 32;\r\n                r <<= 16;\r\n            }\r\n            if (xx >= 0x10000) {\r\n                xx >>= 16;\r\n                r <<= 8;\r\n            }\r\n            if (xx >= 0x100) {\r\n                xx >>= 8;\r\n                r <<= 4;\r\n            }\r\n            if (xx >= 0x10) {\r\n                xx >>= 4;\r\n                r <<= 2;\r\n            }\r\n            if (xx >= 0x8) {\r\n                r <<= 1;\r\n            }\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1; // Seven iterations should be enough\r\n            uint256 r1 = x / r;\r\n            return uint256(r < r1 ? r : r1);\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\nlibrary MassetHelpers {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function transferReturnBalance(\r\n        address _sender,\r\n        address _recipient,\r\n        address _bAsset,\r\n        uint256 _qty\r\n    ) internal returns (uint256 receivedQty, uint256 recipientBalance) {\r\n        uint256 balBefore = IERC20(_bAsset).balanceOf(_recipient);\r\n        IERC20(_bAsset).safeTransferFrom(_sender, _recipient, _qty);\r\n        recipientBalance = IERC20(_bAsset).balanceOf(_recipient);\r\n        receivedQty = recipientBalance - balBefore;\r\n    }\r\n\r\n    function safeInfiniteApprove(address _asset, address _spender) internal {\r\n        IERC20(_asset).safeApprove(_spender, 0);\r\n        IERC20(_asset).safeApprove(_spender, 2**256 - 1);\r\n    }\r\n}\r\n\r\nlibrary StableMath {\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @dev Token Ratios are used when converting between units of bAsset, mAsset and MTA\r\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\r\n     * bAsset ratio unit for use in exact calculations,\r\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\r\n     */\r\n    uint256 private constant RATIO_SCALE = 1e8;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides an interface to the ratio unit\r\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\r\n     */\r\n    function getRatioScale() internal pure returns (uint256) {\r\n        return RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\r\n        return x * FULL_SCALE;\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        // return 9e38 / 1e18 = 9e18\r\n        return (x * y) / scale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x * y;\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled + FULL_SCALE - 1;\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil / FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return (x * FULL_SCALE) / y;\r\n    }\r\n\r\n    /***************************************\r\n                  RATIO FUNCS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the two inputs and then dividing by the ratio scale\r\n     */\r\n    function mulRatioTruncate(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, rounding up the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              ratio scale, rounded up to the closest base unit.\r\n     */\r\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio) internal pure returns (uint256) {\r\n        // e.g. How much mAsset should I burn for this bAsset (x)?\r\n        // 1e18 * 1e8 = 1e26\r\n        uint256 scaled = x * ratio;\r\n        // 1e26 + 9.99e7 = 100..00.999e8\r\n        uint256 ceil = scaled + RATIO_SCALE - 1;\r\n        // return 100..00.999e8 / 1e8 = 1e18\r\n        return ceil / RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\r\n     *      i.e. How much bAsset is this mAsset worth?\r\n     * @param x     Left hand operand in division\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divRatioPrecisely(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        // e.g. 1e14 * 1e8 = 1e22\r\n        // return 1e22 / 1e12 = 1e10\r\n        return (x * RATIO_SCALE) / ratio;\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\n// External\r\n// Internal\r\n// Libs\r\n/**\r\n * @title   FeederLogic\r\n * @author  mStable\r\n * @notice  Logic contract for feeder pools that calculates trade output and updates core state.\r\n *          Includes modular invariant application code applying the StableSwap invariant first designed\r\n *          by Curve Finance and derived for mStable application in MIP-8 (https://mips.mstable.org/MIPS/mip-8)\r\n * @dev     VERSION: 1.0\r\n *          DATE:    2021-03-01\r\n */\r\nlibrary FeederLogic {\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 internal constant A_PRECISION = 100;\r\n\r\n    /***************************************\r\n                    MINT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Transfers token in, updates internal balances and computes the fpToken output\r\n     * @param _data                 Feeder pool storage state\r\n     * @param _config               Core config for use in the invariant validator\r\n     * @param _input                Data on the bAsset to deposit for the minted fpToken.\r\n     * @param _inputQuantity        Quantity in input token units.\r\n     * @param _minOutputQuantity    Minimum fpToken quantity to be minted. This protects against slippage.\r\n     * @return mintOutput           Quantity of fpToken minted from the deposited bAsset.\r\n     */\r\n    function mint(\r\n        FeederData storage _data,\r\n        FeederConfig calldata _config,\r\n        Asset calldata _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity\r\n    ) external returns (uint256 mintOutput) {\r\n        BassetData[] memory cachedBassetData = _data.bAssetData;\r\n        AssetData memory inputData =\r\n            _transferIn(_data, _config, cachedBassetData, _input, _inputQuantity);\r\n        // Validation should be after token transfer, as real input amt is unknown before\r\n        mintOutput = computeMint(cachedBassetData, inputData.idx, inputData.amt, _config);\r\n        require(mintOutput >= _minOutputQuantity, \"Mint quantity < min qty\");\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens in, updates internal balances and computes the fpToken output.\r\n     * Only fAsset & mAsset are supported in this path.\r\n     * @param _data                 Feeder pool storage state\r\n     * @param _config               Core config for use in the invariant validator\r\n     * @param _indices              Non-duplicate addresses of the bAssets to deposit for the minted fpToken.\r\n     * @param _inputQuantities      Quantity of each input in input token units.\r\n     * @param _minOutputQuantity    Minimum fpToken quantity to be minted. This protects against slippage.\r\n     * @return mintOutput           Quantity of fpToken minted from the deposited bAsset.\r\n     */\r\n    function mintMulti(\r\n        FeederData storage _data,\r\n        FeederConfig calldata _config,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _inputQuantities,\r\n        uint256 _minOutputQuantity\r\n    ) external returns (uint256 mintOutput) {\r\n        uint256 len = _indices.length;\r\n        uint256[] memory quantitiesDeposited = new uint256[](len);\r\n        // Load bAssets from storage into memory\r\n        BassetData[] memory allBassets = _data.bAssetData;\r\n        uint256 maxCache = _getCacheDetails(_data, _config.supply);\r\n        // Transfer the Bassets to the integrator & update storage\r\n        for (uint256 i = 0; i < len; i++) {\r\n            if (_inputQuantities[i] > 0) {\r\n                uint8 idx = _indices[i];\r\n                BassetData memory bData = allBassets[idx];\r\n                quantitiesDeposited[i] = _depositTokens(\r\n                    _data.bAssetPersonal[idx],\r\n                    bData.ratio,\r\n                    _inputQuantities[i],\r\n                    maxCache\r\n                );\r\n\r\n                _data.bAssetData[idx].vaultBalance =\r\n                    bData.vaultBalance +\r\n                    SafeCast.toUint128(quantitiesDeposited[i]);\r\n            }\r\n        }\r\n        // Validate the proposed mint, after token transfer\r\n        mintOutput = computeMintMulti(allBassets, _indices, quantitiesDeposited, _config);\r\n        require(mintOutput >= _minOutputQuantity, \"Mint quantity < min qty\");\r\n        require(mintOutput > 0, \"Zero mAsset quantity\");\r\n    }\r\n\r\n    /***************************************\r\n                    SWAP\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Swaps two assets - either internally between fAsset<>mAsset, or between fAsset<>mpAsset by\r\n     * first routing through the mAsset pool.\r\n     * @param _data              Feeder pool storage state\r\n     * @param _config            Core config for use in the invariant validator\r\n     * @param _input             Data on bAsset to deposit\r\n     * @param _output            Data on bAsset to withdraw\r\n     * @param _inputQuantity     Units of input bAsset to swap in\r\n     * @param _minOutputQuantity Minimum quantity of the swap output asset. This protects against slippage\r\n     * @param _recipient         Address to transfer output asset to\r\n     * @return swapOutput        Quantity of output asset returned from swap\r\n     * @return localFee          Fee paid, in fpToken terms\r\n     */\r\n    function swap(\r\n        FeederData storage _data,\r\n        FeederConfig calldata _config,\r\n        Asset calldata _input,\r\n        Asset calldata _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external returns (uint256 swapOutput, uint256 localFee) {\r\n        BassetData[] memory cachedBassetData = _data.bAssetData;\r\n\r\n        AssetData memory inputData =\r\n            _transferIn(_data, _config, cachedBassetData, _input, _inputQuantity);\r\n        // 1. [f/mAsset ->][ f/mAsset]               : Y - normal in, SWAP, normal out\r\n        // 3. [mpAsset -> mAsset][ -> fAsset]        : Y - mint in  , SWAP, normal out\r\n        if (_output.exists) {\r\n            (swapOutput, localFee) = _swapLocal(\r\n                _data,\r\n                _config,\r\n                cachedBassetData,\r\n                inputData,\r\n                _output,\r\n                _minOutputQuantity,\r\n                _recipient\r\n            );\r\n        }\r\n        // 2. [fAsset ->][ mAsset][ -> mpAsset]      : Y - normal in, SWAP, mpOut\r\n        else {\r\n            address mAsset = _data.bAssetPersonal[0].addr;\r\n            (swapOutput, localFee) = _swapLocal(\r\n                _data,\r\n                _config,\r\n                cachedBassetData,\r\n                inputData,\r\n                Asset(0, mAsset, true),\r\n                0,\r\n                address(this)\r\n            );\r\n            swapOutput = IMasset(mAsset).redeem(\r\n                _output.addr,\r\n                swapOutput,\r\n                _minOutputQuantity,\r\n                _recipient\r\n            );\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    REDEEM\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Burns a specified quantity of the senders fpToken in return for a bAsset. The output amount is derived\r\n     * from the invariant. Supports redemption into either the fAsset, mAsset or assets in the mAsset basket.\r\n     * @param _data              Feeder pool storage state\r\n     * @param _config            Core config for use in the invariant validator\r\n     * @param _output            Data on bAsset to withdraw\r\n     * @param _fpTokenQuantity   Quantity of fpToken to burn\r\n     * @param _minOutputQuantity Minimum bAsset quantity to receive for the burnt fpToken. This protects against slippage.\r\n     * @param _recipient         Address to transfer the withdrawn bAssets to.\r\n     * @return outputQuantity    Quanity of bAsset units received for the burnt fpToken\r\n     * @return localFee          Fee paid, in fpToken terms\r\n     */\r\n    function redeem(\r\n        FeederData storage _data,\r\n        FeederConfig calldata _config,\r\n        Asset calldata _output,\r\n        uint256 _fpTokenQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external returns (uint256 outputQuantity, uint256 localFee) {\r\n        if (_output.exists) {\r\n            (outputQuantity, localFee) = _redeemLocal(\r\n                _data,\r\n                _config,\r\n                _output,\r\n                _fpTokenQuantity,\r\n                _minOutputQuantity,\r\n                _recipient\r\n            );\r\n        } else {\r\n            address mAsset = _data.bAssetPersonal[0].addr;\r\n            (outputQuantity, localFee) = _redeemLocal(\r\n                _data,\r\n                _config,\r\n                Asset(0, mAsset, true),\r\n                _fpTokenQuantity,\r\n                0,\r\n                address(this)\r\n            );\r\n            outputQuantity = IMasset(mAsset).redeem(\r\n                _output.addr,\r\n                outputQuantity,\r\n                _minOutputQuantity,\r\n                _recipient\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Credits a recipient with a proportionate amount of bAssets, relative to current vault\r\n     * balance levels and desired fpToken quantity. Burns the fpToken as payment. Only fAsset & mAsset are supported in this path.\r\n     * @param _data                 Feeder pool storage state\r\n     * @param _config               Core config for use in the invariant validator\r\n     * @param _inputQuantity        Quantity of fpToken to redeem\r\n     * @param _minOutputQuantities  Min units of output to receive\r\n     * @param _recipient            Address to credit the withdrawn bAssets\r\n     * @return scaledFee            Fee collected in fpToken terms\r\n     * @return outputs              Array of output asset addresses\r\n     * @return outputQuantities     Array of output asset quantities\r\n     */\r\n    function redeemProportionately(\r\n        FeederData storage _data,\r\n        FeederConfig calldata _config,\r\n        uint256 _inputQuantity,\r\n        uint256[] calldata _minOutputQuantities,\r\n        address _recipient\r\n    )\r\n        external\r\n        returns (\r\n            uint256 scaledFee,\r\n            address[] memory outputs,\r\n            uint256[] memory outputQuantities\r\n        )\r\n    {\r\n        // Calculate mAsset redemption quantities\r\n        scaledFee = _inputQuantity.mulTruncate(_data.redemptionFee);\r\n        // cache = (config.supply - inputQuantity) * 0.2\r\n        uint256 maxCache = _getCacheDetails(_data, _config.supply - _inputQuantity);\r\n\r\n        // Load the bAsset data from storage into memory\r\n        BassetData[] memory allBassets = _data.bAssetData;\r\n        uint256 len = allBassets.length;\r\n        outputs = new address[](len);\r\n        outputQuantities = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            // Get amount out, proportionate to redemption quantity\r\n            uint256 amountOut =\r\n                (allBassets[i].vaultBalance * (_inputQuantity - scaledFee)) / _config.supply;\r\n            require(amountOut > 1, \"Output == 0\");\r\n            amountOut -= 1;\r\n            require(amountOut >= _minOutputQuantities[i], \"bAsset qty < min qty\");\r\n            // Set output in array\r\n            (outputQuantities[i], outputs[i]) = (amountOut, _data.bAssetPersonal[i].addr);\r\n            // Transfer the bAsset to the recipient\r\n            _withdrawTokens(\r\n                amountOut,\r\n                _data.bAssetPersonal[i],\r\n                allBassets[i],\r\n                _recipient,\r\n                maxCache\r\n            );\r\n            // Reduce vaultBalance\r\n            _data.bAssetData[i].vaultBalance =\r\n                allBassets[i].vaultBalance -\r\n                SafeCast.toUint128(amountOut);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Credits a recipient with a certain quantity of selected bAssets, in exchange for burning the\r\n     *      relative fpToken quantity from the sender. Only fAsset & mAsset (0,1) are supported in this path.\r\n     * @param _data                 Feeder pool storage state\r\n     * @param _config               Core config for use in the invariant validator\r\n     * @param _indices              Indices of the bAssets to receive\r\n     * @param _outputQuantities     Units of the bAssets to receive\r\n     * @param _maxInputQuantity     Maximum fpToken quantity to burn for the received bAssets. This protects against slippage.\r\n     * @param _recipient            Address to receive the withdrawn bAssets\r\n     * @return fpTokenQuantity      Quantity of fpToken units to burn as payment\r\n     * @return localFee             Fee collected, in fpToken terms\r\n     */\r\n    function redeemExactBassets(\r\n        FeederData storage _data,\r\n        FeederConfig memory _config,\r\n        uint8[] calldata _indices,\r\n        uint256[] calldata _outputQuantities,\r\n        uint256 _maxInputQuantity,\r\n        address _recipient\r\n    ) external returns (uint256 fpTokenQuantity, uint256 localFee) {\r\n        // Load bAsset data from storage to memory\r\n        BassetData[] memory allBassets = _data.bAssetData;\r\n\r\n        // Validate redemption\r\n        uint256 fpTokenRequired =\r\n            computeRedeemExact(allBassets, _indices, _outputQuantities, _config);\r\n        fpTokenQuantity = fpTokenRequired.divPrecisely(1e18 - _data.redemptionFee);\r\n        localFee = fpTokenQuantity - fpTokenRequired;\r\n        require(fpTokenQuantity > 0, \"Must redeem some mAssets\");\r\n        fpTokenQuantity += 1;\r\n        require(fpTokenQuantity <= _maxInputQuantity, \"Redeem mAsset qty > max quantity\");\r\n\r\n        // Burn the full amount of Masset\r\n        uint256 maxCache = _getCacheDetails(_data, _config.supply - fpTokenQuantity);\r\n        // Transfer the Bassets to the recipient\r\n        for (uint256 i = 0; i < _outputQuantities.length; i++) {\r\n            _withdrawTokens(\r\n                _outputQuantities[i],\r\n                _data.bAssetPersonal[_indices[i]],\r\n                allBassets[_indices[i]],\r\n                _recipient,\r\n                maxCache\r\n            );\r\n            _data.bAssetData[_indices[i]].vaultBalance =\r\n                allBassets[_indices[i]].vaultBalance -\r\n                SafeCast.toUint128(_outputQuantities[i]);\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                FORGING - INTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Transfers an asset in and updates vault balance. Supports fAsset, mAsset and mpAsset.\r\n     * Transferring an mpAsset requires first a mint in the main pool, and consequent depositing of\r\n     * the mAsset.\r\n     */\r\n    function _transferIn(\r\n        FeederData storage _data,\r\n        FeederConfig memory _config,\r\n        BassetData[] memory _cachedBassetData,\r\n        Asset memory _input,\r\n        uint256 _inputQuantity\r\n    ) internal returns (AssetData memory inputData) {\r\n        // fAsset / mAsset transfers\r\n        if (_input.exists) {\r\n            BassetPersonal memory personal = _data.bAssetPersonal[_input.idx];\r\n            uint256 amt =\r\n                _depositTokens(\r\n                    personal,\r\n                    _cachedBassetData[_input.idx].ratio,\r\n                    _inputQuantity,\r\n                    _getCacheDetails(_data, _config.supply)\r\n                );\r\n            inputData = AssetData(_input.idx, amt, personal);\r\n        }\r\n        // mpAsset transfers\r\n        else {\r\n            inputData = _mpMint(\r\n                _data,\r\n                _input,\r\n                _inputQuantity,\r\n                _getCacheDetails(_data, _config.supply)\r\n            );\r\n            require(inputData.amt > 0, \"Must mint something from mp\");\r\n        }\r\n        _data.bAssetData[inputData.idx].vaultBalance =\r\n            _cachedBassetData[inputData.idx].vaultBalance +\r\n            SafeCast.toUint128(inputData.amt);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints an asset in the main mAsset pool. Input asset must be supported by the mAsset\r\n     * or else the call will revert. After minting, check if the balance exceeds the cache upper limit\r\n     * and consequently deposit if necessary.\r\n     */\r\n    function _mpMint(\r\n        FeederData storage _data,\r\n        Asset memory _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _maxCache\r\n    ) internal returns (AssetData memory mAssetData) {\r\n        mAssetData = AssetData(0, 0, _data.bAssetPersonal[0]);\r\n        IERC20(_input.addr).safeTransferFrom(msg.sender, address(this), _inputQuantity);\r\n\r\n        address integrator =\r\n            mAssetData.personal.integrator == address(0)\r\n                ? address(this)\r\n                : mAssetData.personal.integrator;\r\n\r\n        uint256 balBefore = IERC20(mAssetData.personal.addr).balanceOf(integrator);\r\n        // Mint will revert if the _input.addr is not whitelisted on that mAsset\r\n        IMasset(mAssetData.personal.addr).mint(_input.addr, _inputQuantity, 0, integrator);\r\n        uint256 balAfter = IERC20(mAssetData.personal.addr).balanceOf(integrator);\r\n        mAssetData.amt = balAfter - balBefore;\r\n\r\n        // Route the mAsset to platform integration\r\n        if (integrator != address(this)) {\r\n            if (balAfter > _maxCache) {\r\n                uint256 delta = balAfter - (_maxCache / 2);\r\n                IPlatformIntegration(integrator).deposit(mAssetData.personal.addr, delta, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a swap between fAsset and mAsset. If the output is an mAsset, do not\r\n     * charge the swap fee.\r\n     */\r\n    function _swapLocal(\r\n        FeederData storage _data,\r\n        FeederConfig memory _config,\r\n        BassetData[] memory _cachedBassetData,\r\n        AssetData memory _inputData,\r\n        Asset memory _output,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) internal returns (uint256 swapOutput, uint256 scaledFee) {\r\n        // Validate the swap\r\n        (swapOutput, scaledFee) = computeSwap(\r\n            _cachedBassetData,\r\n            _inputData.idx,\r\n            _output.idx,\r\n            _inputData.amt,\r\n            _output.idx == 0 ? 0 : _data.swapFee,\r\n            _config\r\n        );\r\n        require(swapOutput >= _minOutputQuantity, \"Output qty < minimum qty\");\r\n        require(swapOutput > 0, \"Zero output quantity\");\r\n        // Settle the swap\r\n        _withdrawTokens(\r\n            swapOutput,\r\n            _data.bAssetPersonal[_output.idx],\r\n            _cachedBassetData[_output.idx],\r\n            _recipient,\r\n            _getCacheDetails(_data, _config.supply)\r\n        );\r\n        // Decrease output bal\r\n        _data.bAssetData[_output.idx].vaultBalance =\r\n            _cachedBassetData[_output.idx].vaultBalance -\r\n            SafeCast.toUint128(swapOutput);\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a local redemption into either fAsset or mAsset.\r\n     */\r\n    function _redeemLocal(\r\n        FeederData storage _data,\r\n        FeederConfig memory _config,\r\n        Asset memory _output,\r\n        uint256 _fpTokenQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) internal returns (uint256 outputQuantity, uint256 scaledFee) {\r\n        BassetData[] memory allBassets = _data.bAssetData;\r\n        // Subtract the redemption fee\r\n        scaledFee = _fpTokenQuantity.mulTruncate(_data.redemptionFee);\r\n        // Calculate redemption quantities\r\n        outputQuantity = computeRedeem(\r\n            allBassets,\r\n            _output.idx,\r\n            _fpTokenQuantity - scaledFee,\r\n            _config\r\n        );\r\n        require(outputQuantity >= _minOutputQuantity, \"bAsset qty < min qty\");\r\n        require(outputQuantity > 0, \"Output == 0\");\r\n\r\n        // Transfer the bAssets to the recipient\r\n        _withdrawTokens(\r\n            outputQuantity,\r\n            _data.bAssetPersonal[_output.idx],\r\n            allBassets[_output.idx],\r\n            _recipient,\r\n            _getCacheDetails(_data, _config.supply - _fpTokenQuantity)\r\n        );\r\n        // Set vault balance\r\n        _data.bAssetData[_output.idx].vaultBalance =\r\n            allBassets[_output.idx].vaultBalance -\r\n            SafeCast.toUint128(outputQuantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposits a given asset to the system. If there is sufficient room for the asset\r\n     * in the cache, then just transfer, otherwise reset the cache to the desired mid level by\r\n     * depositing the delta in the platform\r\n     */\r\n    function _depositTokens(\r\n        BassetPersonal memory _bAsset,\r\n        uint256 _bAssetRatio,\r\n        uint256 _quantity,\r\n        uint256 _maxCache\r\n    ) internal returns (uint256 quantityDeposited) {\r\n        // 0. If integration is 0, short circuit\r\n        if (_bAsset.integrator == address(0)) {\r\n            (uint256 received, ) =\r\n                MassetHelpers.transferReturnBalance(\r\n                    msg.sender,\r\n                    address(this),\r\n                    _bAsset.addr,\r\n                    _quantity\r\n                );\r\n            return received;\r\n        }\r\n\r\n        // 1 - Send all to PI, using the opportunity to get the cache balance and net amount transferred\r\n        uint256 cacheBal;\r\n        (quantityDeposited, cacheBal) = MassetHelpers.transferReturnBalance(\r\n            msg.sender,\r\n            _bAsset.integrator,\r\n            _bAsset.addr,\r\n            _quantity\r\n        );\r\n\r\n        // 2 - Deposit X if necessary\r\n        // 2.1 - Deposit if xfer fees\r\n        if (_bAsset.hasTxFee) {\r\n            uint256 deposited =\r\n                IPlatformIntegration(_bAsset.integrator).deposit(\r\n                    _bAsset.addr,\r\n                    quantityDeposited,\r\n                    true\r\n                );\r\n\r\n            return StableMath.min(deposited, quantityDeposited);\r\n        }\r\n        // 2.2 - Else Deposit X if Cache > %\r\n        // This check is in place to ensure that any token with a txFee is rejected\r\n        require(quantityDeposited == _quantity, \"Asset not fully transferred\");\r\n\r\n        uint256 relativeMaxCache = _maxCache.divRatioPrecisely(_bAssetRatio);\r\n\r\n        if (cacheBal > relativeMaxCache) {\r\n            uint256 delta = cacheBal - (relativeMaxCache / 2);\r\n            IPlatformIntegration(_bAsset.integrator).deposit(_bAsset.addr, delta, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws a given asset from its platformIntegration. If there is sufficient liquidity\r\n     * in the cache, then withdraw from there, otherwise withdraw from the lending market and reset the\r\n     * cache to the mid level.\r\n     */\r\n    function _withdrawTokens(\r\n        uint256 _quantity,\r\n        BassetPersonal memory _personal,\r\n        BassetData memory _data,\r\n        address _recipient,\r\n        uint256 _maxCache\r\n    ) internal {\r\n        if (_quantity == 0) return;\r\n\r\n        // 1.0 If there is no integrator, send from here\r\n        if (_personal.integrator == address(0)) {\r\n            // If this is part of a cross-swap or cross-redeem, and there is no\r\n            // integrator.. then we don't need to transfer anywhere\r\n            if (_recipient == address(this)) return;\r\n            IERC20(_personal.addr).safeTransfer(_recipient, _quantity);\r\n        }\r\n        // 1.1 If txFee then short circuit - there is no cache\r\n        else if (_personal.hasTxFee) {\r\n            IPlatformIntegration(_personal.integrator).withdraw(\r\n                _recipient,\r\n                _personal.addr,\r\n                _quantity,\r\n                _quantity,\r\n                true\r\n            );\r\n        }\r\n        // 1.2. Else, withdraw from either cache or main vault\r\n        else {\r\n            uint256 cacheBal = IERC20(_personal.addr).balanceOf(_personal.integrator);\r\n            // 2.1 - If balance b in cache, simply withdraw\r\n            if (cacheBal >= _quantity) {\r\n                IPlatformIntegration(_personal.integrator).withdrawRaw(\r\n                    _recipient,\r\n                    _personal.addr,\r\n                    _quantity\r\n                );\r\n            }\r\n            // 2.2 - Else reset the cache to X, or as far as possible\r\n            //       - Withdraw X+b from platform\r\n            //       - Send b to user\r\n            else {\r\n                uint256 relativeMidCache = _maxCache.divRatioPrecisely(_data.ratio) / 2;\r\n                uint256 totalWithdrawal =\r\n                    StableMath.min(\r\n                        relativeMidCache + _quantity - cacheBal,\r\n                        _data.vaultBalance - SafeCast.toUint128(cacheBal)\r\n                    );\r\n\r\n                IPlatformIntegration(_personal.integrator).withdraw(\r\n                    _recipient,\r\n                    _personal.addr,\r\n                    _quantity,\r\n                    totalWithdrawal,\r\n                    false\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the max cache size, given the supply of fpToken\r\n     * @return maxCache    Max units of any given bAsset that should be held in the cache\r\n     */\r\n    function _getCacheDetails(FeederData storage _data, uint256 _supply)\r\n        internal\r\n        view\r\n        returns (uint256 maxCache)\r\n    {\r\n        maxCache = (_supply * _data.cacheSize) / 1e18;\r\n    }\r\n\r\n    /***************************************\r\n                    INVARIANT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Compute the amount of fpToken received for minting\r\n     * with `quantity` amount of bAsset index `i`.\r\n     * @param _bAssets      Array of all bAsset Data\r\n     * @param _i            Index of bAsset with which to mint\r\n     * @param _rawInput     Raw amount of bAsset to use in mint\r\n     * @param _config       Generalised FeederConfig stored externally\r\n     * @return mintAmount   Quantity of fpTokens minted\r\n     */\r\n    function computeMint(\r\n        BassetData[] memory _bAssets,\r\n        uint8 _i,\r\n        uint256 _rawInput,\r\n        FeederConfig memory _config\r\n    ) public pure returns (uint256 mintAmount) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\r\n        require(scaledInput > 1e6, \"Must add > 1e6 units\");\r\n        // 3. Add deposit to x and sum\r\n        x[_i] += scaledInput;\r\n        sum += scaledInput;\r\n        // 4. Finalise mint\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n        mintAmount = _computeMintOutput(x, sum, k0, _config);\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of fpToken received for minting\r\n     * with the given array of inputs.\r\n     * @param _bAssets      Array of all bAsset Data\r\n     * @param _indices      Indexes of bAssets with which to mint\r\n     * @param _rawInputs    Raw amounts of bAssets to use in mint\r\n     * @param _config       Generalised FeederConfig stored externally\r\n     * @return mintAmount   Quantity of fpTokens minted\r\n     */\r\n    function computeMintMulti(\r\n        BassetData[] memory _bAssets,\r\n        uint8[] memory _indices,\r\n        uint256[] memory _rawInputs,\r\n        FeederConfig memory _config\r\n    ) public pure returns (uint256 mintAmount) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        // 3. Add deposits to x and sum\r\n        uint256 len = _indices.length;\r\n        uint8 idx;\r\n        uint256 scaledInput;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            idx = _indices[i];\r\n            scaledInput = (_rawInputs[i] * _bAssets[idx].ratio) / 1e8;\r\n            x[idx] += scaledInput;\r\n            sum += scaledInput;\r\n        }\r\n        // 4. Finalise mint\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n        mintAmount = _computeMintOutput(x, sum, k0, _config);\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of bAsset received for swapping\r\n     * `quantity` amount of index `input_idx` to index `output_idx`.\r\n     * @param _bAssets      Array of all bAsset Data\r\n     * @param _i            Index of bAsset to swap IN\r\n     * @param _o            Index of bAsset to swap OUT\r\n     * @param _rawInput     Raw amounts of input bAsset to input\r\n     * @param _feeRate      Swap fee rate to apply to output\r\n     * @param _config       Generalised FeederConfig stored externally\r\n     * @return bAssetOutputQuantity   Raw bAsset output quantity\r\n     * @return scaledSwapFee          Swap fee collected, in fpToken terms\r\n     */\r\n    function computeSwap(\r\n        BassetData[] memory _bAssets,\r\n        uint8 _i,\r\n        uint8 _o,\r\n        uint256 _rawInput,\r\n        uint256 _feeRate,\r\n        FeederConfig memory _config\r\n    ) public pure returns (uint256 bAssetOutputQuantity, uint256 scaledSwapFee) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        // 3. Add deposits to x and sum\r\n        uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\r\n        require(scaledInput > 1e6, \"Must add > 1e6 units\");\r\n        x[_i] += scaledInput;\r\n        sum += scaledInput;\r\n        // 4. Calc total fpToken q\r\n        uint256 k1 = _invariant(x, sum, _config.a);\r\n        scaledSwapFee = ((k1 - k0) * _feeRate) / 1e18;\r\n        // 5. Calc output bAsset\r\n        uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, k0 + scaledSwapFee);\r\n        // Convert swap fee to fpToken terms\r\n        // fpFee = fee * s / k\r\n        scaledSwapFee = (scaledSwapFee * _config.supply) / k0;\r\n        uint256 output = x[_o] - newOutputReserve - 1;\r\n        bAssetOutputQuantity = (output * 1e8) / _bAssets[_o].ratio;\r\n        // 6. Check for bounds\r\n        x[_o] -= output;\r\n        sum -= output;\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of bAsset index `i` received for\r\n     * redeeming `quantity` amount of fpToken.\r\n     * @param _bAssets              Array of all bAsset Data\r\n     * @param _o                    Index of output bAsset\r\n     * @param _netRedeemInput       Net amount of fpToken to redeem\r\n     * @param _config               Generalised FeederConfig stored externally\r\n     * @return rawOutputUnits       Raw bAsset output returned\r\n     */\r\n    function computeRedeem(\r\n        BassetData[] memory _bAssets,\r\n        uint8 _o,\r\n        uint256 _netRedeemInput,\r\n        FeederConfig memory _config\r\n    ) public pure returns (uint256 rawOutputUnits) {\r\n        require(_netRedeemInput > 1e6, \"Must redeem > 1e6 units\");\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        uint256 kFinal = (k0 * (_config.supply - _netRedeemInput)) / _config.supply + 1;\r\n        // 3. Compute bAsset output\r\n        uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, kFinal);\r\n        uint256 output = x[_o] - newOutputReserve - 1;\r\n        rawOutputUnits = (output * 1e8) / _bAssets[_o].ratio;\r\n        // 4. Check for max weight\r\n        x[_o] -= output;\r\n        sum -= output;\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the amount of fpToken required to redeem\r\n     * a given selection of bAssets.\r\n     * @param _bAssets          Array of all bAsset Data\r\n     * @param _indices          Indexes of output bAssets\r\n     * @param _rawOutputs       Desired raw bAsset outputs\r\n     * @param _config           Generalised FeederConfig stored externally\r\n     * @return redeemInput      Amount of fpToken required to redeem bAssets\r\n     */\r\n    function computeRedeemExact(\r\n        BassetData[] memory _bAssets,\r\n        uint8[] memory _indices,\r\n        uint256[] memory _rawOutputs,\r\n        FeederConfig memory _config\r\n    ) public pure returns (uint256 redeemInput) {\r\n        // 1. Get raw reserves\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        // 2. Get value of reserves according to invariant\r\n        uint256 k0 = _invariant(x, sum, _config.a);\r\n        // 3. Sub deposits from x and sum\r\n        uint256 len = _indices.length;\r\n        uint256 ratioed;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            ratioed = (_rawOutputs[i] * _bAssets[_indices[i]].ratio) / 1e8;\r\n            x[_indices[i]] -= ratioed;\r\n            sum -= ratioed;\r\n        }\r\n        require(_inBounds(x, sum, _config.limits), \"Exceeds weight limits\");\r\n        // 4. Get new value of reserves according to invariant\r\n        uint256 k1 = _invariant(x, sum, _config.a);\r\n        // 5. Total fpToken is the difference between values\r\n        redeemInput = (_config.supply * (k0 - k1)) / k0;\r\n        require(redeemInput > 1e6, \"Must redeem > 1e6 units\");\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the price of the fpToken, and invariant value k\r\n     * @param _bAssets  Array of all bAsset Data\r\n     * @param _config   Generalised FeederConfig stored externally\r\n     * @return price    Price of an fpToken\r\n     * @return k        Total value of basket, k\r\n     */\r\n    function computePrice(BassetData[] memory _bAssets, FeederConfig memory _config)\r\n        public\r\n        pure\r\n        returns (uint256 price, uint256 k)\r\n    {\r\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\r\n        k = _invariant(x, sum, _config.a);\r\n        price = (1e18 * k) / _config.supply;\r\n    }\r\n\r\n    /***************************************\r\n                    INTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Computes the actual mint output after adding mint inputs\r\n     * to the vault balances\r\n     * @param _x            Scaled vaultBalances\r\n     * @param _sum          Sum of vaultBalances, to avoid another loop\r\n     * @param _k            Previous value of invariant, k, before addition\r\n     * @param _config       Generalised FeederConfig stored externally\r\n     * @return mintAmount   Amount of value added to invariant, in fpToken terms\r\n     */\r\n    function _computeMintOutput(\r\n        uint256[] memory _x,\r\n        uint256 _sum,\r\n        uint256 _k,\r\n        FeederConfig memory _config\r\n    ) internal pure returns (uint256 mintAmount) {\r\n        // 1. Get value of reserves according to invariant\r\n        uint256 kFinal = _invariant(_x, _sum, _config.a);\r\n        // 2. Total minted is the difference between values, with respect to total supply\r\n        if (_config.supply == 0) {\r\n            mintAmount = kFinal - _k;\r\n        } else {\r\n            mintAmount = (_config.supply * (kFinal - _k)) / _k;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Simply scaled raw reserve values and returns the sum\r\n     * @param _bAssets  All bAssets\r\n     * @return x        Scaled vault balances\r\n     * @return sum      Sum of scaled vault balances\r\n     */\r\n    function _getReserves(BassetData[] memory _bAssets)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory x, uint256 sum)\r\n    {\r\n        uint256 len = _bAssets.length;\r\n        x = new uint256[](len);\r\n        uint256 r;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            BassetData memory bAsset = _bAssets[i];\r\n            r = (bAsset.vaultBalance * bAsset.ratio) / 1e8;\r\n            x[i] = r;\r\n            sum += r;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks that no bAsset reserves exceed max weight\r\n     * @param _x            Scaled bAsset reserves\r\n     * @param _sum          Sum of x, precomputed\r\n     * @param _limits       Config object containing max and min weights\r\n     * @return inBounds     Bool, true if all assets are within bounds\r\n     */\r\n    function _inBounds(\r\n        uint256[] memory _x,\r\n        uint256 _sum,\r\n        WeightLimits memory _limits\r\n    ) internal pure returns (bool inBounds) {\r\n        uint256 len = _x.length;\r\n        inBounds = true;\r\n        uint256 w;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            w = (_x[i] * 1e18) / _sum;\r\n            if (w > _limits.max || w < _limits.min) return false;\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    INVARIANT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Compute the invariant f(x) for a given array of supplies `x`.\r\n     * @param _x        Scaled vault balances\r\n     * @param _sum      Sum of scaled vault balances\r\n     * @param _a        Precise amplification coefficient\r\n     * @return k        Cumulative value of all assets according to the invariant\r\n     */\r\n    function _invariant(\r\n        uint256[] memory _x,\r\n        uint256 _sum,\r\n        uint256 _a\r\n    ) internal pure returns (uint256 k) {\r\n        if (_sum == 0) return 0;\r\n\r\n        uint256 var1 = _x[0] * _x[1];\r\n        uint256 var2 = (_a * var1) / (_x[0] + _x[1]) / A_PRECISION;\r\n        // result = 2 * (isqrt(var2**2 + (A + A_PRECISION) * var1 // A_PRECISION) - var2) + 1\r\n        k = 2 * (Root.sqrt((var2**2) + (((_a + A_PRECISION) * var1) / A_PRECISION)) - var2) + 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Solves the invariant for _i with respect to target K, given an array of reserves.\r\n     * @param _x        Scaled reserve balances\r\n     * @param _a        Precise amplification coefficient\r\n     * @param _idx      Index of asset for which to solve\r\n     * @param _targetK  Target invariant value K\r\n     * @return y        New reserve of _i\r\n     */\r\n    function _solveInvariant(\r\n        uint256[] memory _x,\r\n        uint256 _a,\r\n        uint8 _idx,\r\n        uint256 _targetK\r\n    ) internal pure returns (uint256 y) {\r\n        require(_idx == 0 || _idx == 1, \"Invalid index\");\r\n\r\n        uint256 x = _idx == 0 ? _x[1] : _x[0];\r\n        uint256 var1 = _a + A_PRECISION;\r\n        uint256 var2 = ((_targetK**2) * A_PRECISION) / var1;\r\n        // var3 = var2 // (4 * x) + k * _a // var1 - x\r\n        uint256 tmp = var2 / (4 * x) + ((_targetK * _a) / var1);\r\n        uint256 var3 = tmp >= x ? tmp - x : x - tmp;\r\n        //  result = (sqrt(var3**2 + var2) + var3) // 2\r\n        y = ((Root.sqrt((var3**2) + var2) + tmp - x) / 2) + 1;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"_i\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_rawInput\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct FeederConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computeMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_indices\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_rawInputs\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct FeederConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computeMintMulti\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct FeederConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"_o\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_netRedeemInput\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct FeederConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computeRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawOutputUnits\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_indices\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_rawOutputs\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct FeederConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computeRedeemExact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemInput\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct BassetData[]\",\"name\":\"_bAssets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"_i\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_o\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_rawInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct FeederConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"computeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bAssetOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scaledSwapFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"FeederLogic","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e7ba85f0b708b8abff3092672d9a78fa4f5bfad0b48efb112edf3021161eae9a"}]}