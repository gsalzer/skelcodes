{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v2/registry/connectors.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title InstaConnectorsV2\\n * @dev Registry for Connectors.\\n */\\n\\ninterface IndexInterface {\\n    function master() external view returns (address);\\n}\\n\\ninterface ConnectorInterface {\\n    function name() external view returns (string memory);\\n}\\n\\ncontract Controllers {\\n\\n    event LogController(address indexed addr, bool indexed isChief);\\n\\n    // InstaIndex Address.\\n    address public immutable instaIndex;\\n\\n    constructor(address _instaIndex) {\\n        instaIndex = _instaIndex;\\n    }\\n\\n    // Enabled Chief(Address of Chief => bool).\\n    mapping(address => bool) public chief;\\n    // Enabled Connectors(Connector name => address).\\n    mapping(string => address) public connectors;\\n\\n    /**\\n    * @dev Throws if the sender not is Master Address from InstaIndex\\n    * or Enabled Chief.\\n    */\\n    modifier isChief {\\n        require(chief[msg.sender] || msg.sender == IndexInterface(instaIndex).master(), \\\"not-an-chief\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Toggle a Chief. Enable if disable & vice versa\\n     * @param _chiefAddress Chief Address.\\n    */\\n    function toggleChief(address _chiefAddress) external {\\n        require(msg.sender == IndexInterface(instaIndex).master(), \\\"toggleChief: not-master\\\");\\n        chief[_chiefAddress] = !chief[_chiefAddress];\\n        emit LogController(_chiefAddress, chief[_chiefAddress]);\\n    }\\n}\\n\\n\\ncontract InstaConnectorsV2 is Controllers {\\n    event LogConnectorAdded(\\n        bytes32 indexed connectorNameHash,\\n        string connectorName,\\n        address indexed connector\\n    );\\n    event LogConnectorUpdated(\\n        bytes32 indexed connectorNameHash,\\n        string connectorName,\\n        address indexed oldConnector,\\n        address indexed newConnector\\n    );\\n    event LogConnectorRemoved(\\n        bytes32 indexed connectorNameHash,\\n        string connectorName,\\n        address indexed connector\\n    );\\n\\n    constructor(address _instaIndex) public Controllers(_instaIndex) {}\\n\\n    /**\\n     * @dev Add Connectors\\n     * @param _connectorNames Array of Connector Names.\\n     * @param _connectors Array of Connector Address.\\n    */\\n    function addConnectors(string[] calldata _connectorNames, address[] calldata _connectors) external isChief {\\n        require(_connectors.length == _connectors.length, \\\"addConnectors: not same length\\\");\\n        for (uint i = 0; i < _connectors.length; i++) {\\n            require(connectors[_connectorNames[i]] == address(0), \\\"addConnectors: _connectorName added already\\\");\\n            require(_connectors[i] != address(0), \\\"addConnectors: _connectors address not vaild\\\");\\n            ConnectorInterface(_connectors[i]).name(); // Checking if connector has function name()\\n            connectors[_connectorNames[i]] = _connectors[i];\\n            emit LogConnectorAdded(keccak256(abi.encodePacked(_connectorNames[i])), _connectorNames[i], _connectors[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Update Connectors\\n     * @param _connectorNames Array of Connector Names.\\n     * @param _connectors Array of Connector Address.\\n    */\\n    function updateConnectors(string[] calldata _connectorNames, address[] calldata _connectors) external isChief {\\n        require(_connectorNames.length == _connectors.length, \\\"updateConnectors: not same length\\\");\\n        for (uint i = 0; i < _connectors.length; i++) {\\n            require(connectors[_connectorNames[i]] != address(0), \\\"updateConnectors: _connectorName not added to update\\\");\\n            require(_connectors[i] != address(0), \\\"updateConnectors: _connector address is not vaild\\\");\\n            ConnectorInterface(_connectors[i]).name(); // Checking if connector has function name()\\n            emit LogConnectorUpdated(keccak256(abi.encodePacked(_connectorNames[i])), _connectorNames[i], connectors[_connectorNames[i]], _connectors[i]);\\n            connectors[_connectorNames[i]] = _connectors[i];\\n        }\\n    }\\n\\n    /**\\n     * @dev Remove Connectors\\n     * @param _connectorNames Array of Connector Names.\\n    */\\n    function removeConnectors(string[] calldata _connectorNames) external isChief {\\n        for (uint i = 0; i < _connectorNames.length; i++) {\\n            require(connectors[_connectorNames[i]] != address(0), \\\"removeConnectors: _connectorName not added to update\\\");\\n            emit LogConnectorRemoved(keccak256(abi.encodePacked(_connectorNames[i])), _connectorNames[i], connectors[_connectorNames[i]]);\\n            delete connectors[_connectorNames[i]];\\n        }\\n    }\\n\\n    /**\\n     * @dev Check if Connector addresses are enabled.\\n     * @param _connectors Array of Connector Names.\\n    */\\n    function isConnectors(string[] calldata _connectorNames) external view returns (bool isOk, address[] memory _connectors) {\\n        isOk = true;\\n        uint len = _connectorNames.length;\\n        _connectors = new address[](len);\\n        for (uint i = 0; i < _connectors.length; i++) {\\n            _connectors[i] = connectors[_connectorNames[i]];\\n            if (_connectors[i] == address(0)) {\\n                isOk = false;\\n                break;\\n            }\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instaIndex\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"connectorNameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"connectorName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"LogConnectorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"connectorNameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"connectorName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"LogConnectorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"connectorNameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"connectorName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldConnector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newConnector\",\"type\":\"address\"}],\"name\":\"LogConnectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isChief\",\"type\":\"bool\"}],\"name\":\"LogController\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_connectorNames\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"}],\"name\":\"addConnectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chief\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"connectors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instaIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_connectorNames\",\"type\":\"string[]\"}],\"name\":\"isConnectors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isOk\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_connectorNames\",\"type\":\"string[]\"}],\"name\":\"removeConnectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chiefAddress\",\"type\":\"address\"}],\"name\":\"toggleChief\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_connectorNames\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"}],\"name\":\"updateConnectors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"InstaConnectorsV2","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002971adfa57b20e5a416ae5a708a8655a9c74f723","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}