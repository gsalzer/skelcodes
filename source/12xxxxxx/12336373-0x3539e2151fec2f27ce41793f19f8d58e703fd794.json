{"status":"1","message":"OK","result":[{"SourceCode":"{\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor(){\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\\n\\n\\n\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n\"},\"XIVBettingFixed.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./XIVInterface.sol\\\";\\n\\ncontract XIVBettingFixed is Ownable{\\n    \\n    using SafeMath for uint256;\\n    uint256 secondsInADay=24 hours;\\n    \\n    uint256 stakeOffset;\\n    address public databaseContractAddress=0x18464e4584759A50CE9FC58eA5997F8B0D1EA1d8;\\n    \\n    XIVDatabaseLib.IndexCoin[] tempObjectArray;\\n    \\n     function betFixed(uint256 amountOfXIV, uint16 typeOfBet, address _betContractAddress, uint256 betSlabeIndex) external{\\n        // 0-\\u003e defi Fixed, 1-\\u003edefi flexible, 2-\\u003e index Fixed and 3-\\u003e index flexible 4-\\u003e flash fixed 5-\\u003e flash flexible\\n        require(typeOfBet==0 || typeOfBet==2 || typeOfBet==4,\\\"Invalid bet Type\\\");\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        require(!dContract.getExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress),\\\"you can\\u0027t place bet using these values.\\\");\\n        Token tokenObj = Token(dContract.getXIVTokenContractAddress());\\n        require((dContract.getBetFactorLP()).mul(dContract.getTokenStakedAmount())\\u003e=\\n                        ((tokenObj.balanceOf(databaseContractAddress)).sub(dContract.getTokenStakedAmount())).add(amountOfXIV),\\n                        \\\"Staking Vaults Have EXCEEDED CAPACITY. Please Check Back in 24hrs?\\\");\\n        require(amountOfXIV\\u003e=dContract.getMinStakeXIVAmount() \\u0026\\u0026 amountOfXIV\\u003c=dContract.getMaxStakeXIVAmount(),\\\"Please enter amount in the specified range\\\");\\n                   \\n        if(typeOfBet==0 || typeOfBet==4){\\n            bool isFlashVault=(typeOfBet==4?true:false);\\n            require(dContract.isDaysAvailable(dContract.getFixedDefiCoinArray()[betSlabeIndex].daysCount),\\\"Day does not exists.\\\");\\n            require(dContract.getFixedDefiCoinArray().length\\u003ebetSlabeIndex,\\\"Day does not exists.\\\");\\n            require(checkTimeForBet(dContract.getFixedDefiCoinArray()[betSlabeIndex].daysCount),\\\"Staking time closed for the selected day\\\");\\n            require(dContract.getDefiCoinsFixedMapping(_betContractAddress,isFlashVault).status,\\\"The currency is currently disabled.\\\");\\n           \\n            // defi fixed\\n            OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\\n            XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\\n                id:dContract.getBetId(),\\n                principalAmount:amountOfXIV,\\n                amount:amountOfXIV,\\n                userAddress:msg.sender,\\n                contractAddress:_betContractAddress,\\n                betType:typeOfBet,\\n                currentPrice:uint256(oWObject.getPrice(dContract.getDefiCoinsFixedMapping(_betContractAddress,isFlashVault).currencySymbol, dContract.getDefiCoinsFixedMapping(_betContractAddress,isFlashVault).oracleType)),\\n                betTimePeriod:(dContract.getFixedDefiCoinArray()[betSlabeIndex].daysCount).mul(1 days),\\n                checkpointPercent:dContract.getFixedDefiCoinArray()[betSlabeIndex].upDownPercentage,\\n                rewardFactor:dContract.getFixedDefiCoinArray()[betSlabeIndex].rewardFactor,\\n                riskFactor:dContract.getFixedDefiCoinArray()[betSlabeIndex].riskFactor,\\n                timestamp:block.timestamp,\\n                adminCommissionFee:0,\\n                status:0\\n            });\\n            dContract.updateBetArray(binfo);\\n            dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\\n            if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\\n                dContract.addUserAddressUsedForBetting(msg.sender);\\n            }\\n            dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\\n            dContract.updateBetId(dContract.getBetId().add(1));\\n            uint256 betEndTime=((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay)).add(binfo.betTimePeriod).sub(1));\\n            dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\\n        }else if(typeOfBet==2){\\n            //index Fixed \\n            require(dContract.isDaysAvailable(dContract.getFixedDefiIndexArray()[betSlabeIndex].daysCount),\\\"Day does not exists.\\\");\\n            require(dContract.getFixedDefiIndexArray().length\\u003ebetSlabeIndex,\\\"Day does not exists.\\\");\\n            require(checkTimeForBet(dContract.getFixedDefiIndexArray()[betSlabeIndex].daysCount),\\\"Staking time closed for the selected day\\\");\\n            \\n             XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\\n                id:dContract.getBetId(),\\n                principalAmount:amountOfXIV,\\n                amount:amountOfXIV,\\n                userAddress:msg.sender,\\n                contractAddress:address(0),\\n                betType:typeOfBet,\\n                currentPrice:uint256(calculateIndexValueForFixedInternal(dContract.getBetId())),\\n                betTimePeriod:(dContract.getFixedDefiIndexArray()[betSlabeIndex].daysCount).mul(1 days),\\n                checkpointPercent:dContract.getFixedDefiIndexArray()[betSlabeIndex].upDownPercentage,\\n                rewardFactor:dContract.getFixedDefiIndexArray()[betSlabeIndex].rewardFactor,\\n                riskFactor:dContract.getFixedDefiIndexArray()[betSlabeIndex].riskFactor,\\n                timestamp:block.timestamp,\\n                adminCommissionFee:0,\\n                status:0\\n            });\\n            dContract.updateBetArray(binfo);\\n            dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\\n            if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\\n                dContract.addUserAddressUsedForBetting(msg.sender);\\n            }\\n            dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\\n            dContract.updateBetId(dContract.getBetId().add(1));\\n            uint256 betEndTime=((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay)).add(binfo.betTimePeriod).sub(1));\\n            dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\\n        }\\n        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),msg.sender,databaseContractAddress,amountOfXIV);\\n        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(amountOfXIV));\\n        dContract.updateExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress,true);\\n    }\\n    function checkTimeForBet(uint256 _days) public view returns(bool){\\n        uint256 currentTime=block.timestamp;\\n        uint256 utcMidNight=((block.timestamp.div(secondsInADay)).mul(secondsInADay));\\n        if(_days==1){\\n            if(((utcMidNight).add(2 hours))\\u003ecurrentTime){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }else if(_days==3){\\n            if(((utcMidNight).add(12 hours))\\u003ecurrentTime){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    function calculateIndexValueForFixedInternal(uint256 _betId) internal returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap;\\n        for(uint256 i=0;i\\u003cdContract.getAllIndexContractAddressArray().length;i++){\\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\\n            if(iCObj.status){\\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\\n                dContract.updateBetIndexForFixedArray(_betId,iCObj);\\n            }\\n        }\\n        XIVDatabaseLib.BetPriceHistory memory bPHObj=XIVDatabaseLib.BetPriceHistory({\\n            baseIndexValue:dContract.getBetBaseIndexValue()==0?10**11:dContract.getBetBaseIndexValue(),\\n            actualIndexValue:totalMarketcap\\n        });\\n        dContract.updateBetPriceHistoryFixedMapping(_betId,bPHObj);\\n        if(dContract.getBetBaseIndexValue()==0){\\n            dContract.updateBetBaseIndexValue(10**11);\\n        }else{\\n            if(totalMarketcap\\u003edContract.getBetActualIndexValue()){\\n                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue().add((\\n                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue()))\\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\\n            }else if(totalMarketcap\\u003cdContract.getBetActualIndexValue()){\\n                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue().sub((\\n                                                     (dContract.getBetActualIndexValue().sub(totalMarketcap))\\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\\n            }\\n        }\\n        dContract.updateBetActualIndexValue(totalMarketcap);\\n        return totalMarketcap;\\n    }\\n    function updateStatus(uint256[] memory offerIds/**uint256 pageNo, uint256 pageSize**/) external {\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\\n        stakeOffset=stakeOffset.add(dContract.getTokenStakedAmount());\\n           for(uint256 i=0;i\\u003cofferIds.length;i++){ \\n            XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[offerIds[i]];\\n            if(bObject.status==0){\\n                uint256 sevenDaysTime=((((bObject.timestamp).div(secondsInADay)).mul(secondsInADay)).add(bObject.betTimePeriod).sub(1));\\n                if(block.timestamp\\u003e=sevenDaysTime){\\n                     if(bObject.betType==0 || bObject.betType==1 || bObject.betType==4 || bObject.betType==5){\\n                        // defi fixed\\n                        string memory tempSymbol;\\n                        uint256 tempOracle;\\n                        if(bObject.betType==0 || bObject.betType==4 || bObject.betType==5){\\n                            bool isFlashVault=((bObject.betType==4 || bObject.betType==5)?true:false);\\n                            tempSymbol=dContract.getDefiCoinsFixedMapping(bObject.contractAddress,isFlashVault).currencySymbol;\\n                            tempOracle=dContract.getDefiCoinsFixedMapping(bObject.contractAddress,isFlashVault).oracleType;\\n                        }else if(bObject.betType==1){\\n                            tempSymbol=dContract.getDefiCoinsFlexibleMapping(bObject.contractAddress).currencySymbol;\\n                            tempOracle=dContract.getDefiCoinsFlexibleMapping(bObject.contractAddress).oracleType;\\n                        }\\n                        uint256 currentprice=uint256(oWObject.getPrice(tempSymbol, tempOracle));\\n                       \\n                        if(currentprice\\u003cbObject.currentPrice){\\n                            uint16 percentageValue=uint16(((bObject.currentPrice.sub(currentprice)).mul(10**4))\\n                                                    .div(bObject.currentPrice));\\n                            if(percentageValue\\u003e=bObject.checkpointPercent){\\n                                updateXIVForStakers(offerIds[i], true);\\n                            }else{\\n                                updateXIVForStakers(offerIds[i], false);\\n                            }\\n                        }else{\\n                            updateXIVForStakers(offerIds[i], false);\\n                        }\\n                    }else if(bObject.betType==2){\\n                        //index Fixed \\n                       updateXIVForStakersIndexFixed(offerIds[i]);\\n                        \\n                    }else if(bObject.betType==3){\\n                        //index flexible\\n                       updateXIVForStakersIndexFlexible(offerIds[i]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    function getUserStakedAddressCount() public view returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        return dContract.getUserStakedAddress().length;\\n    }\\n    function incentiveStakers(uint256 pageNo, uint256 pageSize) external{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 pageStart=pageNo.mul(pageSize);\\n        uint256 pageSizeValue=(pageSize.mul(pageNo.add(1)));\\n        if(getUserStakedAddressCount()\\u003cpageSizeValue){\\n            pageSizeValue=getUserStakedAddressCount();\\n        }\\n        for(uint256 i=pageStart;i\\u003cpageSizeValue;i++){\\n            address userAddress=dContract.getUserStakedAddress()[i];\\n            uint256 updatedAmount;\\n            if(stakeOffset\\u003e0){\\n                updatedAmount=(((dContract.getTokensStaked(userAddress).mul(10**4).mul(stakeOffset))\\n                                    .div(dContract.getTokenStakedAmount().mul(10**4))));\\n            }else{\\n                updatedAmount=dContract.getTokensStaked(userAddress);\\n            }\\n            uint256 excutionId=dContract.getSlotExecutionId();\\n            if(dContract.getSlotId()\\u003e0){\\n                if(excutionId\\u003c=dContract.getSlotId().sub(1)){\\n                    for(uint256 j=0;j\\u003cdContract.getStakingInfoMapping(userAddress).length;j++){\\n                        excutionId=dContract.getSlotExecutionId();\\n                        XIVDatabaseLib.StakingInfo memory stakeInfo=dContract.getStakingInfoMapping(userAddress)[j];\\n                        for(uint256 k=0;k\\u003cdContract.getIncentiveMapping(excutionId).length;k++){\\n                            if(stakeInfo.investmentId\\u003c=dContract.getIncentiveMapping(excutionId)[k].tillInvestmentId){\\n                                uint256 userIncentive=(((stakeInfo.stakeAmount.mul(10**4).mul(dContract.getIncentiveMapping(excutionId)[k].incentiveAmount))\\n                                        .div(dContract.getIncentiveMapping(excutionId)[k].totalAmountStakedAtIncentiveTime.mul(10**4))));\\n                                updatedAmount=updatedAmount.add(userIncentive);\\n                            }\\n                        }\\n                        if(dContract.getSlotId().sub(1)\\u003eexcutionId){\\n                            excutionId++;\\n                        }\\n                    }\\n                }\\n            }\\n            dContract.updateTokensStaked(userAddress,updatedAmount);\\n        }\\n        if(getUserStakedAddressCount()\\u003cpageSizeValue || getUserStakedAddressCount()==pageSizeValue){\\n            uint256 updatedAmount;\\n            if(dContract.getSlotId()\\u003e0){\\n                uint256 indexId=dContract.getSlotExecutionId();\\n                for(uint256 i=0;i\\u003cdContract.getIncentiveMapping(indexId).length;i++){\\n                    updatedAmount=updatedAmount.add(dContract.getIncentiveMapping(indexId)[i].incentiveAmount);\\n                    if(dContract.getSlotId().sub(1)\\u003eindexId){\\n                            indexId++;\\n                    }\\n                }\\n            }\\n            if(stakeOffset\\u003e0){\\n                dContract.updateTokenStakedAmount(stakeOffset.add(updatedAmount));\\n            }else{\\n                dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount().add(updatedAmount));\\n            }\\n            stakeOffset=0;\\n            dContract.updateSlotExecutionId(dContract.getSlotId());\\n        }\\n    }\\n    function updateXIVForStakers(uint256 index, bool isWon) internal{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        if(isWon){\\n            bObject.status=1;\\n            uint256 rewardAmount=(uint256(bObject.rewardFactor).mul(bObject.amount)).div(10**4);\\n            dContract.updateRewardGeneratedAmount(dContract.getRewardGeneratedAmount().add(rewardAmount));\\n            stakeOffset=stakeOffset.sub(rewardAmount);\\n            bObject.amount=bObject.amount.add(rewardAmount);\\n            dContract.updateBetArrayIndex(bObject,index);\\n        }else{\\n            bObject.status=2;\\n            uint256 riskAmount=(uint256(bObject.riskFactor).mul(bObject.amount)).div(10**4);\\n            stakeOffset=stakeOffset.add(riskAmount);\\n            bObject.amount=bObject.amount.sub(riskAmount);\\n            dContract.updateBetArrayIndex(bObject,index);\\n        }\\n        dContract.updateExistingBetCheckMapping(bObject.userAddress,bObject.betType,bObject.contractAddress,false);\\n    }\\n    \\n    function getCalculateIndexValueForFixed(uint256 index) public view returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap;\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        for(uint256 i=0;i\\u003cdContract.getBetIndexForFixedArray(bObject.id).length;i++){\\n            Token tObj=Token(dContract.getBetIndexForFixedArray(bObject.id)[i].contractAddress);\\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getBetIndexForFixedArray(bObject.id)[i].contractAddress);\\n            if(iCObj.status){\\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\\n            }\\n        }\\n        return totalMarketcap;\\n    }\\n    \\n    function updateXIVForStakersIndexFixed(uint256 index) internal{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap=getCalculateIndexValueForFixed(index);\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        if(dContract.getBetPriceHistoryFixedMapping(bObject.id).actualIndexValue\\u003etotalMarketcap){\\n             uint16 percentageValue=uint16(((dContract.getBetPriceHistoryFixedMapping(bObject.id).actualIndexValue\\n                                                .sub(totalMarketcap)\\n                                                .mul(10**4)).div(dContract.getBetPriceHistoryFixedMapping(bObject.id).actualIndexValue)));\\n            if(percentageValue\\u003e=bObject.checkpointPercent){\\n                updateXIVForStakers(index, true);\\n            }else{\\n                updateXIVForStakers(index, false);\\n            }\\n        }else{\\n            updateXIVForStakers(index, false);\\n        }\\n    }\\n    function getCalculateIndexValueForFlexible(uint256 index) public view returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap;\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        for(uint256 i=0;i\\u003cdContract.getBetIndexForFlexibleArray(bObject.id).length;i++){\\n            Token tObj=Token(dContract.getBetIndexForFlexibleArray(bObject.id)[i].contractAddress);\\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getBetIndexForFlexibleArray(bObject.id)[i].contractAddress);\\n            if(iCObj.status){\\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\\n            }\\n        }\\n        return totalMarketcap;\\n    }\\n    function marketCapValue(XIVDatabaseLib.IndexCoin memory iCObj,Token tObj) internal view returns(uint256){\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\\n         if((keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked(\\\"ETH\\\"))) || (keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked(\\\"BTC\\\")))){\\n            return ((((oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\\n                                    /*    .mul(iCObj.contributionPercentage)*/)\\n                                        .div(10**2)));\\n        }else{\\n            return (((tObj.totalSupply().mul(oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\\n                                /*.mul(iCObj.contributionPercentage)*/)\\n                                .div((10**tObj.decimals()).mul(10**2))));\\n        }\\n    }\\n    function updateXIVForStakersIndexFlexible(uint256 index) internal{\\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\\n        uint256 totalMarketcap=getCalculateIndexValueForFlexible(index);\\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\\n        if(dContract.getBetPriceHistoryFlexibleMapping(bObject.id).actualIndexValue\\u003etotalMarketcap){\\n             uint16 percentageValue=uint16(((dContract.getBetPriceHistoryFlexibleMapping(bObject.id).actualIndexValue.sub(totalMarketcap)\\n                                                     .mul(10**4)).div(dContract.getBetPriceHistoryFlexibleMapping(bObject.id).actualIndexValue)));\\n            if(percentageValue\\u003e=bObject.checkpointPercent){\\n                updateXIVForStakers(index, true);\\n            }else{\\n                updateXIVForStakers(index, false);\\n            }\\n        }else{\\n            updateXIVForStakers(index, false);\\n        }\\n    }\\n    \\n    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\\n        databaseContractAddress=_databaseContractAddress;\\n    }\\n}\\n\"},\"XIVDatabaseLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nlibrary XIVDatabaseLib{\\n    // deficoin struct for deficoinmappings..\\n    struct DefiCoin{\\n        uint16 oracleType;\\n        string currencySymbol;\\n        bool status;\\n    }\\n    struct TimePeriod{\\n        uint256 _days;\\n        bool status;\\n    }\\n     struct FlexibleInfo{\\n        uint256 id;\\n        uint16 upDownPercentage; //10**2\\n        uint16 riskFactor;       //10**2\\n        uint16 rewardFactor;     //10**2\\n        bool status;\\n    }\\n    struct FixedInfo{\\n        uint256 id;\\n        uint256 daysCount;// integer value\\n        uint16 upDownPercentage; //10**2\\n        uint16 riskFactor;       //10**2\\n        uint16 rewardFactor;     //10**2\\n        bool status;\\n    }\\n    struct IndexCoin{\\n        uint16 oracleType;\\n        string currencySymbol;\\n        address contractAddress;\\n        bool status;\\n        uint256 contributionPercentage; //10**2\\n    }\\n    struct BetPriceHistory{\\n        uint256 baseIndexValue;\\n        uint256 actualIndexValue;\\n    }\\n    struct LPLockedInfo{\\n        uint256 lockedTimeStamp;\\n        uint256 amountLocked;\\n    }\\n    struct StakingInfo{\\n        uint256 investmentId;\\n        uint256 stakeAmount;\\n    }\\n    struct IncentiveInfo{\\n        uint256 tillInvestmentId;\\n        uint256 incentiveAmount;\\n        uint256 totalAmountStakedAtIncentiveTime;\\n    }\\n    struct BetInfo{\\n        uint256 id;\\n        uint256 principalAmount;\\n        uint256 amount;\\n        address userAddress;\\n        address contractAddress;\\n        uint256 betType; //\\n        uint256 currentPrice;\\n        uint256 timestamp;\\n        uint256 betTimePeriod;\\n        uint16 checkpointPercent;\\n        uint16 rewardFactor;\\n        uint16 riskFactor;\\n        uint256 adminCommissionFee;\\n        uint16 status; // 0-\\u003ebet active, 1-\\u003ebet won, 2-\\u003ebet lost, 3-\\u003e withdraw before result\\n    }\\n}\\n\"},\"XIVInterface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENCED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./XIVDatabaseLib.sol\\\";\\n\\ninterface Token{\\n    function decimals() external view returns(uint256);\\n    function symbol() external view returns(string memory);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n}\\n\\n\\ninterface OracleWrapper{\\n    function getPrice(string calldata currencySymbol,uint256 oracleType) external view returns (uint256);\\n}\\ninterface DatabaseContract{\\n    function transferTokens(address contractAddress,address userAddress,uint256 amount) external;\\n    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external;\\n    function getTokensStaked(address userAddress) external view returns(uint256);\\n    function updateTokensStaked(address userAddress, uint256 amount) external;\\n    function getTokenStakedAmount() external view returns(uint256);\\n    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external;\\n    function getBetId() external view returns(uint256);\\n    function updateBetId(uint256 _userBetId) external;\\n    function updateBetArray(XIVDatabaseLib.BetInfo memory bObject) external;\\n    function getBetArray() external view returns(XIVDatabaseLib.BetInfo[] memory);\\n    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256);\\n    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external;\\n    function updateUserStakedAddress(address _address) external;\\n    function updateUserStakedAddress(address[] memory _userStakedAddress) external;\\n    function getUserStakedAddress() external view returns(address[] memory);\\n    function getDefiCoinsFixedMapping(address _betContractAddress,bool isFlashVault) external view returns(XIVDatabaseLib.DefiCoin memory);\\n    function getDefiCoinsFlexibleMapping(address _betContractAddress) external view returns(XIVDatabaseLib.DefiCoin memory);\\n    function getFlexibleDefiCoinArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\\n    function getFlexibleIndexArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\\n    function updateBetArrayIndex(XIVDatabaseLib.BetInfo memory bObject, uint256 index) external;\\n    function updateBetIndexForFixedArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\\n    function updateBetBaseIndexValue(uint256 _betBaseIndexValueFixed) external;\\n    function getBetBaseIndexValue() external view returns(uint256);\\n    function updateBetPriceHistoryFixedMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\\n    function updateBetActualIndexValue(uint256 _betActualIndexValueFixed) external;\\n    function getBetActualIndexValue() external view returns(uint256);\\n    function getBetIndexForFixedArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\\n    function getBetPriceHistoryFixedMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\\n    function getXIVTokenContractAddress() external view returns(address);\\n    function getAllIndexContractAddressArray() external view returns(address[] memory);\\n    function getDefiCoinIndexMapping(address _ContractAddress) external view returns(XIVDatabaseLib.IndexCoin memory);\\n    \\n    function updateBetIndexForFlexibleArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\\n    function getBetIndexForFlexibleArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\\n    function updateBetPriceHistoryFlexibleMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\\n    function getBetPriceHistoryFlexibleMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\\n    \\n    function getOracleWrapperContractAddress() external view returns(address);\\n    function getPlentyOneDayPercentage() external view returns(uint256);\\n    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256);\\n    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256);\\n    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory);\\n    function updateBetAddressesArray(address userAddress, uint256 _betId) external;\\n    function getRewardGeneratedAmount() external view returns(uint256);\\n    function updateRewardGeneratedAmount(uint256 _rewardGeneratedAmount) external;\\n    function addUserAddressUsedForBetting(address userAddress) external;\\n    function getUserAddressUsedForBetting() external view returns(address[] memory);\\n    function getFixedDefiCoinArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\\n    function getFixedDefiIndexArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\\n    function getMaxStakeXIVAmount() external view returns(uint256);\\n    function getMinStakeXIVAmount() external view returns(uint256);\\n    function getBetFactorLP() external view returns(uint256);\\n    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external;\\n    function getActualAmountStakedByUser(address userAddress) external view returns(uint256);\\n    function isDaysAvailable(uint256 _days) external view returns(bool);\\n    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external;\\n    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool);\\n    function updateTotalTransactions(uint256 _totalTransactions) external;\\n    function getTotalTransactions() external view returns(uint256);\\n    function getFlexibleDefiCoinTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\\n    function getFlexibleIndexTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\\n    function getMinLPvalue() external view returns(uint256);\\n    function getLockingPeriodForLPMapping(address userAddress) external view returns(XIVDatabaseLib.LPLockedInfo memory);\\n    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external;\\n    function getStakingInfoMapping(address userAddress) external view returns(XIVDatabaseLib.StakingInfo[] memory);\\n    function updateStakingInfoMapping(address userAddress, XIVDatabaseLib.StakingInfo memory sInfo) external;\\n    function getInvestmentId() external view returns(uint256);\\n    function updateInvestmentId(uint256 _investmentId) external;\\n    function getSlotExecutionId() external view returns(uint256);\\n    function updateSlotExecutionId(uint256 _slotExecutionId) external;\\n    function getSlotId() external view returns(uint256);\\n    function updateSlotId(uint256 _slotId) external;\\n    function updateIncentiveMapping(uint256 _slotId, XIVDatabaseLib.IncentiveInfo memory iInfo) external;\\n    function getIncentiveMapping(uint256 _slotId) external view returns(XIVDatabaseLib.IncentiveInfo[] memory);\\n    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external;\\n    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external ;\\n    function updateIsStakeMapping(address userAddress,bool isStake) external;\\n    function getIsStakeMapping(address userAddress) external view returns(bool);\\n    \\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOfXIV\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"typeOfBet\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_betContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"betSlabeIndex\",\"type\":\"uint256\"}],\"name\":\"betFixed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"checkTimeForBet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"databaseContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getCalculateIndexValueForFixed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getCalculateIndexValueForFlexible\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserStakedAddressCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pageNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"incentiveStakers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_databaseContractAddress\",\"type\":\"address\"}],\"name\":\"updateDatabaseAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"offerIds\",\"type\":\"uint256[]\"}],\"name\":\"updateStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"XIVBettingFixed","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://60743db59c13682b4e3e81984e69e2e942863a1fdf0471d6cf011a12a345619c"}]}