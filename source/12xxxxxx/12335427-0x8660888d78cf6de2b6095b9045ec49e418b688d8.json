{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.7.0;\r\n\r\ncontract GatedLogBatcherLib {\r\n\r\n    bytes32 constant private GUARD_VALUE = keccak256(\"logs.guard.bytes32\");\r\n\r\n    bytes32 guard;\r\n\r\n    constructor() public {\r\n        guard = GUARD_VALUE;\r\n    }\r\n\r\n    function batchLogs(bytes memory logs)\r\n        public\r\n    {\r\n        require(guard != GUARD_VALUE, \"LogBatcher should only be called via delegatecall\");\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let length := mload(logs)\r\n            let i := 0x20\r\n            for { } lt(i, length) { } {\r\n                // First byte of the data is the operation.\r\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\r\n                // This will also zero out unused data.\r\n                let operation := shr(0xf8, mload(add(logs, i)))\r\n                // We offset the load address by 1 byte (operation byte)\r\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\r\n                let to := shr(0x60, mload(add(logs, add(i, 0x01))))\r\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\r\n                let value := mload(add(logs, add(i, 0x15)))\r\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\r\n                let dataLength := mload(add(logs, add(i, 0x35)))\r\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\r\n                let data := add(logs, add(i, 0x55))\r\n                let success := 0\r\n                switch operation\r\n                case 0 { success := call(gas, to, value, data, dataLength, 0, 0) }\r\n                case 1 { success := delegatecall(gas, to, data, dataLength, 0, 0) }\r\n                if eq(success, 0) { revert(0, 0) }\r\n                // Next entry starts at 85 byte + data length\r\n                i := add(i, add(0x55, dataLength))\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"logs\",\"type\":\"bytes\"}],\"name\":\"batchLogs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GatedLogBatcherLib","CompilerVersion":"v0.5.14+commit.01f1aaa4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b6dbc1fe203f2a12a30d18027843283a2d8235dd16fbdade2163e29b58c03646"}]}