{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    /**\r\n        * @dev Returns the amount of tokens owned by `account`.\r\n        */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n        *\r\n        * Returns a boolean value indicating whether the operation succeeded.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface Uni {\r\n    function swapExactTokensForTokens(\r\n        uint256,\r\n        uint256,\r\n        address[] calldata,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut, \r\n        uint amountInMax, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n}\r\n\r\nlibrary UniswapV2Exchange {\r\n    address public constant DEX = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    function swapExactERC20ForERC20(\r\n        address _from,\r\n        address _to,\r\n        address _recipient,\r\n        uint256 _fromAmount\r\n    ) external returns (uint256[] memory amounts) {\r\n        if(_fromAmount == 0) { return amounts; }\r\n        // approve tokens to the DEX \r\n        IERC20(_from).approve(DEX, _fromAmount);\r\n\r\n        address[] memory _path = new address[](3);\r\n        _path[0] = _from;\r\n        _path[1] = WETH;\r\n        _path[2] = _to;\r\n\r\n        return\r\n            Uni(DEX).swapExactTokensForTokens(\r\n                _fromAmount,\r\n                uint256(0),\r\n                _path,\r\n                _recipient,\r\n                block.timestamp + 1800\r\n            );\r\n    }\r\n\r\n    function swapERC20ForExactERC20(\r\n        address _from,\r\n        address _to,\r\n        address _recipient,\r\n        uint256 _amountOut\r\n    ) external returns (uint256[] memory amounts) {\r\n        uint256 _bal = IERC20(_from).balanceOf(address(this));\r\n        if(_bal == 0) { return amounts; }\r\n        // approve tokens to the DEX\r\n        IERC20(_from).approve(DEX, _bal);\r\n\r\n        address[] memory _path = new address[](3);\r\n        _path[0] = _from;\r\n        _path[1] = WETH;\r\n        _path[2] = _to;\r\n\r\n        return\r\n            Uni(DEX).swapTokensForExactTokens(\r\n                _amountOut,\r\n                _bal,\r\n                _path,\r\n                _recipient,\r\n                block.timestamp + 1800\r\n            );\r\n    }\r\n\r\n    function swapERC20ForExactETH(\r\n        address _from,\r\n        address _recipient,\r\n        uint256 _amountOut\r\n    ) external returns (uint256[] memory amounts) {\r\n        uint256 _bal = IERC20(_from).balanceOf(address(this));\r\n        if(_bal == 0) { return amounts; }\r\n        // approve tokens to the DEX\r\n        IERC20(_from).approve(DEX, _bal);\r\n\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = _from;\r\n        _path[1] = WETH;\r\n\r\n        return\r\n            Uni(DEX).swapTokensForExactETH(\r\n                _amountOut,\r\n                _bal,\r\n                _path,\r\n                _recipient,\r\n                block.timestamp + 1800\r\n            );\r\n    }\r\n\r\n    function swapExactERC20ForETH(\r\n        address _from,\r\n        address _recipient,\r\n        uint256 _amountIn\r\n    ) external returns (uint256[] memory amounts) {\r\n        if(_amountIn == 0) { return amounts; }\r\n        // approve tokens to the DEX\r\n        IERC20(_from).approve(DEX, _amountIn);\r\n\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = _from;\r\n        _path[1] = WETH;\r\n\r\n        return\r\n            Uni(DEX).swapExactTokensForETH(\r\n                _amountIn,\r\n                0,\r\n                _path,\r\n                _recipient,\r\n                block.timestamp + 1800\r\n            );\r\n    }\r\n\r\n    function swapETHForExactERC20(\r\n        address _to,\r\n        address _recipient,\r\n        uint256 _amountOut\r\n    ) external returns (uint256[] memory amounts) {\r\n        if(address(this).balance == 0) { return amounts; }\r\n        \r\n        address[] memory _path = new address[](2);\r\n        _path[0] = WETH;\r\n        _path[1] = _to;\r\n\r\n        bytes memory _data = abi.encodeWithSelector(Uni(DEX).swapETHForExactTokens.selector, _amountOut, _path, _recipient, block.timestamp + 1800);\r\n\r\n        (bool success, bytes memory _amounts) = DEX.call{value:address(this).balance}(_data);\r\n        require(success, \"swapETHForExactERC20: uniswap swap failed.\");\r\n\r\n        (amounts) = abi.decode(\r\n            _amounts,\r\n            (uint256[])\r\n        );\r\n    }\r\n\r\n    function swapExactETHForERC20(\r\n        address _to,\r\n        address _recipient,\r\n        uint256 _amountOutMin\r\n    ) external returns (uint256[] memory amounts) {\r\n        if(address(this).balance == 0) { return amounts; }\r\n        \r\n        address[] memory _path = new address[](2);\r\n        _path[0] = WETH;\r\n        _path[1] = _to;\r\n\r\n        bytes memory _data = abi.encodeWithSelector(Uni(DEX).swapExactETHForTokens.selector, _amountOutMin, _path, _recipient, block.timestamp + 1800);\r\n\r\n        (bool success, bytes memory _amounts) = DEX.call{value:address(this).balance}(_data);\r\n        require(success, \"swapExactETHForERC20: uniswap swap failed.\");\r\n\r\n        (amounts) = abi.decode(\r\n            _amounts,\r\n            (uint256[])\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"DEX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniswapV2Exchange","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9a2d97b4e7bf76b2cebb94bb8fa9122ff8ad9f638ef33c21a208f3c8d7d2bf9a"}]}