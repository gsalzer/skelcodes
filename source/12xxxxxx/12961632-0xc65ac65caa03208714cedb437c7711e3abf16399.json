{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EarlyBirdRegistry/EarlyBirdRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\n\\nimport './IEarlyBirdRegistry.sol';\\n\\n/// @title EarlyBirdRegistry\\n/// @author Simon Fremaux (@dievardump)\\ncontract EarlyBirdRegistry is IEarlyBirdRegistry {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    event ProjectCreated(\\n        address indexed creator,\\n        uint256 indexed projectId,\\n        uint256 endRegistration, // when the registration ends\\n        uint256 maxRegistration, // how many people can register\\n        bool open // if the project accepts Open Registration\\n    );\\n\\n    event Registration(uint256 indexed projectId, address[] list);\\n\\n    struct Project {\\n        bool open;\\n        address creator;\\n        uint256 endRegistration;\\n        uint256 maxRegistration;\\n    }\\n\\n    // this is a counter that increments automatically when registering an Early Bird Project\\n    uint256 lastProjectId;\\n\\n    // list of all projects\\n    mapping(uint256 => Project) public projects;\\n\\n    // list of registered address for a project\\n    mapping(uint256 => EnumerableSet.AddressSet) internal _registered;\\n\\n    modifier onlyProject(uint256 projectId) {\\n        require(exists(projectId), 'Unknown project id.');\\n        _;\\n    }\\n\\n    constructor() {}\\n\\n    /// @notice allows anyone to register a new project that accepts Early Birds registrations\\n    /// @param open if the early bird registration is open or only creator can register addresses\\n    /// @param endRegistration unix epoch timestamp of registration closing\\n    /// @param maxRegistration the max registration count\\n    /// @return projectId the project Id (useful if called by a contract)\\n    function registerProject(\\n        bool open,\\n        uint256 endRegistration,\\n        uint256 maxRegistration\\n    ) external override returns (uint256 projectId) {\\n        projectId = lastProjectId + 1;\\n        lastProjectId = projectId;\\n\\n        projects[projectId] = Project({\\n            open: open,\\n            creator: msg.sender,\\n            endRegistration: endRegistration,\\n            maxRegistration: maxRegistration\\n        });\\n\\n        emit ProjectCreated(\\n            msg.sender,\\n            projectId,\\n            endRegistration,\\n            maxRegistration,\\n            open\\n        );\\n    }\\n\\n    /// @notice tells if a project exists\\n    /// @param projectId project id to check\\n    /// @return true if the project exists\\n    function exists(uint256 projectId) public view override returns (bool) {\\n        return projectId > 0 && projectId <= lastProjectId;\\n    }\\n\\n    /// @notice Helper to paginate all address registered for a project\\n    ///         Using pagination just in case it ever happens that there are much EarlyBirds\\n    /// @param projectId the project id\\n    /// @param offset index where to start\\n    /// @param limit how many to grab\\n    /// @return list of registered addresses\\n    function listRegistrations(\\n        uint256 projectId,\\n        uint256 offset,\\n        uint256 limit\\n    )\\n        external\\n        view\\n        override\\n        onlyProject(projectId)\\n        returns (address[] memory list)\\n    {\\n        EnumerableSet.AddressSet storage registered = _registered[projectId];\\n\\n        uint256 count = registered.length();\\n\\n        require(offset < count, 'Offset too high');\\n\\n        if (count < offset + limit) {\\n            limit = count - offset;\\n        }\\n\\n        list = new address[](limit);\\n        for (uint256 i; i < limit; i++) {\\n            list[i] = registered.at(offset + i);\\n        }\\n    }\\n\\n    /// @notice Helper to know how many address registered to a project\\n    /// @param projectId the project id\\n    /// @return how many people registered\\n    function registeredCount(uint256 projectId)\\n        external\\n        view\\n        override\\n        onlyProject(projectId)\\n        returns (uint256)\\n    {\\n        return _registered[projectId].length();\\n    }\\n\\n    /// @notice Small helpers that returns in how many seconds a project registration ends\\n    /// @param projectId to check\\n    /// @return the time in second before end; 0 if ended\\n    function registrationEndsIn(uint256 projectId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (projects[projectId].endRegistration <= block.timestamp) {\\n            return 0;\\n        }\\n\\n        return projects[projectId].endRegistration - block.timestamp;\\n    }\\n\\n    /// @notice Helper to check if an address is registered for a project id\\n    /// @param check the address to check\\n    /// @param projectId the project id\\n    /// @return if the address was registered as an early bird\\n    function isRegistered(address check, uint256 projectId)\\n        external\\n        view\\n        override\\n        onlyProject(projectId)\\n        returns (bool)\\n    {\\n        return _registered[projectId].contains(check);\\n    }\\n\\n    /// @notice Allows the creator of a project to change registration open state\\n    ///         this can be usefull to first register a specific list of addresses\\n    ///         before making the registration public\\n    /// @param projectId to modify\\n    /// @param open if the project is open to anyone or only creator can change\\n    function setRegistrationOpen(uint256 projectId, bool open) external {\\n        require(\\n            msg.sender == projects[projectId].creator,\\n            'Not project creator.'\\n        );\\n        projects[projectId].open = open;\\n    }\\n\\n    /// @notice Allows a user to register for an EarlyBird spot on a project\\n    /// @dev the project needs to be \\\"open\\\" for people to register directly to it\\n    /// @param projectId the project id to register to\\n    function registerTo(uint256 projectId) external onlyProject(projectId) {\\n        Project memory project = projects[projectId];\\n        require(project.open == true, 'Project not open.');\\n\\n        EnumerableSet.AddressSet storage registered = _registered[projectId];\\n        require(\\n            // before end registration time\\n            block.timestamp <= project.endRegistration &&\\n                // and there is still available spots\\n                registered.length() + 1 <= project.maxRegistration,\\n            'Registration closed.'\\n        );\\n\\n        require(!registered.contains(msg.sender), 'Already registered');\\n\\n        // add user to list\\n        registered.add(msg.sender);\\n\\n        address[] memory list = new address[](1);\\n        list[0] = msg.sender;\\n\\n        emit Registration(projectId, list);\\n    }\\n\\n    /// @notice Allows a project creator to add early birds in Batch\\n    /// @dev msg.sender must be the projectId creator\\n    /// @param projectId to add to\\n    /// @param birds all addresses to add\\n    function registerBatchTo(uint256 projectId, address[] memory birds)\\n        external\\n        override\\n    {\\n        Project memory project = projects[projectId];\\n\\n        require(msg.sender == project.creator, 'Not project creator.');\\n\\n        uint256 count = birds.length;\\n        EnumerableSet.AddressSet storage registered = _registered[projectId];\\n        // before end registration time\\n        require(\\n            block.timestamp <= project.endRegistration,\\n            'Registration closed.'\\n        );\\n\\n        // and there is still enough available spots\\n        require(\\n            registered.length() + count <= project.maxRegistration,\\n            'Not enough spots.'\\n        );\\n\\n        for (uint256 i; i < count; i++) {\\n            registered.add(birds[i]);\\n        }\\n\\n        emit Registration(projectId, birds);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EarlyBirdRegistry/IEarlyBirdRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title IEarlyBirdRegistry\\n/// @author Simon Fremaux (@dievardump)\\ninterface IEarlyBirdRegistry {\\n    /// @notice allows anyone to register a new project that accepts Early Birds registrations\\n    /// @param open if the early bird registration is open or only creator can register addresses\\n    /// @param endRegistration unix epoch timestamp of registration closing\\n    /// @param maxRegistration the max registration count\\n    /// @return projectId the project Id (useful if called by a contract)\\n    function registerProject(\\n        bool open,\\n        uint256 endRegistration,\\n        uint256 maxRegistration\\n    ) external returns (uint256 projectId);\\n\\n    /// @notice tells if a project exists\\n    /// @param projectId project id to check\\n    /// @return if the project exists\\n    function exists(uint256 projectId) external view returns (bool);\\n\\n    /// @notice Helper to paginate all address registered for a project\\n    /// @param projectId the project id\\n    /// @param offset index where to start\\n    /// @param limit how many to grab\\n    /// @return list of registered addresses\\n    function listRegistrations(\\n        uint256 projectId,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory list);\\n\\n    /// @notice Helper to know how many address registered to a project\\n    /// @param projectId the project id\\n    /// @return how many people registered\\n    function registeredCount(uint256 projectId) external view returns (uint256);\\n\\n    /// @notice Helper to check if an address is registered for a project id\\n    /// @param check the address to check\\n    /// @param projectId the project id\\n    /// @return if the address was registered as an early bird\\n    function isRegistered(address check, uint256 projectId)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// @notice Allows a project creator to add early birds in Batch\\n    /// @dev msg.sender must be the projectId creator\\n    /// @param projectId to add to\\n    /// @param birds all addresses to add\\n    function registerBatchTo(uint256 projectId, address[] memory birds)\\n        external;\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endRegistration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxRegistration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"ProjectCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"check\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"isRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"listRegistrations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projects\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endRegistration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRegistration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"birds\",\"type\":\"address[]\"}],\"name\":\"registerBatchTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"endRegistration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRegistration\",\"type\":\"uint256\"}],\"name\":\"registerProject\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"registerTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"registeredCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"registrationEndsIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"setRegistrationOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EarlyBirdRegistry","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}