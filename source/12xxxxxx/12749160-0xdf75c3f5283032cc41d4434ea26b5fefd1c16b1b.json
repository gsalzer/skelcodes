{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PublicSale.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.4;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\n\\nimport { InvestorsVesting, IVesting } from './InvestorsVesting.sol';\\nimport { LiquidityProvider, ILiquidityProvider } from './LiquidityProvider.sol';\\nimport './CliffVesting.sol';\\nimport './interfaces/IPublicSale.sol';\\nimport './interfaces/IOneUp.sol';\\n\\n\\ncontract PublicSale is IPublicSale, Ownable {\\n    using SafeMath for uint256;\\n\\n    bool public privateSaleFinished;\\n    bool public liquidityPoolCreated;\\n\\n    IOneUp public oneUpToken;\\n    IVesting public immutable vesting;\\n    ILiquidityProvider public immutable lpProvider;\\n\\n    address public reserveLockContract;\\n    address public marketingLockContract;\\n    address public developerLockContract;\\n    address payable public immutable publicSaleFund;\\n\\n    uint256 public totalDeposits;\\n    uint256 public publicSaleStartTimestamp;\\n    uint256 public publicSaleFinishedAt;\\n\\n    uint256 public constant PUBLIC_SALE_DELAY = 7 days;\\n    uint256 public constant LP_CREATION_DELAY = 30 minutes;\\n    uint256 public constant TRADING_BLOCK_DELAY = 15 minutes;\\n    uint256 public constant WHITELISTED_USERS_ACCESS = 2 hours;\\n\\n    uint256 public constant PUBLIC_SALE_LOCK_PERCENT = 5000;  // 50% of tokens\\n    uint256 public constant PRIVATE_SALE_LOCK_PERCENT = 1500; // 15% of tokens\\n    uint256 public constant PUBLIC_SALE_PRICE = 151000;       // 1 ETH = 151,000 token\\n\\n    uint256 public constant HARD_CAP_ETH_AMOUNT = 300 ether;\\n    uint256 public constant MIN_DEPOSIT_ETH_AMOUNT = 0.1 ether;\\n    uint256 public constant MAX_DEPOSIT_ETH_AMOUNT = 3 ether;\\n\\n    mapping(address => uint256) internal _deposits;\\n    mapping(address => uint256) internal _whitelistedAmount;\\n\\n    event Deposited(address indexed user, uint256 amount);\\n    event Recovered(address token, uint256 amount);\\n    event EmergencyWithdrawn(address user, uint256 amount);\\n    event UsersWhitelisted(address[] users, uint256 maxAmount);\\n\\n    // ------------------------\\n    // CONSTRUCTOR\\n    // ------------------------\\n\\n    constructor(address oneUpToken_, address payable publicSaleFund_, address uniswapRouter_) {\\n        require(oneUpToken_ != address(0), 'PublicSale: Empty token address!');\\n        require(publicSaleFund_ != address(0), 'PublicSale: Empty fund address!');\\n        require(uniswapRouter_ != address(0), 'PublicSale: Empty uniswap router address!');\\n\\n        oneUpToken = IOneUp(oneUpToken_);\\n        publicSaleFund = publicSaleFund_;\\n\\n        address vestingAddr = address(new InvestorsVesting(oneUpToken_));\\n        vesting = IVesting(vestingAddr);\\n\\n        address lpProviderAddr = address(new LiquidityProvider(oneUpToken_, uniswapRouter_));\\n        lpProvider = ILiquidityProvider(lpProviderAddr);\\n    }\\n\\n    // ------------------------\\n    // PAYABLE RECEIVE\\n    // ------------------------\\n\\n    /// @notice Public receive method which accepts ETH\\n    /// @dev It can be called ONLY when private sale finished, and public sale is active\\n    receive() external payable {\\n        deposit();\\n    }\\n\\n    function deposit() public payable {\\n        require(privateSaleFinished, 'PublicSale: Private sale not finished yet!');\\n        require(publicSaleFinishedAt == 0, 'PublicSale: Public sale already ended!');\\n        require(block.timestamp >= publicSaleStartTimestamp && block.timestamp <= publicSaleStartTimestamp.add(PUBLIC_SALE_DELAY), 'PublicSale: Time was reached!');\\n        require(totalDeposits.add(msg.value) <= HARD_CAP_ETH_AMOUNT, 'PublicSale: Deposit limits reached!');\\n        require(_deposits[msg.sender].add(msg.value) >= MIN_DEPOSIT_ETH_AMOUNT && _deposits[msg.sender].add(msg.value) <= MAX_DEPOSIT_ETH_AMOUNT, 'PublicSale: Limit is reached or not enough amount!');\\n\\n        // Check the whitelisted status during the the first 2 hours\\n        if (block.timestamp < publicSaleStartTimestamp.add(WHITELISTED_USERS_ACCESS)) {\\n            require(_whitelistedAmount[msg.sender] > 0, 'PublicSale: Its time for whitelisted investors only!');\\n            require(_whitelistedAmount[msg.sender] >= msg.value, 'PublicSale: Sent amount should not be bigger from allowed limit!');\\n            _whitelistedAmount[msg.sender] = _whitelistedAmount[msg.sender].sub(msg.value);\\n        }\\n\\n        _deposits[msg.sender] = _deposits[msg.sender].add(msg.value);\\n        totalDeposits = totalDeposits.add(msg.value);\\n\\n        uint256 tokenAmount = msg.value.mul(PUBLIC_SALE_PRICE);\\n        vesting.submit(msg.sender, tokenAmount, PUBLIC_SALE_LOCK_PERCENT);\\n\\n        emit Deposited(msg.sender, msg.value);\\n    }\\n\\n    // ------------------------\\n    // SETTERS (PUBLIC)\\n    // ------------------------\\n\\n    /// @notice Finish public sale\\n    /// @dev It can be called by anyone, if deadline or hard cap was reached\\n    function endPublicSale() external override {\\n        require(publicSaleFinishedAt == 0, 'endPublicSale: Public sale already finished!');\\n        require(privateSaleFinished, 'endPublicSale: Private sale not finished yet!');\\n        require(block.timestamp > publicSaleStartTimestamp.add(PUBLIC_SALE_DELAY) || totalDeposits.add(1 ether) >= HARD_CAP_ETH_AMOUNT, 'endPublicSale: Can not be finished!');\\n        publicSaleFinishedAt = block.timestamp;\\n    }\\n\\n    /// @notice Distribute collected ETH between company/liquidity provider and create liquidity pool\\n    /// @dev It can be called by anyone, after LP_CREATION_DELAY from public sale finish\\n    function addLiquidity() external override  {\\n        require(!liquidityPoolCreated, 'addLiquidity: Pool already created!');\\n        require(publicSaleFinishedAt != 0, 'addLiquidity: Public sale not finished!');\\n        require(block.timestamp > publicSaleFinishedAt.add(LP_CREATION_DELAY), 'addLiquidity: Time was not reached!');\\n\\n        liquidityPoolCreated = true;\\n\\n        // Calculate distribution and liquidity amounts\\n        uint256 balance = address(this).balance;\\n        // Prepare 60% of all ETH for LP creation\\n        uint256 liquidityEth = balance.mul(6000).div(10000);\\n\\n        // Transfer ETH to pre-sale address and liquidity provider\\n        publicSaleFund.transfer(balance.sub(liquidityEth));\\n        payable(address(lpProvider)).transfer(liquidityEth);\\n\\n        // Create liquidity pool\\n        lpProvider.addLiquidity();\\n\\n        // Start vesting for investors\\n        vesting.setStart();\\n\\n        // Tokens will be tradable in TRADING_BLOCK_DELAY\\n        oneUpToken.setTradingStart(block.timestamp.add(TRADING_BLOCK_DELAY));\\n    }\\n\\n    /// @notice Investor withdraw invested funds\\n    /// @dev Method will be available after 1 day if liquidity was not added\\n    function emergencyWithdrawFunds() external override {\\n      require(!liquidityPoolCreated, 'emergencyWithdrawFunds: Liquidity pool already created!');\\n      require(publicSaleFinishedAt != 0, 'emergencyWithdrawFunds: Public sale not finished!');\\n      require(block.timestamp > publicSaleFinishedAt.add(LP_CREATION_DELAY).add(1 days), 'emergencyWithdrawFunds: Not allowed to call now!');\\n\\n      uint256 investedAmount = _deposits[msg.sender];\\n      require(investedAmount > 0, 'emergencyWithdrawFunds: No funds to receive!');\\n\\n      // Reset user vesting information\\n      vesting.reset(msg.sender);\\n\\n      // Transfer funds back to the user\\n      _deposits[msg.sender] = 0;\\n      payable(msg.sender).transfer(investedAmount);\\n\\n      emit EmergencyWithdrawn(msg.sender, investedAmount);\\n    }\\n\\n    // ------------------------\\n    // SETTERS (OWNABLE)\\n    // ------------------------\\n\\n    /// @notice Admin can manually add private sale investors with this method\\n    /// @dev It can be called ONLY during private sale, also lengths of addresses and investments should be equal\\n    /// @param investors Array of investors addresses\\n    /// @param amounts Tokens Amount which investors needs to receive (INVESTED ETH * 200.000)\\n    function addPrivateAllocations(address[] memory investors, uint256[] memory amounts) external override onlyOwner {\\n        require(!privateSaleFinished, 'addPrivateAllocations: Private sale is ended!');\\n        require(investors.length > 0, 'addPrivateAllocations: Array can not be empty!');\\n        require(investors.length == amounts.length, 'addPrivateAllocations: Arrays should have the same length!');\\n\\n        vesting.submitMulti(investors, amounts, PRIVATE_SALE_LOCK_PERCENT);\\n    }\\n\\n    /// @notice Finish private sale and start public sale\\n    /// @dev It can be called once and ONLY during private sale, by admin\\n    function endPrivateSale() external override onlyOwner {\\n        require(!privateSaleFinished, 'endPrivateSale: Private sale is ended!');\\n\\n        privateSaleFinished = true;\\n        publicSaleStartTimestamp = block.timestamp;\\n    }\\n\\n    /// @notice Recover contract based tokens\\n    /// @dev Should be called by admin only to recover lost tokens\\n    function recoverERC20(address tokenAddress) external override onlyOwner {\\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\\n        IERC20(tokenAddress).transfer(msg.sender, balance);\\n        emit Recovered(tokenAddress, balance);\\n    }\\n\\n    /// @notice Recover locked LP tokens when time reached\\n    /// @dev Should be called by admin only, and tokens will be transferred to the owner address\\n    function recoverLpToken(address lPTokenAddress) external override onlyOwner {\\n        lpProvider.recoverERC20(lPTokenAddress, msg.sender);\\n    }\\n\\n    /// @notice Mint and lock tokens for team, marketing, reserve\\n    /// @dev Only admin can call it once, after liquidity pool creation\\n    function lockCompanyTokens(address developerReceiver, address marketingReceiver, address reserveReceiver) external override {\\n        require(marketingReceiver != address(0) && reserveReceiver != address(0) && developerReceiver != address(0), 'lockCompanyTokens: Can not be zero address!');\\n        require(marketingLockContract == address(0) && reserveLockContract == address(0) && developerLockContract == address(0), 'lockCompanyTokens: Already locked!');\\n        require(block.timestamp > publicSaleFinishedAt.add(LP_CREATION_DELAY), 'lockCompanyTokens: Should be called after LP creation!');\\n        require(liquidityPoolCreated, 'lockCompanyTokens: Pool was not created!');\\n\\n        developerLockContract = address(new CliffVesting(developerReceiver, 30 days, 180 days, address(oneUpToken)));    //  1 month cliff  6 months vesting\\n        marketingLockContract = address(new CliffVesting(marketingReceiver, 7 days, 90 days, address(oneUpToken)));      //  7 days cliff   3 months vesting\\n        reserveLockContract = address(new CliffVesting(reserveReceiver, 270 days, 360 days, address(oneUpToken)));        //  9 months cliff 3 months vesting\\n\\n        oneUpToken.mint(developerLockContract, 2000000 ether);  // 2 mln tokens\\n        oneUpToken.mint(marketingLockContract, 2000000 ether);  // 2 mln tokens\\n        oneUpToken.mint(reserveLockContract, 500000 ether);    // 500k tokens\\n    }\\n\\n    /// @notice Whitelist public sale privileged users\\n    /// @dev This users allowed to invest during the first 2 hours\\n    /// @param users list of addresses\\n    /// @param maxEthDeposit max amount of ETH which users allowed to invest during this period\\n    function whitelistUsers(address[] calldata users, uint256 maxEthDeposit) external override onlyOwner {\\n        require(users.length > 0, 'setWhitelistUsers: Empty array!');\\n\\n        uint256 usersLength = users.length;\\n        for (uint256 i = 0; i < usersLength; i++) {\\n            address user = users[i];\\n            _whitelistedAmount[user] = _whitelistedAmount[user].add(maxEthDeposit);\\n        }\\n\\n        emit UsersWhitelisted(users, maxEthDeposit);\\n    }\\n\\n\\n    // ------------------------\\n    // GETTERS\\n    // ------------------------\\n\\n    /// @notice Returns how much provided user can invest during the first 2 hours (if whitelisted)\\n    /// @param user address\\n    function getWhitelistedAmount(address user) external override view returns (uint256) {\\n        return _whitelistedAmount[user];\\n    }\\n\\n    /// @notice Returns how much user invested during the whole public sale\\n    /// @param user address\\n    function getUserDeposits(address user) external override view returns (uint256) {\\n        return _deposits[user];\\n    }\\n\\n    function getTotalDeposits() external view returns (uint256) {\\n        return totalDeposits;\\n    }\\n }\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/InvestorsVesting.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.4;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\nimport './interfaces/IOneUp.sol';\\nimport './interfaces/IVesting.sol';\\n\\n\\ncontract InvestorsVesting is IVesting, Ownable {\\n    using SafeMath for uint256;\\n\\n    uint256 public start;\\n    uint256 public finish;\\n\\n    uint256 public constant RATE_BASE = 10000; // 100%\\n    uint256 public constant VESTING_DELAY = 90 days;\\n\\n    IOneUp public immutable oneUpToken;\\n\\n    struct Investor {\\n        // If user keep his tokens during the all vesting delay\\n        // He becomes privileged user and will be allowed to do some extra stuff\\n        bool isPrivileged;\\n\\n        // Tge tokens will be available for claiming immediately after UNI liquidity creation\\n        // Users will receive all available TGE tokens with 1 transaction\\n        uint256 tgeTokens;\\n\\n        // Released locked tokens shows amount of tokens, which user already received\\n        uint256 releasedLockedTokens;\\n\\n        // Total locked tokens shows total amount, which user should receive in general\\n        uint256 totalLockedTokens;\\n    }\\n\\n    mapping(address => Investor) internal _investors;\\n\\n    event NewPrivilegedUser(address investor);\\n    event TokensReceived(address investor, uint256 amount, bool isLockedTokens);\\n\\n    // ------------------------\\n    // CONSTRUCTOR\\n    // ------------------------\\n\\n    constructor(address token_) {\\n        oneUpToken = IOneUp(token_);\\n    }\\n\\n    // ------------------------\\n    // SETTERS (ONLY PRE-SALE)\\n    // ------------------------\\n\\n    /// @notice Add investor and receivable amount for future claiming\\n    /// @dev This method can be called only by Public sale contract, during the public sale\\n    /// @param investor Address of investor\\n    /// @param amount Tokens amount which investor should receive in general\\n    /// @param lockPercent Which percent of tokens should be available immediately (after start), and which should be locked\\n    function submit(\\n        address investor,\\n        uint256 amount,\\n        uint256 lockPercent\\n    ) public override onlyOwner {\\n        require(start == 0, 'submit: Can not be added after liquidity pool creation!');\\n\\n        uint256 tgeTokens = amount.mul(lockPercent).div(RATE_BASE);\\n        uint256 lockedAmount = amount.sub(tgeTokens);\\n\\n        _investors[investor].tgeTokens = _investors[investor].tgeTokens.add(tgeTokens);\\n        _investors[investor].totalLockedTokens = _investors[investor].totalLockedTokens.add(lockedAmount);\\n    }\\n\\n    /// @notice Remove investor data\\n    /// @dev Owner will remove investors data if they called emergency exit method\\n    /// @param investor Address of investor\\n    function reset(address investor) public override onlyOwner {\\n      delete _investors[investor];\\n    }\\n\\n    /// @notice The same as submit, but for multiply investors\\n    /// @dev Provided arrays should have the same length\\n    /// @param investors Array of investors\\n    /// @param amounts Array of receivable amounts\\n    /// @param lockPercent Which percent of tokens should be available immediately (after start), and which should be locked\\n    function submitMulti(\\n        address[] memory investors,\\n        uint256[] memory amounts,\\n        uint256 lockPercent\\n    ) external override onlyOwner {\\n        uint256 investorsLength = investors.length;\\n\\n        for (uint i = 0; i < investorsLength; i++) {\\n            submit(investors[i], amounts[i], lockPercent);\\n        }\\n    }\\n\\n    /// @notice Start vesting process\\n    /// @dev After this method investors can claim their tokens\\n    function setStart() external override onlyOwner {\\n        start = block.timestamp;\\n        finish = start.add(VESTING_DELAY);\\n    }\\n\\n    // ------------------------\\n    // SETTERS (ONLY CONTRIBUTOR)\\n    // ------------------------\\n\\n    /// @notice Claim TGE tokens immediately after start\\n    /// @dev Can be called once for each investor\\n    function claimTgeTokens() external override {\\n        require(start > 0, 'claimTgeTokens: TGE tokens not available now!');\\n\\n        // Get user available TGE tokens\\n        uint256 amount = _investors[msg.sender].tgeTokens;\\n        require(amount > 0, 'claimTgeTokens: No available tokens!');\\n\\n        // Update user available TGE balance\\n        _investors[msg.sender].tgeTokens = 0;\\n\\n        // Mint tokens to user address\\n        oneUpToken.mint(msg.sender, amount);\\n\\n        emit TokensReceived(msg.sender, amount, false);\\n    }\\n\\n    /// @notice Claim locked tokens\\n    function claimLockedTokens() external override {\\n        require(start > 0, 'claimLockedTokens: Locked tokens not available now!');\\n\\n        // Get user releasable tokens\\n        uint256 availableAmount = _releasableAmount(msg.sender);\\n        require(availableAmount > 0, 'claimLockedTokens: No available tokens!');\\n\\n        // If investors claim all tokens after vesting finish they become privileged\\n        // No need to validate flag every time, as users will claim all tokens with this method\\n        if (_investors[msg.sender].releasedLockedTokens == 0 && block.timestamp > finish) {\\n            _investors[msg.sender].isPrivileged = true;\\n\\n            emit NewPrivilegedUser(msg.sender);\\n        }\\n\\n        // Update user released locked tokens amount\\n        _investors[msg.sender].releasedLockedTokens = _investors[msg.sender].releasedLockedTokens.add(availableAmount);\\n\\n        // Mint tokens to user address\\n        oneUpToken.mint(msg.sender, availableAmount);\\n\\n        emit TokensReceived(msg.sender, availableAmount, true);\\n    }\\n\\n    // ------------------------\\n    // GETTERS\\n    // ------------------------\\n\\n    /// @notice Get current available locked tokens\\n    /// @param investor address\\n    function getReleasableLockedTokens(address investor) external override view returns (uint256) {\\n        return _releasableAmount(investor);\\n    }\\n\\n    /// @notice Get investor data\\n    /// @param investor address\\n    function getUserData(address investor) external override view returns (\\n        uint256 tgeAmount,\\n        uint256 releasedLockedTokens,\\n        uint256 totalLockedTokens\\n    ) {\\n        return (\\n            _investors[investor].tgeTokens,\\n            _investors[investor].releasedLockedTokens,\\n            _investors[investor].totalLockedTokens\\n        );\\n    }\\n\\n    /// @notice Is investor privileged or not, it will be used from external contracts\\n    /// @param account user address\\n    function isPrivilegedInvestor(address account) external override view returns (bool) {\\n        return _investors[account].isPrivileged;\\n    }\\n\\n    // ------------------------\\n    // INTERNAL\\n    // ------------------------\\n\\n    function _releasableAmount(address investor) private view returns (uint256) {\\n        return _vestedAmount(investor).sub(_investors[investor].releasedLockedTokens);\\n    }\\n\\n    function _vestedAmount(address investor) private view returns (uint256) {\\n        uint256 userMaxTokens = _investors[investor].totalLockedTokens;\\n\\n        if (start == 0 || block.timestamp < start) {\\n            return 0;\\n        } else if (block.timestamp >= finish) {\\n            return userMaxTokens;\\n        } else {\\n            uint256 timeSinceStart = block.timestamp.sub(start);\\n            return userMaxTokens.mul(timeSinceStart).div(VESTING_DELAY);\\n        }\\n    }\\n\\n    function getStartTime() external view returns (uint256) {\\n        return start;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LiquidityProvider.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.4;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\\nimport './interfaces/ILiquidityProvider.sol';\\nimport './interfaces/IOneUp.sol';\\n\\n\\ncontract LiquidityProvider is ILiquidityProvider, Ownable {\\n    using SafeMath for uint256;\\n\\n    uint256 public lock;\\n    uint256 public constant UNISWAP_TOKEN_PRICE = 120000; // 1 ETH = 120,000 1-UP\\n    uint256 public constant LP_TOKENS_LOCK_DELAY = 180 days;\\n\\n    IOneUp public immutable oneUpToken;\\n    IUniswapV2Router02 public immutable uniswap;\\n\\n    event Provided(uint256 token, uint256 amount);\\n    event Recovered(address token, uint256 amount);\\n\\n    // ------------------------\\n    // CONSTRUCTOR\\n    // ------------------------\\n\\n    constructor(address oneUpToken_, address uniswapRouter_) {\\n        oneUpToken = IOneUp(oneUpToken_);\\n        uniswap = IUniswapV2Router02(uniswapRouter_);\\n    }\\n\\n    receive() external payable {\\n        // Silence\\n    }\\n\\n    // ------------------------\\n    // SETTERS (OWNABLE)\\n    // ------------------------\\n\\n    /// @notice Owner can add liquidity to the 1-UP/ETH pool\\n    /// @dev If ETH balance of the contract is 0 transaction will be declined\\n    function addLiquidity() public override onlyOwner {\\n        uint256 balance = address(this).balance;\\n        require(balance > 0, 'addLiquidity: ETH balance is zero!');\\n\\n        uint256 amountTokenDesired = balance.mul(UNISWAP_TOKEN_PRICE);\\n        oneUpToken.mint(address(this), amountTokenDesired);\\n        oneUpToken.approve(address(uniswap), amountTokenDesired);\\n\\n        uniswap.addLiquidityETH{value: (balance)}(\\n            address(oneUpToken),\\n            amountTokenDesired,\\n            amountTokenDesired,\\n            balance,\\n            address(this),\\n            block.timestamp.add(2 hours)\\n        );\\n\\n        lock = block.timestamp;\\n        emit Provided(amountTokenDesired, balance);\\n    }\\n\\n    /// @notice Owner can recover LP tokens after LP_TOKENS_LOCK_DELAY from adding liquidity\\n    /// @dev If time does not reached method will be failed\\n    /// @param lpTokenAddress Address of 1-UP/ETH LP token\\n    /// @param receiver Address who should receive tokens\\n    function recoverERC20(address lpTokenAddress, address receiver) public override onlyOwner {\\n        require(lock != 0, 'recoverERC20: Liquidity not added yet!');\\n        require(block.timestamp >= lock.add(LP_TOKENS_LOCK_DELAY), 'recoverERC20: You can claim LP tokens after 180 days!');\\n\\n        IERC20 lpToken = IERC20(lpTokenAddress);\\n        uint256 balance = lpToken.balanceOf(address(this));\\n        lpToken.transfer(receiver, balance);\\n\\n        emit Recovered(lpTokenAddress, balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CliffVesting.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.4;\\n\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\n\\n\\ncontract CliffVesting is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public immutable cliff;\\n    uint256 public immutable start;\\n    uint256 public immutable duration;\\n    uint256 public released;\\n\\n    // Beneficiary of token after they are released\\n    address public immutable beneficiary;\\n    IERC20 public immutable token;\\n\\n    event TokensReleased(uint256 amount);\\n\\n    // ------------------------\\n    // CONSTRUCTOR\\n    // ------------------------\\n\\n    /// @dev Creates a vesting contract that vests its balance of any ERC20 token to the\\n    /// beneficiary, gradually in a linear fashion until start + duration. By then all\\n    /// of the balance will have vested.\\n    /// @param beneficiary_ address of the beneficiary to whom vested token are transferred\\n    /// @param cliffDuration_ duration in seconds of the cliff in which token will begin to vest\\n    /// @param duration_ duration in seconds of the period in which the token will vest\\n    /// @param token_ address of the locked token\\n    constructor(\\n        address beneficiary_,\\n        uint256 cliffDuration_,\\n        uint256 duration_,\\n        address token_\\n    ) {\\n        require(beneficiary_ != address(0));\\n        require(token_ != address(0));\\n        require(cliffDuration_ <= duration_);\\n        require(duration_ > 0);\\n\\n        beneficiary = beneficiary_;\\n        token = IERC20(token_);\\n        duration = duration_;\\n        start = block.timestamp;\\n        cliff = block.timestamp.add(cliffDuration_);\\n    }\\n\\n    // ------------------------\\n    // SETTERS\\n    // ------------------------\\n\\n    /// @notice Transfers vested tokens to beneficiary\\n    function release() external {\\n        uint256 unreleased = _releasableAmount();\\n\\n        require(unreleased > 0);\\n\\n        released = released.add(unreleased);\\n\\n        token.safeTransfer(beneficiary, unreleased);\\n\\n        emit TokensReleased(unreleased);\\n    }\\n\\n    // ------------------------\\n    // INTERNAL\\n    // ------------------------\\n\\n    /// @notice Calculates the amount that has already vested but hasn't been released yet\\n    function _releasableAmount() private view returns (uint256) {\\n        return _vestedAmount().sub(released);\\n    }\\n\\n    /// @notice Calculates the amount that has already vested\\n    function _vestedAmount() private view returns (uint256) {\\n        uint256 currentBalance = token.balanceOf(address(this));\\n        uint256 totalBalance = currentBalance.add(released);\\n\\n        if (block.timestamp < cliff) {\\n            return 0;\\n        } else if (block.timestamp >= start.add(duration)) {\\n            return totalBalance;\\n        } else {\\n            return totalBalance.mul(block.timestamp.sub(start)).div(duration);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPublicSale.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.4;\\n\\n\\ninterface IPublicSale {\\n    function addLiquidity() external;\\n    function endPublicSale() external;\\n    function endPrivateSale() external;\\n    function emergencyWithdrawFunds() external;\\n    function recoverERC20(address tokenAddress) external;\\n    function recoverLpToken(address lPTokenAddress) external;\\n    function addPrivateAllocations(address[] memory investors, uint256[] memory amounts) external;\\n    function lockCompanyTokens(address marketing, address reserve, address development) external;\\n    function whitelistUsers(address[] calldata users, uint256 maxEthDeposit) external;\\n    function getWhitelistedAmount(address user) external view returns (uint256);\\n    function getUserDeposits(address user) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOneUp.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.4;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n\\ninterface IOneUp is IERC20 {\\n    function burn(uint256 amount) external;\\n    function setTradingStart(uint256 time) external;\\n    function mint(address to, uint256 value) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVesting.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.4;\\n\\n\\ninterface IVesting {\\n    function submit(address investor, uint256 amount, uint256 lockPercent) external;\\n    function submitMulti(address[] memory investors, uint256[] memory amounts, uint256 lockPercent) external;\\n    function setStart() external;\\n    function claimTgeTokens() external;\\n    function claimLockedTokens() external;\\n    function reset(address investor) external;\\n    function isPrivilegedInvestor(address account) external view returns (bool);\\n    function getReleasableLockedTokens(address investor) external view returns (uint256);\\n    function getUserData(address investor) external view returns (uint256 tgeAmount, uint256 releasedLockedTokens, uint256 totalLockedTokens);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidityProvider.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.4;\\n\\n\\ninterface ILiquidityProvider {\\n    function addLiquidity() external;\\n    function recoverERC20(address lpTokenAddress, address receiver) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oneUpToken_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"publicSaleFund_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapRouter_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"UsersWhitelisted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HARD_CAP_ETH_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP_CREATION_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DEPOSIT_ETH_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DEPOSIT_ETH_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRIVATE_SALE_LOCK_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUBLIC_SALE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUBLIC_SALE_LOCK_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUBLIC_SALE_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRADING_BLOCK_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WHITELISTED_USERS_ACCESS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"investors\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"addPrivateAllocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developerLockContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endPrivateSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endPublicSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getWhitelistedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityPoolCreated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"developerReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketingReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reserveReceiver\",\"type\":\"address\"}],\"name\":\"lockCompanyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpProvider\",\"outputs\":[{\"internalType\":\"contract ILiquidityProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingLockContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneUpToken\",\"outputs\":[{\"internalType\":\"contract IOneUp\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"privateSaleFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSaleFinishedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSaleFund\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSaleStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lPTokenAddress\",\"type\":\"address\"}],\"name\":\"recoverLpToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveLockContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vesting\",\"outputs\":[{\"internalType\":\"contract IVesting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"maxEthDeposit\",\"type\":\"uint256\"}],\"name\":\"whitelistUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"PublicSale","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c86817249634ac209bc73fca1712bbd75e37407d0000000000000000000000001d03c395c491a4fbf737a1b8f57eec086b38cfef0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}