{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-04-26\r\n*/\r\n\r\n// File: contracts/utils/AddressArray.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\nlibrary AddressArray{\r\n  function exists(address[] memory self, address addr) public pure returns(bool){\r\n    for (uint i = 0; i< self.length;i++){\r\n      if (self[i]==addr){\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function index_of(address[] memory self, address addr) public pure returns(uint){\r\n    for (uint i = 0; i< self.length;i++){\r\n      if (self[i]==addr){\r\n        return i;\r\n      }\r\n    }\r\n    require(false, \"AddressArray:index_of, not exist\");\r\n  }\r\n\r\n  function remove(address[] storage self, address addr) public returns(bool){\r\n    uint index = index_of(self, addr);\r\n    self[index] = self[self.length - 1];\r\n\r\n    delete self[self.length-1];\r\n    self.length--;\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/utils/SafeMath.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"add\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"sub\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"mul\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"div\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/Ownable.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract Ownable {\r\n    address private _contract_owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = msg.sender;\r\n        _contract_owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _contract_owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_contract_owner, newOwner);\r\n        _contract_owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/assets/TokenBankInterface.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract TokenBankInterface{\r\n  function issue(address token_addr, address payable _to, uint _amount) public returns (bool success);\r\n}\r\n\r\n// File: contracts/ERC20SalaryV2.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC20SalaryV2 is Ownable{\r\n  using SafeMath for uint;\r\n  using AddressArray for address[];\r\n\r\n  struct employee_info{\r\n    uint salary;\r\n    uint period;\r\n    uint total;\r\n    uint claimed;\r\n    uint last_block_num;\r\n    uint pause_block_num;\r\n    address leader;\r\n    bool paused;\r\n    bool exists;\r\n  }\r\n\r\n  TokenBankInterface public erc20bank;\r\n  address public target_token;\r\n  string public token_name;\r\n  address[] public employee_accounts;\r\n  mapping (address => employee_info) public employee_infos;\r\n\r\n  event ClaimedSalary(address account, address to, uint amount);\r\n\r\n  constructor(string memory _name, address _target_token, address _erc20bank) public{\r\n    token_name = _name;\r\n    target_token = _target_token;\r\n    erc20bank = TokenBankInterface(_erc20bank);\r\n  }\r\n\r\n  function change_token_bank(address _addr) public onlyOwner{\r\n    require(_addr != address(0x0), \"invalid address\");\r\n    erc20bank = TokenBankInterface(_addr);\r\n  }\r\n\r\n  function unclaimed_amount() public view returns(uint){\r\n    uint total = 0;\r\n    for(uint i = 0; i < employee_accounts.length; ++i){\r\n      uint p = get_unclaimed_period(employee_accounts[i]);\r\n      uint t = employee_infos[employee_accounts[i]].total.safeSub(employee_infos[employee_accounts[i]].claimed);\r\n      uint s = employee_infos[employee_accounts[i]].salary;\r\n      total = total.safeAdd(p.safeMul(s));\r\n      total = total.safeAdd(t);\r\n    }\r\n    return total;\r\n  }\r\n\r\n  function add_employee(address account, uint last_block_num, uint period, uint salary, address leader)\r\n    public onlyOwner\r\n    returns(bool)\r\n    {\r\n      require(account != address(0));\r\n      require(last_block_num >0);\r\n      require(period > 0);\r\n      require(salary > 0);\r\n      require(leader != account, \"cannot be self leader\");\r\n      if(employee_infos[account].exists) return false;\r\n      _primitive_init_employee(account, last_block_num, 0, false, period, salary, 0, 0, leader);\r\n      return true;\r\n    }\r\n\r\n    function add_employee_with_meta(address account, uint last_block_num,\r\n                                    uint pause_block_num, bool paused, uint period,\r\n                                    uint salary, uint total, uint claimed, address leader)\r\n    public onlyOwner\r\n    returns(bool)\r\n      {\r\n      _primitive_init_employee(account, last_block_num, pause_block_num, paused, period, salary, total, claimed, leader);\r\n      return true;\r\n    }\r\n\r\n    function _primitive_init_employee(address account, uint last_block_num,\r\n                                     uint pause_block_num, bool paused, uint period,\r\n                                     uint salary, uint total, uint claimed, address leader) internal{\r\n      if(!employee_infos[account].exists) {\r\n        employee_accounts.push(account);\r\n      }\r\n\r\n      employee_infos[account].salary = salary;\r\n      employee_infos[account].period = period;\r\n      employee_infos[account].total = total;\r\n      employee_infos[account].claimed = claimed;\r\n      employee_infos[account].last_block_num = last_block_num;\r\n      employee_infos[account].pause_block_num = pause_block_num;\r\n      employee_infos[account].leader = leader;\r\n      employee_infos[account].paused = paused;\r\n      employee_infos[account].exists = true;\r\n    }\r\n\r\n    function remove_employee(address account) public onlyOwner{\r\n      _remove_employee(account);\r\n    }\r\n\r\n    function _remove_employee(address account) internal returns(bool){\r\n      if(!employee_infos[account].exists) return false;\r\n      employee_accounts.remove(account);\r\n      delete employee_infos[account];\r\n      return true;\r\n    }\r\n\r\n    function change_employee_period(address account, uint period) public onlyOwner{\r\n      require(employee_infos[account].exists);\r\n      _update_salary(account);\r\n      employee_infos[account].period = period;\r\n    }\r\n\r\n    function change_employee_salary(address account, uint salary) public onlyOwner{\r\n      require(employee_infos[account].exists);\r\n      _update_salary(account);\r\n      employee_infos[account].salary= salary;\r\n    }\r\n\r\n    function change_employee_leader(address account, address leader) public onlyOwner{\r\n      require(employee_infos[account].exists);\r\n      require(account != leader, \"account cannot be self leader\");\r\n      _update_salary(account);\r\n      employee_infos[account].leader = leader;\r\n    }\r\n\r\n    function change_employee_status(address account, bool pause) public onlyOwner{\r\n      require(employee_infos[account].exists);\r\n      require(employee_infos[account].paused != pause, \"status already done\");\r\n      _update_salary(account);\r\n      _change_employee_status(account, pause);\r\n    }\r\n\r\n    function _change_employee_status(address account, bool pause) internal {\r\n      employee_infos[account].paused = pause;\r\n      employee_infos[account].pause_block_num = (block.number - employee_infos[account].pause_block_num);\r\n    }\r\n\r\n    function change_subordinate_period(address account, uint period) public {\r\n      require(employee_infos[account].exists);\r\n      require(employee_infos[account].leader == msg.sender, \"not your subordinate\");\r\n      _update_salary(account);\r\n      employee_infos[account].period = period;\r\n    }\r\n    function change_subordinate_salary(address account, uint salary) public {\r\n      require(employee_infos[account].exists);\r\n      require(employee_infos[account].leader == msg.sender, \"not your subordinate\");\r\n\r\n      employee_infos[account].salary = salary;\r\n    }\r\n    function change_subordinate_status(address account, bool pause) public {\r\n      require(employee_infos[account].exists);\r\n      require(employee_infos[account].leader == msg.sender, \"not your subordinate\");\r\n      _update_salary(account);\r\n      _change_employee_status(account, pause);\r\n    }\r\n\r\n    function get_unclaimed_period(address account) public view returns(uint){\r\n      employee_info storage ei = employee_infos[account];\r\n      uint t = block.number.safeSub(ei.pause_block_num);\r\n      t = t.safeSub(ei.last_block_num).safeDiv(ei.period);\r\n      return t;\r\n    }\r\n    function _update_salary(address account) private {\r\n      employee_info storage ei = employee_infos[account];\r\n      if(ei.paused) return ;\r\n      uint p = get_unclaimed_period(account);\r\n      if(p == 0) return ;\r\n      ei.total = ei.total.safeAdd(p.safeMul(ei.salary));\r\n      ei.last_block_num = ei.last_block_num.safeAdd(p.safeMul(ei.period));\r\n    }\r\n\r\n    function update_salary(address account) public{\r\n      require(employee_infos[account].exists, \"not exist\");\r\n      _update_salary(account);\r\n    }\r\n\r\n    function claim_salary(address payable to, uint amount) public returns(bool){\r\n      require(employee_infos[msg.sender].exists, \"not exist\");\r\n      _update_salary(msg.sender);\r\n      employee_info storage ei = employee_infos[msg.sender];\r\n      require(ei.total.safeSub(ei.claimed) >= amount, \"no balance\");\r\n\r\n      ei.claimed  = ei.claimed.safeAdd(amount);\r\n      erc20bank.issue(target_token, to, amount);\r\n\r\n      emit ClaimedSalary(msg.sender, to, amount);\r\n      return true;\r\n    }\r\n\r\n    function get_employee_count() public view returns(uint){\r\n      return employee_accounts.length;\r\n    }\r\n\r\n    function get_employee_info_with_index(uint index) public view returns(uint salary, uint period, uint total, uint claimed, uint last_claim_block_num, uint paused_block_num, bool paused, address leader){\r\n      require(index >= 0 && index < employee_accounts.length);\r\n      address account = employee_accounts[index];\r\n      require(employee_infos[account].exists);\r\n      return get_employee_info_with_account(account);\r\n    }\r\n\r\n    function get_employee_info_with_account(address account) public view returns(uint salary, uint period, uint total,\r\n                                                                                 uint claimed, uint last_claim_block_num, uint paused_block_num, bool paused, address leader){\r\n      require(employee_infos[account].exists);\r\n      salary = employee_infos[account].salary;\r\n      period = employee_infos[account].period;\r\n      total = employee_infos[account].total;\r\n      claimed = employee_infos[account].claimed;\r\n      last_claim_block_num = employee_infos[account].last_block_num;\r\n      leader = employee_infos[account].leader;\r\n      paused = employee_infos[account].paused;\r\n      paused_block_num = employee_infos[account].pause_block_num;\r\n    }\r\n}\r\n\r\ncontract ERC20SalaryV2Factory{\r\n  event NewERC20Salary(address addr);\r\n  function createERC20SalaryV2(string memory name, address target_token, address erc20bank) public returns(address){\r\n    ERC20SalaryV2 salary = new ERC20SalaryV2(name, target_token, erc20bank);\r\n    emit NewERC20Salary(address(salary));\r\n    salary.transferOwnership(msg.sender);\r\n    return address(salary);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"target_token\",\"type\":\"address\"},{\"name\":\"erc20bank\",\"type\":\"address\"}],\"name\":\"createERC20SalaryV2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NewERC20Salary\",\"type\":\"event\"}]","ContractName":"ERC20SalaryV2Factory","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"SafeMath:071108ad85d7a766b41e0f5e5195537a8fc8e74d;AddressArray:d942f306075a0f7bc375328db822fcc3103b3268","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3a91bf4ba476bd76b06c718e9a219c66d2f23af0dfe1b0d622672353a5b9fef7"}]}