{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.1;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\npragma abicoder v2;\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Uniswap V3\r\ninterface ISwapRouter {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\r\n}\r\n\r\n\r\ninterface IAaveLendingPool {\r\n  function deposit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external;\r\n  function withdraw(\r\n    address asset,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n}\r\n\r\n// Full interface here: https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol\r\ninterface IUniswapSimple {\r\n        function WETH() external pure returns (address);\r\n        function swapTokensForExactTokens(\r\n                uint amountOut,\r\n                uint amountInMax,\r\n                address[] calldata path,\r\n                address to,\r\n                uint deadline\r\n        ) external returns (uint[] memory amounts);\r\n\tfunction swapExactTokensForTokens(\r\n\t\tuint amountIn,\r\n\t\tuint amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external returns (uint[] memory amounts);\r\n}\r\n\r\n// Decisions: will start with aave over compound (easier API - has `onBehalfOf`, referrals), compound can be added later if needed\r\n// uni v3 needs to be supported since it's proving that it's efficient and the router is different\r\ncontract WalletZapper {\r\n\tstruct Trade {\r\n\t\tIUniswapSimple router;\r\n\t\tuint amountIn;\r\n\t\tuint amountOutMin;\r\n\t\taddress[] path;\r\n\t\tbool wrap;\r\n\t}\r\n\tstruct DiversificationTrade {\r\n\t\taddress tokenOut;\r\n\t\tuint24 fee;\r\n\t\tuint allocPts;\r\n\t\tuint amountOutMin;\r\n\t\tbool wrap;\r\n\t}\r\n\r\n\taddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n\taddress public admin;\r\n\tmapping (address => bool) public allowedSpenders;\r\n\tIAaveLendingPool public lendingPool;\r\n\tuint16 aaveRefCode;\r\n\tconstructor(IAaveLendingPool _lendingPool, uint16 _aaveRefCode, address[] memory spenders) {\r\n\t\tadmin = msg.sender;\r\n\t\tlendingPool = _lendingPool;\r\n\t\taaveRefCode = _aaveRefCode;\r\n\t\tallowedSpenders[address(_lendingPool)] = true;\r\n\t\tfor (uint i=0; i!=spenders.length; i++) {\r\n\t\t\tallowedSpenders[spenders[i]] = true;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction approveMax(address token, address spender) external {\r\n\t\trequire(msg.sender == admin, \"NOT_ADMIN\");\r\n\t\trequire(allowedSpenders[spender], \"NOT_ALLOWED\");\r\n\t\tIERC20(token).approve(spender, type(uint256).max);\r\n\t}\r\n\r\n\t// Uniswap V2\r\n\t// We're choosing not to implement a special function for performing a single trade since it's not that much of a gas saving compared to this\r\n\t// We're also choosing not to implement a method like diversifyV3 which first trades the input asset to WETH and then WETH to whatever,\r\n\t//  because we expect diversifyV3 to be enough\r\n\t// We can very easily deploy a new Zapper and upgrade to it since it's just a UI change\r\n\tfunction exchangeV2(address[] calldata assetsToUnwrap, Trade[] memory trades) external {\r\n\t\tfor (uint i=0; i!=assetsToUnwrap.length; i++) {\r\n\t\t\tlendingPool.withdraw(assetsToUnwrap[i], type(uint256).max, address(this));\r\n\t\t}\r\n\t\taddress to = msg.sender;\r\n\t\tuint deadline = block.timestamp;\r\n\t\tuint len = trades.length;\r\n\t\tfor (uint i=0; i!=len; i++) {\r\n\t\t\tTrade memory trade = trades[i];\r\n\t\t\tif (!trade.wrap) {\r\n\t\t\t\ttrade.router.swapExactTokensForTokens(trade.amountIn, trade.amountOutMin, trade.path, to, deadline);\r\n\t\t\t} else {\r\n\t\t\t\tuint[] memory amounts = trade.router.swapExactTokensForTokens(trade.amountIn, trade.amountOutMin, trade.path, address(this), deadline);\r\n\t\t\t\tuint lastIdx = trade.path.length - 1;\r\n\t\t\t\tlendingPool.deposit(trade.path[lastIdx], amounts[lastIdx], to, aaveRefCode);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// @TODO are there ways to ensure there are no leftover funds?\r\n\r\n\t}\r\n\r\n\t// go in/out of lending assets\r\n\tfunction wrapLending(address[] calldata assetsToWrap) external {\r\n\t\tfor (uint i=0; i!=assetsToWrap.length; i++) {\r\n\t\t\tlendingPool.deposit(assetsToWrap[i], IERC20(assetsToWrap[i]).balanceOf(address(this)), msg.sender, aaveRefCode);\r\n\t\t}\r\n\t}\r\n\tfunction unwrapLending(address[] calldata assetsToUnwrap) external {\r\n\t\tfor (uint i=0; i!=assetsToUnwrap.length; i++) {\r\n\t\t\tlendingPool.withdraw(assetsToUnwrap[i], type(uint256).max, msg.sender);\r\n\t\t}\r\n\t}\r\n\r\n\t// wrap WETH\r\n\tfunction wrapETH() payable external {\r\n\t\t// TODO: it may be slightly cheaper to call deposit() directly\r\n\t\tpayable(WETH).transfer(msg.value);\r\n\t}\r\n\r\n\t// Uniswap V3\r\n\tfunction tradeV3(ISwapRouter uniV3Router, ISwapRouter.ExactInputParams calldata params) external returns (uint) {\r\n\t\treturn uniV3Router.exactInput(params);\r\n\t}\r\n\t\r\n\tfunction tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {\r\n\t\tISwapRouter.ExactInputSingleParams memory tradeParams = params;\r\n\t\taddress recipient = params.recipient;\r\n\t\tif(wrapOutputToLending) {\r\n\t\t\ttradeParams.recipient = address(this);\r\n\t\t}\r\n\r\n\t\tuint amountOut = uniV3Router.exactInputSingle(tradeParams);\r\n\t\tif(wrapOutputToLending) {\r\n\t\t\tlendingPool.deposit(params.tokenOut, amountOut, recipient, aaveRefCode);\r\n\t\t}\r\n\t\treturn amountOut;\r\n\t}\r\n\r\n\t// @TODO: unwrap input from aToken?\r\n\tfunction diversifyV3(ISwapRouter uniV3Router, address inputAsset, uint24 inputFee, uint inputMinOut, DiversificationTrade[] memory trades) external {\r\n\t\tuint inputAmount;\r\n\t\tif (inputAsset != address(0)) {\r\n\t\t\tinputAmount = uniV3Router.exactInputSingle(\r\n\t\t\t    ISwapRouter.ExactInputSingleParams (\r\n\t\t\t\tinputAsset,\r\n\t\t\t\tWETH,\r\n\t\t\t\tinputFee,\r\n\t\t\t\taddress(this),\r\n\t\t\t\tblock.timestamp,\r\n\t\t\t\tIERC20(inputAsset).balanceOf(address(this)),\r\n\t\t\t\tinputMinOut,\r\n\t\t\t\t0\r\n\t\t\t    )\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tinputAmount = IERC20(WETH).balanceOf(address(this));\r\n\t\t}\r\n\r\n\t\tuint totalAllocPts;\r\n\t\tuint len = trades.length;\r\n\t\tfor (uint i=0; i!=len; i++) {\r\n\t\t\tDiversificationTrade memory trade = trades[i];\r\n\t\t\ttotalAllocPts += trade.allocPts;\r\n\t\t\tif (!trade.wrap) {\r\n\t\t\t\tuniV3Router.exactInputSingle(\r\n\t\t\t\t    ISwapRouter.ExactInputSingleParams (\r\n\t\t\t\t\tWETH,\r\n\t\t\t\t\ttrade.tokenOut,\r\n\t\t\t\t\ttrade.fee,\r\n\t\t\t\t\tmsg.sender,\r\n\t\t\t\t\tblock.timestamp,\r\n\t\t\t\t\tinputAmount * trade.allocPts / 1000,\r\n\t\t\t\t\ttrade.amountOutMin,\r\n\t\t\t\t\t0\r\n\t\t\t\t    )\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\tuint amountToDeposit = uniV3Router.exactInputSingle(\r\n\t\t\t\t    ISwapRouter.ExactInputSingleParams (\r\n\t\t\t\t\tWETH,\r\n\t\t\t\t\ttrade.tokenOut,\r\n\t\t\t\t\ttrade.fee,\r\n\t\t\t\t\taddress(this),\r\n\t\t\t\t\tblock.timestamp,\r\n\t\t\t\t\tinputAmount * trade.allocPts / 1000,\r\n\t\t\t\t\ttrade.amountOutMin,\r\n\t\t\t\t\t0\r\n\t\t\t\t    )\r\n\t\t\t\t);\r\n\t\t\t\tlendingPool.deposit(trade.tokenOut, amountToDeposit, msg.sender, aaveRefCode);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tIERC20 wrappedETH = IERC20(WETH);\r\n\t\tuint wrappedETHAmount = wrappedETH.balanceOf(address(this));\r\n\t\t// NOTE: what if there is dust?\r\n\t\tif (wrappedETHAmount > 0) require(wrappedETH.transfer(msg.sender, wrappedETHAmount));\r\n\t\t// require(totalAllocPts == 1000, \"ALLOC_PTS\");\r\n\t}\r\n\r\n\tfunction recoverFunds(IERC20 token, uint amount) external {\r\n\t\trequire(msg.sender == admin, \"NOT_ADMIN\");\r\n\t\ttoken.transfer(admin, amount);\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAaveLendingPool\",\"name\":\"_lendingPool\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_aaveRefCode\",\"type\":\"uint16\"},{\"internalType\":\"address[]\",\"name\":\"spenders\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedSpenders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"uniV3Router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inputAsset\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"inputFee\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"inputMinOut\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"allocPts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrap\",\"type\":\"bool\"}],\"internalType\":\"struct WalletZapper.DiversificationTrade[]\",\"name\":\"trades\",\"type\":\"tuple[]\"}],\"name\":\"diversifyV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assetsToUnwrap\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"contract IUniswapSimple\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"wrap\",\"type\":\"bool\"}],\"internalType\":\"struct WalletZapper.Trade[]\",\"name\":\"trades\",\"type\":\"tuple[]\"}],\"name\":\"exchangeV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract IAaveLendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"uniV3Router\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapRouter.ExactInputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"tradeV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"uniV3Router\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct ISwapRouter.ExactInputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"wrapOutputToLending\",\"type\":\"bool\"}],\"name\":\"tradeV3Single\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assetsToUnwrap\",\"type\":\"address[]\"}],\"name\":\"unwrapLending\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assetsToWrap\",\"type\":\"address[]\"}],\"name\":\"wrapLending\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WalletZapper","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://918f555d916adbd7ba4ddff60857c0030c902d622e6eca66729d3b5225b3ff12"}]}