{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * WWWW.LADYLUCKCOIN.COM\r\n * \r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@&#*,(&@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&(,&@@&&@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@&@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@&@@%*(@@@@@@@&@@%(,...,,,.,,#%@@&@@@@@@@@@@@@@@@@&@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@&&(*&@&@&@@&**#@@&&@@@@@@@@@@@@@@@@@&&&@@@@@@@@@@&*,@&(,,@@\r\n * @@@@@@@@@&  .%@@@@@@%*(@&@&@&*(&@@@@@@@@&&*.(&@@@@@@@@@@@@@@@@@@@@@@@@&&*..@@@@@\r\n * @@@@@@@@@@&        .#@&@&&(#&@@@@@@@@&@.       &@@@@@@@@@@@@@@@@&@#@&@%*#@@@&@@@\r\n * @@@@@@@@@@@@%             #@@@@@@&@@@@.        &@@@@@@@@@@@@@@&&*  .&@@@@@@@@@@@\r\n * @@@@@@@@@@@@@(&((@#.            (&@@@@*        @@@@@@@@@@@&#    (@@&&@@@@@@@@@@@\r\n * @@@@@@@@@@@@&&      .(@@@@#,         (@      .&@@@@@@@%.     #&@@&@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@**&            ,%@@@&,    ,     .&&.       .&@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@&@**&@%#*%@@&@@@&%(*.   (@(            &&,%@@@&@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@&#*(@@@*             .,*(#*              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@  @@@@*@@(***(((##@@@@@@@.             *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@**@@@&*@@@@@@@@@@@@@@@@@@   %         (@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@**@@@&*@@@@@@@@@@@@@@@@@&  .@%       .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@**@@@@*@@@@@@@@@@@@@@@@*  #&&        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@**(@@@#*@@@@@@@@@@@@@@@@   @&         ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@**(@@@*#@@@@@@@@@@@@&@@  #@           *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@(**@&&@*(@@@@@@@@@@@@&*  @(            @&@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@&(**@@@@(*@@@@@@@@@@@@  (@(            *@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@&(**&@@@&*(@@@@@@@@@*  &@#             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@%(((@&@@%*(@@@@@@@  @@@%             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@&@(**(@&&&&((%&&@&@(&@@&             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@(***&@@@@&(((&@@&@&@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@#*(*(@@&@@@&(,,*#@,            @@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@&@@(****&@@@@@@@@@#      ..   .@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@&&*,,,,*&@@@@*      %.   *@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&*....        @.   (@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@(          @    (@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,            @@    (@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@&@@@#               %@,    (&@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@&@@@.                 @@@     ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@(                   &@@@,      @@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@&&.                  (&&&@&@&       &@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@&@@&@@@@@@@@@@@@@@@@&&&@@@@@@@@&@&@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@  ██╗░░░░░░█████╗░██████╗░██╗░░░██╗██╗░░░░░██╗░░░██╗░█████╗░██╗░░██╗ @@@@@@\r\n * @@@@@  ██║░░░░░██╔══██╗██╔══██╗╚██╗░██╔╝██║░░░░░██║░░░██║██╔══██╗██║░██╔╝ @@@@@@\r\n * @@@@@  ██║░░░░░███████║██║░░██║░╚████╔╝░██║░░░░░██║░░░██║██║░░╚═╝█████═╝░ @@@@@@\r\n * @@@@@  ██║░░░░░██╔══██║██║░░██║░░╚██╔╝░░██║░░░░░██║░░░██║██║░░██╗██╔═██╗░ @@@@@@\r\n * @@@@@  ███████╗██║░░██║██████╔╝░░░██║░░░███████╗╚██████╔╝╚█████╔╝██║░╚██╗ @@@@@@\r\n * @@@@@  ╚══════╝╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚══════╝░╚═════╝░░╚════╝░╚═╝░░╚═╝ @@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n *\r\n * SPDX-License-Identifier: MIT\r\n * \r\n */\r\n \r\npragma solidity ^0.8.0;\r\n                     \r\nabstract contract Initializable {\r\n\r\n    \r\n    bool private _initialized;\r\n\r\n    bool private _initializing;\r\n\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract VRFRequestIDBase {\r\n    \r\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\r\n    address _requester, uint256 _nonce)\r\n    internal pure returns (uint256)\r\n  {\r\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\r\n  }\r\n  \r\n  function makeRequestId(\r\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\r\n  }\r\n  \r\n}\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external view returns (string memory tokenName);\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\nlibrary SafeMathChainlink {\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\nabstract contract VRFConsumerBase is Initializable, VRFRequestIDBase {\r\n\r\n  using SafeMathChainlink for uint256;\r\n\r\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\r\n    internal virtual;\r\n\r\n  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\r\n    internal returns (bytes32 requestId)\r\n  {\r\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\r\n\r\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\r\n\r\n    nonces[_keyHash] = nonces[_keyHash].add(1);\r\n    return makeRequestId(_keyHash, vRFSeed);\r\n  }\r\n\r\n  LinkTokenInterface  internal LINK;\r\n  address  private vrfCoordinator;\r\n\r\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\r\n\r\n    function __VRFConsumerBase_init() internal initializer {\r\n        __VRFConsumerBase_init_unchained();\r\n    }\r\n    function __VRFConsumerBase_init_unchained() internal initializer {\r\n        vrfCoordinator = 0xf0d54349aDdcf704F77AE15b96510dEA15cb7952;\r\n        LINK = LinkTokenInterface(0x514910771AF9Ca656af840dff83E8264EcF986CA);\r\n    }\r\n\r\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\r\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\r\n    fulfillRandomness(requestId, randomness);\r\n  }\r\n\r\n}\r\n\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n\r\n    function __Context_init_unchained() internal initializer {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n    uint256[50] private __gap;\r\n}\r\n\r\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    function __Pausable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Pausable_init_unchained();\r\n    }\r\n\r\n    function __Pausable_init_unchained() internal initializer {\r\n        _paused = false;\r\n    }\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n    uint256[49] private __gap;\r\n}\r\n\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function __Ownable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal initializer {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n    uint256[49] private __gap;\r\n}\r\n\r\nlibrary MathUpgradeable {\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\nlibrary ArraysUpgradeable {\r\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\r\n        if (array.length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 low = 0;\r\n        uint256 high = array.length;\r\n\r\n        while (low < high) {\r\n            uint256 mid = MathUpgradeable.average(low, high);\r\n\r\n            if (array[mid] > element) {\r\n                high = mid;\r\n            } else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n\r\n        if (low > 0 && array[low - 1] == element) {\r\n            return low - 1;\r\n        } else {\r\n            return low;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary AddressUpgradeable {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20Upgradeable {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\r\n    \r\n    using ArraysUpgradeable for uint256[];\r\n    using AddressUpgradeable for address;\r\n    \r\n    mapping(address => bool) internal _isHolder;\r\n    mapping(uint256 => mapping(address => address)) internal _groupNextHolder;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    \r\n    mapping (address => uint256) internal  _balances;\r\n    mapping (uint256 => uint256) internal _groupHolders;\r\n    mapping (address => uint256) internal _addressGroup;\r\n    mapping (address => uint256) internal _weekLotto;  \r\n\r\n    uint256[] internal GroupIDList;\r\n\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n    \r\n    uint256 public ExchangeSupply;\r\n    uint256 public HoldersNum;    \r\n    uint256 public WeekCounter;\r\n\r\n    address public MegaPot;\r\n    address public LuckPot;\r\n    address public DevWallet;\r\n    address public MarketingWallet;\r\n    \r\n    address constant MOJO = address(1);\r\n\r\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\r\n        __Context_init_unchained();\r\n        __ERC20_init_unchained(name_, symbol_);\r\n    }\r\n\r\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        MarketingWallet = address(0x05dD722A8478715eC4ab7CDdecB82D598A313072);\r\n        MegaPot = address(0x83F9B450a5d71dC6CBeef6D8E7214181FAf5D41f);\r\n        LuckPot = address(0xc4e017a03Cee1F129E93052e6b150466102B3aF5);        \r\n        DevWallet = address(0x538Ca3c8ad2F0e50730E51D730b907ab993EC326); \r\n        \r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function EligibleSupply() public view virtual returns (uint256){\r\n        uint256 ExcludedSupply = _totalSupply - ExchangeSupply - balanceOf(MegaPot) - balanceOf(LuckPot) - balanceOf(DevWallet) - balanceOf(MarketingWallet); \r\n        return ExcludedSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        \r\n        if (_isHolder[account] && _weekLotto[account] < WeekCounter && account != DevWallet && account != MegaPot && account != LuckPot && account != MarketingWallet && !account.isContract()){\r\n            uint256 temp = _balances[account];\r\n            \r\n            uint256 WeekDelta = WeekCounter - _weekLotto[account];\r\n            temp = (temp * (99 ** WeekDelta))/(100** WeekDelta);\r\n            return temp;\r\n            \r\n        } else {\r\n            return _balances[account];\r\n        }\r\n    }\r\n \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n    \r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        \r\n        uint256 feeAmount =  amount/50;\r\n        uint256 gasAmount = amount/100;\r\n        \r\n        if (sender == MegaPot || sender == LuckPot || sender == DevWallet || sender == MarketingWallet || recipient == DevWallet || recipient == MegaPot || recipient == LuckPot || recipient == MarketingWallet) {\r\n            feeAmount = 0;\r\n            gasAmount = 0;\r\n        }        \r\n\r\n        uint256 senderBalance = balanceOf(sender);\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        \r\n        uint256 receiveAmount = amount - feeAmount - gasAmount;\r\n        \r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += receiveAmount;\r\n        _balances[MegaPot] += feeAmount;\r\n        _balances[MarketingWallet] += gasAmount;\r\n        \r\n        emit Transfer(sender, recipient, amount);\r\n        emit Transfer(sender, MegaPot, feeAmount);        \r\n        emit Transfer(sender, MarketingWallet, gasAmount);\r\n\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        \r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n        \r\n        \r\n        if(_totalSupply == 0){\r\n            _totalSupply += amount;\r\n        }\r\n        \r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");    \r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n\r\n\r\n        \r\n        _balances[account] = accountBalance - amount;\r\n        \r\n        if(account != MegaPot || account != LuckPot){\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function AddGroupHolder(address holder) internal {\r\n        if(_isHolder[holder] == false && holder != address(0) && holder != MegaPot && holder != LuckPot && holder != DevWallet && holder != MarketingWallet && !holder.isContract()){\r\n            \r\n            _isHolder[holder] = true;\r\n            \r\n            uint256 GroupNumber = 1;\r\n            while (_groupHolders[GroupNumber] >=750){\r\n                GroupNumber++;\r\n            }\r\n            \r\n            if(_groupNextHolder[GroupNumber][MOJO] == address(0)){\r\n                _groupNextHolder[GroupNumber][MOJO] = MOJO;\r\n                GroupIDList.push(GroupNumber);\r\n            }\r\n            _groupNextHolder[GroupNumber][holder] = _groupNextHolder[GroupNumber][MOJO];\r\n            _groupNextHolder[GroupNumber][MOJO] = holder;\r\n            \r\n            _addressGroup[holder] = GroupNumber;\r\n            _groupHolders[GroupNumber]++;\r\n            \r\n            HoldersNum++;\r\n            \r\n            _weekLotto[holder] = WeekCounter;\r\n\r\n        }\r\n    }\r\n    \r\n    function RemoveGroupHolder(address holder) internal {\r\n        if(_isHolder[holder] == true && holder != address(0) && holder != MegaPot && holder != LuckPot && holder != DevWallet && holder != MarketingWallet && !holder.isContract()){\r\n            \r\n            _isHolder[holder] = false;\r\n            \r\n            uint256 GroupNumber = _addressGroup[holder];\r\n            \r\n            address prevHolder = GetPrevHolder(holder);\r\n            \r\n            _groupNextHolder[GroupNumber][prevHolder] = _groupNextHolder[GroupNumber][holder];\r\n            _groupNextHolder[GroupNumber][holder] = address(0);\r\n\r\n            _addressGroup[holder] = 0;\r\n            _groupHolders[GroupNumber] = _groupHolders[GroupNumber] - 1;\r\n            \r\n            HoldersNum = HoldersNum - 1;\r\n            \r\n            \r\n            _weekLotto[holder] = 0;\r\n                        \r\n    }\r\n    }\r\n    \r\n    function GetPrevHolder(address holder) internal view returns(address){\r\n        \r\n        address currentAddress = MOJO;\r\n        uint256 GroupNumber = _addressGroup[holder];        \r\n        \r\n        while(_groupNextHolder[GroupNumber][currentAddress] != MOJO){\r\n            if(_groupNextHolder[GroupNumber][currentAddress] == holder){\r\n                return currentAddress;\r\n            }\r\n            currentAddress = _groupNextHolder[GroupNumber][currentAddress];\r\n        }\r\n        return address(0);\r\n    }\r\n    \r\n    function GetGroupHolders(uint256 GroupNumber) internal view returns (address[] memory){\r\n        address[] memory holders = new address[](_groupHolders[GroupNumber]);\r\n        address currentAddress = _groupNextHolder[GroupNumber][MOJO];\r\n        for(uint256 i = 0; currentAddress != MOJO; ++i){\r\n            holders[i] = currentAddress;\r\n            currentAddress = _groupNextHolder[GroupNumber][currentAddress];\r\n        }\r\n        return holders;\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {\r\n\r\n    if(to.isContract()){ExchangeSupply  =ExchangeSupply + amount;}\r\n    if(from.isContract()){ExchangeSupply =ExchangeSupply - amount;}\r\n    \r\n    _balances[from] = balanceOf(from);\r\n    _weekLotto[from] = WeekCounter;\r\n    _balances[to] - balanceOf(to);\r\n    _weekLotto[to] = WeekCounter;\r\n    \r\n    \r\n    if (from == address(0)) {\r\n      AddGroupHolder(to);\r\n      \r\n    } else if (to == address(0)) {\r\n      if (balanceOf(from) - amount == 0){RemoveGroupHolder(from);}\r\n      \r\n    } else {\r\n      AddGroupHolder(to);\r\n      if (balanceOf(from) - amount == 0){RemoveGroupHolder(from);}\r\n    }\r\n\r\n    }\r\n    uint256[45] private __gap;\r\n}\r\n\r\ncontract LadyLuck is Initializable, ERC20Upgradeable, OwnableUpgradeable, PausableUpgradeable, VRFConsumerBase  {\r\n    \r\n    bytes32 internal keyHash;\r\n    uint256 internal fee;\r\n    uint256 public randomResult;\r\n    \r\n    uint public LastJackpotTime;\r\n    uint public NextJackpotTime;\r\n    uint256 internal JackpotFreq;\r\n    \r\n    uint256 public JackpotStarted;  \r\n    uint256 internal PreviousRandomNumber;\r\n    uint256[] internal GroupBalanceList;\r\n    \r\n    uint256 internal WinningGroupMega; \r\n    address public WinningWalletMega;\r\n    uint256 public WinningNumberMega;\r\n\r\n    uint256 internal WinningGroupLuck;     \r\n    address public WinningWalletLuck;\r\n    uint256 public WinningNumberLuck;\r\n\r\n    uint256 internal RollingGroupTotal;    \r\n    \r\n    function initialize() public virtual initializer {\r\n        \r\n        __ERC20_init(\"Lady Luck\", \"LUCK\");\r\n        \r\n        __Context_init();\r\n        __Pausable_init();\r\n        __Ownable_init();\r\n    \r\n        __VRFConsumerBase_init();\r\n        \r\n        keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\r\n        fee = 2 * 10 ** 18; // 0.1 LINK        \r\n        \r\n        _mint(DevWallet, 1000000000 * 10 ** decimals());\r\n        WinningWalletMega = MegaPot;\r\n        WinningWalletLuck = LuckPot;\r\n        \r\n        JackpotFreq = 604000;//One Week;        \r\n        LastJackpotTime = block.timestamp;\r\n        NextJackpotTime = block.timestamp + JackpotFreq;   \r\n    }\r\n    \r\n    function distributeToken(address[] memory addresses, uint256 _value) public onlyOwner {\r\n\t    for( uint256 i=0;i<addresses.length;i++){\r\n\t        transfer(addresses[i], _value);\r\n\t    }\r\n\t}\r\n    \r\n    function PrepareLottery() public onlyOwner {\r\n        /////require(block.timestamp > NextJackpotTime);\r\n        uint256 NumberOfGroups = ShowGroupIDList().length;          \r\n        require(JackpotStarted < NumberOfGroups, \"Lottery Has Already Been Prepared\");\r\n        \r\n        JackpotStarted++;\r\n\r\n        if(JackpotStarted == 1){\r\n            _pause();\r\n            delete GroupBalanceList;\r\n            uint256 temp = GetTrueGroupBalance(JackpotStarted);\r\n            GroupBalanceList.push(temp);\r\n            RollingGroupTotal = temp;\r\n            \r\n        } else if(JackpotStarted <= NumberOfGroups){\r\n            uint256 temp = GetTrueGroupBalance(JackpotStarted);\r\n            GroupBalanceList.push(temp);\r\n            RollingGroupTotal += temp;\r\n        }\r\n        \r\n        if(JackpotStarted == NumberOfGroups){\r\n            PreviousRandomNumber = randomResult;\r\n            getRandomNumber(block.timestamp*block.difficulty);\r\n        }\r\n    }\r\n\r\n        \r\n    function RunLuckLottery() public onlyOwner {\r\n        uint256[] memory GroupIDList = ShowGroupIDList();  \r\n        require(JackpotStarted == GroupIDList.length, \"Please Prepare Lottery Or End Mega Lottery\");        \r\n        require(PreviousRandomNumber != randomResult, \"Please Wait For Chainlink To Provide The Random Number\");\r\n        \r\n        uint256 FirstRandomResult = uint256(keccak256(abi.encode(randomResult, 0)));\r\n        WinningNumberLuck = FirstRandomResult % RollingGroupTotal + 1;\r\n\r\n        uint256 i = 0;\r\n        WinningGroupLuck = 0;\r\n        uint256 RollingTotal = 0;        \r\n        while (WinningGroupLuck == 0){\r\n            uint256 CurrentGroupBalance = GroupBalanceList[i];\r\n            if (RollingTotal < WinningNumberLuck && WinningNumberLuck <= RollingTotal + CurrentGroupBalance){\r\n                WinningGroupLuck = GroupIDList[i];\r\n            } else {\r\n                RollingTotal += CurrentGroupBalance;\r\n            }\r\n            i++;\r\n        }\r\n\r\n        address[] memory GroupWinnerList = GetGroupHolders(WinningGroupLuck);\r\n        \r\n        for (uint j=0; j<GroupWinnerList.length; j++) {\r\n            uint256 CurrentUserBalance = balanceOf(GroupWinnerList[j]);\r\n            if (RollingTotal < WinningNumberLuck && WinningNumberLuck <= RollingTotal + CurrentUserBalance){\r\n                  WinningWalletLuck = GroupWinnerList[j];\r\n            }\r\n            RollingTotal += CurrentUserBalance; \r\n        }\r\n        JackpotStarted++;\r\n    }\r\n    \r\n    \r\n    function RunMegaLottery() public onlyOwner {\r\n\r\n        uint256[] memory GroupIDList = ShowGroupIDList(); \r\n        require(JackpotStarted == GroupIDList.length + 1, \"Please Prepare Lottery & End Luck Lottery\");\r\n\r\n        uint256 SecondRandomResult = uint256(keccak256(abi.encode(randomResult, 1)));\r\n        WinningNumberMega = SecondRandomResult % RollingGroupTotal + 1;\r\n        \r\n        uint256 i = 0;\r\n        WinningGroupMega = 0;\r\n        uint256 RollingTotal = 0;        \r\n        while (WinningGroupMega == 0){\r\n            uint256 CurrentGroupBalance = GroupBalanceList[i];\r\n            if (RollingTotal < WinningNumberMega && WinningNumberMega <= RollingTotal + CurrentGroupBalance){\r\n                WinningGroupMega = GroupIDList[i];\r\n            } else {\r\n                RollingTotal += CurrentGroupBalance;\r\n            }\r\n            i++;\r\n        }\r\n        \r\n        address[] memory GroupWinnerList = GetGroupHolders(WinningGroupMega);\r\n        \r\n        for (uint j=0; j<GroupWinnerList.length; j++) {\r\n            uint256 CurrentUserBalance = balanceOf(GroupWinnerList[j]);\r\n            if (RollingTotal < WinningNumberMega && WinningNumberMega <= RollingTotal + CurrentUserBalance){\r\n                  WinningWalletMega = GroupWinnerList[j];\r\n            }\r\n            RollingTotal += CurrentUserBalance; \r\n        }\r\n        \r\n        WeekCounter++;\r\n        \r\n        _unpause();\r\n        \r\n        uint256 MegaPotBalance = balanceOf(MegaPot);\r\n        _burn(MegaPot, MegaPotBalance);\r\n        _mint(WinningWalletMega, MegaPotBalance);\r\n\r\n        _mint(LuckPot, RollingGroupTotal/100);\r\n    \r\n        LastJackpotTime = block.timestamp;\r\n        NextJackpotTime = LastJackpotTime + JackpotFreq;\r\n\r\n        JackpotStarted = 0;\r\n    }\r\n    \r\n    function PayLuckWinner() public onlyOwner {\r\n        uint256 LuckPotBalance = balanceOf(LuckPot);\r\n        _burn(LuckPot, LuckPotBalance);\r\n        _mint(WinningWalletLuck, LuckPotBalance);\r\n\r\n    }\r\n    \r\n    function GetTrueGroupBalance(uint256 Groups) internal view returns(uint256){\r\n        uint256 Temp; \r\n        address[] memory TempList = GetGroupHolders(Groups); \r\n        for (uint j=0; j<TempList.length; j++) {\r\n            Temp += balanceOf(TempList[j]);\r\n        }\r\n        return Temp;\r\n    }    \r\n    \r\n    function ShowGroupIDList() internal view virtual returns(uint256[] memory){\r\n        return GroupIDList;\r\n    }\r\n\r\n    function CurrentTime() public view virtual returns (uint){\r\n        return block.timestamp;\r\n    }     \r\n    \r\n    function ChangeLotteryFreq(uint256 Freq) public onlyOwner {\r\n        JackpotFreq = Freq;\r\n    }\r\n    \r\n    function ResetLotteryStarted() public onlyOwner {\r\n        JackpotStarted = 0;\r\n    }\r\n    \r\n    function CurrentMegaPotSize() public view returns(uint256){\r\n        return balanceOf(MegaPot);\r\n    }    \r\n    \r\n    function CurrentLuckPotSize() public view returns(uint256){\r\n        return balanceOf(LuckPot);\r\n    }       \r\n    \r\n     function getRandomNumber(uint256 userProvidedSeed) internal returns (bytes32 requestId) {\r\n        require(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK - fill contract with faucet\");\r\n        return requestRandomness(keyHash, fee, userProvidedSeed);\r\n    }\r\n\r\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\r\n        randomResult = randomness;\r\n    }\r\n\r\n    function withdrawLink() public onlyOwner {\r\n        require(LINK.transfer(msg.sender, LINK.balanceOf(address(this))), \"Unable to transfer\");\r\n    }   \r\n    \r\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\r\n        internal\r\n        whenNotPaused\r\n        override(ERC20Upgradeable)\r\n    {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n    }\r\n        \r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }    \r\n\r\n    function pause() public onlyOwner{\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner{\r\n        _unpause();\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Freq\",\"type\":\"uint256\"}],\"name\":\"ChangeLotteryFreq\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentLuckPotSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentMegaPotSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DevWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EligibleSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ExchangeSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HoldersNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"JackpotStarted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LastJackpotTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LuckPot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MegaPot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NextJackpotTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PayLuckWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PrepareLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ResetLotteryStarted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RunLuckLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RunMegaLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WeekCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WinningNumberLuck\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WinningNumberMega\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WinningWalletLuck\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WinningWalletMega\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"distributeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LadyLuck","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ef94cabeab7fa9b05013e6f7c230cadfe458f3dac9a2d784ed5029bb6325db9f"}]}