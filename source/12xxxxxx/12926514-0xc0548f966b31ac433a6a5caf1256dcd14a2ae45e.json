{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/options/OilerOptionsRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/drafts/IERC20Permit.sol\\\";\\n\\nimport {IOilerRegistry} from \\\"./interfaces/IOilerRegistry.sol\\\";\\nimport {IOilerOptionBase} from \\\"./interfaces/IOilerOptionBase.sol\\\";\\nimport {IOilerOptionsRouter} from \\\"./interfaces/IOilerOptionsRouter.sol\\\";\\nimport {IBRouter} from \\\"./interfaces/IBRouter.sol\\\";\\nimport {IBPool} from \\\"./interfaces/IBPool.sol\\\";\\n\\ncontract OilerOptionsRouter is IOilerOptionsRouter {\\n    IOilerRegistry public immutable override registry;\\n    IBRouter public immutable override bRouter;\\n\\n    constructor(IOilerRegistry _registry, IBRouter _bRouter) {\\n        registry = _registry;\\n        bRouter = _bRouter;\\n    }\\n\\n    modifier onlyRegistry() {\\n        require(\\n            address(registry) == msg.sender,\\n            \\\"OilerOptionsRouter.setUnlimitedApprovals, only the registry can set an unlimited approval\\\"\\n        );\\n        _;\\n    }\\n\\n    function write(IOilerOptionBase _option, uint256 _amount) external override {\\n        _writeOnBehalfOf(_option, _amount);\\n    }\\n\\n    function writeAndAddLiquidity(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        uint256 _liquidityProviderCollateralAmount\\n    ) external override {\\n        _writeOnBehalfOfAndTransferWriterRights(_option, _amount);\\n        _addLiquidity(_option, _amount, _liquidityProviderCollateralAmount);\\n    }\\n\\n    // Permittable versions of the above:\\n\\n    /**\\n     * @notice permit signed deadline must be max uint.\\n     */\\n    function write(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        Permit calldata _permit\\n    ) external override {\\n        _writeOnBehalfOfAndTransferWriterRightsPermittable(_option, _amount, _permit);\\n    }\\n\\n    function writeAndAddLiquidity(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        uint256 _liquidityProviderCollateralAmount,\\n        Permit calldata _writeOnBehalfOfPermit,\\n        Permit calldata _liquidityAddPermit\\n    ) external override {\\n        _writePermittable(_option, _amount, _writeOnBehalfOfPermit);\\n        _addLiquidityPermittable(_option, _amount, _liquidityProviderCollateralAmount, _liquidityAddPermit);\\n    }\\n\\n    // Restricted functions: onlyRegistry\\n    // This is supposed to be called by the registry when new option is being registered\\n    function setUnlimitedApprovals(IOilerOptionBase _option) external override onlyRegistry {\\n        _option.collateralInstance().approve(address(_option), type(uint256).max);\\n\\n        _option.collateralInstance().approve(address(bRouter), type(uint256).max);\\n\\n        _option.approve(address(bRouter), type(uint256).max);\\n    }\\n\\n    // Internal functions below:\\n\\n    /// @dev writes options where:\\n    /// @dev 1. router receives the options\\n    /// @dev 2. router receives writer rights\\n    function _write(IOilerOptionBase _option, uint256 _amount) internal {\\n        require(\\n            _option.collateralInstance().transferFrom(msg.sender, address(this), _amount),\\n            \\\"OilerOptionsRouter.write, ERC20 transfer failed\\\"\\n        );\\n\\n        _option.write(_amount);\\n    }\\n\\n    /// @dev writes options where:\\n    /// @dev 1. original msg.sender receives the options\\n    /// @dev 2. router receives writer rights\\n    function _writeOnBehalfOf(IOilerOptionBase _option, uint256 _amount) internal {\\n        require(\\n            _option.collateralInstance().transferFrom(msg.sender, address(this), _amount),\\n            \\\"OilerOptionsRouter.write, ERC20 transfer failed\\\"\\n        );\\n\\n        _option.write(_amount, msg.sender);\\n    }\\n\\n    /// @dev writes options where:\\n    /// @dev 1. router receives the options\\n    /// @dev 2. original msg.sender receives writer rights\\n    /// @dev the options most likely will be added to LP and LP tokens will be sent back to msg.sender\\n    function _writeOnBehalfOfAndTransferWriterRights(IOilerOptionBase _option, uint256 _amount) internal {\\n        require(\\n            _option.collateralInstance().transferFrom(msg.sender, address(this), _amount),\\n            \\\"OilerOptionsRouter.write, ERC20 transfer failed\\\"\\n        );\\n\\n        _option.write(_amount, msg.sender, address(this));\\n    }\\n\\n    function _addLiquidity(\\n        IOilerOptionBase _option,\\n        uint256 _optionsAmount,\\n        uint256 _liquidityProviderCollateralAmount\\n    ) internal {\\n        require(\\n            _option.collateralInstance().transferFrom(msg.sender, address(this), _liquidityProviderCollateralAmount),\\n            \\\"OilerOptionsRouter:addLiquidity, ERC20 transfer failed\\\"\\n        );\\n        bRouter.addLiquidity(\\n            address(_option),\\n            address(_option.collateralInstance()),\\n            _optionsAmount,\\n            _liquidityProviderCollateralAmount\\n        );\\n\\n        // Transfer back to msg.sender returned tokens and LP tokens.\\n        require(\\n            _option.transfer(msg.sender, _option.balanceOf(address(this))),\\n            \\\"OilerOptionsRouter:addLiquidity, options return transfer failed\\\"\\n        );\\n\\n        require(\\n            _option.collateralInstance().transfer(msg.sender, _option.collateralInstance().balanceOf(address(this))),\\n            \\\"OilerOptionsRouter:addLiquidity, collateral return transfer failed\\\"\\n        );\\n\\n        IBPool pool = bRouter.getPoolByTokens(address(_option), address(_option.collateralInstance()));\\n\\n        require(\\n            pool.transfer(msg.sender, pool.balanceOf(address(this))),\\n            \\\"OilerOptionsRouter:addLiquidity, lbp tokens return failed\\\"\\n        );\\n    }\\n\\n    // TODO verify if is it ok that all 3 functions have same permit\\n\\n    // Permittable versions of the above:\\n    function _writeOnBehalfOfAndTransferWriterRightsPermittable(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        Permit memory _permit\\n    ) internal {\\n        IERC20Permit(address(_option.collateralInstance())).permit(\\n            msg.sender,\\n            address(this),\\n            _amount,\\n            type(uint256).max,\\n            _permit.v,\\n            _permit.r,\\n            _permit.s\\n        );\\n        _writeOnBehalfOfAndTransferWriterRights(_option, _amount);\\n    }\\n\\n    function _writeOnBehalfOfPermittable(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        Permit memory _permit\\n    ) internal {\\n        IERC20Permit(address(_option.collateralInstance())).permit(\\n            msg.sender,\\n            address(this),\\n            _amount,\\n            type(uint256).max,\\n            _permit.v,\\n            _permit.r,\\n            _permit.s\\n        );\\n        _writeOnBehalfOf(_option, _amount);\\n    }\\n\\n    function _writePermittable(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        Permit memory _permit\\n    ) internal {\\n        IERC20Permit(address(_option.collateralInstance())).permit(\\n            msg.sender,\\n            address(this),\\n            _amount,\\n            type(uint256).max,\\n            _permit.v,\\n            _permit.r,\\n            _permit.s\\n        );\\n        _write(_option, _amount);\\n    }\\n\\n    function _addLiquidityPermittable(\\n        IOilerOptionBase _option,\\n        uint256 _optionsAmount,\\n        uint256 _collateralAmount,\\n        Permit memory _permit\\n    ) internal {\\n        _option.collateralInstance().permit(\\n            msg.sender,\\n            address(this),\\n            _collateralAmount,\\n            type(uint256).max,\\n            _permit.v,\\n            _permit.r,\\n            _permit.s\\n        );\\n\\n        _addLiquidity(_option, _optionsAmount, _collateralAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/drafts/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IOilerRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"./IOilerOptionsRouter.sol\\\";\\n\\ninterface IOilerRegistry {\\n    function PUT() external view returns (uint256);\\n\\n    function CALL() external view returns (uint256);\\n\\n    function activeOptions(bytes32 _type) external view returns (address[2] memory);\\n\\n    function archivedOptions(bytes32 _type, uint256 _index) external view returns (address);\\n\\n    function optionTypes(uint256 _index) external view returns (bytes32);\\n\\n    function factories(bytes32 _optionType) external view returns (address);\\n\\n    function optionsRouter() external view returns (IOilerOptionsRouter);\\n\\n    function getOptionTypesLength() external view returns (uint256);\\n\\n    function getOptionTypeAt(uint256 _index) external view returns (bytes32);\\n\\n    function getArchivedOptionsLength(string memory _optionType) external view returns (uint256);\\n\\n    function getArchivedOptionsLength(bytes32 _optionType) external view returns (uint256);\\n\\n    function getOptionTypeFactory(string memory _optionType) external view returns (address);\\n\\n    function getAllArchivedOptionsOfType(string memory _optionType) external view returns (address[] memory);\\n\\n    function getAllArchivedOptionsOfType(bytes32 _optionType) external view returns (address[] memory);\\n\\n    function registerFactory(address factory) external;\\n\\n    function setOptionsTypeFactory(string memory _optionType, address _factory) external;\\n\\n    function registerOption(address _optionAddress, string memory _optionType) external;\\n\\n    function setOptionsRouter(IOilerOptionsRouter _optionsRouter) external;\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IOilerOptionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"@openzeppelin/contracts/drafts/IERC20Permit.sol\\\";\\nimport {IOilerCollateral} from \\\"./IOilerCollateral.sol\\\";\\n\\ninterface IOilerOptionBase is IERC20, IERC20Permit {\\n    function optionType() external view returns (string memory);\\n\\n    function collateralInstance() external view returns (IOilerCollateral);\\n\\n    function isActive() external view returns (bool active);\\n\\n    function hasExpired() external view returns (bool);\\n\\n    function hasBeenExercised() external view returns (bool);\\n\\n    function put() external view returns (bool);\\n\\n    function write(uint256 _amount) external;\\n\\n    function write(uint256 _amount, address _writer) external;\\n\\n    function write(\\n        uint256 _amount,\\n        address _writer,\\n        address _holder\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IOilerOptionsRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport \\\"./IOilerOptionBase.sol\\\";\\nimport \\\"./IOilerRegistry.sol\\\";\\nimport \\\"./IBRouter.sol\\\";\\n\\ninterface IOilerOptionsRouter {\\n    // TODO add expiration?\\n    struct Permit {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    function registry() external view returns (IOilerRegistry);\\n\\n    function bRouter() external view returns (IBRouter);\\n\\n    function setUnlimitedApprovals(IOilerOptionBase _option) external;\\n\\n    function write(IOilerOptionBase _option, uint256 _amount) external;\\n\\n    function write(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        Permit calldata _permit\\n    ) external;\\n\\n    function writeAndAddLiquidity(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        uint256 _liquidityProviderCollateralAmount\\n    ) external;\\n\\n    function writeAndAddLiquidity(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        uint256 _liquidityProviderCollateralAmount,\\n        Permit calldata _writePermit,\\n        Permit calldata _liquidityAddPermit\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IBRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport {IBPool} from \\\"./IBPool.sol\\\";\\n\\ninterface IBRouter {\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountA,\\n        uint256 amountB\\n    ) external returns (uint256 poolTokens);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 poolAmountIn\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline,\\n        uint256 maxPrice\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function getPoolByTokens(address tokenA, address tokenB) external view returns (IBPool pool);\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IBPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\ninterface IBPool {\\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        address tokenOut,\\n        uint256 minAmountOut,\\n        uint256 maxPrice\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amt\\n    ) external returns (bool);\\n\\n    function approve(address dst, uint256 amt) external returns (bool);\\n\\n    function transfer(address dst, uint256 amt) external returns (bool);\\n\\n    function balanceOf(address whom) external view returns (uint256);\\n\\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n    function finalize() external;\\n\\n    function rebind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) external;\\n\\n    function setSwapFee(uint256 swapFee) external;\\n\\n    function setPublicSwap(bool publicSwap) external;\\n\\n    function bind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) external;\\n\\n    function unbind(address token) external;\\n\\n    function gulp(address token) external;\\n\\n    function isBound(address token) external view returns (bool);\\n\\n    function getBalance(address token) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function getSwapFee() external view returns (uint256);\\n\\n    function isPublicSwap() external view returns (bool);\\n\\n    function getDenormalizedWeight(address token) external view returns (uint256);\\n\\n    function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function EXIT_FEE() external view returns (uint256);\\n\\n    function calcPoolOutGivenSingleIn(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 tokenAmountIn,\\n        uint256 swapFee\\n    ) external pure returns (uint256 poolAmountOut);\\n\\n    function calcSingleInGivenPoolOut(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 poolAmountOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountIn);\\n\\n    function calcSingleOutGivenPoolIn(\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 poolAmountIn,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountOut);\\n\\n    function calcPoolInGivenSingleOut(\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 tokenAmountOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 poolAmountIn);\\n\\n    function getCurrentTokens() external view returns (address[] memory tokens);\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IOilerCollateral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"@openzeppelin/contracts/drafts/IERC20Permit.sol\\\";\\n\\ninterface IOilerCollateral is IERC20, IERC20Permit {\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IOilerRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract IBRouter\",\"name\":\"_bRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"bRouter\",\"outputs\":[{\"internalType\":\"contract IBRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IOilerRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOilerOptionBase\",\"name\":\"_option\",\"type\":\"address\"}],\"name\":\"setUnlimitedApprovals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOilerOptionBase\",\"name\":\"_option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"write\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOilerOptionBase\",\"name\":\"_option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IOilerOptionsRouter.Permit\",\"name\":\"_permit\",\"type\":\"tuple\"}],\"name\":\"write\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOilerOptionBase\",\"name\":\"_option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityProviderCollateralAmount\",\"type\":\"uint256\"}],\"name\":\"writeAndAddLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOilerOptionBase\",\"name\":\"_option\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityProviderCollateralAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IOilerOptionsRouter.Permit\",\"name\":\"_writeOnBehalfOfPermit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IOilerOptionsRouter.Permit\",\"name\":\"_liquidityAddPermit\",\"type\":\"tuple\"}],\"name\":\"writeAndAddLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OilerOptionsRouter","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000fd1b4e26e2aeba6f791f650108ff942fc3e3c0ae0000000000000000000000007ff9cf6c137df7cc813e6d9963ae607b698a1c75","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}