{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/ReserveAuctionV3_flat.sol\r\n\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n      * - `from` cannot be the zero address.\r\n      * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n// File: interfaces/IMarket.sol\r\n\r\n\r\n/**\r\n * @title Math\r\n *\r\n * Library for non-standard Math functions\r\n * NOTE: This file is a clone of the dydx protocol's Decimal.sol contract.\r\n * It was forked from https://github.com/dydxprotocol/solo at commit\r\n * 2d8454e02702fe5bc455b848556660629c3cad36. It has not been modified other than to use a\r\n * newer solidity in the pragma to match the rest of the contract suite of this project.\r\n */\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256) {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /*\r\n     * Return target * (numerator / denominator), but rounded up.\r\n     */\r\n    function getPartialRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256) {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    function to128(uint256 number) internal pure returns (uint128) {\r\n        uint128 result = uint128(number);\r\n        require(result == number, \"Math: Unsafe cast to uint128\");\r\n        return result;\r\n    }\r\n\r\n    function to96(uint256 number) internal pure returns (uint96) {\r\n        uint96 result = uint96(number);\r\n        require(result == number, \"Math: Unsafe cast to uint96\");\r\n        return result;\r\n    }\r\n\r\n    function to32(uint256 number) internal pure returns (uint32) {\r\n        uint32 result = uint32(number);\r\n        require(result == number, \"Math: Unsafe cast to uint32\");\r\n        return result;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n/**\r\n * NOTE: This file is a clone of the dydx protocol's Decimal.sol contract. It was forked from https://github.com/dydxprotocol/solo\r\n * at commit 2d8454e02702fe5bc455b848556660629c3cad36\r\n *\r\n * It has not been modified other than to use a newer solidity in the pragma to match the rest of the contract suite of this project\r\n */\r\n/*\r\n * @title Decimal\r\n *\r\n * Library that defines a fixed-point number with 18 decimal places.\r\n */\r\nlibrary Decimal {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant BASE_POW = 18;\r\n    uint256 constant BASE = 10**BASE_POW;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct D256 {\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function one() internal pure returns (D256 memory) {\r\n        return D256({value: BASE});\r\n    }\r\n\r\n    function onePlus(D256 memory d) internal pure returns (D256 memory) {\r\n        return D256({value: d.value.add(BASE)});\r\n    }\r\n\r\n    function mul(uint256 target, D256 memory d)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Math.getPartial(target, d.value, BASE);\r\n    }\r\n\r\n    function div(uint256 target, D256 memory d)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Math.getPartial(target, BASE, d.value);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Interface for Zora Protocol's Market\r\n */\r\ninterface IMarket {\r\n    struct Bid {\r\n        // Amount of the currency being bid\r\n        uint256 amount;\r\n        // Address to the ERC20 token being used to bid\r\n        address currency;\r\n        // Address of the bidder\r\n        address bidder;\r\n        // Address of the recipient\r\n        address recipient;\r\n        // % of the next sale to award the current owner\r\n        Decimal.D256 sellOnShare;\r\n    }\r\n\r\n    struct Ask {\r\n        // Amount of the currency being asked\r\n        uint256 amount;\r\n        // Address to the ERC20 token being asked\r\n        address currency;\r\n    }\r\n\r\n    struct BidShares {\r\n        // % of sale value that goes to the _previous_ owner of the nft\r\n        Decimal.D256 prevOwner;\r\n        // % of sale value that goes to the original creator of the nft\r\n        Decimal.D256 creator;\r\n        // % of sale value that goes to the seller (current owner) of the nft\r\n        Decimal.D256 owner;\r\n    }\r\n\r\n    event BidCreated(uint256 indexed tokenId, Bid bid);\r\n    event BidRemoved(uint256 indexed tokenId, Bid bid);\r\n    event BidFinalized(uint256 indexed tokenId, Bid bid);\r\n    event AskCreated(uint256 indexed tokenId, Ask ask);\r\n    event AskRemoved(uint256 indexed tokenId, Ask ask);\r\n    event BidShareUpdated(uint256 indexed tokenId, BidShares bidShares);\r\n\r\n    function bidForTokenBidder(uint256 tokenId, address bidder)\r\n        external\r\n        view\r\n        returns (Bid memory);\r\n\r\n    function currentAskForToken(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Ask memory);\r\n\r\n    function bidSharesForToken(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (BidShares memory);\r\n\r\n    function isValidBid(uint256 tokenId, uint256 bidAmount)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function isValidBidShares(BidShares calldata bidShares)\r\n        external\r\n        pure\r\n        returns (bool);\r\n\r\n    function splitShare(Decimal.D256 calldata sharePercentage, uint256 amount)\r\n        external\r\n        pure\r\n        returns (uint256);\r\n\r\n    function configure(address mediaContractAddress) external;\r\n\r\n    function setBidShares(uint256 tokenId, BidShares calldata bidShares)\r\n        external;\r\n\r\n    function setAsk(uint256 tokenId, Ask calldata ask) external;\r\n\r\n    function removeAsk(uint256 tokenId) external;\r\n\r\n    function setBid(\r\n        uint256 tokenId,\r\n        Bid calldata bid,\r\n        address spender\r\n    ) external;\r\n\r\n    function removeBid(uint256 tokenId, address bidder) external;\r\n\r\n    function acceptBid(uint256 tokenId, Bid calldata expectedBid) external;\r\n}\r\n\r\n// File: contracts/ReentrancyGuard.sol\r\n\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev counter to allow mutex lock with only one SSTORE operation\r\n  uint256 private _guardCounter = 1;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one `nonReentrant` function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and an `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    _guardCounter += 1;\r\n    uint256 localCounter = _guardCounter;\r\n    _;\r\n    require(localCounter == _guardCounter);\r\n  }\r\n\r\n}\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/ReserveAuctionV3.sol\r\n\r\n// OpenZeppelin library for performing math operations without overflows.\r\n\r\n// OpenZeppelin security library for preventing reentrancy attacks.\r\n\r\n// For interacting with Zora's Market contract.\r\n\r\n// For checking `supportsInterface`.\r\n\r\n// For interacting with NFT tokens.\r\n\r\n\r\ncontract IMediaModified {\r\n    mapping(uint256 => address) public tokenCreators;\r\n    address public marketContract;\r\n}\r\n\r\ncontract ReserveAuctionV3 is ReentrancyGuard {\r\n    // Use OpenZeppelin's SafeMath library to prevent overflows.\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    // The minimum amount of time left in an auction after a new bid is created; 15 min.\r\n    uint16 public constant TIME_BUFFER = 900;\r\n    // The ETH needed above the current bid for a new bid to be valid; 0.001 ETH.\r\n    uint8 public constant MIN_BID_INCREMENT_PERCENT = 10;\r\n    // Interface constant for ERC721, to check values in constructor.\r\n    bytes4 private constant ERC721_INTERFACE_ID = 0x80ac58cd;\r\n    // Allows external read `getVersion()` to return a version for the auction.\r\n    uint256 private constant RESERVE_AUCTION_VERSION = 1;\r\n\r\n    // ============ Immutable Storage ============\r\n\r\n    // The address of the ERC721 contract for tokens auctioned via this contract.\r\n    address public immutable nftContract;\r\n    // The address of the WETH contract, so that ETH can be transferred via\r\n    // WETH if native ETH transfers fail.\r\n    address public immutable wethAddress;\r\n    // The address that initially is able to recover assets.\r\n    address public immutable adminRecoveryAddress;\r\n\r\n    // ============ Mutable Storage ============\r\n\r\n    /**\r\n     * To start, there will be an admin account that can recover funds\r\n     * if anything goes wrong. Later, this public flag will be irrevocably\r\n     * set to false, removing any admin privileges forever.\r\n     *\r\n     * To check if admin recovery is enabled, call the public function `adminRecoveryEnabled()`.\r\n     */\r\n    bool private _adminRecoveryEnabled;\r\n    /**\r\n     * The account `adminRecoveryAddress` can also pause the contracts\r\n     * while _adminRecoveryEnabled is enabled. This prevents people from using\r\n     * the contract if there is a known problem with it.\r\n     */\r\n    bool private _paused;\r\n\r\n    // A mapping of all of the auctions currently running.\r\n    mapping(uint256 => Auction) public auctions;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Auction {\r\n        // The value of the current highest bid.\r\n        uint256 amount;\r\n        // The amount of time that the auction should run for,\r\n        // after the first bid was made.\r\n        uint256 duration;\r\n        // The time of the first bid.\r\n        uint256 firstBidTime;\r\n        // The minimum price of the first bid.\r\n        uint256 reservePrice;\r\n        uint8 curatorFeePercent;\r\n        // The address of the auction's curator. The curator\r\n        // can cancel the auction if it hasn't had a bid yet.\r\n        address curator;\r\n        // The address of the current highest bid.\r\n        address payable bidder;\r\n        // The address that should receive funds once the NFT is sold.\r\n        address payable fundsRecipient;\r\n    }\r\n\r\n    // ============ Events ============\r\n\r\n    // All of the details of a new auction,\r\n    // with an index created for the tokenId.\r\n    event AuctionCreated(\r\n        uint256 indexed tokenId,\r\n        address nftContractAddress,\r\n        uint256 duration,\r\n        uint256 reservePrice,\r\n        uint8 curatorFeePercent,\r\n        address curator,\r\n        address fundsRecipient\r\n    );\r\n\r\n    // All of the details of a new bid,\r\n    // with an index created for the tokenId.\r\n    event AuctionBid(\r\n        uint256 indexed tokenId,\r\n        address nftContractAddress,\r\n        address sender,\r\n        uint256 value\r\n    );\r\n\r\n    // All of the details of an auction's cancelation,\r\n    // with an index created for the tokenId.\r\n    event AuctionCanceled(\r\n        uint256 indexed tokenId,\r\n        address nftContractAddress,\r\n        address curator\r\n    );\r\n\r\n    // All of the details of an auction's close,\r\n    // with an index created for the tokenId.\r\n    event AuctionEnded(\r\n        uint256 indexed tokenId,\r\n        address nftContractAddress,\r\n        address curator,\r\n        address winner,\r\n        uint256 amount,\r\n        address nftCreator,\r\n        address payable fundsRecipient\r\n    );\r\n\r\n    // When the curator recevies fees, emit the details including the amount,\r\n    // with an index created for the tokenId.\r\n    event CuratorFeePercentTransfer(\r\n        uint256 indexed tokenId,\r\n        address curator,\r\n        uint256 amount\r\n    );\r\n\r\n    // Emitted in the case that the contract is paused.\r\n    event Paused(address account);\r\n    // Emitted when the contract is unpaused.\r\n    event Unpaused(address account);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    // Reverts if the sender is not admin, or admin\r\n    // functionality has been turned off.\r\n    modifier onlyAdminRecovery() {\r\n        require(\r\n            // The sender must be the admin address, and\r\n            // adminRecovery must be set to true.\r\n            adminRecoveryAddress == msg.sender && adminRecoveryEnabled(),\r\n            \"Caller does not have admin privileges\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // Reverts if the sender is not the auction's curator.\r\n    modifier onlyCurator(uint256 tokenId) {\r\n        require(\r\n            auctions[tokenId].curator == msg.sender,\r\n            \"Can only be called by auction curator\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // Reverts if the contract is paused.\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    // Reverts if the auction does not exist.\r\n    modifier auctionExists(uint256 tokenId) {\r\n        // The auction exists if the curator is not null.\r\n        require(!auctionCuratorIsNull(tokenId), \"Auction doesn't exist\");\r\n        _;\r\n    }\r\n\r\n    // Reverts if the auction exists.\r\n    modifier auctionNonExistant(uint256 tokenId) {\r\n        // The auction does not exist if the curator is null.\r\n        require(auctionCuratorIsNull(tokenId), \"Auction already exists\");\r\n        _;\r\n    }\r\n\r\n    // Reverts if the auction is expired.\r\n    modifier auctionNotExpired(uint256 tokenId) {\r\n        require(\r\n            // Auction is not expired if there's never been a bid, or if the\r\n            // current time is less than the time at which the auction ends.\r\n            auctions[tokenId].firstBidTime == 0 ||\r\n                block.timestamp < auctionEnds(tokenId),\r\n            \"Auction expired\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // Reverts if the auction is not complete.\r\n    // Auction is complete if there was a bid, and the time has run out.\r\n    modifier auctionComplete(uint256 tokenId) {\r\n        require(\r\n            // Auction is complete if there has been a bid, and the current time\r\n            // is greater than the auction's end time.\r\n            auctions[tokenId].firstBidTime > 0 &&\r\n                block.timestamp >= auctionEnds(tokenId),\r\n            \"Auction hasn't completed\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address nftContract_,\r\n        address wethAddress_,\r\n        address adminRecoveryAddress_\r\n    ) public {\r\n        require(\r\n            IERC165(nftContract_).supportsInterface(ERC721_INTERFACE_ID),\r\n            \"Contract at nftContract_ address does not support NFT interface\"\r\n        );\r\n        // Initialize immutable memory.\r\n        nftContract = nftContract_;\r\n        wethAddress = wethAddress_;\r\n        adminRecoveryAddress = adminRecoveryAddress_;\r\n        // Initialize mutable memory.\r\n        _paused = false;\r\n        _adminRecoveryEnabled = true;\r\n    }\r\n\r\n    // ============ Create Auction ============\r\n\r\n    function createAuction(\r\n        uint256 tokenId,\r\n        uint256 duration,\r\n        uint256 reservePrice,\r\n        uint8 curatorFeePercent,\r\n        address curator,\r\n        address payable fundsRecipient\r\n    ) external nonReentrant whenNotPaused auctionNonExistant(tokenId) {\r\n        // Check basic input requirements are reasonable.\r\n        require(curator != address(0));\r\n        require(fundsRecipient != address(0));\r\n        require(curatorFeePercent < 100, \"Curator fee should be < 100\");\r\n        // Initialize the auction details, including null values.\r\n        auctions[tokenId] = Auction({\r\n            duration: duration,\r\n            reservePrice: reservePrice,\r\n            curatorFeePercent: curatorFeePercent,\r\n            curator: curator,\r\n            fundsRecipient: fundsRecipient,\r\n            amount: 0,\r\n            firstBidTime: 0,\r\n            bidder: address(0)\r\n        });\r\n        // Transfer the NFT into this auction contract, from whoever owns it.\r\n        IERC721(nftContract).transferFrom(\r\n            IERC721(nftContract).ownerOf(tokenId),\r\n            address(this),\r\n            tokenId\r\n        );\r\n        // Emit an event describing the new auction.\r\n        emit AuctionCreated(\r\n            tokenId,\r\n            nftContract,\r\n            duration,\r\n            reservePrice,\r\n            curatorFeePercent,\r\n            curator,\r\n            fundsRecipient\r\n        );\r\n    }\r\n\r\n    // ============ Create Bid ============\r\n\r\n    function createBid(uint256 tokenId, uint256 amount)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        whenNotPaused\r\n        auctionExists(tokenId)\r\n        auctionNotExpired(tokenId)\r\n    {\r\n        // Validate that the user's expected bid value matches the ETH deposit.\r\n        require(amount == msg.value, \"Amount doesn't equal msg.value\");\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        // Check if the current bid amount is 0.\r\n        if (auctions[tokenId].amount == 0) {\r\n            // If so, it is the first bid.\r\n            auctions[tokenId].firstBidTime = block.timestamp;\r\n            // We only need to check if the bid matches reserve bid for the first bid,\r\n            // since future checks will need to be higher than any previous bid.\r\n            require(\r\n                amount >= auctions[tokenId].reservePrice,\r\n                \"Must bid reservePrice or more\"\r\n            );\r\n        } else {\r\n            // Check that the new bid is sufficiently higher than the previous bid, by\r\n            // the percentage defined as MIN_BID_INCREMENT_PERCENT.\r\n            require(\r\n                amount >=\r\n                    auctions[tokenId].amount.add(\r\n                        // Add 10% of the current bid to the current bid.\r\n                        auctions[tokenId]\r\n                            .amount\r\n                            .mul(MIN_BID_INCREMENT_PERCENT)\r\n                            .div(100)\r\n                    ),\r\n                \"Must bid more than last bid by MIN_BID_INCREMENT_PERCENT amount\"\r\n            );\r\n\r\n            // Refund the previous bidder.\r\n            transferETHOrWETH(\r\n                auctions[tokenId].bidder,\r\n                auctions[tokenId].amount\r\n            );\r\n        }\r\n        // Update the current auction.\r\n        auctions[tokenId].amount = amount;\r\n        auctions[tokenId].bidder = msg.sender;\r\n        // Compare the auction's end time with the current time plus the 15 minute extension,\r\n        // to see whether we're near the auctions end and should extend the auction.\r\n        if (auctionEnds(tokenId) < block.timestamp.add(TIME_BUFFER)) {\r\n            // We add onto the duration whenever time increment is required, so\r\n            // that the auctionEnds at the current time plus the buffer.\r\n            auctions[tokenId].duration += block.timestamp.add(TIME_BUFFER).sub(\r\n                auctionEnds(tokenId)\r\n            );\r\n        }\r\n        // Emit the event that a bid has been made.\r\n        emit AuctionBid(tokenId, nftContract, msg.sender, amount);\r\n    }\r\n\r\n    // ============ End Auction ============\r\n\r\n    function endAuction(uint256 tokenId)\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n        auctionComplete(tokenId)\r\n    {\r\n        // Store relevant auction data in memory for the life of this function.\r\n        address winner = auctions[tokenId].bidder;\r\n        uint256 amount = auctions[tokenId].amount;\r\n        address curator = auctions[tokenId].curator;\r\n        uint8 curatorFeePercent = auctions[tokenId].curatorFeePercent;\r\n        address payable fundsRecipient = auctions[tokenId].fundsRecipient;\r\n        // Remove all auction data for this token from storage.\r\n        delete auctions[tokenId];\r\n        // We don't use safeTransferFrom, to prevent reverts at this point,\r\n        // which would break the auction.\r\n        IERC721(nftContract).transferFrom(address(this), winner, tokenId);\r\n        // First handle the curator's fee.\r\n        if (curatorFeePercent > 0) {\r\n            // Determine the curator amount, which is some percent of the total.\r\n            uint256 curatorAmount = amount.mul(curatorFeePercent).div(100);\r\n            // Send it to the curator.\r\n            transferETHOrWETH(curator, curatorAmount);\r\n            // Subtract the curator amount from the total funds available\r\n            // to send to the funds recipient and original NFT creator.\r\n            amount = amount.sub(curatorAmount);\r\n            // Emit the details of the transfer as an event.\r\n            emit CuratorFeePercentTransfer(tokenId, curator, curatorAmount);\r\n        }\r\n        // Get the address of the original creator, so that we can split shares\r\n        // if appropriate.\r\n        address payable nftCreator =\r\n            payable(\r\n                address(IMediaModified(nftContract).tokenCreators(tokenId))\r\n            );\r\n        // If the creator and the recipient of the funds are the same\r\n        // (and we expect this to be common), we can just do one transaction.\r\n        if (nftCreator == fundsRecipient) {\r\n            transferETHOrWETH(nftCreator, amount);\r\n        } else {\r\n            // Otherwise, we should determine the percent that goes to the creator.\r\n            // Collect share data from Zora.\r\n            uint256 creatorAmount =\r\n                // Call the splitShare function on the market contract, which\r\n                // takes in a Decimal and an amount.\r\n                IMarket(IMediaModified(nftContract).marketContract())\r\n                    .splitShare(\r\n                    // Fetch the decimal from the BidShares data on the market.\r\n                    IMarket(IMediaModified(nftContract).marketContract())\r\n                        .bidSharesForToken(tokenId)\r\n                        .creator,\r\n                    // Specify the amount.\r\n                    amount\r\n                );\r\n            // Send the creator's share to the creator.\r\n            transferETHOrWETH(nftCreator, creatorAmount);\r\n            // Send the remainder of the amount to the funds recipient.\r\n            transferETHOrWETH(fundsRecipient, amount.sub(creatorAmount));\r\n        }\r\n        // Emit an event describing the end of the auction.\r\n        emit AuctionEnded(\r\n            tokenId,\r\n            nftContract,\r\n            curator,\r\n            winner,\r\n            amount,\r\n            nftCreator,\r\n            fundsRecipient\r\n        );\r\n    }\r\n\r\n    // ============ Cancel Auction ============\r\n\r\n    function cancelAuction(uint256 tokenId)\r\n        external\r\n        nonReentrant\r\n        auctionExists(tokenId)\r\n        onlyCurator(tokenId)\r\n    {\r\n        // Check that there hasn't already been a bid for this NFT.\r\n        require(\r\n            uint256(auctions[tokenId].firstBidTime) == 0,\r\n            \"Auction already started\"\r\n        );\r\n        // Pull the creator address before removing the auction.\r\n        address curator = auctions[tokenId].curator;\r\n        // Remove all data about the auction.\r\n        delete auctions[tokenId];\r\n        // Transfer the NFT back to the curator.\r\n        IERC721(nftContract).transferFrom(address(this), curator, tokenId);\r\n        // Emit an event describing that the auction has been canceled.\r\n        emit AuctionCanceled(tokenId, nftContract, curator);\r\n    }\r\n\r\n    // ============ Admin Functions ============\r\n\r\n    // Irrevocably turns off admin recovery.\r\n    function turnOffAdminRecovery() external onlyAdminRecovery {\r\n        _adminRecoveryEnabled = false;\r\n    }\r\n\r\n    function pauseContract() external onlyAdminRecovery {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function unpauseContract() external onlyAdminRecovery {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n\r\n    // Allows the admin to transfer any NFT from this contract\r\n    // to the recovery address.\r\n    function recoverNFT(uint256 tokenId) external onlyAdminRecovery {\r\n        IERC721(nftContract).transferFrom(\r\n            // From the auction contract.\r\n            address(this),\r\n            // To the recovery account.\r\n            adminRecoveryAddress,\r\n            // For the specified token.\r\n            tokenId\r\n        );\r\n    }\r\n\r\n    // Allows the admin to transfer any ETH from this contract to the recovery address.\r\n    function recoverETH(uint256 amount)\r\n        external\r\n        onlyAdminRecovery\r\n        returns (bool success)\r\n    {\r\n        // Attempt an ETH transfer to the recovery account, and return true if it succeeds.\r\n        success = attemptETHTransfer(adminRecoveryAddress, amount);\r\n    }\r\n\r\n    // ============ Miscellaneous Public and External ============\r\n\r\n    // Returns true if the contract is paused.\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    // Returns true if admin recovery is enabled.\r\n    function adminRecoveryEnabled() public view returns (bool) {\r\n        return _adminRecoveryEnabled;\r\n    }\r\n\r\n    // Returns the version of the deployed contract.\r\n    function getVersion() external pure returns (uint256 version) {\r\n        version = RESERVE_AUCTION_VERSION;\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    // Will attempt to transfer ETH, but will transfer WETH instead if it fails.\r\n    function transferETHOrWETH(address to, uint256 value) private {\r\n        // Try to transfer ETH to the given recipient.\r\n        if (!attemptETHTransfer(to, value)) {\r\n            // If the transfer fails, wrap and send as WETH, so that\r\n            // the auction is not impeded and the recipient still\r\n            // can claim ETH via the WETH contract (similar to escrow).\r\n            IWETH(wethAddress).deposit{value: value}();\r\n            IWETH(wethAddress).transfer(to, value);\r\n            // At this point, the recipient can unwrap WETH.\r\n        }\r\n    }\r\n\r\n    // Sending ETH is not guaranteed complete, and the method used here will return false if\r\n    // it fails. For example, a contract can block ETH transfer, or might use\r\n    // an excessive amount of gas, thereby griefing a new bidder.\r\n    // We should limit the gas used in transfers, and handle failure cases.\r\n    function attemptETHTransfer(address to, uint256 value)\r\n        private\r\n        returns (bool)\r\n    {\r\n        // Here increase the gas limit a reasonable amount above the default, and try\r\n        // to send ETH to the recipient.\r\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\r\n        (bool success, ) = to.call{value: value, gas: 30000}(\"\");\r\n        return success;\r\n    }\r\n\r\n    // Returns true if the auction's curator is set to the null address.\r\n    function auctionCuratorIsNull(uint256 tokenId) private view returns (bool) {\r\n        // The auction does not exist if the curator is the null address,\r\n        // since the NFT would not have been transferred in `createAuction`.\r\n        return auctions[tokenId].curator == address(0);\r\n    }\r\n\r\n    // Returns the timestamp at which an auction will finish.\r\n    function auctionEnds(uint256 tokenId) private view returns (uint256) {\r\n        // Derived by adding the auction's duration to the time of the first bid.\r\n        // NOTE: duration can be extended conditionally after each new bid is added.\r\n        return auctions[tokenId].firstBidTime.add(auctions[tokenId].duration);\r\n    }\r\n}\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\n// File: contracts/ABDKMath64x64.sol\r\n\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.5.0 || ^0.6.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /**\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /**\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    return int64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    require (x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    require (x >= 0);\r\n    return uint64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    int256 result = x >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    return int256 (x) << 64;\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) + y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) - y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    if (x == MIN_64x64) {\r\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n        y <= 0x1000000000000000000000000000000000000000000000000);\r\n      return -y << 63;\r\n    } else {\r\n      bool negativeResult = false;\r\n      if (x < 0) {\r\n        x = -x;\r\n        negativeResult = true;\r\n      }\r\n      if (y < 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint256 absoluteResult = mulu (x, uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult <=\r\n          0x8000000000000000000000000000000000000000000000000000000000000000);\r\n        return -int256 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult <=\r\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int256 (absoluteResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) return 0;\r\n\r\n    require (x >= 0);\r\n\r\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n    uint256 hi = uint256 (x) * (y >> 128);\r\n\r\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    hi <<= 64;\r\n\r\n    require (hi <=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n    return hi + lo;\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    int256 result = (int256 (x) << 64) / y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n\r\n    bool negativeResult = false;\r\n    if (x < 0) {\r\n      x = -x; // We rely on overflow behavior here\r\n      negativeResult = true;\r\n    }\r\n    if (y < 0) {\r\n      y = -y; // We rely on overflow behavior here\r\n      negativeResult = !negativeResult;\r\n    }\r\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    uint128 result = divuu (x, y);\r\n    require (result <= uint128 (MAX_64x64));\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return -x;\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return x < 0 ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    require (x != 0);\r\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    return int128 ((int256 (x) + int256 (y)) >> 1);\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 m = int256 (x) * int256 (y);\r\n    require (m >= 0);\r\n    require (m <\r\n        0x4000000000000000000000000000000000000000000000000000000000000000);\r\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    uint256 absoluteResult;\r\n    bool negativeResult = false;\r\n    if (x >= 0) {\r\n      absoluteResult = powu (uint256 (x) << 63, y);\r\n    } else {\r\n      // We rely on overflow behavior here\r\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\r\n      negativeResult = y & 1 > 0;\r\n    }\r\n\r\n    absoluteResult >>= 63;\r\n\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    require (x >= 0);\r\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    int256 msb = 0;\r\n    int256 xc = x;\r\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n    int256 result = msb - 64 << 64;\r\n    uint256 ux = uint256 (x) << 127 - msb;\r\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n      ux *= ux;\r\n      uint256 b = ux >> 255;\r\n      ux >>= 127 + b;\r\n      result += bit * int256 (b);\r\n    }\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    return int128 (\r\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    uint256 result = 0x80000000000000000000000000000000;\r\n\r\n    if (x & 0x8000000000000000 > 0)\r\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n    if (x & 0x4000000000000000 > 0)\r\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n    if (x & 0x2000000000000000 > 0)\r\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n    if (x & 0x1000000000000000 > 0)\r\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n    if (x & 0x800000000000000 > 0)\r\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n    if (x & 0x400000000000000 > 0)\r\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n    if (x & 0x200000000000000 > 0)\r\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n    if (x & 0x100000000000000 > 0)\r\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n    if (x & 0x80000000000000 > 0)\r\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n    if (x & 0x40000000000000 > 0)\r\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n    if (x & 0x20000000000000 > 0)\r\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n    if (x & 0x10000000000000 > 0)\r\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n    if (x & 0x8000000000000 > 0)\r\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n    if (x & 0x4000000000000 > 0)\r\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n    if (x & 0x2000000000000 > 0)\r\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n    if (x & 0x1000000000000 > 0)\r\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n    if (x & 0x800000000000 > 0)\r\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n    if (x & 0x400000000000 > 0)\r\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n    if (x & 0x200000000000 > 0)\r\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n    if (x & 0x100000000000 > 0)\r\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n    if (x & 0x80000000000 > 0)\r\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n    if (x & 0x40000000000 > 0)\r\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n    if (x & 0x20000000000 > 0)\r\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n    if (x & 0x10000000000 > 0)\r\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n    if (x & 0x8000000000 > 0)\r\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n    if (x & 0x4000000000 > 0)\r\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n    if (x & 0x2000000000 > 0)\r\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n    if (x & 0x1000000000 > 0)\r\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n    if (x & 0x800000000 > 0)\r\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n    if (x & 0x400000000 > 0)\r\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n    if (x & 0x200000000 > 0)\r\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n    if (x & 0x100000000 > 0)\r\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n    if (x & 0x80000000 > 0)\r\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n    if (x & 0x40000000 > 0)\r\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n    if (x & 0x20000000 > 0)\r\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n    if (x & 0x10000000 > 0)\r\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n    if (x & 0x8000000 > 0)\r\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n    if (x & 0x4000000 > 0)\r\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n    if (x & 0x2000000 > 0)\r\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n    if (x & 0x1000000 > 0)\r\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n    if (x & 0x800000 > 0)\r\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n    if (x & 0x400000 > 0)\r\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n    if (x & 0x200000 > 0)\r\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n    if (x & 0x100000 > 0)\r\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n    if (x & 0x80000 > 0)\r\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n    if (x & 0x40000 > 0)\r\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n    if (x & 0x20000 > 0)\r\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n    if (x & 0x10000 > 0)\r\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n    if (x & 0x8000 > 0)\r\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n    if (x & 0x4000 > 0)\r\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n    if (x & 0x2000 > 0)\r\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n    if (x & 0x1000 > 0)\r\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n    if (x & 0x800 > 0)\r\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n    if (x & 0x400 > 0)\r\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n    if (x & 0x200 > 0)\r\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n    if (x & 0x100 > 0)\r\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n    if (x & 0x80 > 0)\r\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n    if (x & 0x40 > 0)\r\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n    if (x & 0x20 > 0)\r\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n    if (x & 0x10 > 0)\r\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n    if (x & 0x8 > 0)\r\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n    if (x & 0x4 > 0)\r\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n    if (x & 0x2 > 0)\r\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n    if (x & 0x1 > 0)\r\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n    result >>= 63 - (x >> 64);\r\n    require (result <= uint256 (MAX_64x64));\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    return exp_2 (\r\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    require (y != 0);\r\n\r\n    uint256 result;\r\n\r\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      result = (x << 64) / y;\r\n    else {\r\n      uint256 msb = 192;\r\n      uint256 xc = x >> 192;\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 hi = result * (y >> 128);\r\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 xh = x >> 192;\r\n      uint256 xl = x << 64;\r\n\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n      lo = hi << 128;\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n\r\n      assert (xh == hi >> 128);\r\n\r\n      result += xl / y;\r\n    }\r\n\r\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\r\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 129.127-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return unsigned 129.127-bit fixed point number\r\n   */\r\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\r\n    if (y == 0) return 0x80000000000000000000000000000000;\r\n    else if (x == 0) return 0;\r\n    else {\r\n      int256 msb = 0;\r\n      uint256 xc = x;\r\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\r\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 xe = msb - 127;\r\n      if (xe > 0) x >>= xe;\r\n      else x <<= -xe;\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n      int256 re = 0;\r\n\r\n      while (y > 0) {\r\n        if (y & 1 > 0) {\r\n          result = result * x;\r\n          y -= 1;\r\n          re += xe;\r\n          if (result >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            result >>= 128;\r\n            re += 1;\r\n          } else result >>= 127;\r\n          if (re < -127) return 0; // Underflow\r\n          require (re < 128); // Overflow\r\n        } else {\r\n          x = x * x;\r\n          y >>= 1;\r\n          xe <<= 1;\r\n          if (x >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            x >>= 128;\r\n            xe += 1;\r\n          } else x >>= 127;\r\n          if (xe < -127) return 0; // Underflow\r\n          require (xe < 128); // Overflow\r\n        }\r\n      }\r\n\r\n      if (re > 0) result <<= re;\r\n      else if (re < 0) result >>= -re;\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\r\n    if (x == 0) return 0;\r\n    else {\r\n      require (r > 0);\r\n      while (true) {\r\n        uint256 rr = x / r;\r\n        if (r == rr || r + 1 == rr) return uint128 (r);\r\n        else if (r == rr + 1) return uint128 (rr);\r\n        r = r + rr + 1 >> 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n// File: contracts/PartyBidRA.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.8;\r\n\r\n// ============ Imports ============\r\n\r\n\r\n\r\n\r\n// ============ Interface declarations ============\r\n\r\n// Wrapped Ether\r\ninterface IWETH {\r\n  function deposit() external payable;\r\n  function approve(address guy, uint wad) external returns (bool);\r\n  function balanceOf(address src) external view returns (uint256);\r\n  function transferFrom(address src, address dst, uint256 wad) external returns (bool);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// IMedia (with bid acceptance extension)\r\ninterface IMediaExtended {\r\n  function acceptBid(uint256 tokenId, IMarket.Bid calldata bid) external;\r\n}\r\n\r\n// @dev: Must use wETH for all outgoing transactions, since returned capital from contract will\r\n//       always be wETH (due to hard 30,000 imposed gas limitation at ETH transfer layer).\r\ncontract PartyBid {\r\n  // Use OpenZeppelin library for SafeMath\r\n  using SafeMath for uint256;\r\n\r\n  // ============ Immutable storage ============\r\n\r\n  // Address of the Reserve Auction contract to place bid on\r\n  address public immutable ReserveAuctionV3Address;\r\n  // Address of the wETH contract\r\n  address public immutable wETHAddress;\r\n  // Address of the NFT contract\r\n  address public immutable NFTAddress;\r\n\r\n  // ============ Mutable storage ============\r\n\r\n  // ReserveAuctionV3 auctionID to bid on\r\n  uint256 public auctionID;\r\n  // Amount that DAO will bid for on ReserveAuctionV3 item\r\n  uint256 public bidAmount;\r\n  // Current amount raised to bid on ReserveAuctionV3 item\r\n  uint256 public currentRaisedAmount;\r\n  // Maximum time to wait for dao members to fill contract before enabling exit\r\n  uint256 public exitTimeout; \r\n  // Value received from accepted bid\r\n  uint256 public NFTResoldValue;\r\n  // Toggled when DAO places bid to purchase a ReserveAuctionV3 item\r\n  bool public bidPlaced;\r\n  // Toggled when DAO has resold won ReserveAuctionV3 item (to enable exit liquidity)\r\n  bool public NFTResold;\r\n  // Stakes of individual dao members\r\n  mapping (address => uint256) public daoStakes;\r\n  // List of active proposals to accept bids\r\n  BidProposal[] public BidProposals;\r\n  // List of supporters for each active bid proposal\r\n  mapping (uint256 => mapping (address => bool)) BidProposalSupporters;\r\n\r\n  // ============ Structs ============\r\n\r\n  // Individual bid proposals\r\n  struct BidProposal {\r\n    address proposer; // Proposing DAO member\r\n    address bidder; // Proposed bidder to accept bid from\r\n    uint256 amount; // Proposed bid amount\r\n    uint256 aggregateSupport; // sum(balance(voting_addresses_in_favor))\r\n  }\r\n\r\n  // ============ Modifiers ============\r\n  \r\n  // Reverts if the DAO has not won the NFT\r\n  modifier onlyIfAuctionWon() {\r\n    // Ensure that owner of NFT(auctionId) is contract address\r\n    require(IERC721(NFTAddress).ownerOf(auctionID) == address(this), \"PartyBid: DAO has not won auction.\");\r\n    _;\r\n  }\r\n\r\n  // ============ Events ============\r\n\r\n  // Address of a new DAO member and their entry share\r\n  event PartyJoined(address indexed member, uint256 value);\r\n  // Value of newly placed bid on ReserveAuctionV3 item\r\n  event PartyBidPlaced(uint256 auctionID, uint256 value);\r\n  // Address and exit share of DAO member, along with reason for exit\r\n  event PartyMemberExited(address indexed member, uint256 value, bool postFailure);\r\n  // Value of new proposal ID, proposer, Zora bidder, and Zora bidder bid amount\r\n  event PartyProposeNewZoraBid(uint256 indexed proposalId, address proposer, address bidder, uint256 amount);\r\n  // Value of proposal ID, and voter\r\n  event PartyProposalVote(uint256 indexed proposalId, address voter);\r\n  // Value of executed sale amount\r\n  event PartyExecuteSale(uint256 amount);\r\n\r\n  // ============ Constructor ============\r\n\r\n  constructor(\r\n    address _ReserveAuctionV3Address,\r\n    uint256 _auctionID,\r\n    uint256 _bidAmount,\r\n    uint256 _exitTimeout\r\n  ) public {\r\n    // Initialize immutable memory\r\n    ReserveAuctionV3Address = _ReserveAuctionV3Address;\r\n    wETHAddress = ReserveAuctionV3(_ReserveAuctionV3Address).wethAddress();\r\n    NFTAddress = ReserveAuctionV3(_ReserveAuctionV3Address).nftContract();\r\n\r\n    // Initialize mutable memory\r\n    auctionID = _auctionID;\r\n    bidAmount = _bidAmount;\r\n    currentRaisedAmount = 0;\r\n    exitTimeout = _exitTimeout;\r\n    bidPlaced = false;\r\n    NFTResold = false;\r\n  }\r\n\r\n  // ============ Join the DAO ============\r\n\r\n  /**\r\n   * Join the DAO by sending ETH\r\n   * Requires bidding to be enabled, forced matching of deposit value to sent eth, and there to be capacity in DAO\r\n   */\r\n  function join(uint256 _value) external payable {\r\n    // Dont allow joining once the bid has already been placed\r\n    require(bidPlaced == false, \"PartyBid: Cannot join since bid has been placed.\");\r\n    // Ensure matching of deposited value to ETH sent to contract\r\n    require(msg.value == _value, \"PartyBid: Deposit amount does not match spent ETH.\");\r\n    // Ensure sum(eth sent, current raised) <= required bid amount\r\n    require(_value.add(currentRaisedAmount) <= bidAmount, \"PartyBid: DAO does not have capacity.\");\r\n\r\n    currentRaisedAmount = currentRaisedAmount.add(_value); // Increment raised amount\r\n    daoStakes[msg.sender] = daoStakes[msg.sender].add(_value); // Track DAO member contribution\r\n\r\n    emit PartyJoined(msg.sender, _value); // Emit new DAO member\r\n  }\r\n\r\n  // ============ Place a bid from DAO ============\r\n\r\n  /**\r\n   * Execute bid placement, as DAO member, so long as required conditions are met\r\n   */\r\n  function placeBid() external {\r\n    // Dont allow placing a bid if already placed\r\n    require(bidPlaced == false, \"PartyBid: Bid has already been placed.\");\r\n    // Ensure that required bidAmount is matched with currently raised amount\r\n    require(bidAmount == currentRaisedAmount, \"PartyBid: Insufficient raised capital to place bid.\");\r\n    // Ensure that caller is a DAO member\r\n    require(daoStakes[msg.sender] > 0, \"PartyBid: Must be DAO member to initiate placing bid.\");\r\n\r\n    // Setup auction contract, place bid, toggle bidding status\r\n    ReserveAuctionV3 auction_contract = ReserveAuctionV3(ReserveAuctionV3Address);\r\n    auction_contract.createBid{value: bidAmount}(auctionID, bidAmount);\r\n    bidPlaced = true;\r\n\r\n    emit PartyBidPlaced(auctionID, bidAmount); // Emit bid placed\r\n  }\r\n\r\n  // ============ ReserveAuctionV3 NFT re-auctioning via Zora Market ============\r\n\r\n  /**\r\n   * Returns boolean status of if DAO has won NFT\r\n   */\r\n  function NFTWon() public view returns (bool) {\r\n    // Check if owner of NFT(auctionID) is contract address\r\n    return IERC721(NFTAddress).ownerOf(auctionID) == address(this);\r\n  }\r\n\r\n  /**\r\n   * Propose a new Zora bid for acceptance to the DAO\r\n   */\r\n  function DAOProposeZoraBid(address _bidder) external onlyIfAuctionWon() returns (uint256) {\r\n    // Collect Zora Bid\r\n    IMarket.Bid memory bid = IMarket(\r\n      // Collect Zora Market contract from IMedia storage\r\n      IMediaModified(NFTAddress).marketContract()\r\n    // Collect bid by bidder address\r\n    ).bidForTokenBidder(auctionID, _bidder);\r\n    \r\n    // Ensure that bid from bidder exists\r\n    require(bid.bidder == _bidder, \"PartyBid: Bidder does not have an active bid on NFT.\");\r\n    // Ensure that bid currency is Wrapped Ether\r\n    require(bid.currency == wETHAddress, \"PartyBid: Bidder has bid in a non-wETH token.\");\r\n    // Ensure that caller is a DAO member\r\n    require(daoStakes[msg.sender] > 0, \"PartyBid: Must be a DAO member to propose a new Zora bid.\");\r\n\r\n    // Collect proposalId from proposals array length\r\n    uint256 proposalId = BidProposals.length;\r\n\r\n    BidProposals.push(BidProposal(\r\n      msg.sender,\r\n      _bidder,\r\n      bid.amount,\r\n      // Existing aggregate support starts at power(proposer)\r\n      daoStakes[msg.sender]\r\n    ));\r\n\r\n    // Update supporters mapping\r\n    BidProposalSupporters[proposalId][msg.sender] = true;\r\n\r\n    emit PartyProposeNewZoraBid(proposalId, msg.sender, _bidder, bid.amount); // Emit new bid proposal\r\n    emit PartyProposalVote(proposalId, msg.sender); // Emit new vote for proposal (from proposal proposer themselves)\r\n\r\n    return proposalId;\r\n  }\r\n\r\n  /**\r\n   * Vote for a new Zora bid proposal if you have not already\r\n   */\r\n  function DAOVoteForZoraBidProposal(uint256 _proposalId) external onlyIfAuctionWon() {\r\n    // Ensure that caller is a DAO member\r\n    require(daoStakes[msg.sender] > 0, \"PartyBid: Must be a DAO member to vote for bid proposal.\");\r\n    // Ensure that caller has not already voted in favor of proposal\r\n    require(BidProposalSupporters[_proposalId][msg.sender] != true, \"PartyBid: Cannot vote for a proposal twice.\");\r\n\r\n    // Increment aggregate support with power(voter)\r\n    BidProposals[_proposalId].aggregateSupport = BidProposals[_proposalId].aggregateSupport.add(daoStakes[msg.sender]);\r\n\r\n    // Update supporters mapping\r\n    BidProposalSupporters[_proposalId][msg.sender] = true;\r\n\r\n    emit PartyProposalVote(_proposalId, msg.sender); // Emit new vote for proposal\r\n  }\r\n  \r\n  /**\r\n   * Execute a Zora bid proposal assuming it still exists and matches amount in storage\r\n   */\r\n  function DAOExecuteZoraBid(uint256 _proposalId) external onlyIfAuctionWon() {\r\n    // Ensure that caller is a DAO member\r\n    require(daoStakes[msg.sender] > 0, \"PartyBid: Must first be a DAO member to execute bid proposal.\");\r\n    // Ensure that the proposal being enacted has > 50% of supporting DAO vote\r\n    require(BidProposals[_proposalId].aggregateSupport > currentRaisedAmount.div(2), \"PartyBid: Insufficient support to accept Zora bid.\");\r\n\r\n    // Collect Bid from IMedia\r\n    IMarket.Bid memory bid = IMarket(IMediaModified(NFTAddress).marketContract()).bidForTokenBidder(auctionID, BidProposals[_proposalId].bidder);\r\n    \r\n    // Ensure that bid amount has not changed \r\n    require(BidProposals[_proposalId].amount == bid.amount, \"PartyBid: Bid amount has changed during proposal voting.\");\r\n\r\n    // Collect bidshares to calculate NFTResoldValue\r\n    IMarket.BidShares memory bidShares = IMarket(IMediaModified(NFTAddress).marketContract()).bidSharesForToken(auctionID);\r\n\r\n    // Accept bid from Imedia\r\n    IMediaExtended(NFTAddress).acceptBid(auctionID, bid);\r\n\r\n    // Update NFT price \r\n    NFTResold = true;\r\n    NFTResoldValue = ABDKMath64x64.mulu(\r\n      // Multiply the (bidShare of owner / total bidShare)\r\n      ABDKMath64x64.divu(bidShares.owner.value, 100000000000000000000),\r\n      // By the amount received through the bid\r\n      bid.amount\r\n    );\r\n\r\n    // Nullify proposal aggregate support to prevent resetting price via same proposal in future\r\n    BidProposals[_proposalId].aggregateSupport = 0;\r\n\r\n    emit PartyExecuteSale(NFTResoldValue); // Emit NFT sale price\r\n  }\r\n\r\n  // ============ Exit the DAO ============\r\n\r\n  /**\r\n   * Exit DAO if bid was won, and NFT was resold for NFTResoldValue\r\n   */\r\n  function _exitPostSale() internal {\r\n    // Require NFT to have already have been resold\r\n    require(NFTResold = true, \"PartyBid: NFT has not yet been resold.\");\r\n    // Failsafe: Ensure contract has non-zero funds to payout DAO members\r\n    require(IWETH(wETHAddress).balanceOf(address(this)) > 0, \"PartyBid: DAO is insolvent.\");\r\n    \r\n    // Send calculated share of NFTSalePrice based on DAO membership share\r\n    IWETH(wETHAddress).transferFrom(address(this), msg.sender,\r\n      // Multiply final NFT sale price\r\n      ABDKMath64x64.mulu(\r\n          // Multiply (dao_share / total)\r\n          ABDKMath64x64.divu(daoStakes[msg.sender], currentRaisedAmount),\r\n          // by final NFT sale price\r\n            NFTResoldValue)\r\n    );\r\n    emit PartyMemberExited(msg.sender, daoStakes[msg.sender], false); // Emit exit event\r\n\r\n    // Nullify member DAO share\r\n    daoStakes[msg.sender] = 0;\r\n  }\r\n  \r\n  /**\r\n   * Exit DAO if bid was beaten\r\n   * @dev Capital returned in form of wETH due to 30,000 gas transfer limit imposed by ReserveAuctionV3\r\n   */\r\n  function _exitIfBidFailed() internal {\r\n    // Dont allow exiting via this function if bid hasn't been placed\r\n    require(bidPlaced == true, \"PartyBid: Bid must be placed to exit via failure.\");\r\n    // Ensure that contract wETH balance is > 0 (implying that either funds have been returned or wETH airdropped)\r\n    require(IWETH(wETHAddress).balanceOf(address(this)) > 0, \"PartyBid: DAO bid has not been beaten or refunded yet.\");\r\n\r\n    // Transfer wETH from contract to DAO member and emit event\r\n    IWETH(wETHAddress).transferFrom(address(this), msg.sender, daoStakes[msg.sender]);\r\n    currentRaisedAmount = currentRaisedAmount.sub(daoStakes[msg.sender]);\r\n    emit PartyMemberExited(msg.sender, daoStakes[msg.sender], true); // Emit exit event\r\n\r\n    // Nullify member DAO share\r\n    daoStakes[msg.sender] = 0;\r\n  }\r\n\r\n  /**\r\n   * Exit DAO if deposit timeout has passed\r\n   */\r\n  function _exitIfTimeoutPassed() internal {\r\n    // Dont allow exiting via this function if bid has been placed\r\n    require(bidPlaced == false, \"PartyBid: Bid must be pending to exit via timeout.\");\r\n    // Ensure that current time > deposit timeout\r\n    require(block.timestamp >= exitTimeout, \"PartyBid: Exit timeout not met.\");\r\n\r\n    // Transfer ETH from contract to DAO member and emit event\r\n    payable(msg.sender).transfer(daoStakes[msg.sender]);\r\n    currentRaisedAmount = currentRaisedAmount.sub(daoStakes[msg.sender]);\r\n    emit PartyMemberExited(msg.sender, daoStakes[msg.sender], false); // Emit exit event\r\n\r\n    // Nullify member DAO share\r\n    daoStakes[msg.sender] = 0;\r\n  }\r\n\r\n  /**\r\n   * Public utility function to call internal exit functions based on bid state\r\n   */\r\n  function exit() external payable {\r\n    // Ensure that caller is a DAO member\r\n    require(daoStakes[msg.sender] > 0, \"PartyBid: Must first be a DAO member to exit DAO.\");\r\n\r\n    if (NFTResold) {\r\n      // If NFT has already been resold, allow post-sale exit\r\n      _exitPostSale();\r\n    } else {\r\n      if (bidPlaced) {\r\n        // If bid has been placed, allow exit on bid failure\r\n        _exitIfBidFailed();\r\n      } else {\r\n        // Else, allow exit when exit timeout window has passed\r\n        _exitIfTimeoutPassed();\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ReserveAuctionV3Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_auctionID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exitTimeout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PartyBidPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PartyExecuteSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PartyJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"postFailure\",\"type\":\"bool\"}],\"name\":\"PartyMemberExited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"PartyProposalVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PartyProposeNewZoraBid\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BidProposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aggregateSupport\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"DAOExecuteZoraBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bidder\",\"type\":\"address\"}],\"name\":\"DAOProposeZoraBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"DAOVoteForZoraBidProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFTResold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFTResoldValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFTWon\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReserveAuctionV3Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bidAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bidPlaced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRaisedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"daoStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"placeBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wETHAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PartyBid","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000835f86ff1670917a786b72d1fd8dcc385e27dd770000000000000000000000000000000000000000000000000000000000000b920000000000000000000000000000000000000000000000005ae6464beecf0000000000000000000000000000000000000000000000000000000000006091ee10","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b835724ec5c7844074534454c26c2c1c5c3e975bfec6d9497972dc4a4c03c880"}]}