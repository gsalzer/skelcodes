{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\r\\n// and modified it.\\r\\n\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        require(data.length == 0 || isContract(target));\\r\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // TODO: I think this does not lead to correct error messages.\\r\\n            revert(string(returndata));\\r\\n        }\\r\\n    }\\r\\n}\"},\"MultiSig.sol\":{\"content\":\"/**\\r\\n * SPDX-License-Identifier: MIT\\r\\n */\\r\\n\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./RLPEncode.sol\\\";\\r\\nimport \\\"./Nonce.sol\\\";\\r\\n\\r\\ncontract MultiSig is Nonce {\\r\\n\\r\\n  mapping (address =\\u003e uint8) public signers; // The addresses that can co-sign transactions and the number of signatures needed\\r\\n\\r\\n  uint16 public signerCount;\\r\\n  bytes public contractId; // most likely unique id of this contract\\r\\n\\r\\n  event SignerChange(\\r\\n    address indexed signer,\\r\\n    uint8 cosignaturesNeeded\\r\\n  );\\r\\n\\r\\n  event Transacted(\\r\\n    address indexed toAddress,  // The address the transaction was sent to\\r\\n    bytes4 selector, // selected operation\\r\\n    address[] signers // Addresses of the signers used to initiate the transaction\\r\\n  );\\r\\n\\r\\n  constructor (address owner) {\\r\\n    // We use the gas price to get a unique id into our transactions.\\r\\n    // Note that 32 bits do not guarantee that no one can generate a contract with the\\r\\n    // same id, but it practically rules out that someone accidentally creates two\\r\\n    // two multisig contracts with the same id, and that\\u0027s all we need to prevent\\r\\n    // replay-attacks.\\r\\n    contractId = toBytes(uint32(uint160(address(this))));\\r\\n    _setSigner(owner, 1); // set initial owner\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * It should be possible to store ether on this address.\\r\\n   */\\r\\n  receive() external payable {\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Checks if the provided signatures suffice to sign the transaction and if the nonce is correct.\\r\\n   */\\r\\n  function checkSignatures(uint128 nonce, address to, uint value, bytes calldata data,\\r\\n    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) public view returns (address[] memory) {\\r\\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);\\r\\n    return verifySignatures(transactionHash, v, r, s);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Checks if the execution of a transaction would succeed if it was properly signed.\\r\\n   */\\r\\n  function checkExecution(address to, uint value, bytes calldata data) public {\\r\\n    Address.functionCallWithValue(to, data, value);\\r\\n    require(false, \\\"Test passed. Reverting.\\\");\\r\\n  }\\r\\n\\r\\n  function execute(uint128 nonce, address to, uint value, bytes calldata data, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) public returns (bytes memory) {\\r\\n    bytes32 transactionHash = calculateTransactionHash(nonce, contractId, to, value, data);\\r\\n    address[] memory found = verifySignatures(transactionHash, v, r, s);\\r\\n    bytes memory returndata = Address.functionCallWithValue(to, data, value);\\r\\n    flagUsed(nonce);\\r\\n    emit Transacted(to, extractSelector(data), found);\\r\\n    return returndata;\\r\\n  }\\r\\n\\r\\n  function extractSelector(bytes calldata data) private pure returns (bytes4){\\r\\n    if (data.length \\u003c 4){\\r\\n      return bytes4(0);\\r\\n    } else {\\r\\n      return bytes4(data[0]) | (bytes4(data[1]) \\u003e\\u003e 8) | (bytes4(data[2]) \\u003e\\u003e 16) | (bytes4(data[3]) \\u003e\\u003e 24);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function toBytes(uint number) internal pure returns (bytes memory){\\r\\n    uint len = 0;\\r\\n    uint temp = 1;\\r\\n    while (number \\u003e= temp){\\r\\n      temp = temp \\u003c\\u003c 8;\\r\\n      len++;\\r\\n    }\\r\\n    temp = number;\\r\\n    bytes memory data = new bytes(len);\\r\\n    for (uint i = len; i\\u003e0; i--) {\\r\\n      data[i-1] = bytes1(uint8(temp));\\r\\n      temp = temp \\u003e\\u003e 8;\\r\\n    }\\r\\n    return data;\\r\\n  }\\r\\n\\r\\n  // Note: does not work with contract creation\\r\\n  function calculateTransactionHash(uint128 sequence, bytes memory id, address to, uint value, bytes calldata data)\\r\\n    internal view returns (bytes32){\\r\\n    bytes[] memory all = new bytes[](9);\\r\\n    all[0] = toBytes(sequence); // sequence number instead of nonce\\r\\n    all[1] = id; // contract id instead of gas price\\r\\n    all[2] = toBytes(21000); // gas limit\\r\\n    all[3] = abi.encodePacked(to);\\r\\n    all[4] = toBytes(value);\\r\\n    all[5] = data;\\r\\n    all[6] = toBytes(block.chainid);\\r\\n    all[7] = toBytes(0);\\r\\n    for (uint i = 0; i\\u003c8; i++){\\r\\n      all[i] = RLPEncode.encodeBytes(all[i]);\\r\\n    }\\r\\n    all[8] = all[7];\\r\\n    return keccak256(RLPEncode.encodeList(all));\\r\\n  }\\r\\n\\r\\n  function verifySignatures(bytes32 transactionHash, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s)\\r\\n    public view returns (address[] memory) {\\r\\n    address[] memory found = new address[](r.length);\\r\\n    for (uint i = 0; i \\u003c r.length; i++) {\\r\\n      address signer = ecrecover(transactionHash, v[i], r[i], s[i]);\\r\\n      uint8 cosignaturesNeeded = signers[signer];\\r\\n      require(cosignaturesNeeded \\u003e 0 \\u0026\\u0026 cosignaturesNeeded \\u003c= r.length, \\\"cosigner error\\\");\\r\\n      found[i] = signer;\\r\\n    }\\r\\n    requireNoDuplicates(found);\\r\\n    return found;\\r\\n  }\\r\\n\\r\\n  function requireNoDuplicates(address[] memory found) private pure {\\r\\n    for (uint i = 0; i \\u003c found.length; i++) {\\r\\n      for (uint j = i+1; j \\u003c found.length; j++) {\\r\\n        require(found[i] != found[j], \\\"duplicate signature\\\");\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Call this method through execute\\r\\n   */\\r\\n  function setSigner(address signer, uint8 cosignaturesNeeded) public authorized {\\r\\n    _setSigner(signer, cosignaturesNeeded);\\r\\n    require(signerCount \\u003e 0);\\r\\n  }\\r\\n\\r\\n  function migrate(address destination) public {\\r\\n    _migrate(msg.sender, destination);\\r\\n  }\\r\\n\\r\\n  function migrate(address source, address destination) public authorized {\\r\\n    _migrate(source, destination);\\r\\n  }\\r\\n\\r\\n  function _migrate(address source, address destination) private {\\r\\n    require(signers[destination] == 0); // do not overwrite existing signer!\\r\\n    _setSigner(destination, signers[source]);\\r\\n    _setSigner(source, 0);\\r\\n  }\\r\\n\\r\\n  function _setSigner(address signer, uint8 cosignaturesNeeded) private {\\r\\n    require(!Address.isContract(signer), \\\"signer cannot be a contract\\\");\\r\\n    uint8 prevValue = signers[signer];\\r\\n    signers[signer] = cosignaturesNeeded;\\r\\n    if (prevValue \\u003e 0 \\u0026\\u0026 cosignaturesNeeded == 0){\\r\\n      signerCount--;\\r\\n    } else if (prevValue == 0 \\u0026\\u0026 cosignaturesNeeded \\u003e 0){\\r\\n      signerCount++;\\r\\n    }\\r\\n    emit SignerChange(signer, cosignaturesNeeded);\\r\\n  }\\r\\n\\r\\n  modifier authorized() {\\r\\n    require(address(this) == msg.sender || signers[msg.sender] == 1, \\\"not authorized\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n}\"},\"Nonce.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\r\\n*\\r\\n* MIT License with Automated License Fee Payments\\r\\n*\\r\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\r\\n*\\r\\n* Permission is hereby granted to any person obtaining a copy of this software\\r\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\r\\n* without restriction, including without limitation the rights to use, copy,\\r\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\r\\n* Software, and to permit persons to whom the Software is furnished to do so,\\r\\n* subject to the following conditions:\\r\\n*\\r\\n* - The above copyright notice and this permission notice shall be included in\\r\\n*   all copies or substantial portions of the Software.\\r\\n* - All automated license fee payments integrated into this and related Software\\r\\n*   are preserved.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n* SOFTWARE.\\r\\n*/\\r\\n\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\ncontract Nonce {\\r\\n\\r\\n    uint256 public constant MAX_INCREASE = 100;\\r\\n    \\r\\n    uint256 private compound;\\r\\n    \\r\\n    constructor(){\\r\\n        setBoth(128, 0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * The next recommended nonce, which is the highest nonce ever used plus one.\\r\\n     */\\r\\n    function nextNonce() public view returns (uint256){\\r\\n        return getMax() + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns whether the provided nonce can be used.\\r\\n     * For the 100 nonces in the interval [nextNonce(), nextNonce + 99], this is always true.\\r\\n     * For the nonces in the interval [nextNonce() - 129, nextNonce() - 1], this is true for the nonces that have not been used yet.\\r\\n     */ \\r\\n    function isFree(uint128 nonce) public view returns (bool){\\r\\n        uint128 max = getMax();\\r\\n        return isValidHighNonce(max, nonce) || isValidLowNonce(max, getRegister(), nonce);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Flags the given nonce as used.\\r\\n     * Reverts if the provided nonce is not free.\\r\\n     */\\r\\n    function flagUsed(uint128 nonce) internal {\\r\\n        uint256 comp = compound;\\r\\n        uint128 max = uint128(comp);\\r\\n        uint128 reg = uint128(comp \\u003e\\u003e 128);\\r\\n        if (isValidHighNonce(max, nonce)){\\r\\n            setBoth(nonce, ((reg \\u003c\\u003c 1) | 0x1) \\u003c\\u003c (nonce - max - 1));\\r\\n        } else if (isValidLowNonce(max, reg, nonce)){\\r\\n            setBoth(max, uint128(reg | 0x1 \\u003c\\u003c (max - nonce - 1)));\\r\\n        } else {\\r\\n            require(false);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function getMax() private view returns (uint128) {\\r\\n        return uint128(compound);\\r\\n    }\\r\\n    \\r\\n    function getRegister() private view returns (uint128) {\\r\\n        return uint128(compound \\u003e\\u003e 128);\\r\\n    }\\r\\n    \\r\\n    function setBoth(uint128 max, uint128 reg) private {\\r\\n        compound = uint256(reg) \\u003c\\u003c 128 | max;\\r\\n    }\\r\\n\\r\\n    function isValidHighNonce(uint128 max, uint128 nonce) private pure returns (bool){\\r\\n        return nonce \\u003e max \\u0026\\u0026 nonce \\u003c= max + MAX_INCREASE;\\r\\n    }\\r\\n\\r\\n    function isValidLowNonce(uint128 max, uint128 reg, uint256 nonce) private pure returns (bool){\\r\\n        uint256 diff = max - nonce;\\r\\n        return diff \\u003e 0 \\u0026\\u0026 diff \\u003c= 128 \\u0026\\u0026 ((0x1 \\u003c\\u003c (diff - 1)) \\u0026 reg == 0);\\r\\n    }\\r\\n    \\r\\n}\"},\"RLPEncode.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.4.0;\\r\\n/**\\r\\n * @title RLPEncode\\r\\n * @dev A simple RLP encoding library.\\r\\n * @author Bakaoh\\r\\n */\\r\\nlibrary RLPEncode {\\r\\n    /*\\r\\n     * Internal functions\\r\\n     */\\r\\n\\r\\n    /**\\r\\n     * @dev RLP encodes a byte string.\\r\\n     * @param self The byte string to encode.\\r\\n     * @return The RLP encoded string in bytes.\\r\\n     */\\r\\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\\r\\n        bytes memory encoded;\\r\\n        if (self.length == 1 \\u0026\\u0026 uint8(self[0]) \\u003c= 128) {\\r\\n            encoded = self;\\r\\n        } else {\\r\\n            encoded = concat(encodeLength(self.length, 128), self);\\r\\n        }\\r\\n        return encoded;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev RLP encodes a list of RLP encoded byte byte strings.\\r\\n     * @param self The list of RLP encoded byte strings.\\r\\n     * @return The RLP encoded list of items in bytes.\\r\\n     */\\r\\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\\r\\n        bytes memory list = flatten(self);\\r\\n        return concat(encodeLength(list.length, 192), list);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev RLP encodes a string.\\r\\n     * @param self The string to encode.\\r\\n     * @return The RLP encoded string in bytes.\\r\\n     */\\r\\n    function encodeString(string memory self) internal pure returns (bytes memory) {\\r\\n        return encodeBytes(bytes(self));\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @dev RLP encodes an address.\\r\\n     * @param self The address to encode.\\r\\n     * @return The RLP encoded address in bytes.\\r\\n     */\\r\\n    function encodeAddress(address self) internal pure returns (bytes memory) {\\r\\n        bytes memory inputBytes;\\r\\n        assembly {\\r\\n            let m := mload(0x40)\\r\\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, self))\\r\\n            mstore(0x40, add(m, 52))\\r\\n            inputBytes := m\\r\\n        }\\r\\n        return encodeBytes(inputBytes);\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @dev RLP encodes a uint.\\r\\n     * @param self The uint to encode.\\r\\n     * @return The RLP encoded uint in bytes.\\r\\n     */\\r\\n    function encodeUint(uint self) internal pure returns (bytes memory) {\\r\\n        return encodeBytes(toBinary(self));\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @dev RLP encodes an int.\\r\\n     * @param self The int to encode.\\r\\n     * @return The RLP encoded int in bytes.\\r\\n     */\\r\\n    function encodeInt(int self) internal pure returns (bytes memory) {\\r\\n        return encodeUint(uint(self));\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @dev RLP encodes a bool.\\r\\n     * @param self The bool to encode.\\r\\n     * @return The RLP encoded bool in bytes.\\r\\n     */\\r\\n    function encodeBool(bool self) internal pure returns (bytes memory) {\\r\\n        bytes memory encoded = new bytes(1);\\r\\n        encoded[0] = (self ? bytes1(0x01) : bytes1(0x80));\\r\\n        return encoded;\\r\\n    }\\r\\n\\r\\n\\r\\n    /*\\r\\n     * Private functions\\r\\n     */\\r\\n\\r\\n    /**\\r\\n     * @dev Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\r\\n     * @param len The length of the string or the payload.\\r\\n     * @param offset 128 if item is string, 192 if item is list.\\r\\n     * @return RLP encoded bytes.\\r\\n     */\\r\\n    function encodeLength(uint len, uint offset) private pure returns (bytes memory) {\\r\\n        bytes memory encoded;\\r\\n        if (len \\u003c 56) {\\r\\n            encoded = new bytes(1);\\r\\n            encoded[0] = bytes32(len + offset)[31];\\r\\n        } else {\\r\\n            uint lenLen;\\r\\n            uint i = 1;\\r\\n            while (len / i != 0) {\\r\\n                lenLen++;\\r\\n                i *= 256;\\r\\n            }\\r\\n\\r\\n            encoded = new bytes(lenLen + 1);\\r\\n            encoded[0] = bytes32(lenLen + offset + 55)[31];\\r\\n            for(i = 1; i \\u003c= lenLen; i++) {\\r\\n                encoded[i] = bytes32((len / (256**(lenLen-i))) % 256)[31];\\r\\n            }\\r\\n        }\\r\\n        return encoded;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Encode integer in big endian binary form with no leading zeroes.\\r\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\r\\n     * @param _x The integer to encode.\\r\\n     * @return RLP encoded bytes.\\r\\n     */\\r\\n    function toBinary(uint _x) private pure returns (bytes memory) {\\r\\n        bytes memory b = new bytes(32);\\r\\n        assembly { \\r\\n            mstore(add(b, 32), _x) \\r\\n        }\\r\\n        uint i;\\r\\n        for (i = 0; i \\u003c 32; i++) {\\r\\n            if (b[i] != 0) {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        bytes memory res = new bytes(32 - i);\\r\\n        for (uint j = 0; j \\u003c res.length; j++) {\\r\\n            res[j] = b[i++];\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Copies a piece of memory to another location.\\r\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\r\\n     * @param _dest Destination location.\\r\\n     * @param _src Source location.\\r\\n     * @param _len Length of memory to copy.\\r\\n     */\\r\\n    function memcpy(uint _dest, uint _src, uint _len) private pure {\\r\\n        uint dest = _dest;\\r\\n        uint src = _src;\\r\\n        uint len = _len;\\r\\n\\r\\n        for(; len \\u003e= 32; len -= 32) {\\r\\n            assembly {\\r\\n                mstore(dest, mload(src))\\r\\n            }\\r\\n            dest += 32;\\r\\n            src += 32;\\r\\n        }\\r\\n\\r\\n        uint mask = 256 ** (32 - len) - 1;\\r\\n        assembly {\\r\\n            let srcpart := and(mload(src), not(mask))\\r\\n            let destpart := and(mload(dest), mask)\\r\\n            mstore(dest, or(destpart, srcpart))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Flattens a list of byte strings into one byte string.\\r\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\r\\n     * @param _list List of byte strings to flatten.\\r\\n     * @return The flattened byte string.\\r\\n     */\\r\\n    function flatten(bytes[] memory _list) private pure returns (bytes memory) {\\r\\n        if (_list.length == 0) {\\r\\n            return new bytes(0);\\r\\n        }\\r\\n\\r\\n        uint len;\\r\\n        uint i;\\r\\n        for (i = 0; i \\u003c _list.length; i++) {\\r\\n            len += _list[i].length;\\r\\n        }\\r\\n\\r\\n        bytes memory flattened = new bytes(len);\\r\\n        uint flattenedPtr;\\r\\n        assembly { flattenedPtr := add(flattened, 0x20) }\\r\\n\\r\\n        for(i = 0; i \\u003c _list.length; i++) {\\r\\n            bytes memory item = _list[i];\\r\\n            \\r\\n            uint listPtr;\\r\\n            assembly { listPtr := add(item, 0x20)}\\r\\n\\r\\n            memcpy(flattenedPtr, listPtr, item.length);\\r\\n            flattenedPtr += _list[i].length;\\r\\n        }\\r\\n\\r\\n        return flattened;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Concatenates two bytes.\\r\\n     * @notice From: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol.\\r\\n     * @param _preBytes First byte string.\\r\\n     * @param _postBytes Second byte string.\\r\\n     * @return Both byte string combined.\\r\\n     */\\r\\n    function concat(bytes memory _preBytes, bytes memory _postBytes) private pure returns (bytes memory) {\\r\\n        bytes memory tempBytes;\\r\\n\\r\\n        assembly {\\r\\n            tempBytes := mload(0x40)\\r\\n\\r\\n            let length := mload(_preBytes)\\r\\n            mstore(tempBytes, length)\\r\\n\\r\\n            let mc := add(tempBytes, 0x20)\\r\\n            let end := add(mc, length)\\r\\n\\r\\n            for {\\r\\n                let cc := add(_preBytes, 0x20)\\r\\n            } lt(mc, end) {\\r\\n                mc := add(mc, 0x20)\\r\\n                cc := add(cc, 0x20)\\r\\n            } {\\r\\n                mstore(mc, mload(cc))\\r\\n            }\\r\\n\\r\\n            length := mload(_postBytes)\\r\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\r\\n\\r\\n            mc := end\\r\\n            end := add(mc, length)\\r\\n\\r\\n            for {\\r\\n                let cc := add(_postBytes, 0x20)\\r\\n            } lt(mc, end) {\\r\\n                mc := add(mc, 0x20)\\r\\n                cc := add(cc, 0x20)\\r\\n            } {\\r\\n                mstore(mc, mload(cc))\\r\\n            }\\r\\n\\r\\n            mstore(0x40, and(\\r\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\r\\n              not(31)\\r\\n            ))\\r\\n        }\\r\\n\\r\\n        return tempBytes;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"cosignaturesNeeded\",\"type\":\"uint8\"}],\"name\":\"SignerChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"}],\"name\":\"Transacted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_INCREASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"checkExecution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"nonce\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"checkSignatures\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"nonce\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"nonce\",\"type\":\"uint128\"}],\"name\":\"isFree\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"cosignaturesNeeded\",\"type\":\"uint8\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signerCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"signers\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"verifySignatures\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MultiSig","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005a57dd9c623e1403af1d810673183d89724a4e0c","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5ef261705e8e767bd5c6edc929bf70cf6b20e89ae45816d8ce05f20ddece535e"}]}