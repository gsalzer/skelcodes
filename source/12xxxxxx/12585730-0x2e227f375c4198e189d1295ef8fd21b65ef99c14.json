{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.4;\r\ninterface ERC721\r\n{\r\n  event Transfer( address indexed _from, address indexed _to, uint256 indexed _tokenId );\r\n  event Approval( address indexed _owner, address indexed _approved, uint256 indexed _tokenId );\r\n  event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved );\r\n  function safeTransferFrom( address _from,  address _to, uint256 _tokenId, bytes calldata _data ) external;\r\n  function safeTransferFrom( address _from, address _to, uint256 _tokenId ) external;\r\n  function transferFrom( address _from, address _to, uint256 _tokenId ) external;\r\n  function approve( address _approved, uint256 _tokenId ) external;\r\n  function setApprovalForAll( address _operator, bool _approved ) external;\r\n  function balanceOf( address _owner ) external view returns (uint256);\r\n  function ownerOf( uint256 _tokenId ) external view returns (address);\r\n  function getApproved( uint256 _tokenId ) external view returns (address);\r\n  function isApprovedForAll( address _owner, address _operator ) external view returns (bool);\r\n}\r\ninterface ERC721Metadata\r\n{\r\n  function name() external view returns (string memory _name);\r\n  function symbol() external view returns (string memory _symbol);\r\n  function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\ninterface ERC721TokenReceiver\r\n{\r\n  function onERC721Received( address _operator, address _from, uint256 _tokenId, bytes calldata _data ) external returns(bytes4);\r\n}\r\ninterface ERC165\r\n{\r\n  function supportsInterface( bytes4 _interfaceID ) external view returns (bool);\r\n}\r\ncontract SupportsInterface is ERC165\r\n{\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n  constructor() { supportedInterfaces[0x01ffc9a7] = true; }\r\n  function supportsInterface( bytes4 _interfaceID ) external override view returns (bool) { return supportedInterfaces[_interfaceID]; }\r\n}\r\nlibrary AddressUtils\r\n{\r\n  function isContract( address _addr ) internal view returns (bool addressCheck) {\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\r\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\r\n  }\r\n}\r\ncontract NFToken is ERC721, SupportsInterface\r\n{\r\n  using AddressUtils for address;\r\n  string constant ZERO_ADDRESS = \"003001\";\r\n  string constant NOT_VALID_NFT = \"003002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"003003\";\r\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\r\n  string constant NFT_ALREADY_EXISTS = \"003006\";\r\n  string constant NOT_OWNER = \"003007\";\r\n  string constant IS_OWNER = \"003008\";\r\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n  mapping (uint256 => address) internal idToOwner;\r\n  mapping (uint256 => address) internal idToApproval;\r\n  mapping (address => uint256) private ownerToNFTokenCount;\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n  modifier canOperate( uint256 _tokenId ) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require( tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender], NOT_OWNER_OR_OPERATOR );\r\n    _;\r\n  }\r\n  modifier canTransfer( uint256 _tokenId ) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require( tokenOwner == msg.sender || idToApproval[_tokenId] == msg.sender || ownerToOperators[tokenOwner][msg.sender], NOT_OWNER_APPROVED_OR_OPERATOR );\r\n    _;\r\n  }\r\n  modifier validNFToken( uint256 _tokenId ) {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    _;\r\n  }\r\n  constructor() { supportedInterfaces[0x80ac58cd] = true; }\r\n  function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes calldata _data ) external override {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n  function safeTransferFrom( address _from, address _to, uint256 _tokenId ) external override {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n  function transferFrom( address _from, address _to, uint256 _tokenId ) external override canTransfer(_tokenId) validNFToken(_tokenId)  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    _transfer(_to, _tokenId);\r\n  }\r\n  function approve( address _approved, uint256 _tokenId ) external override canOperate(_tokenId) validNFToken(_tokenId) {\r\n  \taddress tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner, IS_OWNER);\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n  function setApprovalForAll( address _operator, bool _approved ) external override {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n  function balanceOf( address _owner ) external override view returns (uint256) {\r\n    require(_owner != address(0), ZERO_ADDRESS);\r\n    return _getOwnerNFTCount(_owner);\r\n  }\r\n  function ownerOf( uint256 _tokenId ) external override view returns (address _owner) {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n  function getApproved( uint256 _tokenId ) external override view validNFToken(_tokenId) returns (address) {\r\n    return idToApproval[_tokenId];\r\n  }\r\n  function isApprovedForAll( address _owner, address _operator ) external override view returns (bool) {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n  function _transfer( address _to, uint256 _tokenId ) internal {\r\n    address from = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n    _removeNFToken(from, _tokenId);\r\n    _addNFToken(_to, _tokenId);\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n  function _mint( address _to, uint256 _tokenId ) internal virtual {\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n    _addNFToken(_to, _tokenId);\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n  function _burn( uint256 _tokenId ) internal virtual validNFToken(_tokenId) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n    _removeNFToken(tokenOwner, _tokenId);\r\n    emit Transfer(tokenOwner, address(0), _tokenId);\r\n  }\r\n  function _removeNFToken( address _from, uint256 _tokenId ) internal virtual {\r\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n    ownerToNFTokenCount[_from] -= 1;\r\n    delete idToOwner[_tokenId];\r\n  }\r\n  function _addNFToken( address _to, uint256 _tokenId ) internal virtual {\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] += 1;\r\n  }\r\n  function _getOwnerNFTCount( address _owner ) internal virtual view returns (uint256) {\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n  function _safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes memory _data ) private canTransfer(_tokenId) validNFToken(_tokenId) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    _transfer(_to, _tokenId);\r\n    if (_to.isContract())    {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\r\n    }\r\n  }\r\n  function _clearApproval( uint256 _tokenId ) private { delete idToApproval[_tokenId]; }\r\n}\r\ncontract NFTokenMetadata is NFToken, ERC721Metadata {\r\n  string internal nftName;\r\n  string internal nftSymbol;\r\n  mapping (uint256 => string) internal idToUri;\r\n  constructor() { supportedInterfaces[0x5b5e139f] = true; }\r\n  function name() external override view returns (string memory _name) { _name = nftName; }\r\n  function symbol() external override view returns (string memory _symbol) { _symbol = nftSymbol; }\r\n  function tokenURI( uint256 _tokenId ) external override view validNFToken(_tokenId) returns (string memory) { return idToUri[_tokenId]; }\r\n  function _burn( uint256 _tokenId ) internal override virtual { super._burn(_tokenId); delete idToUri[_tokenId]; }\r\n  function _setTokenUri( uint256 _tokenId, string memory _uri ) internal validNFToken(_tokenId) { idToUri[_tokenId] = _uri; }\r\n}\r\ncontract OwnEnemy\r\n{\r\n  string public constant NOT_CURRENT_OWNER = \"018001\";\r\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \"018002\";\r\n  address public owner;\r\n  event OwnershipTransferred( address indexed previousOwner, address indexed newOwner );\r\n  constructor() { owner = msg.sender; }\r\n  modifier onlyOwner() { require(msg.sender == owner, NOT_CURRENT_OWNER); _; }\r\n  function transferOwnership( address _newOwner ) public onlyOwner {\r\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\ncontract InstaPayNFT is  NFTokenMetadata,  OwnEnemy {\r\n  constructor() { nftName = \"InstaPay NFT\"; nftSymbol = \"IPNFT\";  }\r\n  function mint( address _to, uint256 _tokenId, string calldata _uri ) external onlyOwner { super._mint(_to, _tokenId); super._setTokenUri(_tokenId, _uri); }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANNOT_TRANSFER_TO_ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NOT_CURRENT_OWNER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"InstaPayNFT","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ba7590259edcde115a5ac4ccd8d970e0f8aff38ba4cb3a316e12c57d6e691828"}]}