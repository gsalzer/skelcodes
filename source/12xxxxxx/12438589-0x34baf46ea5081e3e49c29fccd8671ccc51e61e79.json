{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ncontract ErrorReporter {\r\n    /**\r\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n     */\r\n    event Failure(uint256 error, uint256 info, uint256 detail);\r\n\r\n    enum Error {\r\n        NO_ERROR,\r\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\r\n        UNAUTHORIZED,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW,\r\n        DIVISION_BY_ZERO,\r\n        BAD_INPUT,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_TRANSFER_FAILED,\r\n        MARKET_NOT_SUPPORTED,\r\n        SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_RATE_CALCULATION_FAILED,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_OUT_FAILED,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INSUFFICIENT_BALANCE,\r\n        INVALID_COLLATERAL_RATIO,\r\n        MISSING_ASSET_PRICE,\r\n        EQUITY_INSUFFICIENT_BALANCE,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        ASSET_NOT_PRICED,\r\n        INVALID_LIQUIDATION_DISCOUNT,\r\n        INVALID_COMBINED_RISK_PARAMETERS\r\n    }\r\n\r\n    /**\r\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\r\n     *       This is because FailureInfo grows significantly faster, and\r\n     *       the order of Error has some meaning, while the order of FailureInfo\r\n     *       is entirely arbitrary.\r\n     */\r\n    enum FailureInfo {\r\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\r\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\r\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\r\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\r\n        BORROW_MARKET_NOT_SUPPORTED,\r\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\r\n        BORROW_TRANSFER_OUT_FAILED,\r\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\r\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\r\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\r\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\r\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\r\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\r\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\r\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\r\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\r\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\r\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\r\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\r\n        LIQUIDATE_TRANSFER_IN_FAILED,\r\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\r\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n        SET_ADMIN_OWNER_CHECK,\r\n        SET_ASSET_PRICE_CHECK_ORACLE,\r\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n        SET_ORACLE_OWNER_CHECK,\r\n        SET_ORIGINATION_FEE_OWNER_CHECK,\r\n        SET_RISK_PARAMETERS_OWNER_CHECK,\r\n        SET_RISK_PARAMETERS_VALIDATION,\r\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        SUPPLY_MARKET_NOT_SUPPORTED,\r\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        SUPPLY_TRANSFER_IN_FAILED,\r\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\r\n        SUPPORT_MARKET_OWNER_CHECK,\r\n        SUPPORT_MARKET_PRICE_CHECK,\r\n        SUSPEND_MARKET_OWNER_CHECK,\r\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\r\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\r\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\r\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\r\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        WITHDRAW_TRANSFER_OUT_FAILED,\r\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\r\n    }\r\n\r\n    /**\r\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n     */\r\n    function fail(Error err, FailureInfo info) internal returns (uint256) {\r\n        emit Failure(uint256(err), uint256(info), 0);\r\n\r\n        return uint256(err);\r\n    }\r\n\r\n    /**\r\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n     */\r\n    function failOpaque(FailureInfo info, uint256 opaqueError)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        emit Failure(uint256(Error.OPAQUE_ERROR), uint256(info), opaqueError);\r\n\r\n        return uint256(Error.OPAQUE_ERROR);\r\n    }\r\n}\r\n\r\ncontract CarefulMath is ErrorReporter {\r\n    /**\r\n     * @dev Multiplies two numbers, returns an error on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        if (a == 0) {\r\n            return (Error.NO_ERROR, 0);\r\n        }\r\n\r\n        uint256 c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        if (b == 0) {\r\n            return (Error.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        if (b <= a) {\r\n            return (Error.NO_ERROR, a - b);\r\n        } else {\r\n            return (Error.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, returns an error on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        uint256 c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (Error.NO_ERROR, c);\r\n        } else {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev add a and b and then subtract c\r\n     */\r\n    function addThenSub(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 c\r\n    ) internal pure returns (Error, uint256) {\r\n        (Error err0, uint256 sum) = add(a, b);\r\n\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return sub(sum, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Add two numbers together, overflow will lead to revert.\r\n     */\r\n    function srcAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Integer subtraction of two numbers, overflow will lead to revert.\r\n     */\r\n    function srcSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, overflow will lead to revert.\r\n     */\r\n    function srcMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function srcDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y > 0, \"ds-math-div-overflow\");\r\n        z = x / y;\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y power(base, exponent)\r\n     */\r\n    function pow(uint256 base, uint256 exponent) internal pure returns (uint256) {\r\n        if (exponent == 0) {\r\n            return 1;\r\n        } else if (exponent == 1) {\r\n            return base;\r\n        } else if (base == 0 && exponent != 0) {\r\n            return 0;\r\n        } else {\r\n            uint256 z = base;\r\n            for (uint256 i = 1; i < exponent; i++) z = srcMul(z, base);\r\n            return z;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Exponential is CarefulMath {\r\n    // TODO: We may wish to put the result of 10**18 here instead of the expression.\r\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\r\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\r\n    uint256 constant expScale = 10**18;\r\n\r\n    // See TODO on expScale\r\n    uint256 constant halfExpScale = expScale / 2;\r\n\r\n    struct Exp {\r\n        uint256 mantissa;\r\n    }\r\n\r\n    uint256 constant mantissaOne = 10**18;\r\n    uint256 constant mantissaOneTenth = 10**17;\r\n\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n     *            or if `denom` is zero.\r\n     */\r\n    function getExp(uint256 num, uint256 denom)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 scaledNumerator) = mul(num, expScale);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({ mantissa: 0 }));\r\n        }\r\n\r\n        (Error err1, uint256 rational) = div(scaledNumerator, denom);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({ mantissa: 0 }));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({ mantissa: rational }));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two exponentials, returning a new exponential.\r\n     */\r\n    function addExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error error, uint256 result) = add(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({ mantissa: result }));\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two exponentials, returning a new exponential.\r\n     */\r\n    function subExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error error, uint256 result) = sub(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({ mantissa: result }));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint256 scalar)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 scaledMantissa) = mul(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({ mantissa: 0 }));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({ mantissa: scaledMantissa }));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function divScalar(Exp memory a, uint256 scalar)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 descaledMantissa) = div(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({ mantissa: 0 }));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({ mantissa: descaledMantissa }));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint256 scalar, Exp memory divisor)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        /*\r\n            We are doing this as:\r\n            getExp(mul(expScale, scalar), divisor.mantissa)\r\n\r\n            How it works:\r\n            Exp = a / b;\r\n            Scalar = s;\r\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (Error err0, uint256 numerator) = mul(expScale, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({ mantissa: 0 }));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 doubleScaledProduct) = mul(a.mantissa, b.mantissa);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({ mantissa: 0 }));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (Error err1, uint256 doubleScaledProductWithHalfScale) =\r\n            add(halfExpScale, doubleScaledProduct);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({ mantissa: 0 }));\r\n        }\r\n\r\n        (Error err2, uint256 product) =\r\n            div(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == Error.NO_ERROR);\r\n\r\n        return (Error.NO_ERROR, Exp({ mantissa: product }));\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\r\n     */\r\n    function truncate(Exp memory exp) internal pure returns (uint256) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / 10**18;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is greater than second Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n}\r\n\r\ninterface ExchangeRateModel {\r\n    function scale() external view returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function getExchangeRate() external view returns (uint256);\r\n\r\n    function getMaxSwingRate(uint256 interval) external view returns (uint256);\r\n\r\n    function getFixedInterestRate(uint256 interval)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getFixedExchangeRate(uint256 interval)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256);\r\n\r\n    function latestTimestamp() external view returns (uint256);\r\n\r\n    function latestRound() external view returns (uint256);\r\n\r\n    function getAnswer(uint256 roundId) external view returns (int256);\r\n\r\n    function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IStatusOracle {\r\n\r\n    function getAssetPriceStatus(address _asset) external view returns (bool);\r\n}\r\n\r\ncontract PriceOracle is Exponential {\r\n    // Flag for whether or not contract is paused.\r\n    bool public paused;\r\n\r\n    // Approximately 1 hour: 60 seconds/minute * 60 minutes/hour * 1 block/15 seconds.\r\n    uint256 public constant numBlocksPerPeriod = 240;\r\n\r\n    uint256 public constant maxSwingMantissa = (5 * 10**15); // 0.005\r\n\r\n    uint256 public constant MINIMUM_SWING = 10**15;\r\n    uint256 public constant MAXIMUM_SWING = 10**17;\r\n\r\n    uint256 public constant SECONDS_PER_WEEK = 604800;\r\n\r\n    /**\r\n     * @dev An administrator who can set the pending anchor value for assets.\r\n     *      Set in the constructor.\r\n     */\r\n    address public anchorAdmin;\r\n\r\n    /**\r\n     * @dev Pending anchor administrator for this contract.\r\n     */\r\n    address public pendingAnchorAdmin;\r\n\r\n    /**\r\n     * @dev Address of the price poster.\r\n     *      Set in the constructor.\r\n     */\r\n    address public poster;\r\n\r\n    /**\r\n     * @dev The maximum allowed percentage difference between a new price and the anchor's price\r\n     *      Set only in the constructor\r\n     */\r\n    Exp public maxSwing;\r\n\r\n    /**\r\n     * @dev The maximum allowed percentage difference for all assets between a new price and the anchor's price\r\n     */\r\n    mapping(address => Exp) public maxSwings;\r\n\r\n    /**\r\n     * @dev Mapping of asset addresses to exchange rate information.\r\n     *      Dynamic changes in asset prices based on exchange rates.\r\n     * map: assetAddress -> ExchangeRateInfo\r\n     */\r\n    struct ExchangeRateInfo {\r\n        address exchangeRateModel; // Address of exchange rate model contract\r\n        uint256 exchangeRate; // Exchange rate between token and wrapped token\r\n        uint256 maxSwingRate; // Maximum changing ratio of the exchange rate\r\n        uint256 maxSwingDuration; // Duration of maximum changing ratio of the exchange rate\r\n    }\r\n    mapping(address => ExchangeRateInfo) public exchangeRates;\r\n\r\n    /**\r\n     * @dev Mapping of asset addresses to asset addresses. Stable coin can share a price.\r\n     *\r\n     * map: assetAddress -> Reader\r\n     */\r\n    struct Reader {\r\n        address asset; // Asset to read price\r\n        int256 decimalsDifference; // Standard decimal is 18, so this is equal to the decimal of `asset` - 18.\r\n    }\r\n    mapping(address => Reader) public readers;\r\n\r\n    /**\r\n     * @dev Mapping of asset addresses and their corresponding price in terms of Eth-Wei\r\n     *      which is simply equal to AssetWeiPrice * 10e18. For instance, if OMG token was\r\n     *      worth 5x Eth then the price for OMG would be 5*10e18 or Exp({mantissa: 5000000000000000000}).\r\n     * map: assetAddress -> Exp\r\n     */\r\n    mapping(address => Exp) public _assetPrices;\r\n    \r\n    /**\r\n     * @dev Mapping of asset addresses to aggregator.\r\n     */\r\n    mapping(address => IAggregator) public aggregator;\r\n\r\n    /**\r\n     * @dev Mapping of asset addresses to statusOracle.\r\n     */\r\n    mapping(address => IStatusOracle) public statusOracle;\r\n\r\n    constructor(address _poster, uint256 _maxSwing) public {\r\n        anchorAdmin = msg.sender;\r\n        poster = _poster;\r\n        _setMaxSwing(_maxSwing);\r\n    }\r\n\r\n    /**\r\n     * @notice Do not pay into PriceOracle.\r\n     */\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n    enum OracleError { NO_ERROR, UNAUTHORIZED, FAILED_TO_SET_PRICE }\r\n\r\n    enum OracleFailureInfo {\r\n        ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK,\r\n        SET_PAUSED_OWNER_CHECK,\r\n        SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_ANCHOR_PERMISSION_CHECK,\r\n        SET_PRICE_CALCULATE_SWING,\r\n        SET_PRICE_CAP_TO_MAX,\r\n        SET_PRICE_MAX_SWING_CHECK,\r\n        SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO,\r\n        SET_PRICE_PERMISSION_CHECK,\r\n        SET_PRICE_ZERO_PRICE,\r\n        SET_PRICES_PARAM_VALIDATION,\r\n        SET_PRICE_IS_READER_ASSET,\r\n        ADMIN_CONFIG\r\n    }\r\n\r\n    /**\r\n     * @dev `msgSender` is msg.sender; `error` corresponds to enum OracleError;\r\n     *      `info` corresponds to enum OracleFailureInfo, and `detail` is an arbitrary\r\n     *      contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n     */\r\n    event OracleFailure(\r\n        address msgSender,\r\n        address asset,\r\n        uint256 error,\r\n        uint256 info,\r\n        uint256 detail\r\n    );\r\n\r\n    /**\r\n     * @dev Use this when reporting a known error from the price oracle or a non-upgradeable collaborator\r\n     *      Using Oracle in name because we already inherit a `fail` function from ErrorReporter.sol\r\n     *      via Exponential.sol\r\n     */\r\n    function failOracle(\r\n        address _asset,\r\n        OracleError _err,\r\n        OracleFailureInfo _info\r\n    ) internal returns (uint256) {\r\n        emit OracleFailure(msg.sender, _asset, uint256(_err), uint256(_info), 0);\r\n\r\n        return uint256(_err);\r\n    }\r\n\r\n    /**\r\n     * @dev Use this to report an error when set asset price.\r\n     *      Give the `error` corresponds to enum Error as `_details`.\r\n     */\r\n    function failOracleWithDetails(\r\n        address _asset,\r\n        OracleError _err,\r\n        OracleFailureInfo _info,\r\n        uint256 _details\r\n    ) internal returns (uint256) {\r\n        emit OracleFailure(\r\n            msg.sender,\r\n            _asset,\r\n            uint256(_err),\r\n            uint256(_info),\r\n            _details\r\n        );\r\n\r\n        return uint256(_err);\r\n    }\r\n\r\n    struct Anchor {\r\n        // Floor(block.number / numBlocksPerPeriod) + 1\r\n        uint256 period;\r\n        // Price in ETH, scaled by 10**18\r\n        uint256 priceMantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Anchors by asset.\r\n     */\r\n    mapping(address => Anchor) public anchors;\r\n\r\n    /**\r\n     * @dev Pending anchor prices by asset.\r\n     */\r\n    mapping(address => uint256) public pendingAnchors;\r\n\r\n    /**\r\n     * @dev Emitted when a pending anchor is set.\r\n     * @param asset Asset for which to set a pending anchor.\r\n     * @param oldScaledPrice If an unused pending anchor was present, its value; otherwise 0.\r\n     * @param newScaledPrice The new scaled pending anchor price.\r\n     */\r\n    event NewPendingAnchor(\r\n        address anchorAdmin,\r\n        address asset,\r\n        uint256 oldScaledPrice,\r\n        uint256 newScaledPrice\r\n    );\r\n\r\n    /**\r\n     * @notice Provides ability to override the anchor price for an asset.\r\n     * @dev Admin function to set the anchor price for an asset.\r\n     * @param _asset Asset for which to override the anchor price.\r\n     * @param _newScaledPrice New anchor price.\r\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details).\r\n     */\r\n    function _setPendingAnchor(address _asset, uint256 _newScaledPrice)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin.\r\n        // Note: Deliberately not allowing admin. They can just change anchorAdmin if desired.\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    _asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PENDING_ANCHOR_PERMISSION_CHECK\r\n                );\r\n        }\r\n\r\n        uint256 _oldScaledPrice = pendingAnchors[_asset];\r\n        pendingAnchors[_asset] = _newScaledPrice;\r\n\r\n        emit NewPendingAnchor(\r\n            msg.sender,\r\n            _asset,\r\n            _oldScaledPrice,\r\n            _newScaledPrice\r\n        );\r\n\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted for all exchangeRates changes.\r\n     */\r\n    event SetExchangeRate(\r\n        address asset,\r\n        address exchangeRateModel,\r\n        uint256 exchangeRate,\r\n        uint256 maxSwingRate,\r\n        uint256 maxSwingDuration\r\n    );\r\n    event SetMaxSwingRate(\r\n        address asset,\r\n        uint256 oldMaxSwingRate,\r\n        uint256 newMaxSwingRate,\r\n        uint256 maxSwingDuration\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted for all readers changes.\r\n     */\r\n    event ReaderPosted(\r\n        address asset,\r\n        address oldReader,\r\n        address newReader,\r\n        int256 decimalsDifference\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted for max swing changes.\r\n     */\r\n    event SetMaxSwing(uint256 maxSwing);\r\n\r\n    /**\r\n     * @dev Emitted for max swing changes.\r\n     */\r\n    event SetMaxSwingForAsset(address asset, uint256 maxSwing);\r\n\r\n    /**\r\n     * @dev Emitted for max swing changes.\r\n     */\r\n    event SetAssetAggregator(address asset, address aggregator);\r\n\r\n    /**\r\n     * @dev Emitted for statusOracle changes.\r\n     */\r\n    event SetAssetStatusOracle(address asset, IStatusOracle statusOracle);\r\n\r\n    /**\r\n     * @dev Emitted for all price changes.\r\n     */\r\n    event PricePosted(\r\n        address asset,\r\n        uint256 previousPriceMantissa,\r\n        uint256 requestedPriceMantissa,\r\n        uint256 newPriceMantissa\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted if this contract successfully posts a capped-to-max price.\r\n     */\r\n    event CappedPricePosted(\r\n        address asset,\r\n        uint256 requestedPriceMantissa,\r\n        uint256 anchorPriceMantissa,\r\n        uint256 cappedPriceMantissa\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when admin either pauses or resumes the contract; `newState` is the resulting state.\r\n     */\r\n    event SetPaused(bool newState);\r\n\r\n    /**\r\n     * @dev Emitted when `pendingAnchorAdmin` is changed.\r\n     */\r\n    event NewPendingAnchorAdmin(\r\n        address oldPendingAnchorAdmin,\r\n        address newPendingAnchorAdmin\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `pendingAnchorAdmin` is accepted, which means anchor admin is updated.\r\n     */\r\n    event NewAnchorAdmin(address oldAnchorAdmin, address newAnchorAdmin);\r\n\r\n    /**\r\n     * @dev Emitted when `poster` is changed.\r\n     */\r\n    event NewPoster(address oldPoster, address newPoster);\r\n\r\n    /**\r\n     * @notice Set `paused` to the specified state.\r\n     * @dev Admin function to pause or resume the contract.\r\n     * @param _requestedState Value to assign to `paused`.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _setPaused(bool _requestedState) external returns (uint256) {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PAUSED_OWNER_CHECK\r\n                );\r\n        }\r\n\r\n        paused = _requestedState;\r\n        emit SetPaused(_requestedState);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Begins to transfer the right of anchor admin.\r\n     *         The `_newPendingAnchorAdmin` must call `_acceptAnchorAdmin` to finalize the transfer.\r\n     * @dev Admin function to change the anchor admin.\r\n     *      The `_newPendingAnchorAdmin` must call `_acceptAnchorAdmin` to finalize the transfer.\r\n     * @param _newPendingAnchorAdmin New pending anchor admin.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _setPendingAnchorAdmin(address _newPendingAnchorAdmin)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin.\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK\r\n                );\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log.\r\n        address _oldPendingAnchorAdmin = pendingAnchorAdmin;\r\n        // Store pendingAdmin = newPendingAdmin.\r\n        pendingAnchorAdmin = _newPendingAnchorAdmin;\r\n\r\n        emit NewPendingAnchorAdmin(\r\n            _oldPendingAnchorAdmin,\r\n            _newPendingAnchorAdmin\r\n        );\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Accepts transfer of anchor admin rights. `msg.sender` must be `pendingAnchorAdmin`.\r\n     * @dev Admin function for pending anchor admin to accept role and update anchor admin`\r\n     * @return uint 0=success, otherwise a failure`\r\n     */\r\n    function _acceptAnchorAdmin() external returns (uint256) {\r\n        // Check caller = pendingAnchorAdmin.\r\n        // `msg.sender` can't be zero.\r\n        if (msg.sender != pendingAnchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo\r\n                        .ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK\r\n                );\r\n        }\r\n\r\n        // Save current value for inclusion in log.\r\n        address _oldAnchorAdmin = anchorAdmin;\r\n        // Store admin = pendingAnchorAdmin.\r\n        anchorAdmin = pendingAnchorAdmin;\r\n        // Clear the pending value.\r\n        pendingAnchorAdmin = address(0);\r\n\r\n        emit NewAnchorAdmin(_oldAnchorAdmin, msg.sender);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set new poster.\r\n     * @dev Admin function to change of poster.\r\n     * @param _newPoster New poster.\r\n     * @return uint 0=success, otherwise a failure.\r\n     *\r\n     * TODO: Should we add a second arg to verify, like a checksum of `newAnchorAdmin` address?\r\n     */\r\n    function _setPoster(address _newPoster) external returns (uint256) {\r\n        assert(poster != _newPoster);\r\n        // Check caller = anchorAdmin.\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log.\r\n        address _oldPoster = poster;\r\n        // Store poster = newPoster.\r\n        poster = _newPoster;\r\n\r\n        emit NewPoster(_oldPoster, _newPoster);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set new exchange rate model.\r\n     * @dev Function to set exchangeRateModel for an asset.\r\n     * @param _asset Asset to set the new `_exchangeRateModel`.\r\n     * @param _exchangeRateModel New `_exchangeRateModel` cnotract address,\r\n     *                          if the `_exchangeRateModel` is address(0), revert to cancle.\r\n     * @param _maxSwingDuration A value greater than zero and less than the seconds of a week.\r\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details).\r\n     */\r\n    function setExchangeRate(\r\n        address _asset,\r\n        address _exchangeRateModel,\r\n        uint256 _maxSwingDuration\r\n    ) external returns (uint256) {\r\n        // Check caller = anchorAdmin.\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    _asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n\r\n        require(\r\n            _exchangeRateModel != address(0),\r\n            \"setExchangeRate: exchangeRateModel cannot be a zero address.\"\r\n        );\r\n        require(\r\n            _maxSwingDuration > 0 && _maxSwingDuration <= SECONDS_PER_WEEK,\r\n            \"setExchangeRate: maxSwingDuration cannot be zero, less than 604800 (seconds per week).\"\r\n        );\r\n\r\n        uint256 _currentExchangeRate =\r\n            ExchangeRateModel(_exchangeRateModel).getExchangeRate();\r\n        require(\r\n            _currentExchangeRate > 0,\r\n            \"setExchangeRate: currentExchangeRate not zero.\"\r\n        );\r\n\r\n        uint256 _maxSwingRate =\r\n            ExchangeRateModel(_exchangeRateModel).getMaxSwingRate(\r\n                _maxSwingDuration\r\n            );\r\n        require(\r\n            _maxSwingRate > 0 &&\r\n                _maxSwingRate <=\r\n                ExchangeRateModel(_exchangeRateModel).getMaxSwingRate(\r\n                    SECONDS_PER_WEEK\r\n                ),\r\n            \"setExchangeRate: maxSwingRate cannot be zero, less than 604800 (seconds per week).\"\r\n        );\r\n\r\n        exchangeRates[_asset].exchangeRateModel = _exchangeRateModel;\r\n        exchangeRates[_asset].exchangeRate = _currentExchangeRate;\r\n        exchangeRates[_asset].maxSwingRate = _maxSwingRate;\r\n        exchangeRates[_asset].maxSwingDuration = _maxSwingDuration;\r\n\r\n        emit SetExchangeRate(\r\n            _asset,\r\n            _exchangeRateModel,\r\n            _currentExchangeRate,\r\n            _maxSwingRate,\r\n            _maxSwingDuration\r\n        );\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the asset’s `exchangeRateModel` to disabled.\r\n     * @dev Admin function to disable of exchangeRateModel.\r\n     * @param _asset Asset for which to disable the `exchangeRateModel`.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _disableExchangeRate(address _asset)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin.\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    _asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n\r\n        exchangeRates[_asset].exchangeRateModel = address(0);\r\n        exchangeRates[_asset].exchangeRate = 0;\r\n        exchangeRates[_asset].maxSwingRate = 0;\r\n        exchangeRates[_asset].maxSwingDuration = 0;\r\n\r\n        emit SetExchangeRate(\r\n            _asset,\r\n            address(0),\r\n            0,\r\n            0,\r\n            0\r\n        );\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set a new `maxSwingRate`.\r\n     * @dev Function to set exchange rate `maxSwingRate` for an asset.\r\n     * @param _asset Asset for which to set the exchange rate `maxSwingRate`.\r\n     * @param _maxSwingDuration Interval time.\r\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details)\r\n     */\r\n    function setMaxSwingRate(address _asset, uint256 _maxSwingDuration)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    _asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n\r\n        require(\r\n            _maxSwingDuration > 0 && _maxSwingDuration <= SECONDS_PER_WEEK,\r\n            \"setMaxSwingRate: maxSwingDuration cannot be zero, less than 604800 (seconds per week).\"\r\n        );\r\n\r\n        ExchangeRateModel _exchangeRateModel =\r\n            ExchangeRateModel(exchangeRates[_asset].exchangeRateModel);\r\n        uint256 _newMaxSwingRate =\r\n            _exchangeRateModel.getMaxSwingRate(_maxSwingDuration);\r\n        uint256 _oldMaxSwingRate = exchangeRates[_asset].maxSwingRate;\r\n        require(\r\n            _oldMaxSwingRate != _newMaxSwingRate,\r\n            \"setMaxSwingRate: the same max swing rate.\"\r\n        );\r\n        require(\r\n            _newMaxSwingRate > 0 &&\r\n                _newMaxSwingRate <=\r\n                _exchangeRateModel.getMaxSwingRate(SECONDS_PER_WEEK),\r\n            \"setMaxSwingRate: maxSwingRate cannot be zero, less than 31536000 (seconds per week).\"\r\n        );\r\n\r\n        exchangeRates[_asset].maxSwingRate = _newMaxSwingRate;\r\n        exchangeRates[_asset].maxSwingDuration = _maxSwingDuration;\r\n\r\n        emit SetMaxSwingRate(\r\n            _asset,\r\n            _oldMaxSwingRate,\r\n            _newMaxSwingRate,\r\n            _maxSwingDuration\r\n        );\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Entry point for updating prices.\r\n     * @dev Set reader for an asset.\r\n     * @param _asset Asset for which to set the reader.\r\n     * @param _readAsset Reader address, if the reader is address(0), cancel the reader.\r\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details).\r\n     */\r\n    function setReaders(address _asset, address _readAsset)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    _asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n\r\n        address _oldReadAsset = readers[_asset].asset;\r\n        // require(_readAsset != _oldReadAsset, \"setReaders: Old and new values cannot be the same.\");\r\n        require(\r\n            _readAsset != _asset,\r\n            \"setReaders: asset and readAsset cannot be the same.\"\r\n        );\r\n\r\n        readers[_asset].asset = _readAsset;\r\n        if (_readAsset == address(0)) readers[_asset].decimalsDifference = 0;\r\n        else\r\n            readers[_asset].decimalsDifference = int256(\r\n                IERC20(_asset).decimals() - IERC20(_readAsset).decimals()\r\n            );\r\n\r\n        emit ReaderPosted(\r\n            _asset,\r\n            _oldReadAsset,\r\n            _readAsset,\r\n            readers[_asset].decimalsDifference\r\n        );\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set `maxSwing` to the specified value.\r\n     * @dev Admin function to change of max swing.\r\n     * @param _maxSwing Value to assign to `maxSwing`.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _setMaxSwing(uint256 _maxSwing) public returns (uint256) {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n\r\n        uint256 _oldMaxSwing = maxSwing.mantissa;\r\n        require(\r\n            _maxSwing != _oldMaxSwing,\r\n            \"_setMaxSwing: Old and new values cannot be the same.\"\r\n        );\r\n\r\n        require(\r\n            _maxSwing >= MINIMUM_SWING && _maxSwing <= MAXIMUM_SWING,\r\n            \"_setMaxSwing: 0.1% <= _maxSwing <= 10%.\"\r\n        );\r\n        maxSwing = Exp({ mantissa: _maxSwing });\r\n        emit SetMaxSwing(_maxSwing);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set `maxSwing` for asset to the specified value.\r\n     * @dev Admin function to change of max swing.\r\n     * @param _asset Asset for which to set the `maxSwing`.\r\n     * @param _maxSwing Value to assign to `maxSwing`.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _setMaxSwingForAsset(address _asset, uint256 _maxSwing)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n\r\n        uint256 _oldMaxSwing = maxSwings[_asset].mantissa;\r\n        require(\r\n            _maxSwing != _oldMaxSwing,\r\n            \"_setMaxSwingForAsset: Old and new values cannot be the same.\"\r\n        );\r\n        require(\r\n            _maxSwing >= MINIMUM_SWING && _maxSwing <= MAXIMUM_SWING,\r\n            \"_setMaxSwingForAsset: 0.1% <= _maxSwing <= 10%.\"\r\n        );\r\n        maxSwings[_asset] = Exp({ mantissa: _maxSwing });\r\n        emit SetMaxSwingForAsset(_asset, _maxSwing);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setMaxSwingForAssetBatch(\r\n        address[] calldata _assets,\r\n        uint256[] calldata _maxSwings\r\n    ) external {\r\n        require(\r\n            _assets.length == _maxSwings.length,\r\n            \"_setMaxSwingForAssetBatch: assets & maxSwings must match the current length.\"\r\n        );\r\n        for (uint256 i = 0; i < _assets.length; i++)\r\n            _setMaxSwingForAsset(_assets[i], _maxSwings[i]);\r\n    }\r\n\r\n    /**\r\n     * @notice Set `aggregator` for asset to the specified address.\r\n     * @dev Admin function to change of aggregator.\r\n     * @param _asset Asset for which to set the `aggregator`.\r\n     * @param _aggregator Address to assign to `aggregator`.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _setAssetAggregator(address _asset, IAggregator _aggregator)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n\r\n        require(\r\n            _aggregator.decimals() > 0,\r\n            \"_setAssetAggregator: This is not the aggregator contract!\"\r\n        );\r\n\r\n        IAggregator _oldAssetAggregator = aggregator[_asset];\r\n        require(\r\n            _aggregator != _oldAssetAggregator,\r\n            \"_setAssetAggregator: Old and new address cannot be the same.\"\r\n        );\r\n        \r\n        aggregator[_asset] = IAggregator(_aggregator);\r\n        emit SetAssetAggregator(_asset, address(_aggregator));\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setAssetAggregatorBatch(\r\n        address[] calldata _assets,\r\n        IAggregator[] calldata _aggregators\r\n    ) external {\r\n        require(\r\n            _assets.length == _aggregators.length,\r\n            \"_setAssetAggregatorBatch: assets & aggregators must match the current length.\"\r\n        );\r\n        for (uint256 i = 0; i < _assets.length; i++)\r\n            _setAssetAggregator(_assets[i], _aggregators[i]);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the asset’s `aggregator` to disabled.\r\n     * @dev Admin function to disable of aggregator.\r\n     * @param _asset Asset for which to disable the `aggregator`.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _disableAssetAggregator(address _asset)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n\r\n        require(\r\n            _getReaderPrice(_asset) > 0,\r\n            \"_disableAssetAggregator: The price of local assets cannot be 0!\"\r\n        );\r\n        \r\n        aggregator[_asset] = IAggregator(address(0));\r\n        emit SetAssetAggregator(_asset, address(0));\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    function _disableAssetAggregatorBatch(address[] calldata _assets) external {\r\n        for (uint256 i = 0; i < _assets.length; i++)\r\n            _disableAssetAggregator(_assets[i]);\r\n    }\r\n\r\n    /**\r\n     * @notice Set `statusOracle` for asset to the specified address.\r\n     * @dev Admin function to change of statusOracle.\r\n     * @param _asset Asset for which to set the `statusOracle`.\r\n     * @param _statusOracle Address to assign to `statusOracle`.\r\n     * @return uint 0=success, otherwise a failure.SetAssetStatusOracle\r\n     */\r\n    function _setAssetStatusOracle(address _asset, IStatusOracle _statusOracle)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n\r\n        _statusOracle.getAssetPriceStatus(_asset);\r\n        \r\n        statusOracle[_asset] = _statusOracle;\r\n        emit SetAssetStatusOracle(_asset, _statusOracle);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setAssetStatusOracleBatch(\r\n        address[] calldata _assets,\r\n        IStatusOracle[] calldata _statusOracles\r\n    ) external {\r\n        require(\r\n            _assets.length == _statusOracles.length,\r\n            \"_setAssetStatusOracleBatch: assets & _statusOracles must match the current length.\"\r\n        );\r\n        for (uint256 i = 0; i < _assets.length; i++)\r\n            _setAssetStatusOracle(_assets[i], _statusOracles[i]);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the `statusOracle` to disabled.\r\n     * @dev Admin function to disable of statusOracle.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _disableAssetStatusOracle(address _asset)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.ADMIN_CONFIG\r\n                );\r\n        }\r\n        statusOracle[_asset] = IStatusOracle(0);\r\n        \r\n        emit SetAssetStatusOracle(_asset, IStatusOracle(0));\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    function _disableAssetStatusOracleBatch(address[] calldata _assets) external {\r\n        for (uint256 i = 0; i < _assets.length; i++)\r\n            _disableAssetStatusOracle(_assets[i]);\r\n    }\r\n\r\n    /**\r\n     * @notice Asset prices are provided by chain link or other aggregator.\r\n     * @dev Get price of `asset` from aggregator.\r\n     * @param _asset Asset for which to get the price.\r\n     * @return Uint mantissa of asset price (scaled by 1e18) or zero if unset or under unexpected case.\r\n     */\r\n    function _getAssetAggregatorPrice(address _asset) internal view returns (uint256) {\r\n        IAggregator _assetAggregator = aggregator[_asset];\r\n        if (address(_assetAggregator) == address(0))\r\n            return 0;\r\n\r\n        int256 _aggregatorPrice = _assetAggregator.latestAnswer();\r\n        if (_aggregatorPrice <= 0)\r\n            return 0;\r\n\r\n        return srcMul(\r\n            uint256(_aggregatorPrice), \r\n            10 ** (srcSub(36, srcAdd(uint256(IERC20(_asset).decimals()), uint256(_assetAggregator.decimals()))))\r\n        );\r\n    }\r\n\r\n    function getAssetAggregatorPrice(address _asset) external view returns (uint256) {\r\n        return _getAssetAggregatorPrice(_asset);\r\n    }\r\n\r\n    /**\r\n     * @notice Asset prices are provided by aggregator or a reader.\r\n     * @dev Get price of `asset`.\r\n     * @param _asset Asset for which to get the price.\r\n     * @return Uint mantissa of asset price (scaled by 1e18) or zero if unset or under unexpected case.\r\n     */\r\n    function _getAssetPrice(address _asset) internal view returns (uint256) {\r\n        uint256 _assetPrice = _getAssetAggregatorPrice(_asset);\r\n        if (_assetPrice == 0)\r\n            return _getReaderPrice(_asset);\r\n        \r\n        return _assetPrice;\r\n    }\r\n\r\n    function getAssetPrice(address _asset) external view returns (uint256) {\r\n        return _getAssetPrice(_asset);\r\n    }\r\n\r\n    /**\r\n     * @notice This is a basic function to read price, although this is a public function,\r\n     *         It is not recommended, the recommended function is `assetPrices(asset)`.\r\n     *         If `asset` does not has a reader to reader price, then read price from original\r\n     *         structure `_assetPrices`;\r\n     *         If `asset` has a reader to read price, first gets the price of reader, then\r\n     *         `readerPrice * 10 ** |(18-assetDecimals)|`\r\n     * @dev Get price of `asset`.\r\n     * @param _asset Asset for which to get the price.\r\n     * @return Uint mantissa of asset price (scaled by 1e18) or zero if unset.\r\n     */\r\n    function _getReaderPrice(address _asset) internal view returns (uint256) {\r\n        Reader storage _reader = readers[_asset];\r\n        if (_reader.asset == address(0)) return _assetPrices[_asset].mantissa;\r\n\r\n        uint256 readerPrice = _assetPrices[_reader.asset].mantissa;\r\n\r\n        if (_reader.decimalsDifference < 0)\r\n            return\r\n                srcMul(\r\n                    readerPrice,\r\n                    pow(10, uint256(0 - _reader.decimalsDifference))\r\n                );\r\n\r\n        return srcDiv(readerPrice, pow(10, uint256(_reader.decimalsDifference)));\r\n    }\r\n\r\n    function getReaderPrice(address _asset) external view returns (uint256) {\r\n        return _getReaderPrice(_asset);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves price of an asset.\r\n     * @dev Get price for an asset.\r\n     * @param _asset Asset for which to get the price.\r\n     * @return Uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused.\r\n     */\r\n    function assetPrices(address _asset) internal view returns (uint256) {\r\n        // Note: zero is treated by the xSwap as an invalid\r\n        //       price and will cease operations with that asset\r\n        //       when zero.\r\n        //\r\n        // We get the price as:\r\n        //\r\n        //  1. If the contract is paused, return 0.\r\n        //  2. If the asset has an exchange rate model, the asset price is calculated based on the exchange rate.\r\n        //  3. Return price in `_assetPrices`, which may be zero.\r\n\r\n        if (paused) {\r\n            return 0;\r\n        } else {\r\n            uint256 _assetPrice = _getAssetPrice(_asset);\r\n            ExchangeRateInfo storage _exchangeRateInfo = exchangeRates[_asset];\r\n            if (_exchangeRateInfo.exchangeRateModel != address(0)) {\r\n                uint256 _scale =\r\n                    ExchangeRateModel(_exchangeRateInfo.exchangeRateModel)\r\n                        .scale();\r\n                uint256 _currentExchangeRate =\r\n                    ExchangeRateModel(_exchangeRateInfo.exchangeRateModel)\r\n                        .getExchangeRate();\r\n                uint256 _currentChangeRate;\r\n                Error _err;\r\n                (_err, _currentChangeRate) = mul(_currentExchangeRate, _scale);\r\n                if (_err != Error.NO_ERROR) return 0;\r\n\r\n                _currentChangeRate =\r\n                    _currentChangeRate /\r\n                    _exchangeRateInfo.exchangeRate;\r\n                // require(_currentExchangeRate >= _exchangeRateInfo.exchangeRate && _currentChangeRate <= _exchangeRateInfo.maxSwingRate, \"assetPrices: Abnormal exchange rate.\");\r\n                if (\r\n                    _currentExchangeRate < _exchangeRateInfo.exchangeRate ||\r\n                    _currentChangeRate > _exchangeRateInfo.maxSwingRate\r\n                ) return 0;\r\n\r\n                uint256 _price;\r\n                (_err, _price) = mul(_assetPrice, _currentExchangeRate);\r\n                if (_err != Error.NO_ERROR) return 0;\r\n\r\n                return _price / _scale;\r\n            } else {\r\n                return _assetPrice;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves price of an asset.\r\n     * @dev Get price for an asset.\r\n     * @param _asset Asset for which to get the price.\r\n     * @return Uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused.\r\n     */\r\n    function getUnderlyingPrice(address _asset) external view returns (uint256) {\r\n        return assetPrices(_asset);\r\n    }\r\n\r\n    /**\r\n     * @notice The asset price status is provided by statusOracle.\r\n     * @dev Get price status of `asset` from statusOracle.\r\n     * @param _asset Asset for which to get the price status.\r\n     * @return The asset price status is Boolean, the price status model is not set to true.true: available, false: unavailable.\r\n     */\r\n    function _getAssetPriceStatus(address _asset) internal view returns (bool) {\r\n\r\n        IStatusOracle _statusOracle = statusOracle[_asset];\r\n        if (_statusOracle == IStatusOracle(0))\r\n            return true;\r\n\r\n        return _statusOracle.getAssetPriceStatus(_asset);\r\n    }\r\n\r\n    function getAssetPriceStatus(address _asset) external view returns (bool) {\r\n        return _getAssetPriceStatus(_asset);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve asset price and status.\r\n     * @dev Get the price and status of the asset.\r\n     * @param _asset The asset whose price and status are to be obtained.\r\n     * @return Asset price and status.\r\n     */\r\n    function getUnderlyingPriceAndStatus(address _asset) external view returns (uint256, bool) {\r\n        uint256 _assetPrice = assetPrices(_asset);\r\n        return (_assetPrice, _getAssetPriceStatus(_asset));\r\n    }\r\n\r\n    /**\r\n     * @dev Get exchange rate info of an asset in the time of `interval`.\r\n     * @param _asset Asset for which to get the exchange rate info.\r\n     * @param _interval Time to get accmulator interest rate.\r\n     * @return Asset price, exchange rate model address, the token that is using this exchange rate model,\r\n     *         exchange rate model contract address,\r\n     *         the token that is using this exchange rate model,\r\n     *         scale between token and wrapped token,\r\n     *         exchange rate between token and wrapped token,\r\n     *         After the time of `_interval`, get the accmulator interest rate.\r\n     */\r\n    function getExchangeRateInfo(address _asset, uint256 _interval)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            address,\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        if (exchangeRates[_asset].exchangeRateModel == address(0))\r\n            return (_getReaderPrice(_asset), address(0), address(0), 0, 0, 0);\r\n\r\n        return (\r\n            _getReaderPrice(_asset),\r\n            exchangeRates[_asset].exchangeRateModel,\r\n            ExchangeRateModel(exchangeRates[_asset].exchangeRateModel).token(),\r\n            ExchangeRateModel(exchangeRates[_asset].exchangeRateModel).scale(),\r\n            ExchangeRateModel(exchangeRates[_asset].exchangeRateModel)\r\n                .getExchangeRate(),\r\n            ExchangeRateModel(exchangeRates[_asset].exchangeRateModel)\r\n                .getFixedInterestRate(_interval)\r\n        );\r\n    }\r\n\r\n    struct SetPriceLocalVars {\r\n        Exp price;\r\n        Exp swing;\r\n        Exp maxSwing;\r\n        Exp anchorPrice;\r\n        uint256 anchorPeriod;\r\n        uint256 currentPeriod;\r\n        bool priceCapped;\r\n        uint256 cappingAnchorPriceMantissa;\r\n        uint256 pendingAnchorMantissa;\r\n    }\r\n\r\n    /**\r\n     * @notice Entry point for updating prices.\r\n     *         1) If admin has set a `readerPrice` for this asset, then poster can not use this function.\r\n     *         2) Standard stablecoin has 18 deicmals, and its price should be 1e18,\r\n     *            so when the poster set a new price for a token,\r\n     *            `requestedPriceMantissa` = actualPrice * 10 ** (18-tokenDecimals),\r\n     *            actualPrice is scaled by 10**18.\r\n     * @dev Set price for an asset.\r\n     * @param _asset Asset for which to set the price.\r\n     * @param _requestedPriceMantissa Requested new price, scaled by 10**18.\r\n     * @return Uint 0=success, otherwise a failure (see enum OracleError for details).\r\n     */\r\n    function setPrice(address _asset, uint256 _requestedPriceMantissa)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        // Fail when msg.sender is not poster\r\n        if (msg.sender != poster) {\r\n            return\r\n                failOracle(\r\n                    _asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PRICE_PERMISSION_CHECK\r\n                );\r\n        }\r\n\r\n        return setPriceInternal(_asset, _requestedPriceMantissa);\r\n    }\r\n\r\n    function setPriceInternal(address _asset, uint256 _requestedPriceMantissa)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // re-used for intermediate errors\r\n        Error _err;\r\n        SetPriceLocalVars memory _localVars;\r\n        // We add 1 for currentPeriod so that it can never be zero and there's no ambiguity about an unset value.\r\n        // (It can be a problem in tests with low block numbers.)\r\n        _localVars.currentPeriod = (block.number / numBlocksPerPeriod) + 1;\r\n        _localVars.pendingAnchorMantissa = pendingAnchors[_asset];\r\n        _localVars.price = Exp({ mantissa: _requestedPriceMantissa });\r\n\r\n        if (exchangeRates[_asset].exchangeRateModel != address(0)) {\r\n            uint256 _currentExchangeRate =\r\n                ExchangeRateModel(exchangeRates[_asset].exchangeRateModel)\r\n                    .getExchangeRate();\r\n            uint256 _scale =\r\n                ExchangeRateModel(exchangeRates[_asset].exchangeRateModel)\r\n                    .scale();\r\n            uint256 _currentChangeRate;\r\n            (_err, _currentChangeRate) = mul(_currentExchangeRate, _scale);\r\n            assert(_err == Error.NO_ERROR);\r\n\r\n            _currentChangeRate =\r\n                _currentChangeRate /\r\n                exchangeRates[_asset].exchangeRate;\r\n            require(\r\n                _currentExchangeRate >= exchangeRates[_asset].exchangeRate &&\r\n                    _currentChangeRate <= exchangeRates[_asset].maxSwingRate,\r\n                \"setPriceInternal: Abnormal exchange rate.\"\r\n            );\r\n            exchangeRates[_asset].exchangeRate = _currentExchangeRate;\r\n        }\r\n\r\n        if (readers[_asset].asset != address(0)) {\r\n            return\r\n                failOracle(\r\n                    _asset,\r\n                    OracleError.FAILED_TO_SET_PRICE,\r\n                    OracleFailureInfo.SET_PRICE_IS_READER_ASSET\r\n                );\r\n        }\r\n\r\n        _localVars.maxSwing = maxSwings[_asset].mantissa == 0\r\n            ? maxSwing\r\n            : maxSwings[_asset];\r\n        if (_localVars.pendingAnchorMantissa != 0) {\r\n            // let's explicitly set to 0 rather than relying on default of declaration\r\n            _localVars.anchorPeriod = 0;\r\n            _localVars.anchorPrice = Exp({\r\n                mantissa: _localVars.pendingAnchorMantissa\r\n            });\r\n\r\n            // Verify movement is within max swing of pending anchor (currently: 10%)\r\n            (_err, _localVars.swing) = calculateSwing(\r\n                _localVars.anchorPrice,\r\n                _localVars.price\r\n            );\r\n            if (_err != Error.NO_ERROR) {\r\n                return\r\n                    failOracleWithDetails(\r\n                        _asset,\r\n                        OracleError.FAILED_TO_SET_PRICE,\r\n                        OracleFailureInfo.SET_PRICE_CALCULATE_SWING,\r\n                        uint256(_err)\r\n                    );\r\n            }\r\n\r\n            // Fail when swing > maxSwing\r\n            // if (greaterThanExp(_localVars.swing, maxSwing)) {\r\n            if (greaterThanExp(_localVars.swing, _localVars.maxSwing)) {\r\n                return\r\n                    failOracleWithDetails(\r\n                        _asset,\r\n                        OracleError.FAILED_TO_SET_PRICE,\r\n                        OracleFailureInfo.SET_PRICE_MAX_SWING_CHECK,\r\n                        _localVars.swing.mantissa\r\n                    );\r\n            }\r\n        } else {\r\n            _localVars.anchorPeriod = anchors[_asset].period;\r\n            _localVars.anchorPrice = Exp({\r\n                mantissa: anchors[_asset].priceMantissa\r\n            });\r\n\r\n            if (_localVars.anchorPeriod != 0) {\r\n                // (_err, _localVars.priceCapped, _localVars.price) = capToMax(_localVars.anchorPrice, _localVars.price);\r\n                (_err, _localVars.priceCapped, _localVars.price) = capToMax(\r\n                    _localVars.anchorPrice,\r\n                    _localVars.price,\r\n                    _localVars.maxSwing\r\n                );\r\n                if (_err != Error.NO_ERROR) {\r\n                    return\r\n                        failOracleWithDetails(\r\n                            _asset,\r\n                            OracleError.FAILED_TO_SET_PRICE,\r\n                            OracleFailureInfo.SET_PRICE_CAP_TO_MAX,\r\n                            uint256(_err)\r\n                        );\r\n                }\r\n                if (_localVars.priceCapped) {\r\n                    // save for use in log\r\n                    _localVars.cappingAnchorPriceMantissa = _localVars\r\n                        .anchorPrice\r\n                        .mantissa;\r\n                }\r\n            } else {\r\n                // Setting first price. Accept as is (already assigned above from _requestedPriceMantissa) and use as anchor\r\n                _localVars.anchorPrice = Exp({\r\n                    mantissa: _requestedPriceMantissa\r\n                });\r\n            }\r\n        }\r\n\r\n        // Fail if anchorPrice or price is zero.\r\n        // zero anchor represents an unexpected situation likely due to a problem in this contract\r\n        // zero price is more likely as the result of bad input from the caller of this function\r\n        if (isZeroExp(_localVars.anchorPrice)) {\r\n            // If we get here price could also be zero, but it does not seem worthwhile to distinguish the 3rd case\r\n            return\r\n                failOracle(\r\n                    _asset,\r\n                    OracleError.FAILED_TO_SET_PRICE,\r\n                    OracleFailureInfo\r\n                        .SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO\r\n                );\r\n        }\r\n\r\n        if (isZeroExp(_localVars.price)) {\r\n            return\r\n                failOracle(\r\n                    _asset,\r\n                    OracleError.FAILED_TO_SET_PRICE,\r\n                    OracleFailureInfo.SET_PRICE_ZERO_PRICE\r\n                );\r\n        }\r\n\r\n        // BEGIN SIDE EFFECTS\r\n\r\n        // Set pendingAnchor = Nothing\r\n        // Pending anchor is only used once.\r\n        if (pendingAnchors[_asset] != 0) {\r\n            pendingAnchors[_asset] = 0;\r\n        }\r\n\r\n        // If currentPeriod > anchorPeriod:\r\n        //  Set anchors[_asset] = (currentPeriod, price)\r\n        //  The new anchor is if we're in a new period or we had a pending anchor, then we become the new anchor\r\n        if (_localVars.currentPeriod > _localVars.anchorPeriod) {\r\n            anchors[_asset] = Anchor({\r\n                period: _localVars.currentPeriod,\r\n                priceMantissa: _localVars.price.mantissa\r\n            });\r\n        }\r\n\r\n        uint256 _previousPrice = _assetPrices[_asset].mantissa;\r\n\r\n        setPriceStorageInternal(_asset, _localVars.price.mantissa);\r\n\r\n        emit PricePosted(\r\n            _asset,\r\n            _previousPrice,\r\n            _requestedPriceMantissa,\r\n            _localVars.price.mantissa\r\n        );\r\n\r\n        if (_localVars.priceCapped) {\r\n            // We have set a capped price. Log it so we can detect the situation and investigate.\r\n            emit CappedPricePosted(\r\n                _asset,\r\n                _requestedPriceMantissa,\r\n                _localVars.cappingAnchorPriceMantissa,\r\n                _localVars.price.mantissa\r\n            );\r\n        }\r\n\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    // As a function to allow harness overrides\r\n    function setPriceStorageInternal(address _asset, uint256 _priceMantissa)\r\n        internal\r\n    {\r\n        _assetPrices[_asset] = Exp({ mantissa: _priceMantissa });\r\n    }\r\n\r\n    // abs(price - anchorPrice) / anchorPrice\r\n    function calculateSwing(Exp memory _anchorPrice, Exp memory _price)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        Exp memory numerator;\r\n        Error err;\r\n\r\n        if (greaterThanExp(_anchorPrice, _price)) {\r\n            (err, numerator) = subExp(_anchorPrice, _price);\r\n            // can't underflow\r\n            assert(err == Error.NO_ERROR);\r\n        } else {\r\n            (err, numerator) = subExp(_price, _anchorPrice);\r\n            // Given greaterThan check above, _price >= _anchorPrice so can't underflow.\r\n            assert(err == Error.NO_ERROR);\r\n        }\r\n\r\n        return divExp(numerator, _anchorPrice);\r\n    }\r\n\r\n    // Base on the current anchor price, get the final valid price.\r\n    function capToMax(\r\n        Exp memory _anchorPrice,\r\n        Exp memory _price,\r\n        Exp memory _maxSwing\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            Error,\r\n            bool,\r\n            Exp memory\r\n        )\r\n    {\r\n        Exp memory one = Exp({ mantissa: mantissaOne });\r\n        Exp memory onePlusMaxSwing;\r\n        Exp memory oneMinusMaxSwing;\r\n        Exp memory max;\r\n        Exp memory min;\r\n        // re-used for intermediate errors\r\n        Error err;\r\n\r\n        (err, onePlusMaxSwing) = addExp(one, _maxSwing);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, false, Exp({ mantissa: 0 }));\r\n        }\r\n\r\n        // max = _anchorPrice * (1 + _maxSwing)\r\n        (err, max) = mulExp(_anchorPrice, onePlusMaxSwing);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, false, Exp({ mantissa: 0 }));\r\n        }\r\n\r\n        // If _price > _anchorPrice * (1 + _maxSwing)\r\n        // Set _price = _anchorPrice * (1 + _maxSwing)\r\n        if (greaterThanExp(_price, max)) {\r\n            return (Error.NO_ERROR, true, max);\r\n        }\r\n\r\n        (err, oneMinusMaxSwing) = subExp(one, _maxSwing);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, false, Exp({ mantissa: 0 }));\r\n        }\r\n\r\n        // min = _anchorPrice * (1 - _maxSwing)\r\n        (err, min) = mulExp(_anchorPrice, oneMinusMaxSwing);\r\n        // We can't overflow here or we would have already overflowed above when calculating `max`\r\n        assert(err == Error.NO_ERROR);\r\n\r\n        // If  _price < _anchorPrice * (1 - _maxSwing)\r\n        // Set _price = _anchorPrice * (1 - _maxSwing)\r\n        if (lessThanExp(_price, min)) {\r\n            return (Error.NO_ERROR, true, min);\r\n        }\r\n\r\n        return (Error.NO_ERROR, false, _price);\r\n    }\r\n\r\n    /**\r\n     * @notice Entry point for updating multiple prices.\r\n     * @dev Set prices for a variable number of assets.\r\n     * @param _assets A list of up to assets for which to set a price.\r\n     *        Notice: 0 < _assets.length == _requestedPriceMantissas.length\r\n     * @param _requestedPriceMantissas Requested new prices for the assets, scaled by 10**18.\r\n     *        Notice: 0 < _assets.length == _requestedPriceMantissas.length\r\n     * @return Uint values in same order as inputs.\r\n     *         For each: 0=success, otherwise a failure (see enum OracleError for details)\r\n     */\r\n    function setPrices(\r\n        address[] memory _assets,\r\n        uint256[] memory _requestedPriceMantissas\r\n    ) external returns (uint256[] memory) {\r\n        uint256 numAssets = _assets.length;\r\n        uint256 numPrices = _requestedPriceMantissas.length;\r\n        uint256[] memory result;\r\n\r\n        // Fail when msg.sender is not poster\r\n        if (msg.sender != poster) {\r\n            result = new uint256[](1);\r\n            result[0] = failOracle(\r\n                address(0),\r\n                OracleError.UNAUTHORIZED,\r\n                OracleFailureInfo.SET_PRICE_PERMISSION_CHECK\r\n            );\r\n            return result;\r\n        }\r\n\r\n        if ((numAssets == 0) || (numPrices != numAssets)) {\r\n            result = new uint256[](1);\r\n            result[0] = failOracle(\r\n                address(0),\r\n                OracleError.FAILED_TO_SET_PRICE,\r\n                OracleFailureInfo.SET_PRICES_PARAM_VALIDATION\r\n            );\r\n            return result;\r\n        }\r\n\r\n        result = new uint256[](numAssets);\r\n\r\n        for (uint256 i = 0; i < numAssets; i++) {\r\n            result[i] = setPriceInternal(_assets[i], _requestedPriceMantissas[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poster\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxSwing\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anchorPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cappedPriceMantissa\",\"type\":\"uint256\"}],\"name\":\"CappedPricePosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAnchorAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAnchorAdmin\",\"type\":\"address\"}],\"name\":\"NewAnchorAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"anchorAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldScaledPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newScaledPrice\",\"type\":\"uint256\"}],\"name\":\"NewPendingAnchor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAnchorAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAnchorAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAnchorAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPoster\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPoster\",\"type\":\"address\"}],\"name\":\"NewPoster\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"OracleFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedPriceMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriceMantissa\",\"type\":\"uint256\"}],\"name\":\"PricePosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldReader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"decimalsDifference\",\"type\":\"int256\"}],\"name\":\"ReaderPosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"SetAssetAggregator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IStatusOracle\",\"name\":\"statusOracle\",\"type\":\"address\"}],\"name\":\"SetAssetStatusOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangeRateModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSwingRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSwingDuration\",\"type\":\"uint256\"}],\"name\":\"SetExchangeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSwing\",\"type\":\"uint256\"}],\"name\":\"SetMaxSwing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSwing\",\"type\":\"uint256\"}],\"name\":\"SetMaxSwingForAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxSwingRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxSwingRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSwingDuration\",\"type\":\"uint256\"}],\"name\":\"SetMaxSwingRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"SetPaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAXIMUM_SWING\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_SWING\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_acceptAnchorAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_assetPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"_disableAssetAggregator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"}],\"name\":\"_disableAssetAggregatorBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"_disableAssetStatusOracle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"}],\"name\":\"_disableAssetStatusOracleBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"_disableExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"contract IAggregator\",\"name\":\"_aggregator\",\"type\":\"address\"}],\"name\":\"_setAssetAggregator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"contract IAggregator[]\",\"name\":\"_aggregators\",\"type\":\"address[]\"}],\"name\":\"_setAssetAggregatorBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"contract IStatusOracle\",\"name\":\"_statusOracle\",\"type\":\"address\"}],\"name\":\"_setAssetStatusOracle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"contract IStatusOracle[]\",\"name\":\"_statusOracles\",\"type\":\"address[]\"}],\"name\":\"_setAssetStatusOracleBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSwing\",\"type\":\"uint256\"}],\"name\":\"_setMaxSwing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxSwing\",\"type\":\"uint256\"}],\"name\":\"_setMaxSwingForAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_maxSwings\",\"type\":\"uint256[]\"}],\"name\":\"_setMaxSwingForAssetBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_requestedState\",\"type\":\"bool\"}],\"name\":\"_setPaused\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newScaledPrice\",\"type\":\"uint256\"}],\"name\":\"_setPendingAnchor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPendingAnchorAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAnchorAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPoster\",\"type\":\"address\"}],\"name\":\"_setPoster\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"aggregator\",\"outputs\":[{\"internalType\":\"contract IAggregator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"anchorAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"anchors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceMantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangeRates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"exchangeRateModel\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwingRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwingDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getAssetAggregatorPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getAssetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getAssetPriceStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"getExchangeRateInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getReaderPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getUnderlyingPriceAndStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSwing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSwingMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxSwings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mantissa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numBlocksPerPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAnchorAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingAnchors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"readers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"decimalsDifference\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeRateModel\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxSwingDuration\",\"type\":\"uint256\"}],\"name\":\"setExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxSwingDuration\",\"type\":\"uint256\"}],\"name\":\"setMaxSwingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requestedPriceMantissa\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_requestedPriceMantissas\",\"type\":\"uint256[]\"}],\"name\":\"setPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_readAsset\",\"type\":\"address\"}],\"name\":\"setReaders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"statusOracle\",\"outputs\":[{\"internalType\":\"contract IStatusOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"PriceOracle","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006f43161e3a56501ea14b2901132a4d9f0945e179000000000000000000000000000000000000000000000000016345785d8a0000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://40395f9d4f7b9173d89f35dcb5820288d7c8564dc35538727efacfaccdacd25f"}]}