{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface AggregatorValidatorInterface {\r\n  function validate(\r\n    uint256 previousRoundId,\r\n    int256 previousAnswer,\r\n    uint256 currentRoundId,\r\n    int256 currentAnswer\r\n  )\r\n    external\r\n    returns (\r\n      bool\r\n    );\r\n}\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwner {\r\n\r\n  address private s_owner;\r\n  address private s_pendingOwner;\r\n\r\n  event OwnershipTransferRequested(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n  event OwnershipTransferred(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n\r\n  constructor(address newOwner) {\r\n    s_owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(\r\n    address to\r\n  )\r\n    external\r\n    onlyOwner()\r\n  {\r\n    require(to != msg.sender, \"Cannot transfer to self\");\r\n\r\n    s_pendingOwner = to;\r\n\r\n    emit OwnershipTransferRequested(s_owner, to);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership()\r\n    external\r\n  {\r\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = s_owner;\r\n    s_owner = msg.sender;\r\n    s_pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the current owner\r\n   */\r\n  function owner()\r\n    public\r\n    view\r\n    returns (\r\n      address\r\n    )\r\n  {\r\n    return s_owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == s_owner, \"Only callable by owner\");\r\n    _;\r\n  }\r\n\r\n}\r\n\r\ncontract ValidatorProxy is AggregatorValidatorInterface, ConfirmedOwner {\r\n\r\n  /// @notice Uses a single storage slot to store the current address\r\n  struct ProxyConfiguration {\r\n    address target;\r\n    bool hasNewProposal;\r\n  }\r\n\r\n  // Configuration for the current aggregator\r\n  ProxyConfiguration private s_currentAggregator;\r\n  // Proposed aggregator address\r\n  address private s_proposedAggregator;\r\n\r\n  // Configuration for the current validator\r\n  ProxyConfiguration private s_currentValidator;\r\n  // Proposed validator address\r\n  address private s_proposedValidator;\r\n\r\n  event AggregatorProposed(\r\n    address indexed aggregator\r\n  );\r\n  event AggregatorUpgraded(\r\n    address indexed previous,\r\n    address indexed current\r\n  );\r\n  event ValidatorProposed(\r\n    address indexed validator\r\n  );\r\n  event ValidatorUpgraded(\r\n    address indexed previous,\r\n    address indexed current\r\n  );\r\n  /// @notice The proposed aggregator called validate, but the call was not passed on to any validators\r\n  event ProposedAggregatorValidateCall(\r\n    address indexed proposed,\r\n    uint256 previousRoundId,\r\n    int256 previousAnswer,\r\n    uint256 currentRoundId,\r\n    int256 currentAnswer\r\n  );\r\n\r\n  /**\r\n   * @notice Construct the ValidatorProxy with an aggregator and a validator\r\n   * @param aggregator address\r\n   * @param validator address\r\n   */\r\n  constructor(\r\n    address aggregator,\r\n    address validator\r\n  )\r\n    ConfirmedOwner(msg.sender)\r\n  {\r\n    s_currentAggregator.target = aggregator;\r\n    s_currentValidator.target = validator;\r\n  }\r\n\r\n  /**\r\n   * @notice Validate a transmission\r\n   * @dev Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`.\r\n   * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target`\r\n   * and the `s_proposedValidator`, if it is set.\r\n   * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that\r\n   * the call was received.\r\n   * @param previousRoundId uint256\r\n   * @param previousAnswer int256\r\n   * @param currentRoundId uint256\r\n   * @param currentAnswer int256\r\n   * @return bool\r\n   */\r\n  function validate(\r\n    uint256 previousRoundId,\r\n    int256 previousAnswer,\r\n    uint256 currentRoundId,\r\n    int256 currentAnswer\r\n  )\r\n    external\r\n    override\r\n    returns (\r\n      bool\r\n    )\r\n  {\r\n    address currentAggregator = s_currentAggregator.target;\r\n    address proposedAggregator = s_proposedAggregator;\r\n    require(msg.sender == currentAggregator || msg.sender == proposedAggregator, \"Not a configured aggregator\");\r\n    // If the aggregator is still in proposed state, emit an event and don't push to any validator.\r\n    // This is to confirm that `validate` is being called prior to upgrade.\r\n    if (msg.sender == proposedAggregator) {\r\n      emit ProposedAggregatorValidateCall(\r\n        proposedAggregator,\r\n        previousRoundId,\r\n        previousAnswer,\r\n        currentRoundId,\r\n        currentAnswer\r\n      );\r\n      return true;\r\n    }\r\n\r\n    // Send the validate call to the current validator\r\n    ProxyConfiguration memory currentValidator = s_currentValidator;\r\n    require(s_currentValidator.target != address(0), \"No validator set\");\r\n    AggregatorValidatorInterface(currentValidator.target).validate(\r\n      previousRoundId,\r\n      previousAnswer,\r\n      currentRoundId,\r\n      currentAnswer\r\n    );\r\n    // If there is a new proposed validator, send the validate call to that validator also\r\n    if (currentValidator.hasNewProposal) {\r\n      AggregatorValidatorInterface(s_proposedValidator).validate(\r\n        previousRoundId,\r\n        previousAnswer,\r\n        currentRoundId,\r\n        currentAnswer\r\n      );\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** AGGREGATOR CONFIGURATION FUNCTIONS **/\r\n\r\n  /**\r\n   * @notice Propose an aggregator\r\n   * @dev A zero address can be used to unset the proposed aggregator. Only owner can call.\r\n   * @param proposed address\r\n   */\r\n  function proposeNewAggregator(\r\n    address proposed\r\n  )\r\n    external\r\n    onlyOwner()\r\n  {\r\n    s_proposedAggregator = proposed;\r\n    // If proposed is zero address, hasNewProposal = false\r\n    s_currentAggregator.hasNewProposal = (proposed != address(0));\r\n    emit AggregatorProposed(proposed);\r\n  }\r\n\r\n  /**\r\n   * @notice Upgrade the aggregator by setting the current aggregator as the proposed aggregator.\r\n   * @dev Must have a proposed aggregator. Only owner can call.\r\n   */\r\n  function upgradeAggregator()\r\n    external\r\n    onlyOwner()\r\n  {\r\n    // Get configuration in memory\r\n    ProxyConfiguration memory current = s_currentAggregator;\r\n    address previous = current.target;\r\n    address proposed = s_proposedAggregator;\r\n\r\n    // Perform the upgrade\r\n    require(current.hasNewProposal == true, \"No proposal\");\r\n    current.target = proposed;\r\n    current.hasNewProposal = false;\r\n\r\n    s_currentAggregator = current;\r\n    s_proposedAggregator = address(0);\r\n\r\n    emit AggregatorUpgraded(previous, proposed);\r\n  }\r\n\r\n  /**\r\n   * @notice Get aggregator details\r\n   * @return current address\r\n   * @return hasProposal bool\r\n   * @return proposed address\r\n   */\r\n  function getAggregators()\r\n    external\r\n    view\r\n    returns(\r\n      address current,\r\n      bool hasProposal,\r\n      address proposed\r\n    )\r\n  {\r\n    current = s_currentAggregator.target;\r\n    hasProposal = s_currentAggregator.hasNewProposal;\r\n    proposed = s_proposedAggregator;\r\n  }\r\n\r\n  /** VALIDATOR CONFIGURATION FUNCTIONS **/\r\n\r\n  /**\r\n   * @notice Propose an validator\r\n   * @dev A zero address can be used to unset the proposed validator. Only owner can call.\r\n   * @param proposed address\r\n   */\r\n  function proposeNewValidator(\r\n    address proposed\r\n  )\r\n    external\r\n    onlyOwner()\r\n  {\r\n    s_proposedValidator = proposed;\r\n    // If proposed is zero address, hasNewProposal = false\r\n    s_currentValidator.hasNewProposal = (proposed != address(0));\r\n    emit ValidatorProposed(proposed);\r\n  }\r\n\r\n  /**\r\n   * @notice Upgrade the validator by setting the current validator as the proposed validator.\r\n   * @dev Must have a proposed validator. Only owner can call.\r\n   */\r\n  function upgradeValidator()\r\n    external\r\n    onlyOwner()\r\n  {\r\n    // Get configuration in memory\r\n    ProxyConfiguration memory current = s_currentValidator;\r\n    address previous = current.target;\r\n    address proposed = s_proposedValidator;\r\n\r\n    // Perform the upgrade\r\n    require(current.hasNewProposal == true, \"No proposal\");\r\n    current.target = proposed;\r\n    current.hasNewProposal = false;\r\n\r\n    s_currentValidator = current;\r\n    s_proposedValidator = address(0);\r\n\r\n    emit ValidatorUpgraded(previous, proposed);\r\n  }\r\n\r\n  /**\r\n   * @notice Get validator details\r\n   * @return current address\r\n   * @return hasProposal bool\r\n   * @return proposed address\r\n   */\r\n  function getValidators()\r\n    external\r\n    view\r\n    returns(\r\n      address current,\r\n      bool hasProposal,\r\n      address proposed\r\n    )\r\n  {\r\n    current = s_currentValidator.target;\r\n    hasProposal = s_currentValidator.hasNewProposal;\r\n    proposed = s_proposedValidator;\r\n  }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"AggregatorProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"AggregatorUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"previousAnswer\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"currentAnswer\",\"type\":\"int256\"}],\"name\":\"ProposedAggregatorValidateCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ValidatorProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"ValidatorUpgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAggregators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasProposal\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValidators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasProposal\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"proposeNewAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"proposeNewValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"previousRoundId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"previousAnswer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"currentRoundId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"currentAnswer\",\"type\":\"int256\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ValidatorProxy","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006235b643251401f2c1bf8ce901f09ac84fbc0fcf0000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://05fdf799c562771a505bc4a0f000639845c0bc95d78802150900ef1b22ab23db"}]}