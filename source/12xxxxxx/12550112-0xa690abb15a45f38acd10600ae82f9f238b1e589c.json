{"status":"1","message":"OK","result":[{"SourceCode":"{\"AggregatorV3Interface.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"},\"HoldefiOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.12;\\n\\n/// @title HoldefiOwnable\\n/// @author Holdefi Team\\n/// @notice Taking ideas from Open Zeppelin\\u0027s Ownable contract\\n/// @dev Contract module which provides a basic access control mechanism, where\\n/// there is an account (an owner) that can be granted exclusive access to\\n/// specific functions.\\n///\\n/// By default, the owner account will be the one that deploys the contract. This\\n/// can later be changed with {transferOwnership}.\\n///\\n/// This module is used through inheritance. It will make available the modifier\\n/// `onlyOwner`, which can be applied to your functions to restrict their use to\\n/// the owner.\\ncontract HoldefiOwnable {\\n    address public owner;\\n    address public pendingOwner;\\n\\n    /// @notice Event emitted when an ownership transfer request is recieved\\n    event OwnershipTransferRequested(address newPendingOwner);\\n\\n    /// @notice Event emitted when an ownership transfer request is accepted by the pending owner\\n    event OwnershipTransferred(address newOwner, address oldOwner);\\n\\n    /// @notice Initializes the contract owner\\n    constructor () public {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n\\n    /// @notice Throws if called by any account other than the owner\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Sender should be owner\\\");\\n        _;\\n    }\\n\\n    /// @notice Transfers ownership of the contract to a new owner\\n    /// @dev Can only be called by the current owner\\n    /// @param newOwner Address of new owner\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        require(newOwner != address(0), \\\"New owner can not be zero address\\\");\\n        pendingOwner = newOwner;\\n\\n        emit OwnershipTransferRequested(newOwner);\\n    }\\n\\n    /// @notice Pending owner accepts ownership of the contract\\n    /// @dev Only Pending owner can call this function\\n    function acceptTransferOwnership () external {\\n        require (pendingOwner != address(0), \\\"Pending owner is empty\\\");\\n        require (pendingOwner == msg.sender, \\\"Pending owner is not same as sender\\\");\\n        \\n        emit OwnershipTransferred(pendingOwner, owner);\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n}\"},\"HoldefiPrices.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./AggregatorV3Interface.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./HoldefiOwnable.sol\\\";\\r\\n\\r\\ninterface ERC20DecimalInterface {\\r\\n    function decimals () external view returns(uint256 res);\\r\\n}\\r\\n/// @title HoldefiPrices contract\\r\\n/// @author Holdefi Team\\r\\n/// @notice This contract is for getting tokens price\\r\\n/// @dev This contract uses Chainlink Oracle to get the tokens price\\r\\n/// @dev The address of ETH asset considered as 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\\r\\ncontract HoldefiPrices is HoldefiOwnable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address constant public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\r\\n\\r\\n    uint256 constant public valueDecimals = 30;\\r\\n\\r\\n    struct Asset {\\r\\n        uint256 decimals;\\r\\n        AggregatorV3Interface priceContract;\\r\\n    }\\r\\n   \\r\\n    mapping(address =\\u003e Asset) public assets;\\r\\n\\r\\n    /// @notice Event emitted when a new price aggregator is set for an asset\\r\\n    event NewPriceAggregator(address indexed asset, uint256 decimals, address priceAggregator);\\r\\n\\r\\n\\t/// @notice Initializes ETH decimals\\r\\n    constructor() public {\\r\\n        assets[ethAddress].decimals = 18;\\r\\n    }\\r\\n\\r\\n    /// @notice You cannot send ETH to this contract\\r\\n    receive() payable external {\\r\\n        revert();\\r\\n    }\\r\\n\\r\\n    /// @notice Gets price of selected asset from Chainlink\\r\\n\\t/// @dev The ETH price is assumed to be 1\\r\\n\\t/// @param asset Address of the given asset\\r\\n    /// @return price Price of the given asset\\r\\n    /// @return priceDecimals Decimals of the given asset\\r\\n    function getPrice(address asset) public view returns (uint256 price, uint256 priceDecimals) {\\r\\n        if (asset == ethAddress){\\r\\n            price = 1;\\r\\n            priceDecimals = 0;\\r\\n        }\\r\\n        else {\\r\\n            (,int aggregatorPrice,,,) = assets[asset].priceContract.latestRoundData();\\r\\n            priceDecimals = assets[asset].priceContract.decimals();\\r\\n            if (aggregatorPrice \\u003e 0) {\\r\\n                price = uint(aggregatorPrice);\\r\\n            }\\r\\n            else {\\r\\n                revert();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Sets price aggregator for the given asset \\r\\n\\t/// @param asset Address of the given asset\\r\\n    /// @param decimals Decimals of the given asset\\r\\n    /// @param priceContractAddress Address of asset\\u0027s price aggregator\\r\\n    function setPriceAggregator(address asset, uint256 decimals, AggregatorV3Interface priceContractAddress)\\r\\n        external\\r\\n        onlyOwner\\r\\n    { \\r\\n        require (asset != ethAddress, \\\"Asset should not be ETH\\\");\\r\\n        assets[asset].priceContract = priceContractAddress;\\r\\n\\r\\n        try ERC20DecimalInterface(asset).decimals() returns (uint256 tokenDecimals) {\\r\\n            assets[asset].decimals = tokenDecimals;\\r\\n        }\\r\\n        catch {\\r\\n            assets[asset].decimals = decimals;\\r\\n        }\\r\\n        emit NewPriceAggregator(asset, decimals, address(priceContractAddress));\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the given asset value based on the given amount \\r\\n\\t/// @param asset Address of the given asset\\r\\n    /// @param amount Amount of the given asset\\r\\n    /// @return res Value calculated for asset based on the price and given amount\\r\\n    function getAssetValueFromAmount(address asset, uint256 amount) external view returns (uint256 res) {\\r\\n        uint256 decimalsDiff;\\r\\n        uint256 decimalsScale;\\r\\n\\r\\n        (uint256 price, uint256 priceDecimals) = getPrice(asset);\\r\\n        uint256 calValueDecimals = priceDecimals.add(assets[asset].decimals);\\r\\n        if (valueDecimals \\u003e calValueDecimals){\\r\\n            decimalsDiff = valueDecimals.sub(calValueDecimals);\\r\\n            decimalsScale =  10 ** decimalsDiff;\\r\\n            res = amount.mul(price).mul(decimalsScale);\\r\\n        }\\r\\n        else {\\r\\n            decimalsDiff = calValueDecimals.sub(valueDecimals);\\r\\n            decimalsScale =  10 ** decimalsDiff;\\r\\n            res = amount.mul(price).div(decimalsScale);\\r\\n        }   \\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the given amount based on the given asset value\\r\\n    /// @param asset Address of the given asset\\r\\n    /// @param value Value of the given asset\\r\\n    /// @return res Amount calculated for asset based on the price and given value\\r\\n    function getAssetAmountFromValue(address asset, uint256 value) external view returns (uint256 res) {\\r\\n        uint256 decimalsDiff;\\r\\n        uint256 decimalsScale;\\r\\n\\r\\n        (uint256 price, uint256 priceDecimals) = getPrice(asset);\\r\\n        uint256 calValueDecimals = priceDecimals.add(assets[asset].decimals);\\r\\n        if (valueDecimals \\u003e calValueDecimals){\\r\\n            decimalsDiff = valueDecimals.sub(calValueDecimals);\\r\\n            decimalsScale =  10 ** decimalsDiff;\\r\\n            res = value.div(decimalsScale).div(price);\\r\\n        }\\r\\n        else {\\r\\n            decimalsDiff = calValueDecimals.sub(valueDecimals);\\r\\n            decimalsScale =  10 ** decimalsDiff;\\r\\n            res = value.mul(decimalsScale).div(price);\\r\\n        }   \\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c \\u003c a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b \\u003e a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceAggregator\",\"type\":\"address\"}],\"name\":\"NewPriceAggregator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"priceContract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getAssetAmountFromValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getAssetValueFromAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceDecimals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"priceContractAddress\",\"type\":\"address\"}],\"name\":\"setPriceAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"valueDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"HoldefiPrices","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://eeaa0b372932f760c0c4fa8bdd833017cdc1920b5110d9681680d97d2d19689d"}]}