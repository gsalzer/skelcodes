{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.8.0;\r\n\r\n// NOTE: this interface lacks return values for transfer/transferFrom/approve on purpose,\r\n// as we use the SafeERC20 library to check the return value\r\ninterface GeneralERC20 {\r\n\tfunction transfer(address to, uint256 amount) external;\r\n\tfunction transferFrom(address from, address to, uint256 amount) external;\r\n\tfunction approve(address spender, uint256 amount) external;\r\n\tfunction balanceOf(address spender) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n\tfunction checkSuccess()\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bool)\r\n\t{\r\n\t\tuint256 returnValue = 0;\r\n\r\n\t\tassembly {\r\n\t\t\t// check number of bytes returned from last function call\r\n\t\t\tswitch returndatasize()\r\n\r\n\t\t\t// no bytes returned: assume success\r\n\t\t\tcase 0x0 {\r\n\t\t\t\treturnValue := 1\r\n\t\t\t}\r\n\r\n\t\t\t// 32 bytes returned: check if non-zero\r\n\t\t\tcase 0x20 {\r\n\t\t\t\t// copy 32 bytes into scratch space\r\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\r\n\r\n\t\t\t\t// load those bytes into returnValue\r\n\t\t\t\treturnValue := mload(0x0)\r\n\t\t\t}\r\n\r\n\t\t\t// not sure what was returned: don't mark as success\r\n\t\t\tdefault { }\r\n\t\t}\r\n\r\n\t\treturn returnValue != 0;\r\n\t}\r\n\r\n\tfunction transfer(address token, address to, uint256 amount) internal {\r\n\t\tGeneralERC20(token).transfer(to, amount);\r\n\t\trequire(checkSuccess(), \"SafeERC20: transfer failed\");\r\n\t}\r\n\r\n\tfunction transferFrom(address token, address from, address to, uint256 amount) internal {\r\n\t\tGeneralERC20(token).transferFrom(from, to, amount);\r\n\t\trequire(checkSuccess(), \"SafeERC20: transferFrom failed\");\r\n\t}\r\n\r\n\tfunction approve(address token, address spender, uint256 amount) internal {\r\n\t\tGeneralERC20(token).approve(spender, amount);\r\n\t\trequire(checkSuccess(), \"SafeERC20: approve failed\");\r\n\t}\r\n}\r\n\r\nlibrary SignatureValidator {\r\n\tenum SignatureMode {\r\n\t\tNO_SIG,\r\n\t\tEIP712,\r\n\t\tGETH,\r\n\t\tTREZOR,\r\n\t\tADEX\r\n\t}\r\n\r\n\tfunction recoverAddr(bytes32 hash, bytes32[3] memory signature) internal pure returns (address) {\r\n\t\tSignatureMode mode = SignatureMode(uint8(signature[0][0]));\r\n\r\n\t\tif (mode == SignatureMode.NO_SIG) {\r\n\t\t\treturn address(0x0);\r\n\t\t}\r\n\r\n\t\tuint8 v = uint8(signature[0][1]);\r\n\r\n\t\tif (mode == SignatureMode.GETH) {\r\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\t\t} else if (mode == SignatureMode.TREZOR) {\r\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\\x20\", hash));\r\n\t\t} else if (mode == SignatureMode.ADEX) {\r\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n108By signing this message, you acknowledge signing an AdEx bid with the hash:\\n\", hash));\r\n\t\t}\r\n\r\n\t\treturn ecrecover(hash, v, signature[1], signature[2]);\r\n\t}\r\n\r\n\t/// @dev Validates that a hash was signed by a specified signer.\r\n\t/// @param hash Hash which was signed.\r\n\t/// @param signer Address of the signer.\r\n\t/// @param signature ECDSA signature along with the mode [{mode}{v}, {r}, {s}]\r\n\t/// @return Returns whether signature is from a specified user.\r\n\tfunction isValid(bytes32 hash, address signer, bytes32[3] memory signature) internal pure returns (bool) {\r\n\t\treturn recoverAddr(hash, signature) == signer;\r\n\t}\r\n\r\n\t/// @notice Recover the signer of hash, assuming it's an EOA account\r\n\t/// @dev Only for EthSign signatures\r\n\t/// @param hash       Hash of message that was signed\r\n\t/// @param signature  Signature encoded as (bytes32 r, bytes32 s, uint8 v)\r\n\t/// @return Returns an address of the user who signed\r\n\tfunction recoverAddrBytes(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n\t\t// only implements case 65: r,s,v signature (standard)\r\n\t\t// see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d3c5bdf4def690228b08e0ac431437288a50e64a/contracts/utils/cryptography/ECDSA.sol#L32\r\n\t\trequire(signature.length == 65, \"SignatureValidator: invalid signature length\");\r\n\r\n\t\tbytes32 r;\r\n\t\tbytes32 s;\r\n\t\tuint8 v;\r\n\t\tassembly {\r\n\t\t\tr := mload(add(signature, 0x20))\r\n\t\t\ts := mload(add(signature, 0x40))\r\n\t\t\tv := byte(0, mload(add(signature, 0x60)))\r\n\t\t}\r\n\r\n\t\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n\t\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n\t\t// the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n\t\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n\t\t//\r\n\t\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n\t\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n\t\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n\t\t// these malleable signatures as well.\r\n\t\t//\r\n\t\t// Source OpenZeppelin\r\n\t\t// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\r\n\t\trequire(\r\n\t\t\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\r\n\t\t\t\"SignatureValidator: invalid signature 's' value\"\r\n\t\t);\r\n\t\trequire(v == 27 || v == 28, \"SignatureValidator: invalid signature 'v' value\");\r\n\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\t\treturn ecrecover(hash, v, r, s);\r\n\t}\r\n}\r\n\r\n\r\ncontract Identity {\r\n\r\n\tmapping (address => bool) public privileges;\r\n\t// The next allowed nonce\r\n\tuint public nonce = 0;\r\n\r\n\t// Events\r\n\tevent LogPrivilegeChanged(address indexed addr, bool priv);\r\n\r\n\t// Transaction structure\r\n\t// Those can be executed by keys with >= PrivilegeLevel.Transactions\r\n\t// Even though the contract cannot receive ETH, we are able to send ETH (.value), cause ETH might've been sent to the contract address before it's deployed\r\n\tstruct Transaction {\r\n\t\t// replay protection\r\n\t\taddress identityContract;\r\n\t\t// The nonce is also part of the replay protection, when signing Transaction objects we need to ensure they can be ran only once\r\n\t\t// this means it doesn't apply to executeBySender\r\n\t\tuint nonce;\r\n\t\t// tx fee, in tokens\r\n\t\taddress feeTokenAddr;\r\n\t\tuint feeAmount;\r\n\t\t// all the regular txn data\r\n\t\taddress to;\r\n\t\tuint value;\r\n\t\tbytes data;\r\n\t}\r\n\r\n\tconstructor(address[] memory addrs) {\r\n\t\tuint len = addrs.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\tprivileges[addrs[i]] = true;\r\n\t\t\temit LogPrivilegeChanged(addrs[i], true);\r\n\t\t}\r\n\t}\r\n\r\n\t// This contract can accept ETH without calldata\r\n\treceive() external payable {}\r\n\r\n\t// This contract can accept ETH with calldata\r\n\tfallback() external payable {}\r\n\r\n\tfunction setAddrPrivilege(address addr, bool priv)\r\n\t\texternal\r\n\t{\r\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\r\n\t\tprivileges[addr] = priv;\r\n\t\temit LogPrivilegeChanged(addr, priv);\r\n\t}\r\n\r\n\tfunction tipMiner(uint amount)\r\n\t\texternal\r\n\t{\r\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\r\n\t\t// See https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment/#managing-payments-to-coinbaseaddress-when-it-is-a-contract\r\n\t\t// generally this contract is reentrancy proof cause of the nonce\r\n\t\texecuteCall(block.coinbase, amount, new bytes(0));\r\n\t}\r\n\r\n\tfunction execute(Transaction[] memory txns, bytes32[3][] memory signatures)\r\n\t\tpublic\r\n\t{\r\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\r\n\t\taddress feeTokenAddr = txns[0].feeTokenAddr;\r\n\t\tuint feeAmount = 0;\r\n\t\tuint len = txns.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\tTransaction memory txn = txns[i];\r\n\t\t\trequire(txn.identityContract == address(this), 'TRANSACTION_NOT_FOR_CONTRACT');\r\n\t\t\trequire(txn.feeTokenAddr == feeTokenAddr, 'EXECUTE_NEEDS_SINGLE_TOKEN');\r\n\t\t\trequire(txn.nonce == nonce, 'WRONG_NONCE');\r\n\r\n\t\t\t// If we use the naive abi.encode(txn) and have a field of type `bytes`,\r\n\t\t\t// there is a discrepancy between ethereumjs-abi and solidity\r\n\t\t\t// if we enter every field individually, in order, there is no discrepancy\r\n\t\t\t//bytes32 hash = keccak256(abi.encode(txn));\r\n\t\t\tbytes32 hash = keccak256(abi.encode(txn.identityContract, txn.nonce, txn.feeTokenAddr, txn.feeAmount, txn.to, txn.value, txn.data));\r\n\t\t\taddress signer = SignatureValidator.recoverAddr(hash, signatures[i]);\r\n\r\n\t\t\trequire(privileges[signer] == true, 'INSUFFICIENT_PRIVILEGE_TRANSACTION');\r\n\r\n\t\t\t// NOTE: we have to change nonce on every txn: do not be tempted to optimize this by incrementing it once by the full txn count\r\n\t\t\t// otherwise reentrancies are possible, and/or anyone who is reading nonce within a txn will read a wrong value\r\n\t\t\tnonce = nonce + 1;\r\n\t\t\tfeeAmount = feeAmount + txn.feeAmount;\r\n\r\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\r\n\t\t\t// The actual anti-bricking mechanism - do not allow a signer to drop his own priviledges\r\n\t\t\trequire(privileges[signer] == true, 'PRIVILEGE_NOT_DOWNGRADED');\r\n\t\t}\r\n\t\tif (feeAmount > 0) {\r\n\t\t\tSafeERC20.transfer(feeTokenAddr, msg.sender, feeAmount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction executeBySender(Transaction[] memory txns)\r\n\t\tpublic\r\n\t{\r\n\t\trequire(privileges[msg.sender] == true || msg.sender == address(this), 'INSUFFICIENT_PRIVILEGE_SENDER');\r\n\t\tuint len = txns.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\tTransaction memory txn = txns[i];\r\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\r\n\t\t}\r\n\t\t// The actual anti-bricking mechanism - do not allow the sender to drop his own priviledges\r\n\t\trequire(privileges[msg.sender] == true, 'PRIVILEGE_NOT_DOWNGRADED');\r\n\t}\r\n\r\n\t// we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884\r\n\t// copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\r\n\t// there's also\r\n\t// https://github.com/gnosis/MultiSigWallet/commit/e1b25e8632ca28e9e9e09c81bd20bf33fdb405ce\r\n\t// https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol\r\n\t// https://github.com/gnosis/safe-contracts/blob/7e2eeb3328bb2ae85c36bc11ea6afc14baeb663c/contracts/base/Executor.sol\r\n\tfunction executeCall(address to, uint256 value, bytes memory data)\r\n\t\tinternal\r\n\t{\r\n\t\tassembly {\r\n\t\t\tlet result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\r\n\r\n\t\t\tswitch result case 0 {\r\n\t\t\t\tlet size := returndatasize()\r\n\t\t\t\tlet ptr := mload(0x40)\r\n\t\t\t\treturndatacopy(ptr, 0, size)\r\n\t\t\t\trevert(ptr, size)\r\n\t\t\t}\r\n\t\t\tdefault {}\r\n\t\t}\r\n\t}\r\n\r\n\t// EIP 1271 implementation\r\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\r\n\t\tif (privileges[SignatureValidator.recoverAddrBytes(hash, signature)]) {\r\n\t\t\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n\t\t\treturn 0x1626ba7e;\r\n\t\t} else {\r\n\t\t\treturn 0xffffffff;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\ncontract IdentityFactory {\r\n\tevent LogDeployed(address addr, uint256 salt);\r\n\r\n\taddress public creator;\r\n\tconstructor() {\r\n\t\tcreator = msg.sender;\r\n\t}\r\n\r\n\tfunction deploy(bytes memory code, uint256 salt) public {\r\n\t\tdeploySafe(code, salt);\r\n\t}\r\n\r\n\t// When the relayer needs to act upon an /execute call, it'll either call execute on the Identity directly\r\n\t// if it's already deployed, or call `deployAndExecute` if the account is still counterfactual\r\n\t// can't have deployAndExecuteBySender, because the sender will be the factory\r\n\tfunction deployAndExecute(\r\n\t\tbytes memory code, uint256 salt,\r\n\t\tIdentity.Transaction[] memory txns, bytes32[3][] memory signatures\r\n\t) public {\r\n\t\taddress payable addr = payable(deploySafe(code, salt));\r\n\t\tIdentity(addr).execute(txns, signatures);\r\n\t}\r\n\r\n\t// Withdraw the earnings from various fees (deploy fees and execute fees earned cause of `deployAndExecute`)\r\n\tfunction withdraw(address tokenAddr, address to, uint256 tokenAmount) public {\r\n\t\trequire(msg.sender == creator, 'ONLY_CREATOR');\r\n\t\tSafeERC20.transfer(tokenAddr, to, tokenAmount);\r\n\t}\r\n\r\n\t// This is done to mitigate possible frontruns where, for example, deploying the same code/salt via deploy()\r\n\t// would make a pending deployAndExecute fail\r\n\t// The way we mitigate that is by checking if the contract is already deployed and if so, we continue execution\r\n\tfunction deploySafe(bytes memory code, uint256 salt) internal returns (address) {\r\n\t\taddress expectedAddr = address(uint160(uint256(\r\n\t\t\tkeccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)))\r\n\t\t)));\r\n\t\tuint size;\r\n\t\tassembly { size := extcodesize(expectedAddr) }\r\n\t\t// If there is code at that address, we can assume it's the one we were about to deploy,\r\n\t\t// because of how CREATE2 and keccak256 works\r\n\t\tif (size == 0) {\r\n\t\t\taddress addr;\r\n\t\t\tassembly { addr := create2(0, add(code, 0x20), mload(code), salt) }\r\n\t\t\trequire(addr != address(0), 'FAILED_DEPLOYING');\r\n\t\t\trequire(addr == expectedAddr, 'FAILED_MATCH');\r\n\t\t\temit LogDeployed(addr, salt);\r\n\t\t}\r\n\t\treturn expectedAddr;\r\n\t}\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"LogDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"code\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"deploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"code\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"identityContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeTokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Identity.Transaction[]\",\"name\":\"txns\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32[3][]\",\"name\":\"signatures\",\"type\":\"bytes32[3][]\"}],\"name\":\"deployAndExecute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"IdentityFactory","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0ce79cbf14878be8f9afbc91de6247a3d1cd915c541085e90c39adc491dda820"}]}