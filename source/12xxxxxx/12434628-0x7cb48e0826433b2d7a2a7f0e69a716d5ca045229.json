{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/auction/AuctionHouse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"./Staged.sol\\\";\\nimport \\\"./AuctionHouseMath.sol\\\";\\n\\nimport \\\"./interfaces/IAuctionHouse.sol\\\";\\n\\nimport \\\"../funds/interfaces/basket/IBasketReader.sol\\\";\\nimport \\\"../oracle/interfaces/ITwap.sol\\\";\\nimport \\\"../policy/interfaces/IMonetaryPolicy.sol\\\";\\nimport \\\"../tokens/interfaces/ISupplyControlledERC20.sol\\\";\\n\\nimport \\\"../lib/BasisMath.sol\\\";\\nimport \\\"../lib/BlockNumber.sol\\\";\\nimport \\\"../lib/Recoverable.sol\\\";\\nimport \\\"../external-lib/SafeDecimalMath.sol\\\";\\nimport \\\"../tokens/SafeSupplyControlledERC20.sol\\\";\\n\\n/**\\n * @title Float Protocol Auction House\\n * @notice The contract used to sell or buy FLOAT\\n * @dev This contract does not store any assets, except for protocol fees, hence\\n * it implements an asset recovery functionality (Recoverable).\\n */\\ncontract AuctionHouse is\\n  IAuctionHouse,\\n  BlockNumber,\\n  AuctionHouseMath,\\n  AccessControl,\\n  Staged,\\n  Recoverable\\n{\\n  using SafeMath for uint256;\\n  using SafeDecimalMath for uint256;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for ISupplyControlledERC20;\\n  using SafeSupplyControlledERC20 for ISupplyControlledERC20;\\n  using BasisMath for uint256;\\n\\n  /* ========== CONSTANTS ========== */\\n  bytes32 public constant GOVERNANCE_ROLE = keccak256(\\\"GOVERNANCE_ROLE\\\");\\n\\n  IERC20 internal immutable weth;\\n  ISupplyControlledERC20 internal immutable bank;\\n  ISupplyControlledERC20 internal immutable float;\\n  IBasketReader internal immutable basket;\\n\\n  /* ========== STATE VARIABLES ========== */\\n  // Monetary Policy Contract that decides the target price\\n  IMonetaryPolicy internal monetaryPolicy;\\n  // Provides the BANK-ETH Time Weighted Average Price (TWAP) [e27]\\n  ITwap internal bankEthOracle;\\n  // Provides the FLOAT-ETH Time Weighted Average Price (TWAP) [e27]\\n  ITwap internal floatEthOracle;\\n\\n  /// @inheritdoc IAuctionHouseState\\n  uint16 public override buffer = 10_00; // 10% default\\n\\n  /// @inheritdoc IAuctionHouseState\\n  uint16 public override protocolFee = 5_00; // 5% / 500 bps\\n\\n  /// @inheritdoc IAuctionHouseState\\n  uint32 public override allowanceCap = 10_00; // 10% / 1000 bps\\n\\n  /// @inheritdoc IAuctionHouseVariables\\n  uint64 public override round;\\n\\n  /**\\n   * @notice Allows for monetary policy updates to be enabled and disabled.\\n   */\\n  bool public shouldUpdatePolicy = true;\\n\\n  /**\\n   * Note that we choose to freeze all price values at the start of an auction.\\n   * These values are stale _by design_. The burden of price checking\\n   * is moved to the arbitrager, already vital for them to make a profit.\\n   * We don't mind these values being out of date, as we start the auctions from a position generously in favour of the protocol (assuming our target price is correct). If these market values are stale, then profit opportunity will start earlier / later, and hence close out a mispriced auction early.\\n   * We also start the auctions at `buffer`% of the price.\\n   */\\n\\n  /// @inheritdoc IAuctionHouseVariables\\n  mapping(uint64 => Auction) public override auctions;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  constructor(\\n    // Dependencies\\n    address _weth,\\n    address _bank,\\n    address _float,\\n    address _basket,\\n    address _monetaryPolicy,\\n    address _gov,\\n    address _bankEthOracle,\\n    address _floatEthOracle,\\n    // Parameters\\n    uint16 _auctionDuration,\\n    uint32 _auctionCooldown,\\n    uint256 _firstAuctionBlock\\n  ) Staged(_auctionDuration, _auctionCooldown, _firstAuctionBlock) {\\n    // Tokens\\n    weth = IERC20(_weth);\\n    bank = ISupplyControlledERC20(_bank);\\n    float = ISupplyControlledERC20(_float);\\n\\n    // Basket\\n    basket = IBasketReader(_basket);\\n\\n    // Monetary Policy\\n    monetaryPolicy = IMonetaryPolicy(_monetaryPolicy);\\n    floatEthOracle = ITwap(_floatEthOracle);\\n    bankEthOracle = ITwap(_bankEthOracle);\\n\\n    emit ModifyParameters(\\\"monetaryPolicy\\\", _monetaryPolicy);\\n    emit ModifyParameters(\\\"floatEthOracle\\\", _floatEthOracle);\\n    emit ModifyParameters(\\\"bankEthOracle\\\", _bankEthOracle);\\n\\n    emit ModifyParameters(\\\"auctionDuration\\\", _auctionDuration);\\n    emit ModifyParameters(\\\"auctionCooldown\\\", _auctionCooldown);\\n    emit ModifyParameters(\\\"lastAuctionBlock\\\", lastAuctionBlock);\\n    emit ModifyParameters(\\\"buffer\\\", buffer);\\n    emit ModifyParameters(\\\"protocolFee\\\", protocolFee);\\n    emit ModifyParameters(\\\"allowanceCap\\\", allowanceCap);\\n\\n    // Roles\\n    _setupRole(DEFAULT_ADMIN_ROLE, _gov);\\n    _setupRole(GOVERNANCE_ROLE, _gov);\\n    _setupRole(RECOVER_ROLE, _gov);\\n  }\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier onlyGovernance {\\n    require(\\n      hasRole(GOVERNANCE_ROLE, _msgSender()),\\n      \\\"AuctionHouse/GovernanceRole\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier inExpansion {\\n    require(\\n      latestAuction().stabilisationCase == Cases.Up ||\\n        latestAuction().stabilisationCase == Cases.Restock,\\n      \\\"AuctionHouse/NotInExpansion\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier inContraction {\\n    require(\\n      latestAuction().stabilisationCase == Cases.Confidence ||\\n        latestAuction().stabilisationCase == Cases.Down,\\n      \\\"AuctionHouse/NotInContraction\\\"\\n    );\\n    _;\\n  }\\n\\n  /* ========== VIEWS ========== */\\n\\n  /// @inheritdoc IAuctionHouseDerivedState\\n  function price()\\n    public\\n    view\\n    override(IAuctionHouseDerivedState)\\n    returns (uint256 wethPrice, uint256 bankPrice)\\n  {\\n    Auction memory _latestAuction = latestAuction();\\n    uint256 _step = step();\\n\\n    wethPrice = lerp(\\n      _latestAuction.startWethPrice,\\n      _latestAuction.endWethPrice,\\n      _step,\\n      auctionDuration\\n    );\\n    bankPrice = lerp(\\n      _latestAuction.startBankPrice,\\n      _latestAuction.endBankPrice,\\n      _step,\\n      auctionDuration\\n    );\\n    return (wethPrice, bankPrice);\\n  }\\n\\n  /// @inheritdoc IAuctionHouseDerivedState\\n  function step()\\n    public\\n    view\\n    override(IAuctionHouseDerivedState)\\n    atStage(Stages.AuctionActive)\\n    returns (uint256)\\n  {\\n    // .sub is unnecessary here - block number >= lastAuctionBlock.\\n    return _blockNumber() - lastAuctionBlock;\\n  }\\n\\n  function _startPrice(\\n    bool expansion,\\n    Cases stabilisationCase,\\n    uint256 targetFloatInEth,\\n    uint256 marketFloatInEth,\\n    uint256 bankInEth,\\n    uint256 basketFactor\\n  ) internal view returns (uint256 wethStart, uint256 bankStart) {\\n    uint256 bufferedMarketPrice =\\n      _bufferedMarketPrice(expansion, marketFloatInEth);\\n\\n    if (stabilisationCase == Cases.Up) {\\n      uint256 bankProportion =\\n        bufferedMarketPrice.sub(targetFloatInEth).divideDecimalRoundPrecise(\\n          bankInEth\\n        );\\n\\n      return (targetFloatInEth, bankProportion);\\n    }\\n\\n    if (\\n      stabilisationCase == Cases.Restock ||\\n      stabilisationCase == Cases.Confidence\\n    ) {\\n      return (bufferedMarketPrice, 0);\\n    }\\n\\n    assert(stabilisationCase == Cases.Down);\\n    assert(basketFactor < SafeDecimalMath.PRECISE_UNIT);\\n    uint256 invertedBasketFactor =\\n      SafeDecimalMath.PRECISE_UNIT.sub(basketFactor);\\n\\n    uint256 basketFactorAdjustedEth =\\n      bufferedMarketPrice.multiplyDecimalRoundPrecise(basketFactor);\\n\\n    // Note that the PRECISE_UNIT factors itself out\\n    uint256 basketFactorAdjustedBank =\\n      bufferedMarketPrice.mul(invertedBasketFactor).div(bankInEth);\\n    return (basketFactorAdjustedEth, basketFactorAdjustedBank);\\n  }\\n\\n  function _endPrice(\\n    Cases stabilisationCase,\\n    uint256 targetFloatInEth,\\n    uint256 bankInEth,\\n    uint256 basketFactor\\n  ) internal pure returns (uint256 wethEnd, uint256 bankEnd) {\\n    if (stabilisationCase == Cases.Down) {\\n      assert(basketFactor < SafeDecimalMath.PRECISE_UNIT);\\n      uint256 invertedBasketFactor =\\n        SafeDecimalMath.PRECISE_UNIT.sub(basketFactor);\\n\\n      uint256 basketFactorAdjustedEth =\\n        targetFloatInEth.multiplyDecimalRoundPrecise(basketFactor);\\n\\n      // Note that the PRECISE_UNIT factors itself out.\\n      uint256 basketFactorAdjustedBank =\\n        targetFloatInEth.mul(invertedBasketFactor).div(bankInEth);\\n      return (basketFactorAdjustedEth, basketFactorAdjustedBank);\\n    }\\n\\n    return (targetFloatInEth, 0);\\n  }\\n\\n  /// @inheritdoc IAuctionHouseDerivedState\\n  function latestAuction()\\n    public\\n    view\\n    override(IAuctionHouseDerivedState)\\n    returns (Auction memory)\\n  {\\n    return auctions[round];\\n  }\\n\\n  /// @dev Returns a buffered [e27] market price, note that buffer is still [e18], so can use divideDecimal.\\n  function _bufferedMarketPrice(bool expansion, uint256 marketPrice)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    uint256 factor =\\n      expansion\\n        ? BasisMath.FULL_PERCENT.add(buffer)\\n        : BasisMath.FULL_PERCENT.sub(buffer);\\n    return marketPrice.percentageOf(factor);\\n  }\\n\\n  /// @dev Calculates the current case based on if we're expanding and basket factor.\\n  function _currentCase(bool expansion, uint256 basketFactor)\\n    internal\\n    pure\\n    returns (Cases)\\n  {\\n    bool underlyingDemand = basketFactor >= SafeDecimalMath.PRECISE_UNIT;\\n\\n    if (expansion) {\\n      return underlyingDemand ? Cases.Up : Cases.Restock;\\n    }\\n\\n    return underlyingDemand ? Cases.Confidence : Cases.Down;\\n  }\\n\\n  /* |||||||||| AuctionPending |||||||||| */\\n\\n  // solhint-disable function-max-lines\\n  /// @inheritdoc IAuctionHouseActions\\n  function start()\\n    external\\n    override(IAuctionHouseActions)\\n    timedTransition\\n    atStage(Stages.AuctionPending)\\n    returns (uint64 newRound)\\n  {\\n    // Check we have up to date oracles, this also ensures we don't have\\n    // auctions too close together (reverts based upon timeElapsed < periodSize).\\n    bankEthOracle.update(address(bank), address(weth));\\n    floatEthOracle.update(address(float), address(weth));\\n\\n    // [e27]\\n    uint256 frozenBankInEth =\\n      bankEthOracle.consult(\\n        address(bank),\\n        SafeDecimalMath.PRECISE_UNIT,\\n        address(weth)\\n      );\\n    // [e27]\\n    uint256 frozenFloatInEth =\\n      floatEthOracle.consult(\\n        address(float),\\n        SafeDecimalMath.PRECISE_UNIT,\\n        address(weth)\\n      );\\n\\n    // Update Monetary Policy with previous auction results\\n    if (round != 0 && shouldUpdatePolicy) {\\n      uint256 oldTargetPriceInEth = monetaryPolicy.consult();\\n      uint256 oldBasketFactor = basket.getBasketFactor(oldTargetPriceInEth);\\n\\n      monetaryPolicy.updateGivenAuctionResults(\\n        round,\\n        lastAuctionBlock,\\n        frozenFloatInEth,\\n        oldBasketFactor\\n      );\\n    }\\n\\n    // Round only increments by one on start, given auction period of restriction of 150 blocks\\n    // this means we'd need 2**64 / 150 blocks or ~3.7 lifetimes of the universe to overflow.\\n    // Likely, we'd have upgraded the contract by this point.\\n    round++;\\n\\n    // Calculate target price [e27]\\n    uint256 frozenTargetPriceInEth = monetaryPolicy.consult();\\n\\n    // STC: Pull out to ValidateOracles\\n    require(frozenTargetPriceInEth != 0, \\\"AuctionHouse/TargetSenseCheck\\\");\\n    require(frozenBankInEth != 0, \\\"AuctionHouse/BankSenseCheck\\\");\\n    require(frozenFloatInEth != 0, \\\"AuctionHouse/FloatSenseCheck\\\");\\n    uint256 basketFactor = basket.getBasketFactor(frozenTargetPriceInEth);\\n\\n    bool expansion = frozenFloatInEth >= frozenTargetPriceInEth;\\n    Cases stabilisationCase = _currentCase(expansion, basketFactor);\\n\\n    // Calculate Auction Price points\\n    (uint256 wethStart, uint256 bankStart) =\\n      _startPrice(\\n        expansion,\\n        stabilisationCase,\\n        frozenTargetPriceInEth,\\n        frozenFloatInEth,\\n        frozenBankInEth,\\n        basketFactor\\n      );\\n\\n    (uint256 wethEnd, uint256 bankEnd) =\\n      _endPrice(\\n        stabilisationCase,\\n        frozenTargetPriceInEth,\\n        frozenBankInEth,\\n        basketFactor\\n      );\\n\\n    // Calculate Allowance\\n    uint256 allowance =\\n      AuctionHouseMath.allowance(\\n        expansion,\\n        allowanceCap,\\n        float.totalSupply(),\\n        frozenFloatInEth,\\n        frozenTargetPriceInEth\\n      );\\n\\n    require(allowance != 0, \\\"AuctionHouse/NoAllowance\\\");\\n\\n    auctions[round].stabilisationCase = stabilisationCase;\\n    auctions[round].targetFloatInEth = frozenTargetPriceInEth;\\n    auctions[round].marketFloatInEth = frozenFloatInEth;\\n    auctions[round].bankInEth = frozenBankInEth;\\n\\n    auctions[round].basketFactor = basketFactor;\\n    auctions[round].allowance = allowance;\\n\\n    auctions[round].startWethPrice = wethStart;\\n    auctions[round].startBankPrice = bankStart;\\n    auctions[round].endWethPrice = wethEnd;\\n    auctions[round].endBankPrice = bankEnd;\\n\\n    lastAuctionBlock = _blockNumber();\\n    _setStage(Stages.AuctionActive);\\n\\n    emit NewAuction(round, allowance, frozenTargetPriceInEth, lastAuctionBlock);\\n\\n    return round;\\n  }\\n\\n  // solhint-enable function-max-lines\\n\\n  /* |||||||||| AuctionActive |||||||||| */\\n\\n  function _updateDelta(uint256 floatDelta) internal {\\n    Auction memory _currentAuction = latestAuction();\\n\\n    require(\\n      floatDelta <= _currentAuction.allowance.sub(_currentAuction.delta),\\n      \\\"AuctionHouse/WithinAllowedDelta\\\"\\n    );\\n\\n    auctions[round].delta = _currentAuction.delta.add(floatDelta);\\n  }\\n\\n  /* |||||||||| AuctionActive:inExpansion |||||||||| */\\n\\n  /// @inheritdoc IAuctionHouseActions\\n  function buy(\\n    uint256 wethInMax,\\n    uint256 bankInMax,\\n    uint256 floatOutMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    override(IAuctionHouseActions)\\n    timedTransition\\n    atStage(Stages.AuctionActive)\\n    inExpansion\\n    returns (\\n      uint256 usedWethIn,\\n      uint256 usedBankIn,\\n      uint256 usedFloatOut\\n    )\\n  {\\n    // solhint-disable-next-line not-rely-on-time\\n    require(block.timestamp <= deadline, \\\"AuctionHouse/TransactionTooOld\\\");\\n\\n    (uint256 wethPrice, uint256 bankPrice) = price();\\n\\n    usedFloatOut = Math.min(\\n      wethInMax.divideDecimalRoundPrecise(wethPrice),\\n      bankPrice == 0\\n        ? type(uint256).max\\n        : bankInMax.divideDecimalRoundPrecise(bankPrice)\\n    );\\n\\n    require(usedFloatOut != 0, \\\"AuctionHouse/ZeroFloatBought\\\");\\n    require(usedFloatOut >= floatOutMin, \\\"AuctionHouse/RequestedTooMuch\\\");\\n\\n    usedWethIn = wethPrice.multiplyDecimalRoundPrecise(usedFloatOut);\\n    usedBankIn = bankPrice.multiplyDecimalRoundPrecise(usedFloatOut);\\n\\n    require(wethInMax >= usedWethIn, \\\"AuctionHouse/MinimumWeth\\\");\\n    require(bankInMax >= usedBankIn, \\\"AuctionHouse/MinimumBank\\\");\\n\\n    _updateDelta(usedFloatOut);\\n\\n    emit Buy(round, _msgSender(), usedWethIn, usedBankIn, usedFloatOut);\\n\\n    _interactBuy(usedWethIn, usedBankIn, usedFloatOut, to);\\n\\n    return (usedWethIn, usedBankIn, usedFloatOut);\\n  }\\n\\n  function _interactBuy(\\n    uint256 usedWethIn,\\n    uint256 usedBankIn,\\n    uint256 usedFloatOut,\\n    address to\\n  ) internal {\\n    weth.safeTransferFrom(_msgSender(), address(basket), usedWethIn);\\n\\n    if (usedBankIn != 0) {\\n      (uint256 bankToSave, uint256 bankToBurn) =\\n        usedBankIn.splitBy(protocolFee);\\n\\n      bank.safeTransferFrom(_msgSender(), address(this), bankToSave);\\n      bank.safeBurnFrom(_msgSender(), bankToBurn);\\n    }\\n\\n    float.safeMint(to, usedFloatOut);\\n  }\\n\\n  /* |||||||||| AuctionActive:inContraction |||||||||| */\\n\\n  /// @inheritdoc IAuctionHouseActions\\n  function sell(\\n    uint256 floatIn,\\n    uint256 wethOutMin,\\n    uint256 bankOutMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    override(IAuctionHouseActions)\\n    timedTransition\\n    atStage(Stages.AuctionActive)\\n    inContraction\\n    returns (\\n      uint256 usedfloatIn,\\n      uint256 usedWethOut,\\n      uint256 usedBankOut\\n    )\\n  {\\n    // solhint-disable-next-line not-rely-on-time\\n    require(block.timestamp <= deadline, \\\"AuctionHouse/TransactionTooOld\\\");\\n    require(floatIn != 0, \\\"AuctionHouse/ZeroFloatSold\\\");\\n\\n    (uint256 wethPrice, uint256 bankPrice) = price();\\n\\n    usedWethOut = wethPrice.multiplyDecimalRoundPrecise(floatIn);\\n    usedBankOut = bankPrice.multiplyDecimalRoundPrecise(floatIn);\\n\\n    require(wethOutMin <= usedWethOut, \\\"AuctionHouse/ExpectedTooMuchWeth\\\");\\n    require(bankOutMin <= usedBankOut, \\\"AuctionHouse/ExpectedTooMuchBank\\\");\\n\\n    _updateDelta(floatIn);\\n\\n    emit Sell(round, _msgSender(), floatIn, usedWethOut, usedBankOut);\\n\\n    _interactSell(floatIn, usedWethOut, usedBankOut, to);\\n\\n    return (floatIn, usedWethOut, usedBankOut);\\n  }\\n\\n  function _interactSell(\\n    uint256 floatIn,\\n    uint256 usedWethOut,\\n    uint256 usedBankOut,\\n    address to\\n  ) internal {\\n    float.safeBurnFrom(_msgSender(), floatIn);\\n\\n    if (usedWethOut != 0) {\\n      weth.safeTransferFrom(address(basket), to, usedWethOut);\\n    }\\n\\n    if (usedBankOut != 0) {\\n      // STC: Maximum mint checks relative to allowance\\n      bank.safeMint(to, usedBankOut);\\n    }\\n  }\\n\\n  /* |||||||||| AuctionCooldown, AuctionPending, AuctionActive |||||||||| */\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n  /* ----- onlyGovernance ----- */\\n\\n  /// @inheritdoc IAuctionHouseGovernedActions\\n  function modifyParameters(bytes32 parameter, uint256 data)\\n    external\\n    override(IAuctionHouseGovernedActions)\\n    onlyGovernance\\n  {\\n    if (parameter == \\\"auctionDuration\\\") {\\n      require(data <= type(uint16).max, \\\"AuctionHouse/ModADMax\\\");\\n      require(data != 0, \\\"AuctionHouse/ModADZero\\\");\\n      auctionDuration = uint16(data);\\n    } else if (parameter == \\\"auctionCooldown\\\") {\\n      require(data <= type(uint32).max, \\\"AuctionHouse/ModCMax\\\");\\n      auctionCooldown = uint32(data);\\n    } else if (parameter == \\\"buffer\\\") {\\n      // 0% <= buffer <= 1000%\\n      require(data <= 10 * BasisMath.FULL_PERCENT, \\\"AuctionHouse/ModBMax\\\");\\n      buffer = uint16(data);\\n    } else if (parameter == \\\"protocolFee\\\") {\\n      // 0% <= protocolFee <= 100%\\n      require(data <= BasisMath.FULL_PERCENT, \\\"AuctionHouse/ModPFMax\\\");\\n      protocolFee = uint16(data);\\n    } else if (parameter == \\\"allowanceCap\\\") {\\n      // 0% < allowanceCap <= N ~ 1_000%\\n      require(data <= type(uint32).max, \\\"AuctionHouse/ModACMax\\\");\\n      require(data != 0, \\\"AuctionHouse/ModACMin\\\");\\n      allowanceCap = uint32(data);\\n    } else if (parameter == \\\"shouldUpdatePolicy\\\") {\\n      require(data == 1 || data == 0, \\\"AuctionHouse/ModUP\\\");\\n      shouldUpdatePolicy = data == 1;\\n    } else if (parameter == \\\"lastAuctionBlock\\\") {\\n      // We wouldn't want to disable auctions for more than ~4.3 weeks\\n      // A longer period should result in a \\\"burnt\\\" auction house and redeploy.\\n      require(data <= block.number + 2e5, \\\"AuctionHouse/ModLABMax\\\");\\n      require(data != 0, \\\"AuctionHouse/ModLABMin\\\");\\n      // Can be used to pause auctions if set in the future.\\n      lastAuctionBlock = data;\\n    } else revert(\\\"AuctionHouse/InvalidParameter\\\");\\n\\n    emit ModifyParameters(parameter, data);\\n  }\\n\\n  /// @inheritdoc IAuctionHouseGovernedActions\\n  function modifyParameters(bytes32 parameter, address data)\\n    external\\n    override(IAuctionHouseGovernedActions)\\n    onlyGovernance\\n  {\\n    if (parameter == \\\"monetaryPolicy\\\") {\\n      // STC: Sense check\\n      monetaryPolicy = IMonetaryPolicy(data);\\n    } else if (parameter == \\\"bankEthOracle\\\") {\\n      // STC: Sense check\\n      bankEthOracle = ITwap(data);\\n    } else if (parameter == \\\"floatEthOracle\\\") {\\n      // STC: Sense check\\n      floatEthOracle = ITwap(data);\\n    } else revert(\\\"AuctionHouse/InvalidParameter\\\");\\n\\n    emit ModifyParameters(parameter, data);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/Staged.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"../lib/BlockNumber.sol\\\";\\n\\ncontract Staged is BlockNumber {\\n  /**\\n   * @dev The current auction stage.\\n   * - AuctionCooling - We cannot start an auction due to Cooling Period.\\n   * - AuctionPending - We can start an auction at any time.\\n   * - AuctionActive - Auction is ongoing.\\n   */\\n  enum Stages {AuctionCooling, AuctionPending, AuctionActive}\\n\\n  /* ========== STATE VARIABLES ========== */\\n\\n  /**\\n   * @dev The cooling period between each auction in blocks.\\n   */\\n  uint32 internal auctionCooldown;\\n\\n  /**\\n   * @dev The length of the auction in blocks.\\n   */\\n  uint16 internal auctionDuration;\\n\\n  /**\\n   * @notice The current stage\\n   */\\n  Stages public stage;\\n\\n  /**\\n   * @notice Block number when the last auction started.\\n   */\\n  uint256 public lastAuctionBlock;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  constructor(\\n    uint16 _auctionDuration,\\n    uint32 _auctionCooldown,\\n    uint256 _firstAuctionBlock\\n  ) {\\n    require(\\n      _firstAuctionBlock >= _auctionDuration + _auctionCooldown,\\n      \\\"Staged/InvalidAuctionStart\\\"\\n    );\\n\\n    auctionDuration = _auctionDuration;\\n    auctionCooldown = _auctionCooldown;\\n    lastAuctionBlock = _firstAuctionBlock - _auctionDuration - _auctionCooldown;\\n    stage = Stages.AuctionCooling;\\n  }\\n\\n  /* ============ Events ============ */\\n\\n  event StageChanged(uint8 _prevStage, uint8 _newStage);\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier atStage(Stages _stage) {\\n    require(stage == _stage, \\\"Staged/InvalidStage\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modify the stages as necessary on call.\\n   */\\n  modifier timedTransition() {\\n    uint256 _blockNumber = _blockNumber();\\n\\n    if (\\n      stage == Stages.AuctionActive &&\\n      _blockNumber > lastAuctionBlock + auctionDuration\\n    ) {\\n      stage = Stages.AuctionCooling;\\n      emit StageChanged(uint8(Stages.AuctionActive), uint8(stage));\\n    }\\n    // Note that this can cascade so AuctionActive -> AuctionPending in one update, when auctionCooldown = 0.\\n    if (\\n      stage == Stages.AuctionCooling &&\\n      _blockNumber > lastAuctionBlock + auctionDuration + auctionCooldown\\n    ) {\\n      stage = Stages.AuctionPending;\\n      emit StageChanged(uint8(Stages.AuctionCooling), uint8(stage));\\n    }\\n\\n    _;\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n  /**\\n   * @notice Updates the stage, even if a function with timedTransition modifier has not yet been called\\n   * @return Returns current auction stage\\n   */\\n  function updateStage() external timedTransition returns (Stages) {\\n    return stage;\\n  }\\n\\n  /**\\n   * @dev Set the stage manually.\\n   */\\n  function _setStage(Stages _stage) internal {\\n    Stages priorStage = stage;\\n    stage = _stage;\\n    emit StageChanged(uint8(priorStage), uint8(_stage));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/AuctionHouseMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\nimport \\\"../lib/BasisMath.sol\\\";\\nimport \\\"../external-lib/SafeDecimalMath.sol\\\";\\n\\ncontract AuctionHouseMath {\\n  using SafeMath for uint256;\\n  using SafeDecimalMath for uint256;\\n  using BasisMath for uint256;\\n\\n  /**\\n   * @notice Calculate the maximum allowance for this action to do a price correction\\n   * This is normally an over-estimate as it assumes all Float is circulating\\n   * and the market cap is constant through supply changes.\\n   */\\n  function allowance(\\n    bool expansion,\\n    uint256 capBasisPoint,\\n    uint256 floatSupply,\\n    uint256 marketFloatPrice,\\n    uint256 targetFloatPrice\\n  ) internal pure returns (uint256) {\\n    uint256 targetSupply =\\n      marketFloatPrice.mul(floatSupply).div(targetFloatPrice);\\n    uint256 allowanceForAdjustment =\\n      expansion ? targetSupply.sub(floatSupply) : floatSupply.sub(targetSupply);\\n\\n    // Cap Allowance per auction; e.g. with 10% of total supply => ~20% price move.\\n    uint256 allowanceByCap = floatSupply.percentageOf(capBasisPoint);\\n\\n    return Math.min(allowanceForAdjustment, allowanceByCap);\\n  }\\n\\n  /**\\n   * @notice Linear interpolation: start + (end - start) * (step/duration)\\n   * @dev For 150 steps, duration = 149, start / end can be in any format\\n   * as long as <= 10 ** 49.\\n   * @param start The starting value\\n   * @param end The ending value\\n   * @param step Number of blocks into interpolation\\n   * @param duration Total range\\n   */\\n  function lerp(\\n    uint256 start,\\n    uint256 end,\\n    uint256 step,\\n    uint256 duration\\n  ) internal pure returns (uint256 result) {\\n    require(duration != 0, \\\"AuctionHouseMath/ZeroDuration\\\");\\n    require(step <= duration, \\\"AuctionHouseMath/InvalidStep\\\");\\n\\n    // Max value <= 2^256 / 10^27 of which 10^49 is.\\n    require(start <= 10**49, \\\"AuctionHouseMath/StartTooLarge\\\");\\n    require(end <= 10**49, \\\"AuctionHouseMath/EndTooLarge\\\");\\n\\n    // 0 <= t <= PRECISE_UNIT\\n    uint256 t = step.divideDecimalRoundPrecise(duration);\\n\\n    // result = start + (end - start) * t\\n    //        = end * t + start - start * t\\n    return\\n      result = end.multiplyDecimalRoundPrecise(t).add(start).sub(\\n        start.multiplyDecimalRoundPrecise(t)\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/IAuctionHouse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./ah/IAuctionHouseState.sol\\\";\\nimport \\\"./ah/IAuctionHouseVariables.sol\\\";\\nimport \\\"./ah/IAuctionHouseDerivedState.sol\\\";\\nimport \\\"./ah/IAuctionHouseActions.sol\\\";\\nimport \\\"./ah/IAuctionHouseGovernedActions.sol\\\";\\nimport \\\"./ah/IAuctionHouseEvents.sol\\\";\\n\\n/**\\n * @title The interface for a Float Protocol Auction House\\n * @notice The Auction House enables the sale and buy of FLOAT tokens from the\\n * market in order to stabilise price.\\n * @dev The Auction House interface is broken up into many smaller pieces\\n */\\ninterface IAuctionHouse is\\n  IAuctionHouseState,\\n  IAuctionHouseVariables,\\n  IAuctionHouseDerivedState,\\n  IAuctionHouseActions,\\n  IAuctionHouseGovernedActions,\\n  IAuctionHouseEvents\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/funds/interfaces/basket/IBasketReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\ninterface IBasketReader {\\n  /**\\n   * @notice Underlying token that is kept in this Basket\\n   */\\n  function underlying() external view returns (address);\\n\\n  /**\\n   * @notice Given a target price, what is the basket factor\\n   * @param targetPriceInUnderlying the current target price to calculate the\\n   * basket factor for in the units of the underlying token.\\n   */\\n  function getBasketFactor(uint256 targetPriceInUnderlying)\\n    external\\n    view\\n    returns (uint256 basketFactor);\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/ITwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\ninterface ITwap {\\n  /**\\n   * @notice Returns the amount out corresponding to the amount in for a given token using the moving average over time range [`block.timestamp` - [`windowSize`, `windowSize - periodSize * 2`], `block.timestamp`].\\n   * E.g. with a windowSize = 24hrs, periodSize = 6hrs.\\n   * [24hrs ago to 12hrs ago, now]\\n   * @dev Update must have been called for the bucket corresponding to the timestamp `now - windowSize`\\n   * @param tokenIn the address of the token we are offering\\n   * @param amountIn the quantity of tokens we are pricing\\n   * @param tokenOut the address of the token we want\\n   * @return amountOut the `tokenOut` amount corresponding to the `amountIn` for `tokenIn` over the time range\\n   */\\n  function consult(\\n    address tokenIn,\\n    uint256 amountIn,\\n    address tokenOut\\n  ) external view returns (uint256 amountOut);\\n\\n  /**\\n   * @notice Checks if a particular pair can be updated\\n   * @param tokenA Token A of pair (any order)\\n   * @param tokenB Token B of pair (any order)\\n   * @return If an update call will succeed\\n   */\\n  function updateable(address tokenA, address tokenB)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @notice Update the cumulative price for the observation at the current timestamp. Each observation is updated at most once per epoch period.\\n   * @param tokenA the first token to create pair from\\n   * @param tokenB the second token to create pair from\\n   * @return if the observation was updated or not.\\n   */\\n  function update(address tokenA, address tokenB) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/policy/interfaces/IMonetaryPolicy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\ninterface IMonetaryPolicy {\\n  /**\\n   * @notice Consult the monetary policy for the target price in eth\\n   */\\n  function consult() external view returns (uint256 targetPriceInEth);\\n\\n  /**\\n   * @notice Update the Target price given the auction results.\\n   * @dev 0 values are used to indicate missing data.\\n   */\\n  function updateGivenAuctionResults(\\n    uint256 round,\\n    uint256 lastAuctionBlock,\\n    uint256 floatMarketPrice,\\n    uint256 basketFactor\\n  ) external returns (uint256 targetPriceInEth);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/interfaces/ISupplyControlledERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ISupplyControlledERC20 is IERC20 {\\n  /**\\n   * @dev Creates `amount` new tokens for `to`.\\n   *\\n   * See {ERC20-_mint}.\\n   *\\n   * Requirements:\\n   * - the caller must have the `MINTER_ROLE`.\\n   */\\n  function mint(address to, uint256 amount) external;\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller.\\n   *\\n   * See {ERC20-_burn}.\\n   */\\n  function burn(uint256 amount) external;\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\n   * total supply.\\n   *\\n   * See {ERC20-_burn}.\\n   */\\n  function burnFrom(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BasisMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n/**\\n * @title Basis Mathematics\\n * @notice Provides helpers to perform percentage calculations\\n * @dev Percentages are [e2] i.e. with 2 decimals precision / basis point.\\n */\\nlibrary BasisMath {\\n  uint256 internal constant FULL_PERCENT = 1e4; // 100.00% / 1000 bp\\n  uint256 internal constant HALF_ONCE_SCALED = FULL_PERCENT / 2;\\n\\n  /**\\n   * @dev Percentage pct, round 0.5+ up.\\n   * @param self The value to take a percentage pct\\n   * @param percentage The percentage to be calculated [e2]\\n   * @return pct self * percentage\\n   */\\n  function percentageOf(uint256 self, uint256 percentage)\\n    internal\\n    pure\\n    returns (uint256 pct)\\n  {\\n    if (self == 0 || percentage == 0) {\\n      pct = 0;\\n    } else {\\n      require(\\n        self <= (type(uint256).max - HALF_ONCE_SCALED) / percentage,\\n        \\\"BasisMath/Overflow\\\"\\n      );\\n\\n      pct = (self * percentage + HALF_ONCE_SCALED) / FULL_PERCENT;\\n    }\\n  }\\n\\n  /**\\n   * @dev Split value into percentage, round 0.5+ up.\\n   * @param self The value to split\\n   * @param percentage The percentage to be calculated [e2]\\n   * @return pct The percentage of the value\\n   * @return rem Anything leftover from the value\\n   */\\n  function splitBy(uint256 self, uint256 percentage)\\n    internal\\n    pure\\n    returns (uint256 pct, uint256 rem)\\n  {\\n    require(percentage <= FULL_PERCENT, \\\"BasisMath/ExcessPercentage\\\");\\n    pct = percentageOf(self, percentage);\\n    rem = self - pct;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BlockNumber.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n/// @title Function for getting block number\\n/// @dev Base contract that is overridden for tests\\nabstract contract BlockNumber {\\n  /// @dev Method that exists purely to be overridden for tests\\n  /// @return The current block number\\n  function _blockNumber() internal view virtual returns (uint256) {\\n    return block.number;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Recoverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title Recoverable feature\\n * @dev should _only_ be used with contracts that should not store assets,\\n * but instead interacted with value so there is potential to lose assets.\\n */\\nabstract contract Recoverable is AccessControl {\\n  using SafeERC20 for IERC20;\\n  using Address for address payable;\\n\\n  /* ========== CONSTANTS ========== */\\n  bytes32 public constant RECOVER_ROLE = keccak256(\\\"RECOVER_ROLE\\\");\\n\\n  /* ============ Events ============ */\\n\\n  event Recovered(address onBehalfOf, address tokenAddress, uint256 amount);\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier isRecoverer {\\n    require(hasRole(RECOVER_ROLE, _msgSender()), \\\"Recoverable/RecoverRole\\\");\\n    _;\\n  }\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n  /* ----- RECOVER_ROLE ----- */\\n\\n  /**\\n   * @notice Provide accidental token retrieval.\\n   * @dev Sourced from synthetix/contracts/StakingRewards.sol\\n   */\\n  function recoverERC20(\\n    address to,\\n    address tokenAddress,\\n    uint256 tokenAmount\\n  ) external isRecoverer {\\n    emit Recovered(to, tokenAddress, tokenAmount);\\n\\n    IERC20(tokenAddress).safeTransfer(to, tokenAmount);\\n  }\\n\\n  /**\\n   * @notice Provide accidental ETH retrieval.\\n   */\\n  function recoverETH(address to) external isRecoverer {\\n    uint256 contractBalance = address(this).balance;\\n\\n    emit Recovered(to, address(0), contractBalance);\\n\\n    payable(to).sendValue(contractBalance);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external-lib/SafeDecimalMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\\nlibrary SafeDecimalMath {\\n  using SafeMath for uint256;\\n\\n  /* Number of decimal places in the representations. */\\n  uint8 public constant decimals = 18;\\n  uint8 public constant highPrecisionDecimals = 27;\\n\\n  /* The number representing 1.0. */\\n  uint256 public constant UNIT = 10**uint256(decimals);\\n\\n  /* The number representing 1.0 for higher fidelity numbers. */\\n  uint256 public constant PRECISE_UNIT = 10**uint256(highPrecisionDecimals);\\n  uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR =\\n    10**uint256(highPrecisionDecimals - decimals);\\n\\n  /**\\n   * @return Provides an interface to UNIT.\\n   */\\n  function unit() external pure returns (uint256) {\\n    return UNIT;\\n  }\\n\\n  /**\\n   * @return Provides an interface to PRECISE_UNIT.\\n   */\\n  function preciseUnit() external pure returns (uint256) {\\n    return PRECISE_UNIT;\\n  }\\n\\n  /**\\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n   * decimals.\\n   *\\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\\n   * so that product must be less than 2**256. As this is an integer division,\\n   * the internal division always rounds down. This helps save on gas. Rounding\\n   * is more expensive on gas.\\n   */\\n  function multiplyDecimal(uint256 x, uint256 y)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    return x.mul(y) / UNIT;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of the specified precision unit.\\n   *\\n   * @dev The operands should be in the form of a the specified unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function _multiplyDecimalRound(\\n    uint256 x,\\n    uint256 y,\\n    uint256 precisionUnit\\n  ) private pure returns (uint256) {\\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\\n    uint256 quotientTimesTen = x.mul(y) / (precisionUnit / 10);\\n\\n    if (quotientTimesTen % 10 >= 5) {\\n      quotientTimesTen += 10;\\n    }\\n\\n    return quotientTimesTen / 10;\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a precise unit.\\n   *\\n   * @dev The operands should be in the precise unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRoundPrecise(uint256 x, uint256 y)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely multiplying x and y, interpreting the operands\\n   * as fixed-point decimals of a standard unit.\\n   *\\n   * @dev The operands should be in the standard unit factor which will be\\n   * divided out after the product of x and y is evaluated, so that product must be\\n   * less than 2**256.\\n   *\\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\\n   * (eg. small fractions or percentages).\\n   */\\n  function multiplyDecimalRound(uint256 x, uint256 y)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return _multiplyDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is a high\\n   * precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n   * this is an integer division, the result is always rounded down.\\n   * This helps save on gas. Rounding is more expensive on gas.\\n   */\\n  function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\\n    /* Reintroduce the UNIT factor that will be divided out by y. */\\n    return x.mul(UNIT).div(y);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * decimal in the precision unit specified in the parameter.\\n   *\\n   * @dev y is divided after the product of x and the specified precision unit\\n   * is evaluated, so the product of x and the specified precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function _divideDecimalRound(\\n    uint256 x,\\n    uint256 y,\\n    uint256 precisionUnit\\n  ) private pure returns (uint256) {\\n    uint256 resultTimesTen = x.mul(precisionUnit * 10).div(y);\\n\\n    if (resultTimesTen % 10 >= 5) {\\n      resultTimesTen += 10;\\n    }\\n\\n    return resultTimesTen / 10;\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * standard precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the standard precision unit\\n   * is evaluated, so the product of x and the standard precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRound(uint256 x, uint256 y)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return _divideDecimalRound(x, y, UNIT);\\n  }\\n\\n  /**\\n   * @return The result of safely dividing x and y. The return value is as a rounded\\n   * high precision decimal.\\n   *\\n   * @dev y is divided after the product of x and the high precision unit\\n   * is evaluated, so the product of x and the high precision unit must\\n   * be less than 2**256. The result is rounded to the nearest increment.\\n   */\\n  function divideDecimalRoundPrecise(uint256 x, uint256 y)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\\n  }\\n\\n  /**\\n   * @dev Convert a standard decimal representation to a high precision one.\\n   */\\n  function decimalToPreciseDecimal(uint256 i) internal pure returns (uint256) {\\n    return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n  }\\n\\n  /**\\n   * @dev Convert a high precision decimal to a standard decimal representation.\\n   */\\n  function preciseDecimalToDecimal(uint256 i) internal pure returns (uint256) {\\n    uint256 quotientTimesTen =\\n      i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n    if (quotientTimesTen % 10 >= 5) {\\n      quotientTimesTen += 10;\\n    }\\n\\n    return quotientTimesTen / 10;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/SafeSupplyControlledERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\n\\nimport \\\"../tokens/interfaces/ISupplyControlledERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\n/**\\n * @title SafeSupplyControlledERC20\\n * @dev Wrappers around Supply Controlled ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n */\\nlibrary SafeSupplyControlledERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeBurnFrom(\\n    ISupplyControlledERC20 token,\\n    address from,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.burnFrom.selector, from, value)\\n    );\\n  }\\n\\n  function safeMint(\\n    ISupplyControlledERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.mint.selector, to, value)\\n    );\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata =\\n      address(token).functionCall(\\n        data,\\n        \\\"SafeSupplyControlled/LowlevelCallFailed\\\"\\n      );\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(\\n        abi.decode(returndata, (bool)),\\n        \\\"SafeSupplyControlled/ERC20Failed\\\"\\n      );\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\n/// @title Auction House state that can change by governance.\\n/// @notice These methods provide vision on specific state that could be used in wrapper contracts.\\ninterface IAuctionHouseState {\\n  /**\\n   * @notice The buffer around the starting price to handle mispriced / stale oracles.\\n   * @dev Basis point\\n   * Starts at 10% / 1e3 so market price is buffered by 110% or 90%\\n   */\\n  function buffer() external view returns (uint16);\\n\\n  /**\\n   * @notice The fee taken by the protocol.\\n   * @dev Basis point\\n   */\\n  function protocolFee() external view returns (uint16);\\n\\n  /**\\n   * @notice The cap based on total FLOAT supply to change in a single auction. E.g. 10% cap => absolute max of 10% of total supply can be minted / burned\\n   * @dev Basis point\\n   */\\n  function allowanceCap() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseVariables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./ICases.sol\\\";\\n\\n/// @title Auction House state that can change\\n/// @notice These methods compose the auctions state, and will change per action.\\ninterface IAuctionHouseVariables is ICases {\\n  /**\\n   * @notice The number of auctions since inception.\\n   */\\n  function round() external view returns (uint64);\\n\\n  /**\\n   * @notice Returns data about a specific auction.\\n   * @param roundNumber The round number for the auction array to fetch\\n   * @return stabilisationCase The Auction struct including case\\n   */\\n  function auctions(uint64 roundNumber)\\n    external\\n    view\\n    returns (\\n      Cases stabilisationCase,\\n      uint256 targetFloatInEth,\\n      uint256 marketFloatInEth,\\n      uint256 bankInEth,\\n      uint256 startWethPrice,\\n      uint256 startBankPrice,\\n      uint256 endWethPrice,\\n      uint256 endBankPrice,\\n      uint256 basketFactor,\\n      uint256 delta,\\n      uint256 allowance\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseDerivedState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./IAuction.sol\\\";\\n\\n/// @title Auction House state that can change\\n/// @notice These methods are derived from the IAuctionHouseState.\\ninterface IAuctionHouseDerivedState is IAuction {\\n  /**\\n   * @notice The price (that the Protocol with expect on expansion, and give on Contraction) for 1 FLOAT\\n   * @dev Under cases, this value is used differently:\\n   * - Contraction, Protocol buys FLOAT for pair.\\n   * - Expansion, Protocol sells FLOAT for pair.\\n   * @return wethPrice [e27] Expected price in wETH.\\n   * @return bankPrice [e27] Expected price in BANK.\\n   */\\n  function price() external view returns (uint256 wethPrice, uint256 bankPrice);\\n\\n  /**\\n   * @notice The current step through the auction.\\n   * @dev block numbers since auction start (0 indexed)\\n   */\\n  function step() external view returns (uint256);\\n\\n  /**\\n   * @notice Latest Auction alias\\n   */\\n  function latestAuction() external view returns (Auction memory);\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\n/// @title Open Auction House actions\\n/// @notice Contains all actions that can be called by anyone\\ninterface IAuctionHouseActions {\\n  /**\\n   * @notice Starts an auction\\n   * @dev This will:\\n   * - update the oracles\\n   * - calculate the target price\\n   * - check stabilisation case\\n   * - create allowance.\\n   * - Set start / end prices of the auction\\n   */\\n  function start() external returns (uint64 newRound);\\n\\n  /**\\n   * @notice Buy for an amount of <WETH, BANK> for as much FLOAT tokens as possible.\\n   * @dev Expansion, Protocol sells FLOAT for pair.\\n    As the price descends there should be no opportunity for slippage causing failure\\n    `msg.sender` should already have given the auction allowance for at least `wethIn` and `bankIn`.\\n   * `wethInMax` / `bankInMax` < 2**256 / 10**18, assumption is that totalSupply\\n   * doesn't exceed type(uint128).max\\n   * @param wethInMax The max amount of WETH to send (takes maximum from given ratio).\\n   * @param bankInMax The max amount of BANK to send (takes maximum from given ratio).\\n   * @param floatOutMin The minimum amount of FLOAT that must be received for this transaction not to revert.\\n   * @param to Recipient of the FLOAT.\\n   * @param deadline Unix timestamp after which the transaction will revert.\\n   */\\n  function buy(\\n    uint256 wethInMax,\\n    uint256 bankInMax,\\n    uint256 floatOutMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    returns (\\n      uint256 usedWethIn,\\n      uint256 usedBankIn,\\n      uint256 usedFloatOut\\n    );\\n\\n  /**\\n   * @notice Sell an amount of FLOAT for the given reward tokens.\\n   * @dev Contraction, Protocol buys FLOAT for pair. `msg.sender` should already have given the auction allowance for at least `floatIn`.\\n   * @param floatIn The amount of FLOAT to sell.\\n   * @param wethOutMin The minimum amount of WETH that can be received before the transaction reverts.\\n   * @param bankOutMin The minimum amount of BANK that can be received before the tranasction reverts.\\n   * @param to Recipient of <WETH, BANK>.\\n   * @param deadline Unix timestamp after which the transaction will revert.\\n   */\\n  function sell(\\n    uint256 floatIn,\\n    uint256 wethOutMin,\\n    uint256 bankOutMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    returns (\\n      uint256 usedfloatIn,\\n      uint256 usedWethOut,\\n      uint256 usedBankOut\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseGovernedActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\n/// @title Auction House actions that require certain level of privilege\\n/// @notice Contains Auction House methods that may only be called by controller\\ninterface IAuctionHouseGovernedActions {\\n  /**\\n   * @notice Modify a uint256 parameter\\n   * @param parameter The parameter name to modify\\n   * @param data New value for the parameter\\n   */\\n  function modifyParameters(bytes32 parameter, uint256 data) external;\\n\\n  /**\\n   * @notice Modify an address parameter\\n   * @param parameter The parameter name to modify\\n   * @param data New address for the parameter\\n   */\\n  function modifyParameters(bytes32 parameter, address data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuctionHouseEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\n/// @title Events emitted by the auction house\\n/// @notice Contains all events emitted by the auction house\\ninterface IAuctionHouseEvents {\\n  event NewAuction(\\n    uint256 indexed round,\\n    uint256 allowance,\\n    uint256 targetFloatInEth,\\n    uint256 startBlock\\n  );\\n  event Buy(\\n    uint256 indexed round,\\n    address indexed buyer,\\n    uint256 wethIn,\\n    uint256 bankIn,\\n    uint256 floatOut\\n  );\\n  event Sell(\\n    uint256 indexed round,\\n    address indexed seller,\\n    uint256 floatIn,\\n    uint256 wethOut,\\n    uint256 bankOut\\n  );\\n  event ModifyParameters(bytes32 parameter, uint256 data);\\n  event ModifyParameters(bytes32 parameter, address data);\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/ICases.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\ninterface ICases {\\n  /**\\n   * @dev The Stabilisation Cases\\n   * Up (Expansion) - Estimated market price >= target price & Basket Factor >= 1.\\n   * Restock (Expansion) - Estimated market price >= target price & Basket Factor < 1.\\n   * Confidence (Contraction) - Estimated market price < target price & Basket Factor >= 1.\\n   * Down (Contraction) - Estimated market price < target price & Basket Factor < 1.\\n   */\\n  enum Cases {Up, Restock, Confidence, Down}\\n}\\n\"\r\n    },\r\n    \"contracts/auction/interfaces/ah/IAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./ICases.sol\\\";\\n\\ninterface IAuction is ICases {\\n  /**\\n   * The current Stabilisation Case\\n   * Auction's target price.\\n   * Auction's floatInEth price.\\n   * Auction's bankInEth price.\\n   * Auction's basket factor.\\n   * Auction's used float delta.\\n   * Auction's allowed float delta (how much FLOAT can be created or burned).\\n   */\\n  struct Auction {\\n    Cases stabilisationCase;\\n    uint256 targetFloatInEth;\\n    uint256 marketFloatInEth;\\n    uint256 bankInEth;\\n    uint256 startWethPrice;\\n    uint256 startBankPrice;\\n    uint256 endWethPrice;\\n    uint256 endBankPrice;\\n    uint256 basketFactor;\\n    uint256 delta;\\n    uint256 allowance;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/mock/AuctionHouseHarness.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../AuctionHouse.sol\\\";\\n\\ncontract AuctionHouseHarness is AuctionHouse {\\n  uint256 public blockNumber;\\n\\n  constructor(\\n    // Dependencies\\n    address _weth,\\n    address _bank,\\n    address _float,\\n    address _basket,\\n    address _monetaryPolicy,\\n    address _gov,\\n    address _bankEthOracle,\\n    address _floatEthOracle,\\n    // Parameters\\n    uint16 _auctionDuration,\\n    uint32 _auctionCooldown,\\n    uint256 _firstAuctionBlock\\n  )\\n    AuctionHouse(\\n      _weth,\\n      _bank,\\n      _float,\\n      _basket,\\n      _monetaryPolicy,\\n      _gov,\\n      _bankEthOracle,\\n      _floatEthOracle,\\n      _auctionDuration,\\n      _auctionCooldown,\\n      _firstAuctionBlock\\n    )\\n  {}\\n\\n  function _blockNumber() internal view override returns (uint256) {\\n    return blockNumber;\\n  }\\n\\n  // Private Var checkers\\n\\n  function __weth() external view returns (address) {\\n    return address(weth);\\n  }\\n\\n  function __bank() external view returns (address) {\\n    return address(bank);\\n  }\\n\\n  function __float() external view returns (address) {\\n    return address(float);\\n  }\\n\\n  function __basket() external view returns (address) {\\n    return address(basket);\\n  }\\n\\n  function __monetaryPolicy() external view returns (address) {\\n    return address(monetaryPolicy);\\n  }\\n\\n  function __bankEthOracle() external view returns (address) {\\n    return address(bankEthOracle);\\n  }\\n\\n  function __floatEthOracle() external view returns (address) {\\n    return address(floatEthOracle);\\n  }\\n\\n  function __auctionDuration() external view returns (uint16) {\\n    return auctionDuration;\\n  }\\n\\n  function __auctionCooldown() external view returns (uint32) {\\n    return auctionCooldown;\\n  }\\n\\n  function __mine(uint256 _blocks) external {\\n    blockNumber = blockNumber + _blocks;\\n  }\\n\\n  function __setBlock(uint256 _number) external {\\n    blockNumber = _number;\\n  }\\n\\n  function __setCap(uint256 _cap) external {\\n    allowanceCap = uint32(_cap);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/funds/MintingCeremony.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\nimport \\\"./interfaces/basket/IBasketReader.sol\\\";\\nimport \\\"./interfaces/IMintingCeremony.sol\\\";\\n\\nimport \\\"../external-lib/SafeDecimalMath.sol\\\";\\nimport \\\"../lib/Recoverable.sol\\\";\\nimport \\\"../lib/Windowed.sol\\\";\\nimport \\\"../tokens/SafeSupplyControlledERC20.sol\\\";\\nimport \\\"../tokens/interfaces/ISupplyControlledERC20.sol\\\";\\nimport \\\"../policy/interfaces/IMonetaryPolicy.sol\\\";\\n\\n/**\\n * @title Minting Ceremony\\n * @dev Note that this is recoverable as it should never store any tokens.\\n */\\ncontract MintingCeremony is\\n  IMintingCeremony,\\n  Windowed,\\n  Recoverable,\\n  ReentrancyGuard\\n{\\n  using SafeMath for uint256;\\n  using SafeDecimalMath for uint256;\\n  using SafeERC20 for IERC20;\\n  using SafeERC20 for ISupplyControlledERC20;\\n  using SafeSupplyControlledERC20 for ISupplyControlledERC20;\\n\\n  /* ========== CONSTANTS ========== */\\n  uint8 public constant ALLOWANCE_FACTOR = 100;\\n  uint32 private constant CEREMONY_DURATION = 6 days;\\n\\n  /* ========== STATE VARIABLES ========== */\\n  // Monetary Policy Contract that decides the target price\\n  IMonetaryPolicy internal immutable monetaryPolicy;\\n  ISupplyControlledERC20 internal immutable float;\\n  IBasketReader internal immutable basket;\\n\\n  // Tokens that set allowance\\n  IERC20[] internal allowanceTokens;\\n\\n  uint256 private _totalSupply;\\n  mapping(address => uint256) private _balances;\\n\\n  /**\\n   * @notice Constructs a new Minting Ceremony\\n   */\\n  constructor(\\n    address governance_,\\n    address monetaryPolicy_,\\n    address basket_,\\n    address float_,\\n    address[] memory allowanceTokens_,\\n    uint256 ceremonyStart\\n  ) Windowed(ceremonyStart, ceremonyStart + CEREMONY_DURATION) {\\n    require(governance_ != address(0), \\\"MC/ZeroAddress\\\");\\n    require(monetaryPolicy_ != address(0), \\\"MC/ZeroAddress\\\");\\n    require(basket_ != address(0), \\\"MC/ZeroAddress\\\");\\n    require(float_ != address(0), \\\"MC/ZeroAddress\\\");\\n\\n    monetaryPolicy = IMonetaryPolicy(monetaryPolicy_);\\n    basket = IBasketReader(basket_);\\n    float = ISupplyControlledERC20(float_);\\n\\n    for (uint256 i = 0; i < allowanceTokens_.length; i++) {\\n      IERC20 allowanceToken = IERC20(allowanceTokens_[i]);\\n      allowanceToken.balanceOf(address(0)); // Check that this is a valid token\\n\\n      allowanceTokens.push(allowanceToken);\\n    }\\n\\n    _setupRole(RECOVER_ROLE, governance_);\\n  }\\n\\n  /* ========== EVENTS ========== */\\n\\n  event Committed(address indexed user, uint256 amount);\\n  event Minted(address indexed user, uint256 amount);\\n\\n  /* ========== VIEWS ========== */\\n\\n  function totalSupply() public view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address account) public view returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  function underlying()\\n    public\\n    view\\n    override(IMintingCeremony)\\n    returns (address)\\n  {\\n    return basket.underlying();\\n  }\\n\\n  /**\\n   * @notice The allowance remaining for an account.\\n   * @dev Based on the current staked balance in `allowanceTokens` and the existing allowance.\\n   */\\n  function allowance(address account)\\n    public\\n    view\\n    override(IMintingCeremony)\\n    returns (uint256 remainingAllowance)\\n  {\\n    uint256 stakedBalance = 0;\\n    for (uint256 i = 0; i < allowanceTokens.length; i++) {\\n      stakedBalance = stakedBalance.add(allowanceTokens[i].balanceOf(account));\\n    }\\n    remainingAllowance = stakedBalance.mul(ALLOWANCE_FACTOR).sub(\\n      _balances[account]\\n    );\\n  }\\n\\n  /**\\n   * @notice Simple conversion using monetary policy.\\n   */\\n  function quote(uint256 wethIn) public view returns (uint256) {\\n    uint256 targetPriceInEth = monetaryPolicy.consult();\\n\\n    require(targetPriceInEth != 0, \\\"MC/MPFailure\\\");\\n\\n    return wethIn.divideDecimalRoundPrecise(targetPriceInEth);\\n  }\\n\\n  /**\\n   * @notice The amount out accounting for quote & allowance.\\n   */\\n  function amountOut(address recipient, uint256 underlyingIn)\\n    public\\n    view\\n    returns (uint256 floatOut)\\n  {\\n    // External calls occur here, but trusted\\n    uint256 floatOutFromPrice = quote(underlyingIn);\\n    uint256 floatOutFromAllowance = allowance(recipient);\\n\\n    floatOut = Math.min(floatOutFromPrice, floatOutFromAllowance);\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n  /**\\n   * @notice Commit a quanity of wETH at the current price\\n   * @dev This is marked non-reentrancy to protect against a malicious\\n   * allowance token or monetary policy (these are trusted however).\\n   *\\n   * - Expects `msg.sender` to give approval to this contract from `basket.underlying()` for at least `underlyingIn`\\n   *\\n   * @param recipient The eventual receiver of the float\\n   * @param underlyingIn The underlying token amount to commit to mint\\n   * @param floatOutMin The minimum amount of FLOAT that must be received for this transaction not to revert.\\n   */\\n  function commit(\\n    address recipient,\\n    uint256 underlyingIn,\\n    uint256 floatOutMin\\n  )\\n    external\\n    override(IMintingCeremony)\\n    nonReentrant\\n    inWindow\\n    returns (uint256 floatOut)\\n  {\\n    floatOut = amountOut(recipient, underlyingIn);\\n    require(floatOut >= floatOutMin, \\\"MC/SlippageOrLowAllowance\\\");\\n    require(floatOut != 0, \\\"MC/NoAllowance\\\");\\n\\n    _totalSupply = _totalSupply.add(floatOut);\\n    _balances[recipient] = _balances[recipient].add(floatOut);\\n\\n    emit Committed(recipient, floatOut);\\n\\n    IERC20(underlying()).safeTransferFrom(\\n      msg.sender,\\n      address(basket),\\n      underlyingIn\\n    );\\n  }\\n\\n  /**\\n   * @notice Release the float to market which has been committed.\\n   */\\n  function mint() external override(IMintingCeremony) afterWindow {\\n    uint256 balance = balanceOf(msg.sender);\\n    require(balance != 0, \\\"MC/NotDueFloat\\\");\\n\\n    _totalSupply = _totalSupply.sub(balance);\\n    _balances[msg.sender] = _balances[msg.sender].sub(balance);\\n\\n    emit Minted(msg.sender, balance);\\n\\n    float.safeMint(msg.sender, balance);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/funds/interfaces/IMintingCeremony.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n/**\\n * @title Minting Ceremony\\n */\\ninterface IMintingCeremony {\\n  function allowance(address account)\\n    external\\n    view\\n    returns (uint256 remainingAllowance);\\n\\n  function underlying() external view returns (address);\\n\\n  function commit(\\n    address recipient,\\n    uint256 underlyingIn,\\n    uint256 floatOutMin\\n  ) external returns (uint256 floatOut);\\n\\n  function mint() external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Windowed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\n// The Window is time-based so will rely on time, however period > 30 minutes\\n// minimise the risk of oracle manipulation.\\n// solhint-disable not-rely-on-time\\n\\n/**\\n * @title A windowed contract\\n * @notice Provides a window for actions to occur\\n */\\ncontract Windowed {\\n  /* ========== STATE VARIABLES ========== */\\n\\n  /**\\n   * @notice The timestamp of the window start\\n   */\\n  uint256 public startWindow;\\n\\n  /**\\n   * @notice The timestamp of the window end\\n   */\\n  uint256 public endWindow;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  constructor(uint256 _startWindow, uint256 _endWindow) {\\n    require(_startWindow > block.timestamp, \\\"Windowed/StartInThePast\\\");\\n    require(_endWindow > _startWindow + 1 days, \\\"Windowed/MustHaveDuration\\\");\\n\\n    startWindow = _startWindow;\\n    endWindow = _endWindow;\\n  }\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier inWindow() {\\n    require(block.timestamp >= startWindow, \\\"Windowed/HasNotStarted\\\");\\n    require(block.timestamp <= endWindow, \\\"Windowed/HasEnded\\\");\\n    _;\\n  }\\n\\n  modifier afterWindow() {\\n    require(block.timestamp > endWindow, \\\"Windowed/NotEnded\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/funds/mock/MintingCeremonyHarness.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"../MintingCeremony.sol\\\";\\n\\ncontract MintingCeremonyHarness is MintingCeremony {\\n  constructor(\\n    address governance_,\\n    address monetaryPolicy_,\\n    address basket_,\\n    address float_,\\n    address[] memory allowanceTokens_,\\n    uint256 ceremonyStart\\n  )\\n    MintingCeremony(\\n      governance_,\\n      monetaryPolicy_,\\n      basket_,\\n      float_,\\n      allowanceTokens_,\\n      ceremonyStart\\n    )\\n  {}\\n\\n  function __monetaryPolicy() external view returns (address) {\\n    return address(monetaryPolicy);\\n  }\\n\\n  function __basket() external view returns (address) {\\n    return address(basket);\\n  }\\n\\n  function __float() external view returns (address) {\\n    return address(float);\\n  }\\n\\n  function __allowanceTokens(uint256 idx) external view returns (address) {\\n    return address(allowanceTokens[idx]);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/policy/MonetaryPolicyV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\nimport \\\"./interfaces/IMonetaryPolicy.sol\\\";\\n\\nimport \\\"../lib/BlockNumber.sol\\\";\\nimport \\\"../lib/MathHelper.sol\\\";\\nimport \\\"../external-lib/SafeDecimalMath.sol\\\";\\nimport \\\"../oracle/interfaces/IEthUsdOracle.sol\\\";\\n\\ncontract MonetaryPolicyV1 is IMonetaryPolicy, BlockNumber, AccessControl {\\n  using SafeMath for uint256;\\n  using SafeDecimalMath for uint256;\\n\\n  /* ========== CONSTANTS ========== */\\n  bytes32 public constant GOVERNANCE_ROLE = keccak256(\\\"GOVERNANCE_ROLE\\\");\\n  bytes32 public constant AUCTION_HOUSE_ROLE = keccak256(\\\"AUCTION_HOUSE_ROLE\\\");\\n  // 0.001$ <= Target Price <= 1000$ as a basic sense check\\n  uint256 private constant MAX_TARGET_PRICE = 1000e27;\\n  uint256 private constant MIN_TARGET_PRICE = 0.001e27;\\n\\n  uint256 private constant MAX_PRICE_DELTA_BOUND = 1e27;\\n  uint256 private constant DEFAULT_MAX_PRICE_DELTA = 4e27;\\n\\n  uint256 private constant DEFAULT_MAX_ADJ_PERIOD = 1e6;\\n  uint256 private constant DEFAULT_MIN_ADJ_PERIOD = 2e5;\\n  // 150 blocks (auction duration) < T_min < T_max < 10 000 000 (~4yrs)\\n  uint256 private constant CAP_MAX_ADJ_PERIOD = 1e7;\\n  uint256 private constant CAP_MIN_ADJ_PERIOD = 150;\\n  /**\\n   * @notice The default FLOAT starting price, golden ratio\\n   * @dev [e27]\\n   */\\n  uint256 public constant STARTING_PRICE = 1.618033988749894848204586834e27;\\n\\n  /* ========== STATE VARIABLES ========== */\\n  /**\\n   * @notice The FLOAT target price in USD.\\n   * @dev [e27]\\n   */\\n  uint256 public targetPrice = STARTING_PRICE;\\n\\n  /**\\n   * @notice If dynamic pricing is enabled.\\n   */\\n  bool public dynamicPricing = true;\\n\\n  /**\\n   * @notice Maximum price Delta of 400%\\n   */\\n  uint256 public maxPriceDelta = DEFAULT_MAX_PRICE_DELTA;\\n\\n  /**\\n   * @notice Maximum adjustment period T_max (Blocks)\\n   * @dev \\\"How long it takes us to normalise\\\"\\n   * - T_max => T_min, quicker initial response with higher price changes.\\n   */\\n  uint256 public maxAdjustmentPeriod = DEFAULT_MAX_ADJ_PERIOD;\\n\\n  /**\\n   * @notice Minimum adjustment period T_min (Blocks)\\n   * @dev \\\"How quickly we respond to market price changes\\\"\\n   * - Low T_min, increased tracking.\\n   */\\n  uint256 public minAdjustmentPeriod = DEFAULT_MIN_ADJ_PERIOD;\\n\\n  /**\\n   * @notice Provides the ETH-USD exchange rate e.g. 1.5e27 would mean 1 ETH = $1.5\\n   * @dev [e27] decimal fixed point number\\n   */\\n  IEthUsdOracle public ethUsdOracle;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n  /**\\n   * @notice Construct a new Monetary Policy\\n   * @param _governance Governance address (can add new roles & parameter control)\\n   * @param _ethUsdOracle The [e27] ETH USD price feed.\\n   */\\n  constructor(address _governance, address _ethUsdOracle) {\\n    ethUsdOracle = IEthUsdOracle(_ethUsdOracle);\\n\\n    // Roles\\n    _setupRole(DEFAULT_ADMIN_ROLE, _governance);\\n    _setupRole(GOVERNANCE_ROLE, _governance);\\n  }\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier onlyGovernance {\\n    require(hasRole(GOVERNANCE_ROLE, msg.sender), \\\"MonetaryPolicy/OnlyGovRole\\\");\\n    _;\\n  }\\n\\n  modifier onlyAuctionHouse {\\n    require(\\n      hasRole(AUCTION_HOUSE_ROLE, msg.sender),\\n      \\\"MonetaryPolicy/OnlyAuctionHouse\\\"\\n    );\\n    _;\\n  }\\n\\n  /* ========== VIEWS ========== */\\n\\n  /**\\n   * @notice Consult monetary policy to get the current target price of FLOAT in ETH\\n   * @dev [e27]\\n   */\\n  function consult() public view override(IMonetaryPolicy) returns (uint256) {\\n    if (!dynamicPricing) return _toEth(STARTING_PRICE);\\n\\n    return _toEth(targetPrice);\\n  }\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n  /* ----- onlyGovernance ----- */\\n\\n  /**\\n   * @notice Updates the EthUsdOracle\\n   * @param _ethUsdOracle The address of the ETH-USD price oracle.\\n   */\\n  function setEthUsdOracle(address _ethUsdOracle) external onlyGovernance {\\n    require(_ethUsdOracle != address(0), \\\"MonetaryPolicyV1/ValidAddress\\\");\\n    ethUsdOracle = IEthUsdOracle(_ethUsdOracle);\\n  }\\n\\n  /**\\n   * @notice Set the target price of FLOAT\\n   * @param _targetPrice [e27]\\n   */\\n  function setTargetPrice(uint256 _targetPrice) external onlyGovernance {\\n    require(_targetPrice <= MAX_TARGET_PRICE, \\\"MonetaryPolicyV1/MaxTarget\\\");\\n    require(_targetPrice >= MIN_TARGET_PRICE, \\\"MonetaryPolicyV1/MinTarget\\\");\\n    targetPrice = _targetPrice;\\n  }\\n\\n  /**\\n   * @notice Allows dynamic pricing to be turned on / off.\\n   */\\n  function setDynamicPricing(bool _dynamicPricing) external onlyGovernance {\\n    dynamicPricing = _dynamicPricing;\\n  }\\n\\n  /**\\n   * @notice Allows monetary policy parameters to be adjusted.\\n   */\\n  function setPolicyParameters(\\n    uint256 _minAdjustmentPeriod,\\n    uint256 _maxAdjustmentPeriod,\\n    uint256 _maxPriceDelta\\n  ) external onlyGovernance {\\n    require(\\n      _minAdjustmentPeriod < _maxAdjustmentPeriod,\\n      \\\"MonetaryPolicyV1/MinAdjLTMaxAdj\\\"\\n    );\\n    require(\\n      _maxAdjustmentPeriod <= CAP_MAX_ADJ_PERIOD,\\n      \\\"MonetaryPolicyV1/MaxAdj\\\"\\n    );\\n    require(\\n      _minAdjustmentPeriod >= CAP_MIN_ADJ_PERIOD,\\n      \\\"MonetaryPolicyV1/MinAdj\\\"\\n    );\\n    require(\\n      _maxPriceDelta >= MAX_PRICE_DELTA_BOUND,\\n      \\\"MonetaryPolicyV1/MaxDeltaBound\\\"\\n    );\\n    minAdjustmentPeriod = _minAdjustmentPeriod;\\n    maxAdjustmentPeriod = _maxAdjustmentPeriod;\\n    maxPriceDelta = _maxPriceDelta;\\n  }\\n\\n  /* ----- onlyAuctionHouse ----- */\\n\\n  /**\\n   * @notice Updates with previous auctions result\\n   * @dev future:param round Round number\\n   * @param lastAuctionBlock The last time an auction started.\\n   * @param floatMarketPriceInEth [e27] The current float market price (ETH)\\n   * @param basketFactor [e27] The basket factor given the prior target price\\n   * @return targetPriceInEth [e27]\\n   */\\n  function updateGivenAuctionResults(\\n    uint256,\\n    uint256 lastAuctionBlock,\\n    uint256 floatMarketPriceInEth,\\n    uint256 basketFactor\\n  ) external override(IMonetaryPolicy) onlyAuctionHouse returns (uint256) {\\n    // Exit early if this is the first auction\\n    if (lastAuctionBlock == 0) {\\n      return consult();\\n    }\\n\\n    return\\n      _updateTargetPrice(lastAuctionBlock, floatMarketPriceInEth, basketFactor);\\n  }\\n\\n  /**\\n   * @dev Converts [e27] USD price, to an [e27] ETH Price\\n   */\\n  function _toEth(uint256 price) internal view returns (uint256) {\\n    uint256 ethInUsd = ethUsdOracle.consult();\\n    return price.divideDecimalRoundPrecise(ethInUsd);\\n  }\\n\\n  /**\\n   * @dev Updates the $ valued target price, returns the eth valued target price.\\n   */\\n  function _updateTargetPrice(\\n    uint256 _lastAuctionBlock,\\n    uint256 _floatMarketPriceInEth,\\n    uint256 _basketFactor\\n  ) internal returns (uint256) {\\n    // _toEth pulled out as we do a _fromEth later.\\n    uint256 ethInUsd = ethUsdOracle.consult();\\n    uint256 priorTargetPriceInEth =\\n      targetPrice.divideDecimalRoundPrecise(ethInUsd);\\n\\n    // Check if basket and FLOAT are moving the same direction\\n    bool basketFactorDown = _basketFactor < SafeDecimalMath.PRECISE_UNIT;\\n    bool floatDown = _floatMarketPriceInEth < priorTargetPriceInEth;\\n    if (basketFactorDown != floatDown) {\\n      return priorTargetPriceInEth;\\n    }\\n\\n    // N.B: block number will always be >= _lastAuctionBlock\\n    uint256 auctionTimePeriod = _blockNumber().sub(_lastAuctionBlock);\\n\\n    uint256 normDelta =\\n      _normalisedDelta(_floatMarketPriceInEth, priorTargetPriceInEth);\\n    uint256 adjustmentPeriod = _adjustmentPeriod(normDelta);\\n\\n    // [e27]\\n    uint256 basketFactorDiff =\\n      MathHelper.diff(_basketFactor, SafeDecimalMath.PRECISE_UNIT);\\n\\n    uint256 targetChange =\\n      priorTargetPriceInEth.multiplyDecimalRoundPrecise(\\n        basketFactorDiff.mul(auctionTimePeriod).div(adjustmentPeriod)\\n      );\\n\\n    // If we have got this far, then we know that market and basket are\\n    // in the same direction, so basketFactor can be used to choose direction.\\n    uint256 targetPriceInEth =\\n      basketFactorDown\\n        ? priorTargetPriceInEth.sub(targetChange)\\n        : priorTargetPriceInEth.add(targetChange);\\n\\n    targetPrice = targetPriceInEth.multiplyDecimalRoundPrecise(ethInUsd);\\n\\n    return targetPriceInEth;\\n  }\\n\\n  function _adjustmentPeriod(uint256 _normDelta)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    // calculate T, 'the adjustment period', similar to \\\"lookback\\\" as it controls the length of the tail\\n    // T = T_max - d (T_max - T_min).\\n    //   = d * T_min + T_max - d * T_max\\n    // TBC: This doesn't need safety checks\\n    // T_min <= T <= T_max\\n    return\\n      minAdjustmentPeriod\\n        .multiplyDecimalRoundPrecise(_normDelta)\\n        .add(maxAdjustmentPeriod)\\n        .sub(maxAdjustmentPeriod.multiplyDecimalRoundPrecise(_normDelta));\\n  }\\n\\n  /**\\n   * @notice Obtain normalised delta between market and target price\\n   */\\n  function _normalisedDelta(\\n    uint256 _floatMarketPriceInEth,\\n    uint256 _priorTargetPriceInEth\\n  ) internal view returns (uint256) {\\n    uint256 delta =\\n      MathHelper.diff(_floatMarketPriceInEth, _priorTargetPriceInEth);\\n    uint256 scaledDelta =\\n      delta.divideDecimalRoundPrecise(_priorTargetPriceInEth);\\n\\n    // Invert delta if contraction to flip curve from concave increasing to convex decreasing\\n    // Also allows for a greater response in expansions than contractions.\\n    if (_floatMarketPriceInEth < _priorTargetPriceInEth) {\\n      scaledDelta = scaledDelta.divideDecimalRoundPrecise(\\n        SafeDecimalMath.PRECISE_UNIT.sub(scaledDelta)\\n      );\\n    }\\n\\n    // Normalise delta based on Dmax -> 0 <= d <= X\\n    uint256 normDelta = scaledDelta.divideDecimalRoundPrecise(maxPriceDelta);\\n\\n    // Cap normalised delta 0 <= d <= 1\\n    if (normDelta > SafeDecimalMath.PRECISE_UNIT) {\\n      normDelta = SafeDecimalMath.PRECISE_UNIT;\\n    }\\n\\n    return normDelta;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MathHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nlibrary MathHelper {\\n  function diff(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    z = x > y ? x - y : y - x;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/IEthUsdOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\n\\ninterface IEthUsdOracle {\\n  /**\\n   * @notice Spot price\\n   * @return price The latest price as an [e27]\\n   */\\n  function consult() external view returns (uint256 price);\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/ChainlinkEthUsdConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./interfaces/IEthUsdOracle.sol\\\";\\n\\ncontract ChainlinkEthUsdConsumer is IEthUsdOracle {\\n  using SafeMath for uint256;\\n\\n  /// @dev Number of decimal places in the representations. */\\n  uint8 private constant AGGREGATOR_DECIMALS = 8;\\n  uint8 private constant PRICE_DECIMALS = 27;\\n\\n  uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR =\\n    10**uint256(PRICE_DECIMALS - AGGREGATOR_DECIMALS);\\n\\n  AggregatorV3Interface internal immutable priceFeed;\\n\\n  /**\\n   * @notice Construct a new price consumer\\n   * @dev Source: https://docs.chain.link/docs/ethereum-addresses#config\\n   */\\n  constructor(address aggregatorAddress) {\\n    priceFeed = AggregatorV3Interface(aggregatorAddress);\\n  }\\n\\n  /// @inheritdoc IEthUsdOracle\\n  function consult()\\n    external\\n    view\\n    override(IEthUsdOracle)\\n    returns (uint256 price)\\n  {\\n    (, int256 _price, , , ) = priceFeed.latestRoundData();\\n    require(_price >= 0, \\\"ChainlinkConsumer/StrangeOracle\\\");\\n    return (price = uint256(_price).mul(\\n      UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR\\n    ));\\n  }\\n\\n  /**\\n   * @notice Retrieves decimals of price feed\\n   * @dev (`AGGREGATOR_DECIMALS` for ETH-USD by default, scaled up to `PRICE_DECIMALS` here)\\n   */\\n  function getDecimals() external pure returns (uint8 decimals) {\\n    return (decimals = PRICE_DECIMALS);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"../../utils/Pausable.sol\\\";\\n\\n/**\\n * @dev ERC20 token with pausable token transfers, minting and burning.\\n *\\n * Useful for scenarios such as preventing trades until the end of an evaluation\\n * period, or having an emergency switch for freezing all token transfers in the\\n * event of a large bug.\\n */\\nabstract contract ERC20Pausable is ERC20, Pausable {\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the contract must not be paused.\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        require(!paused(), \\\"ERC20Pausable: token transfer while paused\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/Phase2Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"synthetix/contracts/interfaces/IStakingRewards.sol\\\";\\n\\nimport \\\"./RewardDistributionRecipient.sol\\\";\\n\\n/**\\n * @title Phase 2 BANK Reward Pool for Float Protocol\\n * @notice This contract is used to reward `rewardToken` when `stakeToken` is staked.\\n */\\ncontract Phase2Pool is\\n  IStakingRewards,\\n  Context,\\n  AccessControl,\\n  RewardDistributionRecipient,\\n  ReentrancyGuard\\n{\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  /* ========== CONSTANTS ========== */\\n  uint256 public constant DURATION = 7 days;\\n  bytes32 public constant RECOVER_ROLE = keccak256(\\\"RECOVER_ROLE\\\");\\n\\n  /* ========== STATE VARIABLES ========== */\\n  IERC20 public rewardToken;\\n  IERC20 public stakeToken;\\n\\n  uint256 public periodFinish = 0;\\n  uint256 public rewardRate = 0;\\n  uint256 public lastUpdateTime;\\n  uint256 public rewardPerTokenStored;\\n\\n  mapping(address => uint256) public userRewardPerTokenPaid;\\n  mapping(address => uint256) public rewards;\\n\\n  uint256 private _totalSupply;\\n  mapping(address => uint256) private _balances;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  /**\\n   * @notice Construct a new Phase2Pool\\n   * @param _admin The default role controller for\\n   * @param _rewardDistribution The reward distributor (can change reward rate)\\n   * @param _rewardToken The reward token to distribute\\n   * @param _stakingToken The staking token used to qualify for rewards\\n   */\\n  constructor(\\n    address _admin,\\n    address _rewardDistribution,\\n    address _rewardToken,\\n    address _stakingToken\\n  ) RewardDistributionRecipient(_admin) {\\n    rewardDistribution = _rewardDistribution;\\n    rewardToken = IERC20(_rewardToken);\\n    stakeToken = IERC20(_stakingToken);\\n\\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n    _setupRole(RECOVER_ROLE, _admin);\\n  }\\n\\n  /* ========== EVENTS ========== */\\n\\n  event RewardAdded(uint256 reward);\\n  event Staked(address indexed user, uint256 amount);\\n  event Withdrawn(address indexed user, uint256 amount);\\n  event RewardPaid(address indexed user, uint256 reward);\\n  event Recovered(address token, uint256 amount);\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier updateReward(address account) {\\n    rewardPerTokenStored = rewardPerToken();\\n    lastUpdateTime = lastTimeRewardApplicable();\\n    if (account != address(0)) {\\n      rewards[account] = earned(account);\\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n    }\\n    _;\\n  }\\n\\n  /* ========== VIEWS ========== */\\n\\n  function totalSupply()\\n    public\\n    view\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address account)\\n    public\\n    view\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    return _balances[account];\\n  }\\n\\n  function lastTimeRewardApplicable()\\n    public\\n    view\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    return Math.min(block.timestamp, periodFinish);\\n  }\\n\\n  function rewardPerToken()\\n    public\\n    view\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    if (totalSupply() == 0) {\\n      return rewardPerTokenStored;\\n    }\\n\\n    return\\n      rewardPerTokenStored.add(\\n        lastTimeRewardApplicable()\\n          .sub(lastUpdateTime)\\n          .mul(rewardRate)\\n          .mul(1e18)\\n          .div(totalSupply())\\n      );\\n  }\\n\\n  function earned(address account)\\n    public\\n    view\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    return\\n      balanceOf(account)\\n        .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\n        .div(1e18)\\n        .add(rewards[account]);\\n  }\\n\\n  function getRewardForDuration()\\n    external\\n    view\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    return rewardRate.mul(DURATION);\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n  function stake(uint256 amount)\\n    public\\n    virtual\\n    override(IStakingRewards)\\n    updateReward(msg.sender)\\n  {\\n    require(amount > 0, \\\"Phase2Pool::stake: Cannot stake 0\\\");\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\\n\\n    stakeToken.safeTransferFrom(msg.sender, address(this), amount);\\n    emit Staked(msg.sender, amount);\\n  }\\n\\n  function withdraw(uint256 amount)\\n    public\\n    override(IStakingRewards)\\n    updateReward(msg.sender)\\n  {\\n    require(amount > 0, \\\"Phase2Pool::withdraw: Cannot withdraw 0\\\");\\n    _totalSupply = _totalSupply.sub(amount);\\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n    stakeToken.safeTransfer(msg.sender, amount);\\n    emit Withdrawn(msg.sender, amount);\\n  }\\n\\n  function exit() external override(IStakingRewards) {\\n    withdraw(balanceOf(msg.sender));\\n    getReward();\\n  }\\n\\n  function getReward()\\n    public\\n    virtual\\n    override(IStakingRewards)\\n    updateReward(msg.sender)\\n  {\\n    uint256 reward = earned(msg.sender);\\n    if (reward > 0) {\\n      rewards[msg.sender] = 0;\\n      rewardToken.safeTransfer(msg.sender, reward);\\n      emit RewardPaid(msg.sender, reward);\\n    }\\n  }\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n  /* ----- Reward Distributor ----- */\\n\\n  /**\\n   * @notice Should be called after the amount of reward tokens has\\n     been sent to the contract.\\n     Reward should be divisible by duration.\\n   * @param reward number of tokens to be distributed over the duration.\\n   */\\n  function notifyRewardAmount(uint256 reward)\\n    external\\n    override\\n    onlyRewardDistribution\\n    updateReward(address(0))\\n  {\\n    if (block.timestamp >= periodFinish) {\\n      rewardRate = reward.div(DURATION);\\n    } else {\\n      uint256 remaining = periodFinish.sub(block.timestamp);\\n      uint256 leftover = remaining.mul(rewardRate);\\n      rewardRate = reward.add(leftover).div(DURATION);\\n    }\\n\\n    // Ensure provided reward amount is not more than the balance in the contract.\\n    // Keeps reward rate within the right range to prevent overflows in earned or rewardsPerToken\\n    // Reward + leftover < 1e18\\n    uint256 balance = rewardToken.balanceOf(address(this));\\n    require(\\n      rewardRate <= balance.div(DURATION),\\n      \\\"Phase2Pool::notifyRewardAmount: Insufficent balance for reward rate\\\"\\n    );\\n\\n    lastUpdateTime = block.timestamp;\\n    periodFinish = block.timestamp.add(DURATION);\\n    emit RewardAdded(reward);\\n  }\\n\\n  /* ----- RECOVER_ROLE ----- */\\n\\n  /**\\n   * @notice Provide accidental token retrieval.\\n   * @dev Sourced from synthetix/contracts/StakingRewards.sol\\n   */\\n  function recoverERC20(address tokenAddress, uint256 tokenAmount) external {\\n    require(\\n      hasRole(RECOVER_ROLE, _msgSender()),\\n      \\\"Phase2Pool::recoverERC20: You must possess the recover role to recover erc20\\\"\\n    );\\n    require(\\n      tokenAddress != address(stakeToken),\\n      \\\"Phase2Pool::recoverERC20: Cannot recover the staking token\\\"\\n    );\\n    require(\\n      tokenAddress != address(rewardToken),\\n      \\\"Phase2Pool::recoverERC20: Cannot recover the reward token\\\"\\n    );\\n\\n    IERC20(tokenAddress).safeTransfer(_msgSender(), tokenAmount);\\n    emit Recovered(tokenAddress, tokenAmount);\\n  }\\n}\\n\"\r\n    },\r\n    \"synthetix/contracts/interfaces/IStakingRewards.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/istakingrewards\\ninterface IStakingRewards {\\n    // Views\\n    function lastTimeRewardApplicable() external view returns (uint256);\\n\\n    function rewardPerToken() external view returns (uint256);\\n\\n    function earned(address account) external view returns (uint256);\\n\\n    function getRewardForDuration() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    // Mutative\\n\\n    function stake(uint256 amount) external;\\n\\n    function withdraw(uint256 amount) external;\\n\\n    function getReward() external;\\n\\n    function exit() external;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/RewardDistributionRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\n\\nabstract contract RewardDistributionRecipient is Context, AccessControl {\\n    bytes32 public constant DISTRIBUTION_ASSIGNER_ROLE = keccak256(\\\"DISTRIBUTION_ASSIGNER_ROLE\\\");\\n\\n    address public rewardDistribution;\\n\\n    constructor(address assigner) {\\n        _setupRole(DISTRIBUTION_ASSIGNER_ROLE, assigner);\\n    }\\n\\n    modifier onlyRewardDistribution() {\\n        require(\\n            _msgSender() == rewardDistribution,\\n            \\\"RewardDisributionRecipient::onlyRewardDistribution: Caller is not RewardsDistribution contract\\\"\\n        );\\n        _;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    /* ----- rewardDistribution ----- */\\n\\n    function notifyRewardAmount(uint256 reward) external virtual;\\n\\n    /* ----- DISTRIBUTION_ASSIGNER_ROLE ----- */\\n\\n    function setRewardDistribution(address _rewardDistribution)\\n        external\\n    {\\n        require(\\n            hasRole(DISTRIBUTION_ASSIGNER_ROLE, _msgSender()),\\n            \\\"RewardDistributionRecipient::setRewardDistribution: must have distribution assigner role\\\"\\n        );\\n        rewardDistribution = _rewardDistribution;\\n    }\\n}\"\r\n    },\r\n    \"contracts/staking/Phase1Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"./RewardDistributionRecipient.sol\\\";\\nimport \\\"./interfaces/IStakingRewardWhitelisted.sol\\\";\\nimport \\\"./Whitelisted.sol\\\";\\nimport \\\"./Phase2Pool.sol\\\";\\n\\ncontract Phase1Pool is Phase2Pool, Whitelisted, IStakingRewardWhitelisted {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  /* ========== STATE VARIABLES ========== */\\n  uint256 public maximumContribution;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  /**\\n   * @notice Construct a new Phase1Pool\\n   * @param _admin The default role controller for\\n   * @param _rewardDistribution The reward distributor (can change reward rate)\\n   * @param _whitelist The address of the deployed whitelist contract\\n   * @param _rewardToken The reward token to distribute\\n   * @param _stakingToken The staking token used to qualify for rewards\\n   * @param _maximumContribution The maximum contribution for this token (in the unit of the respective contract)\\n   */\\n  constructor(\\n    address _admin,\\n    address _rewardDistribution,\\n    address _whitelist,\\n    address _rewardToken,\\n    address _stakingToken,\\n    uint256 _maximumContribution\\n  ) Phase2Pool(_admin, _rewardDistribution, _rewardToken, _stakingToken) {\\n    whitelist = IWhitelist(_whitelist);\\n    maximumContribution = _maximumContribution;\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n  function stake(uint256) public pure override(Phase2Pool, IStakingRewards) {\\n    revert(\\n      \\\"Phase1Pool::stake: Cannot stake on Phase1Pool directly due to whitelist\\\"\\n    );\\n  }\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n  /* ----- onlyWhitelisted ----- */\\n\\n  function stakeWithProof(uint256 amount, bytes32[] calldata proof)\\n    public\\n    override(IStakingRewardWhitelisted)\\n    onlyWhitelisted(proof)\\n    updateReward(msg.sender)\\n  {\\n    require(\\n      balanceOf(msg.sender).add(amount) <= maximumContribution,\\n      \\\"Phase1Pool::stake: Cannot exceed maximum contribution\\\"\\n    );\\n\\n    super.stake(amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/interfaces/IStakingRewardWhitelisted.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"synthetix/contracts/interfaces/IStakingRewards.sol\\\";\\n\\ninterface IStakingRewardWhitelisted is IStakingRewards {\\n  function stakeWithProof(uint256 amount, bytes32[] calldata proof) external;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/Whitelisted.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport '@openzeppelin/contracts/GSN/Context.sol';\\n\\nimport './interfaces/IWhitelist.sol';\\n\\nabstract contract Whitelisted is Context {\\n    IWhitelist public whitelist;\\n\\n    modifier onlyWhitelisted(bytes32[] calldata proof) {\\n        require(\\n            whitelist.whitelisted(_msgSender(), proof),\\n            \\\"Whitelisted::onlyWhitelisted: Caller is not whitelisted / proof invalid\\\"\\n        );\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/staking/interfaces/IWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.2;\\n\\ninterface IWhitelist {\\n  // Views\\n  function root() external view returns (bytes32);\\n  function uri() external view returns (string memory);\\n  function whitelisted(address account, bytes32[] memory proof) external view returns (bool);\\n\\n  // Mutative\\n  function updateWhitelist(bytes32 _root, string memory _uri) external; \\n}\"\r\n    },\r\n    \"contracts/staking/MerkleWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\n\\nimport \\\"./interfaces/IWhitelist.sol\\\";\\n\\ncontract MerkleWhitelist is IWhitelist, Context, AccessControl {\\n  /* ========== CONSTANTS ========== */\\n  bytes32 public constant WHITELISTER_ROLE = keccak256(\\\"WHITELISTER_ROLE\\\");\\n\\n  /* ========== STATE VARIABLES ========== */\\n  bytes32 public merkleRoot;\\n  string public sourceUri;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  /**\\n   * @notice Construct a new MerkleWhitelist\\n   * @param _admin The default role controller and whitelister for the contract.\\n   * @param _root The default merkleRoot.\\n   * @param _uri The link to the full whitelist.\\n   */\\n  constructor(\\n    address _admin,\\n    bytes32 _root,\\n    string memory _uri\\n  ) {\\n    merkleRoot = _root;\\n    sourceUri = _uri;\\n\\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n    _setupRole(WHITELISTER_ROLE, _admin);\\n  }\\n\\n  /* ========== EVENTS ========== */\\n\\n  event UpdatedWhitelist(bytes32 root, string uri);\\n\\n  /* ========== VIEWS ========== */\\n\\n  function root() external view override(IWhitelist) returns (bytes32) {\\n    return merkleRoot;\\n  }\\n\\n  function uri() external view override(IWhitelist) returns (string memory) {\\n    return sourceUri;\\n  }\\n\\n  function whitelisted(address account, bytes32[] memory proof)\\n    public\\n    view\\n    override(IWhitelist)\\n    returns (bool)\\n  {\\n    // Need to include bytes1(0x00) in order to prevent pre-image attack.\\n    bytes32 leafHash = keccak256(abi.encodePacked(bytes1(0x00), account));\\n    return checkProof(merkleRoot, proof, leafHash);\\n  }\\n\\n  /* ========== PURE ========== */\\n\\n  function checkProof(\\n    bytes32 _root,\\n    bytes32[] memory _proof,\\n    bytes32 _leaf\\n  ) internal pure returns (bool) {\\n    bytes32 computedHash = _leaf;\\n\\n    for (uint256 i = 0; i < _proof.length; i++) {\\n      bytes32 proofElement = _proof[i];\\n\\n      if (computedHash < proofElement) {\\n        computedHash = keccak256(\\n          abi.encodePacked(bytes1(0x01), computedHash, proofElement)\\n        );\\n      } else {\\n        computedHash = keccak256(\\n          abi.encodePacked(bytes1(0x01), proofElement, computedHash)\\n        );\\n      }\\n    }\\n\\n    return computedHash == _root;\\n  }\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n  /* ----- WHITELISTER_ROLE ----- */\\n\\n  function updateWhitelist(bytes32 root_, string memory uri_)\\n    public\\n    override(IWhitelist)\\n  {\\n    require(\\n      hasRole(WHITELISTER_ROLE, _msgSender()),\\n      \\\"MerkleWhitelist::updateWhitelist: only whitelister may update the whitelist\\\"\\n    );\\n\\n    merkleRoot = root_;\\n    sourceUri = uri_;\\n\\n    emit UpdatedWhitelist(merkleRoot, sourceUri);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/mock/TokenMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol\\\";\\n\\n/**\\n * @dev {ERC20} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * This has an open mint functionality\\n */\\ncontract TokenMock is Context, AccessControl, ERC20Burnable, ERC20Pausable {\\n  bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n  /**\\n   * @dev Grants `DEFAULT_ADMIN_ROLE`, and `PAUSER_ROLE` to the\\n   * account that deploys the contract.\\n   *\\n   * See {ERC20-constructor}.\\n   */\\n  constructor(\\n    address _admin,\\n    string memory _name,\\n    string memory _symbol,\\n    uint8 _decimals\\n  ) ERC20(_name, _symbol) {\\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n    _setupRole(PAUSER_ROLE, _admin);\\n\\n    _setupDecimals(_decimals);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` new tokens for `to`.\\n   *\\n   * See {ERC20-_mint}.\\n   *\\n   */\\n  function mint(address to, uint256 amount) external virtual {\\n    _mint(to, amount);\\n  }\\n\\n  /**\\n   * @dev Pauses all token transfers.\\n   *\\n   * See {ERC20Pausable} and {Pausable-_pause}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have the `PAUSER_ROLE`.\\n   */\\n  function pause() external virtual {\\n    require(hasRole(PAUSER_ROLE, _msgSender()), \\\"TokenMock/PauserRole\\\");\\n    _pause();\\n  }\\n\\n  /**\\n   * @dev Unpauses all token transfers.\\n   *\\n   * See {ERC20Pausable} and {Pausable-_unpause}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have the `PAUSER_ROLE`.\\n   */\\n  function unpause() external virtual {\\n    require(hasRole(PAUSER_ROLE, _msgSender()), \\\"TokenMock/PauserRole\\\");\\n    _unpause();\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual override(ERC20, ERC20Pausable) {\\n    super._beforeTokenTransfer(from, to, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/mock/RecoverableHarness.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"../Recoverable.sol\\\";\\n\\ncontract RecoverableHarness is Recoverable {\\n  constructor(address governance) {\\n    _setupRole(RECOVER_ROLE, governance);\\n  }\\n\\n  receive() external payable {\\n    // Blindly accept ETH.\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/ETHPhase2Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./RewardDistributionRecipient.sol\\\";\\nimport \\\"./interfaces/IETHStakingRewards.sol\\\";\\n\\n/**\\n * @title Phase 2 BANK Reward Pool for Float Protocol, specifically for ETH.\\n * @notice This contract is used to reward `rewardToken` when ETH is staked.\\n */\\ncontract ETHPhase2Pool is\\n  IETHStakingRewards,\\n  Context,\\n  AccessControl,\\n  RewardDistributionRecipient,\\n  ReentrancyGuard\\n{\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  /* ========== CONSTANTS ========== */\\n  uint256 public constant DURATION = 7 days;\\n  bytes32 public constant RECOVER_ROLE = keccak256(\\\"RECOVER_ROLE\\\");\\n\\n  /* ========== STATE VARIABLES ========== */\\n  IERC20 public rewardToken;\\n\\n  uint256 public periodFinish = 0;\\n  uint256 public rewardRate = 0;\\n  uint256 public lastUpdateTime;\\n  uint256 public rewardPerTokenStored;\\n\\n  mapping(address => uint256) public userRewardPerTokenPaid;\\n  mapping(address => uint256) public rewards;\\n\\n  uint256 private _totalSupply;\\n  mapping(address => uint256) private _balances;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  /**\\n   * @notice Construct a new Phase2Pool for ETH\\n   * @param _admin The default role controller for\\n   * @param _rewardDistribution The reward distributor (can change reward rate)\\n   * @param _rewardToken The reward token to distribute\\n   */\\n  constructor(\\n    address _admin,\\n    address _rewardDistribution,\\n    address _rewardToken\\n  ) RewardDistributionRecipient(_admin) {\\n    rewardDistribution = _rewardDistribution;\\n    rewardToken = IERC20(_rewardToken);\\n\\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n    _setupRole(RECOVER_ROLE, _admin);\\n  }\\n\\n  /* ========== EVENTS ========== */\\n\\n  event RewardAdded(uint256 reward);\\n  event Staked(address indexed user, uint256 amount);\\n  event Withdrawn(address indexed user, uint256 amount);\\n  event RewardPaid(address indexed user, uint256 reward);\\n  event Recovered(address token, uint256 amount);\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier updateReward(address account) {\\n    rewardPerTokenStored = rewardPerToken();\\n    lastUpdateTime = lastTimeRewardApplicable();\\n    if (account != address(0)) {\\n      rewards[account] = earned(account);\\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n    }\\n    _;\\n  }\\n\\n  /* ========== VIEWS ========== */\\n\\n  function totalSupply()\\n    public\\n    view\\n    override(IETHStakingRewards)\\n    returns (uint256)\\n  {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address account)\\n    public\\n    view\\n    override(IETHStakingRewards)\\n    returns (uint256)\\n  {\\n    return _balances[account];\\n  }\\n\\n  function lastTimeRewardApplicable()\\n    public\\n    view\\n    override(IETHStakingRewards)\\n    returns (uint256)\\n  {\\n    return Math.min(block.timestamp, periodFinish);\\n  }\\n\\n  function rewardPerToken()\\n    public\\n    view\\n    override(IETHStakingRewards)\\n    returns (uint256)\\n  {\\n    if (totalSupply() == 0) {\\n      return rewardPerTokenStored;\\n    }\\n\\n    return\\n      rewardPerTokenStored.add(\\n        lastTimeRewardApplicable()\\n          .sub(lastUpdateTime)\\n          .mul(rewardRate)\\n          .mul(1e18)\\n          .div(totalSupply())\\n      );\\n  }\\n\\n  function earned(address account)\\n    public\\n    view\\n    override(IETHStakingRewards)\\n    returns (uint256)\\n  {\\n    return\\n      balanceOf(account)\\n        .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\n        .div(1e18)\\n        .add(rewards[account]);\\n  }\\n\\n  function getRewardForDuration()\\n    external\\n    view\\n    override(IETHStakingRewards)\\n    returns (uint256)\\n  {\\n    return rewardRate.mul(DURATION);\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n  /**\\n   * @dev Fallback, `msg.value` of ETH sent to this contract grants caller account a matching stake in contract.\\n   * Emits {Staked} event to reflect this.\\n   */\\n  receive() external payable {\\n    stake(msg.value);\\n  }\\n\\n  function stake(uint256 amount)\\n    public\\n    payable\\n    virtual\\n    override(IETHStakingRewards)\\n    updateReward(msg.sender)\\n  {\\n    require(amount > 0, \\\"ETHPhase2Pool/ZeroStake\\\");\\n    require(amount == msg.value, \\\"ETHPhase2Pool/IncorrectEth\\\");\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\\n\\n    emit Staked(msg.sender, amount);\\n  }\\n\\n  function withdraw(uint256 amount)\\n    public\\n    override(IETHStakingRewards)\\n    updateReward(msg.sender)\\n  {\\n    require(amount > 0, \\\"ETHPhase2Pool/ZeroWithdraw\\\");\\n    _totalSupply = _totalSupply.sub(amount);\\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n\\n    emit Withdrawn(msg.sender, amount);\\n    (bool success, ) = msg.sender.call{value: amount}(\\\"\\\");\\n    require(success, \\\"ETHPhase2Pool/EthTransferFail\\\");\\n  }\\n\\n  function exit() external override(IETHStakingRewards) {\\n    withdraw(balanceOf(msg.sender));\\n    getReward();\\n  }\\n\\n  function getReward()\\n    public\\n    virtual\\n    override(IETHStakingRewards)\\n    updateReward(msg.sender)\\n  {\\n    uint256 reward = earned(msg.sender);\\n    if (reward > 0) {\\n      rewards[msg.sender] = 0;\\n      rewardToken.safeTransfer(msg.sender, reward);\\n      emit RewardPaid(msg.sender, reward);\\n    }\\n  }\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n  /* ----- Reward Distributor ----- */\\n\\n  /**\\n   * @notice Should be called after the amount of reward tokens has\\n     been sent to the contract.\\n     Reward should be divisible by duration.\\n   * @param reward number of tokens to be distributed over the duration.\\n   */\\n  function notifyRewardAmount(uint256 reward)\\n    external\\n    override\\n    onlyRewardDistribution\\n    updateReward(address(0))\\n  {\\n    if (block.timestamp >= periodFinish) {\\n      rewardRate = reward.div(DURATION);\\n    } else {\\n      uint256 remaining = periodFinish.sub(block.timestamp);\\n      uint256 leftover = remaining.mul(rewardRate);\\n      rewardRate = reward.add(leftover).div(DURATION);\\n    }\\n\\n    // Ensure provided reward amount is not more than the balance in the contract.\\n    // Keeps reward rate within the right range to prevent overflows in earned or rewardsPerToken\\n    // Reward + leftover < 1e18\\n    uint256 balance = rewardToken.balanceOf(address(this));\\n    require(\\n      rewardRate <= balance.div(DURATION),\\n      \\\"ETHPhase2Pool/LowRewardBalance\\\"\\n    );\\n\\n    lastUpdateTime = block.timestamp;\\n    periodFinish = block.timestamp.add(DURATION);\\n    emit RewardAdded(reward);\\n  }\\n\\n  /* ----- RECOVER_ROLE ----- */\\n\\n  /**\\n   * @notice Provide accidental token retrieval.\\n   * @dev Sourced from synthetix/contracts/StakingRewards.sol\\n   */\\n  function recoverERC20(address tokenAddress, uint256 tokenAmount) external {\\n    require(\\n      hasRole(RECOVER_ROLE, _msgSender()),\\n      \\\"ETHPhase2Pool/HasRecoverRole\\\"\\n    );\\n    require(tokenAddress != address(rewardToken), \\\"ETHPhase2Pool/NotReward\\\");\\n\\n    IERC20(tokenAddress).safeTransfer(_msgSender(), tokenAmount);\\n    emit Recovered(tokenAddress, tokenAmount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/interfaces/IETHStakingRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\ninterface IETHStakingRewards {\\n    // Views\\n    function lastTimeRewardApplicable() external view returns (uint256);\\n    function rewardPerToken() external view returns (uint256);\\n    function earned(address account) external view returns (uint256);\\n    function getRewardForDuration() external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    // Mutative\\n    function stake(uint256 amount) external payable;\\n    function withdraw(uint256 amount) external;\\n    function getReward() external;\\n    function exit() external;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/BasePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"synthetix/contracts/interfaces/IStakingRewards.sol\\\";\\n\\nimport \\\"./RewardDistributionRecipient.sol\\\";\\n\\n/**\\n * @title Base Reward Pool for Float Protocol\\n * @notice This contract is used to reward `rewardToken` when `stakeToken` is staked.\\n * @dev The Pools are based on the original Synthetix rewards contract (https://etherscan.io/address/0xDCB6A51eA3CA5d3Fd898Fd6564757c7aAeC3ca92#code) developed by @k06a which is battled tested and widely used.\\n * Alterations:\\n * - duration set on constructor (immutable)\\n * - Internal properties rather than private\\n * - Add virtual marker to functions\\n * - Change stake / withdraw to external and provide internal equivalents\\n * - Change require messages to match convention\\n * - Add hooks for _beforeWithdraw and _beforeStake\\n * - Emit events before external calls in line with best practices.\\n */\\nabstract contract BasePool is\\n  IStakingRewards,\\n  AccessControl,\\n  RewardDistributionRecipient\\n{\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  /* ========== CONSTANTS ========== */\\n  bytes32 public constant RECOVER_ROLE = keccak256(\\\"RECOVER_ROLE\\\");\\n  uint256 public immutable duration;\\n\\n  /* ========== STATE VARIABLES ========== */\\n  IERC20 public rewardToken;\\n  IERC20 public stakeToken;\\n\\n  uint256 public periodFinish;\\n  uint256 public rewardRate;\\n  uint256 public lastUpdateTime;\\n  uint256 public rewardPerTokenStored;\\n\\n  mapping(address => uint256) public userRewardPerTokenPaid;\\n  mapping(address => uint256) public rewards;\\n\\n  uint256 internal _totalSupply;\\n  mapping(address => uint256) internal _balances;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  /**\\n   * @notice Construct a new BasePool\\n   * @param _admin The default role controller\\n   * @param _rewardDistribution The reward distributor (can change reward rate)\\n   * @param _rewardToken The reward token to distribute\\n   * @param _stakingToken The staking token used to qualify for rewards\\n   */\\n  constructor(\\n    address _admin,\\n    address _rewardDistribution,\\n    address _rewardToken,\\n    address _stakingToken,\\n    uint256 _duration\\n  ) RewardDistributionRecipient(_admin) {\\n    rewardDistribution = _rewardDistribution;\\n    rewardToken = IERC20(_rewardToken);\\n    stakeToken = IERC20(_stakingToken);\\n\\n    duration = _duration;\\n\\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n    _setupRole(RECOVER_ROLE, _admin);\\n  }\\n\\n  /* ========== EVENTS ========== */\\n\\n  event RewardAdded(uint256 reward);\\n  event Staked(address indexed user, uint256 amount);\\n  event Withdrawn(address indexed user, uint256 amount);\\n  event RewardPaid(address indexed user, uint256 reward);\\n  event Recovered(address token, uint256 amount);\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier updateReward(address account) virtual {\\n    rewardPerTokenStored = rewardPerToken();\\n    lastUpdateTime = lastTimeRewardApplicable();\\n    if (account != address(0)) {\\n      rewards[account] = earned(account);\\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n    }\\n    _;\\n  }\\n\\n  /* ========== VIEWS ========== */\\n\\n  /**\\n   * @notice The total reward producing staked supply (total quantity to distribute)\\n   */\\n  function totalSupply()\\n    public\\n    view\\n    virtual\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @notice The total reward producing balance of the account.\\n   */\\n  function balanceOf(address account)\\n    public\\n    view\\n    virtual\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    return _balances[account];\\n  }\\n\\n  function lastTimeRewardApplicable()\\n    public\\n    view\\n    virtual\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    return Math.min(block.timestamp, periodFinish);\\n  }\\n\\n  function rewardPerToken()\\n    public\\n    view\\n    virtual\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    if (totalSupply() == 0) {\\n      return rewardPerTokenStored;\\n    }\\n\\n    return\\n      rewardPerTokenStored.add(\\n        lastTimeRewardApplicable()\\n          .sub(lastUpdateTime)\\n          .mul(rewardRate)\\n          .mul(1e18)\\n          .div(totalSupply())\\n      );\\n  }\\n\\n  function earned(address account)\\n    public\\n    view\\n    virtual\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    return\\n      balanceOf(account)\\n        .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\n        .div(1e18)\\n        .add(rewards[account]);\\n  }\\n\\n  function getRewardForDuration()\\n    external\\n    view\\n    override(IStakingRewards)\\n    returns (uint256)\\n  {\\n    return rewardRate.mul(duration);\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n  function stake(uint256 amount)\\n    external\\n    virtual\\n    override(IStakingRewards)\\n    updateReward(msg.sender)\\n  {\\n    require(amount > 0, \\\"BasePool/NonZeroStake\\\");\\n\\n    _stake(msg.sender, msg.sender, amount);\\n  }\\n\\n  function withdraw(uint256 amount)\\n    external\\n    virtual\\n    override(IStakingRewards)\\n    updateReward(msg.sender)\\n  {\\n    require(amount > 0, \\\"BasePool/NonZeroWithdraw\\\");\\n\\n    _withdraw(msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice Exit the pool, taking any rewards due and staked\\n   */\\n  function exit()\\n    external\\n    virtual\\n    override(IStakingRewards)\\n    updateReward(msg.sender)\\n  {\\n    _withdraw(msg.sender, _balances[msg.sender]);\\n    getReward();\\n  }\\n\\n  /**\\n   * @notice Retrieve any rewards due\\n   */\\n  function getReward()\\n    public\\n    virtual\\n    override(IStakingRewards)\\n    updateReward(msg.sender)\\n  {\\n    uint256 reward = earned(msg.sender);\\n    if (reward > 0) {\\n      rewards[msg.sender] = 0;\\n\\n      emit RewardPaid(msg.sender, reward);\\n\\n      rewardToken.safeTransfer(msg.sender, reward);\\n    }\\n  }\\n\\n  /**\\n   * @dev Stakes `amount` tokens from `staker` to `recipient`, increasing the total supply.\\n   *\\n   * Emits a {Staked} event.\\n   *\\n   * Requirements:\\n   * - `recipient` cannot be zero address.\\n   * - `staker` must have at least `amount` tokens\\n   * - `staker` must approve this contract for at least `amount`\\n   */\\n  function _stake(\\n    address staker,\\n    address recipient,\\n    uint256 amount\\n  ) internal virtual {\\n    require(recipient != address(0), \\\"BasePool/ZeroAddressS\\\");\\n\\n    _beforeStake(staker, recipient, amount);\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[recipient] = _balances[recipient].add(amount);\\n\\n    emit Staked(recipient, amount);\\n    stakeToken.safeTransferFrom(staker, address(this), amount);\\n  }\\n\\n  /**\\n   * @dev Withdraws `amount` tokens from `account`, reducing the total supply.\\n   *\\n   * Emits a {Withdrawn} event.\\n   *\\n   * Requirements:\\n   * - `account` cannot be zero address.\\n   * - `account` must have at least `amount` staked.\\n   */\\n  function _withdraw(address account, uint256 amount) internal virtual {\\n    require(account != address(0), \\\"BasePool/ZeroAddressW\\\");\\n\\n    _beforeWithdraw(account, amount);\\n\\n    _balances[account] = _balances[account].sub(\\n      amount,\\n      \\\"BasePool/WithdrawExceedsBalance\\\"\\n    );\\n    _totalSupply = _totalSupply.sub(amount);\\n\\n    emit Withdrawn(account, amount);\\n    stakeToken.safeTransfer(account, amount);\\n  }\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n  /* ----- Reward Distributor ----- */\\n\\n  /**\\n   * @notice Should be called after the amount of reward tokens has\\n     been sent to the contract.\\n     Reward should be divisible by duration.\\n   * @param reward number of tokens to be distributed over the duration.\\n   */\\n  function notifyRewardAmount(uint256 reward)\\n    public\\n    virtual\\n    override\\n    onlyRewardDistribution\\n    updateReward(address(0))\\n  {\\n    if (block.timestamp >= periodFinish) {\\n      rewardRate = reward.div(duration);\\n    } else {\\n      uint256 remaining = periodFinish.sub(block.timestamp);\\n      uint256 leftover = remaining.mul(rewardRate);\\n      rewardRate = reward.add(leftover).div(duration);\\n    }\\n\\n    // Ensure provided reward amount is not more than the balance in the contract.\\n    // Keeps reward rate within the right range to prevent overflows in earned or rewardsPerToken\\n    // Reward + leftover < 1e18\\n    uint256 balance = rewardToken.balanceOf(address(this));\\n    require(rewardRate <= balance.div(duration), \\\"BasePool/InsufficentBalance\\\");\\n\\n    lastUpdateTime = block.timestamp;\\n    periodFinish = block.timestamp.add(duration);\\n    emit RewardAdded(reward);\\n  }\\n\\n  /* ----- RECOVER_ROLE ----- */\\n\\n  /**\\n   * @notice Provide accidental token retrieval.\\n   * @dev Sourced from synthetix/contracts/StakingRewards.sol\\n   */\\n  function recoverERC20(address tokenAddress, uint256 tokenAmount) external {\\n    require(hasRole(RECOVER_ROLE, _msgSender()), \\\"BasePool/RecoverRole\\\");\\n    require(tokenAddress != address(stakeToken), \\\"BasePool/NoRecoveryOfStake\\\");\\n    require(\\n      tokenAddress != address(rewardToken),\\n      \\\"BasePool/NoRecoveryOfReward\\\"\\n    );\\n\\n    emit Recovered(tokenAddress, tokenAmount);\\n\\n    IERC20(tokenAddress).safeTransfer(_msgSender(), tokenAmount);\\n  }\\n\\n  /* ========== HOOKS ========== */\\n\\n  /**\\n   * @dev Hook that is called before any staking of tokens.\\n   *\\n   * Calling conditions:\\n   *\\n   * - `amount` of ``staker``'s tokens will be staked into the pool\\n   * - `recipient` can withdraw.\\n   */\\n  function _beforeStake(\\n    address staker,\\n    address recipient,\\n    uint256 amount\\n  ) internal virtual {}\\n\\n  /**\\n   * @dev Hook that is called before any staking of tokens.\\n   *\\n   * Calling conditions:\\n   *\\n   * - `amount` of ``from``'s tokens will be withdrawn into the pool\\n   */\\n  function _beforeWithdraw(address from, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/staking/Phase4aPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"./BasePool.sol\\\";\\nimport \\\"./extensions/DeadlinePool.sol\\\";\\n\\nimport \\\"./extensions/LockInPool.sol\\\";\\n\\n/**\\n * Phase 4a Pool - is a special ceremony pool that can only be joined within the window period and has a Lock in period for the tokens\\n */\\ncontract Phase4aPool is DeadlinePool, LockInPool {\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  /**\\n   * @notice Construct a new BasePool\\n   * @param _admin The default role controller\\n   * @param _rewardDistribution The reward distributor (can change reward rate)\\n   * @param _rewardToken The reward token to distribute\\n   * @param _stakingToken The staking token used to qualify for rewards\\n   * @param _startWindow When ceremony starts\\n   * @param _endWindow When ceremony ends\\n   */\\n  constructor(\\n    address _admin,\\n    address _rewardDistribution,\\n    address _rewardToken,\\n    address _stakingToken,\\n    uint256 _duration,\\n    uint256 _startWindow,\\n    uint256 _endWindow\\n  )\\n    DeadlinePool(\\n      _admin,\\n      _rewardDistribution,\\n      _rewardToken,\\n      _stakingToken,\\n      _duration,\\n      _startWindow,\\n      _endWindow\\n    )\\n  {}\\n\\n  // COMPILER HINTS for overrides\\n\\n  function _beforeStake(\\n    address staker,\\n    address recipient,\\n    uint256 amount\\n  ) internal virtual override(LockInPool, DeadlinePool) {\\n    super._beforeStake(staker, recipient, amount);\\n  }\\n\\n  function _beforeWithdraw(address from, uint256 amount)\\n    internal\\n    virtual\\n    override(BasePool, LockInPool)\\n  {\\n    super._beforeWithdraw(from, amount);\\n  }\\n\\n  function balanceOf(address account)\\n    public\\n    view\\n    virtual\\n    override(BasePool, LockInPool)\\n    returns (uint256)\\n  {\\n    return super.balanceOf(account);\\n  }\\n\\n  function totalSupply()\\n    public\\n    view\\n    virtual\\n    override(BasePool, LockInPool)\\n    returns (uint256)\\n  {\\n    return super.totalSupply();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/extensions/DeadlinePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"../BasePool.sol\\\";\\nimport \\\"../../lib/Windowed.sol\\\";\\n\\n/**\\n * @notice Only allow staking before the deadline.\\n */\\nabstract contract DeadlinePool is BasePool, Windowed {\\n  constructor(\\n    address _admin,\\n    address _rewardDistribution,\\n    address _rewardToken,\\n    address _stakingToken,\\n    uint256 _duration,\\n    uint256 _startWindow,\\n    uint256 _endWindow\\n  )\\n    BasePool(\\n      _admin,\\n      _rewardDistribution,\\n      _rewardToken,\\n      _stakingToken,\\n      _duration\\n    )\\n    Windowed(_startWindow, _endWindow)\\n  {}\\n\\n  function _beforeStake(\\n    address staker,\\n    address recipient,\\n    uint256 amount\\n  ) internal virtual override(BasePool) inWindow {\\n    super._beforeStake(staker, recipient, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/extensions/LockInPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../BasePool.sol\\\";\\n\\n/**\\n * Integrates a timelock of `LOCK_DURATION` on the Pool.\\n * Can only withdraw from the pool if:\\n * - not started\\n * - or requested an unlock and waited the `LOCK_DURATION`\\n * - or the rewards have finished for `REFILL_ALLOWANCE`.\\n */\\nabstract contract LockInPool is BasePool {\\n  using SafeMath for uint256;\\n\\n  uint256 private constant REFILL_ALLOWANCE = 2 hours;\\n  uint256 private constant LOCK_DURATION = 8 days;\\n\\n  mapping(address => uint256) public unlocks;\\n  uint256 private _unlockingSupply;\\n\\n  event Unlock(address indexed account);\\n\\n  /* ========== VIEWS ========== */\\n\\n  /**\\n   * @notice The balance that is currently being unlocked\\n   * @param account The account we're interested in.\\n   */\\n  function inLimbo(address account) public view returns (uint256) {\\n    if (unlocks[account] == 0) {\\n      return 0;\\n    }\\n    return super.balanceOf(account);\\n  }\\n\\n  /// @inheritdoc BasePool\\n  function balanceOf(address account)\\n    public\\n    view\\n    virtual\\n    override(BasePool)\\n    returns (uint256)\\n  {\\n    if (unlocks[account] != 0) {\\n      return 0;\\n    }\\n    return super.balanceOf(account);\\n  }\\n\\n  /// @inheritdoc BasePool\\n  function totalSupply()\\n    public\\n    view\\n    virtual\\n    override(BasePool)\\n    returns (uint256)\\n  {\\n    return super.totalSupply().sub(_unlockingSupply);\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n  /**\\n   * @notice Request unlock of the token, removing this senders reward accural by:\\n   * - Setting balanceOf to return 0 (used for reward calculation) and adjusting total supply by amount unlocking.\\n   */\\n  function unlock() external updateReward(msg.sender) {\\n    require(unlocks[msg.sender] == 0, \\\"LockIn/UnlockOnce\\\");\\n\\n    _unlockingSupply = _unlockingSupply.add(balanceOf(msg.sender));\\n    unlocks[msg.sender] = block.timestamp;\\n\\n    emit Unlock(msg.sender);\\n  }\\n\\n  /* ========== HOOKS ========== */\\n\\n  /**\\n   * @notice Handle unlocks when staking, resets lock if was unlocking\\n   */\\n  function _beforeStake(\\n    address staker,\\n    address recipient,\\n    uint256 amount\\n  ) internal virtual override(BasePool) {\\n    super._beforeStake(staker, recipient, amount);\\n\\n    if (unlocks[recipient] != 0) {\\n      // If we are resetting an unlock, reset the unlockingSupply\\n      _unlockingSupply = _unlockingSupply.sub(inLimbo(recipient));\\n      unlocks[recipient] = 0;\\n    }\\n  }\\n\\n  /**\\n   * @dev Prevent withdrawal if:\\n   * - has started (i.e. rewards have entered the pool)\\n   * - before finished (+ allowance)\\n   * - not unlocked `LOCK_DURATION` ago\\n   *\\n   * - reset the unlock, so you can re-enter.\\n   */\\n  function _beforeWithdraw(address recipient, uint256 amount)\\n    internal\\n    virtual\\n    override(BasePool)\\n  {\\n    super._beforeWithdraw(recipient, amount);\\n\\n    // Before rewards have been added / after + `REFILL`\\n    bool releaseWithoutLock =\\n      block.timestamp >= periodFinish.add(REFILL_ALLOWANCE);\\n\\n    // A lock has been requested and the `LOCK_DURATION` has passed.\\n    bool releaseWithLock =\\n      (unlocks[recipient] != 0) &&\\n        (unlocks[recipient] <= block.timestamp.sub(LOCK_DURATION));\\n\\n    require(releaseWithoutLock || releaseWithLock, \\\"LockIn/NotReleased\\\");\\n\\n    if (unlocks[recipient] != 0) {\\n      // Reduce unlocking supply (so we don't keep discounting total supply when\\n      // it is reduced). Amount will be validated in withdraw proper.\\n      _unlockingSupply = _unlockingSupply.sub(amount);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/Phase4Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"./extensions/LockInPool.sol\\\";\\n\\n/**\\n * Phase4Pool that acts as a SNX Reward Contract, with an 8 day token lock.\\n */\\ncontract Phase4Pool is LockInPool {\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  /**\\n   * @notice Construct a new Phase4Pool\\n   * @param _admin The default role controller\\n   * @param _rewardDistribution The reward distributor (can change reward rate)\\n   * @param _rewardToken The reward token to distribute\\n   * @param _stakingToken The staking token used to qualify for rewards\\n   * @param _duration Duration for token\\n   */\\n  constructor(\\n    address _admin,\\n    address _rewardDistribution,\\n    address _rewardToken,\\n    address _stakingToken,\\n    uint256 _duration\\n  )\\n    BasePool(\\n      _admin,\\n      _rewardDistribution,\\n      _rewardToken,\\n      _stakingToken,\\n      _duration\\n    )\\n  {}\\n}\\n\"\r\n    },\r\n    \"contracts/staking/extensions/MasterChefV2Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IMasterChefRewarder.sol\\\";\\n\\nimport \\\"../BasePool.sol\\\";\\n\\n// !!!! WIP !!!!!\\n// This code doesn't work. You can deposit via sushi, withdraw through normal functions.\\n// Must separate the balances and only keep them the same for the rewards.\\n\\n/**\\n * Provides adapters to allow this reward contract to be used as a MASTERCHEF V2 Rewards contract\\n */\\nabstract contract MasterChefV2Pool is BasePool, IMasterChefRewarder {\\n  using SafeMath for uint256;\\n\\n  address private immutable masterchefV2;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  /**\\n   * @notice Construct a new MasterChefV2Pool\\n   * @param _admin The default role controller\\n   * @param _rewardDistribution The reward distributor (can change reward rate)\\n   * @param _rewardToken The reward token to distribute\\n   * @param _stakingToken The staking token used to qualify for rewards\\n   * @param _duration The duration for each reward distribution\\n   * @param _masterchefv2 The trusted masterchef contract\\n   */\\n  constructor(\\n    address _admin,\\n    address _rewardDistribution,\\n    address _rewardToken,\\n    address _stakingToken,\\n    uint256 _duration,\\n    address _masterchefv2\\n  )\\n    BasePool(\\n      _admin,\\n      _rewardDistribution,\\n      _rewardToken,\\n      _stakingToken,\\n      _duration\\n    )\\n  {\\n    masterchefV2 = _masterchefv2;\\n  }\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier onlyMCV2 {\\n    require(msg.sender == masterchefV2, \\\"MasterChefV2Pool/OnlyMCV2\\\");\\n    _;\\n  }\\n\\n  /* ========== VIEWS ========== */\\n\\n  function pendingTokens(\\n    uint256,\\n    address user,\\n    uint256\\n  )\\n    external\\n    view\\n    override(IMasterChefRewarder)\\n    returns (IERC20[] memory rewardTokens, uint256[] memory rewardAmounts)\\n  {\\n    IERC20[] memory _rewardTokens = new IERC20[](1);\\n    _rewardTokens[0] = (rewardToken);\\n    uint256[] memory _rewardAmounts = new uint256[](1);\\n    _rewardAmounts[0] = earned(user);\\n    return (_rewardTokens, _rewardAmounts);\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n  /**\\n   * Adds to the internal balance record,\\n   */\\n  function onSushiReward(\\n    uint256,\\n    address _user,\\n    address,\\n    uint256,\\n    uint256 newLpAmount\\n  ) external override(IMasterChefRewarder) onlyMCV2 updateReward(_user) {\\n    uint256 internalBalance = _balances[_user];\\n    if (internalBalance > newLpAmount) {\\n      // _withdrawWithoutPush(_user, internalBalance.sub(newLpAmount));\\n    } else if (internalBalance < newLpAmount) {\\n      // _stakeWithoutPull(_user, _user, newLpAmount.sub(internalBalance));\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/interfaces/IMasterChefRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMasterChefRewarder {\\n  function onSushiReward(\\n    uint256 pid,\\n    address user,\\n    address recipient,\\n    uint256 sushiAmount,\\n    uint256 newLpAmount\\n  ) external;\\n\\n  function pendingTokens(\\n    uint256 pid,\\n    address user,\\n    uint256 sushiAmount\\n  ) external view returns (IERC20[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/mock/SupplyControlledTokenMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"../interfaces/ISupplyControlledERC20.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @dev {ERC20} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * This has an open mint functionality\\n */\\n// ISupplyControlledERC20,\\ncontract SupplyControlledTokenMock is AccessControl, ERC20Burnable {\\n  bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n  /**\\n   * @dev Grants `DEFAULT_ADMIN_ROLE` to the\\n   * account that deploys the contract.\\n   *\\n   * See {ERC20-constructor}.\\n   */\\n  constructor(\\n    address _admin,\\n    string memory _name,\\n    string memory _symbol,\\n    uint8 _decimals\\n  ) ERC20(_name, _symbol) {\\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n    _setupRole(MINTER_ROLE, _admin);\\n\\n    _setupDecimals(_decimals);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` new tokens for `to`.\\n   *\\n   * See {ERC20-_mint}.\\n   *\\n   */\\n  function mint(address to, uint256 amount) external {\\n    require(hasRole(MINTER_ROLE, _msgSender()), \\\"SCTokenMock/MinterRole\\\");\\n    _mint(to, amount);\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal override(ERC20) {\\n    // console.log(symbol(), from, \\\"->\\\", to);\\n    // console.log(symbol(), \\\">\\\", amount);\\n    super._beforeTokenTransfer(from, to, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/governance/TimeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n// Copyright 2020 Compound Labs, Inc.\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract TimeLock {\\n  using SafeMath for uint256;\\n\\n  event NewAdmin(address indexed newAdmin);\\n  event NewPendingAdmin(address indexed newPendingAdmin);\\n  event NewDelay(uint256 indexed newDelay);\\n  event CancelTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n  event ExecuteTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n  event QueueTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n\\n  uint256 public constant GRACE_PERIOD = 14 days;\\n  uint256 public constant MINIMUM_DELAY = 2 days;\\n  uint256 public constant MAXIMUM_DELAY = 30 days;\\n\\n  address public admin;\\n  address public pendingAdmin;\\n  uint256 public delay;\\n\\n  mapping(bytes32 => bool) public queuedTransactions;\\n\\n  constructor(address admin_, uint256 delay_) public {\\n    require(\\n      delay_ >= MINIMUM_DELAY,\\n      \\\"TimeLock::constructor: Delay must exceed minimum delay.\\\"\\n    );\\n    require(\\n      delay_ <= MAXIMUM_DELAY,\\n      \\\"TimeLock::constructor: Delay must not exceed maximum delay.\\\"\\n    );\\n\\n    admin = admin_;\\n    delay = delay_;\\n  }\\n\\n  fallback() external {}\\n\\n  function setDelay(uint256 delay_) public {\\n    require(\\n      msg.sender == address(this),\\n      \\\"TimeLock::setDelay: Call must come from TimeLock.\\\"\\n    );\\n    require(\\n      delay_ >= MINIMUM_DELAY,\\n      \\\"TimeLock::setDelay: Delay must exceed minimum delay.\\\"\\n    );\\n    require(\\n      delay_ <= MAXIMUM_DELAY,\\n      \\\"TimeLock::setDelay: Delay must not exceed maximum delay.\\\"\\n    );\\n    delay = delay_;\\n\\n    emit NewDelay(delay);\\n  }\\n\\n  function acceptAdmin() public {\\n    require(\\n      msg.sender == pendingAdmin,\\n      \\\"TimeLock::acceptAdmin: Call must come from pendingAdmin.\\\"\\n    );\\n    admin = msg.sender;\\n    pendingAdmin = address(0);\\n\\n    emit NewAdmin(admin);\\n  }\\n\\n  function setPendingAdmin(address pendingAdmin_) public {\\n    require(\\n      msg.sender == address(this),\\n      \\\"TimeLock::setPendingAdmin: Call must come from TimeLock.\\\"\\n    );\\n    pendingAdmin = pendingAdmin_;\\n\\n    emit NewPendingAdmin(pendingAdmin);\\n  }\\n\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) public returns (bytes32) {\\n    require(\\n      msg.sender == admin,\\n      \\\"TimeLock::queueTransaction: Call must come from admin.\\\"\\n    );\\n    require(\\n      eta >= getBlockTimestamp().add(delay),\\n      \\\"TimeLock::queueTransaction: Estimated execution block must satisfy delay.\\\"\\n    );\\n\\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n    queuedTransactions[txHash] = true;\\n\\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\\n    return txHash;\\n  }\\n\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) public {\\n    require(\\n      msg.sender == admin,\\n      \\\"TimeLock::cancelTransaction: Call must come from admin.\\\"\\n    );\\n\\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n    queuedTransactions[txHash] = false;\\n\\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\\n  }\\n\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) public payable returns (bytes memory) {\\n    require(\\n      msg.sender == admin,\\n      \\\"TimeLock::executeTransaction: Call must come from admin.\\\"\\n    );\\n\\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n    require(\\n      queuedTransactions[txHash],\\n      \\\"TimeLock::executeTransaction: Transaction hasn't been queued.\\\"\\n    );\\n    require(\\n      getBlockTimestamp() >= eta,\\n      \\\"TimeLock::executeTransaction: Transaction hasn't surpassed time lock.\\\"\\n    );\\n    require(\\n      getBlockTimestamp() <= eta.add(GRACE_PERIOD),\\n      \\\"TimeLock::executeTransaction: Transaction is stale.\\\"\\n    );\\n\\n    queuedTransactions[txHash] = false;\\n\\n    bytes memory callData;\\n\\n    if (bytes(signature).length == 0) {\\n      callData = data;\\n    } else {\\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n    }\\n\\n    // solium-disable-next-line security/no-call-value\\n    (bool success, bytes memory returnData) =\\n      target.call{value: value}(callData);\\n    require(\\n      success,\\n      \\\"TimeLock::executeTransaction: Transaction execution reverted.\\\"\\n    );\\n\\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\\n\\n    return returnData;\\n  }\\n\\n  function getBlockTimestamp() internal view returns (uint256) {\\n    // solium-disable-next-line security/no-block-members\\n    return block.timestamp;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/mock/TimeLockMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n// Copyright 2020 Compound Labs, Inc.\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"../TimeLock.sol\\\";\\n\\ncontract TimeLockMock is TimeLock {\\n  constructor(address admin_, uint256 delay_)\\n    TimeLock(admin_, TimeLock.MINIMUM_DELAY)\\n  {\\n    admin = admin_;\\n    delay = delay_;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/auxiliary/EarnedAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"synthetix/contracts/interfaces/IStakingRewards.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract EarnedAggregator {\\n  /// @notice The address of the Float Protocol Timelock\\n  address public timelock;\\n\\n  /// @notice addresses of pools (Staking Rewards Contracts)\\n  address[] public pools;\\n\\n  constructor(address timelock_, address[] memory pools_) {\\n    timelock = timelock_;\\n    pools = pools_;\\n  }\\n\\n  function getPools() public view returns (address[] memory) {\\n    address[] memory pls = pools;\\n    return pls;\\n  }\\n\\n  function addPool(address pool) public {\\n    // Sanity check for function and no error\\n    IStakingRewards(pool).earned(timelock);\\n\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      require(pools[i] != pool, \\\"already added\\\");\\n    }\\n\\n    require(msg.sender == address(timelock), \\\"EarnedAggregator: !timelock\\\");\\n    pools.push(pool);\\n  }\\n\\n  function removePool(uint256 index) public {\\n    require(msg.sender == address(timelock), \\\"EarnedAggregator: !timelock\\\");\\n    if (index >= pools.length) return;\\n\\n    if (index != pools.length - 1) {\\n      pools[index] = pools[pools.length - 1];\\n    }\\n\\n    pools.pop();\\n  }\\n\\n  function getCurrentEarned(address account) public view returns (uint256) {\\n    uint256 votes = 0;\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      // get tokens earned for staking\\n      votes = SafeMath.add(votes, IStakingRewards(pools[i]).earned(account));\\n    }\\n    return votes;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/mock/AuctionHouseMathTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"../AuctionHouseMath.sol\\\";\\n\\ncontract AuctionHouseMathTest is AuctionHouseMath {\\n  function _lerp(\\n    uint256 start,\\n    uint256 end,\\n    uint16 step,\\n    uint16 maxStep\\n  ) public pure returns (uint256 result) {\\n    return lerp(start, end, step, maxStep);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/funds/BasketV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../external-lib/SafeDecimalMath.sol\\\";\\n\\nimport \\\"./interfaces/IBasket.sol\\\";\\nimport \\\"./BasketMath.sol\\\";\\n\\n/**\\n * @title Float Protocol Basket\\n * @notice The logic contract for storing underlying ETH (as wETH)\\n */\\ncontract BasketV1 is IBasket, Initializable, AccessControlUpgradeable {\\n  using SafeMath for uint256;\\n  using SafeDecimalMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  /* ========== CONSTANTS ========== */\\n  bytes32 public constant GOVERNANCE_ROLE = keccak256(\\\"GOVERNANCE_ROLE\\\");\\n  bytes32 public constant AUCTION_HOUSE_ROLE = keccak256(\\\"AUCTION_HOUSE_ROLE\\\");\\n\\n  /* ========== STATE VARIABLES ========== */\\n  IERC20 public float;\\n  IERC20 private weth;\\n\\n  /**\\n   * @notice The target ratio for \\\"collateralisation\\\"\\n   * @dev [e27] Start at 100%\\n   */\\n  uint256 public targetRatio;\\n\\n  function initialize(\\n    address _admin,\\n    address _weth,\\n    address _float\\n  ) external initializer {\\n    weth = IERC20(_weth);\\n    float = IERC20(_float);\\n    targetRatio = SafeDecimalMath.PRECISE_UNIT;\\n\\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n    _setupRole(GOVERNANCE_ROLE, _admin);\\n  }\\n\\n  /* ========== MODIFIERS ========== */\\n\\n  modifier onlyGovernance {\\n    require(\\n      hasRole(GOVERNANCE_ROLE, _msgSender()),\\n      \\\"AuctionHouse/GovernanceRole\\\"\\n    );\\n    _;\\n  }\\n\\n  /* ========== VIEWS ========== */\\n\\n  /// @inheritdoc IBasketReader\\n  function underlying() public view override(IBasketReader) returns (address) {\\n    return address(weth);\\n  }\\n\\n  /// @inheritdoc IBasketReader\\n  function getBasketFactor(uint256 targetPriceInEth)\\n    external\\n    view\\n    override(IBasketReader)\\n    returns (uint256 basketFactor)\\n  {\\n    uint256 wethInBasket = weth.balanceOf(address(this));\\n    uint256 floatTotalSupply = float.totalSupply();\\n\\n    return\\n      basketFactor = BasketMath.calcBasketFactor(\\n        targetPriceInEth,\\n        wethInBasket,\\n        floatTotalSupply,\\n        targetRatio\\n      );\\n  }\\n\\n  /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n  /* ----- onlyGovernance ----- */\\n\\n  /// @inheritdoc IBasketGovernedActions\\n  function buildAuctionHouse(address _auctionHouse, uint256 _allowance)\\n    external\\n    override(IBasketGovernedActions)\\n    onlyGovernance\\n  {\\n    grantRole(AUCTION_HOUSE_ROLE, _auctionHouse);\\n    weth.safeApprove(_auctionHouse, 0);\\n    weth.safeApprove(_auctionHouse, _allowance);\\n  }\\n\\n  /// @inheritdoc IBasketGovernedActions\\n  function burnAuctionHouse(address _auctionHouse)\\n    external\\n    override(IBasketGovernedActions)\\n    onlyGovernance\\n  {\\n    revokeRole(AUCTION_HOUSE_ROLE, _auctionHouse);\\n    weth.safeApprove(_auctionHouse, 0);\\n  }\\n\\n  /// @inheritdoc IBasketGovernedActions\\n  function setTargetRatio(uint256 _targetRatio)\\n    external\\n    override(IBasketGovernedActions)\\n    onlyGovernance\\n  {\\n    require(\\n      _targetRatio <= BasketMath.MAX_TARGET_RATIO,\\n      \\\"BasketV1/RatioTooHigh\\\"\\n    );\\n    require(\\n      _targetRatio >= BasketMath.MIN_TARGET_RATIO,\\n      \\\"BasketV1/RatioTooLow\\\"\\n    );\\n    targetRatio = _targetRatio;\\n\\n    emit NewTargetRatio(_targetRatio);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable {\\n    function __AccessControl_init() internal initializer {\\n        __Context_init_unchained();\\n        __AccessControl_init_unchained();\\n    }\\n\\n    function __AccessControl_init_unchained() internal initializer {\\n    }\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using AddressUpgradeable for address;\\n\\n    struct RoleData {\\n        EnumerableSetUpgradeable.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/funds/interfaces/IBasket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./basket/IBasketReader.sol\\\";\\nimport \\\"./basket/IBasketGovernedActions.sol\\\";\\n\\n/**\\n * @title The interface for a Float Protocol Asset Basket\\n * @notice A Basket stores value used to stabilise price and assess the\\n * the movement of the underlying assets we're trying to track.\\n * @dev The Basket interface is broken up into many smaller pieces to allow only\\n * relevant parts to be imported\\n */\\ninterface IBasket is IBasketReader, IBasketGovernedActions {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/funds/BasketMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"../external-lib/SafeDecimalMath.sol\\\";\\n\\nlibrary BasketMath {\\n  using SafeMath for uint256;\\n  using SafeDecimalMath for uint256;\\n\\n  // SafeDecimalMath.PRECISE_UNIT = 1e27\\n  uint256 internal constant MIN_TARGET_RATIO = 0.1e27;\\n  uint256 internal constant MAX_TARGET_RATIO = 2e27;\\n\\n  /**\\n   * @dev bF = ( eS / (fS * tP) ) / Q\\n   * @param targetPriceInEth [e27] target price (tP).\\n   * @param ethStored [e18] denoting total eth stored in basket (eS).\\n   * @param floatSupply [e18] denoting total floatSupply (fS).\\n   * @param targetRatio [e27] target ratio (Q)\\n   * @return basketFactor an [e27] decimal (bF)\\n   */\\n  function calcBasketFactor(\\n    uint256 targetPriceInEth,\\n    uint256 ethStored,\\n    uint256 floatSupply,\\n    uint256 targetRatio\\n  ) internal pure returns (uint256 basketFactor) {\\n    // Note that targetRatio should already be checked on set\\n    assert(targetRatio >= MIN_TARGET_RATIO);\\n    assert(targetRatio <= MAX_TARGET_RATIO);\\n    uint256 floatValue =\\n      floatSupply.multiplyDecimalRoundPrecise(targetPriceInEth);\\n    uint256 basketRatio = ethStored.divideDecimalRoundPrecise(floatValue);\\n    return basketFactor = basketRatio.divideDecimalRoundPrecise(targetRatio);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/funds/interfaces/basket/IBasketGovernedActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\n/**\\n * @title Basket Actions with suitable access control\\n * @notice Contains actions which can only be called by governance.\\n */\\ninterface IBasketGovernedActions {\\n  event NewTargetRatio(uint256 targetRatio);\\n\\n  /**\\n   * @notice Sets the basket target factor, initially \\\"1\\\"\\n   * @dev Expects an [e27] fixed point decimal value.\\n   * Target Ratio is what the basket factor is \\\"aiming for\\\",\\n   * i.e. target ratio = 0.8 then an 80% support from the basket\\n   * results in a 100% Basket Factor.\\n   * @param _targetRatio [e27] The new Target ratio\\n   */\\n  function setTargetRatio(uint256 _targetRatio) external;\\n\\n  /**\\n   * @notice Connect and approve a new auction house to spend from the basket.\\n   * @dev Note that any allowance can be set, and even type(uint256).max will\\n   * slowly be eroded.\\n   * @param _auctionHouse The Auction House address to approve\\n   * @param _allowance The amount of the underlying token it can spend\\n   */\\n  function buildAuctionHouse(address _auctionHouse, uint256 _allowance)\\n    external;\\n\\n  /**\\n   * @notice Remove an auction house, allows easy upgrades.\\n   * @param _auctionHouse The Auction House address to revoke.\\n   */\\n  function burnAuctionHouse(address _auctionHouse) external;\\n}\\n\"\r\n    },\r\n    \"contracts/funds/mock/BasketMathHarness.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"../BasketMath.sol\\\";\\n\\ncontract BasketMathHarness {\\n  function _calcBasketFactor(\\n    uint256 targetPriceInEth,\\n    uint256 ethStored,\\n    uint256 floatSupply,\\n    uint256 targetRatio\\n  ) external pure returns (uint256 basketFactor) {\\n    return\\n      BasketMath.calcBasketFactor(\\n        targetPriceInEth,\\n        ethStored,\\n        floatSupply,\\n        targetRatio\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/ERC20PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\n\\n/**\\n * @title {ERC20} Pausable token through the PAUSER_ROLE\\n *\\n * @dev This contract uses OpenZeppelin {AccessControlUpgradeable} to lock permissioned functions using the different roles.\\n */\\nabstract contract ERC20PausableUpgradeable is\\n  Initializable,\\n  PausableUpgradeable,\\n  AccessControlUpgradeable,\\n  ERC20Upgradeable\\n{\\n  bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n  // solhint-disable-next-line func-name-mixedcase\\n  function __ERC20Pausable_init_unchained(address pauser) internal initializer {\\n    _setupRole(PAUSER_ROLE, pauser);\\n  }\\n\\n  /**\\n   * @dev Pauses all token transfers.\\n   *\\n   * See {ERC20Pausable} and {Pausable-_pause}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have the `PAUSER_ROLE`.\\n   */\\n  function pause() external {\\n    require(\\n      hasRole(PAUSER_ROLE, _msgSender()),\\n      \\\"ERC20Pausable/PauserRoleRequired\\\"\\n    );\\n    _pause();\\n  }\\n\\n  /**\\n   * @dev Unpauses all token transfers.\\n   *\\n   * See {ERC20Pausable} and {Pausable-_unpause}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have the `PAUSER_ROLE`.\\n   */\\n  function unpause() external {\\n    require(\\n      hasRole(PAUSER_ROLE, _msgSender()),\\n      \\\"ERC20Pausable/PauserRoleRequired\\\"\\n    );\\n    _unpause();\\n  }\\n\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual override(ERC20Upgradeable) {\\n    super._beforeTokenTransfer(from, to, amount);\\n\\n    require(!paused(), \\\"ERC20Pausable/Paused\\\");\\n  }\\n\\n  uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"../../math/SafeMathUpgradeable.sol\\\";\\nimport \\\"../../proxy/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\\n    using SafeMathUpgradeable for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n    uint256[44] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/FloatTokenV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\n\\nimport \\\"./ERC20PermitUpgradeable.sol\\\";\\nimport \\\"./ERC20PausableUpgradeable.sol\\\";\\nimport \\\"./ERC20SupplyControlledUpgradeable.sol\\\";\\n\\n/**\\n * @dev {ERC20} FLOAT token, including:\\n *\\n * - a minter role that allows for token minting (necessary for stabilisation)\\n * - the ability to burn tokens (necessary for stabilisation)\\n * - the use of permits to reduce gas costs\\n * - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses OpenZeppelin {AccessControlUpgradeable} to lock permissioned functions\\n * using the different roles.\\n * This contract is upgradable.\\n */\\ncontract FloatTokenV1 is\\n  ERC20PausableUpgradeable,\\n  ERC20PermitUpgradeable,\\n  ERC20SupplyControlledUpgradeable\\n{\\n  /**\\n   * @notice Construct a FloatTokenV1 instance\\n   * @param governance The default role controller, minter and pauser for the contract.\\n   * @param minter An additional minter (useful for quick launches, check this is revoked)\\n   * @dev We expect minters to be defined on deploy, e.g. AuctionHouse should get minter role\\n   */\\n  function initialize(address governance, address minter) external initializer {\\n    __Context_init_unchained();\\n    __ERC20_init_unchained(\\\"Float Protocol: FLOAT\\\", \\\"FLOAT\\\");\\n    __ERC20Permit_init_unchained(\\\"Float Protocol: FLOAT\\\", \\\"1\\\");\\n    __ERC20Pausable_init_unchained(governance);\\n    __ERC20SupplyControlled_init_unchained(governance);\\n\\n    _setupRole(DEFAULT_ADMIN_ROLE, governance);\\n\\n    // Quick launches\\n    _setupRole(MINTER_ROLE, minter);\\n  }\\n\\n  /// @dev Hint to compiler, that this override has already occured.\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\\n    super._beforeTokenTransfer(from, to, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/ERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\n\\nimport \\\"../external-lib/Counters.sol\\\";\\nimport \\\"../external-lib/EIP712.sol\\\";\\nimport \\\"./interfaces/IERC20Permit.sol\\\";\\n\\n/**\\n * @dev Wrapper implementation for ERC20 Permit extension allowing approvals\\n * via signatures, as defined in https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ncontract ERC20PermitUpgradeable is\\n  IERC20Permit,\\n  Initializable,\\n  ERC20Upgradeable\\n{\\n  using Counters for Counters.Counter;\\n\\n  bytes32 private constant PERMIT_TYPEHASH =\\n    keccak256(\\n      \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n    );\\n\\n  bytes32 internal _domainSeparator;\\n\\n  mapping(address => Counters.Counter) private _nonces;\\n\\n  // solhint-disable-next-line func-name-mixedcase\\n  function __ERC20Permit_init_unchained(\\n    string memory domainName,\\n    string memory version\\n  ) internal initializer {\\n    _domainSeparator = EIP712.domainSeparatorV4(domainName, version);\\n  }\\n\\n  /// @inheritdoc IERC20Permit\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR()\\n    external\\n    view\\n    override(IERC20Permit)\\n    returns (bytes32)\\n  {\\n    return _domainSeparator;\\n  }\\n\\n  /**\\n   * @dev See {IERC20Permit-permit}.\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external override(IERC20Permit) {\\n    // solhint-disable-next-line not-rely-on-time\\n    require(block.timestamp <= deadline, \\\"ERC20Permit/ExpiredDeadline\\\");\\n\\n    bytes32 structHash =\\n      keccak256(\\n        abi.encode(\\n          PERMIT_TYPEHASH,\\n          owner,\\n          spender,\\n          value,\\n          _useNonce(owner),\\n          deadline\\n        )\\n      );\\n\\n    bytes32 hash = EIP712.hashTypedDataV4(_domainSeparator, structHash);\\n\\n    address signer = ECDSA.recover(hash, v, r, s);\\n    require(signer == owner, \\\"ERC20Permit/InvalidSignature\\\");\\n\\n    _approve(owner, spender, value);\\n  }\\n\\n  /// @inheritdoc IERC20Permit\\n  function nonces(address owner)\\n    external\\n    view\\n    virtual\\n    override(IERC20Permit)\\n    returns (uint256)\\n  {\\n    return _nonces[owner].current();\\n  }\\n\\n  /**\\n   * @dev \\\"Consume a nonce\\\": return the current value and increment.\\n   */\\n  function _useNonce(address owner) internal virtual returns (uint256 current) {\\n    Counters.Counter storage nonce = _nonces[owner];\\n    current = nonce.current();\\n    nonce.increment();\\n  }\\n\\n  uint256[48] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/ERC20SupplyControlledUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @title {ERC20} Supply Controlled token that allows burning (by all), and minting\\n * by MINTER_ROLE\\n *\\n * @dev This contract uses OpenZeppelin {AccessControlUpgradeable} to lock permissioned functions using the different roles.\\n */\\nabstract contract ERC20SupplyControlledUpgradeable is\\n  Initializable,\\n  AccessControlUpgradeable,\\n  ERC20Upgradeable\\n{\\n  using SafeMath for uint256;\\n\\n  bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n  // solhint-disable-next-line func-name-mixedcase\\n  function __ERC20SupplyControlled_init_unchained(address minter)\\n    internal\\n    initializer\\n  {\\n    _setupRole(MINTER_ROLE, minter);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` new tokens for `to`.\\n   *\\n   * See {ERC20-_mint}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have the `MINTER_ROLE`.\\n   */\\n  function mint(address to, uint256 amount) external virtual {\\n    require(\\n      hasRole(MINTER_ROLE, _msgSender()),\\n      \\\"ERC20SupplyControlled/MinterRole\\\"\\n    );\\n    _mint(to, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller.\\n   *\\n   * See {ERC20-_burn}.\\n   */\\n  function burn(uint256 amount) external virtual {\\n    _burn(_msgSender(), amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n   * allowance.\\n   *\\n   * See {ERC20-_burn} and {ERC20-allowance}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have allowance for `accounts`'s tokens of at least\\n   * `amount`.\\n   */\\n  function burnFrom(address account, uint256 amount) external virtual {\\n    uint256 decreasedAllowance =\\n      allowance(account, _msgSender()).sub(\\n        amount,\\n        \\\"ERC20SupplyControlled/Overburn\\\"\\n      );\\n\\n    _approve(account, _msgSender(), decreasedAllowance);\\n    _burn(account, amount);\\n  }\\n\\n  uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/external-lib/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs) https://github.com/OpenZeppelin/openzeppelin-contracts\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n  struct Counter {\\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\\n    uint256 _value; // default: 0\\n  }\\n\\n  function current(Counter storage counter) internal view returns (uint256) {\\n    return counter._value;\\n  }\\n\\n  function increment(Counter storage counter) internal {\\n    counter._value += 1;\\n  }\\n\\n  function decrement(Counter storage counter) internal {\\n    uint256 value = counter._value;\\n    require(value > 0, \\\"Counter: decrement overflow\\\");\\n    counter._value = value - 1;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external-lib/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n// Based on OpenZeppelin's draft EIP712, with updates to remove storage variables.\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n */\\nlibrary EIP712 {\\n  bytes32 private constant _TYPE_HASH =\\n    keccak256(\\n      \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n    );\\n\\n  /**\\n   * @dev Returns the domain separator for the current chain.\\n   */\\n  function domainSeparatorV4(string memory name, string memory version)\\n    internal\\n    view\\n    returns (bytes32)\\n  {\\n    return\\n      _buildDomainSeparator(\\n        _TYPE_HASH,\\n        keccak256(bytes(name)),\\n        keccak256(bytes(version))\\n      );\\n  }\\n\\n  function _buildDomainSeparator(\\n    bytes32 typeHash,\\n    bytes32 name,\\n    bytes32 version\\n  ) private view returns (bytes32) {\\n    uint256 chainId;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      chainId := chainid()\\n    }\\n    return\\n      keccak256(abi.encode(typeHash, name, version, chainId, address(this)));\\n  }\\n\\n  /**\\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n   * function returns the hash of the fully encoded EIP712 message for the given domain.\\n   *\\n   * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n   *\\n   * ```solidity\\n   * bytes32 digest = EIP712.hashTypedDataV4(\\n   *   EIP712.domainSeparatorV4(\\\"DApp Name\\\", \\\"1\\\"),\\n   *   keccak256(abi.encode(\\n   *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n   *     mailTo,\\n   *     keccak256(bytes(mailContents))\\n   * )));\\n   * address signer = ECDSA.recover(digest, signature);\\n   * ```\\n   */\\n  function hashTypedDataV4(bytes32 domainSeparator, bytes32 structHash)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    return ECDSA.toTypedDataHash(domainSeparator, structHash);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n   * given ``owner``'s signed approval.\\n   *\\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n   * ordering also apply here.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `deadline` must be a timestamp in the future.\\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n   * over the EIP712-formatted function arguments.\\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\\n   *\\n   * For more information on the signature format, see the\\n   * https://eips.ethereum.org/EIPS/eip-2612.\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n   * included whenever a signature is generated for {permit}.\\n   *\\n   * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n   * prevents a signature from being used multiple times.\\n   */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/external-lib/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n  /**\\n   * @dev Returns the address that signed a hashed message (`hash`) with\\n   * `signature`. This address can then be used for verification purposes.\\n   *\\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n   * this function rejects them by requiring the `s` value to be in the lower\\n   * half order, and the `v` value to be either 27 or 28.\\n   *\\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n   * verification to be secure: it is possible to craft signatures that\\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n   * this is by receiving a hash of the original message (which may otherwise\\n   * be too long), and then calling {toEthSignedMessageHash} on it.\\n   */\\n  function recover(bytes32 hash, bytes memory signature)\\n    internal\\n    pure\\n    returns (address)\\n  {\\n    // Divide the signature in r, s and v variables\\n    bytes32 r;\\n    bytes32 s;\\n    uint8 v;\\n\\n    // Check the signature length\\n    // - case 65: r,s,v signature (standard)\\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n    if (signature.length == 65) {\\n      // ecrecover takes the signature parameters, and the only way to get them\\n      // currently is to use assembly.\\n      // solhint-disable-next-line no-inline-assembly\\n      assembly {\\n        r := mload(add(signature, 0x20))\\n        s := mload(add(signature, 0x40))\\n        v := byte(0, mload(add(signature, 0x60)))\\n      }\\n    } else if (signature.length == 64) {\\n      // ecrecover takes the signature parameters, and the only way to get them\\n      // currently is to use assembly.\\n      // solhint-disable-next-line no-inline-assembly\\n      assembly {\\n        let vs := mload(add(signature, 0x40))\\n        r := mload(add(signature, 0x20))\\n        s := and(\\n          vs,\\n          0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n        )\\n        v := add(shr(255, vs), 27)\\n      }\\n    } else {\\n      revert(\\\"ECDSA: invalid signature length\\\");\\n    }\\n\\n    return recover(hash, v, r, s);\\n  }\\n\\n  /**\\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\\n   * `r` and `s` signature fields separately.\\n   */\\n  function recover(\\n    bytes32 hash,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal pure returns (address) {\\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n    // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n    //\\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n    // these malleable signatures as well.\\n    require(\\n      uint256(s) <=\\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n      \\\"ECDSA: invalid signature 's' value\\\"\\n    );\\n    require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n    // If the signature is valid (and not malleable), return the signer address\\n    address signer = ecrecover(hash, v, r, s);\\n    require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n    return signer;\\n  }\\n\\n  /**\\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n   * produces hash corresponding to the one signed with the\\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n   * JSON-RPC method as part of EIP-191.\\n   *\\n   * See {recover}.\\n   */\\n  function toEthSignedMessageHash(bytes32 hash)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    // 32 is the length in bytes of hash,\\n    // enforced by the type signature above\\n    return\\n      keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n  }\\n\\n  /**\\n   * @dev Returns an Ethereum Signed Typed Data, created from a\\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\\n   * to the one signed with the\\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n   * JSON-RPC method as part of EIP-712.\\n   *\\n   * See {recover}.\\n   */\\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/BankToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\n\\n/**\\n * @dev {ERC20} BANK token, including:\\n * \\n * - a minter role that allows for token minting (creation)\\n * - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses OpenZeppelin {AccessControlUpgradeable} to lock permissioned functions\\n * using the different roles.\\n * This contract is upgradable.\\n */\\ncontract BankToken is Initializable, PausableUpgradeable, AccessControlUpgradeable, ERC20Upgradeable {\\n  bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n  bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n  /**\\n    @notice Construct a BankToken instance\\n    @param admin The default role controller, minter and pauser for the contract.\\n    @param minter An additional minter (for quick launch of epoch 1).\\n   */\\n  function initialize(address admin, address minter) public initializer {\\n    __ERC20_init(\\\"Float Bank\\\", \\\"BANK\\\");\\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\\n\\n    _setupRole(MINTER_ROLE, admin);\\n    _setupRole(MINTER_ROLE, minter);\\n    _setupRole(PAUSER_ROLE, admin);\\n  }\\n\\n  /**\\n    * @dev Creates `amount` new tokens for `to`.\\n    *\\n    * See {ERC20-_mint}.\\n    *\\n    * Requirements:\\n    *\\n    * - the caller must have the `MINTER_ROLE`.\\n    */\\n  function mint(address to, uint256 amount) public virtual {\\n    require(hasRole(MINTER_ROLE, _msgSender()), \\\"Bank::mint: must have minter role to mint\\\");\\n    _mint(to, amount);\\n  }\\n\\n  /**\\n    * @dev Pauses all token transfers.\\n    *\\n    * See {ERC20Pausable} and {Pausable-_pause}.\\n    *\\n    * Requirements:\\n    *\\n    * - the caller must have the `PAUSER_ROLE`.\\n    */\\n  function pause() public virtual {\\n    require(hasRole(PAUSER_ROLE, _msgSender()), \\\"Bank::pause: must have pauser role to pause\\\");\\n    _pause();\\n  }\\n\\n  /**\\n    * @dev Unpauses all token transfers.\\n    *\\n    * See {ERC20Pausable} and {Pausable-_unpause}.\\n    *\\n    * Requirements:\\n    *\\n    * - the caller must have the `PAUSER_ROLE`.\\n    */\\n  function unpause() public virtual {\\n    require(hasRole(PAUSER_ROLE, _msgSender()), \\\"Bank::unpause: must have pauser role to unpause\\\");\\n    _unpause();\\n  }\\n\\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual\\n    override(ERC20Upgradeable) {\\n      super._beforeTokenTransfer(from, to, amount);\\n\\n      require(!paused(), \\\"ERC20Pausable: token transfer while paused\\\");\\n  }\\n}\"\r\n    },\r\n    \"contracts/tokens/BankTokenV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\n\\nimport \\\"../lib/Upgradeable.sol\\\";\\nimport \\\"./ERC20PermitUpgradeable.sol\\\";\\nimport \\\"./ERC20PausableUpgradeable.sol\\\";\\nimport \\\"./ERC20SupplyControlledUpgradeable.sol\\\";\\n\\n/**\\n * @dev {ERC20} BANK token, including:\\n *\\n * - a minter role that allows for token minting (necessary for stabilisation)\\n * - the ability to burn tokens (necessary for stabilisation)\\n * - the use of permits to reduce gas costs\\n * - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses OpenZeppelin {AccessControlUpgradeable} to lock permissioned functions\\n * using the different roles.\\n * This contract is upgradable.\\n */\\ncontract BankTokenV2 is\\n  ERC20PausableUpgradeable,\\n  ERC20PermitUpgradeable,\\n  ERC20SupplyControlledUpgradeable,\\n  Upgradeable\\n{\\n  /**\\n   * @notice Construct a brand new BankTokenV2 instance\\n   * @param governance The default role controller, minter and pauser for the contract.\\n   * @dev We expect minters to be defined after deploy, e.g. AuctionHouse should get minter role\\n   */\\n  function initialize(address governance) external initializer {\\n    _version = 2;\\n\\n    __Context_init_unchained();\\n    __ERC20_init_unchained(\\\"Float Bank\\\", \\\"BANK\\\");\\n    __ERC20Permit_init_unchained(\\\"Float Protocol: BANK\\\", \\\"2\\\");\\n    __ERC20Pausable_init_unchained(governance);\\n    __ERC20SupplyControlled_init_unchained(governance);\\n    _setupRole(DEFAULT_ADMIN_ROLE, governance);\\n  }\\n\\n  /**\\n   * @notice Upgrade from V1, and initialise the relevant \\\"new\\\" state\\n   * @dev Uses upgradeAndCall in the ProxyAdmin, to call upgradeToAndCall, which will delegatecall this function.\\n   * _version keeps this single use\\n   * onlyProxyAdmin ensures this only occurs on upgrade\\n   */\\n  function upgrade() external onlyProxyAdmin {\\n    require(_version < 2, \\\"BankTokenV2/AlreadyUpgraded\\\");\\n    _version = 2;\\n    _domainSeparator = EIP712.domainSeparatorV4(\\\"Float Protocol: BANK\\\", \\\"2\\\");\\n  }\\n\\n  /// @dev Hint to compiler that this override has already occured.\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\\n    super._beforeTokenTransfer(from, to, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\n\\n/**\\n * @title Upgradeable\\n * @dev This contract provides special helper functions when using the upgradeability proxy.\\n */\\nabstract contract Upgradeable {\\n  uint256 internal _version;\\n\\n  /**\\n   * @dev Storage slot with the admin of the contract.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n   */\\n  bytes32 internal constant ADMIN_SLOT =\\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n  modifier onlyProxyAdmin() {\\n    address proxyAdmin;\\n    bytes32 slot = ADMIN_SLOT;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      proxyAdmin := sload(slot)\\n    }\\n    require(msg.sender == proxyAdmin, \\\"Upgradeable/MustBeProxyAdmin\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/mock/BasisMathMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.7.6;\\n\\nimport \\\"../BasisMath.sol\\\";\\n\\ncontract BasisMathMock {\\n  using BasisMath for uint256;\\n\\n  function _splitBy(uint256 value, uint256 percentage)\\n    public\\n    pure\\n    returns (uint256, uint256)\\n  {\\n    return value.splitBy(percentage);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external-lib/zapper/ZapBaseV1.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n// SPDX-License-Identifier: GPLv2\\n\\n// Changes:\\n// - Conversion to 0.7.6\\n//   - library imports throughout\\n//   - remove revert fallback as now default\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\npragma solidity ^0.7.6;\\n\\ncontract ZapBaseV1 is Ownable {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n  bool public stopped = false;\\n\\n  // if true, goodwill is not deducted\\n  mapping(address => bool) public feeWhitelist;\\n\\n  uint256 public goodwill;\\n  // % share of goodwill (0-100 %)\\n  uint256 affiliateSplit;\\n  // restrict affiliates\\n  mapping(address => bool) public affiliates;\\n  // affiliate => token => amount\\n  mapping(address => mapping(address => uint256)) public affiliateBalance;\\n  // token => amount\\n  mapping(address => uint256) public totalAffiliateBalance;\\n\\n  address internal constant ETHAddress =\\n    0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  constructor(uint256 _goodwill, uint256 _affiliateSplit) {\\n    goodwill = _goodwill;\\n    affiliateSplit = _affiliateSplit;\\n  }\\n\\n  // circuit breaker modifiers\\n  modifier stopInEmergency {\\n    if (stopped) {\\n      revert(\\\"Temporarily Paused\\\");\\n    } else {\\n      _;\\n    }\\n  }\\n\\n  function _getBalance(address token) internal view returns (uint256 balance) {\\n    if (token == address(0)) {\\n      balance = address(this).balance;\\n    } else {\\n      balance = IERC20(token).balanceOf(address(this));\\n    }\\n  }\\n\\n  function _approveToken(address token, address spender) internal {\\n    IERC20 _token = IERC20(token);\\n    if (_token.allowance(address(this), spender) > 0) return;\\n    else {\\n      _token.safeApprove(spender, uint256(-1));\\n    }\\n  }\\n\\n  function _approveToken(\\n    address token,\\n    address spender,\\n    uint256 amount\\n  ) internal {\\n    IERC20 _token = IERC20(token);\\n    _token.safeApprove(spender, 0);\\n    _token.safeApprove(spender, amount);\\n  }\\n\\n  // - to Pause the contract\\n  function toggleContractActive() public onlyOwner {\\n    stopped = !stopped;\\n  }\\n\\n  function set_feeWhitelist(address zapAddress, bool status)\\n    external\\n    onlyOwner\\n  {\\n    feeWhitelist[zapAddress] = status;\\n  }\\n\\n  function set_new_goodwill(uint256 _new_goodwill) public onlyOwner {\\n    require(\\n      _new_goodwill >= 0 && _new_goodwill <= 100,\\n      \\\"GoodWill Value not allowed\\\"\\n    );\\n    goodwill = _new_goodwill;\\n  }\\n\\n  function set_new_affiliateSplit(uint256 _new_affiliateSplit)\\n    external\\n    onlyOwner\\n  {\\n    require(_new_affiliateSplit <= 100, \\\"Affiliate Split Value not allowed\\\");\\n    affiliateSplit = _new_affiliateSplit;\\n  }\\n\\n  function set_affiliate(address _affiliate, bool _status) external onlyOwner {\\n    affiliates[_affiliate] = _status;\\n  }\\n\\n  ///@notice Withdraw goodwill share, retaining affilliate share\\n  function withdrawTokens(address[] calldata tokens) external onlyOwner {\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      uint256 qty;\\n\\n      if (tokens[i] == ETHAddress) {\\n        qty = address(this).balance.sub(totalAffiliateBalance[tokens[i]]);\\n        Address.sendValue(payable(owner()), qty);\\n      } else {\\n        qty = IERC20(tokens[i]).balanceOf(address(this)).sub(\\n          totalAffiliateBalance[tokens[i]]\\n        );\\n        IERC20(tokens[i]).safeTransfer(owner(), qty);\\n      }\\n    }\\n  }\\n\\n  ///@notice Withdraw affilliate share, retaining goodwill share\\n  function affilliateWithdraw(address[] calldata tokens) external {\\n    uint256 tokenBal;\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      tokenBal = affiliateBalance[msg.sender][tokens[i]];\\n      affiliateBalance[msg.sender][tokens[i]] = 0;\\n      totalAffiliateBalance[tokens[i]] = totalAffiliateBalance[tokens[i]].sub(\\n        tokenBal\\n      );\\n\\n      if (tokens[i] == ETHAddress) {\\n        Address.sendValue(msg.sender, tokenBal);\\n      } else {\\n        IERC20(tokens[i]).safeTransfer(msg.sender, tokenBal);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external-lib/zapper/ZapInBaseV2.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n// SPDX-License-Identifier: GPLv2\\n\\n// Changes:\\n// - Conversion to 0.7.6\\n//   - abstract type\\n//   - library imports throughout\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./ZapBaseV1.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nabstract contract ZapInBaseV2 is ZapBaseV1 {\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  function _pullTokens(\\n    address token,\\n    uint256 amount,\\n    address affiliate,\\n    bool enableGoodwill,\\n    bool shouldSellEntireBalance\\n  ) internal returns (uint256 value) {\\n    uint256 totalGoodwillPortion;\\n\\n    if (token == address(0)) {\\n      require(msg.value > 0, \\\"No eth sent\\\");\\n\\n      // subtract goodwill\\n      totalGoodwillPortion = _subtractGoodwill(\\n        ETHAddress,\\n        msg.value,\\n        affiliate,\\n        enableGoodwill\\n      );\\n\\n      return msg.value.sub(totalGoodwillPortion);\\n    }\\n    require(amount > 0, \\\"Invalid token amount\\\");\\n    require(msg.value == 0, \\\"Eth sent with token\\\");\\n\\n    //transfer token\\n    if (shouldSellEntireBalance) {\\n      require(\\n        Address.isContract(msg.sender),\\n        \\\"ERR: shouldSellEntireBalance is true for EOA\\\"\\n      );\\n      amount = IERC20(token).allowance(msg.sender, address(this));\\n    }\\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n    // subtract goodwill\\n    totalGoodwillPortion = _subtractGoodwill(\\n      token,\\n      amount,\\n      affiliate,\\n      enableGoodwill\\n    );\\n\\n    return amount.sub(totalGoodwillPortion);\\n  }\\n\\n  function _subtractGoodwill(\\n    address token,\\n    uint256 amount,\\n    address affiliate,\\n    bool enableGoodwill\\n  ) internal returns (uint256 totalGoodwillPortion) {\\n    bool whitelisted = feeWhitelist[msg.sender];\\n    if (enableGoodwill && !whitelisted && goodwill > 0) {\\n      totalGoodwillPortion = SafeMath.div(\\n        SafeMath.mul(amount, goodwill),\\n        10000\\n      );\\n\\n      if (affiliates[affiliate]) {\\n        if (token == address(0)) {\\n          token = ETHAddress;\\n        }\\n\\n        uint256 affiliatePortion =\\n          totalGoodwillPortion.mul(affiliateSplit).div(100);\\n        affiliateBalance[affiliate][token] = affiliateBalance[affiliate][token]\\n          .add(affiliatePortion);\\n        totalAffiliateBalance[token] = totalAffiliateBalance[token].add(\\n          affiliatePortion\\n        );\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/auxiliary/FloatMintingCeremony_ZapIn.sol\": {\r\n      \"content\": \"// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\\n// Copyright (C) 2021 zapper\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 2 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n\\n///@author Zapper\\n// SPDX-License-Identifier: GPLv2\\n\\n// Changes:\\n// - Uses msg.sender / removes the transfer from the zap contract.\\n// - Uses IMintingCeremony over IVault\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../funds/interfaces/IMintingCeremony.sol\\\";\\nimport \\\"../external-lib/zapper/ZapInBaseV2.sol\\\";\\n\\ncontract FloatMintingCeremonyZapInV1 is ZapInBaseV2 {\\n  using SafeMath for uint256;\\n\\n  // calldata only accepted for approved zap contracts\\n  mapping(address => bool) public approvedTargets;\\n\\n  event zapIn(address sender, address pool, uint256 tokensRec);\\n\\n  constructor(uint256 _goodwill, uint256 _affiliateSplit)\\n    ZapBaseV1(_goodwill, _affiliateSplit)\\n  {}\\n\\n  /**\\n    @notice This function commits to the Float Minting Ceremony with ETH or ERC20 tokens\\n    @param fromToken The token used for entry (address(0) if ether)\\n    @param amountIn The amount of fromToken to invest\\n    @param ceremony Float Protocol: Minting Ceremony address\\n    @param minFloatTokens The minimum acceptable quantity Float tokens to receive. Reverts otherwise\\n    @param intermediateToken Token to swap fromToken to before entering ceremony\\n    @param swapTarget Excecution target for the swap or zap\\n    @param swapData DEX or Zap data\\n    @param affiliate Affiliate address\\n    @return tokensReceived - Quantity of FLOAT that will be received\\n     */\\n  function ZapIn(\\n    address fromToken,\\n    uint256 amountIn,\\n    address ceremony,\\n    uint256 minFloatTokens,\\n    address intermediateToken,\\n    address swapTarget,\\n    bytes calldata swapData,\\n    address affiliate,\\n    bool shouldSellEntireBalance\\n  ) external payable stopInEmergency returns (uint256 tokensReceived) {\\n    require(\\n      approvedTargets[swapTarget] || swapTarget == address(0),\\n      \\\"Target not Authorized\\\"\\n    );\\n\\n    // get incoming tokens\\n    uint256 toInvest =\\n      _pullTokens(\\n        fromToken,\\n        amountIn,\\n        affiliate,\\n        true,\\n        shouldSellEntireBalance\\n      );\\n\\n    // get intermediate token\\n    uint256 intermediateAmt =\\n      _fillQuote(fromToken, intermediateToken, toInvest, swapTarget, swapData);\\n\\n    // Deposit to Minting Ceremony\\n    tokensReceived = _ceremonyCommit(intermediateAmt, ceremony, minFloatTokens);\\n  }\\n\\n  function _ceremonyCommit(\\n    uint256 amount,\\n    address toCeremony,\\n    uint256 minTokensRec\\n  ) internal returns (uint256 tokensReceived) {\\n    address underlyingVaultToken = IMintingCeremony(toCeremony).underlying();\\n\\n    _approveToken(underlyingVaultToken, toCeremony);\\n\\n    uint256 initialBal = IERC20(toCeremony).balanceOf(msg.sender);\\n    IMintingCeremony(toCeremony).commit(msg.sender, amount, minTokensRec);\\n    tokensReceived = IERC20(toCeremony).balanceOf(msg.sender).sub(initialBal);\\n    require(tokensReceived >= minTokensRec, \\\"Err: High Slippage\\\");\\n\\n    // Note that tokens are gifted directly, so we don't transfer from vault.\\n    // IERC20(toCeremony).safeTransfer(msg.sender, tokensReceived);\\n    emit zapIn(msg.sender, toCeremony, tokensReceived);\\n  }\\n\\n  function _fillQuote(\\n    address _fromTokenAddress,\\n    address toToken,\\n    uint256 _amount,\\n    address _swapTarget,\\n    bytes memory swapCallData\\n  ) internal returns (uint256 amtBought) {\\n    uint256 valueToSend;\\n\\n    if (_fromTokenAddress == toToken) {\\n      return _amount;\\n    }\\n\\n    if (_fromTokenAddress == address(0)) {\\n      valueToSend = _amount;\\n    } else {\\n      _approveToken(_fromTokenAddress, _swapTarget);\\n    }\\n\\n    uint256 iniBal = _getBalance(toToken);\\n    (bool success, ) = _swapTarget.call{value: valueToSend}(swapCallData);\\n    require(success, \\\"Error Swapping Tokens 1\\\");\\n    uint256 finalBal = _getBalance(toToken);\\n\\n    amtBought = finalBal.sub(iniBal);\\n  }\\n\\n  function setApprovedTargets(\\n    address[] calldata targets,\\n    bool[] calldata isApproved\\n  ) external onlyOwner {\\n    require(targets.length == isApproved.length, \\\"Invalid Input length\\\");\\n\\n    for (uint256 i = 0; i < targets.length; i++) {\\n      approvedTargets[targets[i]] = isApproved[i];\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/Twap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.7.6;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@uniswap/lib/contracts/libraries/FixedPoint.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../external-lib/UniswapV2Library.sol\\\";\\nimport \\\"../external-lib/UniswapV2OracleLibrary.sol\\\";\\nimport \\\"../lib/SushiswapLibrary.sol\\\";\\n\\nimport \\\"./interfaces/ITwap.sol\\\";\\n\\n// As these are \\\"Time\\\"-Weighted Average Price contracts, they necessarily rely on time.\\n// solhint-disable not-rely-on-time\\n\\n/**\\n * @title A sliding window for AMMs (specifically Sushiswap)\\n * @notice Uses observations collected over a window to provide moving price averages in the past\\n * @dev This is a singleton TWAP that only needs to be deployed once per desired parameters. `windowSize` has a precision of `windowSize / granularity`\\n * Errors:\\n * MissingPastObsr   - We do not have suffient past observations.\\n * UnexpectedElapsed - We have an unexpected time elapsed.\\n * EarlyUpdate       - Tried to update the TWAP before the period has elapsed.\\n * InvalidToken      - Cannot consult an invalid token pair.\\n */\\ncontract Twap is ITwap {\\n  using FixedPoint for *;\\n  using SafeMath for uint256;\\n\\n  struct Observation {\\n    uint256 timestamp;\\n    uint256 price0Cumulative;\\n    uint256 price1Cumulative;\\n  }\\n\\n  /* ========== IMMUTABLE VARIABLES ========== */\\n\\n  /// @notice the Uniswap Factory contract for tracking exchanges\\n  address public immutable factory;\\n\\n  /// @notice The desired amount of time over which the moving average should be computed, e.g. 24 hours\\n  uint256 public immutable windowSize;\\n\\n  /// @notice The number of observations stored for each pair, i.e. how many price observations are stored for the window\\n  /// @dev As granularity increases from, more frequent updates are needed; but precision increases [`windowSize - (windowSize / granularity) * 2`, `windowSize`]\\n  uint8 public immutable granularity;\\n\\n  /// @dev Redundant with `granularity` and `windowSize`, but has gas savings & easy read\\n  uint256 public immutable periodSize;\\n\\n  /* ========== STATE VARIABLES ========== */\\n\\n  /// @notice Mapping from pair address to a list of price observations of that pair\\n  mapping(address => Observation[]) public pairObservations;\\n\\n  /* ========== EVENTS ========== */\\n\\n  event NewObservation(\\n    uint256 timestamp,\\n    uint256 price0Cumulative,\\n    uint256 price1Cumulative\\n  );\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  /**\\n   * @notice Construct a new Sliding Window TWAP\\n   * @param factory_ The AMM factory\\n   * @param windowSize_ The window size for this TWAP\\n   * @param granularity_ The granularity required for the TWAP\\n   */\\n  constructor(\\n    address factory_,\\n    uint256 windowSize_,\\n    uint8 granularity_\\n  ) {\\n    require(factory_ != address(0), \\\"Twap/InvalidFactory\\\");\\n    require(granularity_ > 1, \\\"Twap/Granularity\\\");\\n    require(\\n      (periodSize = windowSize_ / granularity_) * granularity_ == windowSize_,\\n      \\\"Twap/WindowSize\\\"\\n    );\\n    factory = factory_;\\n    windowSize = windowSize_;\\n    granularity = granularity_;\\n  }\\n\\n  /* ========== PURE ========== */\\n\\n  /**\\n   * @notice Given the cumulative prices of the start and end of a period, and the length of the period, compute the average price in terms of the amount in\\n   * @param priceCumulativeStart the cumulative price for the start of the period\\n   * @param priceCumulativeEnd the cumulative price for the end of the period\\n   * @param timeElapsed the time from now to the first observation\\n   * @param amountIn the amount of tokens in\\n   * @return amountOut amount out received for the amount in\\n   */\\n  function _computeAmountOut(\\n    uint256 priceCumulativeStart,\\n    uint256 priceCumulativeEnd,\\n    uint256 timeElapsed,\\n    uint256 amountIn\\n  ) private pure returns (uint256 amountOut) {\\n    // overflow is desired.\\n    FixedPoint.uq112x112 memory priceAverage =\\n      FixedPoint.uq112x112(\\n        uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\\n      );\\n    amountOut = priceAverage.mul(amountIn).decode144();\\n  }\\n\\n  /* ========== VIEWS ========== */\\n\\n  /**\\n   * @notice Calculates the index of the observation for the given `timestamp`\\n   * @param timestamp the observation for the timestamp\\n   * @return index The index of the observation\\n   */\\n  function observationIndexOf(uint256 timestamp)\\n    public\\n    view\\n    returns (uint8 index)\\n  {\\n    uint256 epochPeriod = timestamp / periodSize;\\n    return uint8(epochPeriod % granularity);\\n  }\\n\\n  /// @inheritdoc ITwap\\n  function updateable(address tokenA, address tokenB)\\n    external\\n    view\\n    override(ITwap)\\n    returns (bool)\\n  {\\n    address pair = SushiswapLibrary.pairFor(factory, tokenA, tokenB);\\n\\n    uint8 observationIndex = observationIndexOf(block.timestamp);\\n    Observation storage observation = pairObservations[pair][observationIndex];\\n\\n    // We only want to commit updates once per period (i.e. windowSize / granularity).\\n    uint256 timeElapsed = block.timestamp - observation.timestamp;\\n\\n    return timeElapsed > periodSize;\\n  }\\n\\n  /// @inheritdoc ITwap\\n  function consult(\\n    address tokenIn,\\n    uint256 amountIn,\\n    address tokenOut\\n  ) external view override(ITwap) returns (uint256 amountOut) {\\n    address pair = SushiswapLibrary.pairFor(factory, tokenIn, tokenOut);\\n    Observation storage firstObservation = _getFirstObservationInWindow(pair);\\n\\n    uint256 timeElapsed = block.timestamp - firstObservation.timestamp;\\n    require(timeElapsed <= windowSize, \\\"Twap/MissingPastObsr\\\");\\n    require(\\n      timeElapsed >= windowSize - periodSize * 2,\\n      \\\"Twap/UnexpectedElapsed\\\"\\n    );\\n\\n    (uint256 price0Cumulative, uint256 price1Cumulative, ) =\\n      UniswapV2OracleLibrary.currentCumulativePrices(pair);\\n    (address token0, address token1) =\\n      UniswapV2Library.sortTokens(tokenIn, tokenOut);\\n\\n    if (token0 == tokenIn) {\\n      return\\n        _computeAmountOut(\\n          firstObservation.price0Cumulative,\\n          price0Cumulative,\\n          timeElapsed,\\n          amountIn\\n        );\\n    }\\n\\n    require(token1 == tokenIn, \\\"Twap/InvalidToken\\\");\\n\\n    return\\n      _computeAmountOut(\\n        firstObservation.price1Cumulative,\\n        price1Cumulative,\\n        timeElapsed,\\n        amountIn\\n      );\\n  }\\n\\n  /**\\n   * @notice Observation from the oldest epoch (at the beginning of the window) relative to the current time\\n   * @param pair the Uniswap pair address\\n   * @return firstObservation The observation from the oldest epoch relative to current time.\\n   */\\n  function _getFirstObservationInWindow(address pair)\\n    private\\n    view\\n    returns (Observation storage firstObservation)\\n  {\\n    uint8 observationIndex = observationIndexOf(block.timestamp);\\n    // No overflow issues; if observationIndex + 1 overflows, result is still zero.\\n    uint8 firstObservationIndex = (observationIndex + 1) % granularity;\\n    firstObservation = pairObservations[pair][firstObservationIndex];\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n  /// @inheritdoc ITwap\\n  function update(address tokenA, address tokenB)\\n    external\\n    override(ITwap)\\n    returns (bool)\\n  {\\n    address pair = SushiswapLibrary.pairFor(factory, tokenA, tokenB);\\n\\n    // Populate the array with empty observations for the first call.\\n    for (uint256 i = pairObservations[pair].length; i < granularity; i++) {\\n      pairObservations[pair].push();\\n    }\\n\\n    // Get the observation for the current period.\\n    uint8 observationIndex = observationIndexOf(block.timestamp);\\n    Observation storage observation = pairObservations[pair][observationIndex];\\n\\n    // We only want to commit updates once per period (i.e. windowSize / granularity).\\n    uint256 timeElapsed = block.timestamp - observation.timestamp;\\n\\n    if (timeElapsed <= periodSize) {\\n      // Skip update as we're in the same observation slot.\\n      return false;\\n    }\\n\\n    (uint256 price0Cumulative, uint256 price1Cumulative, ) =\\n      UniswapV2OracleLibrary.currentCumulativePrices(pair);\\n    observation.timestamp = block.timestamp;\\n    observation.price0Cumulative = price0Cumulative;\\n    observation.price1Cumulative = price1Cumulative;\\n\\n    emit NewObservation(\\n      observation.timestamp,\\n      observation.price0Cumulative,\\n      observation.price1Cumulative\\n    );\\n\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.0;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external-lib/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary UniswapV2Library {\\n  using SafeMath for uint256;\\n\\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n  function sortTokens(address tokenA, address tokenB)\\n    internal\\n    pure\\n    returns (address token0, address token1)\\n  {\\n    require(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n    require(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\n  }\\n\\n  // calculates the CREATE2 address for a pair without making any external calls\\n  function pairFor(\\n    address factory,\\n    address tokenA,\\n    address tokenB\\n  ) internal pure returns (address pair) {\\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\\n    pair = address(\\n      uint256(\\n        keccak256(\\n          abi.encodePacked(\\n            hex\\\"ff\\\",\\n            factory,\\n            keccak256(abi.encodePacked(token0, token1)),\\n            hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\" // init code hash\\n          )\\n        )\\n      )\\n    );\\n  }\\n\\n  // fetches and sorts the reserves for a pair\\n  function getReserves(\\n    address factory,\\n    address tokenA,\\n    address tokenB\\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n    (address token0, ) = sortTokens(tokenA, tokenB);\\n    (uint256 reserve0, uint256 reserve1, ) =\\n      IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n    (reserveA, reserveB) = tokenA == token0\\n      ? (reserve0, reserve1)\\n      : (reserve1, reserve0);\\n  }\\n\\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n  function quote(\\n    uint256 amountA,\\n    uint256 reserveA,\\n    uint256 reserveB\\n  ) internal pure returns (uint256 amountB) {\\n    require(amountA > 0, \\\"UniswapV2Library: INSUFFICIENT_AMOUNT\\\");\\n    require(\\n      reserveA > 0 && reserveB > 0,\\n      \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n    );\\n    amountB = amountA.mul(reserveB) / reserveA;\\n  }\\n\\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n  function getAmountOut(\\n    uint256 amountIn,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) internal pure returns (uint256 amountOut) {\\n    require(amountIn > 0, \\\"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\n    require(\\n      reserveIn > 0 && reserveOut > 0,\\n      \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n    );\\n    uint256 amountInWithFee = amountIn.mul(997);\\n    uint256 numerator = amountInWithFee.mul(reserveOut);\\n    uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\\n    amountOut = numerator / denominator;\\n  }\\n\\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n  function getAmountIn(\\n    uint256 amountOut,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) internal pure returns (uint256 amountIn) {\\n    require(amountOut > 0, \\\"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n    require(\\n      reserveIn > 0 && reserveOut > 0,\\n      \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n    );\\n    uint256 numerator = reserveIn.mul(amountOut).mul(1000);\\n    uint256 denominator = reserveOut.sub(amountOut).mul(997);\\n    amountIn = (numerator / denominator).add(1);\\n  }\\n\\n  // performs chained getAmountOut calculations on any number of pairs\\n  function getAmountsOut(\\n    address factory,\\n    uint256 amountIn,\\n    address[] memory path\\n  ) internal view returns (uint256[] memory amounts) {\\n    require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n    amounts = new uint256[](path.length);\\n    amounts[0] = amountIn;\\n    for (uint256 i; i < path.length - 1; i++) {\\n      (uint256 reserveIn, uint256 reserveOut) =\\n        getReserves(factory, path[i], path[i + 1]);\\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n    }\\n  }\\n\\n  // performs chained getAmountIn calculations on any number of pairs\\n  function getAmountsIn(\\n    address factory,\\n    uint256 amountOut,\\n    address[] memory path\\n  ) internal view returns (uint256[] memory amounts) {\\n    require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n    amounts = new uint256[](path.length);\\n    amounts[amounts.length - 1] = amountOut;\\n    for (uint256 i = path.length - 1; i > 0; i--) {\\n      (uint256 reserveIn, uint256 reserveOut) =\\n        getReserves(factory, path[i - 1], path[i]);\\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external-lib/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@uniswap/lib/contracts/libraries/FixedPoint.sol\\\";\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n  using FixedPoint for *;\\n\\n  // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n  function currentBlockTimestamp() internal view returns (uint32) {\\n    return uint32(block.timestamp % 2**32);\\n  }\\n\\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n  function currentCumulativePrices(address pair)\\n    internal\\n    view\\n    returns (\\n      uint256 price0Cumulative,\\n      uint256 price1Cumulative,\\n      uint32 blockTimestamp\\n    )\\n  {\\n    blockTimestamp = currentBlockTimestamp();\\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\\n    (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) =\\n      IUniswapV2Pair(pair).getReserves();\\n    if (blockTimestampLast != blockTimestamp) {\\n      // subtraction overflow is desired\\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n      // addition overflow is desired\\n      // counterfactual\\n      price0Cumulative +=\\n        uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\\n        timeElapsed;\\n      // counterfactual\\n      price1Cumulative +=\\n        uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\\n        timeElapsed;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SushiswapLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../external-lib/UniswapV2Library.sol\\\";\\n\\nlibrary SushiswapLibrary {\\n  // calculates the CREATE2 address for a pair without making any external calls\\n  function pairFor(\\n    address factory,\\n    address tokenA,\\n    address tokenB\\n  ) internal pure returns (address pair) {\\n    (address token0, address token1) =\\n      UniswapV2Library.sortTokens(tokenA, tokenB);\\n    pair = address(\\n      uint256(\\n        keccak256(\\n          abi.encodePacked(\\n            hex\\\"ff\\\",\\n            factory,\\n            keccak256(abi.encodePacked(token0, token1)),\\n            hex\\\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\\\" // init code hash\\n          )\\n        )\\n      )\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/policy/mock/MonetaryPolicyV1Harness.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../MonetaryPolicyV1.sol\\\";\\n\\ncontract MonetaryPolicyV1Harness is MonetaryPolicyV1 {\\n  uint256 public blockNumber;\\n\\n  constructor(address _governance, address _ethUsdOracle)\\n    MonetaryPolicyV1(_governance, _ethUsdOracle)\\n  {}\\n\\n  function _blockNumber() internal view override returns (uint256) {\\n    return blockNumber;\\n  }\\n\\n  function __setBlock(uint256 _number) external {\\n    blockNumber = _number;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"windowSize_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"granularity_\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price0Cumulative\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price1Cumulative\",\"type\":\"uint256\"}],\"name\":\"NewObservation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"consult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"observationIndexOf\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1Cumulative\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"updateable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"windowSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Twap","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac00000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000004","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}