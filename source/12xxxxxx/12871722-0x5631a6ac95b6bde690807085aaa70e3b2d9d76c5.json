{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/pedro/git/rsk/public/tokenbridge/bridge/contracts/Federation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\n// Upgradables\\nimport \\\"./zeppelin/upgradable/Initializable.sol\\\";\\nimport \\\"./zeppelin/upgradable/ownership/UpgradableOwnable.sol\\\";\\n\\nimport \\\"./IBridge.sol\\\";\\n\\ncontract Federation is Initializable, UpgradableOwnable {\\n    uint constant public MAX_MEMBER_COUNT = 50;\\n    address constant private NULL_ADDRESS = address(0);\\n\\n    IBridge public bridge;\\n    address[] public members;\\n    uint public required;\\n\\n    mapping (address => bool) public isMember;\\n    mapping (bytes32 => mapping (address => bool)) public votes;\\n    mapping(bytes32 => bool) public processed;\\n\\n    event Executed(\\n        address indexed federator,\\n        bytes32 indexed transactionHash,\\n        bytes32 indexed transactionId,\\n        address originalTokenAddress,\\n        address sender,\\n        address receiver,\\n        uint256 amount,\\n        bytes32 blockHash,\\n        uint32 logIndex\\n    );\\n    event MemberAddition(address indexed member);\\n    event MemberRemoval(address indexed member);\\n    event RequirementChange(uint required);\\n    event BridgeChanged(address bridge);\\n    event Voted(\\n        address indexed federator,\\n        bytes32 indexed transactionHash,\\n        bytes32 indexed transactionId,\\n        address originalTokenAddress,\\n        address sender,\\n        address receiver,\\n        uint256 amount,\\n        bytes32 blockHash,\\n        uint32 logIndex\\n    );\\n    event HeartBeat(\\n        address indexed sender,\\n        uint256 fedRskBlock,\\n        uint256 fedEthBlock,\\n        string federatorVersion,\\n        string nodeRskInfo,\\n        string nodeEthInfo\\n    );\\n\\n    modifier onlyMember() {\\n        require(isMember[_msgSender()], \\\"Federation: Not Federator\\\");\\n        _;\\n    }\\n\\n    modifier validRequirement(uint membersCount, uint _required) {\\n        // solium-disable-next-line max-len\\n        require(_required <= membersCount && _required != 0 && membersCount != 0, \\\"Federation: Invalid requirements\\\");\\n        _;\\n    }\\n\\n    function initialize(address[] memory _members, uint _required, address _bridge, address owner)\\n    validRequirement(_members.length, _required) public initializer {\\n        UpgradableOwnable.initialize(owner);\\n        require(_members.length <= MAX_MEMBER_COUNT, \\\"Federation: Too many members\\\");\\n        members = _members;\\n        for (uint i = 0; i < _members.length; i++) {\\n            require(!isMember[_members[i]] && _members[i] != NULL_ADDRESS, \\\"Federation: Invalid members\\\");\\n            isMember[_members[i]] = true;\\n            emit MemberAddition(_members[i]);\\n        }\\n        required = _required;\\n        emit RequirementChange(required);\\n        _setBridge(_bridge);\\n    }\\n\\n    function version() external pure returns (string memory) {\\n        return \\\"v2\\\";\\n    }\\n\\n    function setBridge(address _bridge) external onlyOwner {\\n        _setBridge(_bridge);\\n    }\\n\\n    function _setBridge(address _bridge) internal {\\n        require(_bridge != NULL_ADDRESS, \\\"Federation: Empty bridge\\\");\\n        bridge = IBridge(_bridge);\\n        emit BridgeChanged(_bridge);\\n    }\\n\\n    function voteTransaction(\\n        address originalTokenAddress,\\n        address payable sender,\\n        address payable receiver,\\n        uint256 amount,\\n        bytes32 blockHash,\\n        bytes32 transactionHash,\\n        uint32 logIndex\\n    )\\n    public onlyMember returns(bool)\\n    {\\n        bytes32 transactionId = getTransactionId(\\n            originalTokenAddress,\\n            sender,\\n            receiver,\\n            amount,\\n            blockHash,\\n            transactionHash,\\n            logIndex\\n        );\\n        if (processed[transactionId])\\n            return true;\\n\\n        if (votes[transactionId][_msgSender()])\\n            return true;\\n\\n        votes[transactionId][_msgSender()] = true;\\n        emit Voted(\\n            _msgSender(),\\n            transactionHash,\\n            transactionId,\\n            originalTokenAddress,\\n            sender,\\n            receiver,\\n            amount,\\n            blockHash,\\n            logIndex\\n        );\\n\\n        uint transactionCount = getTransactionCount(transactionId);\\n        if (transactionCount >= required && transactionCount >= members.length / 2 + 1) {\\n            processed[transactionId] = true;\\n            bridge.acceptTransfer(\\n                originalTokenAddress,\\n                sender,\\n                receiver,\\n                amount,\\n                blockHash,\\n                transactionHash,\\n                logIndex\\n            );\\n            emit Executed(\\n                _msgSender(),\\n                transactionHash,\\n                transactionId,\\n                originalTokenAddress,\\n                sender,\\n                receiver,\\n                amount,\\n                blockHash,\\n                logIndex\\n            );\\n            return true;\\n        }\\n\\n        return true;\\n    }\\n\\n    function getTransactionCount(bytes32 transactionId) public view returns(uint) {\\n        uint count = 0;\\n        for (uint i = 0; i < members.length; i++) {\\n            if (votes[transactionId][members[i]])\\n                count += 1;\\n        }\\n        return count;\\n    }\\n\\n    function hasVoted(bytes32 transactionId) external view returns(bool)\\n    {\\n        return votes[transactionId][_msgSender()];\\n    }\\n\\n    function transactionWasProcessed(bytes32 transactionId) external view returns(bool)\\n    {\\n        return processed[transactionId];\\n    }\\n\\n    function getTransactionId(\\n        address originalTokenAddress,\\n        address sender,\\n        address receiver,\\n        uint256 amount,\\n        bytes32 blockHash,\\n        bytes32 transactionHash,\\n        uint32 logIndex\\n    ) public pure returns(bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n            originalTokenAddress,\\n            sender,\\n            receiver,\\n            amount,\\n            blockHash,\\n            transactionHash,\\n            logIndex\\n            )\\n        );\\n    }\\n\\n    function addMember(address _newMember) external onlyOwner\\n    {\\n        require(_newMember != NULL_ADDRESS, \\\"Federation: Empty member\\\");\\n        require(!isMember[_newMember], \\\"Federation: Member already exists\\\");\\n        require(members.length < MAX_MEMBER_COUNT, \\\"Federation: Max members reached\\\");\\n\\n        isMember[_newMember] = true;\\n        members.push(_newMember);\\n        emit MemberAddition(_newMember);\\n    }\\n\\n    function removeMember(address _oldMember) external onlyOwner\\n    {\\n        require(_oldMember != NULL_ADDRESS, \\\"Federation: Empty member\\\");\\n        require(isMember[_oldMember], \\\"Federation: Member doesn't exists\\\");\\n        require(members.length > 1, \\\"Federation: Can't remove all the members\\\");\\n        require(members.length - 1 >= required, \\\"Federation: Can't have less than required members\\\");\\n\\n        isMember[_oldMember] = false;\\n        for (uint i = 0; i < members.length - 1; i++) {\\n            if (members[i] == _oldMember) {\\n                members[i] = members[members.length - 1];\\n                break;\\n            }\\n        }\\n        members.pop(); // remove an element from the end of the array.\\n        emit MemberRemoval(_oldMember);\\n    }\\n\\n    function getMembers() external view returns (address[] memory)\\n    {\\n        return members;\\n    }\\n\\n    function changeRequirement(uint _required) external onlyOwner validRequirement(members.length, _required)\\n    {\\n        require(_required >= 2, \\\"Federation: Requires at least 2\\\");\\n        required = _required;\\n        emit RequirementChange(_required);\\n    }\\n\\n    function emitHeartbeat(\\n        uint256 fedRskBlock,\\n        uint256 fedEthBlock,\\n        string calldata federatorVersion,\\n        string calldata nodeRskInfo,\\n        string calldata nodeEthInfo\\n    ) external onlyMember {\\n        emit HeartBeat(\\n            _msgSender(),\\n            fedRskBlock,\\n            fedEthBlock,\\n            federatorVersion,\\n            nodeRskInfo,\\n            nodeEthInfo\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/pedro/git/rsk/public/tokenbridge/bridge/contracts/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\ninterface IBridge {\\n\\n    struct ClaimData {\\n        address payable to;\\n        uint256 amount;\\n        bytes32 blockHash;\\n        bytes32 transactionHash;\\n        uint32 logIndex;\\n    }\\n\\n    function version() external pure returns (string memory);\\n\\n    function getFeePercentage() external view returns(uint);\\n\\n    /**\\n     * ERC-20 tokens approve and transferFrom pattern\\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom\\n     */\\n    function receiveTokensTo(address tokenToUse, address to, uint256 amount) external;\\n\\n    /**\\n     * Use network currency and cross it.\\n     */\\n    function depositTo(address to) external payable;\\n\\n    /**\\n     * ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details\\n     */\\n    function tokensReceived (\\n        address operator,\\n        address from,\\n        address to,\\n        uint amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * Accepts the transaction from the other chain that was voted and sent by the Federation contract\\n     */\\n    function acceptTransfer(\\n        address _originalTokenAddress,\\n        address payable _from,\\n        address payable _to,\\n        uint256 _amount,\\n        bytes32 _blockHash,\\n        bytes32 _transactionHash,\\n        uint32 _logIndex\\n    ) external;\\n\\n    /**\\n     * Claims the crossed transaction using the hash, this sends the funds to the address indicated in\\n     */\\n    function claim(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\\n\\n    function claimFallback(ClaimData calldata _claimData) external returns (uint256 receivedAmount);\\n\\n    function claimGasless(\\n        ClaimData calldata _claimData,\\n        address payable _relayer,\\n        uint256 _fee,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external returns (uint256 receivedAmount);\\n\\n    function getTransactionDataHash(\\n        address _to,\\n        uint256 _amount,\\n        bytes32 _blockHash,\\n        bytes32 _transactionHash,\\n        uint32 _logIndex\\n    ) external returns(bytes32);\\n\\n    event Cross(\\n        address indexed _tokenAddress,\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 _amount,\\n        bytes _userData\\n    );\\n    event NewSideToken(\\n        address indexed _newSideTokenAddress,\\n        address indexed _originalTokenAddress,\\n        string _newSymbol,\\n        uint256 _granularity\\n    );\\n    event AcceptedCrossTransfer(\\n        bytes32 indexed _transactionHash,\\n        address indexed _originalTokenAddress,\\n        address indexed _to,\\n        address  _from,\\n        uint256 _amount,\\n        bytes32 _blockHash,\\n        uint256 _logIndex\\n    );\\n    event FeePercentageChanged(uint256 _amount);\\n    event Claimed(\\n        bytes32 indexed _transactionHash,\\n        address indexed _originalTokenAddress,\\n        address indexed _to,\\n        address _sender,\\n        uint256 _amount,\\n        bytes32 _blockHash,\\n        uint256 _logIndex,\\n        address _reciever,\\n        address _relayer,\\n        uint256 _fee\\n    );\\n}\"\r\n    },\r\n    \"/Users/pedro/git/rsk/public/tokenbridge/bridge/contracts/zeppelin/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract  Context {\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/pedro/git/rsk/public/tokenbridge/bridge/contracts/zeppelin/upgradable/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || !initialized, \\\"Contract instance is already initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\"\r\n    },\r\n    \"/Users/pedro/git/rsk/public/tokenbridge/bridge/contracts/zeppelin/upgradable/ownership/UpgradableOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../Initializable.sol\\\";\\n\\nimport \\\"../../GSN/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract UpgradableOwnable is Initializable, Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function initialize(address sender) public initializer {\\n        _owner = sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * > Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"}],\"name\":\"BridgeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"federator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originalTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"logIndex\",\"type\":\"uint32\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fedRskBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fedEthBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"federatorVersion\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"nodeRskInfo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"nodeEthInfo\",\"type\":\"string\"}],\"name\":\"HeartBeat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"RequirementChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"federator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originalTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"logIndex\",\"type\":\"uint32\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_MEMBER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMember\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fedRskBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fedEthBlock\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"federatorVersion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"nodeRskInfo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"nodeEthInfo\",\"type\":\"string\"}],\"name\":\"emitHeartbeat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"getTransactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"originalTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"logIndex\",\"type\":\"uint32\"}],\"name\":\"getTransactionId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"hasVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_members\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_required\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldMember\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"setBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"transactionWasProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"originalTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"logIndex\",\"type\":\"uint32\"}],\"name\":\"voteTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Federation","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}