{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n *      See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr), \"Illegal user rights\");\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\nlibrary RBAC\r\n{\r\n    using Roles for Roles.Role;\r\n\r\n    struct RolesManager\r\n    {\r\n        mapping (string => Roles.Role)  userRoles;\r\n        address owner;\r\n        bool isInit;\r\n    }\r\n\r\n    event RoleAdded(address addr, string roleName);\r\n    event RoleRemoved(address addr, string roleName);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function initialize(RolesManager storage rolesManager, address _owner) internal\r\n    {\r\n        rolesManager.owner = _owner;\r\n        rolesManager.userRoles[\"admin\"].add(msg.sender);\r\n        rolesManager.userRoles[\"mint\"].add(msg.sender);\r\n        addRole(rolesManager, _owner, \"admin\");\r\n        addRole(rolesManager, _owner, \"mint\");\r\n        addRole(rolesManager, _owner, \"burn\");\r\n        addRole(rolesManager, _owner, \"frozen\");\r\n        addRole(rolesManager, _owner, \"pause\");\r\n    }\r\n\r\n    modifier onlyAdmin(RolesManager storage rolesManager)\r\n    {\r\n        require(isAdmin(rolesManager), \"Adminable: caller is not the admin\");\r\n        _;\r\n    }\r\n\r\n    function isOwner(RolesManager storage rolesManager) internal view returns(bool)\r\n    {\r\n        return (msg.sender == rolesManager.owner);\r\n    }\r\n\r\n    function isAdmin(RolesManager storage rolesManager) internal view returns(bool)\r\n    {\r\n        return hasRole(rolesManager, msg.sender, \"admin\") || msg.sender == rolesManager.owner;\r\n    }\r\n\r\n    /**\r\n    * @dev reverts if addr does not have role\r\n    * @param addr address\r\n    * @param roleName the name of the role\r\n    * // reverts\r\n    */\r\n    function checkRole(RolesManager storage rolesManager, address addr, string memory roleName) internal view\r\n    {\r\n        rolesManager.userRoles[roleName].check(addr);\r\n    }\r\n\r\n    /**\r\n    * @dev determine if addr has role\r\n    * @param addr address\r\n    * @param roleName the name of the role\r\n    * @return bool\r\n    */\r\n    function hasRole(RolesManager storage rolesManager, address addr, string memory roleName) internal view returns (bool)\r\n    {\r\n        return rolesManager.userRoles[roleName].has(addr);\r\n    }\r\n\r\n    /**\r\n    * @dev add a role to an address\r\n    * @param addr address\r\n    * @param roleName the name of the role\r\n    */\r\n    function addRole(RolesManager storage rolesManager, address addr, string memory roleName) internal onlyAdmin(rolesManager)\r\n    {\r\n        rolesManager.userRoles[roleName].add(addr);\r\n        emit RoleAdded(addr, roleName);\r\n    }\r\n\r\n    /**\r\n    * @dev remove a role from an address\r\n    * @param addr address\r\n    * @param roleName the name of the role\r\n    */\r\n    function removeRole(RolesManager storage rolesManager, address addr, string memory roleName) internal onlyAdmin(rolesManager)\r\n    {\r\n        rolesManager.userRoles[roleName].remove(addr);\r\n        emit RoleRemoved(addr, roleName);\r\n    }\r\n\r\n    function setOwner(RolesManager storage rolesManager, address newOwner) private onlyAdmin(rolesManager) {\r\n        address oldOwner = rolesManager.owner;\r\n        rolesManager.owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /** set owner null\r\n     */\r\n    function renounceOwnership(RolesManager storage rolesManager)  internal\r\n    {\r\n        setOwner(rolesManager, address(0));\r\n    }\r\n\r\n    /* transfer owner */\r\n    function transferOwnership(RolesManager storage rolesManager, address newOwner) internal\r\n    {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        setOwner(rolesManager, newOwner);\r\n    }\r\n}\r\n\r\n\r\nlibrary BasicTokenLib {\r\n    using RBAC for RBAC.RolesManager;\r\n\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished(address account);\r\n    event MintResumed(address account);\r\n    event Burn(address indexed _who, uint256 _value);\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n    event FrozenAccount(address indexed addr);\r\n    event UnrozenAccount(address indexed addr);\r\n    event DepositEth(address indexed _buyer, uint256 _ethWei, uint256 _tokens);\r\n    event WithdrawEth(address indexed _buyer, uint256 _ethWei);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event DappTransfer(address indexed from, address indexed _to, uint256 gamerChips, uint256 dappChips);\r\n\r\n    struct Xrc20Token {\r\n        string _name;\r\n        string _symbol;\r\n        uint8 _decimals;\r\n        string tokenURI;\r\n        string iconURI;\r\n\r\n        mapping(address => uint256) balances;\r\n        mapping(address => mapping(address => uint256)) _allowances;\r\n        mapping(address=>bool) frozenAccounts;\r\n\r\n        uint256 _totalSupply;\r\n        bool paused;\r\n        bool mintFinished; \r\n        RBAC.RolesManager rolesManager;\r\n    } \r\n\r\n    function initialize(\r\n        Xrc20Token storage token,\r\n        address _owner,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        uint256 _initialBalance,\r\n        string memory _tokenURI,\r\n        string memory _iconURI\r\n    ) internal\r\n    {\r\n        require(_owner != address(0), \"the owner cannot be null\");\r\n\r\n        token.rolesManager.initialize(_owner);\r\n        token.paused = false;\r\n        token._name = _name;\r\n        token._symbol = _symbol;\r\n        token._decimals = _decimals;\r\n        token._totalSupply = 0;\r\n        token.tokenURI = _tokenURI;\r\n        token.iconURI = _iconURI;\r\n        token.mintFinished = false;\r\n\r\n        mint(token, _owner, _initialBalance);\r\n    }\r\n\r\n    function name(Xrc20Token storage token) internal view returns (string memory) {\r\n        return token._name;\r\n    }\r\n\r\n    function updateName(Xrc20Token storage token, string memory _name) internal onlyAdmin(token) returns(bool)\r\n    {\r\n        token._name = _name;\r\n        return true;\r\n    }\r\n\r\n    function updateSymbol(Xrc20Token storage token, string memory _symbol) internal onlyAdmin(token) returns(bool)\r\n    {\r\n        token._symbol = _symbol;\r\n        return true;\r\n    }\r\n\r\n    function symbol(Xrc20Token storage token) internal view returns (string memory) {\r\n        return token._symbol;\r\n    }\r\n\r\n     function decimals(Xrc20Token storage token) internal view returns (uint8) {\r\n        return token._decimals;\r\n    }\r\n\r\n    /* 查询总发行量 */\r\n    function totalSupply(Xrc20Token storage token) internal view returns (uint256)\r\n    {\r\n        return token._totalSupply;\r\n    }\r\n\r\n    /* 查询用户余额 */\r\n    function balanceOf(Xrc20Token storage token, address _owner) internal view returns (uint256) \r\n    {\r\n        return token.balances[_owner];\r\n    }\r\n\r\n    function tokenURI(Xrc20Token storage token) internal view returns (string memory)\r\n    {\r\n        return token.tokenURI;\r\n    }\r\n\r\n    function updateTokenURI(Xrc20Token storage token, string memory _tokenURI) internal onlyAdmin(token) returns(bool)\r\n    {\r\n        token.tokenURI = _tokenURI;\r\n        return true;\r\n    }\r\n\r\n    function iconURI(Xrc20Token storage token) internal view returns (string memory)\r\n    {\r\n        return token.iconURI;\r\n    }\r\n\r\n    function updateIconURI(Xrc20Token storage token, string memory _iconURI) internal onlyAdmin(token) returns(bool)\r\n    {\r\n        token.iconURI = _iconURI;\r\n        return true;\r\n    }\r\n\r\n    modifier onlyOwner(Xrc20Token storage token)  \r\n    {\r\n        require (token.rolesManager.isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyRole(Xrc20Token storage token, string memory roleName)  {\r\n        token.rolesManager.checkRole(msg.sender, roleName);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin(Xrc20Token storage token)\r\n    {\r\n        require(token.rolesManager.isAdmin(), \"Adminable: caller is not the admin\");\r\n        _;\r\n    }\r\n\r\n    modifier hasEnoughTokens(Xrc20Token storage token, address addr, uint256 amount)\r\n    {\r\n        require (token.balances[addr] >= amount, \"the sender hasn't enough tokens\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused(Xrc20Token storage token)\r\n    {\r\n        require(!token.paused, \"the token contract has been paused!\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused(Xrc20Token storage token)\r\n    {\r\n        require(token.paused, \"the token contract hasen't paused!\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUnfrozen(Xrc20Token storage token, address account)\r\n    {\r\n        require(!token.frozenAccounts[account], \"account has been frozened!\");\r\n        _;\r\n    }\r\n    \r\n    \r\n    modifier canMint(Xrc20Token storage token) {\r\n        require(!token.mintFinished, \"the minting already finished\");\r\n        _;\r\n    }\r\n\r\n    function addRole(Xrc20Token storage token, address addr, string memory roleName) internal\r\n    {\r\n        return token.rolesManager.addRole(addr, roleName);\r\n    }\r\n\r\n    function removeRole(Xrc20Token storage token, address addr, string memory roleName) internal\r\n    {\r\n        return token.rolesManager.removeRole(addr, roleName);\r\n    }\r\n\r\n    function renounceOwnership(Xrc20Token storage token)  internal\r\n    {\r\n        token.rolesManager.renounceOwnership();\r\n    }\r\n\r\n    function transferOwnership(Xrc20Token storage token, address newOwner) internal\r\n    {\r\n        return token.rolesManager.transferOwnership(newOwner);\r\n    }\r\n\r\n    function pause(Xrc20Token storage token)  internal onlyRole(token, \"pause\")\r\n    {\r\n        token.paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function unpause(Xrc20Token storage token)  internal onlyRole(token, \"pause\")\r\n    {\r\n        token.paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n\r\n    function mint(Xrc20Token storage token, address _to, uint256 _amount) internal onlyRole(token, \"mint\") canMint(token) returns (bool) \r\n    {\r\n        uint256 _mintAmount = _amount * (10  ** uint256(token._decimals));\r\n        token._totalSupply = token._totalSupply + _mintAmount;\r\n        token.balances[_to] = token.balances[_to] + _mintAmount;\r\n     \r\n        emit Mint(_to, _amount);\r\n  \r\n        return true;\r\n    }\r\n\r\n    function stopMint(Xrc20Token storage token) internal onlyRole(token, \"mint\") canMint(token) returns (bool) {\r\n        token.mintFinished = true;\r\n        emit MintFinished(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    function resumeMint(Xrc20Token storage token) internal onlyRole(token, \"mint\") canMint(token) returns (bool) {\r\n        token.mintFinished = false;\r\n        emit MintResumed(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    function burn(Xrc20Token storage token, address _who, uint256 _value) internal onlyRole(token, \"burn\") returns (bool) \r\n    {\r\n        if(_value > token.balances[_who])\r\n        {\r\n            _value = token.balances[_who];\r\n        }\r\n        token.balances[_who] = token.balances[_who] - _value;\r\n        token._totalSupply = token._totalSupply - _value;\r\n     \r\n        emit Burn(_who, _value);\r\n\r\n        return true;\r\n    }\r\n    \r\n    function frozenAccount(Xrc20Token storage token, address addr) internal onlyRole(token, \"frozen\") \r\n    {\r\n        require(addr != address(0), \"the frozen account cannot be null\");\r\n        token.frozenAccounts[addr] = true;\r\n        \r\n        emit FrozenAccount(addr);\r\n    }\r\n\r\n    function unfrozenAccount(Xrc20Token storage token, address addr) internal onlyRole(token, \"frozen\")\r\n    {\r\n        require(addr != address(0), \"the frozen account cannot be null\");\r\n        token.frozenAccounts[addr] = false;\r\n        \r\n        emit UnrozenAccount(addr);\r\n    }\r\n\r\n    function allowance(Xrc20Token storage token, address _owner, address _spender) internal view returns (uint256) \r\n    {\r\n        return token._allowances[_owner][_spender];\r\n    }\r\n\r\n    function approve(Xrc20Token storage token, address spender, uint256 amount) internal returns (bool) {\r\n        _approve(token, msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        Xrc20Token storage token,\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        token._allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function transfer(Xrc20Token storage token, address recipient, uint256 amount) internal returns (bool) {\r\n        _transfer(token, msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        Xrc20Token storage token,\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) \r\n    {\r\n        uint256 currentAllowance = token._allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(token, sender, msg.sender, currentAllowance - amount);\r\n        }\r\n        _transfer(token, sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(Xrc20Token storage token, address spender, uint256 addedValue) internal returns (bool) {\r\n        _approve(token, msg.sender, spender, token._allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(Xrc20Token storage token, address spender, uint256 subtractedValue) internal returns (bool) {\r\n        uint256 currentAllowance = token._allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(token, msg.sender, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferForeignEth(Xrc20Token storage token, uint256 ethWei) internal onlyOwner(token) returns(bool)\r\n    {\r\n        require(address(this).balance >= ethWei, \"the contract hasn't engogh eth to transfer\");\r\n        payable(address(msg.sender)).transfer(ethWei);\r\n\r\n        emit WithdrawEth(msg.sender, ethWei);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        Xrc20Token storage token,\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) private whenNotPaused(token) onlyUnfrozen(token, sender) onlyUnfrozen(token, recipient) hasEnoughTokens(token, sender, amount) {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = token.balances[sender];\r\n        unchecked {\r\n            token.balances[sender] = senderBalance - amount;\r\n        }\r\n        token.balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract YITZU {\r\n    BasicTokenLib.Xrc20Token private xrc20Token;\r\n    using BasicTokenLib for BasicTokenLib.Xrc20Token;\r\n\r\n    constructor(){\r\n        xrc20Token.initialize(0x5DB357308BB38d74093272f9F8F2A2F52A66374D, \"YITZU\", \"YZU\", 18, 1000000000000000, \"\", \"\");\r\n        xrc20Token.mint(msg.sender, 1000000000);\r\n    }\r\n\r\n    receive() external virtual payable { } \r\n\r\n    fallback() external virtual payable {  }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return xrc20Token.name();\r\n    }\r\n\r\n    function symbol() public view virtual  returns (string memory) {\r\n        return xrc20Token.symbol();\r\n    }\r\n\r\n    function decimals() public view virtual  returns (uint8) {\r\n        return xrc20Token.decimals();\r\n    }\r\n\r\n    function totalSupply() public view virtual  returns (uint256) {\r\n        return xrc20Token.totalSupply();\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual  returns (uint256) {\r\n        return xrc20Token.balanceOf(account);\r\n    }\r\n\r\n    function burn(address _who, uint256 _value) public virtual returns (bool) \r\n    {\r\n        return xrc20Token.burn(_who, _value);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual  returns (bool) {\r\n        return xrc20Token.transfer(recipient, amount);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual  returns (uint256) {\r\n        return xrc20Token.allowance(owner, spender);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual  returns (bool) {\r\n        return xrc20Token.approve(spender, amount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual  returns (bool) {\r\n        return xrc20Token.transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        return xrc20Token.increaseAllowance(spender, addedValue);\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        return xrc20Token.decreaseAllowance(spender, subtractedValue);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"YITZU","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://572435e935aa23910b856425928597667944cbe80507d4d3a312df3a2bbd69e7"}]}