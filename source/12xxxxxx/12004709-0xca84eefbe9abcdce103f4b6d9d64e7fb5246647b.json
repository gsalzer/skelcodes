{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\n/**\\n * Copyright 2018 ZeroEx Intl.\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *   http://www.apache.org/licenses/LICENSE-2.0\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract,\\n   * as the code is not actually created until after the constructor finishes.\\n   * @param account address of the account to check\\n   * @return whether the target address is a contract\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n    // XXX Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address.\\n    // See https://ethereum.stackexchange.com/a/14016/36603\\n    // for more details about how this works.\\n    // TODO Check this again before the Serenity release, because all addresses will be\\n    // contracts then.\\n    assembly { codehash := extcodehash(account) }\\n    return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\n  }\\n\\n}\"},\"Context.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"},\"ERC1155.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./IERC1155TokenReceiver.sol\\\";\\n\\n/**\\n * @dev Implementation of Multi-Token Standard contract\\n */\\ncontract ERC1155 is IERC165 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n\\n  /***********************************|\\n  |        Variables and Events       |\\n  |__________________________________*/\\n\\n  // onReceive function signatures\\n  bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\\n  bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\\n\\n  // Objects balances\\n  mapping (address =\\u003e mapping(uint256 =\\u003e uint256)) internal balances;\\n\\n  // Operator Functions\\n  mapping (address =\\u003e mapping(address =\\u003e bool)) internal operators;\\n\\n  // Events\\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n  event URI(string _uri, uint256 indexed _id);\\n\\n\\n  /***********************************|\\n  |     Public Transfer Functions     |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\\n   * @param _from    Source address\\n   * @param _to      Target address\\n   * @param _id      ID of the token type\\n   * @param _amount  Transfered amount\\n   * @param _data    Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\\n    public\\n  {\\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \\\"ERC1155#safeTransferFrom: INVALID_OPERATOR\\\");\\n    require(_to != address(0),\\\"ERC1155#safeTransferFrom: INVALID_RECIPIENT\\\");\\n    // require(_amount \\u003e= balances[_from][_id]) is not necessary since checked with safemath operations\\n\\n    _safeTransferFrom(_from, _to, _id, _amount);\\n    _callonERC1155Received(_from, _to, _id, _amount, _data);\\n  }\\n\\n  /**\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n   * @param _from     Source addresses\\n   * @param _to       Target addresses\\n   * @param _ids      IDs of each token type\\n   * @param _amounts  Transfer amounts per token type\\n   * @param _data     Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\\n    public\\n  {\\n    // Requirements\\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \\\"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\\\");\\n    require(_to != address(0), \\\"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\\\");\\n\\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\\n  }\\n\\n\\n  /***********************************|\\n  |    Internal Transfer Functions    |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\\n   * @param _from    Source address\\n   * @param _to      Target address\\n   * @param _id      ID of the token type\\n   * @param _amount  Transfered amount\\n   */\\n  function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\\n    internal\\n  {\\n    // Update balances\\n    balances[_from][_id] = balances[_from][_id].sub(_amount); // Subtract amount\\n    balances[_to][_id] = balances[_to][_id].add(_amount);     // Add amount\\n\\n    // Emit event\\n    emit TransferSingle(msg.sender, _from, _to, _id, _amount);\\n  }\\n\\n  /**\\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\\n   */\\n  function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\\n    internal\\n  {\\n    // Check if recipient is contract\\n    if (_to.isContract()) {\\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\\n      require(retval == ERC1155_RECEIVED_VALUE, \\\"ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE\\\");\\n    }\\n  }\\n\\n  /**\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n   * @param _from     Source addresses\\n   * @param _to       Target addresses\\n   * @param _ids      IDs of each token type\\n   * @param _amounts  Transfer amounts per token type\\n   */\\n  function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\\n    internal\\n  {\\n    require(_ids.length == _amounts.length, \\\"ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH\\\");\\n\\n    // Number of transfer to execute\\n    uint256 nTransfer = _ids.length;\\n\\n    // Executing all transfers\\n    for (uint256 i = 0; i \\u003c nTransfer; i++) {\\n      // Update storage balance of previous bin\\n      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\\n      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\\n    }\\n\\n    // Emit event\\n    emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\\n  }\\n\\n  /**\\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\\n   */\\n  function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\\n    internal\\n  {\\n    // Pass data if recipient is contract\\n    if (_to.isContract()) {\\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data);\\n      require(retval == ERC1155_BATCH_RECEIVED_VALUE, \\\"ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE\\\");\\n    }\\n  }\\n\\n\\n  /***********************************|\\n  |         Operator Functions        |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller\\u0027s tokens\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved)\\n    external\\n  {\\n    // Update operator status\\n    operators[msg.sender][_operator] = _approved;\\n    emit ApprovalForAll(msg.sender, _operator, _approved);\\n  }\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator)\\n    public view returns (bool isOperator)\\n  {\\n    return operators[_owner][_operator];\\n  }\\n\\n\\n  /***********************************|\\n  |         Balance Functions         |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice Get the balance of an account\\u0027s Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return The _owner\\u0027s balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id)\\n    public view returns (uint256)\\n  {\\n    return balances[_owner][_id];\\n  }\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner\\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\\n    public view returns (uint256[] memory)\\n  {\\n    require(_owners.length == _ids.length, \\\"ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH\\\");\\n\\n    // Variables\\n    uint256[] memory batchBalances = new uint256[](_owners.length);\\n\\n    // Iterate over each owner and token ID\\n    for (uint256 i = 0; i \\u003c _owners.length; i++) {\\n      batchBalances[i] = balances[_owners[i]][_ids[i]];\\n    }\\n\\n    return batchBalances;\\n  }\\n\\n\\n  /***********************************|\\n  |          ERC165 Functions         |\\n  |__________________________________*/\\n\\n  /**\\n   * INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256(\\\"supportsInterface(bytes4)\\\"));\\n   */\\n  bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\\n\\n  /**\\n   * INTERFACE_SIGNATURE_ERC1155 =\\n   * bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\")) ^\\n   * bytes4(keccak256(\\\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\\")) ^\\n   * bytes4(keccak256(\\\"balanceOf(address,uint256)\\\")) ^\\n   * bytes4(keccak256(\\\"balanceOfBatch(address[],uint256[])\\\")) ^\\n   * bytes4(keccak256(\\\"setApprovalForAll(address,bool)\\\")) ^\\n   * bytes4(keccak256(\\\"isApprovedForAll(address,address)\\\"));\\n   */\\n  bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID  The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID` and\\n   */\\n  function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\\n    if (_interfaceID == INTERFACE_SIGNATURE_ERC165 ||\\n        _interfaceID == INTERFACE_SIGNATURE_ERC1155) {\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n}\"},\"ERC1155Metadata.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\n/**\\n * @notice Contract that handles metadata related methods.\\n * @dev Methods assume a deterministic generation of URI based on token IDs.\\n *      Methods also assume that URI uses hex representation of token IDs.\\n */\\ncontract ERC1155Metadata {\\n\\n  // URI\\u0027s default URI prefix\\n  string internal baseMetadataURI;\\n  event URI(string _uri, uint256 indexed _id);\\n\\n\\n  /***********************************|\\n  |     Metadata Public Function s    |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\\n   * @dev URIs are defined in RFC 3986.\\n   *      URIs are assumed to be deterministically generated based on token ID\\n   *      Token IDs are assumed to be represented in their hex format in URIs\\n   * @return URI string\\n   */\\n  function uri(uint256 _id) public view returns (string memory) {\\n    return string(abi.encodePacked(baseMetadataURI, _uint2str(_id), \\\".json\\\"));\\n  }\\n\\n\\n  /***********************************|\\n  |    Metadata Internal Functions    |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice Will emit default URI log event for corresponding token _id\\n   * @param _tokenIDs Array of IDs of tokens to log default URI\\n   */\\n  function _logURIs(uint256[] memory _tokenIDs) internal {\\n    string memory baseURL = baseMetadataURI;\\n    string memory tokenURI;\\n\\n    for (uint256 i = 0; i \\u003c _tokenIDs.length; i++) {\\n      tokenURI = string(abi.encodePacked(baseURL, _uint2str(_tokenIDs[i]), \\\".json\\\"));\\n      emit URI(tokenURI, _tokenIDs[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice Will emit a specific URI log event for corresponding token\\n   * @param _tokenIDs IDs of the token corresponding to the _uris logged\\n   * @param _URIs    The URIs of the specified _tokenIDs\\n   */\\n  function _logURIs(uint256[] memory _tokenIDs, string[] memory _URIs) internal {\\n    require(_tokenIDs.length == _URIs.length, \\\"ERC1155Metadata#_logURIs: INVALID_ARRAYS_LENGTH\\\");\\n    for (uint256 i = 0; i \\u003c _tokenIDs.length; i++) {\\n      emit URI(_URIs[i], _tokenIDs[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice Will update the base URL of token\\u0027s URI\\n   * @param _newBaseMetadataURI New base URL of token\\u0027s URI\\n   */\\n  function _setBaseMetadataURI(string memory _newBaseMetadataURI) internal {\\n    baseMetadataURI = _newBaseMetadataURI;\\n  }\\n\\n\\n  /***********************************|\\n  |    Utility Internal Functions     |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice Convert uint256 to string\\n   * @param _i Unsigned integer to convert to string\\n   */\\n  function _uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\\n    if (_i == 0) {\\n      return \\\"0\\\";\\n    }\\n\\n    uint256 j = _i;\\n    uint256 ii = _i;\\n    uint256 len;\\n\\n    // Get number of bytes\\n    while (j != 0) {\\n      len++;\\n      j /= 10;\\n    }\\n\\n    bytes memory bstr = new bytes(len);\\n    uint256 k = len - 1;\\n\\n    // Get each individual ASCII\\n    while (ii != 0) {\\n      bstr[k--] = byte(uint8(48 + ii % 10));\\n      ii /= 10;\\n    }\\n\\n    // Convert to string\\n    return string(bstr);\\n  }\\n\\n}\"},\"ERC1155MintBurn.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\n\\nimport \\\"./ERC1155.sol\\\";\\n\\n\\n/**\\n * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\\n *      a parent contract to be executed as they are `internal` functions\\n */\\ncontract ERC1155MintBurn is ERC1155 {\\n\\n\\n  /****************************************|\\n  |            Minting Functions           |\\n  |_______________________________________*/\\n\\n  /**\\n   * @notice Mint _amount of tokens of a given id\\n   * @param _to      The address to mint tokens to\\n   * @param _id      Token id to mint\\n   * @param _amount  The amount to be minted\\n   * @param _data    Data to pass if receiver is contract\\n   */\\n  function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\\n    internal\\n  {\\n    // Add _amount\\n    balances[_to][_id] = balances[_to][_id].add(_amount);\\n\\n    // Emit event\\n    emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\\n\\n    // Calling onReceive method if recipient is contract\\n    _callonERC1155Received(address(0x0), _to, _id, _amount, _data);\\n  }\\n\\n  /**\\n   * @notice Mint tokens for each ids in _ids\\n   * @param _to       The address to mint tokens to\\n   * @param _ids      Array of ids to mint\\n   * @param _amounts  Array of amount of tokens to mint per id\\n   * @param _data    Data to pass if receiver is contract\\n   */\\n  function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\\n    internal\\n  {\\n    require(_ids.length == _amounts.length, \\\"ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH\\\");\\n\\n    // Number of mints to execute\\n    uint256 nMint = _ids.length;\\n\\n     // Executing all minting\\n    for (uint256 i = 0; i \\u003c nMint; i++) {\\n      // Update storage balance\\n      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\\n    }\\n\\n    // Emit batch mint event\\n    emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\\n\\n    // Calling onReceive method if recipient is contract\\n    _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, _data);\\n  }\\n\\n\\n  /****************************************|\\n  |            Burning Functions           |\\n  |_______________________________________*/\\n\\n  /**\\n   * @notice Burn _amount of tokens of a given token id\\n   * @param _from    The address to burn tokens from\\n   * @param _id      Token id to burn\\n   * @param _amount  The amount to be burned\\n   */\\n  function _burn(address _from, uint256 _id, uint256 _amount)\\n    internal\\n  {\\n    //Substract _amount\\n    balances[_from][_id] = balances[_from][_id].sub(_amount);\\n\\n    // Emit event\\n    emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\\n  }\\n\\n  /**\\n   * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\\n   * @param _from     The address to burn tokens from\\n   * @param _ids      Array of token ids to burn\\n   * @param _amounts  Array of the amount to be burned\\n   */\\n  function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\\n    internal\\n  {\\n    require(_ids.length == _amounts.length, \\\"ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH\\\");\\n\\n    // Number of mints to execute\\n    uint256 nBurn = _ids.length;\\n\\n     // Executing all minting\\n    for (uint256 i = 0; i \\u003c nBurn; i++) {\\n      // Update storage balance\\n      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\\n    }\\n\\n    // Emit batch mint event\\n    emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\\n  }\\n\\n}\"},\"ERC1155Minter.sol\":{\"content\":\"pragma solidity 0.5.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../Ownable.sol\\\";\\nimport \\\"../MinterRole.sol\\\";\\nimport \\\"../ERC1155.sol\\\";\\nimport \\\"../WhitelistAdminRole.sol\\\";\\nimport \\\"../ERC1155Metadata.sol\\\";\\nimport \\\"../ERC1155MintBurn.sol\\\";\\nimport \\\"../Strings.sol\\\";\\nimport \\\"../ProxyRegistry.sol\\\";\\n\\n/**\\n * @title ERC1155Tradable\\n * ERC1155Tradable - ERC1155 contract that whitelists an operator address, \\n * has create and mint functionality, and supports useful standards from OpenZeppelin,\\n  like _exists(), name(), symbol(), and totalSupply()\\n */\\ncontract ERC1155Minter is ERC1155, ERC1155MintBurn, ERC1155Metadata, Ownable, MinterRole, WhitelistAdminRole {\\n    using Strings for string;\\n\\n    struct Participant {\\n        uint128 nftId;\\n        uint64 x;\\n        uint64 y;\\n        address participant;\\n    }\\n\\n    Participant [] internal _participants;\\n    mapping(uint256 =\\u003e address) public creators;\\n    mapping(uint256 =\\u003e uint256) public tokenSupply;\\n    mapping(uint256 =\\u003e uint256) public tokenMaxSupply;\\n    // Contract name\\n    string public name;\\n    // Contract symbol\\n    string public symbol;\\n\\n    function init(string memory _name, string memory _symbol) public onlyOwner {\\n        require((bytes(name)).length == 0, \\u0027Already initiated\\u0027);\\n\\n        name = _name;\\n        symbol = _symbol;\\n        _addMinter(_msgSender());\\n        _addWhitelistAdmin(_msgSender());\\n        _setBaseMetadataURI(\\\"https://lambo.hcore.finance/spot-the-ball-win/#home\\\");\\n    }\\n\\n    function removeWhitelistAdmin(address account) public onlyOwner {\\n        _removeWhitelistAdmin(account);\\n    }\\n\\n    function removeMinter(address account) public onlyOwner {\\n        _removeMinter(account);\\n    }\\n\\n    /**\\n     * @dev Returns the total quantity for a token ID\\n     * @param _id uint256 ID of the token to query\\n     * @return amount of token in existence\\n     */\\n    function totalSupply(uint256 _id) public view returns (uint256) {\\n        return tokenSupply[_id];\\n    }\\n\\n    /**\\n     * @dev Returns the max quantity for a token ID\\n     * @param _id uint256 ID of the token to query\\n     * @return amount of token in existence\\n     */\\n    function maxSupply(uint256 _id) public view returns (uint256) {\\n        return tokenMaxSupply[_id];\\n    }\\n\\n    /**\\n     * @dev Will update the base URL of token\\u0027s URI\\n     * @param _newBaseMetadataURI New base URL of token\\u0027s URI\\n     */\\n    function setBaseMetadataURI(string memory _newBaseMetadataURI) public onlyWhitelistAdmin {\\n        _setBaseMetadataURI(_newBaseMetadataURI);\\n    }\\n\\n    /**\\n     * @dev Creates a new token type and assigns _initialSupply to an address\\n     * @param _maxSupply max supply allowed\\n     * @param _initialSupply Optional amount to supply the first owner\\n     * @param _id attemptId\\n     * @param _data Optional data to pass if receiver is contract\\n     * @return The newly created token ID\\n     */\\n    function create(\\n        address _creator,\\n        uint256 _maxSupply,\\n        uint256 _initialSupply,\\n        uint256 _id,\\n        uint64 _x,\\n        uint64 _y,\\n        bytes calldata _data\\n    ) external onlyMinter returns (uint256) {\\n        require(!_exists(_id), \\\"Id already used\\\");\\n        require(_initialSupply \\u003c= _maxSupply, \\\"Initial supply cannot be more than max supply\\\");\\n        creators[_id] = _creator;\\n\\n        if (_initialSupply != 0) _mint(_creator, _id, _initialSupply, _data);\\n        tokenSupply[_id] = _initialSupply;\\n        tokenMaxSupply[_id] = _maxSupply;\\n        _participants.push(Participant(uint128(_id), _x, _y, _creator));\\n        return _id;\\n    }\\n\\n    function getParticipantsCount() public view returns (uint) {\\n        return _participants.length;\\n    }\\n\\n    function getParticipantById(uint _id) public view returns (uint128, uint64, uint64, address) {\\n        Participant storage participant = _participants[_id];\\n        return (participant.nftId, participant.x, participant.y, participant.participant);\\n    }\\n\\n    /**\\n     * @dev Returns whether the specified token exists by checking to see if it has a creator\\n     * @param _id uint256 ID of the token to query the existence of\\n     * @return bool whether the token exists\\n     */\\n    function _exists(uint256 _id) internal view returns (bool) {\\n        return creators[_id] != address(0);\\n    }\\n\\n}\"},\"GameMinter.sol\":{\"content\":\"pragma solidity 0.5.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC1155Minter.sol\\\";\\n\\ncontract GameMinter is ERC1155Minter {\\n\\n  function uri() public view returns (string memory) {\\n    return baseMetadataURI;\\n  }\\n\\n  function uri(uint256) public view returns (string memory) {\\n    return baseMetadataURI;\\n  }\\n}\"},\"IERC1155.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\ninterface IERC1155 {\\n  // Events\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\n\\n  /**\\n   * @dev MUST emit when an approval is updated\\n   */\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n  /**\\n   * @dev MUST emit when the URI is updated for a token ID\\n   *   URIs are defined in RFC 3986\\n   *   The URI MUST point a JSON file that conforms to the \\\"ERC-1155 Metadata JSON Schema\\\"\\n   */\\n  event URI(string _amount, uint256 indexed _id);\\n\\n  /**\\n   * @notice Transfers amount of an _id from the _from address to the _to address specified\\n   * @dev MUST emit TransferSingle event on success\\n   * Caller must be approved to manage the _from account\\u0027s tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \\u003e 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   * @param _from    Source address\\n   * @param _to      Target address\\n   * @param _id      ID of the token type\\n   * @param _amount  Transfered amount\\n   * @param _data    Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\\n\\n  /**\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n   * @dev MUST emit TransferBatch event on success\\n   * Caller must be approved to manage the _from account\\u0027s tokens (see isApprovedForAll)\\n   * MUST throw if `_to` is the zero address\\n   * MUST throw if length of `_ids` is not the same as length of `_amounts`\\n   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\n   * MUST throw on any other error\\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \\u003e 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\n   * @param _from     Source addresses\\n   * @param _to       Target addresses\\n   * @param _ids      IDs of each token type\\n   * @param _amounts  Transfer amounts per token type\\n   * @param _data     Additional data with no specified format, sent in call to `_to`\\n  */\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\\n  \\n  /**\\n   * @notice Get the balance of an account\\u0027s Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return        The _owner\\u0027s balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner\\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller\\u0027s tokens\\n   * @dev MUST emit the ApprovalForAll event on success\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return           True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\\n\\n}\"},\"IERC1155TokenReceiver.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\n/**\\n * @dev ERC-1155 interface for accepting safe transfers.\\n */\\ninterface IERC1155TokenReceiver {\\n\\n  /**\\n   * @notice Handle the receipt of a single ERC1155 token type\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value MUST result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _id        The id of the token being transferred\\n   * @param _amount    The amount of tokens being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   */\\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\\n\\n  /**\\n   * @notice Handle the receipt of multiple ERC1155 token types\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value WILL result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _ids       An array containing ids of each token being transferred\\n   * @param _amounts   An array containing amounts of each token being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   */\\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\\n\\n  /**\\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\\n   *      This function MUST NOT consume more than 5,000 gas.\\n   * @return Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported.\\n   */\\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n\\n}\"},\"IERC165.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\n/**\\n * @title ERC165\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\ninterface IERC165 {\\n\\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @dev Interface identification is specified in ERC-165. This function\\n     * uses less than 30,000 gas\\n     * @param _interfaceId The interface identifier, as specified in ERC-165\\n     */\\n    function supportsInterface(bytes4 _interfaceId)\\n    external\\n    view\\n    returns (bool);\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"LPTokenWrapper.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ncontract LPTokenWrapper {\\n    using SafeMath for uint256;\\n    IERC20 public token;\\n\\n    constructor(IERC20 _erc20Address) public {\\n        token = IERC20(_erc20Address);\\n    }\\n\\n    uint256 private _totalSupply;\\n    mapping(address =\\u003e uint256) private _balances;\\n\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function stake(uint256 amount) public {\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n        token.transferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    function withdraw(uint256 amount) public {\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        token.transfer(msg.sender, amount);\\n    }\\n}\\n\"},\"MinterRole.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Roles.sol\\\";\\n\\ncontract MinterRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    Roles.Role private _minters;\\n\\n    modifier onlyMinter() {\\n        require(isMinter(_msgSender()), \\\"MinterRole: caller does not have the Minter role\\\");\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters.has(account);\\n    }\\n\\n    function addMinter(address account) public onlyMinter {\\n        _addMinter(account);\\n    }\\n\\n    function renounceMinter() public {\\n        _removeMinter(_msgSender());\\n    }\\n\\n    function _addMinter(address account) internal {\\n        _minters.add(account);\\n        emit MinterAdded(account);\\n    }\\n\\n    function _removeMinter(address account) internal {\\n        _minters.remove(account);\\n        emit MinterRemoved(account);\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity 0.5.12;\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"},\"ProxyRegistry.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\ncontract OwnableDelegateProxy {}\\n\\ncontract ProxyRegistry {\\n    mapping(address =\\u003e OwnableDelegateProxy) public proxies;\\n}\"},\"Roles.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address =\\u003e bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account\\u0027s access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n   * @dev Multiplies two unsigned integers, reverts on overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath#mul: OVERFLOW\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b \\u003e 0, \\\"SafeMath#div: DIVISION_BY_ZERO\\\");\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003c= a, \\\"SafeMath#sub: UNDERFLOW\\\");\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Adds two unsigned integers, reverts on overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a, \\\"SafeMath#add: OVERFLOW\\\");\\n\\n    return c; \\n  }\\n\\n  /**\\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n   * reverts when dividing by zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"SafeMath#mod: DIVISION_BY_ZERO\\\");\\n    return a % b;\\n  }\\n\\n}\"},\"Strings.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\n\\nlibrary Strings {\\n    // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\\n    function strConcat(\\n        string memory _a,\\n        string memory _b,\\n        string memory _c,\\n        string memory _d,\\n        string memory _e\\n    ) internal pure returns (string memory) {\\n        bytes memory _ba = bytes(_a);\\n        bytes memory _bb = bytes(_b);\\n        bytes memory _bc = bytes(_c);\\n        bytes memory _bd = bytes(_d);\\n        bytes memory _be = bytes(_e);\\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\\n        bytes memory babcde = bytes(abcde);\\n        uint256 k = 0;\\n        for (uint256 i = 0; i \\u003c _ba.length; i++) babcde[k++] = _ba[i];\\n        for (uint256 i = 0; i \\u003c _bb.length; i++) babcde[k++] = _bb[i];\\n        for (uint256 i = 0; i \\u003c _bc.length; i++) babcde[k++] = _bc[i];\\n        for (uint256 i = 0; i \\u003c _bd.length; i++) babcde[k++] = _bd[i];\\n        for (uint256 i = 0; i \\u003c _be.length; i++) babcde[k++] = _be[i];\\n        return string(babcde);\\n    }\\n\\n    function strConcat(\\n        string memory _a,\\n        string memory _b,\\n        string memory _c,\\n        string memory _d\\n    ) internal pure returns (string memory) {\\n        return strConcat(_a, _b, _c, _d, \\\"\\\");\\n    }\\n\\n    function strConcat(\\n        string memory _a,\\n        string memory _b,\\n        string memory _c\\n    ) internal pure returns (string memory) {\\n        return strConcat(_a, _b, _c, \\\"\\\", \\\"\\\");\\n    }\\n\\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\\n        return strConcat(_a, _b, \\\"\\\", \\\"\\\", \\\"\\\");\\n    }\\n\\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n}\"},\"WhitelistAdminRole.sol\":{\"content\":\"pragma solidity 0.5.12;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Roles.sol\\\";\\n\\n/**\\n * @title WhitelistAdminRole\\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\\n */\\ncontract WhitelistAdminRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event WhitelistAdminAdded(address indexed account);\\n    event WhitelistAdminRemoved(address indexed account);\\n\\n    Roles.Role private _whitelistAdmins;\\n\\n    modifier onlyWhitelistAdmin() {\\n        require(isWhitelistAdmin(_msgSender()), \\\"WhitelistAdminRole: caller does not have the WhitelistAdmin role\\\");\\n        _;\\n    }\\n\\n    function isWhitelistAdmin(address account) public view returns (bool) {\\n        return _whitelistAdmins.has(account);\\n    }\\n\\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\\n        _addWhitelistAdmin(account);\\n    }\\n\\n    function renounceWhitelistAdmin() public {\\n        _removeWhitelistAdmin(_msgSender());\\n    }\\n\\n    function _addWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.add(account);\\n        emit WhitelistAdminAdded(account);\\n    }\\n\\n    function _removeWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.remove(account);\\n        emit WhitelistAdminRemoved(account);\\n    }\\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_x\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_y\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"creators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getParticipantById\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParticipantsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isOperator\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newBaseMetadataURI\",\"type\":\"string\"}],\"name\":\"setBaseMetadataURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenMaxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GameMinter","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7488c021d92e735c6e57577f6c4c8ea4399834ce3253a0addaa1b39d284d44fd"}]}