{"status":"1","message":"OK","result":[{"SourceCode":"// \"SPDX-License-Identifier: GPL-3.0-or-later\"\r\n\r\npragma solidity 0.7.6;\r\n\r\n\r\n// Highly opinionated token implementation\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address whom) external view returns (uint);\r\n    function allowance(address src, address dst) external view returns (uint);\r\n\r\n    function approve(address dst, uint amt) external returns (bool);\r\n    function transfer(address dst, uint amt) external returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint amt\r\n    ) external returns (bool);\r\n}\r\n\r\npragma solidity 0.7.6;\r\n\r\n/// @title Derivative Specification interface\r\n/// @notice Immutable collection of derivative attributes\r\n/// @dev Created by the derivative's author and published to the DerivativeSpecificationRegistry\r\ninterface IDerivativeSpecification {\r\n    /// @notice Proof of a derivative specification\r\n    /// @dev Verifies that contract is a derivative specification\r\n    /// @return true if contract is a derivative specification\r\n    function isDerivativeSpecification() external pure returns (bool);\r\n\r\n    /// @notice Set of oracles that are relied upon to measure changes in the state of the world\r\n    /// between the start and the end of the Live period\r\n    /// @dev Should be resolved through OracleRegistry contract\r\n    /// @return oracle symbols\r\n    function oracleSymbols() external view returns (bytes32[] memory);\r\n\r\n    /// @notice Algorithm that, for the type of oracle used by the derivative,\r\n    /// finds the value closest to a given timestamp\r\n    /// @dev Should be resolved through OracleIteratorRegistry contract\r\n    /// @return oracle iterator symbols\r\n    function oracleIteratorSymbols() external view returns (bytes32[] memory);\r\n\r\n    /// @notice Type of collateral that users submit to mint the derivative\r\n    /// @dev Should be resolved through CollateralTokenRegistry contract\r\n    /// @return collateral token symbol\r\n    function collateralTokenSymbol() external view returns (bytes32);\r\n\r\n    /// @notice Mapping from the change in the underlying variable (as defined by the oracle)\r\n    /// and the initial collateral split to the final collateral split\r\n    /// @dev Should be resolved through CollateralSplitRegistry contract\r\n    /// @return collateral split symbol\r\n    function collateralSplitSymbol() external view returns (bytes32);\r\n\r\n    /// @notice Lifecycle parameter that define the length of the derivative's Live period.\r\n    /// @dev Set in seconds\r\n    /// @return live period value\r\n    function livePeriod() external view returns (uint256);\r\n\r\n    /// @notice Parameter that determines starting nominal value of primary asset\r\n    /// @dev Units of collateral theoretically swappable for 1 unit of primary asset\r\n    /// @return primary nominal value\r\n    function primaryNominalValue() external view returns (uint256);\r\n\r\n    /// @notice Parameter that determines starting nominal value of complement asset\r\n    /// @dev Units of collateral theoretically swappable for 1 unit of complement asset\r\n    /// @return complement nominal value\r\n    function complementNominalValue() external view returns (uint256);\r\n\r\n    /// @notice Minting fee rate due to the author of the derivative specification.\r\n    /// @dev Percentage fee multiplied by 10 ^ 12\r\n    /// @return author fee\r\n    function authorFee() external view returns (uint256);\r\n\r\n    /// @notice Symbol of the derivative\r\n    /// @dev Should be resolved through DerivativeSpecificationRegistry contract\r\n    /// @return derivative specification symbol\r\n    function symbol() external view returns (string memory);\r\n\r\n    /// @notice Return optional long name of the derivative\r\n    /// @dev Isn't used directly in the protocol\r\n    /// @return long name\r\n    function name() external view returns (string memory);\r\n\r\n    /// @notice Optional URI to the derivative specs\r\n    /// @dev Isn't used directly in the protocol\r\n    /// @return URI to the derivative specs\r\n    function baseURI() external view returns (string memory);\r\n\r\n    /// @notice Derivative spec author\r\n    /// @dev Used to set and receive author's fee\r\n    /// @return address of the author\r\n    function author() external view returns (address);\r\n}\r\n\r\npragma solidity 0.7.6;\r\n\r\ninterface IVault {\r\n    /// @notice vault initialization time\r\n    function initializationTime() external view returns(uint256);\r\n    /// @notice start of live period\r\n    function liveTime() external view returns(uint256);\r\n    /// @notice end of live period\r\n    function settleTime() external view returns(uint256);\r\n\r\n    /// @notice underlying value at the start of live period\r\n    function underlyingStarts(uint index) external view returns(int256);\r\n    /// @notice underlying value at the end of live period\r\n    function underlyingEnds(uint index) external view returns(int256);\r\n\r\n    /// @notice primary token conversion rate multiplied by 10 ^ 12\r\n    function primaryConversion() external view returns(uint256);\r\n    /// @notice complement token conversion rate multiplied by 10 ^ 12\r\n    function complementConversion() external view returns(uint256);\r\n\r\n    // @notice derivative specification address\r\n    function derivativeSpecification() external view returns(IDerivativeSpecification);\r\n    // @notice collateral token address\r\n    function collateralToken() external view returns(IERC20);\r\n    // @notice oracle address\r\n    function oracles(uint index) external view returns(address);\r\n    function oracleIterators(uint index) external view returns(address);\r\n\r\n    // @notice primary token address\r\n    function primaryToken() external view returns(IERC20);\r\n    // @notice complement token address\r\n    function complementToken() external view returns(IERC20);\r\n\r\n    function mint(uint256 _collateralAmount) external;\r\n\r\n    function mintTo(address _recipient, uint256 _collateralAmount) external;\r\n\r\n    function refund(uint256 _tokenAmount) external;\r\n\r\n    function refundTo(address _recipient, uint256 _tokenAmount) external;\r\n\r\n    function redeem(\r\n        uint256 _primaryTokenAmount,\r\n        uint256 _complementTokenAmount,\r\n        uint256[] memory _underlyingEndRoundHints\r\n    ) external;\r\n\r\n    function redeemTo(\r\n        address _recipient,\r\n        uint256 _primaryTokenAmount,\r\n        uint256 _complementTokenAmount,\r\n        uint256[] memory _underlyingEndRoundHints\r\n    ) external;\r\n}\r\n\r\npragma solidity 0.7.6;\r\n\r\ninterface IPool is IERC20 {\r\n\r\n    function repricingBlock() external view returns(uint);\r\n\r\n    function baseFee() external view returns(uint);\r\n    function feeAmp() external view returns(uint);\r\n    function maxFee() external view returns(uint);\r\n\r\n    function pMin() external view returns(uint);\r\n    function qMin() external view returns(uint);\r\n    function exposureLimit() external view returns(uint);\r\n    function volatility() external view returns(uint);\r\n\r\n    function derivativeVault() external view returns(IVault);\r\n    function dynamicFee() external view returns(address);\r\n    function repricer() external view returns(address);\r\n\r\n    function isFinalized()\r\n    external view\r\n    returns (bool);\r\n\r\n    function getNumTokens()\r\n    external view\r\n    returns (uint);\r\n\r\n    function getTokens()\r\n    external view\r\n    returns (address[] memory tokens);\r\n\r\n    function getLeverage(address token)\r\n    external view\r\n    returns (uint);\r\n\r\n    function getBalance(address token)\r\n    external view\r\n    returns (uint);\r\n\r\n    function getController()\r\n    external view\r\n    returns (address);\r\n\r\n    function setController(address manager)\r\n    external;\r\n\r\n\r\n    function joinPool(uint poolAmountOut, uint[2] calldata maxAmountsIn)\r\n    external;\r\n\r\n    function exitPool(uint poolAmountIn, uint[2] calldata minAmountsOut)\r\n    external;\r\n\r\n    function swapExactAmountIn(\r\n        address tokenIn,\r\n        uint tokenAmountIn,\r\n        address tokenOut,\r\n        uint minAmountOut\r\n    )\r\n    external\r\n    returns (uint tokenAmountOut, uint spotPriceAfter);\r\n}\r\n\r\npragma solidity 0.7.6;\r\n\r\ninterface IERC20Metadata {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: contracts/ProxyActions.sol\r\n\r\npragma solidity 0.7.6;\r\n\r\n\r\n\r\ncontract ProxyActions {\r\n\r\n    uint public constant BONE = 10**18;\r\n\r\n    // Using vars to avoid stack do deep error\r\n    struct Vars {\r\n        IERC20 collateralToken;\r\n        IERC20 primaryToken;\r\n        IERC20 complementToken;\r\n        IVault vault;\r\n        IPool pool;\r\n        uint256 primaryTokenBalance;\r\n        uint256 complementTokenBalance;\r\n        uint256 primaryTokenAmount;\r\n        uint256 complementTokenAmount;\r\n        IERC20 derivativeIn;\r\n        IERC20 derivativeOut;\r\n        uint256 tokenDecimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /// @notice Direct method mint\r\n    function mint(\r\n        address _vault,\r\n        uint256 _collateralAmount\r\n    ) external {\r\n\r\n        Vars memory vars;\r\n        vars.vault = IVault(_vault);\r\n        vars.collateralToken = IERC20(vars.vault.collateralToken());\r\n\r\n        // Transfer collateral from user to Proxy\r\n        require(\r\n            vars.collateralToken.transferFrom(msg.sender, address(this), _collateralAmount),\r\n            \"COLLATERAL_IN\"\r\n        );\r\n\r\n        vars.collateralToken.approve(_vault, _collateralAmount);\r\n\r\n        vars.vault.mintTo(msg.sender, _collateralAmount);\r\n    }\r\n\r\n    /// @notice Direct method refund\r\n    function refund(\r\n        address _vault,\r\n        uint256 _tokenAmount\r\n    ) external {\r\n\r\n        Vars memory vars;\r\n        vars.vault = IVault(_vault);\r\n        vars.primaryToken = IERC20(vars.vault.primaryToken());\r\n        vars.complementToken = IERC20(vars.vault.complementToken());\r\n\r\n        require(\r\n            vars.primaryToken.transferFrom(msg.sender, address(this), _tokenAmount),\r\n            \"PRIMARY_IN\"\r\n        );\r\n\r\n        require(\r\n            vars.complementToken.transferFrom(msg.sender, address(this), _tokenAmount),\r\n            \"COLLATERAL_IN\"\r\n        );\r\n\r\n        vars.primaryToken.approve(_vault, _tokenAmount);\r\n        vars.complementToken.approve(_vault, _tokenAmount);\r\n\r\n        vars.vault.refundTo(msg.sender, _tokenAmount);\r\n    }\r\n\r\n    /// @notice Direct method redeem\r\n    function redeem(\r\n        address _vault,\r\n        uint256 _primaryTokenAmount,\r\n        uint256 _complementTokenAmount,\r\n        uint256[] memory _underlyingEndRoundHints\r\n    ) external {\r\n\r\n        Vars memory vars;\r\n        vars.vault = IVault(_vault);\r\n        vars.primaryToken = IERC20(vars.vault.primaryToken());\r\n        vars.complementToken = IERC20(vars.vault.complementToken());\r\n\r\n        // Transfer collateral from user to Proxy\r\n        if(_primaryTokenAmount > 0) {\r\n            require(\r\n                vars.primaryToken.transferFrom(msg.sender, address(this), _primaryTokenAmount),\r\n                \"PRIMARY_IN\"\r\n            );\r\n            vars.primaryToken.approve(_vault, _primaryTokenAmount);\r\n        }\r\n\r\n        if(_complementTokenAmount > 0) {\r\n            require(\r\n                vars.complementToken.transferFrom(msg.sender, address(this), _complementTokenAmount),\r\n                \"COLLATERAL_IN\"\r\n            );\r\n            vars.complementToken.approve(_vault, _complementTokenAmount);\r\n        }\r\n\r\n        vars.vault.redeemTo(msg.sender, _primaryTokenAmount, _complementTokenAmount, _underlyingEndRoundHints);\r\n    }\r\n\r\n    /// @notice Withdraw own token balance\r\n    function withdraw(\r\n        address _token\r\n    ) external {\r\n        require(_token != address(0), \"ZERO_ADDRESS\");\r\n        IERC20 token = IERC20(_token);\r\n        token.transfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n\r\n    function withdrawAll(\r\n        address[] memory _tokens\r\n    ) external {\r\n        for(uint256 i = 0; i < _tokens.length; i++) {\r\n            this.withdraw(_tokens[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice direct method joinPool\r\n    function joinPool(\r\n        address _pool,\r\n        uint256 _poolAmountOut,\r\n        uint256[2] calldata _maxAmountsIn\r\n    ) external {\r\n        Vars memory vars;\r\n        vars.pool = IPool(_pool);\r\n\r\n        vars.vault = IVault(vars.pool.derivativeVault());\r\n\r\n        vars.primaryToken = IERC20(vars.vault.primaryToken());\r\n        vars.complementToken = IERC20(vars.vault.complementToken());\r\n\r\n        require(\r\n            vars.primaryToken.transferFrom(msg.sender, address(this), _maxAmountsIn[0]),\r\n            \"TAKE_PRIMARY\"\r\n        );\r\n\r\n        require(\r\n            vars.complementToken.transferFrom(msg.sender, address(this), _maxAmountsIn[1]),\r\n            \"TAKE_COMPLEMENT\"\r\n        );\r\n\r\n        vars.primaryToken.approve(_pool, _maxAmountsIn[0]);\r\n        vars.complementToken.approve(_pool, _maxAmountsIn[1]);\r\n\r\n        vars.pool.joinPool(_poolAmountOut,_maxAmountsIn);\r\n\r\n        // Return Remaining tokens\r\n        if (vars.primaryToken.balanceOf(address(this)) > 0) {\r\n            require(\r\n                vars.primaryToken.transfer(msg.sender,vars.primaryToken.balanceOf(address(this))),\r\n                \"GIVE_PRIMARY\"\r\n            );\r\n        }\r\n\r\n        if (vars.complementToken.balanceOf(address(this)) > 0) {\r\n            require(\r\n                    vars.complementToken.transfer(msg.sender,vars.complementToken.balanceOf(address(this))),\r\n                    \"GIVE_COMPLEMENT\"\r\n                );\r\n        }\r\n\r\n        // Transfer Pool Tokens To users\r\n        require (vars.pool.transfer( msg.sender, vars.pool.balanceOf(address(this))), \"GIVE_POOL\");\r\n    }\r\n\r\n    /// @notice Direct method swapExactAmountIn\r\n    function swap(\r\n        address _pool,\r\n        address _tokenIn,\r\n        uint256 _tokenAmountIn,\r\n        address _tokenOut,\r\n        uint256 _minAmountOut\r\n    ) external {\r\n\r\n        Vars memory vars;\r\n        vars.pool = IPool(_pool);\r\n\r\n        IERC20 tokenIn = IERC20(_tokenIn);\r\n        IERC20 tokenOut = IERC20(_tokenOut);\r\n\r\n        // Transfer tokens from user to Proxy\r\n        require(\r\n            tokenIn.transferFrom(msg.sender, address(this), _tokenAmountIn),\r\n            \"TAKE_IN\"\r\n        );\r\n\r\n        tokenIn.approve(_pool, _tokenAmountIn);\r\n\r\n        vars.pool.swapExactAmountIn(_tokenIn,_tokenAmountIn,_tokenOut,_minAmountOut);\r\n\r\n        require(\r\n            tokenOut.transfer(msg.sender, tokenOut.balanceOf(address(this))),\r\n            \"GIVE_OUT\"\r\n        );\r\n    }\r\n\r\n    /// @notice Direct method:  exitPool\r\n    function exitPool(\r\n        address _pool,\r\n        uint256 _poolAmountIn,\r\n        uint256[2] calldata _minAmountsOut\r\n    ) external {\r\n        Vars memory vars;\r\n        vars.pool = IPool(_pool);\r\n\r\n        vars.vault = IVault(vars.pool.derivativeVault());\r\n\r\n        vars.primaryToken = IERC20(vars.vault.primaryToken());\r\n        vars.complementToken = IERC20(vars.vault.complementToken());\r\n        vars.collateralToken = IERC20(vars.vault.collateralToken());\r\n\r\n        require(\r\n            vars.pool.transferFrom(msg.sender, address(this), _poolAmountIn),\r\n            \"TAKE_POOL\"\r\n        );\r\n\r\n        vars.pool.exitPool(_poolAmountIn, _minAmountsOut);\r\n\r\n        // Transfer Tokens to User Wallet\r\n        require(\r\n            vars.primaryToken.transfer(msg.sender, vars.primaryToken.balanceOf(address(this))),\r\n            \"GIVE_PRIMARY\"\r\n        );\r\n        require(\r\n            vars.complementToken.transfer(msg.sender, vars.complementToken.balanceOf(address(this))),\r\n            \"GIVE_COMPLEMENT\"\r\n        );\r\n    }\r\n\r\n    /// @notice  1 (Δ𝑪+, Δ𝑩𝒊-), user declares Δ𝑪+ : State = Live\r\n    function mintAndSwapCollateralToDerivative(\r\n        address _pool,\r\n        uint256 _collateralAmount,\r\n        address _tokenIn, // Unwanted Derivative to be swaped\r\n        uint256 _minAmountOut\r\n    ) external {\r\n\r\n        Vars memory vars;\r\n        vars.pool = IPool(_pool);\r\n\r\n        vars.vault = IVault(vars.pool.derivativeVault());\r\n\r\n        vars.collateralToken = IERC20(vars.vault.collateralToken());\r\n\r\n        /// Transfer collateral tokens from user to Proxy\r\n        require(\r\n            vars.collateralToken.transferFrom(msg.sender, address(this), _collateralAmount),\r\n            \"TAKE_COLLATERAL\"\r\n        );\r\n\r\n        (IERC20 tokenOut) = mintAndSwapCollateralToDerivativeInternal(\r\n            _pool,\r\n            _collateralAmount,\r\n            _tokenIn,\r\n            _minAmountOut\r\n        );\r\n\r\n        uint256 tokenOutBalance = tokenOut.balanceOf(address(this));\r\n\r\n        // Transfer Back To user wallet\r\n        require(tokenOut.transfer(msg.sender, tokenOutBalance), \"GIVE_OUT\");\r\n    }\r\n\r\n    function mintAndSwapCollateralToDerivativeInternal(\r\n        address _pool,\r\n        uint256 _collateralAmount,\r\n        address _tokenIn, // Unwanted Derivative to be swaped\r\n        uint256 _minAmountOut\r\n    ) internal returns (IERC20 tokenOut) {\r\n\r\n        Vars memory vars;\r\n        vars.pool = IPool(_pool);\r\n\r\n        vars.vault = IVault(vars.pool.derivativeVault());\r\n\r\n        vars.primaryToken = IERC20(vars.vault.primaryToken());\r\n        vars.complementToken = IERC20(vars.vault.complementToken());\r\n        vars.collateralToken = IERC20(vars.vault.collateralToken());\r\n\r\n        // Approve collateral Tokens for Vault Contract\r\n        vars.collateralToken.approve(address(vars.vault), _collateralAmount);\r\n\r\n        /// Mint Symmetric derivatives\r\n        vars.vault.mint(_collateralAmount);\r\n\r\n        address tokenOutAddress =\r\n        _tokenIn == address(vars.primaryToken)\r\n        ? address(vars.complementToken)\r\n        : address(vars.primaryToken);\r\n\r\n        tokenOut = IERC20(tokenOutAddress);\r\n        IERC20 tokenIn = IERC20(_tokenIn);\r\n\r\n        uint256 tokenInBalance = tokenIn.balanceOf(address(this));\r\n\r\n        tokenIn.approve(_pool, tokenInBalance);\r\n\r\n        /// Swap Unwanted derivative\r\n        vars.pool.swapExactAmountIn(\r\n            _tokenIn,\r\n            tokenInBalance,\r\n            tokenOutAddress,\r\n            _minAmountOut\r\n        );\r\n    }\r\n\r\n    /// @notice 3 (∆Bi+,∆C-), user declares ∆Bi+\r\n    /// @notice There is a sufficient collateral in the pool\r\n    function swapDerivativesToCollateral(\r\n        address _pool,\r\n        address _derivativeIn,\r\n        uint256 _derivativeAmount,\r\n        uint256 _tokenAmountIn,\r\n        address _derivativeOut,\r\n        uint256 _derivativeMinAmountOut\r\n    ) external {\r\n\r\n        (IERC20 collateralToken, uint256 collateralAmount) = swapDerivativesToCollateralInternal(\r\n            _pool,\r\n            _derivativeIn,\r\n            _derivativeAmount,\r\n            _tokenAmountIn,\r\n            _derivativeOut,\r\n            _derivativeMinAmountOut\r\n        );\r\n\r\n        // Transfer Collateral To users Wallet\r\n        require(collateralToken.transfer(msg.sender, collateralAmount), \"GIVE_COLLATERAL\");\r\n    }\r\n\r\n    function swapDerivativesToCollateralInternal(\r\n        address _pool,\r\n        address _derivativeIn,\r\n        uint256 _derivativeAmount,\r\n        uint256 _tokenAmountIn,\r\n        address _derivativeOut,\r\n        uint256 _derivativeMinAmountOut\r\n    ) internal returns (IERC20 collateralToken, uint256 collateralAmountOut) {\r\n        Vars memory vars;\r\n        vars.pool = IPool(_pool);\r\n\r\n        vars.vault = IVault(vars.pool.derivativeVault());\r\n\r\n        vars.primaryToken = IERC20(vars.vault.primaryToken());\r\n        vars.complementToken = IERC20(vars.vault.complementToken());\r\n        vars.collateralToken = IERC20(vars.vault.collateralToken());\r\n\r\n        require(\r\n            IERC20(_derivativeIn).transferFrom(msg.sender, address(this), _derivativeAmount),\r\n            \"TAKE_IN\"\r\n        );\r\n\r\n        IERC20(_derivativeIn).approve(_pool, _tokenAmountIn);\r\n\r\n        vars.pool.swapExactAmountIn(\r\n            _derivativeIn,\r\n            _tokenAmountIn,\r\n            _derivativeOut,\r\n            _derivativeMinAmountOut\r\n        );\r\n\r\n        uint256 primaryTokenAmount = vars.primaryToken.balanceOf(address(this));\r\n        uint256 complementTokenAmount = vars.complementToken.balanceOf(address(this));\r\n\r\n        vars.primaryToken.approve(address(vars.vault), primaryTokenAmount);\r\n        vars.complementToken.approve(address(vars.vault), complementTokenAmount);\r\n\r\n        uint256 _tokenAmountOut = min(primaryTokenAmount, complementTokenAmount);\r\n\r\n        vars.vault.refund(_tokenAmountOut);\r\n\r\n        if (vars.primaryToken.balanceOf(address(this)) > 0) {\r\n            vars.primaryToken.transfer(msg.sender, vars.primaryToken.balanceOf(address(this)));\r\n        }\r\n\r\n        if (vars.complementToken.balanceOf(address(this)) > 0) {\r\n            vars.complementToken.transfer(\r\n                msg.sender,\r\n                vars.complementToken.balanceOf(address(this))\r\n            );\r\n        }\r\n\r\n        collateralAmountOut = vars.collateralToken.balanceOf(address(this));\r\n        collateralToken  = vars.collateralToken;\r\n    }\r\n\r\n\r\n    // 6 Trade Between Derivatives\r\n    function tradeBetweenDerivatives(\r\n        address _poolFromAddress,\r\n        address _derivativeInAddress,\r\n        uint256 _derivativeInAmount,\r\n        uint256 _derivativeInAmountToSell,\r\n        address _derivativeOut,\r\n        uint256 _minTokenOutAmountForFirstSwap,\r\n        address _poolToAddress,\r\n        address _mintedDerivativeToSell,\r\n        uint256 _minTokenOutAmountForSecondSwap\r\n    ) external {\r\n\r\n        Vars memory vars;\r\n        vars.pool = IPool(_poolFromAddress);\r\n\r\n        vars.vault = IVault(vars.pool.derivativeVault());\r\n        vars.collateralToken = IERC20(vars.vault.collateralToken());\r\n\r\n        // Step 1: execute (ΔBi+, ΔC_) using Method 3\r\n        swapDerivativesToCollateralInternal(\r\n            _poolFromAddress,\r\n            _derivativeInAddress,\r\n            _derivativeInAmount,\r\n            _derivativeInAmountToSell,\r\n            _derivativeOut,\r\n            _minTokenOutAmountForFirstSwap\r\n        );\r\n\r\n        uint256 _collateralAmountToMint = vars.collateralToken.balanceOf(address(this));\r\n\r\n        // Step 2: execute (ΔC+, ΔBj-) using Method 1\r\n        (IERC20 tokenOut) = mintAndSwapCollateralToDerivativeInternal(\r\n            _poolToAddress,\r\n            _collateralAmountToMint,\r\n            _mintedDerivativeToSell,\r\n            _minTokenOutAmountForSecondSwap\r\n        );\r\n\r\n        uint256 tokenOutBalance = tokenOut.balanceOf(address(this));\r\n\r\n        // Transfer Back To user wallet\r\n        require(tokenOut.transfer(msg.sender, tokenOutBalance), \"GIVE_OUT\");\r\n    }\r\n\r\n     /// @notice  8 Mint & Add Liquidity - LP state=Live\r\n     function mintAndJoinPool(\r\n        address _pool,\r\n        uint256 _collateralAmount,\r\n        address _tokenIn,\r\n        uint256 _tokenAmountIn,\r\n        address _tokenOut,\r\n        uint256 _minAmountOut,\r\n        uint256 _minPoolAmountOut\r\n     ) external {\r\n         Vars memory vars;\r\n         vars.pool = IPool(_pool);\r\n\r\n         vars.vault = IVault(vars.pool.derivativeVault());\r\n\r\n         vars.primaryToken = IERC20(vars.vault.primaryToken());\r\n         vars.complementToken = IERC20(vars.vault.complementToken());\r\n         vars.collateralToken = IERC20(vars.vault.collateralToken());\r\n\r\n         // Transfer collateral tokens from users to Proxy\r\n         require(\r\n             vars.collateralToken.transferFrom(msg.sender, address(this), _collateralAmount),\r\n             \"TAKE_COLLATERAL\"\r\n         );\r\n\r\n         // Approve collateral Tokens for Vault Contract\r\n         vars.collateralToken.approve(address(vars.vault), _collateralAmount);\r\n\r\n         // Mint derivatives\r\n         vars.vault.mintTo(address(this), _collateralAmount);\r\n\r\n         if(_tokenAmountIn > 0) {\r\n             IERC20(_tokenIn).approve(_pool, _tokenAmountIn);\r\n\r\n             // Swap derivative for re-balancing\r\n             vars.pool.swapExactAmountIn(\r\n                 _tokenIn,\r\n                 _tokenAmountIn,\r\n                 _tokenOut,\r\n                 _minAmountOut\r\n             );\r\n         }\r\n\r\n         uint lpTokenSupply = IERC20(address(vars.pool)).totalSupply();\r\n         vars.primaryTokenBalance = vars.pool.getBalance(address(vars.primaryToken));\r\n         vars.complementTokenBalance = vars.pool.getBalance(address(vars.complementToken));\r\n         vars.primaryTokenAmount = vars.primaryToken.balanceOf(address(this));\r\n         vars.complementTokenAmount = vars.complementToken.balanceOf(address(this));\r\n\r\n         uint lpTokenMultiplier = 1;\r\n         vars.tokenDecimals = uint(IERC20Metadata(address(vars.collateralToken)).decimals());\r\n         if(vars.tokenDecimals > 0 && vars.tokenDecimals < 18) {\r\n             lpTokenMultiplier = 18 - vars.tokenDecimals;\r\n         }\r\n\r\n         uint poolAmountOut = min(\r\n             lpTokenSupply * scaleTo(vars.primaryTokenAmount, lpTokenMultiplier) * BONE / scaleTo(vars.primaryTokenBalance, lpTokenMultiplier),\r\n             lpTokenSupply * scaleTo(vars.complementTokenAmount, lpTokenMultiplier) * BONE / scaleTo(vars.complementTokenBalance, lpTokenMultiplier)\r\n         ) / BONE;\r\n\r\n         require(poolAmountOut >= _minPoolAmountOut, \"MIN_POOL_AMOUNT_OUT\");\r\n\r\n         vars.primaryToken.approve(_pool, vars.primaryTokenAmount);\r\n         vars.complementToken.approve(_pool, vars.complementTokenAmount);\r\n\r\n         uint256[2] memory tokenBalances;\r\n         tokenBalances[0] = vars.primaryTokenAmount;\r\n         tokenBalances[1] = vars.complementTokenAmount;\r\n\r\n         vars.pool.joinPool(poolAmountOut, tokenBalances);\r\n\r\n         require(vars.pool.transfer(msg.sender, poolAmountOut), \"GIVE_POOL\");\r\n     }\r\n\r\n\r\n    function scaleTo(uint256 _amount, uint256 _decimal) internal returns (uint256) {\r\n        return _amount * (10 ** _decimal);\r\n    }\r\n\r\n    /// @notice 9. Remove Liquidity & Redeem Settled Derivatives. User provides amount of LPtokens\r\n    function removeLiquidityOnSettledState(\r\n        address _pool,\r\n        uint256 _poolAmountIn,\r\n        uint256[2] calldata _minAmountsOut,\r\n        uint256[] memory _underlyingEndRoundHints\r\n    ) external {\r\n\r\n        Vars memory vars;\r\n        vars.pool = IPool(_pool);\r\n\r\n        vars.vault = IVault(vars.pool.derivativeVault());\r\n\r\n        vars.primaryToken = IERC20(vars.vault.primaryToken());\r\n        vars.complementToken = IERC20(vars.vault.complementToken());\r\n        vars.collateralToken = IERC20(vars.vault.collateralToken());\r\n\r\n        require(\r\n            vars.pool.transferFrom(msg.sender, address(this), _poolAmountIn),\r\n            \"TAKE_POOL\"\r\n        );\r\n\r\n        // Approve LP tokens for POOL // Not sure if this needed\r\n        require(vars.pool.approve(_pool, _poolAmountIn), \"APPROVE\");\r\n\r\n        // Step 1: Users sends LP tokens, receives (ΔBprim-, ΔBcompl-, ΔC-)\r\n        vars.pool.exitPool(_poolAmountIn, _minAmountsOut);\r\n\r\n        uint256 primaryTokenAmount = vars.primaryToken.balanceOf(address(this));\r\n        uint256 complementTokenAmount = vars.complementToken.balanceOf(address(this));\r\n\r\n        vars.primaryToken.approve(address(vars.vault), primaryTokenAmount);\r\n        vars.complementToken.approve(address(vars.vault), complementTokenAmount);\r\n\r\n        vars.vault.redeemTo(\r\n            msg.sender,\r\n            primaryTokenAmount,\r\n            complementTokenAmount,\r\n            _underlyingEndRoundHints\r\n        );\r\n    }\r\n\r\n    /// @notice 10. Remove Liquidity & Redeem Live Derivatives.\r\n    /// @notice User provides amount of LP tokens (method applies only when state = Minting or Live)\r\n    function removeLiquidityOnLiveOrMintingState(\r\n        address _pool,\r\n        uint256 _poolAmountIn,\r\n        address _tokenIn,\r\n        uint256 _tokenAmountIn,\r\n        uint256 _minAmountOut,\r\n        uint256[2] calldata _minAmountsOut\r\n    ) external {\r\n\r\n        Vars memory vars;\r\n        vars.pool = IPool(_pool);\r\n\r\n        vars.vault = IVault(vars.pool.derivativeVault());\r\n\r\n        vars.primaryToken = IERC20(vars.vault.primaryToken());\r\n        vars.complementToken = IERC20(vars.vault.complementToken());\r\n        vars.collateralToken = IERC20(vars.vault.collateralToken());\r\n\r\n        require(\r\n            vars.pool.transferFrom(msg.sender, address(this), _poolAmountIn),\r\n            \"TAKE_POOL\"\r\n        );\r\n\r\n        // Approve LP tokens for POOL // Not sure if this needed\r\n        require(vars.pool.approve(_pool, _poolAmountIn), \"APPROVE\");\r\n\r\n        // Step 1: Users sends LP tokens, receives (ΔBprim-, ΔBcompl-)\r\n        vars.pool.exitPool(_poolAmountIn, _minAmountsOut);\r\n\r\n        // Step 2: Execute Composite Method 5 to reach symmetric derivative portfolio\r\n        if(_tokenAmountIn > 0) {\r\n//            address tokenOut = _tokenIn == address(vars.primaryToken)\r\n//                ? address(vars.complementToken)\r\n//                : address(vars.primaryToken);\r\n//\r\n//            IERC20 tokenIn = IERC20(_tokenIn);\r\n//            uint256 tokenInBalance = tokenIn.balanceOf(address(this));\r\n//\r\n//            tokenIn.approve(address(vars.pool), tokenInBalance);\r\n//\r\n//            vars.pool.swapExactAmountIn(\r\n//                address(tokenIn),\r\n//                _tokenAmountIn,\r\n//                tokenOut,\r\n//                _minAmountOut\r\n//            );\r\n        }\r\n\r\n        // Step 3: Redeem refund symmetric derivative portfolio for collateral\r\n        vars.primaryTokenAmount = vars.primaryToken.balanceOf(address(this));\r\n        vars.complementTokenAmount = vars.complementToken.balanceOf(address(this));\r\n\r\n        uint256 _tokensAmountOut = min(vars.primaryTokenAmount, vars.complementTokenAmount);\r\n\r\n        vars.primaryToken.approve(address(vars.vault), _tokensAmountOut);\r\n        vars.complementToken.approve(address(vars.vault), _tokensAmountOut);\r\n\r\n        vars.vault.refundTo(msg.sender, _tokensAmountOut);\r\n\r\n        if(vars.primaryToken.balanceOf(address(this)) > vars.complementToken.balanceOf(address(this))) {\r\n            vars.primaryToken.transfer(msg.sender, vars.primaryToken.balanceOf(address(this)));\r\n        } else {\r\n            vars.complementToken.transfer(msg.sender, vars.complementToken.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    function extractChange(address _pool) external {\r\n        Vars memory vars;\r\n        vars.pool = IPool(_pool);\r\n\r\n        vars.vault = IVault(vars.pool.derivativeVault());\r\n\r\n        vars.primaryToken = IERC20(vars.vault.primaryToken());\r\n        vars.complementToken = IERC20(vars.vault.complementToken());\r\n\r\n        if (vars.primaryToken.balanceOf(address(this)) > 0) {\r\n            vars.primaryToken.transfer(\r\n                msg.sender,\r\n                vars.primaryToken.balanceOf(address(this))\r\n            );\r\n        }\r\n\r\n        if (vars.complementToken.balanceOf(address(this)) > 0) {\r\n            vars.complementToken.transfer(\r\n                msg.sender,\r\n                vars.complementToken.balanceOf(address(this))\r\n            );\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"_minAmountsOut\",\"type\":\"uint256[2]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"extractChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"_maxAmountsIn\",\"type\":\"uint256[2]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"mintAndJoinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountOut\",\"type\":\"uint256\"}],\"name\":\"mintAndSwapCollateralToDerivative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_primaryTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_complementTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_underlyingEndRoundHints\",\"type\":\"uint256[]\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"_minAmountsOut\",\"type\":\"uint256[2]\"}],\"name\":\"removeLiquidityOnLiveOrMintingState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"_minAmountsOut\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[]\",\"name\":\"_underlyingEndRoundHints\",\"type\":\"uint256[]\"}],\"name\":\"removeLiquidityOnSettledState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountOut\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_derivativeIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_derivativeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_derivativeOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_derivativeMinAmountOut\",\"type\":\"uint256\"}],\"name\":\"swapDerivativesToCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolFromAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_derivativeInAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_derivativeInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_derivativeInAmountToSell\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_derivativeOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minTokenOutAmountForFirstSwap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mintedDerivativeToSell\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minTokenOutAmountForSecondSwap\",\"type\":\"uint256\"}],\"name\":\"tradeBetweenDerivatives\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ProxyActions","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://62ea10348f176820ca0713286d854c16529616c1e67520a9c6364a28aa9a414f"}]}