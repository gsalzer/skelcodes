{"status":"1","message":"OK","result":[{"SourceCode":"{\"FixedSupplyToken.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at Etherscan.io on 2019-05-09\\r\\n*/\\r\\n\\r\\npragma solidity ^0.5.8;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// Contract function to receive approval and execute function in one call\\r\\n//\\r\\n// Borrowed from MiniMeToken\\r\\n// ----------------------------------------------------------------------------\\r\\ncontract ApproveAndCallFallBack {\\r\\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\\r\\n}\\r\\n\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// Owned contract\\r\\n// ----------------------------------------------------------------------------\\r\\ncontract Owned {\\r\\n    address public owner;\\r\\n    address public newOwner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\r\\n    \\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address _newOwner) public onlyOwner {\\r\\n        newOwner = _newOwner;\\r\\n    }\\r\\n    function acceptOwnership() public {\\r\\n        require(msg.sender == newOwner);\\r\\n        emit OwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n        newOwner = address(0);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// ERC20 Token, with the addition of symbol, name and decimals and a\\r\\n// fixed supply\\r\\n// ----------------------------------------------------------------------------\\r\\ncontract FixedSupplyToken is IERC20, Owned {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    string public symbol;\\r\\n    string public  name;\\r\\n    uint8 public decimals;\\r\\n    uint public _totalSupply;\\r\\n\\r\\n    mapping(address =\\u003e uint) balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\r\\n\\r\\n\\r\\n\\r\\n    constructor(string memory _symbol,string memory _name,uint8 _decimals,uint256 _total,address _owner) public {\\r\\n        symbol = _symbol;\\r\\n        name = _name;\\r\\n        decimals = _decimals;\\r\\n        owner = _owner;\\r\\n        _totalSupply = _total * (10 ** uint(decimals));\\r\\n        balances[owner] = _totalSupply;\\r\\n        emit Transfer(address(0), owner, _totalSupply);\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Total supply\\r\\n    // ------------------------------------------------------------------------\\r\\n    function totalSupply() public view returns (uint) {\\r\\n        return _totalSupply.sub(balances[address(0)]);\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Get the token balance for account `tokenOwner`\\r\\n    // ------------------------------------------------------------------------\\r\\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\\r\\n        return balances[tokenOwner];\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Transfer the balance from token owner\\u0027s account to `to` account\\r\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\r\\n    // - 0 value transfers are allowed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transfer(address to, uint tokens) public returns (bool success) {\\r\\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\\r\\n        balances[to] = balances[to].add(tokens);\\r\\n        emit Transfer(msg.sender, to, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\r\\n    // from the token owner\\u0027s account\\r\\n    //\\r\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\r\\n    // recommends that there are no checks for the approval double-spend attack\\r\\n    // as this should be implemented in user interfaces\\r\\n    // ------------------------------------------------------------------------\\r\\n    function approve(address spender, uint tokens) public returns (bool success) {\\r\\n        allowed[msg.sender][spender] = tokens;\\r\\n        emit Approval(msg.sender, spender, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Transfer `tokens` from the `from` account to the `to` account\\r\\n    //\\r\\n    // The calling account must already have sufficient tokens approve(...)-d\\r\\n    // for spending from the `from` account and\\r\\n    // - From account must have sufficient balance to transfer\\r\\n    // - Spender must have sufficient allowance to transfer\\r\\n    // - 0 value transfers are allowed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\\r\\n        balances[from] = balances[from].sub(tokens);\\r\\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\\r\\n        balances[to] = balances[to].add(tokens);\\r\\n        emit Transfer(from, to, tokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Returns the amount of tokens approved by the owner that can be\\r\\n    // transferred to the spender\\u0027s account\\r\\n    // ------------------------------------------------------------------------\\r\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\\r\\n        return allowed[tokenOwner][spender];\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\r\\n    // from the token owner\\u0027s account. The `spender` contract function\\r\\n    // `receiveApproval(...)` is then executed\\r\\n    // ------------------------------------------------------------------------\\r\\n    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\\r\\n        allowed[msg.sender][spender] = tokens;\\r\\n        emit Approval(msg.sender, spender, tokens);\\r\\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    function () external payable {\\r\\n        revert();\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\\r\\n        return IERC20(tokenAddress).transfer(owner, tokens);\\r\\n    }\\r\\n}\\r\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\n/**\\n * @title IERC20 interface\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IPledgeMining.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\ncontract IPledgeMining {\\n    event PledgeEvent(address indexed user, uint256 indexed amount, uint256 indexed day);\\n    event ReceiveIncomeEvent(address indexed user, uint256 indexed amount, uint256 indexed index);\\n    event RemovePledgeEvent(address indexed user, uint256 indexed amount, uint256 indexed index);\\n\\n\\n    function pledge(uint256 _amount, uint256 _type) public returns (uint256);\\n\\n    function calcReceiveIncome(address addr, uint256 _index) public view returns (uint256);\\n\\n    function receiveIncome(uint256 _index) public returns (uint256);\\n\\n    function removePledge(uint256 _index) public returns (uint256);\\n\\n    function closeRenewal(uint256 _index) public;\\n\\n    function openRenewal(uint256 _index) public;\\n\\n    function getUserRecords(address addr, uint256 offset, uint256 size) public view returns (\\n        uint256 [4] memory page,\\n        uint256 [] memory data\\n    );\\n\\n}\"},\"PledgeMining.sol\":{\"content\":\"pragma solidity ^0.5.8;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\nimport \\\"./ReentrancyGuard.sol\\\";\\r\\nimport \\\"./IPledgeMining.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n//质押挖矿合约逻辑\\r\\n//ADAO质押币\\r\\n//WDAO收益币\\r\\n//一．质押erc20代币ADAO：质押时间为30/60/90/120/150/180天，到期才能赎回，未到时间不予赎回，且按质押数量定挖。\\r\\n//质押币本位精算到天结算：30天为总挖矿5/千，60天为总挖矿12/千，90天总挖矿21/千，120天总挖矿32/千，150天为总挖矿45/千，180天为总挖矿60/千。\\r\\n//二．质押币ADAO为整数，数量1个起步\\r\\n//例如：A质押ADAO54个，质押时间为60天，A最终收益为：54ADAO*12/1000=0.648WDAO，平均每天收益为0.648/60=0.0108WDAO。\\r\\n\\r\\n\\r\\n//PLEDGE:AMOUNT_ERROR 输入金额不足1个ADAO\\r\\n//PLEDGE:TYPE_ERROR   输入类型合约不支持\\r\\n//PLEDGE:SAFE_TRANSFER_FROM_ERROR 转账到智能合约失败\\r\\n//PLEDGE:RECORD_OVER  质押记录已结束\\r\\n//PLEDGE:SAFE_TRANSFER_ERROR  智能合约转出失败\\r\\n//PLEDGE:NO_EXTRA_INCOME  没有多余的收益\\r\\n//PLEDGE:NOT_EXPIRED  未到期\\r\\n//PLEDGE:STOP_MINING  停止挖矿\\r\\n//PLEDGE:UNABLE_TO_CLOSE_RENEWAL  无法关闭续约\\r\\n//PLEDGE:UNABLE_TO_OPEN_RENEWAL  无法开启续约\\r\\n\\r\\ncontract Owned {\\r\\n    address public owner;\\r\\n    address public newOwner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\r\\n\\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address _newOwner) public onlyOwner {\\r\\n        newOwner = _newOwner;\\r\\n    }\\r\\n\\r\\n    function acceptOwnership() public {\\r\\n        require(msg.sender == newOwner);\\r\\n        emit OwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n        newOwner = address(0);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract PledgeMining is IPledgeMining, ReentrancyGuard, Owned {\\r\\n\\r\\n    IERC20  _tokenA;\\r\\n    IERC20  _tokenB;\\r\\n    using TransferHelper for address;\\r\\n    using SafeMath for uint;\\r\\n    uint256 periodUnit = 1 days;\\r\\n    bool public mining_state;\\r\\n\\r\\n    struct Record {\\r\\n        uint256 id;\\r\\n        uint256 createTime;\\r\\n        uint256 stopTime;\\r\\n        uint256 heaven;\\r\\n        uint256 scale;\\r\\n        uint256 pledgeAmount;\\r\\n        uint256 releaseAmount;\\r\\n        uint256 over; // 1 processing 2 over\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e Record []) miningRecords;\\r\\n    mapping(uint256 =\\u003e uint256) public typeConfig;\\r\\n\\r\\n\\r\\n    constructor(address tokenA, address tokenB) public {\\r\\n        _tokenA = IERC20(tokenA);\\r\\n        _tokenB = IERC20(tokenB);\\r\\n\\r\\n        // pledge type config init\\r\\n        typeConfig[uint256(30)] = uint256(5);\\r\\n        typeConfig[uint256(60)] = uint256(12);\\r\\n        typeConfig[uint256(90)] = uint256(21);\\r\\n        typeConfig[uint256(120)] = uint256(32);\\r\\n        typeConfig[uint256(150)] = uint256(45);\\r\\n        typeConfig[uint256(180)] = uint256(60);\\r\\n        mining_state = true;\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Does not accept ETH\\r\\n    function() external payable {\\r\\n        revert();\\r\\n    }\\r\\n\\r\\n    modifier mining {\\r\\n        require(mining_state, \\\"PLEDGE:STOP_MINING\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    // 停止挖矿,并从资金池提取WDAO\\r\\n    function stop_mining(uint256 tokenAAmount, uint256 tokenBAmount) public nonReentrant onlyOwner {\\r\\n        if (tokenAAmount \\u003e 0) {\\r\\n            require(address(_tokenA).safeTransfer(msg.sender, tokenAAmount), \\\"PLEDGE:SAFE_TRANSFER_ERROR\\\");\\r\\n        }\\r\\n        if (tokenBAmount \\u003e 0) {\\r\\n            require(address(_tokenB).safeTransfer(msg.sender, tokenBAmount), \\\"PLEDGE:SAFE_TRANSFER_ERROR\\\");\\r\\n        }\\r\\n        mining_state = false;\\r\\n    }\\r\\n\\r\\n\\r\\n    // 质押\\r\\n    function pledge(uint256 _amount, uint256 _type) public mining nonReentrant returns (uint256){\\r\\n        require(_amount \\u003e= (10 ** uint(18)), \\\"PLEDGE:AMOUNT_ERROR\\\");\\r\\n        require(typeConfig[_type] != uint256(0), \\\"PLEDGE:TYPE_ERROR\\\");\\r\\n        require(address(_tokenA).safeTransferFrom(msg.sender, address(this), _amount), \\\"PLEDGE:SAFE_TRANSFER_FROM_ERROR\\\");\\r\\n\\r\\n        uint256 scale = typeConfig[_type];\\r\\n        Record [] storage records = miningRecords[msg.sender];\\r\\n        uint256 _id = records.length;\\r\\n        records.push(Record(_id, block.timestamp, 0, _type, scale, _amount, 0, 1));\\r\\n        emit PledgeEvent(msg.sender, _amount, _type);\\r\\n        return _id;\\r\\n    }\\r\\n\\r\\n\\r\\n    //领取收益\\r\\n    function receiveIncomeInternal(uint256 _index) internal returns (uint256){\\r\\n        uint256 income = calcReceiveIncome(msg.sender, _index);\\r\\n        if (income \\u003e 0) {\\r\\n            Record storage r = miningRecords[msg.sender][_index];\\r\\n            r.releaseAmount = r.releaseAmount.add(income);\\r\\n            require(address(_tokenB).safeTransfer(msg.sender, income), \\\"PLEDGE:SAFE_TRANSFER_ERROR\\\");\\r\\n            emit ReceiveIncomeEvent(msg.sender, income, _index);\\r\\n        }\\r\\n        return (income);\\r\\n    }\\r\\n\\r\\n    // 关闭续约\\r\\n    function closeRenewal(uint256 _index) public nonReentrant {\\r\\n        Record storage r = miningRecords[msg.sender][_index];\\r\\n        require(r.over == uint256(1) \\u0026\\u0026 r.stopTime == uint256(0), \\\"PLEDGE:UNABLE_TO_CLOSE_RENEWAL\\\");\\r\\n        // 周期 =（ （（当前时间-开始时间）/ 周期时间） + 1） * 周期时间\\r\\n        r.stopTime = block.timestamp.sub(r.createTime)\\r\\n        .div(r.heaven.mul(periodUnit)).add(1)\\r\\n        .mul(r.heaven.mul(periodUnit)).add(r.createTime);\\r\\n    }\\r\\n\\r\\n    // 开启续约\\r\\n    function openRenewal(uint256 _index) public nonReentrant {\\r\\n        Record storage r = miningRecords[msg.sender][_index];\\r\\n        require(r.over == uint256(1) \\u0026\\u0026 r.stopTime \\u003e 0 \\u0026\\u0026 block.timestamp \\u003c r.stopTime, \\\"PLEDGE:UNABLE_TO_OPEN_RENEWAL\\\");\\r\\n        r.stopTime = uint256(0);\\r\\n    }\\r\\n\\r\\n\\r\\n    // 领取收益\\r\\n    function receiveIncome(uint256 _index) public nonReentrant returns (uint256){\\r\\n        uint256 income = receiveIncomeInternal(_index);\\r\\n        require(income \\u003e 0, \\\"PLEDGE:NO_EXTRA_INCOME\\\");\\r\\n        return (income);\\r\\n    }\\r\\n\\r\\n    // 移除质押\\r\\n    function removePledge(uint256 _index) public nonReentrant returns (uint256){\\r\\n        Record storage r = miningRecords[msg.sender][_index];\\r\\n        require(r.over == uint256(1) \\u0026\\u0026 r.stopTime \\u003e 0 \\u0026\\u0026 block.timestamp \\u003e= r.stopTime, \\\"PLEDGE:NOT_EXPIRED\\\");\\r\\n        uint256 income = receiveIncomeInternal(_index);\\r\\n        require(address(_tokenA).safeTransfer(msg.sender, r.pledgeAmount), \\\"PLEDGE:SAFE_TRANSFER_ERROR\\\");\\r\\n        r.over = uint256(2);\\r\\n        emit RemovePledgeEvent(msg.sender, r.pledgeAmount, _index);\\r\\n        return (income);\\r\\n    }\\r\\n\\r\\n\\r\\n    // 计算收益\\r\\n    function calcReceiveIncome(address addr, uint256 _index) public view returns (uint256){\\r\\n        Record storage r = miningRecords[addr][_index];\\r\\n        require(r.over == uint256(1), \\\"PLEDGE:RECORD_OVER\\\");\\r\\n\\r\\n        uint256 oneTotal = r.pledgeAmount.mul(r.scale).div(uint256(1000));\\r\\n        // current income = total * (block time - create time) / (heaven * 1 day)\\r\\n        uint256 _income = oneTotal.mul(block.timestamp.sub(r.createTime)).div(r.heaven.mul(periodUnit));\\r\\n        //Cannot exceed total revenue\\r\\n        if (r.stopTime \\u003e 0) {\\r\\n            // total income  =  54ADAO * 12 / 1000 * 周期时间\\r\\n            // total = amount * scale / 1000 * 周期时间\\r\\n            uint256 _total = oneTotal\\r\\n            .mul(r.stopTime.sub(r.createTime).div(r.heaven.mul(periodUnit)));\\r\\n            if (_income \\u003e _total) {\\r\\n                _income = _total;\\r\\n            }\\r\\n        }\\r\\n        _income = _income.sub(r.releaseAmount);\\r\\n\\r\\n\\r\\n        // 如果收益大于了平台余额，那么就不给币了\\r\\n        uint256 _balance = _tokenB.balanceOf(address(this));\\r\\n        if (_income \\u003e 0 \\u0026\\u0026 _income \\u003e _balance) {\\r\\n            _income = _balance;\\r\\n        }\\r\\n\\r\\n        return (_income);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    // 获取token 地址\\r\\n    function getTokens() public view returns (address, address){\\r\\n        return (address(_tokenA), address(_tokenB));\\r\\n    }\\r\\n\\r\\n\\r\\n    // 通过分页的方式获取用户质押记录\\r\\n    function getUserRecords(address addr, uint256 offset, uint256 size) public view returns (\\r\\n        uint256 [4] memory page,\\r\\n        uint256 [] memory data\\r\\n    ){\\r\\n        require(offset \\u003e= 0);\\r\\n        require(size \\u003e 0);\\r\\n        Record [] storage records = miningRecords[addr];\\r\\n        uint256 lrSize = records.length;\\r\\n        uint256 len = 0;\\r\\n        uint256 prop_count = 8;\\r\\n        if (size \\u003e lrSize) {\\r\\n            size = lrSize;\\r\\n        }\\r\\n        data = new uint256[](size * prop_count);\\r\\n        if (lrSize == 0 || offset \\u003e (lrSize - 1)) {\\r\\n            return ([len, block.timestamp, lrSize, prop_count], data);\\r\\n        }\\r\\n        uint256 i = lrSize - 1 - offset;\\r\\n        uint256 iMax = 0;\\r\\n        if (offset \\u003c= (lrSize - size)) {\\r\\n            iMax = lrSize - size - offset;\\r\\n        }\\r\\n        while (i \\u003e= 0 \\u0026\\u0026 i \\u003e= iMax) {\\r\\n            Record memory r = records[i];\\r\\n            data[len * prop_count + 0] = r.id;\\r\\n            data[len * prop_count + 1] = r.createTime;\\r\\n            data[len * prop_count + 2] = r.stopTime;\\r\\n            data[len * prop_count + 3] = r.heaven;\\r\\n            data[len * prop_count + 4] = r.scale;\\r\\n            data[len * prop_count + 5] = r.pledgeAmount;\\r\\n            data[len * prop_count + 6] = r.releaseAmount;\\r\\n            data[len * prop_count + 7] = r.over;\\r\\n            len = len + 1;\\r\\n            if (i == 0) {\\r\\n                break;\\r\\n            }\\r\\n            i--;\\r\\n        }\\r\\n        return ([len, block.timestamp, lrSize, prop_count], data);\\r\\n    }\\r\\n\\r\\n\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction\\u0027s gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        _notEntered = true;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.8;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Unsigned math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n    /**\\r\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath#mul: OVERFLOW\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, \\\"SafeMath#div: DIVISION_BY_ZERO\\\");\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath#sub: UNDERFLOW\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath#add: OVERFLOW\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\r\\n     * reverts when dividing by zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath#mod: DIVISION_BY_ZERO\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n\\r\\n}\"},\"SunnyStop.sol\":{\"content\":\"/**\\n *Submitted for verification at Etherscan.io on 2019-05-09\\n*/\\n\\npragma solidity ^0.5.8;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./TransferHelper.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./PledgeMining.sol\\\";\\n\\n\\ncontract SunnyStop is Owned {\\n    IERC20  _tokenA;\\n    IERC20  _tokenB;\\n    PledgeMining  _pledgeMining;\\n    using TransferHelper for address;\\n    using SafeMath for uint;\\n//    uint256 periodUnit = 1 minutes;\\n    uint256 periodUnit = 1 days;\\n\\n\\n    mapping(address =\\u003e bool)  public userUse;\\n    mapping(address =\\u003e uint256)  public userTokenA;\\n    mapping(address =\\u003e uint256)  public userTokenB;\\n\\n    uint256 public stopTime;\\n    bool public mining_state;\\n\\n    struct Record {\\n        uint256 id;\\n        uint256 createTime;\\n        uint256 stopTime;\\n        uint256 heaven;\\n        uint256 scale;\\n        uint256 pledgeAmount;\\n        uint256 releaseAmount;\\n        uint256 over; // 1 processing 2 over\\n    }\\n\\n\\n    constructor(address tokenA, address tokenB, address payable pledgeMining_) public {\\n        _tokenA = IERC20(tokenA);\\n        _tokenB = IERC20(tokenB);\\n        stopTime = block.timestamp;\\n        owner = msg.sender;\\n        _pledgeMining = PledgeMining(pledgeMining_);\\n        mining_state = true;\\n    }\\n\\n    modifier mining {\\n        require(mining_state, \\\"PLEDGE:STOP_MINING\\\");\\n        _;\\n    }\\n\\n\\n    // 停止挖矿,并从资金池提取WDAO\\n    function stop_mining(uint256 tokenAAmount, uint256 tokenBAmount) public onlyOwner {\\n        if (tokenAAmount \\u003e 0) {\\n            require(address(_tokenA).safeTransfer(msg.sender, tokenAAmount), \\\"SAFE_TRANSFER_ERROR\\\");\\n        }\\n        if (tokenBAmount \\u003e 0) {\\n            require(address(_tokenB).safeTransfer(msg.sender, tokenBAmount), \\\"SAFE_TRANSFER_ERROR\\\");\\n        }\\n        mining_state = false;\\n    }\\n\\n\\n    function calcReceiveIncome(Record memory r) internal view returns (uint256){\\n\\n        uint256 oneTotal = r.pledgeAmount.mul(r.scale).div(uint256(1000));\\n        uint256 _income = oneTotal.mul(stopTime.sub(r.createTime)).div(r.heaven.mul(periodUnit));\\n        if (r.stopTime \\u003e 0) {\\n            // total income  =  54ADAO * 12 / 1000 * 周期时间\\n            // total = amount * scale / 1000 * 周期时间\\n            uint256 _total = oneTotal\\n            .mul(r.stopTime.sub(r.createTime).div(r.heaven.mul(periodUnit)));\\n            if (_income \\u003e _total) {\\n                _income = _total;\\n            }\\n        }\\n        _income = _income.sub(r.releaseAmount);\\n        // 如果收益大于了平台余额，那么就不给币了\\n        uint256 _balance = _tokenB.balanceOf(address(this));\\n        if (_income \\u003e 0 \\u0026\\u0026 _income \\u003e _balance) {\\n            _income = _balance;\\n        }\\n        return (_income);\\n    }\\n\\n\\n    function getAmount(address user) public view returns (uint256 token0, uint256 token1){\\n        if (userUse[user]) {\\n            return (token0, token1);\\n        }\\n\\n        (\\n        uint256 [4] memory page,\\n        uint256 [] memory data\\n        ) = _pledgeMining.getUserRecords(user, 0, 10000);\\n\\n        uint256 len = page[0];\\n        uint256 prop_count = page[3];\\n        for (uint256 i = 0; i \\u003c len; i++) {\\n            Record memory r = Record(\\n                data[i * prop_count + 0],\\n                data[i * prop_count + 1],\\n                data[i * prop_count + 2],\\n                data[i * prop_count + 3],\\n                data[i * prop_count + 4],\\n                data[i * prop_count + 5],\\n                data[i * prop_count + 6],\\n                data[i * prop_count + 7]\\n            );\\n            if (r.over == uint256(1)) {\\n                token1 = token1.add(calcReceiveIncome(r));\\n                token0 = token0.add(r.pledgeAmount);\\n            }\\n\\n        }\\n        return (token0, token1);\\n    }\\n\\n    event Withdraw(address indexed user, uint256 indexed token0, uint256 indexed token1);\\n\\n    function withdraw() public mining {\\n        require(!userUse[msg.sender], \\\"withdraw Use\\\");\\n        (uint256 token0, uint256 token1) = getAmount(msg.sender);\\n        userUse[msg.sender] = true;\\n        userTokenA[msg.sender] = userTokenA[msg.sender].add(token0);\\n        userTokenB[msg.sender] = userTokenB[msg.sender].add(token1);\\n        if (token0 \\u003e 0) {\\n            require(address(_tokenA).safeTransfer(msg.sender, token0), \\\"SAFE_TRANSFER_ERROR TOKEN0\\\");\\n        }\\n        if (token1 \\u003e 0) {\\n            require(address(_tokenB).safeTransfer(msg.sender, token1), \\\"SAFE_TRANSFER_ERROR TOKEN1\\\");\\n        }\\n        emit Withdraw(msg.sender, token0, token1);\\n    }\\n}\"},\"TransferHelper.sol\":{\"content\":\"pragma solidity ^0.5.8;\\r\\n\\r\\nlibrary TransferHelper {\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) internal returns (bool){\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        return (success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address token, address from, address to, uint value) internal returns (bool){\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        return (success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))));\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"pledgeMining_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token0\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token1\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mining_state\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"}],\"name\":\"stop_mining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTokenA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTokenB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userUse\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SunnyStop","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000071fbc1d795fcfbca43a3ebf6de0101952f31a41000000000000000000000000056aa2f35ad4bf936a144d193b43fcc0f27b16f5b000000000000000000000000e45d8a1096b663c3f6404c97506b237320b8bce7","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://faf59185e8275b69fe1a543d3b57b69103e1dc04e6a9a26129eada922f9990c5"}]}