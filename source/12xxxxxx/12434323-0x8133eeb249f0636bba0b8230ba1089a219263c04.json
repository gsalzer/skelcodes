{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/balancer/BRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"../interfaces/IBPool.sol\\\";\\nimport \\\"../interfaces/IBFactory.sol\\\";\\n\\n/**\\n * @title BRegistry\\n * @author Protofire\\n * @dev Stores a registry of Balancer Pool addresses for a given token address pair. Pools can be\\n * sorted in order of liquidity and queried via view functions. Used in combination with the Exchange\\n * Proxy swaps can be sourced and exectured entirely on-chain.\\n *\\n * This code is based on Balancer On Chain Registry contract\\n * https://docs.balancer.finance/smart-contracts/on-chain-registry\\n * (https://etherscan.io/address/0x7226DaaF09B3972320Db05f5aB81FF38417Dd687#code)\\n */\\ncontract BRegistry {\\n    using SafeMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    struct PoolPairInfo {\\n        uint80 weight1;\\n        uint80 weight2;\\n        uint80 swapFee;\\n        uint256 liq;\\n    }\\n\\n    struct SortedPools {\\n        EnumerableSet.AddressSet pools;\\n        bytes32 indices;\\n    }\\n\\n    event PoolTokenPairAdded(address indexed pool, address indexed token1, address indexed token2);\\n\\n    event IndicesUpdated(address indexed token1, address indexed token2, bytes32 oldIndices, bytes32 newIndices);\\n\\n    uint256 private constant BONE = 10**18;\\n    uint256 private constant MAX_SWAP_FEE = (3 * BONE) / 100;\\n\\n    mapping(bytes32 => SortedPools) private _pools;\\n    mapping(address => mapping(bytes32 => PoolPairInfo)) private _infos;\\n\\n    IBFactory public bfactory;\\n\\n    constructor(address _bfactory) {\\n        bfactory = IBFactory(_bfactory);\\n    }\\n\\n    function getPairInfo(\\n        address pool,\\n        address fromToken,\\n        address destToken\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 weight1,\\n            uint256 weight2,\\n            uint256 swapFee\\n        )\\n    {\\n        bytes32 key = _createKey(fromToken, destToken);\\n        PoolPairInfo memory info = _infos[pool][key];\\n        return (info.weight1, info.weight2, info.swapFee);\\n    }\\n\\n    function getPoolsWithLimit(\\n        address fromToken,\\n        address destToken,\\n        uint256 offset,\\n        uint256 limit\\n    ) public view returns (address[] memory result) {\\n        bytes32 key = _createKey(fromToken, destToken);\\n        result = new address[](Math.min(limit, _pools[key].pools.values.length - offset));\\n        for (uint256 i = 0; i < result.length; i++) {\\n            result[i] = _pools[key].pools.values[offset + i];\\n        }\\n    }\\n\\n    function getBestPools(address fromToken, address destToken) external view returns (address[] memory pools) {\\n        return getBestPoolsWithLimit(fromToken, destToken, 32);\\n    }\\n\\n    function getBestPoolsWithLimit(\\n        address fromToken,\\n        address destToken,\\n        uint256 limit\\n    ) public view returns (address[] memory pools) {\\n        bytes32 key = _createKey(fromToken, destToken);\\n        bytes32 indices = _pools[key].indices;\\n        uint256 len = 0;\\n        while (indices[len] > 0 && len < Math.min(limit, indices.length)) {\\n            len++;\\n        }\\n\\n        pools = new address[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            uint256 index = uint256(uint8(indices[i])).sub(1);\\n            pools[i] = _pools[key].pools.values[index];\\n        }\\n    }\\n\\n    // Add and update registry\\n\\n    function addPoolPair(\\n        address pool,\\n        address token1,\\n        address token2\\n    ) public returns (uint256 listed) {\\n        require(bfactory.isBPool(pool), \\\"ERR_NOT_BPOOL\\\");\\n\\n        uint256 swapFee = IBPool(pool).getSwapFee();\\n        require(swapFee <= MAX_SWAP_FEE, \\\"ERR_FEE_TOO_HIGH\\\");\\n\\n        bytes32 key = _createKey(token1, token2);\\n        _pools[key].pools.add(pool);\\n\\n        if (token1 < token2) {\\n            _infos[pool][key] = PoolPairInfo({\\n                weight1: uint80(IBPool(pool).getDenormalizedWeight(token1)),\\n                weight2: uint80(IBPool(pool).getDenormalizedWeight(token2)),\\n                swapFee: uint80(swapFee),\\n                liq: uint256(0)\\n            });\\n        } else {\\n            _infos[pool][key] = PoolPairInfo({\\n                weight1: uint80(IBPool(pool).getDenormalizedWeight(token2)),\\n                weight2: uint80(IBPool(pool).getDenormalizedWeight(token1)),\\n                swapFee: uint80(swapFee),\\n                liq: uint256(0)\\n            });\\n        }\\n\\n        emit PoolTokenPairAdded(pool, token1, token2);\\n\\n        listed++;\\n    }\\n\\n    function addPools(\\n        address[] calldata pools,\\n        address token1,\\n        address token2\\n    ) external returns (uint256[] memory listed) {\\n        listed = new uint256[](pools.length);\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            listed[i] = addPoolPair(pools[i], token1, token2);\\n        }\\n    }\\n\\n    function sortPools(address[] calldata tokens, uint256 lengthLimit) external {\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            for (uint256 j = i + 1; j < tokens.length; j++) {\\n                bytes32 key = _createKey(tokens[i], tokens[j]);\\n                address[] memory pools = getPoolsWithLimit(tokens[i], tokens[j], 0, Math.min(256, lengthLimit));\\n                uint256[] memory effectiveLiquidity = _getEffectiveLiquidityForPools(tokens[i], tokens[j], pools);\\n\\n                bytes32 indices = _buildSortIndices(effectiveLiquidity);\\n\\n                // console.logBytes32(indices);\\n\\n                if (indices != _pools[key].indices) {\\n                    emit IndicesUpdated(\\n                        tokens[i] < tokens[j] ? tokens[i] : tokens[j],\\n                        tokens[i] < tokens[j] ? tokens[j] : tokens[i],\\n                        _pools[key].indices,\\n                        indices\\n                    );\\n                    _pools[key].indices = indices;\\n                }\\n            }\\n        }\\n    }\\n\\n    function sortPoolsWithPurge(address[] calldata tokens, uint256 lengthLimit) external {\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            for (uint256 j = i + 1; j < tokens.length; j++) {\\n                bytes32 key = _createKey(tokens[i], tokens[j]);\\n                address[] memory pools = getPoolsWithLimit(tokens[i], tokens[j], 0, Math.min(256, lengthLimit));\\n                uint256[] memory effectiveLiquidity = _getEffectiveLiquidityForPoolsPurge(tokens[i], tokens[j], pools);\\n                bytes32 indices = _buildSortIndices(effectiveLiquidity);\\n\\n                if (indices != _pools[key].indices) {\\n                    emit IndicesUpdated(\\n                        tokens[i] < tokens[j] ? tokens[i] : tokens[j],\\n                        tokens[i] < tokens[j] ? tokens[j] : tokens[i],\\n                        _pools[key].indices,\\n                        indices\\n                    );\\n                    _pools[key].indices = indices;\\n                }\\n            }\\n        }\\n    }\\n\\n    // Internal\\n\\n    function _createKey(address token1, address token2) internal pure returns (bytes32) {\\n        return\\n            bytes32(\\n                (uint256(uint128((token1 < token2) ? token1 : token2)) << 128) |\\n                    (uint256(uint128((token1 < token2) ? token2 : token1)))\\n            );\\n    }\\n\\n    function _getEffectiveLiquidityForPools(\\n        address token1,\\n        address token2,\\n        address[] memory pools\\n    ) internal view returns (uint256[] memory effectiveLiquidity) {\\n        effectiveLiquidity = new uint256[](pools.length);\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            bytes32 key = _createKey(token1, token2);\\n            PoolPairInfo memory info = _infos[pools[i]][key];\\n            if (token1 < token2) {\\n                // we define effective liquidity as b2 * w1 / (w1 + w2)\\n                effectiveLiquidity[i] = bdiv(uint256(info.weight1), uint256(info.weight1).add(uint256(info.weight2)));\\n                effectiveLiquidity[i] = effectiveLiquidity[i].mul(IBPool(pools[i]).getBalance(token2));\\n                // console.log(\\\"1. %s: %s\\\", pools[i], effectiveLiquidity[i]);\\n            } else {\\n                effectiveLiquidity[i] = bdiv(uint256(info.weight2), uint256(info.weight1).add(uint256(info.weight2)));\\n                effectiveLiquidity[i] = effectiveLiquidity[i].mul(IBPool(pools[i]).getBalance(token2));\\n                // console.log(\\\"2. %s: %s\\\", pools[i], effectiveLiquidity[i]);\\n            }\\n        }\\n    }\\n\\n    // Calculates total liquidity for all existing token pair pools\\n    // Removes any that are below threshold\\n    function _getEffectiveLiquidityForPoolsPurge(\\n        address token1,\\n        address token2,\\n        address[] memory pools\\n    ) public returns (uint256[] memory effectiveLiquidity) {\\n        uint256 totalLiq = 0;\\n        bytes32 key = _createKey(token1, token2);\\n\\n        // Store each pools liquidity and sum total liquidity\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            PoolPairInfo memory info = _infos[pools[i]][key];\\n            if (token1 < token2) {\\n                // we define effective liquidity as b2 * w1 / (w1 + w2)\\n                _infos[pools[i]][key].liq = bdiv(\\n                    uint256(info.weight1),\\n                    uint256(info.weight1).add(uint256(info.weight2))\\n                );\\n                _infos[pools[i]][key].liq = _infos[pools[i]][key].liq.mul(IBPool(pools[i]).getBalance(token2));\\n                totalLiq = totalLiq.add(_infos[pools[i]][key].liq);\\n                // console.log(\\\"1. %s: %s\\\", pools[i], _infos[pools[i]][key].liq);\\n            } else {\\n                _infos[pools[i]][key].liq = bdiv(\\n                    uint256(info.weight2),\\n                    uint256(info.weight1).add(uint256(info.weight2))\\n                );\\n                _infos[pools[i]][key].liq = _infos[pools[i]][key].liq.mul(IBPool(pools[i]).getBalance(token2));\\n                totalLiq = totalLiq.add(_infos[pools[i]][key].liq);\\n                // console.log(\\\"2. %s: %s\\\", pools[i], _infos[pools[i]][key].liq);\\n            }\\n        }\\n\\n        uint256 threshold = bmul(totalLiq, ((10 * BONE) / 100));\\n        // console.log(\\\"totalLiq: %s, Thresh: %s\\\", totalLiq, threshold);\\n\\n        // Delete any pools that aren't greater than threshold (10% of total)\\n        for (uint256 i = 0; i < _pools[key].pools.length(); i++) {\\n            //console.log(\\\"Pool: %s, %s\\\", _pools[key].pools.values[i], info.liq);\\n            if (_infos[_pools[key].pools.values[i]][key].liq < threshold) {\\n                _pools[key].pools.remove(_pools[key].pools.values[i]);\\n            }\\n        }\\n\\n        effectiveLiquidity = new uint256[](_pools[key].pools.length());\\n\\n        // pool.remove reorders pools so need to use correct liq for index\\n        for (uint256 i = 0; i < _pools[key].pools.length(); i++) {\\n            // console.log(_pools[key].pools.values[i]);\\n            effectiveLiquidity[i] = _infos[_pools[key].pools.values[i]][key].liq;\\n        }\\n    }\\n\\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint256 c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bdiv overflow\\n        uint256 c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint256 c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint256 c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint256 c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function _buildSortIndices(uint256[] memory effectiveLiquidity) internal pure returns (bytes32) {\\n        uint256 result = 0;\\n        uint256 prevEffectiveLiquidity = uint256(-1);\\n        for (uint256 i = 0; i < Math.min(effectiveLiquidity.length, 32); i++) {\\n            uint256 bestIndex = 0;\\n            for (uint256 j = 0; j < effectiveLiquidity.length; j++) {\\n                if (\\n                    (effectiveLiquidity[j] > effectiveLiquidity[bestIndex] &&\\n                        effectiveLiquidity[j] < prevEffectiveLiquidity) ||\\n                    effectiveLiquidity[bestIndex] >= prevEffectiveLiquidity\\n                ) {\\n                    bestIndex = j;\\n                }\\n            }\\n            prevEffectiveLiquidity = effectiveLiquidity[bestIndex];\\n            result |= (bestIndex + 1) << (248 - i * 8);\\n        }\\n        return bytes32(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/balancer/EnumerableSet.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * As of v2.5.0, only `address` sets are supported.\\n *\\n * Include with `using EnumerableSet for EnumerableSet.AddressSet;`.\\n *\\n * _Available since v2.5.0._\\n *\\n * @author Alberto Cuesta CaÃ±ada\\n */\\nlibrary EnumerableSet {\\n    struct AddressSet {\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(address => uint256) index;\\n        address[] values;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     * Returns false if the value was already in the set.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        if (!contains(set, value)) {\\n            set.values.push(value);\\n            set.index[value] = set.values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     * Returns false if the value was not present in the set.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        if (contains(set, value)) {\\n            uint256 toDeleteIndex = set.index[value] - 1;\\n            uint256 lastIndex = set.values.length - 1;\\n\\n            // If the element we're deleting is the last one, we can just remove it without doing a swap\\n            if (lastIndex != toDeleteIndex) {\\n                address lastValue = set.values[lastIndex];\\n\\n                // Move the last value to the index where the deleted value is\\n                set.values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set.index[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\\n            }\\n\\n            // Delete the index entry for the deleted value\\n            delete set.index[value];\\n\\n            // Delete the old entry for the moved value\\n            set.values.pop();\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return set.index[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns an array with all values in the set. O(N).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n\\n     * WARNING: This function may run out of gas on large sets: use {length} and\\n     * {get} instead in these cases.\\n     */\\n    function enumerate(AddressSet storage set) internal view returns (address[] memory) {\\n        address[] memory output = new address[](set.values.length);\\n        for (uint256 i; i < set.values.length; i++) {\\n            output[i] = set.values[i];\\n        }\\n        return output;\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements on the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return set.values.length;\\n    }\\n\\n    /** @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function get(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return set.values[index];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBPool.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title IBPool\\n * @author Protofire\\n * @dev Balancer BPool contract interface.\\n *\\n */\\ninterface IBPool {\\n    function isPublicSwap() external view returns (bool);\\n\\n    function isFinalized() external view returns (bool);\\n\\n    function isBound(address t) external view returns (bool);\\n\\n    function getNumTokens() external view returns (uint256);\\n\\n    function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n    function getFinalTokens() external view returns (address[] memory tokens);\\n\\n    function getDenormalizedWeight(address token) external view returns (uint256);\\n\\n    function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n    function getNormalizedWeight(address token) external view returns (uint256);\\n\\n    function getBalance(address token) external view returns (uint256);\\n\\n    function getSwapFee() external view returns (uint256);\\n\\n    function getController() external view returns (address);\\n\\n    function setSwapFee(uint256 swapFee) external;\\n\\n    function setController(address manager) external;\\n\\n    function setPublicSwap(bool public_) external;\\n\\n    function finalize() external;\\n\\n    function bind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) external;\\n\\n    function rebind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) external;\\n\\n    function unbind(address token) external;\\n\\n    function gulp(address token) external;\\n\\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        address tokenOut,\\n        uint256 minAmountOut,\\n        uint256 maxPrice\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint256 maxAmountIn,\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 maxPrice\\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\\n\\n    function joinswapExternAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        uint256 minPoolAmountOut\\n    ) external returns (uint256 poolAmountOut);\\n\\n    function joinswapPoolAmountOut(\\n        address tokenIn,\\n        uint256 poolAmountOut,\\n        uint256 maxAmountIn\\n    ) external returns (uint256 tokenAmountIn);\\n\\n    function exitswapPoolAmountIn(\\n        address tokenOut,\\n        uint256 poolAmountIn,\\n        uint256 minAmountOut\\n    ) external returns (uint256 tokenAmountOut);\\n\\n    function exitswapExternAmountOut(\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 maxPoolAmountIn\\n    ) external returns (uint256 poolAmountIn);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address whom) external view returns (uint256);\\n\\n    function allowance(address src, address dst) external view returns (uint256);\\n\\n    function approve(address dst, uint256 amt) external returns (bool);\\n\\n    function transfer(address dst, uint256 amt) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amt\\n    ) external returns (bool);\\n\\n    function calcSpotPrice(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 spotPrice);\\n\\n    function calcOutGivenIn(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 tokenAmountIn,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountOut);\\n\\n    function calcInGivenOut(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 tokenAmountOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountIn);\\n\\n    function calcPoolOutGivenSingleIn(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 tokenAmountIn,\\n        uint256 swapFee\\n    ) external pure returns (uint256 poolAmountOut);\\n\\n    function calcSingleInGivenPoolOut(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 poolAmountOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountIn);\\n\\n    function calcSingleOutGivenPoolIn(\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 poolAmountIn,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountOut);\\n\\n    function calcPoolInGivenSingleOut(\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 tokenAmountOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 poolAmountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IBPool.sol\\\";\\n\\ninterface IBFactory {\\n    event LOG_NEW_POOL(address indexed caller, address indexed pool);\\n\\n    function isBPool(address b) external view returns (bool);\\n\\n    function newBPool() external returns (IBPool);\\n\\n    function setExchProxy(address exchProxy) external;\\n\\n    function setOperationsRegistry(address operationsRegistry) external;\\n\\n    function setPermissionManager(address permissionManager) external;\\n\\n    function setAuthorization(address _authorization) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bfactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"oldIndices\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newIndices\",\"type\":\"bytes32\"}],\"name\":\"IndicesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"}],\"name\":\"PoolTokenPairAdded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"_getEffectiveLiquidityForPoolsPurge\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"effectiveLiquidity\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"}],\"name\":\"addPoolPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"listed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"}],\"name\":\"addPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"listed\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bfactory\",\"outputs\":[{\"internalType\":\"contract IBFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"}],\"name\":\"getBestPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getBestPoolsWithLimit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"}],\"name\":\"getPairInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weight1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getPoolsWithLimit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"lengthLimit\",\"type\":\"uint256\"}],\"name\":\"sortPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"lengthLimit\",\"type\":\"uint256\"}],\"name\":\"sortPoolsWithPurge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BRegistry","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009186503af1d7d3317b4c2c44a815be984838c296","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}