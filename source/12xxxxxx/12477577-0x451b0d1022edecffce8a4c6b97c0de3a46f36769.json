{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.3.0 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v3.4.0\r\n\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/proxy/Initializable.sol@v3.4.0\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.4.24 <0.8.0;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        return !Address.isContract(address(this));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IMaintainersRegistry.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/**\r\n * IMaintainersRegistry contract.\r\n * @author Nikola Madjarevic\r\n * Date created: 3.5.21.\r\n * Github: madjarevicn\r\n */\r\ninterface IMaintainersRegistry {\r\n    function isMaintainer(address _address) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/ChainportMiddleware.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/**\r\n * ChainportMiddleware contract.\r\n * @author Nikola Madjarevic\r\n * Date created: 4.5.21.\r\n * Github: madjarevicn\r\n */\r\ncontract ChainportMiddleware {\r\n\r\n    address public chainportCongress;\r\n    IMaintainersRegistry public maintainersRegistry;\r\n\r\n    // Only maintainer modifier\r\n    modifier onlyMaintainer {\r\n        require(maintainersRegistry.isMaintainer(msg.sender), \"ChainportUpgradables: Restricted only to Maintainer\");\r\n        _;\r\n    }\r\n\r\n    // Only chainport congress modifier\r\n    modifier onlyChainportCongress {\r\n        require(msg.sender == chainportCongress, \"ChainportUpgradables: Restricted only to ChainportCongress\");\r\n        _;\r\n    }\r\n\r\n    function setCongressAndMaintainers(\r\n        address _chainportCongress,\r\n        address _maintainersRegistry\r\n    )\r\n    internal\r\n    {\r\n        chainportCongress = _chainportCongress;\r\n        maintainersRegistry = IMaintainersRegistry(_maintainersRegistry);\r\n    }\r\n\r\n    function setMaintainersRegistry(\r\n        address _maintainersRegistry\r\n    )\r\n    public\r\n    onlyChainportCongress\r\n    {\r\n        maintainersRegistry = IMaintainersRegistry(_maintainersRegistry);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Validator.sol\r\n\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\n/**\r\n * Validator contract.\r\n * @author Nikola Madjarevic\r\n * Date created: 3.5.21.\r\n * Github: madjarevicn\r\n */\r\ncontract Validator is Initializable, ChainportMiddleware {\r\n\r\n    address public signatoryAddress;\r\n\r\n    // Set initial signatory address and Chainport congress\r\n    function initialize(\r\n        address _signatoryAddress,\r\n        address _chainportCongress,\r\n        address _maintainersRegistry\r\n    )\r\n    public\r\n    initializer\r\n    {\r\n        signatoryAddress = _signatoryAddress;\r\n        setCongressAndMaintainers(_chainportCongress, _maintainersRegistry);\r\n    }\r\n\r\n    // Set / change signatory address\r\n    function setSignatoryAddress(\r\n        address _signatoryAddress\r\n    )\r\n    public\r\n    onlyChainportCongress\r\n    {\r\n        require(_signatoryAddress != address(0));\r\n        signatoryAddress = _signatoryAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice          Function to verify withdraw parameters and if signatory signed message\r\n     * @param           signedMessage is the message to verify\r\n     * @param           beneficiary is the address of user for who we signed message\r\n     * @param           token is the address of the token being withdrawn\r\n     * @param           amount is the amount of tokens user is attempting to withdraw\r\n     */\r\n    function verifyWithdraw(\r\n        bytes memory signedMessage,\r\n        address token,\r\n        uint256 amount,\r\n        address beneficiary,\r\n        uint256 nonce\r\n    )\r\n    external\r\n    view\r\n    returns (bool)\r\n    {\r\n        address messageSigner = recoverSignature(signedMessage, beneficiary, token, amount, nonce);\r\n        return messageSigner == signatoryAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice          Function to can check who signed the message\r\n     * @param           signedMessage is the message to verify\r\n     * @param           beneficiary is the address of user for who we signed message\r\n     * @param           token is the address of the token being withdrawn\r\n     * @param           amount is the amount of tokens user is attempting to withdraw\r\n     */\r\n    function recoverSignature(\r\n        bytes memory signedMessage,\r\n        address beneficiary,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 nonce\r\n    )\r\n    public\r\n    pure\r\n    returns (address)\r\n    {\r\n        // Generate hash\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                keccak256(abi.encodePacked('bytes binding user withdrawal')),\r\n                keccak256(abi.encodePacked(beneficiary, token, amount, nonce))\r\n            )\r\n        );\r\n\r\n        // Recover signer message from signature\r\n        return recoverHash(hash,signedMessage,0);\r\n    }\r\n\r\n    /**\r\n     * @notice          Generalized recover sig for hash\r\n     * @dev             Built for easily integrating onwards with new contracts,\r\n     *                  since the message can be hashed on the another contract also.\r\n     * @param           hash is hash generated by encoding and hashing data\r\n     * @param           signature is the signature which should be verified.\r\n     */\r\n    function recoverSigFromHash(bytes32 hash, bytes memory signature)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        address signer = recoverHash(hash, signature, 0);\r\n        return signer == signatoryAddress;\r\n    }\r\n\r\n\r\n    function recoverHash(\r\n        bytes32 hash,\r\n        bytes memory sig,\r\n        uint idx\r\n    )\r\n    public\r\n    pure\r\n    returns (address)\r\n    {\r\n        // same as recoverHash in utils/sign.js\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        require (sig.length >= 65+idx, 'bad signature length');\r\n        idx += 32;\r\n        bytes32 r;\r\n        assembly\r\n        {\r\n            r := mload(add(sig, idx))\r\n        }\r\n\r\n        idx += 32;\r\n        bytes32 s;\r\n        assembly\r\n        {\r\n            s := mload(add(sig, idx))\r\n        }\r\n\r\n        idx += 1;\r\n        uint8 v;\r\n        assembly\r\n        {\r\n            v := mload(add(sig, idx))\r\n        }\r\n        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\r\n            v -= 32;\r\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; // 32 is the number of bytes in the following hash\r\n            hash = keccak256(abi.encodePacked(prefix, hash));\r\n        }\r\n        if (v <= 1) v += 27;\r\n        require(v==27 || v==28,'bad sig v');\r\n        //https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol#L57\r\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'bad sig s');\r\n        return ecrecover(hash, v, r, s);\r\n\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"name\":\"chainportCongress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signatoryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chainportCongress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_maintainersRegistry\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maintainersRegistry\",\"outputs\":[{\"internalType\":\"contract IMaintainersRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"recoverHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigFromHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signedMessage\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"recoverSignature\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_maintainersRegistry\",\"type\":\"address\"}],\"name\":\"setMaintainersRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signatoryAddress\",\"type\":\"address\"}],\"name\":\"setSignatoryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signatoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signedMessage\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"verifyWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Validator","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://d1ff62374ea9527a98434e9cd08ba6c08824d87d7c1f8f98957119a36374e4c2"}]}