{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/connectors/compound.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\ninterface CTokenInterface {\\n    function mint(uint mintAmount) external returns (uint);\\n    function redeem(uint redeemTokens) external returns (uint);\\n    function borrow(uint borrowAmount) external returns (uint);\\n    function repayBorrow(uint repayAmount) external returns (uint);\\n\\n    function borrowBalanceCurrent(address account) external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\n    function exchangeRateCurrent() external returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n}\\n\\ninterface CETHInterface {\\n    function mint() external payable;\\n    function repayBorrow() external payable;\\n}\\n\\ninterface TokenInterface {\\n    function allowance(address, address) external view returns (uint);\\n    function balanceOf(address) external view returns (uint);\\n    function approve(address, uint) external;\\n    function transfer(address, uint) external returns (bool);\\n    function transferFrom(address, address, uint) external returns (bool);\\n}\\n\\ninterface ComptrollerInterface {\\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\\n    function exitMarket(address cTokenAddress) external returns (uint);\\n}\\n\\ninterface InstaMapping {\\n    function cTokenMapping(address) external view returns (address);\\n}\\n\\ncontract DSMath {\\n\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, \\\"math-not-safe\\\");\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"math-not-safe\\\");\\n    }\\n\\n    uint constant WAD = 10 ** 18;\\n\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n}\\n\\n\\ncontract Helpers is DSMath {\\n    /**\\n     * @dev Return ethereum address\\n     */\\n    function getAddressETH() internal pure returns (address) {\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\\n    }\\n\\n    function getAddressWETH() internal pure returns (address) {\\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\\n    }\\n\\n    function isETH(address token) internal pure returns(bool) {\\n        return token == getAddressETH() || token == getAddressWETH();\\n    }\\n}\\n\\n\\ncontract CompoundHelpers is Helpers {\\n    /**\\n     * @dev Return Compound Comptroller Address\\n     */\\n    function getComptrollerAddress() internal pure returns (address) {\\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B; // main\\n    }\\n\\n    /**\\n     * @dev Return InstaDApp Mapping Addresses\\n     */\\n    function getMappingAddr() internal pure returns (address) {\\n        return 0x309eFfce30436C50a872fd9d2B431D7a77341f4C; // InstaPoolCompoundMapping Address\\n    }\\n\\n\\n    /**\\n     * @dev enter compound market\\n     */\\n    function enterMarket(address cToken) internal {\\n        address[] memory cTokens = new address[](1);\\n        cTokens[0] = cToken;\\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\\n        troller.enterMarkets(cTokens);\\n    }\\n}\\n\\n\\ncontract BasicResolver is CompoundHelpers {\\n    event LogDeposit(address indexed token, uint256 tokenAmt);\\n    event LogWithdraw(address indexed token);\\n    event LogBorrow(address indexed token, uint256 tokenAmt);\\n    event LogPayback(address indexed token);\\n\\n    /**\\n     * @dev Deposit ETH/ERC20_Token.\\n     * @param token token address to deposit.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\\n     * @param amt token amount to deposit.\\n    */\\n    function deposit(address token, uint amt) external payable{\\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\\n        uint _amt = amt;\\n        enterMarket(cToken);\\n        if (isETH(token)) {\\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\\n            CETHInterface(cToken).mint{value: _amt}();\\n        } else {\\n            TokenInterface tokenContract = TokenInterface(token);\\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\\n            tokenContract.approve(cToken, _amt);\\n            require(CTokenInterface(cToken).mint(_amt) == 0, \\\"minting-failed\\\");\\n        }\\n\\n        emit LogDeposit(token, _amt);\\n    }\\n\\n    /**\\n     * @dev Withdraw ETH/ERC20_Token.\\n     * @param token token address to withdraw.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\\n     * @param amt token amount to withdraw.\\n    */\\n    function withdraw(address token, uint amt) external {\\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\\n        if (amt == uint(-1)) {\\n            TokenInterface tokenContract = TokenInterface(token);\\n            require(cTokenContract.redeem(cTokenContract.balanceOf(address(this))) == 0, \\\"full-withdraw-failed\\\");\\n        } else {\\n            require(cTokenContract.redeemUnderlying(amt) == 0, \\\"withdraw-failed\\\");\\n        }\\n\\n        emit LogWithdraw(token);\\n    }\\n\\n    /**\\n     * @dev Borrow ETH/ERC20_Token.\\n     * @param token token address to borrow.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\\n     * @param amt token amount to borrow.\\n    */\\n    function borrow(address token, uint amt) external {\\n        uint _amt = amt;\\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\\n        enterMarket(cToken);\\n        require(CTokenInterface(cToken).borrow(_amt) == 0, \\\"borrow-failed\\\");\\n\\n        emit LogBorrow(token, _amt);\\n    }\\n\\n    /**\\n     * @dev Payback borrowed ETH/ERC20_Token.\\n     * @param token token address to payback.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\\n     * @param amt token amount to payback.\\n    */\\n    function payback(address token, uint amt) external {\\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\\n        uint _amt = amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(address(this)) : amt;\\n\\n        if (isETH(token)) {\\n            require(address(this).balance >= _amt, \\\"not-enough-eth\\\");\\n            CETHInterface(cToken).repayBorrow{value: _amt}();\\n        } else {\\n            TokenInterface tokenContract = TokenInterface(token);\\n            require(tokenContract.balanceOf(address(this)) >= _amt, \\\"not-enough-token\\\");\\n            tokenContract.approve(cToken, _amt);\\n            require(cTokenContract.repayBorrow(_amt) == 0, \\\"repay-failed.\\\");\\n        }\\n\\n        emit LogPayback(token);\\n    }\\n}\\n\\ncontract MarketsResolver is BasicResolver {\\n    /**\\n     * @dev enter compound market\\n     */\\n    function enterMarkets(address[] calldata cTokens) external {\\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\\n        troller.enterMarkets(cTokens);\\n    }\\n\\n    /**\\n     * @dev enter compound market\\n     */\\n    function exitMarkets(address cToken) external {\\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\\n        troller.exitMarket(cToken);\\n    }\\n}\\n\\n\\ncontract ConnectCompound is MarketsResolver {\\n    string public name = \\\"Compound-v1.0\\\";\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"}],\"name\":\"LogBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LogPayback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"cTokens\",\"type\":\"address[]\"}],\"name\":\"enterMarkets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"exitMarkets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"payback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ConnectCompound","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}