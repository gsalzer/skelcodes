{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.7.4;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface Token {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\nlibrary SafeMathLib {\r\n  function times(uint a, uint b) public pure returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b, 'Overflow detected');\r\n    return c;\r\n  }\r\n\r\n  function minus(uint a, uint b) public pure returns (uint) {\r\n    require(b <= a, 'Underflow detected');\r\n    return a - b;\r\n  }\r\n\r\n  function plus(uint a, uint b) public pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c>=a && c>=b, 'Overflow detected');\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\n// This contract is inspired by the harberger tax idea, it rewards people with FVT for burning their liquidity provider\r\n// tokens.\r\ncontract LiquidityMining {\r\n    using SafeMathLib for uint;\r\n\r\n    // this represents a single recipient of token rewards on a fixed schedule that does not depend on deposit or burn rate\r\n    // it specifies an id (key to a map below) an marker for the last time it was updated, a deposit (of LP tokens) and a\r\n    // burn rate of those LP tokens per block, and finally, the owner of the slot, who will receive the rewards\r\n    struct Slot {\r\n        uint id;\r\n        uint lastUpdatedBlock;\r\n        uint deposit;\r\n        uint burnRate;\r\n        address owner;\r\n    }\r\n\r\n    // privileged key that can change key parameters, will change to dao later\r\n    address public management;\r\n\r\n    // the token that the rewards are made in\r\n    Token public rewardToken;\r\n\r\n    // the liquidity provider (LP) token\r\n    Token public liquidityToken;\r\n\r\n    bool public paused = false;\r\n    uint public pausedBlock = 0;\r\n\r\n    // maximum number of slots, changeable by management key\r\n    uint public maxStakers = 0;\r\n\r\n    // current number of stakers\r\n    uint public numStakers = 0;\r\n\r\n    // minimum deposit allowable to claim a slot\r\n    uint public minimumDeposit = 0;\r\n\r\n    // maximum deposit allowable (used to limit risk)\r\n    uint public maximumDeposit = 1000 ether;\r\n\r\n    // minimum burn rate allowable to claim a slot\r\n    uint public minimumBurnRate = 0;\r\n\r\n    // total liquidity tokens staked\r\n    uint public totalStaked = 0;\r\n\r\n    // total rewards distributed\r\n    uint public totalRewards = 0;\r\n\r\n    // total LP tokens burned\r\n    uint public totalBurned = 0;\r\n\r\n    // start block used to compute rewards\r\n    uint public pulseStartBlock;\r\n\r\n    // the length of a single pulse of rewards, in blocks\r\n    uint public pulseWavelengthBlocks = 0;\r\n\r\n    // the amount of the highest per-block reward, in FVT\r\n    uint public pulseAmplitudeFVT = 0;\r\n\r\n    // computed constants for deferred computation\r\n    uint public pulseIntegral = 0;\r\n    uint public pulseConstant = 0;\r\n\r\n    // map of slot ids to slots\r\n    mapping (uint => Slot) public slots;\r\n\r\n    // map of addresses to amount staked\r\n    mapping (address => uint) public totalStakedFor;\r\n\r\n    // map of total rewards by address\r\n    mapping (address => uint) public totalRewardsFor;\r\n\r\n    // map of rewards for session slotId -> rewardsForThisSession\r\n    mapping (uint => uint) public rewardsForSession;\r\n\r\n    // map of total burned by address\r\n    mapping (address => uint) public totalBurnedFor;\r\n\r\n    event ManagementUpdated(address oldMgmt, address newMgmt);\r\n    event ContractPaused();\r\n    event ContractUnpaused();\r\n    event WavelengthUpdated(uint oldWavelength, uint newWavelength);\r\n    event AmplitudeUpdated(uint oldAmplitude, uint newAmplitude);\r\n    event MaxStakersUpdated(uint oldMaxStakers, uint newMaxStakers);\r\n    event MinDepositUpdated(uint oldMinDeposit, uint newMinDeposit);\r\n    event MaxDepositUpdated(uint oldMaxDeposit, uint newMaxDeposit);\r\n    event MinBurnRateUpdated(uint oldMinBurnRate, uint newMinBurnRate);\r\n    event SlotChangedHands(uint slotId, uint deposit, uint burnRate, address owner);\r\n\r\n    modifier managementOnly() {\r\n        require (msg.sender == management, 'Only management may call this');\r\n        _;\r\n    }\r\n\r\n    constructor(address rewardTokenAddr, address liquidityTokenAddr, address mgmt, uint pulseLengthBlocks, uint pulseAmplitude, uint mxStkrs) {\r\n        rewardToken = Token(rewardTokenAddr);\r\n        liquidityToken = Token(liquidityTokenAddr);\r\n        management = mgmt;\r\n        pulseStartBlock = block.number;\r\n        pulseWavelengthBlocks = pulseLengthBlocks;\r\n        pulseAmplitudeFVT = pulseAmplitude;\r\n        pulseConstant = pulseAmplitudeFVT / pulseWavelengthBlocks.times(pulseWavelengthBlocks);\r\n        pulseIntegral = pulseSum(pulseWavelengthBlocks);\r\n        maxStakers = mxStkrs;\r\n    }\r\n\r\n    // only management can reset management key\r\n    function setManagement(address newMgmt) public managementOnly {\r\n        address oldMgmt = management;\r\n        management = newMgmt;\r\n        emit ManagementUpdated(oldMgmt, newMgmt);\r\n    }\r\n\r\n    function pauseContract() public managementOnly {\r\n        require(paused == false, 'Already paused');\r\n        paused = true;\r\n        pausedBlock = block.number;\r\n        emit ContractPaused();\r\n    }\r\n\r\n    function unpauseContract() public managementOnly {\r\n        require(paused == true, 'Already unpaused');\r\n        require(numStakers == 0, 'Must kick everyone out before unpausing');\r\n        paused = false;\r\n        pausedBlock = 0;\r\n        emit ContractUnpaused();\r\n    }\r\n\r\n    // change the number of slots, should be done with care\r\n    function setMaxStakers(uint newMaxStakers) public managementOnly {\r\n        uint oldMaxStakers = maxStakers;\r\n        maxStakers = newMaxStakers;\r\n        emit MaxStakersUpdated(oldMaxStakers, maxStakers);\r\n    }\r\n\r\n    // change the minimum deposit to acquire a slot\r\n    function setMinDeposit(uint newMinDeposit) public managementOnly {\r\n        uint oldMinDeposit = minimumDeposit;\r\n        minimumDeposit = newMinDeposit;\r\n        emit MinDepositUpdated(oldMinDeposit, newMinDeposit);\r\n    }\r\n\r\n    // change the maximum deposit\r\n    function setMaxDeposit(uint newMaxDeposit) public managementOnly {\r\n        uint oldMaxDeposit = maximumDeposit;\r\n        maximumDeposit = newMaxDeposit;\r\n        emit MaxDepositUpdated(oldMaxDeposit, newMaxDeposit);\r\n    }\r\n\r\n    // change the minimum burn rate to acquire a slot\r\n    function setMinBurnRate(uint newMinBurnRate) public managementOnly {\r\n        uint oldMinBurnRate = minimumBurnRate;\r\n        minimumBurnRate = newMinBurnRate;\r\n        emit MinBurnRateUpdated(oldMinBurnRate, newMinBurnRate);\r\n    }\r\n\r\n    // change the length of a pulse, should be done with care, probably should update all slots simultaneously\r\n    function setPulseWavelength(uint newWavelength) public managementOnly {\r\n        uint oldWavelength = pulseWavelengthBlocks;\r\n        pulseWavelengthBlocks = newWavelength;\r\n        pulseConstant = pulseAmplitudeFVT / pulseWavelengthBlocks.times(pulseWavelengthBlocks);\r\n        pulseIntegral = pulseSum(newWavelength);\r\n        emit WavelengthUpdated(oldWavelength, newWavelength);\r\n    }\r\n\r\n    // change the maximum height of the reward curve\r\n    function setPulseAmplitude(uint newAmplitude) public managementOnly {\r\n        uint oldAmplitude = pulseAmplitudeFVT;\r\n        pulseAmplitudeFVT = newAmplitude;\r\n        pulseConstant = pulseAmplitudeFVT / pulseWavelengthBlocks.times(pulseWavelengthBlocks);\r\n        pulseIntegral = pulseSum(pulseWavelengthBlocks);\r\n        emit AmplitudeUpdated(oldAmplitude, newAmplitude);\r\n    }\r\n\r\n    // compute the sum of the rewards per pulse\r\n    function pulseSum(uint wavelength) public view returns (uint) {\r\n        // sum of squares formula\r\n        return pulseConstant.times(wavelength.times(wavelength.plus(1))).times(wavelength.times(2).plus(1)) / 6;\r\n    }\r\n\r\n    // compute the undistributed rewards for a slot\r\n    function getRewards(uint slotId) public view returns (uint) {\r\n        Slot storage slot = slots[slotId];\r\n        if (slot.owner == address(0)) {\r\n            return 0;\r\n        }\r\n        uint referenceBlock = block.number;\r\n        if (paused) {\r\n            referenceBlock = pausedBlock;\r\n        }\r\n        // three parts, incomplete beginning, incomplete end and complete middle\r\n        uint rewards;\r\n\r\n        // complete middle\r\n        // trim off overhang on both ends\r\n        uint startPhase = slot.lastUpdatedBlock.minus(pulseStartBlock) % pulseWavelengthBlocks;\r\n        uint startOverhang = pulseWavelengthBlocks.minus(startPhase);\r\n        uint startSum = pulseSum(startOverhang);\r\n\r\n        uint blocksDiffTotal = referenceBlock.minus(slot.lastUpdatedBlock);\r\n\r\n        uint endPhase = referenceBlock.minus(pulseStartBlock) % pulseWavelengthBlocks;\r\n        uint endingBlocks = pulseWavelengthBlocks.minus(endPhase);\r\n        uint leftoverSum = pulseSum(endingBlocks);\r\n\r\n        // if we haven't made it to phase 0 yet\r\n        if (blocksDiffTotal < startOverhang) {\r\n            rewards = startSum.minus(leftoverSum);\r\n        } else {\r\n            uint blocksDiff = blocksDiffTotal.minus(endPhase).minus(startOverhang);\r\n            uint wavelengths = blocksDiff / pulseWavelengthBlocks;\r\n            rewards = wavelengths.times(pulseIntegral);\r\n\r\n            // incomplete beginning of reward cycle, end of pulse\r\n            if (startPhase > 0) {\r\n                rewards = rewards.plus(pulseSum(startOverhang));\r\n            }\r\n\r\n            // incomplete ending of reward cycle, beginning of pulse\r\n            if (endPhase > 0) {\r\n                rewards = rewards.plus(pulseIntegral.minus(leftoverSum));\r\n            }\r\n        }\r\n\r\n        return rewards;\r\n    }\r\n\r\n    // compute the unapplied burn to the deposit\r\n    function getBurn(uint slotId) public view returns (uint) {\r\n        Slot storage slot = slots[slotId];\r\n        uint referenceBlock = block.number;\r\n        if (paused) {\r\n            referenceBlock = pausedBlock;\r\n        }\r\n        uint burn = slot.burnRate * (referenceBlock - slot.lastUpdatedBlock);\r\n        if (burn > slot.deposit) {\r\n            burn = slot.deposit;\r\n        }\r\n        return burn;\r\n    }\r\n\r\n    // this must be idempotent, it syncs both the rewards and the deposit burn atomically, and updates lastUpdatedBlock\r\n    function updateSlot(uint slotId) public {\r\n        Slot storage slot = slots[slotId];\r\n\r\n        // burn and rewards always have to update together, since they both depend on lastUpdatedBlock\r\n        uint burn = getBurn(slotId);\r\n        uint rewards = getRewards(slotId);\r\n\r\n        // update this first to make burn and reward zero in the case of re-entrance\r\n        slot.lastUpdatedBlock = block.number;\r\n\r\n        if (burn > 0) {\r\n            // adjust deposit first\r\n            slot.deposit = slot.deposit.minus(burn);\r\n\r\n            // bookkeeping\r\n            totalBurned = totalBurned.plus(burn);\r\n            totalBurnedFor[slot.owner] = totalBurnedFor[slot.owner].plus(burn);\r\n\r\n            // burn them!\r\n            liquidityToken.transfer(address(0), burn);\r\n        }\r\n\r\n        if (rewards > 0) {\r\n            // bookkeeping\r\n            totalRewards = totalRewards.plus(rewards);\r\n            totalRewardsFor[slot.owner] = totalStakedFor[slot.owner].plus(rewards);\r\n            rewardsForSession[slotId] = rewardsForSession[slotId].plus(rewards);\r\n\r\n            rewardToken.transfer(slot.owner, rewards);\r\n        }\r\n    }\r\n\r\n    // most important function for users, allows them to start receiving rewards\r\n    function claimSlot(uint slotId, uint newBurnRate, uint deposit) external {\r\n        require(slotId > 0, 'Slot id must be positive');\r\n        require(slotId <= maxStakers, 'Slot id out of range');\r\n        require(newBurnRate >= minimumBurnRate, 'Burn rate must meet or exceed minimum');\r\n        require(deposit >= minimumDeposit, 'Deposit must meet or exceed minimum');\r\n        require(deposit <= maximumDeposit, 'Deposit must not exceed maximum');\r\n        require(paused == false, 'Must be unpaused');\r\n\r\n        Slot storage slot = slots[slotId];\r\n\r\n        // count the stakers\r\n        if (slot.owner == address(0)) {\r\n            // assign id since this may be the first time\r\n            slot.id = slotId;\r\n            numStakers = numStakers.plus(1);\r\n            slot.lastUpdatedBlock = block.number;\r\n        } else {\r\n            updateSlot(slotId);\r\n\r\n            bool betterDeal = newBurnRate > slot.burnRate && (deposit > slot.deposit || deposit == maximumDeposit);\r\n            require(betterDeal || slot.deposit == 0, 'You must outbid the current owner');\r\n\r\n            // bookkeeping\r\n            totalStaked = totalStaked.minus(slot.deposit);\r\n            totalStakedFor[slot.owner] = totalStakedFor[slot.owner].minus(slot.deposit);\r\n\r\n            // withdraw current owner\r\n            withdrawFromSlotInternal(slotId);\r\n        }\r\n\r\n        // set new owner, burn rate\r\n        slot.owner = msg.sender;\r\n        slot.burnRate = newBurnRate;\r\n        slot.deposit = deposit;\r\n\r\n        // bookkeeping\r\n        totalStaked = totalStaked.plus(deposit);\r\n        totalStakedFor[msg.sender] = totalStakedFor[msg.sender].plus(deposit);\r\n\r\n        // transfer the tokens!\r\n        if (deposit > 0) {\r\n            liquidityToken.transferFrom(msg.sender, address(this), deposit);\r\n        }\r\n\r\n        emit SlotChangedHands(slotId, deposit, newBurnRate, msg.sender);\r\n    }\r\n\r\n    // separates user from slot, if either voluntary or delinquent\r\n    function withdrawFromSlot(uint slotId) external {\r\n        Slot storage slot = slots[slotId];\r\n        bool withdrawable = slot.owner == msg.sender || slot.deposit == 0;\r\n        require(withdrawable || paused, 'Only owner can call this unless user is delinquent or contract is paused');\r\n        updateSlot(slotId);\r\n        withdrawFromSlotInternal(slotId);\r\n\r\n        // zero out owner and burn rate\r\n        slot.owner = address(0);\r\n        slot.burnRate = 0;\r\n        numStakers = numStakers.minus(1);\r\n        emit SlotChangedHands(slotId, 0, 0, address(0));\r\n    }\r\n\r\n    // internal function for withdrawing from a slot\r\n    function withdrawFromSlotInternal(uint slotId) internal {\r\n        Slot storage slot = slots[slotId];\r\n\r\n        rewardsForSession[slotId] = 0;\r\n\r\n        // if there's any deposit left,\r\n        if (slot.deposit > 0) {\r\n            uint deposit = slot.deposit;\r\n            slot.deposit = 0;\r\n            liquidityToken.transfer(slot.owner, deposit);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pulseLengthBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseAmplitude\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mxStkrs\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmplitude\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmplitude\",\"type\":\"uint256\"}],\"name\":\"AmplitudeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldMgmt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"ManagementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxDeposit\",\"type\":\"uint256\"}],\"name\":\"MaxDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxStakers\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxStakers\",\"type\":\"uint256\"}],\"name\":\"MaxStakersUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinBurnRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinBurnRate\",\"type\":\"uint256\"}],\"name\":\"MinBurnRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinDeposit\",\"type\":\"uint256\"}],\"name\":\"MinDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SlotChangedHands\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldWavelength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newWavelength\",\"type\":\"uint256\"}],\"name\":\"WavelengthUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBurnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"claimSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"getBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityToken\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumBurnRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausedBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pulseAmplitudeFVT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pulseConstant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pulseIntegral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pulseStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wavelength\",\"type\":\"uint256\"}],\"name\":\"pulseSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pulseWavelengthBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsForSession\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxDeposit\",\"type\":\"uint256\"}],\"name\":\"setMaxDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxStakers\",\"type\":\"uint256\"}],\"name\":\"setMaxStakers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinBurnRate\",\"type\":\"uint256\"}],\"name\":\"setMinBurnRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinDeposit\",\"type\":\"uint256\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmplitude\",\"type\":\"uint256\"}],\"name\":\"setPulseAmplitude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWavelength\",\"type\":\"uint256\"}],\"name\":\"setPulseWavelength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"slots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdatedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBurnedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalRewardsFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalStakedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"updateSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"withdrawFromSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidityMining","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000045080a6531d671ddff20db42f93792a489685e3200000000000000000000000075001b3ffe0f77864c7dc64c55e1e22b205e4a07000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b0000000000000000000000000000000000000000000000000000000000030d400000000000000000000000000000000000000000000000000853a0d2313c00000000000000000000000000000000000000000000000000000000000000000032","EVMVersion":"Default","Library":"SafeMathLib:82d7630c5eb722557de6d76575c9a7b8de718500","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0e9f65c8d936fc2b834574ae402cd7eb1509fbae6a75ebc31fec22df1fc2e016"}]}