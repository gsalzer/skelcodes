{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.3;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Library used to query support of an interface declared via {IERC165}.\r\n *\r\n * Note that these functions return the actual result of the query: they do not\r\n * `revert` if an interface is not supported. It is up to the caller to decide\r\n * what to do in these cases.\r\n */\r\nlibrary ERC165Checker {\r\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\r\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports the {IERC165} interface,\r\n     */\r\n    function supportsERC165(address account) internal view returns (bool) {\r\n        // Any contract that implements ERC165 must explicitly indicate support of\r\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\r\n        return\r\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\r\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports the interface defined by\r\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(address account, bytes4 interfaceId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // query support of both ERC165 as per the spec and support of _interfaceId\r\n        return\r\n            supportsERC165(account) &&\r\n            _supportsERC165Interface(account, interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a boolean array where each value corresponds to the\r\n     * interfaces passed in and whether they're supported or not. This allows\r\n     * you to batch check interfaces for a contract where your expectation\r\n     * is that some interfaces may not be supported.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function getSupportedInterfaces(\r\n        address account,\r\n        bytes4[] memory interfaceIds\r\n    ) internal view returns (bool[] memory) {\r\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\r\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\r\n\r\n        // query support of ERC165 itself\r\n        if (supportsERC165(account)) {\r\n            // query support of each interface in interfaceIds\r\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\r\n                interfaceIdsSupported[i] = _supportsERC165Interface(\r\n                    account,\r\n                    interfaceIds[i]\r\n                );\r\n            }\r\n        }\r\n\r\n        return interfaceIdsSupported;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports all the interfaces defined in\r\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * Batch-querying can lead to gas savings by skipping repeated checks for\r\n     * {IERC165} support.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsAllInterfaces(\r\n        address account,\r\n        bytes4[] memory interfaceIds\r\n    ) internal view returns (bool) {\r\n        // query support of ERC165 itself\r\n        if (!supportsERC165(account)) {\r\n            return false;\r\n        }\r\n\r\n        // query support of each interface in _interfaceIds\r\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\r\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // all interfaces supported\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface, does not check ERC165 support\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return true if the contract at account indicates support of the interface with\r\n     * identifier interfaceId, false otherwise\r\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\r\n     * the behavior of this method is undefined. This precondition can be checked\r\n     * with {supportsERC165}.\r\n     * Interface identification is specified in ERC-165.\r\n     */\r\n    function _supportsERC165Interface(address account, bytes4 interfaceId)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes memory encodedParams =\r\n            abi.encodeWithSelector(\r\n                IERC165(account).supportsInterface.selector,\r\n                interfaceId\r\n            );\r\n        (bool success, bytes memory result) =\r\n            account.staticcall{gas: 30000}(encodedParams);\r\n        if (result.length < 32) return false;\r\n        return success && abi.decode(result, (bool));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\nabstract contract MinterReceiver is ERC165 {\r\n    function onSharesMinted(\r\n        uint40 stakeId,\r\n        address supplier,\r\n        uint72 stakedHearts,\r\n        uint72 stakeShares\r\n    ) external virtual;\r\n\r\n    function onEarningsMinted(uint40 stakeId, uint72 heartsEarned)\r\n        external\r\n        virtual;\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(MinterReceiver).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\ninterface IHEX {\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function currentDay() external view returns (uint256);\r\n\r\n    function stakeCount(address stakerAddr) external view returns (uint256);\r\n\r\n    function stakeEnd(uint256 stakeIndex, uint40 stakeIdParam) external;\r\n\r\n    function stakeLists(address, uint256)\r\n        external\r\n        view\r\n        returns (\r\n            uint40 stakeId,\r\n            uint72 stakedHearts,\r\n            uint72 stakeShares,\r\n            uint16 lockedDay,\r\n            uint16 stakedDays,\r\n            uint16 unlockedDay,\r\n            bool isAutoStake\r\n        );\r\n\r\n    function stakeStart(uint256 newStakedHearts, uint256 newStakedDays)\r\n        external;\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract ShareMinter {\r\n    IHEX public hexContract;\r\n\r\n    struct Stake {\r\n        uint24 unlockDay;\r\n        MinterReceiver receiver;\r\n    }\r\n    mapping(uint40 => Stake) public stakes;\r\n\r\n    event MintShares(uint40 stakeId, MinterReceiver receiver, uint72 shares);\r\n    event MintEarnings(uint40 stakeId, MinterReceiver receiver, uint72 hearts);\r\n\r\n    uint256 private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, \"LOCKED\");\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    constructor(IHEX _hex) {\r\n        hexContract = _hex;\r\n    }\r\n\r\n    function mintShares(\r\n        MinterReceiver receiver,\r\n        address supplier,\r\n        uint256 newStakedHearts,\r\n        uint256 newStakedDays\r\n    ) external lock {\r\n        require(\r\n            ERC165Checker.supportsInterface(\r\n                address(receiver),\r\n                type(MinterReceiver).interfaceId\r\n            ),\r\n            \"UNSUPPORTED_RECEIVER\"\r\n        );\r\n\r\n        hexContract.transferFrom(msg.sender, address(this), newStakedHearts);\r\n        hexContract.stakeStart(newStakedHearts, newStakedDays);\r\n\r\n        uint256 stakeCount = hexContract.stakeCount(address(this));\r\n        (\r\n            uint40 stakeId,\r\n            uint72 stakedHearts,\r\n            uint72 stakeShares,\r\n            uint16 lockedDay,\r\n            uint16 stakedDays,\r\n            ,\r\n\r\n        ) = hexContract.stakeLists(address(this), stakeCount - 1);\r\n        uint24 unlockDay = lockedDay + stakedDays;\r\n\r\n        Stake storage stake = stakes[stakeId];\r\n        stake.receiver = receiver;\r\n        stake.unlockDay = unlockDay;\r\n\r\n        receiver.onSharesMinted(stakeId, supplier, stakedHearts, stakeShares);\r\n\r\n        emit MintShares(stakeId, receiver, stakeShares);\r\n    }\r\n\r\n    function mintEarnings(uint256 stakeIndex, uint40 stakeId) external lock {\r\n        Stake memory stake = stakes[stakeId];\r\n        uint256 currentDay = hexContract.currentDay();\r\n        require(currentDay >= stake.unlockDay, \"STAKE_NOT_MATURE\");\r\n\r\n        uint256 prevHearts = hexContract.balanceOf(address(this));\r\n        hexContract.stakeEnd(stakeIndex, stakeId);\r\n        uint256 newHearts = hexContract.balanceOf(address(this));\r\n        uint72 heartsEarned = uint72(newHearts - prevHearts);\r\n\r\n        hexContract.transfer(address(stake.receiver), heartsEarned);\r\n        stake.receiver.onEarningsMinted(stakeId, heartsEarned);\r\n\r\n        emit MintEarnings(stakeId, stake.receiver, heartsEarned);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IHEX\",\"name\":\"_hex\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"stakeId\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"contract MinterReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint72\",\"name\":\"hearts\",\"type\":\"uint72\"}],\"name\":\"MintEarnings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"stakeId\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"contract MinterReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint72\",\"name\":\"shares\",\"type\":\"uint72\"}],\"name\":\"MintShares\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"hexContract\",\"outputs\":[{\"internalType\":\"contract IHEX\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"stakeId\",\"type\":\"uint40\"}],\"name\":\"mintEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MinterReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"supplier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newStakedHearts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newStakedDays\",\"type\":\"uint256\"}],\"name\":\"mintShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"unlockDay\",\"type\":\"uint24\"},{\"internalType\":\"contract MinterReceiver\",\"name\":\"receiver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ShareMinter","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"0000000000000000000000002b591e99afe9f32eaa6214f7b7629768c40eeb39","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f9a527b20ce826561739ffac835e7131070dde9f270bd35434a226e920ce4258"}]}