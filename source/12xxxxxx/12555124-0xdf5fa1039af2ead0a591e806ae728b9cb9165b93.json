{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/RegenesisMultisig.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Config.sol\\\";\\n\\n/// @title Regenesis Multisig contract\\n/// @author Matter Labs\\ncontract RegenesisMultisig is Ownable, Config {\\n    event CandidateAccepted(bytes32 oldRootHash, bytes32 newRootHash);\\n    event CandidateApproval(uint256 currentApproval);\\n\\n    bytes32 public oldRootHash;\\n    bytes32 public newRootHash;\\n\\n    bytes32 public candidateOldRootHash;\\n    bytes32 public candidateNewRootHash;\\n\\n    /// @dev Stores boolean flags which means the confirmations of the upgrade for each member of security council\\n    mapping(uint256 => bool) internal securityCouncilApproves;\\n    uint256 internal numberOfApprovalsFromSecurityCouncil;\\n\\n    uint256 securityCouncilThreshold;\\n\\n    constructor(uint256 threshold) Ownable(msg.sender) {\\n        securityCouncilThreshold = threshold;\\n    }\\n\\n    function submitHash(bytes32 _oldRootHash, bytes32 _newRootHash) external {\\n        // Only zkSync team can submit the hashes\\n        require(msg.sender == getMaster(), \\\"1\\\");\\n\\n        candidateOldRootHash = _oldRootHash;\\n        candidateNewRootHash = _newRootHash;\\n\\n        oldRootHash = bytes32(0);\\n        newRootHash = bytes32(0);\\n\\n        for (uint256 i = 0; i < SECURITY_COUNCIL_MEMBERS_NUMBER; ++i) {\\n            securityCouncilApproves[i] = false;\\n        }\\n        numberOfApprovalsFromSecurityCouncil = 0;\\n    }\\n\\n    function approveHash(bytes32 _oldRootHash, bytes32 _newRootHash) external {\\n        require(_oldRootHash == candidateOldRootHash, \\\"2\\\");\\n        require(_newRootHash == candidateNewRootHash, \\\"3\\\");\\n\\n        address payable[SECURITY_COUNCIL_MEMBERS_NUMBER] memory SECURITY_COUNCIL_MEMBERS =\\n            [0xa2602ea835E03fb39CeD30B43d6b6EAf6aDe1769,0x9D5d6D4BaCCEDf6ECE1883456AA785dc996df607,0x002A5dc50bbB8d5808e418Aeeb9F060a2Ca17346,0x71E805aB236c945165b9Cd0bf95B9f2F0A0488c3,0x76C6cE74EAb57254E785d1DcC3f812D274bCcB11,0xFBfF3FF69D65A9103Bf4fdBf988f5271D12B3190,0xAfC2F2D803479A2AF3A72022D54cc0901a0ec0d6,0x4d1E3089042Ab3A93E03CA88B566b99Bd22438C6,0x19eD6cc20D44e5cF4Bb4894F50162F72402d8567,0x39415255619783A2E71fcF7d8f708A951d92e1b6,0x399a6a13D298CF3F41a562966C1a450136Ea52C2,0xee8AE1F1B4B1E1956C8Bda27eeBCE54Cf0bb5eaB,0xe7CCD4F3feA7df88Cf9B59B30f738ec1E049231f,0xA093284c707e207C36E3FEf9e0B6325fd9d0e33B,0x225d3822De44E58eE935440E0c0B829C4232086e];\\n        for (uint256 id = 0; id < SECURITY_COUNCIL_MEMBERS_NUMBER; ++id) {\\n            if (SECURITY_COUNCIL_MEMBERS[id] == msg.sender) {\\n                require(securityCouncilApproves[id] == false);\\n                securityCouncilApproves[id] = true;\\n                numberOfApprovalsFromSecurityCouncil++;\\n                emit CandidateApproval(numberOfApprovalsFromSecurityCouncil);\\n\\n                // It is ok to check for strict equality since the numberOfApprovalsFromSecurityCouncil\\n                // is increased by one at a time. It is better to do so not to emit the\\n                // CandidateAccepted event more than once\\n                if (numberOfApprovalsFromSecurityCouncil == securityCouncilThreshold) {\\n                    oldRootHash = candidateOldRootHash;\\n                    newRootHash = candidateNewRootHash;\\n                    emit CandidateAccepted(oldRootHash, newRootHash);\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Ownable Contract\\n/// @author Matter Labs\\ncontract Ownable {\\n    /// @dev Storage position of the masters address (keccak256('eip1967.proxy.admin') - 1)\\n    bytes32 private constant MASTER_POSITION = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice Contract constructor\\n    /// @dev Sets msg sender address as masters address\\n    /// @param masterAddress Master address\\n    constructor(address masterAddress) {\\n        setMaster(masterAddress);\\n    }\\n\\n    /// @notice Check if specified address is master\\n    /// @param _address Address to check\\n    function requireMaster(address _address) internal view {\\n        require(_address == getMaster(), \\\"1c\\\"); // oro11 - only by master\\n    }\\n\\n    /// @notice Returns contract masters address\\n    /// @return master Master's address\\n    function getMaster() public view returns (address master) {\\n        bytes32 position = MASTER_POSITION;\\n        assembly {\\n            master := sload(position)\\n        }\\n    }\\n\\n    /// @dev Sets new masters address\\n    /// @param _newMaster New master's address\\n    function setMaster(address _newMaster) internal {\\n        bytes32 position = MASTER_POSITION;\\n        assembly {\\n            sstore(position, _newMaster)\\n        }\\n    }\\n\\n    /// @notice Transfer mastership of the contract to new master\\n    /// @param _newMaster New masters address\\n    function transferMastership(address _newMaster) external {\\n        requireMaster(msg.sender);\\n        require(_newMaster != address(0), \\\"1d\\\"); // otp11 - new masters address can't be zero address\\n        setMaster(_newMaster);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/Config.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title zkSync configuration constants\\n/// @author Matter Labs\\ncontract Config {\\n    /// @dev ERC20 tokens and ETH withdrawals gas limit, used only for complete withdrawals\\n    uint256 internal constant WITHDRAWAL_GAS_LIMIT = 100000;\\n\\n    /// @dev NFT withdrawals gas limit, used only for complete withdrawals\\n    uint256 internal constant WITHDRAWAL_NFT_GAS_LIMIT = 300000;\\n\\n    /// @dev Bytes in one chunk\\n    uint8 internal constant CHUNK_BYTES = 10;\\n\\n    /// @dev zkSync address length\\n    uint8 internal constant ADDRESS_BYTES = 20;\\n\\n    uint8 internal constant PUBKEY_HASH_BYTES = 20;\\n\\n    /// @dev Public key bytes length\\n    uint8 internal constant PUBKEY_BYTES = 32;\\n\\n    /// @dev Ethereum signature r/s bytes length\\n    uint8 internal constant ETH_SIGN_RS_BYTES = 32;\\n\\n    /// @dev Success flag bytes length\\n    uint8 internal constant SUCCESS_FLAG_BYTES = 1;\\n\\n    /// @dev Max amount of tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\\n    uint16 internal constant MAX_AMOUNT_OF_REGISTERED_TOKENS = 1023;\\n\\n    /// @dev Max account id that could be registered in the network\\n    uint32 internal constant MAX_ACCOUNT_ID = 16777215;\\n\\n    /// @dev Expected average period of block creation\\n    uint256 internal constant BLOCK_PERIOD = 15 seconds;\\n\\n    /// @dev ETH blocks verification expectation\\n    /// @dev Blocks can be reverted if they are not verified for at least EXPECT_VERIFICATION_IN.\\n    /// @dev If set to 0 validator can revert blocks at any time.\\n    uint256 internal constant EXPECT_VERIFICATION_IN = 0 hours / BLOCK_PERIOD;\\n\\n    uint256 internal constant NOOP_BYTES = 1 * CHUNK_BYTES;\\n    uint256 internal constant DEPOSIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant MINT_NFT_BYTES = 5 * CHUNK_BYTES;\\n    uint256 internal constant TRANSFER_TO_NEW_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant PARTIAL_EXIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant TRANSFER_BYTES = 2 * CHUNK_BYTES;\\n    uint256 internal constant FORCED_EXIT_BYTES = 6 * CHUNK_BYTES;\\n    uint256 internal constant WITHDRAW_NFT_BYTES = 10 * CHUNK_BYTES;\\n\\n    /// @dev Full exit operation length\\n    uint256 internal constant FULL_EXIT_BYTES = 11 * CHUNK_BYTES;\\n\\n    /// @dev ChangePubKey operation length\\n    uint256 internal constant CHANGE_PUBKEY_BYTES = 6 * CHUNK_BYTES;\\n\\n    /// @dev Expiration delta for priority request to be satisfied (in seconds)\\n    /// @dev NOTE: Priority expiration should be > (EXPECT_VERIFICATION_IN * BLOCK_PERIOD)\\n    /// @dev otherwise incorrect block with priority op could not be reverted.\\n    uint256 internal constant PRIORITY_EXPIRATION_PERIOD = 3 days;\\n\\n    /// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\\n    uint256 internal constant PRIORITY_EXPIRATION =\\n        PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD;\\n\\n    /// @dev Maximum number of priority request to clear during verifying the block\\n    /// @dev Cause deleting storage slots cost 5k gas per each slot it's unprofitable to clear too many slots\\n    /// @dev Value based on the assumption of ~750k gas cost of verifying and 5 used storage slots per PriorityOperation structure\\n    uint64 internal constant MAX_PRIORITY_REQUESTS_TO_DELETE_IN_VERIFY = 6;\\n\\n    /// @dev Reserved time for users to send full exit priority operation in case of an upgrade (in seconds)\\n    uint256 internal constant MASS_FULL_EXIT_PERIOD = 9 days;\\n\\n    /// @dev Reserved time for users to withdraw funds from full exit priority operation in case of an upgrade (in seconds)\\n    uint256 internal constant TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT = 2 days;\\n\\n    /// @dev Notice period before activation preparation status of upgrade mode (in seconds)\\n    /// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\\n    uint256 internal constant UPGRADE_NOTICE_PERIOD =\\n        MASS_FULL_EXIT_PERIOD+PRIORITY_EXPIRATION_PERIOD+TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT;\\n\\n    /// @dev Timestamp - seconds since unix epoch\\n    uint256 internal constant COMMIT_TIMESTAMP_NOT_OLDER = 24 hours;\\n\\n    /// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\\n    /// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\\n    uint256 internal constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 15 minutes;\\n\\n    /// @dev Bit mask to apply for verifier public input before verifying.\\n    uint256 internal constant INPUT_MASK = 14474011154664524427946373126085988481658748083205070504932198000989141204991;\\n\\n    /// @dev Auth fact reset timelock.\\n    uint256 internal constant AUTH_FACT_RESET_TIMELOCK = 1 days;\\n\\n    /// @dev Max deposit of ERC20 token that is possible to deposit\\n    uint128 internal constant MAX_DEPOSIT_AMOUNT = 20282409603651670423947251286015;\\n\\n    uint32 internal constant SPECIAL_ACCOUNT_ID = 16777215;\\n    address internal constant SPECIAL_ACCOUNT_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n    uint32 internal constant SPECIAL_NFT_TOKEN_ID = 2147483646;\\n\\n    uint32 internal constant MAX_FUNGIBLE_TOKEN_ID = 65535;\\n\\n    uint256 internal constant SECURITY_COUNCIL_MEMBERS_NUMBER = 15;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"oldRootHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newRootHash\",\"type\":\"bytes32\"}],\"name\":\"CandidateAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentApproval\",\"type\":\"uint256\"}],\"name\":\"CandidateApproval\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_oldRootHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_newRootHash\",\"type\":\"bytes32\"}],\"name\":\"approveHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"candidateNewRootHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"candidateOldRootHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"master\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newRootHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldRootHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_oldRootHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_newRootHash\",\"type\":\"bytes32\"}],\"name\":\"submitHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMaster\",\"type\":\"address\"}],\"name\":\"transferMastership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RegenesisMultisig","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000008","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}