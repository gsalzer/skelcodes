{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/options/OilerRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IOilerOptionBaseFactory} from \\\"./interfaces/IOilerOptionBaseFactory.sol\\\";\\nimport {IOilerOptionBase} from \\\"./interfaces/IOilerOptionBase.sol\\\";\\nimport {IOilerOptionsRouter} from \\\"./interfaces/IOilerOptionsRouter.sol\\\";\\n\\ncontract OilerRegistry is Ownable {\\n    uint256 public constant PUT = 1;\\n    uint256 public constant CALL = 0;\\n\\n    /**\\n     * @dev Active options store, once the option expires the mapping keys are replaced.\\n     * option type => option contract.\\n     */\\n    mapping(bytes32 => address[2]) public activeOptions;\\n\\n    /**\\n     * @dev Archived options store.\\n     * Once an option expires and is replaced it's pushed to an array under it's type key.\\n     * option type => option contracts.\\n     */\\n    mapping(bytes32 => address[]) public archivedOptions;\\n\\n    /**\\n     * @dev Stores supported types of options.\\n     */\\n    bytes32[] public optionTypes; // Array of all option types ever registered\\n\\n    /**\\n     * @dev Indicates who's the factory of specific option types.\\n     * option type => factory.\\n     */\\n    mapping(bytes32 => address) public factories;\\n\\n    IOilerOptionsRouter public optionsRouter;\\n\\n    constructor(address _owner) Ownable() {\\n        Ownable.transferOwnership(_owner);\\n    }\\n\\n    function registerOption(address _optionAddress, string memory _optionType) external {\\n        require(address(optionsRouter) != address(0), \\\"OilerRegistry.registerOption: router not set\\\");\\n        bytes32 optionTypeHash = keccak256(abi.encodePacked(_optionType));\\n        // Check if caller is factory registered for current option.\\n        require(factories[optionTypeHash] == msg.sender, \\\"OilerRegistry.registerOption: not a factory.\\\"); // Ensure that contract under address is an option.\\n        require(\\n            IOilerOptionBaseFactory(msg.sender).isClone(_optionAddress),\\n            \\\"OilerRegistry.registerOption: invalid option contract.\\\"\\n        );\\n        uint256 optionDirection = IOilerOptionBase(_optionAddress).put() ? PUT : CALL;\\n        // Ensure option is not being registered again.\\n        require(\\n            _optionAddress != activeOptions[optionTypeHash][optionDirection],\\n            \\\"OilerRegistry.registerOption: option already registered\\\"\\n        );\\n        // Ensure currently set option is expired.\\n        if (activeOptions[optionTypeHash][optionDirection] != address(0)) {\\n            require(\\n                !IOilerOptionBase(activeOptions[optionTypeHash][optionDirection]).isActive(),\\n                \\\"OilerRegistry.registerOption: option still active\\\"\\n            );\\n        }\\n        archivedOptions[optionTypeHash].push(activeOptions[optionTypeHash][optionDirection]);\\n        activeOptions[optionTypeHash][optionDirection] = _optionAddress;\\n        optionsRouter.setUnlimitedApprovals(IOilerOptionBase(_optionAddress));\\n    }\\n\\n    function setOptionsTypeFactory(string memory _optionType, address _factory) external onlyOwner {\\n        bytes32 optionTypeHash = keccak256(abi.encodePacked(_optionType));\\n        require(_factory != address(0), \\\"Cannot set factory to 0x0\\\");\\n        require(factories[optionTypeHash] != address(0), \\\"OptionType wasn't yet registered\\\");\\n        if (_factory != address(uint256(-1))) {\\n            // Send -1 if you want to remove the factory and disable this optionType\\n            require(\\n                optionTypeHash ==\\n                    keccak256(\\n                        abi.encodePacked(\\n                            IOilerOptionBase(IOilerOptionBaseFactory(_factory).optionLogicImplementation()).optionType()\\n                        )\\n                    ),\\n                \\\"The factory is for different optionType\\\"\\n            );\\n        }\\n        factories[optionTypeHash] = _factory;\\n    }\\n\\n    function registerFactory(address factory) external onlyOwner {\\n        bytes32 optionTypeHash = keccak256(\\n            abi.encodePacked(\\n                IOilerOptionBase(IOilerOptionBaseFactory(factory).optionLogicImplementation()).optionType()\\n            )\\n        );\\n        require(factories[optionTypeHash] == address(0), \\\"The factory for this OptionType was already registered\\\");\\n        factories[optionTypeHash] = factory;\\n        optionTypes.push(optionTypeHash);\\n    }\\n\\n    function setOptionsRouter(IOilerOptionsRouter _optionsRouter) external onlyOwner {\\n        optionsRouter = _optionsRouter;\\n    }\\n\\n    function getOptionTypesLength() external view returns (uint256) {\\n        return optionTypes.length;\\n    }\\n\\n    function getOptionTypeAt(uint256 _index) external view returns (bytes32) {\\n        return optionTypes[_index];\\n    }\\n\\n    function getOptionTypeFactory(string memory _optionType) external view returns (address) {\\n        return factories[keccak256(abi.encodePacked(_optionType))];\\n    }\\n\\n    function getAllArchivedOptionsOfType(bytes32 _optionType) external view returns (address[] memory) {\\n        return archivedOptions[_optionType];\\n    }\\n\\n    function getAllArchivedOptionsOfType(string memory _optionType) external view returns (address[] memory) {\\n        return archivedOptions[keccak256(abi.encodePacked(_optionType))];\\n    }\\n\\n    function checkActive(string memory _optionType) public view returns (bool, bool) {\\n        bytes32 id = keccak256(abi.encodePacked(_optionType));\\n        return checkActive(id);\\n    }\\n\\n    function checkActive(bytes32 _optionType) public view returns (bool, bool) {\\n        return (\\n            activeOptions[_optionType][CALL] != address(0)\\n                ? IOilerOptionBase(activeOptions[_optionType][CALL]).isActive()\\n                : false,\\n            activeOptions[_optionType][PUT] != address(0)\\n                ? IOilerOptionBase(activeOptions[_optionType][PUT]).isActive()\\n                : false\\n        );\\n    }\\n\\n    function getActiveOptions(bytes32 _optionType) public view returns (address[2] memory result) {\\n        (bool isCallActive, bool isPutActive) = checkActive(_optionType);\\n\\n        if (isCallActive) {\\n            result[0] = activeOptions[_optionType][0];\\n        }\\n\\n        if (isPutActive) {\\n            result[1] = activeOptions[_optionType][1];\\n        }\\n    }\\n\\n    function getActiveOptions(string memory _optionType) public view returns (address[2] memory result) {\\n        return getActiveOptions(keccak256(abi.encodePacked(_optionType)));\\n    }\\n\\n    function getArchivedOptions(bytes32 _optionType) public view returns (address[] memory result) {\\n        (bool isCallActive, bool isPutActive) = checkActive(_optionType);\\n\\n        uint256 extraLength = 0;\\n        if (!isCallActive) {\\n            extraLength++;\\n        }\\n        if (!isPutActive) {\\n            extraLength++;\\n        }\\n\\n        uint256 archivedLength = getArchivedOptionsLength(_optionType);\\n\\n        result = new address[](archivedLength + extraLength);\\n\\n        for (uint256 i = 0; i < archivedLength; i++) {\\n            result[i] = archivedOptions[_optionType][i];\\n        }\\n\\n        uint256 cursor;\\n        if (!isCallActive) {\\n            result[archivedLength + cursor++] = activeOptions[_optionType][0];\\n        }\\n\\n        if (!isPutActive) {\\n            result[archivedLength + cursor++] = activeOptions[_optionType][1];\\n        }\\n\\n        return result;\\n    }\\n\\n    function getArchivedOptions(string memory _optionType) public view returns (address[] memory result) {\\n        return getArchivedOptions(keccak256(abi.encodePacked(_optionType)));\\n    }\\n\\n    function getArchivedOptionsLength(string memory _optionType) public view returns (uint256) {\\n        return archivedOptions[keccak256(abi.encodePacked(_optionType))].length;\\n    }\\n\\n    function getArchivedOptionsLength(bytes32 _optionType) public view returns (uint256) {\\n        return archivedOptions[_optionType].length;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IOilerOptionBaseFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\ninterface IOilerOptionBaseFactory {\\n    function optionLogicImplementation() external view returns (address);\\n\\n    function isClone(address _query) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IOilerOptionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"@openzeppelin/contracts/drafts/IERC20Permit.sol\\\";\\nimport {IOilerCollateral} from \\\"./IOilerCollateral.sol\\\";\\n\\ninterface IOilerOptionBase is IERC20, IERC20Permit {\\n    function optionType() external view returns (string memory);\\n\\n    function collateralInstance() external view returns (IOilerCollateral);\\n\\n    function isActive() external view returns (bool active);\\n\\n    function hasExpired() external view returns (bool);\\n\\n    function hasBeenExercised() external view returns (bool);\\n\\n    function put() external view returns (bool);\\n\\n    function write(uint256 _amount) external;\\n\\n    function write(uint256 _amount, address _onBehalfOf) external;\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IOilerOptionsRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport \\\"./IOilerOptionBase.sol\\\";\\nimport \\\"./IOilerRegistry.sol\\\";\\nimport \\\"./IBRouter.sol\\\";\\n\\ninterface IOilerOptionsRouter {\\n    // TODO add expiration?\\n    struct Permit {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    function registry() external view returns (IOilerRegistry);\\n\\n    function bRouter() external view returns (IBRouter);\\n\\n    function setUnlimitedApprovals(IOilerOptionBase _option) external;\\n\\n    function write(IOilerOptionBase _option, uint256 _amount) external;\\n\\n    function write(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        Permit calldata _permit\\n    ) external;\\n\\n    function writeAndAddLiquidity(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        uint256 _liquidityProviderCollateralAmount\\n    ) external;\\n\\n    function writeAndAddLiquidity(\\n        IOilerOptionBase _option,\\n        uint256 _amount,\\n        uint256 _liquidityProviderCollateralAmount,\\n        Permit calldata _writePermit,\\n        Permit calldata _liquidityAddPermit\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/drafts/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IOilerCollateral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"@openzeppelin/contracts/drafts/IERC20Permit.sol\\\";\\n\\ninterface IOilerCollateral is IERC20, IERC20Permit {\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IOilerRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"./IOilerOptionsRouter.sol\\\";\\n\\ninterface IOilerRegistry {\\n    function PUT() external view returns (uint256);\\n\\n    function CALL() external view returns (uint256);\\n\\n    function activeOptions(bytes32 _type) external view returns (address[2] memory);\\n\\n    function archivedOptions(bytes32 _type, uint256 _index) external view returns (address);\\n\\n    function optionTypes(uint256 _index) external view returns (bytes32);\\n\\n    function factories(bytes32 _optionType) external view returns (address);\\n\\n    function optionsRouter() external view returns (IOilerOptionsRouter);\\n\\n    function getOptionTypesLength() external view returns (uint256);\\n\\n    function getOptionTypeAt(uint256 _index) external view returns (bytes32);\\n\\n    function getArchivedOptionsLength(string memory _optionType) external view returns (uint256);\\n\\n    function getArchivedOptionsLength(bytes32 _optionType) external view returns (uint256);\\n\\n    function getOptionTypeFactory(string memory _optionType) external view returns (address);\\n\\n    function getAllArchivedOptionsOfType(string memory _optionType) external view returns (address[] memory);\\n\\n    function getAllArchivedOptionsOfType(bytes32 _optionType) external view returns (address[] memory);\\n\\n    function registerFactory(address factory) external;\\n\\n    function setOptionsTypeFactory(string memory _optionType, address _factory) external;\\n\\n    function registerOption(address _optionAddress, string memory _optionType) external;\\n\\n    function setOptionsRouter(IOilerOptionsRouter _optionsRouter) external;\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IBRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport {IBPool} from \\\"./IBPool.sol\\\";\\n\\ninterface IBRouter {\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountA,\\n        uint256 amountB\\n    ) external returns (uint256 poolTokens);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 poolAmountIn\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline,\\n        uint256 maxPrice\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function getPoolByTokens(address tokenA, address tokenB) external view returns (IBPool pool);\\n}\\n\"\r\n    },\r\n    \"contracts/options/interfaces/IBPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\ninterface IBPool {\\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        address tokenOut,\\n        uint256 minAmountOut,\\n        uint256 maxPrice\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amt\\n    ) external returns (bool);\\n\\n    function approve(address dst, uint256 amt) external returns (bool);\\n\\n    function transfer(address dst, uint256 amt) external returns (bool);\\n\\n    function balanceOf(address whom) external view returns (uint256);\\n\\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n    function finalize() external;\\n\\n    function rebind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) external;\\n\\n    function setSwapFee(uint256 swapFee) external;\\n\\n    function setPublicSwap(bool publicSwap) external;\\n\\n    function bind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) external;\\n\\n    function unbind(address token) external;\\n\\n    function gulp(address token) external;\\n\\n    function isBound(address token) external view returns (bool);\\n\\n    function getBalance(address token) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function getSwapFee() external view returns (uint256);\\n\\n    function isPublicSwap() external view returns (bool);\\n\\n    function getDenormalizedWeight(address token) external view returns (uint256);\\n\\n    function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function EXIT_FEE() external view returns (uint256);\\n\\n    function calcPoolOutGivenSingleIn(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 tokenAmountIn,\\n        uint256 swapFee\\n    ) external pure returns (uint256 poolAmountOut);\\n\\n    function calcSingleInGivenPoolOut(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 poolAmountOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountIn);\\n\\n    function calcSingleOutGivenPoolIn(\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 poolAmountIn,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountOut);\\n\\n    function calcPoolInGivenSingleOut(\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 tokenAmountOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 poolAmountIn);\\n\\n    function getCurrentTokens() external view returns (address[] memory tokens);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CALL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activeOptions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"archivedOptions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_optionType\",\"type\":\"string\"}],\"name\":\"checkActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_optionType\",\"type\":\"bytes32\"}],\"name\":\"checkActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"factories\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_optionType\",\"type\":\"string\"}],\"name\":\"getActiveOptions\",\"outputs\":[{\"internalType\":\"address[2]\",\"name\":\"result\",\"type\":\"address[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_optionType\",\"type\":\"bytes32\"}],\"name\":\"getActiveOptions\",\"outputs\":[{\"internalType\":\"address[2]\",\"name\":\"result\",\"type\":\"address[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_optionType\",\"type\":\"string\"}],\"name\":\"getAllArchivedOptionsOfType\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_optionType\",\"type\":\"bytes32\"}],\"name\":\"getAllArchivedOptionsOfType\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_optionType\",\"type\":\"string\"}],\"name\":\"getArchivedOptions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_optionType\",\"type\":\"bytes32\"}],\"name\":\"getArchivedOptions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_optionType\",\"type\":\"bytes32\"}],\"name\":\"getArchivedOptionsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_optionType\",\"type\":\"string\"}],\"name\":\"getArchivedOptionsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getOptionTypeAt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_optionType\",\"type\":\"string\"}],\"name\":\"getOptionTypeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOptionTypesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"optionTypes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionsRouter\",\"outputs\":[{\"internalType\":\"contract IOilerOptionsRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"registerFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_optionAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_optionType\",\"type\":\"string\"}],\"name\":\"registerOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOilerOptionsRouter\",\"name\":\"_optionsRouter\",\"type\":\"address\"}],\"name\":\"setOptionsRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_optionType\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setOptionsTypeFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OilerRegistry","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f37fd9185bb5657d7e57ddea268fe56c2458f675","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}