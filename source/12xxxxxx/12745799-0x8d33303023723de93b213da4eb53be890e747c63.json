{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.8.1;\r\n\r\ninterface IMoonCatAcclimator {\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n}\r\n\r\ninterface IMoonCatRescue {\r\n    function rescueOrder(uint256 tokenId) external view returns (bytes5);\r\n    function catOwners(bytes5 catId) external view returns (address);\r\n}\r\n\r\ninterface IReverseResolver {\r\n    function claim(address owner) external returns (bytes32);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\ninterface IERC721 {\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n\r\n/**\r\n * @dev Derived from OpenZeppelin standard template\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol\r\n * b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e\r\n */\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        uint256[] _values;\r\n        mapping (uint256 => uint256) _indexes;\r\n    }\r\n\r\n    function at(Set storage set, uint256 index) internal view returns (uint256) {\r\n        return set._values[index];\r\n    }\r\n\r\n    function contains(Set storage set, uint256 value) internal view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function length(Set storage set) internal view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function add(Set storage set, uint256 value) internal returns (bool) {\r\n        if (!contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function remove(Set storage set, uint256 value) internal returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            if (lastIndex != toDeleteIndex) {\r\n                uint256 lastvalue = set._values[lastIndex];\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary MoonCatBitSet {\r\n\r\n    bytes32 constant Mask =  0x0000000000000000000000000000000000000000000000000000000000000001;\r\n\r\n    function activate(bytes32[100] storage set)\r\n        internal\r\n    {\r\n        set[99] |= Mask;\r\n    }\r\n\r\n    function deactivate(bytes32[100] storage set)\r\n        internal\r\n    {\r\n        set[99] &= ~Mask;\r\n    }\r\n\r\n    function setBit(bytes32[100] storage set, uint16 index)\r\n        internal\r\n    {\r\n        uint16 wordIndex = index / 256;\r\n        uint16 bitIndex = index % 256;\r\n        bytes32 mask = Mask << (255 - bitIndex);\r\n        set[wordIndex] |= mask;\r\n    }\r\n\r\n    function clearBit(bytes32[100] storage set, uint16 index)\r\n        internal\r\n    {\r\n        uint16 wordIndex = index / 256;\r\n        uint16 bitIndex = index % 256;\r\n        bytes32 mask = ~(Mask << (255 - bitIndex));\r\n        set[wordIndex] &= mask;\r\n    }\r\n\r\n    function checkBit(bytes32[100] memory set, uint256 index)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 wordIndex = index / 256;\r\n        uint256 bitIndex = index % 256;\r\n        bytes32 mask = Mask << (255 - bitIndex);\r\n        return (mask & set[wordIndex]) != 0;\r\n    }\r\n\r\n    function isActive(bytes32[100] memory set)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (Mask & set[99]) == Mask;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title MoonCatâ€‹Accessories\r\n * @notice Public MoonCat Wearables infrastructure/protocols\r\n * @dev Allows wearable-designers to create accessories for sale and gifting.\r\n */\r\ncontract MoonCatAccessories {\r\n\r\n    /* External Contracts */\r\n\r\n    IMoonCatAcclimator MCA = IMoonCatAcclimator(0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69);\r\n    IMoonCatRescue MCR = IMoonCatRescue(0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6);\r\n\r\n    /* Events */\r\n\r\n    event AccessoryCreated(uint256 accessoryId, address creator, uint256 price, uint16 totalSupply, bytes30 name);\r\n    event AccessoryManagementTransferred(uint256 accessoryId, address newManager);\r\n    event AccessoryPriceChanged(uint256 accessoryId, uint256 price);\r\n    event AccessoryPurchased(uint256 accessoryId, uint256 rescueOrder, uint256 price);\r\n    event AccessoryApplied(uint256 accessoryId, uint256 rescueOrder, uint8 paletteIndex, uint16 zIndex);\r\n    event AccessoryDiscontinued(uint256 accessoryId);\r\n\r\n    event EligibleListSet(uint256 accessoryId);\r\n    event EligibleListCleared(uint256 accessoryId);\r\n\r\n    /* Structs */\r\n\r\n    struct Accessory {            // Accessory Definition\r\n        address payable manager;  // initially creator; payee for sales\r\n        uint8 width;              // image width\r\n        uint8 height;             // image height\r\n        uint8 meta;               // metadata flags [Reserved 3b, Audience 2b, MirrorPlacement 1b, MirrorAccessory 1b, Background 1b]\r\n        uint72 price;             // price at which accessory can be purchased (MAX ~4,722 ETH)\r\n                                  // if set to max value, the accessory is not for sale\r\n\r\n        uint16 totalSupply;      // total number of a given accessory that will ever exist; can only be changed by discontinuing the accessory\r\n        uint16 availableSupply;  // number of given accessory still available for sale; decremented on each sale\r\n        bytes28 name;            // unicode name of accessory, can only be set on creation\r\n\r\n        bytes8[7] palettes;     // color palettes, each palette is an array of uint8 offsets into the global palette\r\n        bytes2[4] positions;    // offsets for all 4 MoonCat poses, an offset pair of 0xffff indicates the pose is not supported\r\n                                // position order is [standing, sleeping, pouncing, stalking]\r\n\r\n        bytes IDAT;            // PNG IDAT chunk data for image reconstruction\r\n    }\r\n\r\n    struct OwnedAccessory {   // Accessory owned by an AcclimatedMoonCat\r\n        uint232 accessoryId;  // index into AllAccessories Array\r\n        uint8 paletteIndex;   // index into Accessory.palettes Array\r\n        uint16 zIndex;        // drawing order indicator (lower numbers are closer to MoonCat)\r\n                              // zIndex == 0 indicates the MoonCat is not wearing the accessory\r\n                              // if the accessory meta `Background` bit is 1 the zIndex is interpreted as negative\r\n    }\r\n\r\n    struct AccessoryBatchData {   // Used for batch accessory alterations and purchases\r\n        uint256 rescueOrder;\r\n        uint232 ownedIndexOrAccessoryId;\r\n        uint8 paletteIndex;\r\n        uint16 zIndex;\r\n    }\r\n\r\n    using EnumerableSet for EnumerableSet.Set;\r\n\r\n    /* State */\r\n\r\n    bool public frozen = true;\r\n\r\n    Accessory[] internal AllAccessories; //  Array of all Accessories that have been created\r\n    mapping (uint256 => bytes32[100]) internal AllEligibleLists; // Accessory ID => BitSet\r\n                                                                 // Each bit represents the eligbility of an AcclimatedMoonCat\r\n                                                                 // An eligibleList is active when the final bit == 1\r\n\r\n    mapping (address => EnumerableSet.Set) internal AccessoriesByManager; // Manager address => accessoryId Set\r\n\r\n    mapping (uint256 => mapping(uint256 => bool)) internal OwnedAccessoriesByMoonCat; // AcclimatedMoonCat rescueOrder => Accessory ID => isOwned?\r\n    mapping (uint256 => OwnedAccessory[]) public AccessoriesByMoonCat; // AcclimatedMoonCat rescueOrder => Array of AppliedAccessory structs\r\n\r\n    mapping (bytes32 => bool) public accessoryHashes; // used to check if the image data for an accessory has already been submitted\r\n\r\n    address payable public owner;\r\n\r\n    uint72 constant NOT_FOR_SALE = 0xffffffffffffffffff;\r\n\r\n    uint256 public feeDenominator = 5;\r\n    uint256 public referralDenominator = 0;\r\n\r\n    /* Modifiers */\r\n\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        _;\r\n    }\r\n\r\n    modifier accessoryExists (uint256 accessoryId){\r\n        require(accessoryId < AllAccessories.length, \"Accessory Not Found\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAccessoryManager (uint256 accessoryId) {\r\n        require(msg.sender == AllAccessories[accessoryId].manager, \"Not Accessory Manager\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAMCOwner (uint256 rescueOrder) {\r\n        require(MCR.catOwners(MCR.rescueOrder(rescueOrder)) == 0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69,\r\n                \"Not Acclimated\");\r\n        address moonCatOwner = MCA.ownerOf(rescueOrder);\r\n        require((msg.sender == moonCatOwner)\r\n            || (msg.sender == MCA.getApproved(rescueOrder))\r\n            || (MCA.isApprovedForAll(moonCatOwner, msg.sender)),\r\n            \"Not AMC Owner or Approved\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier notZeroAddress (address a){\r\n        require(a != address(0), \"Zero Address\");\r\n        _;\r\n    }\r\n\r\n    modifier notFrozen () {\r\n        require(!frozen, \"Frozen\");\r\n        _;\r\n    }\r\n\r\n    modifier validPrice(uint256 price) {\r\n        require(price <= NOT_FOR_SALE, \"Invalid Price\");\r\n        _;\r\n    }\r\n\r\n    /* Admin */\r\n\r\n    constructor(){\r\n        owner = payable(msg.sender);\r\n\r\n        // https://docs.ens.domains/contract-api-reference/reverseregistrar#claim-address\r\n        IReverseResolver(0x084b1c3C81545d370f3634392De611CaaBFf8148)\r\n            .claim(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer funds from the contract's wallet to an external wallet, minus a fee\r\n     */\r\n    function sendPayment (address payable target, uint256 amount, address payable referrer)\r\n        internal\r\n    {\r\n        uint256 fee = (feeDenominator > 0) ? (amount / feeDenominator) : 0;\r\n        uint256 referral = (referralDenominator > 0) ? (fee / referralDenominator) : 0;\r\n        fee = fee - referral;\r\n        uint256 payment = amount - fee - referral;\r\n        owner.transfer(fee);\r\n        referrer.transfer(referral);\r\n        target.transfer(payment);\r\n    }\r\n\r\n    /**\r\n     * @dev Update the amount of fee taken from each sale\r\n     */\r\n    function setFee (uint256 denominator)\r\n        public\r\n        onlyOwner\r\n    {\r\n        feeDenominator = denominator;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the amount of referral fee taken from each sale\r\n     */\r\n    function setReferralFee (uint256 denominator)\r\n        public\r\n        onlyOwner\r\n    {\r\n        referralDenominator = denominator;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow current `owner` to transfer ownership to another address\r\n     */\r\n    function transferOwnership (address payable newOwner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevent creating and applying accessories\r\n     */\r\n    function freeze ()\r\n        public\r\n        onlyOwner\r\n        notFrozen\r\n    {\r\n        frozen = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Enable creating and applying accessories\r\n     */\r\n    function unfreeze ()\r\n        public\r\n        onlyOwner\r\n    {\r\n        frozen = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the metadata flags for an accessory\r\n     */\r\n    function setMetaByte (uint256 accessoryId, uint8 metabyte)\r\n        public\r\n        onlyOwner\r\n        accessoryExists(accessoryId)\r\n    {\r\n        Accessory storage accessory = AllAccessories[accessoryId];\r\n        accessory.meta = metabyte;\r\n    }\r\n\r\n    /**\r\n     * @dev Batch-update metabytes for accessories, by ensuring given bits are on\r\n     */\r\n    function batchOrMetaByte (uint8 value, uint256[] calldata accessoryIds)\r\n        public\r\n        onlyOwner\r\n    {\r\n        uint256 id;\r\n        Accessory storage accessory;\r\n        for(uint256 i = 0; i < accessoryIds.length; i++){\r\n            id = accessoryIds[i];\r\n            if(i < AllAccessories.length){\r\n                accessory = AllAccessories[id];\r\n                accessory.meta = accessory.meta | value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Batch-update metabytes for accessories, by ensuring given bits are off\r\n     */\r\n    function batchAndMetaByte (uint8 value, uint256[] calldata accessoryIds)\r\n        public\r\n        onlyOwner\r\n    {\r\n        uint256 id;\r\n        Accessory storage accessory;\r\n        for(uint256 i = 0; i < accessoryIds.length; i++){\r\n            id = accessoryIds[i];\r\n            if(i < AllAccessories.length){\r\n                accessory = AllAccessories[id];\r\n                accessory.meta = accessory.meta & value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC20 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC20(address tokenContract)\r\n        public\r\n        onlyOwner\r\n    {\r\n        IERC20 token = IERC20(tokenContract);\r\n        token.transfer(owner, token.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC721 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC721(address tokenContract, uint256 tokenId)\r\n        public\r\n        onlyOwner\r\n    {\r\n        IERC721(tokenContract).safeTransferFrom(address(this), owner, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a MoonCat is eligible to purchase an accessory\r\n     */\r\n    function isEligible(uint256 rescueOrder, uint256 accessoryId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        if(MoonCatBitSet.isActive(AllEligibleLists[accessoryId])) {\r\n            return MoonCatBitSet.checkBit(AllEligibleLists[accessoryId], rescueOrder);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /* Helpers */\r\n\r\n    /**\r\n     * @dev Mark an accessory as owned by a specific MoonCat, and put it on\r\n     *\r\n     * This is an internal function that only does sanity-checking (prevent double-buying an accessory, and prevent picking an invalid palette).\r\n     * All methods that use this function check permissions before calling this function.\r\n     */\r\n    function applyAccessory (uint256 rescueOrder, uint256 accessoryId, uint8 paletteIndex, uint16 zIndex)\r\n        private\r\n        accessoryExists(accessoryId)\r\n        notFrozen\r\n        returns (uint256)\r\n    {\r\n        require(OwnedAccessoriesByMoonCat[rescueOrder][accessoryId] == false, \"Already Owned\");\r\n        require(uint64(AllAccessories[accessoryId].palettes[paletteIndex]) != 0, \"Invalid Palette\");\r\n        OwnedAccessory[] storage ownedAccessories = AccessoriesByMoonCat[rescueOrder];\r\n        uint256 ownedAccessoryIndex = ownedAccessories.length;\r\n        ownedAccessories.push(OwnedAccessory(uint232(accessoryId), paletteIndex, zIndex));\r\n        OwnedAccessoriesByMoonCat[rescueOrder][accessoryId] = true;\r\n        emit AccessoryApplied(accessoryId, rescueOrder, paletteIndex, zIndex);\r\n        return ownedAccessoryIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Ensure an accessory's image data has not been submitted before\r\n     */\r\n    function verifyAccessoryUniqueness(bytes calldata IDAT)\r\n        internal\r\n    {\r\n        bytes32 accessoryHash = keccak256(IDAT);\r\n        require(!accessoryHashes[accessoryHash], \"Duplicate\");\r\n        accessoryHashes[accessoryHash] = true;\r\n    }\r\n\r\n    /* Creator */\r\n\r\n    /**\r\n     * @dev Create an accessory, as the contract owner\r\n     *\r\n     * This method allows the contract owner to deploy accessories on behalf of others. It also allows deploying\r\n     * accessories that break some of the rules:\r\n     *\r\n     * This method can be called when frozen, so the owner can add to the store even when others cannot.\r\n     * This method does not check for duplicates, so if an accessory creator wants to make a literal duplicate, that can be facilitated.\r\n     */\r\n    function ownerCreateAccessory(address payable manager, uint8[3] calldata WHM, uint256 priceWei, uint16 totalSupply, bytes28 name, bytes2[4] calldata positions, bytes8[7] calldata initialPalettes, bytes calldata IDAT)\r\n        public\r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        uint256 accessoryId = AllAccessories.length;\r\n        AllAccessories.push(Accessory(manager, WHM[0], WHM[1], WHM[2], uint72(priceWei), totalSupply, totalSupply, name, initialPalettes, positions, IDAT));\r\n\r\n        bytes32 accessoryHash = keccak256(IDAT);\r\n        accessoryHashes[accessoryHash] = true;\r\n\r\n        emit AccessoryCreated(accessoryId, manager, priceWei, totalSupply, name);\r\n        AccessoriesByManager[manager].add(accessoryId);\r\n        return accessoryId;\r\n    }\r\n\r\n    /**\r\n     * @dev Create an accessory with an eligible list, as the contract owner\r\n     */\r\n    function ownerCreateAccessory(address payable manager, uint8[3] calldata WHM, uint256 priceWei, uint16 totalSupply, bytes28 name, bytes2[4] calldata positions, bytes8[7] calldata initialPalettes, bytes calldata IDAT, bytes32[100] calldata eligibleList)\r\n        public\r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        uint256 accessoryId = ownerCreateAccessory(manager, WHM, priceWei, totalSupply, name, positions, initialPalettes, IDAT);\r\n        AllEligibleLists[accessoryId] = eligibleList;\r\n        MoonCatBitSet.activate(AllEligibleLists[accessoryId]);\r\n        return accessoryId;\r\n    }\r\n\r\n    /**\r\n     * @dev Create an accessory\r\n     */\r\n    function createAccessory (uint8[3] calldata WHM, uint256 priceWei, uint16 totalSupply, bytes28 name, bytes2[4] calldata positions, bytes8[] calldata palettes, bytes calldata IDAT)\r\n        public\r\n        notFrozen\r\n        validPrice(priceWei)\r\n        returns (uint256)\r\n    {\r\n        require(palettes.length <= 7 && palettes.length > 0, \"Invalid Palette Count\");\r\n        require(totalSupply > 0 && totalSupply <= 25440, \"Invalid Supply\");\r\n        require(WHM[0] > 0 && WHM[1] > 0, \"Invalid Dimensions\");\r\n        verifyAccessoryUniqueness(IDAT);\r\n        uint256 accessoryId = AllAccessories.length;\r\n        bytes8[7] memory initialPalettes;\r\n        for(uint i = 0; i < palettes.length; i++){\r\n            require(uint64(palettes[i]) != 0, \"Invalid Palette\");\r\n            initialPalettes[i] = palettes[i];\r\n        }\r\n        AllAccessories.push(Accessory(payable(msg.sender), WHM[0], WHM[1], WHM[2] & 0x1f, uint72(priceWei), totalSupply, totalSupply, name, initialPalettes, positions, IDAT));\r\n        //                                                                        ^ Clear reserved bits\r\n        emit AccessoryCreated(accessoryId, msg.sender, priceWei, totalSupply, name);\r\n        AccessoriesByManager[msg.sender].add(accessoryId);\r\n        return accessoryId;\r\n    }\r\n\r\n    /**\r\n     * @dev Create an accessory with an eligible list\r\n     */\r\n    function createAccessory (uint8[3] calldata WHM, uint256 priceWei, uint16 totalSupply, bytes28 name, bytes2[4] calldata positions, bytes8[] calldata palettes, bytes calldata IDAT, bytes32[100] calldata eligibleList)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        uint256 accessoryId = createAccessory(WHM, priceWei, totalSupply, name, positions, palettes, IDAT);\r\n        AllEligibleLists[accessoryId] = eligibleList;\r\n        MoonCatBitSet.activate(AllEligibleLists[accessoryId]);\r\n        return accessoryId;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a color palette variant to an existing accessory\r\n     */\r\n    function addAccessoryPalette (uint256 accessoryId, bytes8 newPalette)\r\n        public\r\n        onlyAccessoryManager(accessoryId)\r\n    {\r\n        require(uint64(newPalette) != 0, \"Invalid Palette\");\r\n        Accessory storage accessory = AllAccessories[accessoryId];\r\n        bytes8[7] storage accessoryPalettes = accessory.palettes;\r\n\r\n        require(uint64(accessoryPalettes[6]) == 0, \"Palette Limit Exceeded\");\r\n        uint paletteIndex = 1;\r\n        while(uint64(accessoryPalettes[paletteIndex]) > 0){\r\n            paletteIndex++;\r\n        }\r\n        accessoryPalettes[paletteIndex] = newPalette;\r\n    }\r\n\r\n    /**\r\n     * @dev Give ownership of an accessory to someone else\r\n     */\r\n    function transferAccessoryManagement (uint256 accessoryId, address payable newManager)\r\n        public\r\n        onlyAccessoryManager(accessoryId)\r\n        notZeroAddress(newManager)\r\n    {\r\n        Accessory storage accessory = AllAccessories[accessoryId];\r\n        AccessoriesByManager[accessory.manager].remove(accessoryId);\r\n        AccessoriesByManager[newManager].add(accessoryId);\r\n        accessory.manager = newManager;\r\n        emit AccessoryManagementTransferred(accessoryId, newManager);\r\n    }\r\n\r\n    /**\r\n     * @dev Set accessory to have a new price\r\n     */\r\n    function setAccessoryPrice (uint256 accessoryId, uint256 newPriceWei)\r\n        public\r\n        onlyAccessoryManager(accessoryId)\r\n        validPrice(newPriceWei)\r\n    {\r\n        Accessory storage accessory = AllAccessories[accessoryId];\r\n\r\n        if(accessory.price != newPriceWei){\r\n            accessory.price = uint72(newPriceWei);\r\n            emit AccessoryPriceChanged(accessoryId, newPriceWei);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set accessory eligible list\r\n     */\r\n    function setEligibleList (uint256 accessoryId, bytes32[100] calldata eligibleList)\r\n        public\r\n        onlyAccessoryManager(accessoryId)\r\n    {\r\n        AllEligibleLists[accessoryId] = eligibleList;\r\n        MoonCatBitSet.activate(AllEligibleLists[accessoryId]);\r\n        emit EligibleListSet(accessoryId);\r\n    }\r\n\r\n    /**\r\n     * @dev Clear accessory eligible list\r\n     */\r\n    function clearEligibleList (uint256 accessoryId)\r\n        public\r\n        onlyAccessoryManager(accessoryId)\r\n    {\r\n        delete AllEligibleLists[accessoryId];\r\n        emit EligibleListCleared(accessoryId);\r\n    }\r\n\r\n    /**\r\n     * @dev Turns eligible list on or off without setting/clearing\r\n     */\r\n    function toggleEligibleList (uint256 accessoryId, bool active)\r\n        public\r\n        onlyAccessoryManager(accessoryId)\r\n    {\r\n        bool isActive = MoonCatBitSet.isActive(AllEligibleLists[accessoryId]);\r\n        if(isActive && !active) {\r\n            MoonCatBitSet.deactivate(AllEligibleLists[accessoryId]);\r\n            emit EligibleListCleared(accessoryId);\r\n        } else if (!isActive && active){\r\n            MoonCatBitSet.activate(AllEligibleLists[accessoryId]);\r\n            emit EligibleListSet(accessoryId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add/Remove individual rescueOrders from an eligibleSet\r\n     */\r\n    function editEligibleMoonCats(uint256 accessoryId, bool targetState, uint16[] calldata rescueOrders)\r\n        public\r\n        onlyAccessoryManager(accessoryId)\r\n    {\r\n        bytes32[100] storage eligibleList = AllEligibleLists[accessoryId];\r\n        for(uint i = 0; i < rescueOrders.length; i++){\r\n            require(rescueOrders[i] < 25440, \"Out of bounds\");\r\n            if(targetState) {\r\n                MoonCatBitSet.setBit(eligibleList, rescueOrders[i]);\r\n            } else {\r\n                MoonCatBitSet.clearBit(eligibleList, rescueOrders[i]);\r\n            }\r\n        }\r\n        if(MoonCatBitSet.isActive(eligibleList)){\r\n            emit EligibleListSet(accessoryId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Buy an accessory as the manager of that accessory\r\n     *\r\n     * Accessory managers always get charged zero cost for buying/applying their own accessories,\r\n     * and always bypass the EligibleList (if there is any).\r\n     *\r\n     * A purchase by the accessory manager still reduces the available supply of an accessory, and\r\n     * the Manager must be the owner of or be granted access to the MoonCat to which the accessory\r\n     * is being applied.\r\n     */\r\n    function managerApplyAccessory (uint256 rescueOrder, uint256 accessoryId, uint8 paletteIndex, uint16 zIndex)\r\n        public\r\n        onlyAccessoryManager(accessoryId)\r\n        onlyAMCOwner(rescueOrder)\r\n        returns (uint256)\r\n    {\r\n        require(AllAccessories[accessoryId].availableSupply > 0, \"Supply Exhausted\");\r\n        AllAccessories[accessoryId].availableSupply--;\r\n        return applyAccessory(rescueOrder, accessoryId, paletteIndex, zIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove accessory from the market forever by transferring\r\n     * management to the zero address, setting it as not for sale, and\r\n     * setting the total supply to the current existing quantity.\r\n     */\r\n    function discontinueAccessory (uint256 accessoryId)\r\n        public\r\n        onlyAccessoryManager(accessoryId)\r\n    {\r\n        Accessory storage accessory = AllAccessories[accessoryId];\r\n        accessory.price = NOT_FOR_SALE;\r\n        AccessoriesByManager[accessory.manager].remove(accessoryId);\r\n        AccessoriesByManager[address(0)].add(accessoryId);\r\n        accessory.manager = payable(address(0));\r\n        accessory.totalSupply = accessory.totalSupply - accessory.availableSupply;\r\n        accessory.availableSupply = 0;\r\n        emit AccessoryDiscontinued(accessoryId);\r\n    }\r\n\r\n    /* User */\r\n\r\n    /**\r\n     * @dev Purchase and apply an accessory in a standard manner.\r\n     *\r\n     * This method is an internal method for doing standard permission checks before calling the applyAccessory function.\r\n     * This method checks that an accessory is set to be allowed for sale (not set to the max price), that there's enough supply left,\r\n     * and that the buyer has supplied enough ETH to satisfy the price of the accessory.\r\n     *\r\n     * In addition, it checks to ensure that the MoonCat receiving the accessory is owned by the address making this purchase,\r\n     * and that the MoonCat purchasing the accessory is on the Eligible List for that accessory.\r\n     */\r\n    function buyAndApplyAccessory (uint256 rescueOrder, uint256 accessoryId, uint8 paletteIndex, uint16 zIndex, address payable referrer)\r\n        private\r\n        onlyAMCOwner(rescueOrder)\r\n        notZeroAddress(referrer)\r\n        accessoryExists(accessoryId)\r\n        returns (uint256)\r\n    {\r\n        require(isEligible(rescueOrder, accessoryId), \"Ineligible\");\r\n        Accessory storage accessory = AllAccessories[accessoryId];\r\n        require(accessory.price != NOT_FOR_SALE, \"Not For Sale\");\r\n        require(accessory.availableSupply > 0, \"Supply Exhausted\");\r\n        accessory.availableSupply--;\r\n        require(address(this).balance >= accessory.price, \"Insufficient Value\");\r\n        emit AccessoryPurchased(accessoryId, rescueOrder, accessory.price);\r\n        uint256 ownedAccessoryId = applyAccessory(rescueOrder, accessoryId, paletteIndex, zIndex);\r\n        if(accessory.price > 0) {\r\n            sendPayment(accessory.manager, accessory.price, referrer);\r\n        }\r\n        return ownedAccessoryId;\r\n    }\r\n\r\n    /**\r\n     * @dev Buy an accessory that is up for sale by its owner\r\n     *\r\n     * This method is the typical purchase method used by storefronts;\r\n     * it allows the storefront to claim a referral fee for the purchase.\r\n     *\r\n     * Passing a z-index value of zero to this method just purchases the accessory,\r\n     * but does not make it an active part of the MoonCat's appearance.\r\n     */\r\n    function buyAccessory (uint256 rescueOrder, uint256 accessoryId, uint8 paletteIndex, uint16 zIndex, address payable referrer)\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        uint256 ownedAccessoryId = buyAndApplyAccessory(rescueOrder, accessoryId, paletteIndex, zIndex, referrer);\r\n        if(address(this).balance > 0){\r\n            // The buyer over-paid; transfer their funds back to them\r\n            payable(msg.sender).transfer(address(this).balance);\r\n        }\r\n        return ownedAccessoryId;\r\n    }\r\n\r\n    /**\r\n     * @dev Buy an accessory that is up for sale by its owner\r\n     *\r\n     * This method is a generic fallback method if no referrer address is given for a purchase.\r\n     * Defaults to the owner of the contract to receive the referral fee in this case.\r\n     */\r\n    function buyAccessory (uint256 rescueOrder, uint256 accessoryId, uint8 paletteIndex, uint16 zIndex)\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        return buyAccessory(rescueOrder, accessoryId, paletteIndex, zIndex, owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Buy multiple accessories at once; setting a palette and z-index for each one\r\n     */\r\n    function buyAccessories (AccessoryBatchData[] calldata orders, address payable referrer)\r\n        public\r\n        payable\r\n    {\r\n        for (uint256 i = 0; i < orders.length; i++) {\r\n            AccessoryBatchData memory order = orders[i];\r\n            buyAndApplyAccessory(order.rescueOrder, order.ownedIndexOrAccessoryId, order.paletteIndex, order.zIndex, referrer);\r\n        }\r\n        if(address(this).balance > 0){\r\n            // The buyer over-paid; transfer their funds back to them\r\n            payable(msg.sender).transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Buy multiple accessories at once; setting a palette and z-index for each one (setting the contract owner as the referrer)\r\n     */\r\n    function buyAccessories (AccessoryBatchData[] calldata orders)\r\n        public\r\n        payable\r\n    {\r\n        buyAccessories(orders, owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change the status of an owned accessory (worn or not, z-index ordering, color palette variant)\r\n     */\r\n    function alterAccessory (uint256 rescueOrder, uint256 ownedAccessoryIndex, uint8 paletteIndex, uint16 zIndex)\r\n        public\r\n        onlyAMCOwner(rescueOrder)\r\n    {\r\n        OwnedAccessory[] storage ownedAccessories = AccessoriesByMoonCat[rescueOrder];\r\n        require(ownedAccessoryIndex < ownedAccessories.length, \"Owned Accessory Not Found\");\r\n        OwnedAccessory storage ownedAccessory = ownedAccessories[ownedAccessoryIndex];\r\n        require((paletteIndex <= 7) && (uint64(AllAccessories[ownedAccessory.accessoryId].palettes[paletteIndex]) != 0), \"Palette Not Found\");\r\n        ownedAccessory.paletteIndex = paletteIndex;\r\n        ownedAccessory.zIndex = zIndex;\r\n        emit AccessoryApplied(ownedAccessory.accessoryId, rescueOrder, paletteIndex, zIndex);\r\n    }\r\n\r\n    /**\r\n    * @dev Change the status of multiple accessories at once\r\n    */\r\n    function alterAccessories (AccessoryBatchData[] calldata alterations)\r\n        public\r\n    {\r\n        for(uint i = 0; i < alterations.length; i++ ){\r\n            AccessoryBatchData memory alteration = alterations[i];\r\n            alterAccessory(alteration.rescueOrder, alteration.ownedIndexOrAccessoryId, alteration.paletteIndex, alteration.zIndex);\r\n        }\r\n    }\r\n\r\n    /* View - Accessories */\r\n\r\n    /**\r\n     * @dev How many accessories exist in this contract?\r\n     */\r\n    function totalAccessories ()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return AllAccessories.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if there is an accessory with same IDAT data\r\n     */\r\n    function isAccessoryUnique(bytes calldata IDAT)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes32 accessoryHash = keccak256(IDAT);\r\n        return (!accessoryHashes[accessoryHash]);\r\n    }\r\n\r\n    /**\r\n     * @dev How many palettes are defined for an accessory?\r\n     */\r\n    function accessoryPaletteCount (uint256 accessoryId)\r\n        public\r\n        view\r\n        accessoryExists(accessoryId)\r\n        returns (uint8)\r\n    {\r\n        bytes8[7] memory accessoryPalettes = AllAccessories[accessoryId].palettes;\r\n        for(uint8 i = 0; i < accessoryPalettes.length; i++) {\r\n            if (uint64(accessoryPalettes[i]) == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return uint8(accessoryPalettes.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Fetch a specific palette for a given accessory\r\n     */\r\n    function accessoryPalette (uint256 accessoryId, uint256 paletteIndex)\r\n        public\r\n        view\r\n        returns (bytes8)\r\n    {\r\n        return AllAccessories[accessoryId].palettes[paletteIndex];\r\n    }\r\n\r\n    /**\r\n     * @dev Fetch data about a given accessory\r\n     */\r\n    function accessoryInfo (uint256 accessoryId)\r\n        public\r\n        view\r\n        accessoryExists(accessoryId)\r\n        returns (uint16 totalSupply, uint16 availableSupply, bytes28 name, address manager, uint8 metabyte, uint8 availablePalettes, bytes2[4] memory positions, bool availableForPurchase, uint256 price)\r\n    {\r\n        Accessory memory accessory = AllAccessories[accessoryId];\r\n        availablePalettes = accessoryPaletteCount(accessoryId);\r\n        bool available = accessory.price != NOT_FOR_SALE && accessory.availableSupply > 0;\r\n        return (accessory.totalSupply, accessory.availableSupply, accessory.name, accessory.manager, accessory.meta, availablePalettes, accessory.positions, available, accessory.price);\r\n    }\r\n\r\n    /**\r\n     * @dev Fetch image data about a given accessory\r\n     */\r\n    function accessoryImageData (uint256 accessoryId)\r\n        public\r\n        view\r\n        accessoryExists(accessoryId)\r\n        returns (bytes2[4] memory positions, bytes8[7] memory palettes, uint8 width, uint8 height, uint8 meta, bytes memory IDAT)\r\n    {\r\n        Accessory memory accessory = AllAccessories[accessoryId];\r\n        return (accessory.positions, accessory.palettes, accessory.width, accessory.height, accessory.meta, accessory.IDAT);\r\n    }\r\n\r\n    /**\r\n     * @dev Fetch EligibleList for a given accessory\r\n     */\r\n    function accessoryEligibleList(uint256 accessoryId)\r\n        public\r\n        view\r\n        accessoryExists(accessoryId)\r\n        returns (bytes32[100] memory)\r\n    {\r\n        return AllEligibleLists[accessoryId];\r\n    }\r\n\r\n    /*  View - Manager */\r\n\r\n    /**\r\n     * @dev Which address manages a specific accessory?\r\n     */\r\n    function managerOf (uint256 accessoryId)\r\n        public\r\n        view\r\n        accessoryExists(accessoryId)\r\n        returns (address)\r\n    {\r\n        return AllAccessories[accessoryId].manager;\r\n    }\r\n\r\n    /**\r\n     * @dev How many accessories does a given address manage?\r\n     */\r\n    function balanceOf (address manager)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return AccessoriesByManager[manager].length();\r\n    }\r\n\r\n    /**\r\n     * @dev Iterate through a given address's managed accessories\r\n     */\r\n    function managedAccessoryByIndex (address manager, uint256 managedAccessoryIndex)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return AccessoriesByManager[manager].at(managedAccessoryIndex);\r\n    }\r\n\r\n    /*  View - AcclimatedMoonCat */\r\n\r\n    /**\r\n     * @dev How many accessories does a given MoonCat own?\r\n     */\r\n    function balanceOf (uint256 rescueOrder)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return AccessoriesByMoonCat[rescueOrder].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Iterate through a given MoonCat's accessories\r\n     */\r\n    function ownedAccessoryByIndex (uint256 rescueOrder, uint256 ownedAccessoryIndex)\r\n        public\r\n        view\r\n        returns (OwnedAccessory memory)\r\n    {\r\n        require(ownedAccessoryIndex < AccessoriesByMoonCat[rescueOrder].length, \"Index out of bounds\");\r\n        return AccessoriesByMoonCat[rescueOrder][ownedAccessoryIndex];\r\n    }\r\n\r\n    /**\r\n     * @dev Lookup function to see if this MoonCat has already purchased a given accessory\r\n     */\r\n    function doesMoonCatOwnAccessory (uint256 rescueOrder, uint256 accessoryId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return OwnedAccessoriesByMoonCat[rescueOrder][accessoryId];\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"zIndex\",\"type\":\"uint16\"}],\"name\":\"AccessoryApplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"totalSupply\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes30\",\"name\":\"name\",\"type\":\"bytes30\"}],\"name\":\"AccessoryCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"AccessoryDiscontinued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"AccessoryManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"AccessoryPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"AccessoryPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"EligibleListCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"EligibleListSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"AccessoriesByMoonCat\",\"outputs\":[{\"internalType\":\"uint232\",\"name\":\"accessoryId\",\"type\":\"uint232\"},{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"zIndex\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"accessoryEligibleList\",\"outputs\":[{\"internalType\":\"bytes32[100]\",\"name\":\"\",\"type\":\"bytes32[100]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"accessoryHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"accessoryImageData\",\"outputs\":[{\"internalType\":\"bytes2[4]\",\"name\":\"positions\",\"type\":\"bytes2[4]\"},{\"internalType\":\"bytes8[7]\",\"name\":\"palettes\",\"type\":\"bytes8[7]\"},{\"internalType\":\"uint8\",\"name\":\"width\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"height\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"meta\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"IDAT\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"accessoryInfo\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"totalSupply\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"availableSupply\",\"type\":\"uint16\"},{\"internalType\":\"bytes28\",\"name\":\"name\",\"type\":\"bytes28\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"metabyte\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"availablePalettes\",\"type\":\"uint8\"},{\"internalType\":\"bytes2[4]\",\"name\":\"positions\",\"type\":\"bytes2[4]\"},{\"internalType\":\"bool\",\"name\":\"availableForPurchase\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paletteIndex\",\"type\":\"uint256\"}],\"name\":\"accessoryPalette\",\"outputs\":[{\"internalType\":\"bytes8\",\"name\":\"\",\"type\":\"bytes8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"accessoryPaletteCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"bytes8\",\"name\":\"newPalette\",\"type\":\"bytes8\"}],\"name\":\"addAccessoryPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint232\",\"name\":\"ownedIndexOrAccessoryId\",\"type\":\"uint232\"},{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"zIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct MoonCatAccessories.AccessoryBatchData[]\",\"name\":\"alterations\",\"type\":\"tuple[]\"}],\"name\":\"alterAccessories\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownedAccessoryIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"zIndex\",\"type\":\"uint16\"}],\"name\":\"alterAccessory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"value\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"accessoryIds\",\"type\":\"uint256[]\"}],\"name\":\"batchAndMetaByte\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"value\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"accessoryIds\",\"type\":\"uint256[]\"}],\"name\":\"batchOrMetaByte\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint232\",\"name\":\"ownedIndexOrAccessoryId\",\"type\":\"uint232\"},{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"zIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct MoonCatAccessories.AccessoryBatchData[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"address payable\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buyAccessories\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint232\",\"name\":\"ownedIndexOrAccessoryId\",\"type\":\"uint232\"},{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"zIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct MoonCatAccessories.AccessoryBatchData[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"buyAccessories\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"zIndex\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buyAccessory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"zIndex\",\"type\":\"uint16\"}],\"name\":\"buyAccessory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"clearEligibleList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[3]\",\"name\":\"WHM\",\"type\":\"uint8[3]\"},{\"internalType\":\"uint256\",\"name\":\"priceWei\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"totalSupply\",\"type\":\"uint16\"},{\"internalType\":\"bytes28\",\"name\":\"name\",\"type\":\"bytes28\"},{\"internalType\":\"bytes2[4]\",\"name\":\"positions\",\"type\":\"bytes2[4]\"},{\"internalType\":\"bytes8[]\",\"name\":\"palettes\",\"type\":\"bytes8[]\"},{\"internalType\":\"bytes\",\"name\":\"IDAT\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[100]\",\"name\":\"eligibleList\",\"type\":\"bytes32[100]\"}],\"name\":\"createAccessory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[3]\",\"name\":\"WHM\",\"type\":\"uint8[3]\"},{\"internalType\":\"uint256\",\"name\":\"priceWei\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"totalSupply\",\"type\":\"uint16\"},{\"internalType\":\"bytes28\",\"name\":\"name\",\"type\":\"bytes28\"},{\"internalType\":\"bytes2[4]\",\"name\":\"positions\",\"type\":\"bytes2[4]\"},{\"internalType\":\"bytes8[]\",\"name\":\"palettes\",\"type\":\"bytes8[]\"},{\"internalType\":\"bytes\",\"name\":\"IDAT\",\"type\":\"bytes\"}],\"name\":\"createAccessory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"discontinueAccessory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"doesMoonCatOwnAccessory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"targetState\",\"type\":\"bool\"},{\"internalType\":\"uint16[]\",\"name\":\"rescueOrders\",\"type\":\"uint16[]\"}],\"name\":\"editEligibleMoonCats\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"IDAT\",\"type\":\"bytes\"}],\"name\":\"isAccessoryUnique\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"isEligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"managedAccessoryIndex\",\"type\":\"uint256\"}],\"name\":\"managedAccessoryByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"zIndex\",\"type\":\"uint16\"}],\"name\":\"managerApplyAccessory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"}],\"name\":\"managerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownedAccessoryIndex\",\"type\":\"uint256\"}],\"name\":\"ownedAccessoryByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint232\",\"name\":\"accessoryId\",\"type\":\"uint232\"},{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"zIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct MoonCatAccessories.OwnedAccessory\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint8[3]\",\"name\":\"WHM\",\"type\":\"uint8[3]\"},{\"internalType\":\"uint256\",\"name\":\"priceWei\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"totalSupply\",\"type\":\"uint16\"},{\"internalType\":\"bytes28\",\"name\":\"name\",\"type\":\"bytes28\"},{\"internalType\":\"bytes2[4]\",\"name\":\"positions\",\"type\":\"bytes2[4]\"},{\"internalType\":\"bytes8[7]\",\"name\":\"initialPalettes\",\"type\":\"bytes8[7]\"},{\"internalType\":\"bytes\",\"name\":\"IDAT\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[100]\",\"name\":\"eligibleList\",\"type\":\"bytes32[100]\"}],\"name\":\"ownerCreateAccessory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint8[3]\",\"name\":\"WHM\",\"type\":\"uint8[3]\"},{\"internalType\":\"uint256\",\"name\":\"priceWei\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"totalSupply\",\"type\":\"uint16\"},{\"internalType\":\"bytes28\",\"name\":\"name\",\"type\":\"bytes28\"},{\"internalType\":\"bytes2[4]\",\"name\":\"positions\",\"type\":\"bytes2[4]\"},{\"internalType\":\"bytes8[7]\",\"name\":\"initialPalettes\",\"type\":\"bytes8[7]\"},{\"internalType\":\"bytes\",\"name\":\"IDAT\",\"type\":\"bytes\"}],\"name\":\"ownerCreateAccessory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPriceWei\",\"type\":\"uint256\"}],\"name\":\"setAccessoryPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[100]\",\"name\":\"eligibleList\",\"type\":\"bytes32[100]\"}],\"name\":\"setEligibleList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"metabyte\",\"type\":\"uint8\"}],\"name\":\"setMetaByte\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"setReferralFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"toggleEligibleList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAccessories\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accessoryId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferAccessoryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawForeignERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawForeignERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MoonCatAccessories","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://01a3f04d7fcae1dc1d847527809bb1c1ca6c826ccf153571c48e40e4e7b3807a"}]}