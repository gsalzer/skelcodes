{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.4;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n    @title Interface for handler that handles generic deposits and deposit executions.\r\n    @author ChainSafe Systems.\r\n */\r\ninterface IGenericHandler {\r\n    /**\r\n        @notice Correlates {resourceID} with {contractAddress}, {depositFunctionSig}, and {executeFunctionSig}.\r\n        @param resourceID ResourceID to be used when making deposits.\r\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\r\n        @param depositFunctionSig Function signature of method to be called in {contractAddress} when a deposit is made.\r\n        @param depositFunctionDepositerOffset Depositer address position offset in the metadata, in bytes.\r\n        @param executeFunctionSig Function signature of method to be called in {contractAddress} when a deposit is executed.\r\n     */\r\n    function setResource(\r\n        bytes32 resourceID,\r\n        address contractAddress,\r\n        bytes4 depositFunctionSig,\r\n        uint depositFunctionDepositerOffset,\r\n        bytes4 executeFunctionSig) external;\r\n}\r\n\r\n/**\r\n    @title Handles generic deposits and deposit executions.\r\n    @author ChainSafe Systems.\r\n    @notice This contract is intended to be used with the Bridge contract.\r\n */\r\ncontract GenericHandler is IGenericHandler {\r\n    address public _bridgeAddress;\r\n\r\n    struct DepositRecord {\r\n        uint8   _destinationChainID;\r\n        address _depositer;\r\n        bytes32 _resourceID;\r\n        bytes   _metaData;\r\n    }\r\n\r\n    // depositNonce => Deposit Record\r\n    mapping (uint8 => mapping(uint64 => DepositRecord)) public _depositRecords;\r\n\r\n    // resourceID => contract address\r\n    mapping (bytes32 => address) public _resourceIDToContractAddress;\r\n\r\n    // contract address => resourceID\r\n    mapping (address => bytes32) public _contractAddressToResourceID;\r\n\r\n    // contract address => deposit function signature\r\n    mapping (address => bytes4) public _contractAddressToDepositFunctionSignature;\r\n\r\n    // contract address => depositer address position offset in the metadata\r\n    mapping (address => uint256) public _contractAddressToDepositFunctionDepositerOffset;\r\n \r\n    // contract address => execute proposal function signature\r\n    mapping (address => bytes4) public _contractAddressToExecuteFunctionSignature;\r\n\r\n    // token contract address => is whitelisted\r\n    mapping (address => bool) public _contractWhitelist;\r\n\r\n    modifier onlyBridge() {\r\n        _onlyBridge();\r\n        _;\r\n    }\r\n\r\n    function _onlyBridge() private {\r\n        require(msg.sender == _bridgeAddress, \"sender must be bridge contract\");\r\n    }\r\n\r\n    /**\r\n        @param bridgeAddress Contract address of previously deployed Bridge.\r\n        @param initialResourceIDs Resource IDs used to identify a specific contract address.\r\n        These are the Resource IDs this contract will initially support.\r\n        @param initialContractAddresses These are the addresses the {initialResourceIDs} will point to, and are the contracts that will be\r\n        called to perform deposit and execution calls.\r\n        @param initialDepositFunctionSignatures These are the function signatures {initialContractAddresses} will point to,\r\n        and are the function that will be called when executing {deposit}\r\n        @param initialDepositFunctionDepositerOffsets These are the offsets of depositer positions, inside of metadata used to call\r\n        {initialContractAddresses} when executing {deposit}\r\n        @param initialExecuteFunctionSignatures These are the function signatures {initialContractAddresses} will point to,\r\n        and are the function that will be called when executing {executeProposal}\r\n\r\n        @dev {initialResourceIDs}, {initialContractAddresses}, {initialDepositFunctionSignatures},\r\n        and {initialExecuteFunctionSignatures} must all have the same length. Also,\r\n        values must be ordered in the way that that index x of any mentioned array\r\n        must be intended for value x of any other array, e.g. {initialContractAddresses}[0]\r\n        is the intended address for {initialDepositFunctionSignatures}[0].\r\n     */\r\n    constructor(\r\n        address          bridgeAddress,\r\n        bytes32[] memory initialResourceIDs,\r\n        address[] memory initialContractAddresses,\r\n        bytes4[]  memory initialDepositFunctionSignatures,\r\n        uint256[] memory initialDepositFunctionDepositerOffsets,\r\n        bytes4[]  memory initialExecuteFunctionSignatures\r\n    ) public {\r\n        require(initialResourceIDs.length == initialContractAddresses.length,\r\n            \"initialResourceIDs and initialContractAddresses len mismatch\");\r\n\r\n        require(initialContractAddresses.length == initialDepositFunctionSignatures.length,\r\n            \"provided contract addresses and function signatures len mismatch\");\r\n\r\n        require(initialDepositFunctionSignatures.length == initialExecuteFunctionSignatures.length,\r\n            \"provided deposit and execute function signatures len mismatch\");\r\n\r\n        require(initialDepositFunctionDepositerOffsets.length == initialExecuteFunctionSignatures.length,\r\n            \"provided depositer offsets and function signatures len mismatch\");\r\n\r\n        _bridgeAddress = bridgeAddress;\r\n\r\n        for (uint256 i = 0; i < initialResourceIDs.length; i++) {\r\n            _setResource(\r\n                initialResourceIDs[i],\r\n                initialContractAddresses[i],\r\n                initialDepositFunctionSignatures[i],\r\n                initialDepositFunctionDepositerOffsets[i],\r\n                initialExecuteFunctionSignatures[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @param depositNonce This ID will have been generated by the Bridge contract.\r\n        @param destId ID of chain deposit will be bridged to.\r\n        @return DepositRecord which consists of:\r\n        - _destinationChainID ChainID deposited tokens are intended to end up on.\r\n        - _resourceID ResourceID used when {deposit} was executed.\r\n        - _depositer Address that initially called {deposit} in the Bridge contract.\r\n        - _metaData Data to be passed to method executed in corresponding {resourceID} contract.\r\n    */\r\n    function getDepositRecord(uint64 depositNonce, uint8 destId) external view returns (DepositRecord memory) {\r\n        return _depositRecords[destId][depositNonce];\r\n    }\r\n\r\n    /**\r\n        @notice First verifies {_resourceIDToContractAddress}[{resourceID}] and\r\n        {_contractAddressToResourceID}[{contractAddress}] are not already set,\r\n        then sets {_resourceIDToContractAddress} with {contractAddress},\r\n        {_contractAddressToResourceID} with {resourceID},\r\n        {_contractAddressToDepositFunctionSignature} with {depositFunctionSig},\r\n        {_contractAddressToDepositFunctionDepositerOffset} with {depositFunctionDepositerOffset},\r\n        {_contractAddressToExecuteFunctionSignature} with {executeFunctionSig},\r\n        and {_contractWhitelist} to true for {contractAddress}.\r\n        @param resourceID ResourceID to be used when making deposits.\r\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\r\n        @param depositFunctionSig Function signature of method to be called in {contractAddress} when a deposit is made.\r\n        @param depositFunctionDepositerOffset Depositer address position offset in the metadata, in bytes.\r\n        @param executeFunctionSig Function signature of method to be called in {contractAddress} when a deposit is executed.\r\n     */\r\n    function setResource(\r\n        bytes32 resourceID,\r\n        address contractAddress,\r\n        bytes4 depositFunctionSig,\r\n        uint256 depositFunctionDepositerOffset,\r\n        bytes4 executeFunctionSig\r\n    ) external onlyBridge override {\r\n\r\n        _setResource(resourceID, contractAddress, depositFunctionSig, depositFunctionDepositerOffset, executeFunctionSig);\r\n    }\r\n\r\n    /**\r\n        @notice A deposit is initiatied by making a deposit in the Bridge contract.\r\n        @param destinationChainID Chain ID deposit is expected to be bridged to.\r\n        @param depositNonce This value is generated as an ID by the Bridge contract.\r\n        @param depositer Address of the account making deposit in the Bridge contract.\r\n        @param data Consists of: {resourceID}, {lenMetaData}, and {metaData} all padded to 32 bytes.\r\n        @notice Data passed into the function should be constructed as follows:\r\n        len(data)                              uint256     bytes  0  - 32\r\n        data                                   bytes       bytes  64 - END\r\n        @notice {contractAddress} is required to be whitelisted\r\n        @notice If {_contractAddressToDepositFunctionSignature}[{contractAddress}] is set,\r\n        {metaData} is expected to consist of needed function arguments.\r\n     */\r\n    function deposit(bytes32 resourceID, uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) external onlyBridge {\r\n        uint256      lenMetadata;\r\n        bytes memory metadata;\r\n\r\n        lenMetadata = abi.decode(data, (uint256));\r\n        metadata = bytes(data[32:32 + lenMetadata]);\r\n        \r\n        address contractAddress = _resourceIDToContractAddress[resourceID];\r\n        uint256 depositerOffset = _contractAddressToDepositFunctionDepositerOffset[contractAddress];\r\n        if (depositerOffset > 0) {\r\n            uint256 metadataDepositer;\r\n            // Skipping 32 bytes of length prefix and depositerOffset bytes.\r\n            assembly {\r\n                metadataDepositer := mload(add(add(metadata, 32), depositerOffset))\r\n            }\r\n            // metadataDepositer contains 0xdepositerAddressdepositerAddressdeposite************************\r\n            // Shift it 12 bytes right:   0x000000000000000000000000depositerAddressdepositerAddressdeposite\r\n            require(depositer == address(metadataDepositer >> 96), 'incorrect depositer in the data');\r\n        }\r\n\r\n        require(_contractWhitelist[contractAddress], \"provided contractAddress is not whitelisted\");\r\n\r\n        bytes4 sig = _contractAddressToDepositFunctionSignature[contractAddress];\r\n        if (sig != bytes4(0)) {\r\n            bytes memory callData = abi.encodePacked(sig, metadata);\r\n            (bool success,) = contractAddress.call(callData);\r\n            require(success, \"call to contractAddress failed\");\r\n        }\r\n\r\n        _depositRecords[destinationChainID][depositNonce] = DepositRecord(\r\n            destinationChainID,\r\n            depositer,\r\n            resourceID,\r\n            metadata\r\n        );\r\n    }\r\n\r\n    /**\r\n        @notice Proposal execution should be initiated when a proposal is finalized in the Bridge contract.\r\n        @param data Consists of {resourceID}, {lenMetaData}, and {metaData}.\r\n        @notice Data passed into the function should be constructed as follows:\r\n        len(data)                              uint256     bytes  0  - 32\r\n        data                                   bytes       bytes  32 - END\r\n        @notice {contractAddress} is required to be whitelisted\r\n        @notice If {_contractAddressToExecuteFunctionSignature}[{contractAddress}] is set,\r\n        {metaData} is expected to consist of needed function arguments.\r\n     */\r\n    function executeProposal(bytes32 resourceID, bytes calldata data) external onlyBridge {\r\n        uint256      lenMetadata;\r\n        bytes memory metaData;\r\n\r\n        lenMetadata = abi.decode(data, (uint256)); \r\n        metaData = bytes(data[32:32 + lenMetadata]);\r\n\r\n        address contractAddress = _resourceIDToContractAddress[resourceID];\r\n        require(_contractWhitelist[contractAddress], \"provided contractAddress is not whitelisted\");\r\n\r\n        bytes4 sig = _contractAddressToExecuteFunctionSignature[contractAddress];\r\n        if (sig != bytes4(0)) {\r\n            bytes memory callData = abi.encodePacked(sig, metaData);\r\n            (bool success,) = contractAddress.call(callData);\r\n            require(success, \"delegatecall to contractAddress failed\");\r\n        }\r\n    }\r\n\r\n    function _setResource(\r\n        bytes32 resourceID,\r\n        address contractAddress,\r\n        bytes4 depositFunctionSig,\r\n        uint256 depositFunctionDepositerOffset,\r\n        bytes4 executeFunctionSig\r\n    ) internal {\r\n        _resourceIDToContractAddress[resourceID] = contractAddress;\r\n        _contractAddressToResourceID[contractAddress] = resourceID;\r\n        _contractAddressToDepositFunctionSignature[contractAddress] = depositFunctionSig;\r\n        _contractAddressToDepositFunctionDepositerOffset[contractAddress] = depositFunctionDepositerOffset;\r\n        _contractAddressToExecuteFunctionSignature[contractAddress] = executeFunctionSig;\r\n\r\n        _contractWhitelist[contractAddress] = true;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridgeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"initialResourceIDs\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"initialContractAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"initialDepositFunctionSignatures\",\"type\":\"bytes4[]\"},{\"internalType\":\"uint256[]\",\"name\":\"initialDepositFunctionDepositerOffsets\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"initialExecuteFunctionSignatures\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_bridgeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_contractAddressToDepositFunctionDepositerOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_contractAddressToDepositFunctionSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_contractAddressToExecuteFunctionSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_contractAddressToResourceID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_contractWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"_depositRecords\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"_destinationChainID\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_depositer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_metaData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_resourceIDToContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"destinationChainID\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"depositer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"destId\",\"type\":\"uint8\"}],\"name\":\"getDepositRecord\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"_destinationChainID\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_depositer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_metaData\",\"type\":\"bytes\"}],\"internalType\":\"struct GenericHandler.DepositRecord\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"depositFunctionSig\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"depositFunctionDepositerOffset\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"executeFunctionSig\",\"type\":\"bytes4\"}],\"name\":\"setResource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GenericHandler","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000682642d18ebb4bb5e759af07a7de4eadae8e8c500000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"constantinople","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://675f116492fa707c91661ae0a844789ac82898302b47cacd58860a3511a16202"}]}