{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^ 0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract Oracle{\r\n\taddress ORACLE = address(0); //\r\n\taddress address0 = address(0);\r\n\r\n\tstruct RequestTicket{\r\n\t\tuint ID;\r\n\t\taddress sender;\r\n\t\tuint timeRequested;\r\n\t\tuint timeWindow;\r\n\t\tbool finalized;\r\n\t\tuint serviceFee;\r\n\t\tbool subjective;\r\n\r\n\t\tmapping(address => mapping(address => bool)) attacks;\r\n\t\tmapping(address => bool) damaged;\r\n\r\n\t\tuint8 dataType; // string, uint, bool, address\r\n\r\n\t\t//commit\r\n\t\tmapping(address => bool) committed;\r\n\t\tmapping(address => bytes32) commitHash;\r\n\r\n\t\t//reveal\r\n\t\tmapping(address => bool) revealed;\r\n\t\tmapping(address => bool) rejected;\r\n\t\tmapping(address => bool) voted;\r\n\r\n\t\tmapping(address => string) stringVotes;\r\n\t\tmapping(address => int) intVotes;\r\n\t\tmapping(address => bytes) bytesVotes;\r\n\t\tmapping(address => address) addressVotes;\r\n\r\n\t\t//RESULTS\r\n\t\tbool ticketRejected;\r\n\t\tuint numberOfOptions;\r\n\t\t\r\n\t\t//results\r\n\t\tmapping(uint => uint) weightOfResults;\r\n\t\tmapping(uint => string) resolvedStrings;\r\n\t\tmapping(uint => int) resolvedInts;\r\n\t\tmapping(uint => bytes) resolvedBytes;\r\n\t\tmapping(uint => address) resolvedAddresses;\r\n\t}\r\n\r\n\t//oracle configs\r\n\tuint constant ROUNDTABLE_SEATS = 0;\r\n\tuint constant RESPONSE_TIME_WINDOW = 1;\r\n\tuint constant DELEGATE_REWARDSHARE = 2;\r\n\tuint constant FREEZE_TIMEOUT = 3;\r\n\tuint constant SERVICE_FEE = 4;\r\n\tuint constant TX_FEE_PER = 5;\r\n\tuint constant CONFIGS = 6;\r\n\r\n\tuint[] public oracleConfigurations = new uint[](CONFIGS);\r\n\tmapping(uint/*configID*/ => mapping(uint => uint) ) public totalVotes_forEach_configOption;\r\n\tmapping(uint/*configID*/ => mapping(address => uint) ) public individualsSelectedOption;\r\n\t\r\n\tmapping(address => uint) resolveWeight;\r\n\tmapping(address => uint) weightLocked;\r\n\t\r\n\tmapping(uint => RequestTicket) requestTickets;\r\n\tuint requestTicketCount;\r\n\t//ROUND TABLE & Candidates\r\n\tmapping(uint => address) public chairsCandidate; // only looks at the first X indexes\r\n\tmapping(address => uint) candidatesChair;\r\n\tmapping(address => uint) timeSeated; // watchers aren't responsible for requestTickets that came in before them\r\n\tmapping(address => bool) frozen;\r\n\tmapping(address => uint) latestPunishment;\r\n\tmapping(address => uint) timeWhenThawedOut;\r\n\tmapping(address => bool) paused; // self pause\r\n\tmapping(address => bool) hasChair;\r\n\tuint chairs;\r\n\tuint public hotSeats;\r\n\r\n\tuint256 constant scaleFactor = 0x10000000000000000;\r\n\t//PAYROLL\r\n\tmapping(address => uint) earnings;\r\n\tmapping(address => uint) totalShares;\r\n    mapping(address => mapping(address => uint256)) public shares;\r\n    mapping(address => mapping(address => uint256)) payouts;\r\n    mapping(address => uint) earningsPerShare;\r\n\r\n    //Tx Coverage fee\r\n    uint earningsPerWatcher;\r\n\tuint public totalWatchers;\r\n\tmapping(address => uint256) watcherPayouts;\r\n\r\n\r\n    //lazy UI data\r\n    mapping(address => address[]) public yourBacking;\r\n    mapping(address => mapping(address => bool)) public alreadyBacking;\r\n    \r\n\tResolveToken public resolveToken;\r\n\taddress payable pineapples;\r\n\tPyramid public pyramid = Pyramid(0x91683899ed812C1AC49590779cb72DA6BF7971fE);\r\n\tGreenpoint greenpoint = Greenpoint(0x8dB802D64f97dC6BDE4eE9e8C1aecC64d3E7c028);\r\n\tuint genesis;\r\n\t\r\n\tconstructor() public{\r\n\t\tresolveToken = pyramid.resolveToken();\r\n\t\tgenesis = block.timestamp;\r\n\t\tpineapples = msg.sender;\r\n\t}\r\n\r\n\tfunction addressPayable(address addr) public pure returns(address payable){\r\n\t\treturn address( uint160(addr) );\r\n\t}\r\n\r\n\tfunction addShares(address pool, address account, uint amount) internal{\r\n\t\tupdate(pool, account);\r\n\t\ttotalShares[pool] += amount;\r\n\t\tshares[pool][account] += amount;\r\n\r\n\t\tif(pool == ORACLE){\r\n\t\t\tupdateWatcherTxEarnings(account,false);\r\n\t\t\tif (account != address0)\r\n\t\t\t\ttotalWatchers += 1;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removeShares(address pool, address account, uint amount) internal{\r\n\t\tupdate(pool, account);\r\n\t\ttotalShares[pool] -= amount;\r\n\t\tshares[pool][account] -= amount;\r\n\r\n\t\tif(pool == ORACLE){\r\n\t\t\tupdateWatcherTxEarnings(account,true);\r\n\t\t\tif (account != address0)\r\n\t\t\t\ttotalWatchers -= 1;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction dividendsOf(address pool, address account) public view returns(uint){\r\n\t\tuint owedPerShare = earningsPerShare[pool] - payouts[pool][account];\r\n\t\tif(pool == ORACLE && !isWatcher(account))\r\n\t\t\treturn 0;\r\n\t\treturn shares[pool][account] * owedPerShare / scaleFactor;\r\n\t}\r\n\t\r\n\t\r\n\tevent WatcherPayroll(address watcher, uint paidOut);\t\r\n\tfunction update(address pool, address account) internal {\r\n\t\tuint newMoney = dividendsOf(pool, account);\r\n        payouts[pool][account] = earningsPerShare[pool];\r\n\r\n\t\tif(pool == ORACLE){\r\n\t\t\tuint eth4Watcher = newMoney * oracleConfigurations[DELEGATE_REWARDSHARE] / (1e20);\r\n\t\t\tearnings[account] += eth4Watcher;\r\n\r\n\t\t\tuint newDivs;\r\n\t\t\tif(totalShares[account]>0){\r\n\t\t\t\tnewDivs = (newMoney - eth4Watcher) * scaleFactor / totalShares[account];\r\n\t\t\t}else{\r\n\t\t\t\tnewDivs = 0;\r\n\t\t\t}\r\n\r\n\t\t\tearningsPerShare[account/*this is what the watcher has to distribute to its electorates*/] += newDivs;\r\n\t\t}else{\r\n\t\t\tearnings[account] += newMoney;\r\n\t\t}\r\n    }\r\n\r\n\tevent TxCashout(address watcher, uint amount);\r\n\tfunction updateWatcherTxEarnings(address watcher, bool paying) internal {\r\n\t\tuint owed = earningsPerWatcher - watcherPayouts[watcher];\r\n\t\twatcherPayouts[watcher] = earningsPerWatcher;\r\n\t\tif(paying) earnings[watcher] += owed;\r\n\t\temit TxCashout(watcher, owed);\r\n    }\r\n\r\n    mapping(address => bool) notNew;\r\n\tevent StakeResolves( address indexed addr, uint256 amountStaked, bytes _data );\r\n\tfunction tokenFallback(address from, uint value, bytes calldata _data) external{\r\n\t\tif( msg.sender == address(resolveToken) ){\r\n\t\t\tif(from == address(pyramid)){\r\n\t\t\t\treturn;// if the pyramid is sending resolve tokens back to this contract, then do nothing.\r\n\t\t\t}\r\n\t\t\tresolveWeight[from] += value;\r\n\t\t\t//update option totals\r\n\t\t\tuint option;\r\n\t\t\tif(notNew[from]){\r\n\t\t\t\tfor(uint8 config = 0; config<CONFIGS; config+=1){\r\n\t\t\t\t\toption = individualsSelectedOption[config][from];\r\n\t\t\t\t\ttotalVotes_forEach_configOption[config][option] += value;\r\n\t\t\t\t\tassertOption(config, option);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tnotNew[from] = true;\r\n\t\t\t\tfor(uint8 config = 0; config<CONFIGS; config+=1){\r\n\t\t\t\t\toption = oracleConfigurations[config];\r\n\t\t\t\t\tindividualsSelectedOption[config][from] = option;\r\n\t\t\t\t\ttotalVotes_forEach_configOption[config][option] += value;\r\n\t\t\t\t\tassertOption(config, option);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\temit StakeResolves(from, value, _data);\r\n\t\t\t\r\n\t\t\taddress backImmediately = bytesToAddress( _data );\r\n\r\n\t\t\tif( backImmediately != address0){\r\n\t\t\t\tbackCandidate(from, backImmediately, value);\r\n\t\t\t}\r\n\r\n\t\t\tresolveToken.transfer( address(pyramid), value);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tevent UnstakeResolves(address sender, uint amount);\r\n\tfunction unstakeResolves(uint amount) public{\r\n\t\taddress sender = msg.sender;\r\n\t\tif( amount <= ( resolveWeight[sender] - weightLocked[sender] ) ){\r\n\t\t\tresolveWeight[sender] -= amount;\r\n\t\t\tfor(uint config = 0; config<CONFIGS; config+=1){\r\n\t\t\t\ttotalVotes_forEach_configOption[config][individualsSelectedOption[config][sender]] -= amount;\r\n\t\t\t}\r\n\r\n\t\t\temit UnstakeResolves(sender, amount);\r\n\t\t\tpyramid.pullResolves(amount);\r\n\r\n\t\t\tresolveToken.transfer(sender, amount);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tevent BackCandidate(address sender,address candidate, uint amount);\r\n\tfunction stakeCandidate(address candidate, uint amount) public{ backCandidate(msg.sender, candidate, amount); }\r\n\tfunction backCandidate(address sender, address candidate, uint amount) internal{\r\n\t\trequire(candidate!=ORACLE);\r\n\t\tif( amount <= ( resolveWeight[sender] - weightLocked[sender] ) && !frozen[candidate] && !isWatcher(candidate) ){\r\n\t\t\tweightLocked[sender] += amount;\r\n\t\t\taddShares(candidate, sender, amount);\r\n\r\n\t\t\temit BackCandidate(sender, candidate, amount);\r\n\t\t\t//LAZY U.I.\r\n\t\t\tif(!alreadyBacking[sender][candidate]){\r\n\t\t\t\tyourBacking[sender].push(candidate);\r\n\t\t\t\talreadyBacking[sender][candidate] = true;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\t\r\n\t}\r\n\t\r\n\tevent PullBacking(address sender, address candidate, uint amount);\r\n\tfunction pullBacking( address candidate, uint amount ) public{\r\n\t\taddress sender = msg.sender;\r\n\t\tif( amount <= shares[candidate][sender] && !frozen[candidate] && ( !(candidatesChair[candidate]<hotSeats) || paused[candidate] ) ){\r\n\t\t\tweightLocked[sender] -= amount;\r\n\t\t\tremoveShares(candidate, sender, amount);\r\n\t\t\temit PullBacking(sender, candidate, amount);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction pullAllTheWay(address candidate, uint amount) public{\r\n\t\tpullBacking(candidate, amount);\r\n\t\tunstakeResolves(amount);\r\n\t}\r\n\t\r\n\tfunction frausted(address candidate) public view returns(bool){\r\n\t\treturn paused[candidate] || frozen[candidate];\r\n\t}\r\n\r\n\tevent AssertCandidate(address candidate, bool successfulAssert, address replacedWatcher, uint newSeat);\r\n\tfunction assertCandidate() public returns(bool success){\r\n\t\taddress candidate = msg.sender;\r\n\t\tuint weakestChair;\r\n\t\tbool nullSeat;\r\n\t\trequire( !frausted(candidate) && hotSeats > 0);\r\n\t\taddress thisWatcher;\r\n\r\n\t\tfor(uint i; i<hotSeats; i+=1){\r\n\t\t\tthisWatcher = chairsCandidate[i];\r\n\t\t\tif( frausted( thisWatcher ) || thisWatcher == address0 ){\r\n\t\t\t\tnullSeat = true;\r\n\t\t\t\tweakestChair = i;\r\n\t\t\t}else if( totalShares[ thisWatcher ] < totalShares[ chairsCandidate[weakestChair] ] ){\r\n\t\t\t\tweakestChair = i;\r\n\t\t\t}\r\n\t\t\tif(nullSeat){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif( (totalShares[candidate] > totalShares[ chairsCandidate[weakestChair] ] || nullSeat ) && !isWatcher(candidate) ){\r\n\t\t\taddress targetCandidate = chairsCandidate[weakestChair];\r\n\r\n\t\t\tif(targetCandidate!=address0)\r\n\t\t\t\tremoveShares(ORACLE, targetCandidate, totalShares[targetCandidate]);\r\n\t\t\taddShares(ORACLE, candidate, totalShares[candidate]);\t\r\n\t\t\ttimeSeated[candidate] = now;\r\n\t\t\t\r\n\t\t\thasChair[candidate] = true;\r\n\t\t\thasChair[targetCandidate] = false;\r\n\r\n\t\t\tchairsCandidate[weakestChair] = candidate; \r\n\t\t\tcandidatesChair[candidate] = weakestChair;\r\n\r\n\t\t\temit AssertCandidate(candidate, true, targetCandidate, weakestChair);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\temit AssertCandidate(candidate, false, address0, weakestChair);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tevent OptionVote(address sender, uint config, uint option, uint weight);\r\n\tfunction optionVote(bool[] memory isModifying, uint[] memory modifiedOptions) public{\r\n\t\taddress sender = msg.sender;\r\n\t\tuint config;\r\n\t\tuint modifiedOption;\r\n\t\tnotNew[sender] = true;\r\n\t\tfor(config = 0; config<CONFIGS; config+=1){\r\n\t\t\tif(isModifying[config]){\r\n\t\t\t\tmodifiedOption = modifiedOptions[config];\r\n\t\t\t\ttotalVotes_forEach_configOption[config][ individualsSelectedOption[config][sender] ] -= resolveWeight[sender];\r\n\t\t\t\tindividualsSelectedOption[config][sender] = modifiedOption;\r\n\t\t\t\ttotalVotes_forEach_configOption[config][ modifiedOption ] += resolveWeight[sender];\r\n\t\t\t\temit OptionVote(sender, config, modifiedOption, resolveWeight[sender]);\r\n\t\t\t\tassertOption( config, modifiedOption );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent AssertOption(uint config, uint option);\r\n\tfunction assertOption(uint config, uint option) public{\r\n\t\tif( totalVotes_forEach_configOption[config][option] > totalVotes_forEach_configOption[config][ oracleConfigurations[config] ] ){\r\n\t\t\tif(config == RESPONSE_TIME_WINDOW){ option = option>60?option:(60); }\r\n\t\t\tif(config == ROUNDTABLE_SEATS){ option = option>5?option:(5); }\r\n\t\t\tif(config == DELEGATE_REWARDSHARE){ option = option>1e20?1e20:option; }\r\n\t\t\toracleConfigurations[config] = option;\r\n\t\t\temit AssertOption(config, option);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction isWatcher(address candidate) public view returns(bool){\r\n\t\treturn candidatesChair[candidate]<hotSeats && hasChair[candidate] && !frausted(candidate);\r\n\t}\r\n\r\n\tfunction getFee() public view returns(uint txCoverageFee, uint serviceFee){\r\n\t\tuint activeWatchers;\r\n\t\tfor(uint chair = 0; chair<hotSeats; chair+=1){\r\n\t\t\tif( !frausted(chairsCandidate[chair]) && chairsCandidate[chair]!=address0 ){\r\n\t\t\t\tactiveWatchers += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ( oracleConfigurations[TX_FEE_PER]*activeWatchers, oracleConfigurations[SERVICE_FEE] );\r\n\t}\r\n\r\n\tuint public devFunds;\r\n\tfunction updatePines(address addr) public{\r\n\t\trequire(msg.sender == pineapples);\r\n\t\tpineapples = payable(addr);\r\n\t}\r\n\r\n\tbool acreLock;\r\n\tfunction updateACRE(address addr, bool lock) public{\r\n\t\trequire(msg.sender == pineapples && !acreLock);\r\n\t\tgreenpoint = Greenpoint(addr);\r\n\t\tacreLock = lock;\r\n\t}\r\n\r\n\tfunction devPull() public{\r\n\t\trequire(msg.sender == pineapples);\r\n\t\tuint money = devFunds;\r\n\t\tdevFunds = 0;\r\n\t\tgreenpoint.payEthToAcreStakers{value: money/2 }();\r\n\t\tmsg.sender.transfer( money-money/2 );\r\n\t}\r\n\r\n\t//------------------------------ Request Ticket Life Cycle\r\n\tevent FileRequestTicket(address sender, uint ticketID, uint8 dataType, bool subjective, uint timeRequested, uint responseTimeWindow, uint feePaid);\r\n\tfunction fileRequestTicket( uint8 returnType, bool subjective) external payable returns(uint ticketID){\r\n\t\tuint ETH = msg.value;\r\n\t\t(uint txCoverageFee, uint serviceFee) = getFee();\r\n\r\n\t\tuint devFee = ( (block.timestamp - genesis) < 86400*365 )?(serviceFee/20):0;\r\n\r\n\t\tif(ETH - devFee >= txCoverageFee + serviceFee){\r\n\t\t\tif(returnType>3) returnType = 3;\r\n\r\n\t\t\tticketID = requestTicketCount;\r\n\t\t\tRequestTicket storage ticket = requestTickets[requestTicketCount];\r\n\t\t\trequestTicketCount++;\r\n\r\n\t\t\tticket.dataType = returnType;\r\n\t\t\tticket.timeRequested = now;\r\n\t\t\tticket.timeWindow = oracleConfigurations[RESPONSE_TIME_WINDOW];\r\n\t\t\tticket.ID = ticketID;\r\n\t\t\tticket.sender = msg.sender;\r\n\t\t\tticket.subjective = subjective;\r\n\t\t\tticket.serviceFee = ETH - devFee - txCoverageFee;\r\n\t\t\tdevFunds += devFee;\r\n\t\t\tearningsPerWatcher += txCoverageFee / totalWatchers;\r\n\r\n\t\t\temit FileRequestTicket(msg.sender, ticketID, returnType, subjective, now, ticket.timeWindow, ETH);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tevent CommitVote(address voter, uint ticketID, bytes32 hash);\r\n\tfunction commitVote(uint[] memory tickets, bytes32[] memory voteHashes) external{\r\n\t\taddress sender = msg.sender;\r\n\t\tRequestTicket storage ticket;\r\n\t\tfor(uint R; R<tickets.length; R+=1 ){\r\n\t\t\tticket = requestTickets[ tickets[R] ];\r\n\t\t\tif( now <= ticket.timeRequested + ticket.timeWindow ){\r\n\t\t\t\tticket.committed[sender] = true;\r\n\t\t\t\tticket.commitHash[sender] = voteHashes[R];\r\n\t\t\t\temit CommitVote(sender, tickets[R], voteHashes[R]);\r\n\t\t\t}else{\r\n\t\t\t\trevert();//outside of timewindow\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tevent RevealVote(address voter, uint ticketID, bool rejected, int intVote, bytes bytesVote, address addressVote);\r\n\tfunction revealVote(uint[] memory tickets, bool[] memory rejected, int[] memory intVotes, bytes[] memory bytesVotes, address[] memory addressVotes, string[] memory passwords) external{\r\n\t\taddress sender = msg.sender;\r\n\t\tRequestTicket memory ticket;\r\n\t\tbytes memory abiEncodePacked;\r\n\t\tfor(uint R; R<tickets.length; R+=1 ){\r\n\t\t\tticket = requestTickets[ tickets[R] ];\r\n\t\t\tif(now > ticket.timeRequested + ticket.timeWindow && now <= ticket.timeRequested + ticket.timeWindow*2 ){\r\n\t\t\t\tif(ticket.dataType == 1){\r\n\t\t\t\t\tabiEncodePacked = abi.encodePacked( rejected[R], intVotes[R], passwords[R] );\r\n\t\t\t\t}else if(ticket.dataType == 2){\r\n\t\t\t\t\tabiEncodePacked = abi.encodePacked( rejected[R], bytesVotes[R], passwords[R] );\r\n\t\t\t\t}else if(ticket.dataType == 3){\r\n\t\t\t\t\tabiEncodePacked = abi.encodePacked( rejected[R], addressVotes[R], passwords[R] );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif( compareBytes( keccak256(abiEncodePacked), requestTickets[ tickets[R] ].commitHash[sender]) ){\r\n\r\n\t\t\t\t\trequestTickets[ tickets[R] ].revealed[sender] = true;\r\n\t\t\t\t\tif(rejected[R]){\r\n\t\t\t\t\t\trequestTickets[ tickets[R] ].rejected[sender] = true;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\trequestTickets[ tickets[R] ].voted[sender] = true;\r\n\t\t\t\t\t\tif(ticket.dataType == 1){\r\n\t\t\t\t\t\t\trequestTickets[ tickets[R] ].intVotes[sender] = intVotes[R];\r\n\t\t\t\t\t\t}else if(ticket.dataType == 2){\r\n\t\t\t\t\t\t\trequestTickets[ tickets[R] ].bytesVotes[sender] = bytesVotes[R];\r\n\t\t\t\t\t\t}else if(ticket.dataType == 3){\r\n\t\t\t\t\t\t\trequestTickets[ tickets[R] ].addressVotes[sender] = addressVotes[R];\r\n\t\t\t\t\t\t}\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\temit RevealVote(sender, tickets[R], rejected[R], intVotes[R], bytesVotes[R], addressVotes[R]);\r\n\t\t\t\t}else{\r\n\t\t\t\t\trevert();//not a match\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\trevert();//outside of timewindow\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent SubjectiveStance(address voter, uint ticketID, address defender, bool stance);\r\n\tfunction subjectiveStance(uint[] memory tickets, address[] memory defenders, bool[] memory stances) external{\r\n\t\taddress sender = msg.sender;\r\n\t\tRequestTicket storage ticket;\r\n\t\tfor(uint R; R<tickets.length; R+=1 ){\r\n\t\t\tticket = requestTickets[ tickets[R] ];\r\n\t\t\tif(timeSeated[sender] <= ticket.timeRequested){\r\n\t\t\t\tif( timeSeated[defenders[R]] <= ticket.timeRequested && now > ticket.timeRequested + ticket.timeWindow*2 && now <= ticket.timeRequested + ticket.timeWindow*3 ){\r\n\t\t\t\t\tticket.attacks[sender][defenders[R]] = stances[R];\r\n\t\t\t\t\temit SubjectiveStance(sender, tickets[R], defenders[R], stances[R]);\r\n\t\t\t\t}else{\r\n\t\t\t\t\trevert();//outside timewindow\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\trevert();//you just got here homie, whatcha takin' shots for?\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction calculateDamage( uint ticketID ) internal view returns(uint combatWeight, uint[] memory damage){\r\n\t\tRequestTicket storage ticket = requestTickets[ticketID];\r\n\t\taddress offensiveWatcher;\r\n\t\taddress defender;\r\n\t\tuint Y;\r\n\t\tuint X;\r\n\t\tdamage = new uint[](hotSeats);\r\n\t\tif(ticket.subjective){\r\n\t\t\tfor(X = 0; X < hotSeats; X+=1){\r\n\t\t\t\toffensiveWatcher = chairsCandidate[X];\r\n\t\t\t\tif( isWatcher(offensiveWatcher) && timeSeated[offensiveWatcher] <= ticket.timeRequested ){\r\n\t\t\t\t\tcombatWeight += totalShares[offensiveWatcher];\r\n\t\t\t\t\tfor(Y = 0; Y < hotSeats; Y+=1){\r\n\t\t\t\t\t\tdefender = chairsCandidate[Y];\r\n\t\t\t\t\t\tif( isWatcher(defender) && timeSeated[defender] <= ticket.timeRequested){\r\n\t\t\t\t\t\t\tif(ticket.attacks[offensiveWatcher][defender]){\r\n\t\t\t\t\t\t\t\tdamage[Y] += totalShares[offensiveWatcher];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent FinalizedRequest(uint ticketID, address[] watchers);\r\n\tfunction finalizeRequests(uint[] memory tickets) external{\r\n\t\tfor(uint R; R<tickets.length; R+=1 ){\r\n\t\t\tfinalizeRequest( tickets[R] );\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction finalizeRequest(uint ticketID) public{\r\n\t\t// if responsew time window is over or all delegates have voted,\r\n\t\t// anyone can finalize the request to trigger the event\r\n\t\tRequestTicket storage ticket = requestTickets[ticketID];\r\n\t\tif(!ticket.finalized){\r\n\t\t\t\r\n\t\t\taddress watcher;\r\n\t\t\t\r\n\t\t\tint[] memory intOptions = new int[](hotSeats);\r\n\t\t\tbytes[] memory bytesOptions = new bytes[](hotSeats);\r\n\t\t\taddress[] memory addressOptions = new address[](hotSeats);\r\n\t\t\tuint[] memory optionWeights = new uint[](hotSeats);\r\n\r\n\t\t\taddress[] memory watchers = new address[](hotSeats);// lazy UI data\r\n\r\n\t\t\tuint[] memory UINTs = new uint[](7);//0= weight of votes, 1=top Option, 2= number of options, 3=top Option, 4 =total eligible weight, 5 = combat weight, 6  = loop for saving subjectives to storage\r\n\r\n\t\t\tuint opt;\r\n\t\t\tuint[] memory damage;\r\n\t\t\t(UINTs[5]/*combatWeight*/, damage) = calculateDamage(ticketID);\r\n\t\t\tfor(uint chair = 0; chair < hotSeats; chair+=1){\r\n\t\t\t\twatcher = chairsCandidate[chair];\r\n\t\t\t\twatchers[chair] = watcher;\r\n\t\t\t\tif(damage[chair]<=UINTs[5]/*combatWeight*//2){\r\n\t\t\t\t\tif( watcher!=address0 && isWatcher(watcher) && timeSeated[watcher] <= ticket.timeRequested && ticket.revealed[watcher] ){\r\n\t\t\t\t\t\tUINTs[4]/*total Eligible Weight*/ += totalShares[watcher];\r\n\t\t\t\t\t\tif( ticket.voted[watcher] ){\r\n\t\t\t\t\t\t\tUINTs[0]/*weight of votes*/ += totalShares[watcher];\r\n\t\t\t\t\t\t\t//check to see if chosen option already is accounted for, if so, add weight to it.\r\n\t\t\t\t\t\t\tfor(opt = 0; opt<UINTs[2]/*option count*/; opt+=1){\r\n\t\t\t\t\t\t\t\tif( (ticket.dataType == 1 && intOptions[opt] == ticket.intVotes[watcher]) ||\r\n\t\t\t\t\t\t\t\t\t(ticket.dataType == 2 && compareBytes( keccak256(bytesOptions[opt]), keccak256(ticket.bytesVotes[watcher]) ) ) ||\r\n\t\t\t\t\t\t\t\t\t(ticket.dataType == 3 && addressOptions[opt] == ticket.addressVotes[watcher]) \r\n\t\t\t\t\t\t\t\t){\r\n\t\t\t\t\t\t\t\t\toptionWeights[opt] += totalShares[watcher];\r\n\t\t\t\t\t\t\t\t\tif(optionWeights[opt] > optionWeights[UINTs[3]/*top option*/] && !ticket.subjective){\r\n\t\t\t\t\t\t\t\t\t\tUINTs[3]/*top option*/ = opt;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t//add new unique option\r\n\t\t\t\t\t\t\tif(opt == UINTs[2]/*option count*/){\r\n\t\t\t\t\t\t\t\tif(ticket.dataType == 1){\r\n\t\t\t\t\t\t\t\t\tintOptions[UINTs[2]/*option count*/] = ticket.intVotes[watcher];\r\n\t\t\t\t\t\t\t\t}else if(ticket.dataType == 2){\r\n\t\t\t\t\t\t\t\t\tbytesOptions[UINTs[2]/*option count*/] = ticket.bytesVotes[watcher];\r\n\t\t\t\t\t\t\t\t}else if(ticket.dataType == 3){\r\n\t\t\t\t\t\t\t\t\taddressOptions[UINTs[2]/*option count*/] = ticket.addressVotes[watcher];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\toptionWeights[UINTs[2]/*option count*/] = totalShares[watcher];\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tUINTs[2]/*option count*/+=1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else if(ticket.rejected[watcher]){\r\n\t\t\t\t\t\t\tUINTs[1]/*weight of rejections*/ += totalShares[watcher];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tticket.damaged[watcher] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif( (UINTs[4]/*total Eligible Weight*/ == (UINTs[1]/*weight of rejections*/ + UINTs[0]/*weight of votes*/) && !ticket.subjective) || (now > ticket.timeRequested + ticket.timeWindow*(ticket.subjective?3:2) ) ){\r\n\t\t\t\t\r\n\t\t\t\tbool rejected;\r\n\t\t\t\tif( UINTs[1]/*weight of rejections*/ > optionWeights[UINTs[3]/*top option*/] ){\r\n\t\t\t\t\trejected = true;\r\n\t\t\t\t}\r\n\t\t\t\tuint8 dataType = ticket.dataType;\r\n\t\t\t\t//write results in stone\r\n\t\t\t\tif(rejected){\r\n\t\t\t\t\tticket.ticketRejected = true;\r\n\t\t\t\t}else{\t\t\t\t\r\n\t\t\t\t\tif(ticket.subjective){\r\n\t\t\t\t\t\tticket.numberOfOptions = UINTs[2]/*option count*/;\r\n\t\t\t\t\t\tfor(UINTs[6]=0;UINTs[6]<UINTs[2];UINTs[6]+=1){\r\n\t\t\t\t\t\t\tticket.weightOfResults[UINTs[6]] = optionWeights[UINTs[6]];\r\n\t\t\t\t\t\t\tif(dataType == 1){\r\n\t\t\t\t\t\t\t\tticket.resolvedInts[UINTs[6]] = intOptions[UINTs[6]];\r\n\t\t\t\t\t\t\t}else if(dataType == 2){\r\n\t\t\t\t\t\t\t\tticket.resolvedBytes[UINTs[6]] = bytesOptions[UINTs[6]];\r\n\t\t\t\t\t\t\t}else if(dataType == 3){\r\n\t\t\t\t\t\t\t\tticket.resolvedAddresses[UINTs[6]] = addressOptions[UINTs[6]];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tticket.numberOfOptions = UINTs[2]==0?0:1;//just in case no one responds the number of options needs to be 0\r\n\t\t\t\t\t\tif(dataType == 1){\r\n\t\t\t\t\t\t\tticket.resolvedInts[0] = intOptions[UINTs[3]/*top option*/];\r\n\t\t\t\t\t\t}else if(dataType == 2){\r\n\t\t\t\t\t\t\tticket.resolvedBytes[0] = bytesOptions[UINTs[3]/*top option*/];\r\n\t\t\t\t\t\t}else if(dataType == 3){\r\n\t\t\t\t\t\t\tticket.resolvedAddresses[0] = addressOptions[UINTs[3]/*top option*/];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//dish out the rewards\r\n\t\t\t\tearningsPerShare[ORACLE] += ticket.serviceFee * scaleFactor / totalShares[ORACLE];\r\n\r\n\t\t\t\tticket.finalized = true;\r\n\t\t\t\tif(dataType == 1){\r\n\t\t\t\t\tRequestor(ticket.sender).oracleIntFallback(ticket.ID, ticket.ticketRejected, ticket.numberOfOptions, optionWeights, intOptions);\r\n\t\t\t\t}else if(dataType == 2){\r\n\t\t\t\t\tRequestor(ticket.sender).oracleBytesFallback(ticket.ID, ticket.ticketRejected, ticket.numberOfOptions, optionWeights, bytesOptions);\r\n\t\t\t\t}else if(dataType == 3){\r\n\t\t\t\t\tRequestor(ticket.sender).oracleAddressFallback(ticket.ID, ticket.ticketRejected, ticket.numberOfOptions, optionWeights, addressOptions);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\temit FinalizedRequest(ticket.ID, watchers);\r\n\t\t\t}else{\r\n\t\t\t\trevert();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent Cashout(address addr, uint ETH);\r\n\tfunction cashout(address[] memory pools) external{\r\n\t\taddress payable sender = msg.sender;\r\n\t\tfor(uint p; p < pools.length; p+=1){\r\n\t\t\tupdate(pools[p], sender);\r\n\t\t}\r\n\t\trunWatcherPayroll(sender);\r\n\t\tuint ETH = earnings[sender];\r\n\t\tearnings[sender] = 0;\r\n\t\temit Cashout(sender, ETH);\r\n\t\tsender.transfer( ETH );\r\n\t}\r\n\r\n\tfunction runWatcherPayroll(address watcher) public{\r\n\t\tif( isWatcher(watcher) ){\r\n\t\t\tupdate(ORACLE, watcher );\r\n\t\t\tupdateWatcherTxEarnings( watcher, true );\r\n\t\t}\r\n\t}\r\n\r\n\tfunction tryToPunish(uint[] memory tickets, address[] memory watchers) external{\r\n\t\tfreezeNoncommits(tickets, watchers);\r\n\t\tfreezeUnrevealedCommits(tickets, watchers);\r\n\t\tfreezeWrongWatchers(tickets, watchers);\r\n\t}\r\n\r\n\tevent FreezeNoncommits(uint ticketID, address watcher);\r\n\tfunction freezeNoncommits(uint[] memory tickets, address[] memory watchers) public{\r\n\t\t// get them while they're still at the round table and we're in the reveal phase of a ticket\r\n\t\tRequestTicket storage ticket;\r\n\t\tfor(uint i; i<watchers.length; i+=1){\r\n\t\t\tticket = requestTickets[ tickets[i] ];\r\n\t\t\tif( isWatcher( watchers[i] ) &&\r\n\t\t\t\t!ticket.committed[ watchers[i] ] &&\r\n\t\t\t\ttimeSeated[ watchers[i] ] <= ticket.timeRequested &&\r\n\t\t\t\tnow > ticket.timeRequested + ticket.timeWindow\r\n\t\t\t){\r\n\t\t\t\tif(punish(tickets[i] , watchers[i]) ){\r\n\t\t\t\t\temit FreezeNoncommits(tickets[i] , watchers[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tevent FreezeUnrevealedCommits(uint ticketID, address watcher);\r\n\tfunction freezeUnrevealedCommits(uint[] memory tickets, address[] memory watchers) public{\r\n\t\t// get them if they made a commit, but did not reveal it after the reveal window is over\r\n\t\tRequestTicket storage ticket;\r\n\t\tfor(uint i; i<watchers.length; i+=1){\r\n\t\t    ticket = requestTickets[ tickets[i] ];\r\n\t\t\tif( ticket.committed[ watchers[i] ] &&\r\n\t\t\t\t!ticket.revealed[ watchers[i] ] &&\r\n\t\t\t\tnow > requestTickets[ tickets[i] ].timeRequested + ticket.timeWindow*2\r\n\t\t\t){\r\n\t\t\t\tif(punish(tickets[i] , watchers[i]) ){\r\n\t\t\t\t\temit FreezeUnrevealedCommits(tickets[i] , watchers[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent FreezeWrongWatchers(uint ticketID, address watcher);\r\n\tfunction freezeWrongWatchers(uint[] memory tickets, address[] memory watchers) public{\r\n\t\t// get them if the ticket is finalized and their vote doesn't match the resolved answer\r\n\t\taddress watcher;\r\n\t\tRequestTicket storage ticket;\r\n\t\tfor(uint i; i<watchers.length; i+=1){\r\n\t\t\tticket = requestTickets[ tickets[i] ];\r\n\t\t\twatcher = watchers[i];\r\n\t\t\tif( ticket.finalized &&\r\n\t\t\t\tticket.committed[ watcher ] &&\r\n\t\t\t\t!ticket.ticketRejected &&\r\n\t\t\t\t(\r\n\t\t\t\t\t(!ticket.subjective && (\r\n\t\t\t\t\t\t(ticket.dataType == 1 && ticket.resolvedInts[0] != ticket.intVotes[ watcher ] )||\r\n\t\t\t\t\t\t(ticket.dataType == 2 && compareBytes( keccak256(ticket.resolvedBytes[0]), keccak256(ticket.bytesVotes[ watcher ]) ) )||\r\n\t\t\t\t\t\t(ticket.dataType == 3 && ticket.resolvedAddresses[0] != ticket.addressVotes[ watcher ] )\r\n\t\t\t\t\t))||\r\n\t\t\t\t\t(ticket.subjective && ticket.damaged[ watcher ] )||//if their subjective contribution is garbage\r\n\t\t\t\t\tticket.rejected[ watcher ]//if they reject something the majority didn't reject\r\n\t\t\t\t)\r\n\t\t\t){\r\n\t\t\t\tif(punish(tickets[i] , watcher)){\r\n\t\t\t\t\temit FreezeWrongWatchers(tickets[i] , watcher);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent Punish(address watcher, uint thawOutTime);\r\n\tfunction punish(uint ticketID, address watcher) internal returns(bool punished){\r\n\t\tRequestTicket storage ticket = requestTickets[ticketID];\r\n\t\tif(latestPunishment[watcher] < ticket.timeRequested){\r\n\t\t\tif( isWatcher(watcher) ){\r\n\t\t\t\tremoveShares(ORACLE, watcher, totalShares[watcher]);\r\n\t\t\t}\r\n\r\n\t\t\tfrozen[watcher] = true;\r\n\t\t\tlatestPunishment[watcher] = ticket.timeRequested;\r\n\t\t\ttimeWhenThawedOut[watcher] = now + oracleConfigurations[FREEZE_TIMEOUT];\r\n\r\n\t\t\temit Punish(watcher, timeWhenThawedOut[watcher]);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tevent Thaw(address candidate);\r\n\tfunction thaw(address candidate) public{\r\n\t\tif( now >= timeWhenThawedOut[candidate] && frozen[candidate] ){\r\n\t\t\tfrozen[candidate] = false;\r\n\t\t\tif( candidatesChair[candidate] < hotSeats && !paused[candidate] ){\r\n\t\t\t\taddShares(ORACLE, candidate, totalShares[candidate]);\r\n\t\t\t\ttimeSeated[candidate] = now;\r\n\t\t\t}\r\n\t\t\temit Thaw(candidate);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tevent PauseOut(address sender);\r\n\tfunction pauseOut() public{\r\n\t\taddress sender = msg.sender;\r\n\t\tif(isWatcher(sender)){\r\n\t\t\tremoveShares(ORACLE, sender, totalShares[sender]);\r\n\t\t}\r\n\t\tpaused[sender] = true;\r\n\t\temit PauseOut(sender);\r\n\t}\r\n\r\n\tevent Unpause(address sender);\r\n\tfunction unpause(bool _assert) public{\r\n\t\taddress sender = msg.sender;\r\n\t\tpaused[sender] = false;\r\n\t\tif( candidatesChair[sender] < hotSeats){\r\n\t\t\tif(!frozen[sender])\r\n\t\t\t\taddShares(ORACLE, sender, totalShares[sender]);\r\n\t\t\t//timeSeated[sender] = now; //this refreshes when they sat down. so they lose responsibility for old tickets.\r\n\t\t}else if( _assert ){\r\n\t\t\tassertCandidate();\r\n\t\t}\r\n\t\temit Unpause(sender);\r\n\t\t\r\n\t}\r\n\r\n\tevent UpdateRoundTable(uint newTotalHotSeats);\r\n\tfunction updateRoundTable(uint seats) public{\r\n\t\t// update hotSeats up and down.\r\n\t\taddress candidate;\r\n\t\tuint s;\r\n\t\tfor( s = 0; s<seats; s+=1){\r\n\t\t\tif( oracleConfigurations[ROUNDTABLE_SEATS] > hotSeats ){\r\n\t\t\t\tcandidate = chairsCandidate[hotSeats];\r\n\t\t\t\taddShares(ORACLE, candidate, totalShares[candidate]);\r\n\t\t\t\ttimeSeated[candidate] = now;\r\n\t\t\t\thotSeats+=1;\r\n\t\t\t}\r\n\t\t\tif( oracleConfigurations[ROUNDTABLE_SEATS] < hotSeats ){\r\n\t\t\t\tcandidate = chairsCandidate[hotSeats-1];\r\n\t\t\t\tremoveShares(ORACLE, candidate, totalShares[candidate]);\r\n\t\t\t\thotSeats-=1;\r\n\t\t\t}\r\n\t\t\tif( oracleConfigurations[ROUNDTABLE_SEATS] == hotSeats ){break;}\r\n\t\t}\r\n\t\temit UpdateRoundTable(hotSeats);\r\n\t}\r\n\r\n\tfunction viewRequestTicket(uint ticketID) public view returns(\r\n\t\taddress sender,\r\n\t\tuint timeRequested,\r\n\t\tuint timeWindow,\r\n\t\tuint numberOfOptions,\r\n\t\tbool finalized,\r\n\t\tbool rejected,\r\n\t\tuint[] memory weightOfResults,\r\n\t\tint[] memory resolvedInts,\r\n\t\tbytes[] memory resolvedBytes,\r\n\t\taddress[] memory resolvedAddresses\r\n\t){\t\r\n\t\tRequestTicket storage T = requestTickets[ticketID];\r\n\t\tsender = T.sender;\r\n\t\ttimeRequested = T.timeRequested;\r\n\t\ttimeWindow = T.timeWindow;\r\n\t\tfinalized = T.finalized;\r\n\t\tnumberOfOptions = T.numberOfOptions;\r\n\t\trejected = T.ticketRejected;\r\n\r\n\t\tweightOfResults = new uint[](T.numberOfOptions);\r\n\t\tresolvedInts = new int[](T.numberOfOptions);\r\n\t\tresolvedBytes = new bytes[](T.numberOfOptions);\r\n\t\tresolvedAddresses = new address[](T.numberOfOptions);\r\n\t\t//yikes\r\n\t\tfor(uint i = 0; i< T.numberOfOptions; i+=1){\r\n\t\t\tweightOfResults[i] = T.weightOfResults[i];\r\n\t\t\tresolvedInts[i] = T.resolvedInts[i];\r\n\t\t\tresolvedBytes[i] = T.resolvedBytes[i];\r\n\t\t\tresolvedAddresses[i] = T.resolvedAddresses[i];\t\r\n\t\t}\r\n\t}\r\n\r\n\tfunction viewCandidates(bool personal_or_roundtable, address perspective) public view returns(address[] memory addresses, uint[] memory dividends, bool[] memory hasChairs, uint[] memory seat, uint[] memory weights, uint[] memory clocks, bool[] memory isFrozen, bool[] memory isPaused,uint[] memory roundTableDividends){\r\n\t\tuint L;\r\n\t\t\r\n\t\tif(personal_or_roundtable){\r\n\t\t\tL = hotSeats;\r\n\t\t}else{\r\n\t\t\tL = yourBacking[perspective].length;\r\n\t\t}\r\n\r\n\t\tdividends = new uint[](L);\r\n\t\tseat = new uint[](L);\r\n\t\troundTableDividends = new uint[](L);\r\n\r\n\t\tweights = new uint[](L*2);\r\n\t\tclocks = new uint[](L*3);\r\n\r\n\t\tisFrozen = new bool[](L);\r\n\t\tisPaused = new bool[](L);\r\n\t\thasChairs = new bool[](L);\r\n\r\n\t\taddresses = new address[](L);\r\n\r\n\t\taddress candidate;\r\n\t\tfor(uint c = 0; c<L; c+=1){\r\n\t\t\tif(personal_or_roundtable){\r\n\t\t\t\tcandidate = chairsCandidate[c];\r\n\t\t\t}else{\r\n\t\t\t\tcandidate = yourBacking[perspective][c];\r\n\t\t\t}\r\n\t\t\taddresses[c] = candidate;\r\n\t\t\tdividends[c] = dividendsOf(candidate, perspective);\r\n\t\t\troundTableDividends[c] = dividendsOf(ORACLE, candidate);\r\n\t\t\tseat[c] = candidatesChair[candidate];\r\n\t\t\tweights[c] = shares[candidate][perspective];\r\n\t\t\tweights[c+L] = totalShares[candidate];\r\n\t\t\tisFrozen[c] = frozen[candidate];\r\n\t\t\tisPaused[c] = paused[candidate];\r\n\t\t\thasChairs[c] = hasChair[candidate];\r\n\t\t\tclocks[c] = timeWhenThawedOut[candidate];\r\n\t\t\tclocks[c+L] = timeSeated[candidate];\r\n\t\t\tclocks[c+L*2] = latestPunishment[candidate];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction viewGovernance(address addr) public view returns(uint[] memory data){\r\n\t\tdata = new uint[](CONFIGS*4);\r\n\t\tfor(uint i = 0; i< CONFIGS; i+=1){\r\n\t\t\tdata[i] = oracleConfigurations[i];\r\n\t\t\tdata[CONFIGS + i] = totalVotes_forEach_configOption[i][ oracleConfigurations[i] ];\r\n\t\t\tdata[CONFIGS*2 + i] = individualsSelectedOption[i][addr];\r\n\t\t\tdata[CONFIGS*3 + i] = totalVotes_forEach_configOption[i][ individualsSelectedOption[i][addr] ];\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction accountData(address account) public view returns(\r\n\t\tuint _resolveWeight,\r\n\t\tuint _weightLocked,\r\n\t\tuint _timeSeated,\r\n\t\tbool _frozen,\r\n\t\tbool _paused,\r\n\t\tbool _hasChair,\r\n\t\tuint _earnings,\r\n\t\tuint _totalShares,\r\n\t\tuint[] memory UINTs\r\n\t){\r\n\t\t_resolveWeight = resolveWeight[account];\r\n\t\t_weightLocked = weightLocked[account];\r\n\t\t_timeSeated = timeSeated[account];\r\n\t\t_frozen = frozen[account];\r\n\t\t_paused = paused[account];\r\n\t\t_hasChair = hasChair[account];\r\n\t\t_earnings = earnings[account];\r\n\t\t_totalShares = totalShares[account];\r\n\t\tUINTs = new uint[](5);\r\n\r\n\t\tif( isWatcher(account) ){\r\n\t\t\tUINTs[0] = earningsPerWatcher - watcherPayouts[account];//txCoverageFee\r\n\t\t\tUINTs[1] = dividendsOf(ORACLE, account) * oracleConfigurations[DELEGATE_REWARDSHARE] / (1e20);\r\n\t\t}\r\n\r\n\t\tUINTs[2] = timeWhenThawedOut[account];\r\n\t\tUINTs[3] = latestPunishment[account];\r\n\t\tUINTs[4] = candidatesChair[account];\r\n\t}\r\n\r\n\tfunction compareStrings(string memory a, string memory b) public pure returns (bool) {\r\n\t\treturn (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))) );\r\n\t}\r\n\tfunction compareBytes(bytes32 a, bytes32 b) public pure returns (bool) {\r\n\t\treturn (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))) );\r\n\t}\r\n\tfunction bytesToAddress(bytes memory bys) private pure returns (address addr){\r\n        assembly {\r\n          addr := mload( add(bys,20) )\r\n        } \r\n    }\r\n}\r\n\r\nabstract contract ResolveToken{\r\n\tfunction transfer(address _to, uint256 _value) public virtual returns (bool);\r\n}\r\n\r\nabstract contract Pyramid{\r\n\tfunction pullResolves(uint amount) public virtual returns (uint forfeiture);\r\n\tfunction resolveToken() public view virtual returns(ResolveToken);\r\n}\r\n\r\nabstract contract Requestor{\r\n\tfunction oracleIntFallback(uint ticketID, bool rejected, uint numberOfOptions, uint[] memory optionWeights, int[] memory intOptions) external virtual;\r\n\tfunction oracleBytesFallback(uint ticketID, bool rejected, uint numberOfOptions, uint[] memory optionWeights, bytes[] memory bytesOptions) external virtual;\r\n\tfunction oracleAddressFallback(uint ticketID, bool rejected, uint numberOfOptions, uint[] memory optionWeights, address[] memory addressOptions) external virtual;\r\n}\r\n\r\nabstract contract Greenpoint{\r\n\tfunction payEthToAcreStakers() payable public virtual;\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"successfulAssert\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"replacedWatcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSeat\",\"type\":\"uint256\"}],\"name\":\"AssertCandidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"config\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"option\",\"type\":\"uint256\"}],\"name\":\"AssertOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BackCandidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ETH\",\"type\":\"uint256\"}],\"name\":\"Cashout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"CommitVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"dataType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"subjective\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"responseTimeWindow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"name\":\"FileRequestTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"watchers\",\"type\":\"address[]\"}],\"name\":\"FinalizedRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"watcher\",\"type\":\"address\"}],\"name\":\"FreezeNoncommits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"watcher\",\"type\":\"address\"}],\"name\":\"FreezeUnrevealedCommits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"watcher\",\"type\":\"address\"}],\"name\":\"FreezeWrongWatchers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"config\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"option\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"OptionVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PauseOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PullBacking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"watcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"thawOutTime\",\"type\":\"uint256\"}],\"name\":\"Punish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rejected\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"intVote\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"bytesVote\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addressVote\",\"type\":\"address\"}],\"name\":\"RevealVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"StakeResolves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"defender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"stance\",\"type\":\"bool\"}],\"name\":\"SubjectiveStance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"Thaw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"watcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TxCashout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeResolves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalHotSeats\",\"type\":\"uint256\"}],\"name\":\"UpdateRoundTable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"watcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidOut\",\"type\":\"uint256\"}],\"name\":\"WatcherPayroll\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accountData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_resolveWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_weightLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeSeated\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_frozen\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_hasChair\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_earnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"UINTs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addressPayable\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"alreadyBacking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assertCandidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"config\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"option\",\"type\":\"uint256\"}],\"name\":\"assertOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"cashout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chairsCandidate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tickets\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"voteHashes\",\"type\":\"bytes32[]\"}],\"name\":\"commitVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"a\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"b\",\"type\":\"bytes32\"}],\"name\":\"compareBytes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"a\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"b\",\"type\":\"string\"}],\"name\":\"compareStrings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devPull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"returnType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"subjective\",\"type\":\"bool\"}],\"name\":\"fileRequestTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"}],\"name\":\"finalizeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tickets\",\"type\":\"uint256[]\"}],\"name\":\"finalizeRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"frausted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tickets\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"watchers\",\"type\":\"address[]\"}],\"name\":\"freezeNoncommits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tickets\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"watchers\",\"type\":\"address[]\"}],\"name\":\"freezeUnrevealedCommits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tickets\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"watchers\",\"type\":\"address[]\"}],\"name\":\"freezeWrongWatchers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"txCoverageFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"serviceFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hotSeats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"individualsSelectedOption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"isWatcher\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool[]\",\"name\":\"isModifying\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"modifiedOptions\",\"type\":\"uint256[]\"}],\"name\":\"optionVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"oracleConfigurations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pullAllTheWay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pullBacking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pyramid\",\"outputs\":[{\"internalType\":\"contract Pyramid\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolveToken\",\"outputs\":[{\"internalType\":\"contract ResolveToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tickets\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"rejected\",\"type\":\"bool[]\"},{\"internalType\":\"int256[]\",\"name\":\"intVotes\",\"type\":\"int256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"bytesVotes\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"addressVotes\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"passwords\",\"type\":\"string[]\"}],\"name\":\"revealVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"watcher\",\"type\":\"address\"}],\"name\":\"runWatcherPayroll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeCandidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tickets\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"defenders\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"stances\",\"type\":\"bool[]\"}],\"name\":\"subjectiveStance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"thaw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalVotes_forEach_configOption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWatchers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tickets\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"watchers\",\"type\":\"address[]\"}],\"name\":\"tryToPunish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_assert\",\"type\":\"bool\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstakeResolves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"name\":\"updateACRE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"updatePines\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seats\",\"type\":\"uint256\"}],\"name\":\"updateRoundTable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"personal_or_roundtable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"perspective\",\"type\":\"address\"}],\"name\":\"viewCandidates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"dividends\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"hasChairs\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"seat\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"clocks\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"isFrozen\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"isPaused\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"roundTableDividends\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"viewGovernance\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketID\",\"type\":\"uint256\"}],\"name\":\"viewRequestTicket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfOptions\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finalized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rejected\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"weightOfResults\",\"type\":\"uint256[]\"},{\"internalType\":\"int256[]\",\"name\":\"resolvedInts\",\"type\":\"int256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"resolvedBytes\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"resolvedAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"yourBacking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Oracle","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ecfc3f2966013f3b4631d8266aecebd78f08a3eb62b14579c841322c815a72aa"}]}