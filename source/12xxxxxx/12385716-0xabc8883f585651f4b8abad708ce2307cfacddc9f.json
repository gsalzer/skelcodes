{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ReserveAuctionV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n// OpenZeppelin library for performing math operations without overflows.\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n// OpenZeppelin security library for preventing reentrancy attacks.\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n// For checking `supportsInterface`.\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n// For interacting with NFT tokens.\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ncontract IMediaModified {\\n    mapping(uint256 => address) public tokenCreators;\\n}\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n}\\n\\ninterface Royalties {\\n    function deposit() external payable;\\n}\\n\\ncontract ReserveAuctionV3 is ReentrancyGuard {\\n    // Use OpenZeppelin's SafeMath library to prevent overflows.\\n    using SafeMath for uint256;\\n\\n    // ============ Constants ============\\n\\n    // The minimum amount of time left in an auction after a new bid is created; 15 min.\\n    uint16 public constant TIME_BUFFER = 0;\\n    // The ETH needed above the current bid for a new bid to be valid; 0.001 ETH.\\n    uint8 public constant MIN_BID_INCREMENT_PERCENT = 10;\\n    // Interface constant for ERC721, to check values in constructor.\\n    bytes4 private constant ERC721_INTERFACE_ID = 0x80ac58cd;\\n    // Allows external read `getVersion()` to return a version for the auction.\\n    uint256 private constant RESERVE_AUCTION_VERSION = 1;\\n\\n    // ============ Immutable Storage ============\\n\\n    // The address of the ERC721 contract for tokens auctioned via this contract.\\n    address public immutable nftContract;\\n    // The address of the WETH contract, so that ETH can be transferred via\\n    // WETH if native ETH transfers fail.\\n    address public immutable wethAddress;\\n    // The address that initially is able to recover assets.\\n    address public immutable adminRecoveryAddress;\\n\\n    // ============ Mutable Storage ============\\n\\n    bool private _adminRecoveryEnabled;\\n    bool private _paused;\\n\\n    // A mapping of all of the auctions currently running.\\n    mapping(uint256 => Auction) public auctions;\\n\\n    // The address of the creator pool\\n    address public creatorPoolAddress;\\n\\n    // ============ Structs ============\\n\\n    struct Auction {\\n        // The value of the current highest bid.\\n        uint256 amount;\\n        // The amount of time that the auction should run for,\\n        // after the first bid was made.\\n        uint256 duration;\\n        // The time of the first bid.\\n        uint256 firstBidTime;\\n        // The minimum price of the first bid.\\n        uint256 reservePrice;\\n        uint8 curatorFeePercent;\\n        // The address of the auction's curator. The curator\\n        // can cancel the auction if it hasn't had a bid yet.\\n        address curator;\\n        // The address of the current highest bid.\\n        address payable bidder;\\n        // The address that should receive funds once the NFT is sold.\\n        address payable fundsRecipient;\\n    }\\n\\n    // ============ Events ============\\n\\n    // All of the details of a new auction,\\n    // with an index created for the tokenId.\\n    event AuctionCreated(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        uint256 duration,\\n        uint256 reservePrice,\\n        uint8 curatorFeePercent,\\n        address curator,\\n        address fundsRecipient\\n    );\\n\\n    // All of the details of a new bid,\\n    // with an index created for the tokenId.\\n    event AuctionBid(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        address sender,\\n        uint256 value\\n    );\\n\\n    // All of the details of an auction's cancelation,\\n    // with an index created for the tokenId.\\n    event AuctionCanceled(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        address curator\\n    );\\n\\n    // All of the details of an auction's close,\\n    // with an index created for the tokenId.\\n    event AuctionEnded(\\n        uint256 indexed tokenId,\\n        address nftContractAddress,\\n        address curator,\\n        address winner,\\n        uint256 amount,\\n        address nftCreator,\\n        address payable fundsRecipient\\n    );\\n\\n    // When the curator recevies fees, emit the details including the amount,\\n    // with an index created for the tokenId.\\n    event CuratorFeePercentTransfer(\\n        uint256 indexed tokenId,\\n        address curator,\\n        uint256 amount\\n    );\\n\\n    // Emitted in the case that the contract is paused.\\n    event Paused(address account);\\n    // Emitted when the contract is unpaused.\\n    event Unpaused(address account);\\n\\n    // ============ Modifiers ============\\n\\n    // Reverts if the sender is not admin, or admin\\n    // functionality has been turned off.\\n    modifier onlyAdminRecovery() {\\n        require(\\n            // The sender must be the admin address, and\\n            // adminRecovery must be set to true.\\n            adminRecoveryAddress == msg.sender && adminRecoveryEnabled(),\\n            \\\"Caller does not have admin privileges\\\"\\n        );\\n        _;\\n    }\\n\\n    // Reverts if the sender is not the auction's curator.\\n    modifier onlyCurator(uint256 tokenId) {\\n        require(\\n            auctions[tokenId].curator == msg.sender,\\n            \\\"Can only be called by auction curator\\\"\\n        );\\n        _;\\n    }\\n\\n    // Reverts if the contract is paused.\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Contract is paused\\\");\\n        _;\\n    }\\n\\n    // Reverts if the auction does not exist.\\n    modifier auctionExists(uint256 tokenId) {\\n        // The auction exists if the curator is not null.\\n        require(!auctionCuratorIsNull(tokenId), \\\"Auction doesn't exist\\\");\\n        _;\\n    }\\n\\n    // Reverts if the auction exists.\\n    modifier auctionNonExistant(uint256 tokenId) {\\n        // The auction does not exist if the curator is null.\\n        require(auctionCuratorIsNull(tokenId), \\\"Auction already exists\\\");\\n        _;\\n    }\\n\\n    // Reverts if the auction is expired.\\n    modifier auctionNotExpired(uint256 tokenId) {\\n        require(\\n            // Auction is not expired if there's never been a bid, or if the\\n            // current time is less than the time at which the auction ends.\\n            auctions[tokenId].firstBidTime == 0 ||\\n                block.timestamp < auctionEnds(tokenId),\\n            \\\"Auction expired\\\"\\n        );\\n        _;\\n    }\\n\\n    // Reverts if the auction is not complete.\\n    // Auction is complete if there was a bid, and the time has run out.\\n    modifier auctionComplete(uint256 tokenId) {\\n        require(\\n            // Auction is complete if there has been a bid, and the current time\\n            // is greater than the auction's end time.\\n            auctions[tokenId].firstBidTime > 0 &&\\n                block.timestamp >= auctionEnds(tokenId),\\n            \\\"Auction hasn't completed\\\"\\n        );\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(\\n        address nftContract_,\\n        address wethAddress_,\\n        address adminRecoveryAddress_,\\n        address creatorPoolAddress_\\n    ) {\\n        require(\\n            IERC165(nftContract_).supportsInterface(ERC721_INTERFACE_ID),\\n            \\\"Contract at nftContract_ address does not support NFT interface\\\"\\n        );\\n        // Initialize immutable memory.\\n        nftContract = nftContract_;\\n        wethAddress = wethAddress_;\\n        adminRecoveryAddress = adminRecoveryAddress_;\\n        creatorPoolAddress = creatorPoolAddress_;\\n        // Initialize mutable memory.\\n        _paused = false;\\n        _adminRecoveryEnabled = true;\\n    }\\n\\n    // ============ Create Auction ============\\n\\n    function createAuction(\\n        uint256 tokenId,\\n        uint256 duration,\\n        uint256 reservePrice,\\n        uint8 curatorFeePercent,\\n        address curator,\\n        address payable fundsRecipient\\n    ) external nonReentrant whenNotPaused auctionNonExistant(tokenId) {\\n        // Check basic input requirements are reasonable.\\n        require(curator != address(0));\\n        require(fundsRecipient != address(0));\\n        require(curatorFeePercent < 100, \\\"Curator fee should be < 100\\\");\\n        // Initialize the auction details, including null values.\\n        auctions[tokenId] = Auction({\\n            duration: duration,\\n            reservePrice: reservePrice,\\n            curatorFeePercent: curatorFeePercent,\\n            curator: curator,\\n            fundsRecipient: fundsRecipient,\\n            amount: 0,\\n            firstBidTime: 0,\\n            bidder: payable(address(0))\\n        });\\n        // Transfer the NFT into this auction contract, from whoever owns it.\\n        IERC721(nftContract).transferFrom(\\n            IERC721(nftContract).ownerOf(tokenId),\\n            address(this),\\n            tokenId\\n        );\\n        // Emit an event describing the new auction.\\n        emit AuctionCreated(\\n            tokenId,\\n            nftContract,\\n            duration,\\n            reservePrice,\\n            curatorFeePercent,\\n            curator,\\n            fundsRecipient\\n        );\\n    }\\n\\n    // ============ Create Bid ============\\n\\n    function createBid(uint256 tokenId, uint256 amount)\\n        external\\n        payable\\n        nonReentrant\\n        whenNotPaused\\n        auctionExists(tokenId)\\n        auctionNotExpired(tokenId)\\n    {\\n        // Validate that the user's expected bid value matches the ETH deposit.\\n        require(amount == msg.value, \\\"Amount doesn't equal msg.value\\\");\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n        // Check if the current bid amount is 0.\\n        if (auctions[tokenId].amount == 0) {\\n            // If so, it is the first bid.\\n            auctions[tokenId].firstBidTime = block.timestamp;\\n            // We only need to check if the bid matches reserve bid for the first bid,\\n            // since future checks will need to be higher than any previous bid.\\n            require(\\n                amount >= auctions[tokenId].reservePrice,\\n                \\\"Must bid reservePrice or more\\\"\\n            );\\n        } else {\\n            // Check that the new bid is sufficiently higher than the previous bid, by\\n            // the percentage defined as MIN_BID_INCREMENT_PERCENT.\\n            require(\\n                amount >=\\n                    auctions[tokenId].amount.add(\\n                        // Add 10% of the current bid to the current bid.\\n                        auctions[tokenId]\\n                            .amount\\n                            .mul(MIN_BID_INCREMENT_PERCENT)\\n                            .div(100)\\n                    ),\\n                \\\"Must bid more than last bid by MIN_BID_INCREMENT_PERCENT amount\\\"\\n            );\\n\\n            // Refund the previous bidder.\\n            transferETHOrWETH(\\n                auctions[tokenId].bidder,\\n                auctions[tokenId].amount\\n            );\\n        }\\n        // Update the current auction.\\n        auctions[tokenId].amount = amount;\\n        auctions[tokenId].bidder = payable(msg.sender);\\n        // Compare the auction's end time with the current time plus the 15 minute extension,\\n        // to see whether we're near the auctions end and should extend the auction.\\n        if (auctionEnds(tokenId) < block.timestamp.add(TIME_BUFFER)) {\\n            // We add onto the duration whenever time increment is required, so\\n            // that the auctionEnds at the current time plus the buffer.\\n            auctions[tokenId].duration += block.timestamp.add(TIME_BUFFER).sub(\\n                auctionEnds(tokenId)\\n            );\\n        }\\n        // Emit the event that a bid has been made.\\n        emit AuctionBid(tokenId, nftContract, msg.sender, amount);\\n    }\\n\\n    // ============ End Auction ============\\n\\n    function endAuction(uint256 tokenId)\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        auctionComplete(tokenId)\\n    {\\n        // Store relevant auction data in memory for the life of this function.\\n        address winner = auctions[tokenId].bidder;\\n        uint256 amount = auctions[tokenId].amount;\\n        address curator = auctions[tokenId].curator;\\n        uint8 curatorFeePercent = auctions[tokenId].curatorFeePercent;\\n        address payable fundsRecipient = auctions[tokenId].fundsRecipient;\\n        // Remove all auction data for this token from storage.\\n        delete auctions[tokenId];\\n        // We don't use safeTransferFrom, to prevent reverts at this point,\\n        // which would break the auction.\\n        IERC721(nftContract).transferFrom(address(this), winner, tokenId);\\n        // First handle the curator's fee.\\n        if (curatorFeePercent > 0) {\\n            // Determine the curator amount, which is some percent of the total.\\n            uint256 curatorAmount = amount.mul(curatorFeePercent).div(100);\\n            // Send it to the curator.\\n            transferETHOrWETH(curator, curatorAmount);\\n            // Subtract the curator amount from the total funds available\\n            // to send to the funds recipient and original NFT creator.\\n            amount = amount.sub(curatorAmount);\\n            // Emit the details of the transfer as an event.\\n            emit CuratorFeePercentTransfer(tokenId, curator, curatorAmount);\\n        }\\n        // Get the address of the original creator, so that we can split shares\\n        // if appropriate.\\n        address payable nftCreator =\\n            payable(\\n                address(IMediaModified(nftContract).tokenCreators(tokenId))\\n            );\\n\\n        // Otherwise, we should determine the percent that goes to the creator.\\n        // Collect share data from Zora.\\n        uint256 creatorAmount = calculatePercentage(amount, 6000); // 60% goes to the creator\\n        uint256 poolAmount = calculatePercentage(amount, 300); // 3% to the pool\\n        // Send the creator's share to the creator.\\n        transferETHOrWETH(nftCreator, creatorAmount);\\n        // Send the pools share to the pool\\n        transferETHOrWETH(creatorPoolAddress, poolAmount);\\n        // Send the remainder of the amount to the funds recipient.\\n        transferETHOrWETH(fundsRecipient, amount.sub(creatorAmount).sub(poolAmount));\\n\\n        // Emit an event describing the end of the auction.\\n        emit AuctionEnded(\\n            tokenId,\\n            nftContract,\\n            curator,\\n            winner,\\n            amount,\\n            nftCreator,\\n            fundsRecipient\\n        );\\n    }\\n\\n    function calculatePercentage(\\n        uint amount, uint bp\\n    )\\n    internal\\n    pure\\n    returns (uint) {\\n        return amount * bp / 10000;\\n    }\\n\\n    // ============ Cancel Auction ============\\n\\n    function cancelAuction(uint256 tokenId)\\n        external\\n        nonReentrant\\n        auctionExists(tokenId)\\n        onlyCurator(tokenId)\\n    {\\n        // Check that there hasn't already been a bid for this NFT.\\n        require(\\n            uint256(auctions[tokenId].firstBidTime) == 0,\\n            \\\"Auction already started\\\"\\n        );\\n        // Pull the creator address before removing the auction.\\n        address curator = auctions[tokenId].curator;\\n        // Remove all data about the auction.\\n        delete auctions[tokenId];\\n        // Transfer the NFT back to the curator.\\n        IERC721(nftContract).transferFrom(address(this), curator, tokenId);\\n        // Emit an event describing that the auction has been canceled.\\n        emit AuctionCanceled(tokenId, nftContract, curator);\\n    }\\n\\n    // ============ Admin Functions ============\\n\\n    // Irrevocably turns off admin recovery.\\n    function turnOffAdminRecovery() external onlyAdminRecovery {\\n        _adminRecoveryEnabled = false;\\n    }\\n\\n    function pauseContract() external onlyAdminRecovery {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    function unpauseContract() external onlyAdminRecovery {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    // Allows the admin to transfer any NFT from this contract\\n    // to the recovery address.\\n    function recoverNFT(uint256 tokenId) external onlyAdminRecovery {\\n        IERC721(nftContract).transferFrom(\\n            // From the auction contract.\\n            address(this),\\n            // To the recovery account.\\n            adminRecoveryAddress,\\n            // For the specified token.\\n            tokenId\\n        );\\n    }\\n\\n    // Allows the admin to transfer any ETH from this contract to the recovery address.\\n    function recoverETH(uint256 amount)\\n        external\\n        onlyAdminRecovery\\n        returns (bool success)\\n    {\\n        // Attempt an ETH transfer to the recovery account, and return true if it succeeds.\\n        success = attemptETHTransfer(adminRecoveryAddress, amount);\\n    }\\n\\n    // ============ Miscellaneous Public and External ============\\n    // Returns true if the contract is paused.\\n    function setCreatorPool(address newCreatorPoolAddress) public onlyAdminRecovery {\\n        creatorPoolAddress = newCreatorPoolAddress;\\n    }\\n\\n    // Returns true if the contract is paused.\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    // Returns true if admin recovery is enabled.\\n    function adminRecoveryEnabled() public view returns (bool) {\\n        return _adminRecoveryEnabled;\\n    }\\n\\n    // Returns the version of the deployed contract.\\n    function getVersion() external pure returns (uint256 version) {\\n        version = RESERVE_AUCTION_VERSION;\\n    }\\n\\n    // ============ Private Functions ============\\n\\n    // Will attempt to transfer ETH, but will transfer WETH instead if it fails.\\n    function transferETHOrWETH(address to, uint256 value) private {\\n        // Try to transfer ETH to the given recipient.\\n        if (!attemptETHTransfer(to, value)) {\\n            // If the transfer fails, wrap and send as WETH, so that\\n            // the auction is not impeded and the recipient still\\n            // can claim ETH via the WETH contract (similar to escrow).\\n            IWETH(wethAddress).deposit{value: value}();\\n            IWETH(wethAddress).transfer(to, value);\\n            // At this point, the recipient can unwrap WETH.\\n        }\\n    }\\n\\n    // Sending ETH is not guaranteed complete, and the method used here will return false if\\n    // it fails. For example, a contract can block ETH transfer, or might use\\n    // an excessive amount of gas, thereby griefing a new bidder.\\n    // We should limit the gas used in transfers, and handle failure cases.\\n    function attemptETHTransfer(address to, uint256 value)\\n        private\\n        returns (bool)\\n    {\\n        // Here increase the gas limit a reasonable amount above the default, and try\\n        // to send ETH to the recipient.\\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\\n        (bool success, ) = to.call{value: value, gas: 30000}(\\\"\\\");\\n        return success;\\n    }\\n\\n    // Returns true if the auction's curator is set to the null address.\\n    function auctionCuratorIsNull(uint256 tokenId) private view returns (bool) {\\n        // The auction does not exist if the curator is the null address,\\n        // since the NFT would not have been transferred in `createAuction`.\\n        return auctions[tokenId].curator == address(0);\\n    }\\n\\n    // Returns the timestamp at which an auction will finish.\\n    function auctionEnds(uint256 tokenId) private view returns (uint256) {\\n        // Derived by adding the auction's duration to the time of the first bid.\\n        // NOTE: duration can be extended conditionally after each new bid is added.\\n        return auctions[tokenId].firstBidTime.add(auctions[tokenId].duration);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wethAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adminRecoveryAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creatorPoolAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AuctionBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"}],\"name\":\"AuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"curatorFeePercent\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundsRecipient\",\"type\":\"address\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftCreator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"fundsRecipient\",\"type\":\"address\"}],\"name\":\"AuctionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CuratorFeePercentTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_BID_INCREMENT_PERCENT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_BUFFER\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminRecoveryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminRecoveryEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstBidTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"curatorFeePercent\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsRecipient\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"curatorFeePercent\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsRecipient\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creatorPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"endAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"recoverNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCreatorPoolAddress\",\"type\":\"address\"}],\"name\":\"setCreatorPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"turnOffAdminRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ReserveAuctionV3","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002c02b28f612dd57a30e5b64894329fefe6dbf338000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000ede73d584e6d6c0ca53cdf56a8613f4b8204c0dd000000000000000000000000450fc8db5a00bd2271800f6d13a978f01630fcf3","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}