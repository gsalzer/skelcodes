{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\npragma solidity 0.8.0;\r\npragma abicoder v2;\r\n\r\n\r\ninterface MassetStructs {\r\n    struct BassetPersonal {\r\n        // Address of the bAsset\r\n        address addr;\r\n        // Address of the bAsset\r\n        address integrator;\r\n        // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\r\n        bool hasTxFee; // takes a byte in storage\r\n        // Status of the bAsset\r\n        BassetStatus status;\r\n    }\r\n\r\n    struct BassetData {\r\n        // 1 Basset * ratio / ratioScale == x Masset (relative value)\r\n        // If ratio == 10e8 then 1 bAsset = 10 mAssets\r\n        // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\r\n        uint128 ratio;\r\n        // Amount of the Basset that is held in Collateral\r\n        uint128 vaultBalance;\r\n    }\r\n\r\n    // Status of the Basset - has it broken its peg?\r\n    enum BassetStatus {\r\n        Default,\r\n        Normal,\r\n        BrokenBelowPeg,\r\n        BrokenAbovePeg,\r\n        Blacklisted,\r\n        Liquidating,\r\n        Liquidated,\r\n        Failed\r\n    }\r\n\r\n    struct BasketState {\r\n        bool undergoingRecol;\r\n        bool failed;\r\n    }\r\n\r\n    struct InvariantConfig {\r\n        uint256 a;\r\n        WeightLimits limits;\r\n    }\r\n\r\n    struct WeightLimits {\r\n        uint128 min;\r\n        uint128 max;\r\n    }\r\n\r\n    struct AmpData {\r\n        uint64 initialA;\r\n        uint64 targetA;\r\n        uint64 rampStartTime;\r\n        uint64 rampEndTime;\r\n    }\r\n}\r\n\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\nstruct Basket {\r\n    Basset[] bassets;\r\n    uint8 maxBassets;\r\n    bool undergoingRecol;\r\n    bool failed;\r\n    uint256 collateralisationRatio;\r\n\r\n}\r\n\r\ninterface IBasketManager {\r\n    function getBassetIntegrator(address _bAsset)\r\n        external\r\n        view\r\n        returns (address integrator);\r\n\r\n    function getBasket()\r\n        external\r\n        view\r\n        returns (Basket memory b);\r\n}\r\n\r\nstruct Basset {\r\n    address addr;\r\n    BassetStatus status;\r\n    bool isTransferFeeCharged;\r\n    uint256 ratio;\r\n    uint256 maxWeight;\r\n    uint256 vaultBalance;\r\n}\r\n\r\n/** @dev Status of the Basset - has it broken its peg? */\r\nenum BassetStatus {\r\n    Default,\r\n    Normal,\r\n    BrokenBelowPeg,\r\n    BrokenAbovePeg,\r\n    Blacklisted,\r\n    Liquidating,\r\n    Liquidated,\r\n    Failed\r\n}\r\n\r\nlibrary Migrator {\r\n\r\n    function upgrade(\r\n        IBasketManager basketManager,\r\n        MassetStructs.BassetPersonal[] storage bAssetPersonal,\r\n        MassetStructs.BassetData[] storage bAssetData,\r\n        mapping(address => uint8) storage bAssetIndexes\r\n    ) external {\r\n        Basket memory importedBasket = basketManager.getBasket();\r\n\r\n        uint256 len = importedBasket.bassets.length;\r\n        uint256[] memory scaledVaultBalances = new uint[](len);\r\n        uint256 maxScaledVaultBalance;\r\n        for (uint8 i = 0; i < len; i++) {\r\n            Basset memory bAsset = importedBasket.bassets[i];\r\n            address bAssetAddress = bAsset.addr;\r\n            bAssetIndexes[bAssetAddress] = i;\r\n\r\n            address integratorAddress = basketManager.getBassetIntegrator(bAssetAddress);\r\n            bAssetPersonal.push(\r\n                MassetStructs.BassetPersonal({\r\n                    addr: bAssetAddress,\r\n                    integrator: integratorAddress,\r\n                    hasTxFee: false,\r\n                    status: MassetStructs.BassetStatus.Normal\r\n                })\r\n            );\r\n\r\n            uint128 ratio = SafeCast.toUint128(bAsset.ratio);\r\n            uint128 vaultBalance = SafeCast.toUint128(bAsset.vaultBalance);\r\n            bAssetData.push(\r\n                MassetStructs.BassetData({ ratio: ratio, vaultBalance: vaultBalance })\r\n            );\r\n\r\n            // caclulate scaled vault bAsset balance and totoal vault balance\r\n            uint128 scaledVaultBalance = (vaultBalance * ratio) / 1e8;\r\n            scaledVaultBalances[i] = scaledVaultBalance;\r\n            maxScaledVaultBalance += scaledVaultBalance;\r\n        }\r\n\r\n        // Check each bAsset is under 25.01% weight\r\n        uint256 maxWeight = 2501;\r\n        if(len == 3){\r\n            maxWeight = 3334;\r\n        } else if (len != 4){\r\n            revert(\"Invalid length\");\r\n        }\r\n        maxScaledVaultBalance = maxScaledVaultBalance * 2501 / 10000;\r\n        for (uint8 i = 0; i < len; i++) {\r\n            require(scaledVaultBalances[i] < maxScaledVaultBalance, \"imbalanced\");\r\n        }\r\n    }\r\n}","ABI":"[]","ContractName":"Migrator","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6f14474b98177b143d2684cfa597e11c661ab3e4c0b2092ba82f5199681aaad4"}]}