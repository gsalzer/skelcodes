{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ALCXRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport { BoringMath, BoringMath128 } from \\\"./libraries/boring/BoringMath.sol\\\";\\nimport { BoringOwnable } from \\\"./libraries/boring/BoringOwnable.sol\\\";\\nimport { BoringERC20 } from \\\"./libraries/boring/BoringERC20.sol\\\";\\n\\nimport { IRewarder } from \\\"./interfaces/sushi/IRewarder.sol\\\";\\nimport { IMasterChefV2 } from \\\"./interfaces/sushi/IMasterChefV2.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract ALCXRewarder is IRewarder, BoringOwnable {\\n\\tusing BoringMath for uint256;\\n\\tusing BoringMath128 for uint128;\\n\\tusing BoringERC20 for IERC20;\\n\\n\\tIERC20 private immutable rewardToken;\\n\\tIMasterChefV2 private immutable MC_V2;\\n\\n\\t/// @notice Info of each MCV2 user.\\n\\t/// `amount` LP token amount the user has provided.\\n\\t/// `rewardDebt` The amount of SUSHI entitled to the user.\\n\\tstruct UserInfo {\\n\\t\\tuint256 amount;\\n\\t\\tuint256 rewardDebt;\\n\\t}\\n\\n\\t/// @notice Info of each MCV2 pool.\\n\\t/// `allocPoint` The amount of allocation points assigned to the pool.\\n\\t/// Also known as the amount of SUSHI to distribute per block.\\n\\tstruct PoolInfo {\\n\\t\\tuint128 accTokenPerShare;\\n\\t\\tuint64 lastRewardBlock;\\n\\t\\tuint64 allocPoint;\\n\\t}\\n\\n\\tuint256[] public poolIds;\\n\\t/// @notice Info of each pool.\\n\\tmapping(uint256 => PoolInfo) public poolInfo;\\n\\t/// @notice Info of each user that stakes LP tokens.\\n\\tmapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n\\t/// @dev Total allocation points. Must be the sum of all allocation points in all pools.\\n\\tuint256 totalAllocPoint;\\n\\n\\tuint256 public tokenPerBlock;\\n\\tuint256 private constant ACC_TOKEN_PRECISION = 1e12;\\n\\n\\tevent PoolAdded(uint256 indexed pid, uint256 allocPoint);\\n\\tevent PoolSet(uint256 indexed pid, uint256 allocPoint);\\n\\tevent PoolUpdated(uint256 indexed pid, uint64 lastRewardBlock, uint256 lpSupply, uint256 accTokenPerShare);\\n\\tevent OnReward(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n\\tevent RewardRateUpdated(uint256 oldRate, uint256 newRate);\\n\\n\\tmodifier onlyMCV2 {\\n\\t\\trequire(msg.sender == address(MC_V2), \\\"ALCXRewarder::onlyMCV2: only MasterChef V2 can call this function.\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tconstructor(\\n\\t\\tIERC20 _rewardToken,\\n\\t\\tuint256 _tokenPerBlock,\\n\\t\\tIMasterChefV2 _MCV2\\n\\t) public {\\n\\t\\trequire(Address.isContract(address(_rewardToken)), \\\"ALCXRewarder: reward token must be a valid contract\\\");\\n\\t\\trequire(Address.isContract(address(_MCV2)), \\\"ALCXRewarder: MasterChef V2 must be a valid contract\\\");\\n\\n\\t\\trewardToken = _rewardToken;\\n\\t\\ttokenPerBlock = _tokenPerBlock;\\n\\t\\tMC_V2 = _MCV2;\\n\\t}\\n\\n\\t/// @notice Add a new LP to the pool. Can only be called by the owner.\\n\\t/// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n\\t/// @param allocPoint AP of the new pool.\\n\\t/// @param _pid Pid on MCV2\\n\\tfunction addPool(uint256 _pid, uint256 allocPoint) public onlyOwner {\\n\\t\\trequire(poolInfo[_pid].lastRewardBlock == 0, \\\"ALCXRewarder::add: cannot add existing pool\\\");\\n\\n\\t\\tuint256 lastRewardBlock = block.number;\\n\\t\\ttotalAllocPoint = totalAllocPoint.add(allocPoint);\\n\\n\\t\\tpoolInfo[_pid] = PoolInfo({\\n\\t\\t\\tallocPoint: allocPoint.to64(),\\n\\t\\t\\tlastRewardBlock: lastRewardBlock.to64(),\\n\\t\\t\\taccTokenPerShare: 0\\n\\t\\t});\\n\\t\\tpoolIds.push(_pid);\\n\\n\\t\\temit PoolAdded(_pid, allocPoint);\\n\\t}\\n\\n\\t/// @notice Update the given pool's SUSHI allocation point and `IRewarder` contract. Can only be called by the owner.\\n\\t/// @param _pid The index of the pool. See `poolInfo`.\\n\\t/// @param _allocPoint New AP of the pool.\\n\\tfunction setPool(uint256 _pid, uint256 _allocPoint) public onlyOwner {\\n\\t\\ttotalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n\\t\\tpoolInfo[_pid].allocPoint = _allocPoint.to64();\\n\\n\\t\\temit PoolSet(_pid, _allocPoint);\\n\\t}\\n\\n\\t/// @notice Update reward variables of the given pool.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @return pool Returns the pool that was updated.\\n\\tfunction updatePool(uint256 pid) public returns (PoolInfo memory pool) {\\n\\t\\tpool = poolInfo[pid];\\n\\n\\t\\tif (block.number > pool.lastRewardBlock) {\\n\\t\\t\\tuint256 lpSupply = MC_V2.lpToken(pid).balanceOf(address(MC_V2));\\n\\n\\t\\t\\tif (lpSupply > 0) {\\n\\t\\t\\t\\tuint256 blocks = block.number.sub(pool.lastRewardBlock);\\n\\t\\t\\t\\tuint256 tokenReward = blocks.mul(tokenPerBlock).mul(pool.allocPoint) / totalAllocPoint;\\n\\t\\t\\t\\tpool.accTokenPerShare = pool.accTokenPerShare.add(\\n\\t\\t\\t\\t\\t(tokenReward.mul(ACC_TOKEN_PRECISION) / lpSupply).to128()\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tpool.lastRewardBlock = block.number.to64();\\n\\t\\t\\tpoolInfo[pid] = pool;\\n\\n\\t\\t\\temit PoolUpdated(pid, pool.lastRewardBlock, lpSupply, pool.accTokenPerShare);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Update reward variables for all pools\\n\\t/// @dev Be careful of gas spending!\\n\\t/// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\\n\\tfunction massUpdatePools(uint256[] calldata pids) public {\\n\\t\\tuint256 len = pids.length;\\n\\t\\tfor (uint256 i = 0; i < len; ++i) {\\n\\t\\t\\tupdatePool(pids[i]);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Sets the distribution reward rate. This will also update all of the pools.\\n\\t/// @param _tokenPerBlock The number of tokens to distribute per block\\n\\tfunction setRewardRate(uint256 _tokenPerBlock, uint256[] calldata _pids) external onlyOwner {\\n\\t\\tmassUpdatePools(_pids);\\n\\n\\t\\tuint256 oldRate = tokenPerBlock;\\n\\t\\ttokenPerBlock = _tokenPerBlock;\\n\\n\\t\\temit RewardRateUpdated(oldRate, _tokenPerBlock);\\n\\t}\\n\\n\\tfunction onSushiReward(\\n\\t\\tuint256 pid,\\n\\t\\taddress _user,\\n\\t\\taddress to,\\n\\t\\tuint256,\\n\\t\\tuint256 lpToken\\n\\t) external override onlyMCV2 {\\n\\t\\tPoolInfo memory pool = updatePool(pid);\\n\\t\\tUserInfo storage user = userInfo[pid][_user];\\n\\t\\tuint256 pending;\\n\\t\\t// if user had deposited\\n\\t\\tif (user.amount > 0) {\\n\\t\\t\\tpending = (user.amount.mul(pool.accTokenPerShare) / ACC_TOKEN_PRECISION).sub(user.rewardDebt);\\n\\t\\t\\trewardToken.safeTransfer(to, pending);\\n\\t\\t}\\n\\n\\t\\tuser.amount = lpToken;\\n\\t\\tuser.rewardDebt = user.rewardDebt.add(pending);\\n\\n\\t\\temit OnReward(_user, pid, pending, to);\\n\\t}\\n\\n\\tfunction pendingTokens(\\n\\t\\tuint256 pid,\\n\\t\\taddress user,\\n\\t\\tuint256\\n\\t) external view override returns (IERC20[] memory rewardTokens, uint256[] memory rewardAmounts) {\\n\\t\\tIERC20[] memory _rewardTokens = new IERC20[](1);\\n\\t\\t_rewardTokens[0] = (rewardToken);\\n\\n\\t\\tuint256[] memory _rewardAmounts = new uint256[](1);\\n\\t\\t_rewardAmounts[0] = pendingToken(pid, user);\\n\\n\\t\\treturn (_rewardTokens, _rewardAmounts);\\n\\t}\\n\\n\\t/// @notice View function to see pending Token\\n\\t/// @param _pid The index of the pool. See `poolInfo`.\\n\\t/// @param _user Address of user.\\n\\t/// @return pending SUSHI reward for a given user.\\n\\tfunction pendingToken(uint256 _pid, address _user) public view returns (uint256 pending) {\\n\\t\\tPoolInfo memory pool = poolInfo[_pid];\\n\\t\\tUserInfo storage user = userInfo[_pid][_user];\\n\\n\\t\\tuint256 accTokenPerShare = pool.accTokenPerShare;\\n\\t\\tuint256 lpSupply = MC_V2.lpToken(_pid).balanceOf(address(MC_V2));\\n\\n\\t\\tif (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n\\t\\t\\tuint256 blocks = block.number.sub(pool.lastRewardBlock);\\n\\t\\t\\tuint256 tokenReward = blocks.mul(tokenPerBlock).mul(pool.allocPoint) / totalAllocPoint;\\n\\t\\t\\taccTokenPerShare = accTokenPerShare.add(tokenReward.mul(ACC_TOKEN_PRECISION) / lpSupply);\\n\\t\\t}\\n\\n\\t\\tpending = (user.amount.mul(accTokenPerShare) / ACC_TOKEN_PRECISION).sub(user.rewardDebt);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/boring/BoringMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n/// @notice A library for performing overflow-/underflow-safe math,\\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\\nlibrary BoringMath {\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n\\t\\trequire((c = a + b) >= b, \\\"BoringMath::add: Add Overflow\\\");\\n\\t}\\n\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n\\t\\trequire((c = a - b) <= a, \\\"BoringMath::sub: Underflow\\\");\\n\\t}\\n\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n\\t\\trequire(b == 0 || (c = a * b) / b == a, \\\"BoringMath::mul: Mul Overflow\\\");\\n\\t}\\n\\n\\tfunction to128(uint256 a) internal pure returns (uint128 c) {\\n\\t\\trequire(a <= uint128(-1), \\\"BoringMath::to128: uint128 Overflow\\\");\\n\\t\\tc = uint128(a);\\n\\t}\\n\\n\\tfunction to64(uint256 a) internal pure returns (uint64 c) {\\n\\t\\trequire(a <= uint64(-1), \\\"BoringMath::to64: uint64 Overflow\\\");\\n\\t\\tc = uint64(a);\\n\\t}\\n\\n\\tfunction to32(uint256 a) internal pure returns (uint32 c) {\\n\\t\\trequire(a <= uint32(-1), \\\"BoringMath::to32: uint32 Overflow\\\");\\n\\t\\tc = uint32(a);\\n\\t}\\n}\\n\\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\\nlibrary BoringMath128 {\\n\\tfunction add(uint128 a, uint128 b) internal pure returns (uint128 c) {\\n\\t\\trequire((c = a + b) >= b, \\\"BoringMath128::add: Add Overflow\\\");\\n\\t}\\n\\n\\tfunction sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\\n\\t\\trequire((c = a - b) <= a, \\\"BoringMath128::sub: Underflow\\\");\\n\\t}\\n}\\n\\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\\nlibrary BoringMath64 {\\n\\tfunction add(uint64 a, uint64 b) internal pure returns (uint64 c) {\\n\\t\\trequire((c = a + b) >= b, \\\"BoringMath64::add: Add Overflow\\\");\\n\\t}\\n\\n\\tfunction sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\\n\\t\\trequire((c = a - b) <= a, \\\"BoringMath64::sub: Underflow\\\");\\n\\t}\\n}\\n\\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\\nlibrary BoringMath32 {\\n\\tfunction add(uint32 a, uint32 b) internal pure returns (uint32 c) {\\n\\t\\trequire((c = a + b) >= b, \\\"BoringMath32::add: Add Overflow\\\");\\n\\t}\\n\\n\\tfunction sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\\n\\t\\trequire((c = a - b) <= a, \\\"BoringMath32::sub: Underflow\\\");\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/boring/BoringOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\\n// Edited by BoringCrypto\\n\\ncontract BoringOwnableData {\\n\\taddress public owner;\\n\\taddress public pendingOwner;\\n}\\n\\ncontract BoringOwnable is BoringOwnableData {\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\t/// @notice `owner` defaults to msg.sender on construction.\\n\\tconstructor() public {\\n\\t\\towner = msg.sender;\\n\\t\\temit OwnershipTransferred(address(0), msg.sender);\\n\\t}\\n\\n\\t/// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\\n\\t/// Can only be invoked by the current `owner`.\\n\\t/// @param newOwner Address of the new owner.\\n\\t/// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\\n\\t/// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\\n\\tfunction transferOwnership(\\n\\t\\taddress newOwner,\\n\\t\\tbool direct,\\n\\t\\tbool renounce\\n\\t) public onlyOwner {\\n\\t\\tif (direct) {\\n\\t\\t\\t// Checks\\n\\t\\t\\trequire(newOwner != address(0) || renounce, \\\"BoringOwnable::transferOwnership: zero address\\\");\\n\\n\\t\\t\\t// Effects\\n\\t\\t\\temit OwnershipTransferred(owner, newOwner);\\n\\t\\t\\towner = newOwner;\\n\\t\\t\\tpendingOwner = address(0);\\n\\t\\t} else {\\n\\t\\t\\t// Effects\\n\\t\\t\\tpendingOwner = newOwner;\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Needs to be called by `pendingOwner` to claim ownership.\\n\\tfunction claimOwnership() public {\\n\\t\\taddress _pendingOwner = pendingOwner;\\n\\n\\t\\t// Checks\\n\\t\\trequire(msg.sender == _pendingOwner, \\\"BoringOwnable::claimOwnership: caller != pending owner\\\");\\n\\n\\t\\t// Effects\\n\\t\\temit OwnershipTransferred(owner, _pendingOwner);\\n\\t\\towner = _pendingOwner;\\n\\t\\tpendingOwner = address(0);\\n\\t}\\n\\n\\t/// @notice Only allows the `owner` to execute the function.\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(msg.sender == owner, \\\"BoringOwnable::onlyOwner: caller is not the owner\\\");\\n\\t\\t_;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/boring/BoringERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n// solhint-disable avoid-low-level-calls\\nlibrary BoringERC20 {\\n\\tbytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\\n\\tbytes4 private constant SIG_NAME = 0x06fdde03; // name()\\n\\tbytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\\n\\tbytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\\n\\tbytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\\n\\n\\tfunction returnDataToString(bytes memory data) internal pure returns (string memory) {\\n\\t\\tif (data.length >= 64) {\\n\\t\\t\\treturn abi.decode(data, (string));\\n\\t\\t} else if (data.length == 32) {\\n\\t\\t\\tuint8 i = 0;\\n\\t\\t\\twhile (i < 32 && data[i] != 0) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tbytes memory bytesArray = new bytes(i);\\n\\t\\t\\tfor (i = 0; i < 32 && data[i] != 0; i++) {\\n\\t\\t\\t\\tbytesArray[i] = data[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn string(bytesArray);\\n\\t\\t} else {\\n\\t\\t\\treturn \\\"???\\\";\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\\n\\t/// @param token The address of the ERC-20 token contract.\\n\\t/// @return (string) Token symbol.\\n\\tfunction safeSymbol(IERC20 token) internal view returns (string memory) {\\n\\t\\t(bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\\n\\t\\treturn success ? returnDataToString(data) : \\\"???\\\";\\n\\t}\\n\\n\\t/// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\\n\\t/// @param token The address of the ERC-20 token contract.\\n\\t/// @return (string) Token name.\\n\\tfunction safeName(IERC20 token) internal view returns (string memory) {\\n\\t\\t(bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\\n\\t\\treturn success ? returnDataToString(data) : \\\"???\\\";\\n\\t}\\n\\n\\t/// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\\n\\t/// @param token The address of the ERC-20 token contract.\\n\\t/// @return (uint8) Token decimals.\\n\\tfunction safeDecimals(IERC20 token) internal view returns (uint8) {\\n\\t\\t(bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\\n\\t\\treturn success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\n\\t}\\n\\n\\t/// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\\n\\t/// Reverts on a failed transfer.\\n\\t/// @param token The address of the ERC-20 token.\\n\\t/// @param to Transfer tokens to.\\n\\t/// @param amount The token amount.\\n\\tfunction safeTransfer(\\n\\t\\tIERC20 token,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) internal {\\n\\t\\t(bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\\n\\t\\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20::safeTransfer: transfer failed\\\");\\n\\t}\\n\\n\\t/// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\\n\\t/// Reverts on a failed transfer.\\n\\t/// @param token The address of the ERC-20 token.\\n\\t/// @param from Transfer tokens from.\\n\\t/// @param to Transfer tokens to.\\n\\t/// @param amount The token amount.\\n\\tfunction safeTransferFrom(\\n\\t\\tIERC20 token,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) internal {\\n\\t\\t(bool success, bytes memory data) =\\n\\t\\t\\taddress(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\\n\\t\\trequire(\\n\\t\\t\\tsuccess && (data.length == 0 || abi.decode(data, (bool))),\\n\\t\\t\\t\\\"BoringERC20::safeTransferFrom: transfer failed\\\"\\n\\t\\t);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/sushi/IRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"../../libraries/boring/BoringERC20.sol\\\";\\n\\ninterface IRewarder {\\n\\tusing BoringERC20 for IERC20;\\n\\n\\tfunction onSushiReward(\\n\\t\\tuint256 pid,\\n\\t\\taddress user,\\n\\t\\taddress recipient,\\n\\t\\tuint256 sushiAmount,\\n\\t\\tuint256 newLpAmount\\n\\t) external;\\n\\n\\tfunction pendingTokens(\\n\\t\\tuint256 pid,\\n\\t\\taddress user,\\n\\t\\tuint256 sushiAmount\\n\\t) external view returns (IERC20[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/sushi/IMasterChefV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../libraries/boring/BoringERC20.sol\\\";\\n\\ninterface IMasterChefV2 {\\n\\tusing BoringERC20 for IERC20;\\n\\n\\tstruct UserInfo {\\n\\t\\tuint256 amount; // How many LP tokens the user has provided.\\n\\t\\tuint256 rewardDebt; // Reward debt. See explanation below.\\n\\t}\\n\\n\\tstruct PoolInfo {\\n\\t\\tIERC20 lpToken; // Address of LP token contract.\\n\\t\\tuint256 allocPoint; // How many allocation points assigned to this pool. SUSHI to distribute per block.\\n\\t\\tuint256 lastRewardBlock; // Last block number that SUSHI distribution occurs.\\n\\t\\tuint256 accSushiPerShare; // Accumulated SUSHI per share, times 1e12. See below.\\n\\t}\\n\\n\\tfunction lpToken(uint256 pid) external view returns (IERC20);\\n\\n\\tfunction poolInfo(uint256 pid) external view returns (PoolInfo memory);\\n\\n\\tfunction totalAllocPoint() external view returns (uint256);\\n\\n\\tfunction deposit(uint256 _pid, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/StakingPools.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { ReentrancyGuard } from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport { StakingPools } from \\\"./StakingPools.sol\\\";\\nimport { FixedPointMath } from \\\"./libraries/math/FixedPointMath.sol\\\";\\nimport { IMintableERC20 } from \\\"./interfaces/token/ERC20/IMintableERC20.sol\\\";\\nimport { Pool } from \\\"./libraries/pools/Pool.sol\\\";\\nimport { Stake } from \\\"./libraries/pools/Stake.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title StakingPools\\n//    ___    __        __                _               ___                              __         _\\n//   / _ |  / / ____  / /  ___   __ _   (_) __ __       / _ \\\\  ____ ___   ___ ___   ___  / /_  ___  (_)\\n//  / __ | / / / __/ / _ \\\\/ -_) /  ' \\\\ / /  \\\\ \\\\ /      / ___/ / __// -_) (_-</ -_) / _ \\\\/ __/ (_-< _\\n// /_/ |_|/_/  \\\\__/ /_//_/\\\\__/ /_/_/_//_/  /_\\\\_\\\\      /_/    /_/   \\\\__/ /___/\\\\__/ /_//_/\\\\__/ /___/(_)\\n//\\n//      _______..___________.     ___       __  ___  __  .__   __.   _______    .______     ______     ______    __           _______.\\n//     /       ||           |    /   \\\\     |  |/  / |  | |  \\\\ |  |  /  _____|   |   _  \\\\   /  __  \\\\   /  __  \\\\  |  |         /       |\\n//    |   (----``---|  |----`   /  ^  \\\\    |  '  /  |  | |   \\\\|  | |  |  __     |  |_)  | |  |  |  | |  |  |  | |  |        |   (----`\\n//     \\\\   \\\\        |  |       /  /_\\\\  \\\\   |    <   |  | |  . `  | |  | |_ |    |   ___/  |  |  |  | |  |  |  | |  |         \\\\   \\\\\\n// .----)   |       |  |      /  _____  \\\\  |  .  \\\\  |  | |  |\\\\   | |  |__| |    |  |      |  `--'  | |  `--'  | |  `----..----)   |\\n// |_______/        |__|     /__/     \\\\__\\\\ |__|\\\\__\\\\ |__| |__| \\\\__|  \\\\______|    | _|       \\\\______/   \\\\______/  |_______||_______/\\n///\\n/// @dev A contract which allows users to stake to farm tokens.\\n///\\n/// This contract was inspired by Chef Nomi's 'MasterChef' contract which can be found in this\\n/// repository: https://github.com/sushiswap/sushiswap.\\ncontract StakingPools is ReentrancyGuard {\\n\\tusing FixedPointMath for FixedPointMath.uq192x64;\\n\\tusing Pool for Pool.Data;\\n\\tusing Pool for Pool.List;\\n\\tusing SafeERC20 for IERC20;\\n\\tusing SafeMath for uint256;\\n\\tusing Stake for Stake.Data;\\n\\n\\tevent PendingGovernanceUpdated(address pendingGovernance);\\n\\n\\tevent GovernanceUpdated(address governance);\\n\\n\\tevent RewardRateUpdated(uint256 rewardRate);\\n\\n\\tevent PoolRewardWeightUpdated(uint256 indexed poolId, uint256 rewardWeight);\\n\\n\\tevent PoolCreated(uint256 indexed poolId, IERC20 indexed token);\\n\\n\\tevent TokensDeposited(address indexed user, uint256 indexed poolId, uint256 amount);\\n\\n\\tevent TokensWithdrawn(address indexed user, uint256 indexed poolId, uint256 amount);\\n\\n\\tevent TokensClaimed(address indexed user, uint256 indexed poolId, uint256 amount);\\n\\n\\t/// @dev The token which will be minted as a reward for staking.\\n\\tIMintableERC20 public reward;\\n\\n\\t/// @dev The address of the account which currently has administrative capabilities over this contract.\\n\\taddress public governance;\\n\\n\\taddress public pendingGovernance;\\n\\n\\t/// @dev Tokens are mapped to their pool identifier plus one. Tokens that do not have an associated pool\\n\\t/// will return an identifier of zero.\\n\\tmapping(IERC20 => uint256) public tokenPoolIds;\\n\\n\\t/// @dev The context shared between the pools.\\n\\tPool.Context private _ctx;\\n\\n\\t/// @dev A list of all of the pools.\\n\\tPool.List private _pools;\\n\\n\\t/// @dev A mapping of all of the user stakes mapped first by pool and then by address.\\n\\tmapping(address => mapping(uint256 => Stake.Data)) private _stakes;\\n\\n\\tconstructor(IMintableERC20 _reward, address _governance) public {\\n\\t\\trequire(_governance != address(0), \\\"StakingPools: governance address cannot be 0x0\\\");\\n\\n\\t\\treward = _reward;\\n\\t\\tgovernance = _governance;\\n\\t}\\n\\n\\t/// @dev A modifier which reverts when the caller is not the governance.\\n\\tmodifier onlyGovernance() {\\n\\t\\trequire(msg.sender == governance, \\\"StakingPools: only governance\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t/// @dev Sets the governance.\\n\\t///\\n\\t/// This function can only called by the current governance.\\n\\t///\\n\\t/// @param _pendingGovernance the new pending governance.\\n\\tfunction setPendingGovernance(address _pendingGovernance) external onlyGovernance {\\n\\t\\trequire(_pendingGovernance != address(0), \\\"StakingPools: pending governance address cannot be 0x0\\\");\\n\\t\\tpendingGovernance = _pendingGovernance;\\n\\n\\t\\temit PendingGovernanceUpdated(_pendingGovernance);\\n\\t}\\n\\n\\tfunction acceptGovernance() external {\\n\\t\\trequire(msg.sender == pendingGovernance, \\\"StakingPools: only pending governance\\\");\\n\\n\\t\\taddress _pendingGovernance = pendingGovernance;\\n\\t\\tgovernance = _pendingGovernance;\\n\\n\\t\\temit GovernanceUpdated(_pendingGovernance);\\n\\t}\\n\\n\\t/// @dev Sets the distribution reward rate.\\n\\t///\\n\\t/// This will update all of the pools.\\n\\t///\\n\\t/// @param _rewardRate The number of tokens to distribute per second.\\n\\tfunction setRewardRate(uint256 _rewardRate) external onlyGovernance {\\n\\t\\t_updatePools();\\n\\n\\t\\t_ctx.rewardRate = _rewardRate;\\n\\n\\t\\temit RewardRateUpdated(_rewardRate);\\n\\t}\\n\\n\\t/// @dev Creates a new pool.\\n\\t///\\n\\t/// The created pool will need to have its reward weight initialized before it begins generating rewards.\\n\\t///\\n\\t/// @param _token The token the pool will accept for staking.\\n\\t///\\n\\t/// @return the identifier for the newly created pool.\\n\\tfunction createPool(IERC20 _token) external onlyGovernance returns (uint256) {\\n\\t\\trequire(tokenPoolIds[_token] == 0, \\\"StakingPools: token already has a pool\\\");\\n\\n\\t\\tuint256 _poolId = _pools.length();\\n\\n\\t\\t_pools.push(\\n\\t\\t\\tPool.Data({\\n\\t\\t\\t\\ttoken: _token,\\n\\t\\t\\t\\ttotalDeposited: 0,\\n\\t\\t\\t\\trewardWeight: 0,\\n\\t\\t\\t\\taccumulatedRewardWeight: FixedPointMath.uq192x64(0),\\n\\t\\t\\t\\tlastUpdatedBlock: block.number\\n\\t\\t\\t})\\n\\t\\t);\\n\\n\\t\\ttokenPoolIds[_token] = _poolId + 1;\\n\\n\\t\\temit PoolCreated(_poolId, _token);\\n\\n\\t\\treturn _poolId;\\n\\t}\\n\\n\\t/// @dev Sets the reward weights of all of the pools.\\n\\t///\\n\\t/// @param _rewardWeights The reward weights of all of the pools.\\n\\tfunction setRewardWeights(uint256[] calldata _rewardWeights) external onlyGovernance {\\n\\t\\trequire(_rewardWeights.length == _pools.length(), \\\"StakingPools: weights length mismatch\\\");\\n\\n\\t\\t_updatePools();\\n\\n\\t\\tuint256 _totalRewardWeight = _ctx.totalRewardWeight;\\n\\t\\tfor (uint256 _poolId = 0; _poolId < _pools.length(); _poolId++) {\\n\\t\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\n\\t\\t\\tuint256 _currentRewardWeight = _pool.rewardWeight;\\n\\t\\t\\tif (_currentRewardWeight == _rewardWeights[_poolId]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// FIXME\\n\\t\\t\\t_totalRewardWeight = _totalRewardWeight.sub(_currentRewardWeight).add(_rewardWeights[_poolId]);\\n\\t\\t\\t_pool.rewardWeight = _rewardWeights[_poolId];\\n\\n\\t\\t\\temit PoolRewardWeightUpdated(_poolId, _rewardWeights[_poolId]);\\n\\t\\t}\\n\\n\\t\\t_ctx.totalRewardWeight = _totalRewardWeight;\\n\\t}\\n\\n\\t/// @dev Stakes tokens into a pool.\\n\\t///\\n\\t/// @param _poolId        the pool to deposit tokens into.\\n\\t/// @param _depositAmount the amount of tokens to deposit.\\n\\tfunction deposit(uint256 _poolId, uint256 _depositAmount) external nonReentrant {\\n\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\t_pool.update(_ctx);\\n\\n\\t\\tStake.Data storage _stake = _stakes[msg.sender][_poolId];\\n\\t\\t_stake.update(_pool, _ctx);\\n\\n\\t\\t_deposit(_poolId, _depositAmount);\\n\\t}\\n\\n\\t/// @dev Withdraws staked tokens from a pool.\\n\\t///\\n\\t/// @param _poolId          The pool to withdraw staked tokens from.\\n\\t/// @param _withdrawAmount  The number of tokens to withdraw.\\n\\tfunction withdraw(uint256 _poolId, uint256 _withdrawAmount) external nonReentrant {\\n\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\t_pool.update(_ctx);\\n\\n\\t\\tStake.Data storage _stake = _stakes[msg.sender][_poolId];\\n\\t\\t_stake.update(_pool, _ctx);\\n\\n\\t\\t_claim(_poolId);\\n\\t\\t_withdraw(_poolId, _withdrawAmount);\\n\\t}\\n\\n\\t/// @dev Claims all rewarded tokens from a pool.\\n\\t///\\n\\t/// @param _poolId The pool to claim rewards from.\\n\\t///\\n\\t/// @notice use this function to claim the tokens from a corresponding pool by ID.\\n\\tfunction claim(uint256 _poolId) external nonReentrant {\\n\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\t_pool.update(_ctx);\\n\\n\\t\\tStake.Data storage _stake = _stakes[msg.sender][_poolId];\\n\\t\\t_stake.update(_pool, _ctx);\\n\\n\\t\\t_claim(_poolId);\\n\\t}\\n\\n\\t/// @dev Claims all rewards from a pool and then withdraws all staked tokens.\\n\\t///\\n\\t/// @param _poolId the pool to exit from.\\n\\tfunction exit(uint256 _poolId) external nonReentrant {\\n\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\t_pool.update(_ctx);\\n\\n\\t\\tStake.Data storage _stake = _stakes[msg.sender][_poolId];\\n\\t\\t_stake.update(_pool, _ctx);\\n\\n\\t\\t_claim(_poolId);\\n\\t\\t_withdraw(_poolId, _stake.totalDeposited);\\n\\t}\\n\\n\\t/// @dev Gets the rate at which tokens are minted to stakers for all pools.\\n\\t///\\n\\t/// @return the reward rate.\\n\\tfunction rewardRate() external view returns (uint256) {\\n\\t\\treturn _ctx.rewardRate;\\n\\t}\\n\\n\\t/// @dev Gets the total reward weight between all the pools.\\n\\t///\\n\\t/// @return the total reward weight.\\n\\tfunction totalRewardWeight() external view returns (uint256) {\\n\\t\\treturn _ctx.totalRewardWeight;\\n\\t}\\n\\n\\t/// @dev Gets the number of pools that exist.\\n\\t///\\n\\t/// @return the pool count.\\n\\tfunction poolCount() external view returns (uint256) {\\n\\t\\treturn _pools.length();\\n\\t}\\n\\n\\t/// @dev Gets the token a pool accepts.\\n\\t///\\n\\t/// @param _poolId the identifier of the pool.\\n\\t///\\n\\t/// @return the token.\\n\\tfunction getPoolToken(uint256 _poolId) external view returns (IERC20) {\\n\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\treturn _pool.token;\\n\\t}\\n\\n\\t/// @dev Gets the total amount of funds staked in a pool.\\n\\t///\\n\\t/// @param _poolId the identifier of the pool.\\n\\t///\\n\\t/// @return the total amount of staked or deposited tokens.\\n\\tfunction getPoolTotalDeposited(uint256 _poolId) external view returns (uint256) {\\n\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\treturn _pool.totalDeposited;\\n\\t}\\n\\n\\t/// @dev Gets the reward weight of a pool which determines how much of the total rewards it receives per block.\\n\\t///\\n\\t/// @param _poolId the identifier of the pool.\\n\\t///\\n\\t/// @return the pool reward weight.\\n\\tfunction getPoolRewardWeight(uint256 _poolId) external view returns (uint256) {\\n\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\treturn _pool.rewardWeight;\\n\\t}\\n\\n\\t/// @dev Gets the amount of tokens per block being distributed to stakers for a pool.\\n\\t///\\n\\t/// @param _poolId the identifier of the pool.\\n\\t///\\n\\t/// @return the pool reward rate.\\n\\tfunction getPoolRewardRate(uint256 _poolId) external view returns (uint256) {\\n\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\treturn _pool.getRewardRate(_ctx);\\n\\t}\\n\\n\\t/// @dev Gets the number of tokens a user has staked into a pool.\\n\\t///\\n\\t/// @param _account The account to query.\\n\\t/// @param _poolId  the identifier of the pool.\\n\\t///\\n\\t/// @return the amount of deposited tokens.\\n\\tfunction getStakeTotalDeposited(address _account, uint256 _poolId) external view returns (uint256) {\\n\\t\\tStake.Data storage _stake = _stakes[_account][_poolId];\\n\\t\\treturn _stake.totalDeposited;\\n\\t}\\n\\n\\t/// @dev Gets the number of unclaimed reward tokens a user can claim from a pool.\\n\\t///\\n\\t/// @param _account The account to get the unclaimed balance of.\\n\\t/// @param _poolId  The pool to check for unclaimed rewards.\\n\\t///\\n\\t/// @return the amount of unclaimed reward tokens a user has in a pool.\\n\\tfunction getStakeTotalUnclaimed(address _account, uint256 _poolId) external view returns (uint256) {\\n\\t\\tStake.Data storage _stake = _stakes[_account][_poolId];\\n\\t\\treturn _stake.getUpdatedTotalUnclaimed(_pools.get(_poolId), _ctx);\\n\\t}\\n\\n\\t/// @dev Updates all of the pools.\\n\\tfunction _updatePools() internal {\\n\\t\\tfor (uint256 _poolId = 0; _poolId < _pools.length(); _poolId++) {\\n\\t\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\t\\t_pool.update(_ctx);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Stakes tokens into a pool.\\n\\t///\\n\\t/// The pool and stake MUST be updated before calling this function.\\n\\t///\\n\\t/// @param _poolId        the pool to deposit tokens into.\\n\\t/// @param _depositAmount the amount of tokens to deposit.\\n\\tfunction _deposit(uint256 _poolId, uint256 _depositAmount) internal {\\n\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\tStake.Data storage _stake = _stakes[msg.sender][_poolId];\\n\\n\\t\\t_pool.totalDeposited = _pool.totalDeposited.add(_depositAmount);\\n\\t\\t_stake.totalDeposited = _stake.totalDeposited.add(_depositAmount);\\n\\n\\t\\t_pool.token.safeTransferFrom(msg.sender, address(this), _depositAmount);\\n\\n\\t\\temit TokensDeposited(msg.sender, _poolId, _depositAmount);\\n\\t}\\n\\n\\t/// @dev Withdraws staked tokens from a pool.\\n\\t///\\n\\t/// The pool and stake MUST be updated before calling this function.\\n\\t///\\n\\t/// @param _poolId          The pool to withdraw staked tokens from.\\n\\t/// @param _withdrawAmount  The number of tokens to withdraw.\\n\\tfunction _withdraw(uint256 _poolId, uint256 _withdrawAmount) internal {\\n\\t\\tPool.Data storage _pool = _pools.get(_poolId);\\n\\t\\tStake.Data storage _stake = _stakes[msg.sender][_poolId];\\n\\n\\t\\t_pool.totalDeposited = _pool.totalDeposited.sub(_withdrawAmount);\\n\\t\\t_stake.totalDeposited = _stake.totalDeposited.sub(_withdrawAmount);\\n\\n\\t\\t_pool.token.safeTransfer(msg.sender, _withdrawAmount);\\n\\n\\t\\temit TokensWithdrawn(msg.sender, _poolId, _withdrawAmount);\\n\\t}\\n\\n\\t/// @dev Claims all rewarded tokens from a pool.\\n\\t///\\n\\t/// The pool and stake MUST be updated before calling this function.\\n\\t///\\n\\t/// @param _poolId The pool to claim rewards from.\\n\\t///\\n\\t/// @notice use this function to claim the tokens from a corresponding pool by ID.\\n\\tfunction _claim(uint256 _poolId) internal {\\n\\t\\tStake.Data storage _stake = _stakes[msg.sender][_poolId];\\n\\n\\t\\tuint256 _claimAmount = _stake.totalUnclaimed;\\n\\t\\t_stake.totalUnclaimed = 0;\\n\\n\\t\\treward.mint(msg.sender, _claimAmount);\\n\\n\\t\\temit TokensClaimed(msg.sender, _poolId, _claimAmount);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/FixedPointMath.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.12;\\n\\nlibrary FixedPointMath {\\n\\tuint256 public constant DECIMALS = 18;\\n\\tuint256 public constant SCALAR = 10**DECIMALS;\\n\\n\\tstruct uq192x64 {\\n\\t\\tuint256 x;\\n\\t}\\n\\n\\tfunction fromU256(uint256 value) internal pure returns (uq192x64 memory) {\\n\\t\\tuint256 x;\\n\\t\\trequire(value == 0 || (x = value * SCALAR) / SCALAR == value);\\n\\t\\treturn uq192x64(x);\\n\\t}\\n\\n\\tfunction maximumValue() internal pure returns (uq192x64 memory) {\\n\\t\\treturn uq192x64(uint256(-1));\\n\\t}\\n\\n\\tfunction add(uq192x64 memory self, uq192x64 memory value) internal pure returns (uq192x64 memory) {\\n\\t\\tuint256 x;\\n\\t\\trequire((x = self.x + value.x) >= self.x);\\n\\t\\treturn uq192x64(x);\\n\\t}\\n\\n\\tfunction add(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\\n\\t\\treturn add(self, fromU256(value));\\n\\t}\\n\\n\\tfunction sub(uq192x64 memory self, uq192x64 memory value) internal pure returns (uq192x64 memory) {\\n\\t\\tuint256 x;\\n\\t\\trequire((x = self.x - value.x) <= self.x);\\n\\t\\treturn uq192x64(x);\\n\\t}\\n\\n\\tfunction sub(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\\n\\t\\treturn sub(self, fromU256(value));\\n\\t}\\n\\n\\tfunction mul(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\\n\\t\\tuint256 x;\\n\\t\\trequire(value == 0 || (x = self.x * value) / value == self.x);\\n\\t\\treturn uq192x64(x);\\n\\t}\\n\\n\\tfunction div(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\\n\\t\\trequire(value != 0);\\n\\t\\treturn uq192x64(self.x / value);\\n\\t}\\n\\n\\tfunction cmp(uq192x64 memory self, uq192x64 memory value) internal pure returns (int256) {\\n\\t\\tif (self.x < value.x) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tif (self.x > value.x) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfunction decode(uq192x64 memory self) internal pure returns (uint256) {\\n\\t\\treturn self.x / SCALAR;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/token/ERC20/IMintableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.12;\\n\\nimport { IDetailedERC20 } from \\\"./IDetailedERC20.sol\\\";\\n\\ninterface IMintableERC20 is IDetailedERC20 {\\n\\tfunction mint(address _recipient, uint256 _amount) external;\\n\\n\\tfunction burnFrom(address account, uint256 amount) external;\\n\\n\\tfunction lowerHasMinted(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/pools/Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport { Math } from \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport { FixedPointMath } from \\\"../math/FixedPointMath.sol\\\";\\nimport { IDetailedERC20 } from \\\"../../interfaces/token/ERC20/IDetailedERC20.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title Pool\\n///\\n/// @dev A library which provides the Pool data struct and associated functions.\\nlibrary Pool {\\n\\tusing FixedPointMath for FixedPointMath.uq192x64;\\n\\tusing Pool for Pool.Data;\\n\\tusing Pool for Pool.List;\\n\\tusing SafeMath for uint256;\\n\\n\\tstruct Context {\\n\\t\\tuint256 rewardRate;\\n\\t\\tuint256 totalRewardWeight;\\n\\t}\\n\\n\\tstruct Data {\\n\\t\\tIERC20 token;\\n\\t\\tuint256 totalDeposited;\\n\\t\\tuint256 rewardWeight;\\n\\t\\tFixedPointMath.uq192x64 accumulatedRewardWeight;\\n\\t\\tuint256 lastUpdatedBlock;\\n\\t}\\n\\n\\tstruct List {\\n\\t\\tData[] elements;\\n\\t}\\n\\n\\t/// @dev Updates the pool.\\n\\t///\\n\\t/// @param _ctx the pool context.\\n\\tfunction update(Data storage _data, Context storage _ctx) internal {\\n\\t\\t_data.accumulatedRewardWeight = _data.getUpdatedAccumulatedRewardWeight(_ctx);\\n\\t\\t_data.lastUpdatedBlock = block.number;\\n\\t}\\n\\n\\t/// @dev Gets the rate at which the pool will distribute rewards to stakers.\\n\\t///\\n\\t/// @param _ctx the pool context.\\n\\t///\\n\\t/// @return the reward rate of the pool in tokens per block.\\n\\tfunction getRewardRate(Data storage _data, Context storage _ctx) internal view returns (uint256) {\\n\\t\\t// console.log(\\\"get reward rate\\\");\\n\\t\\t// console.log(uint(_data.rewardWeight));\\n\\t\\t// console.log(uint(_ctx.totalRewardWeight));\\n\\t\\t// console.log(uint(_ctx.rewardRate));\\n\\t\\treturn _ctx.rewardRate.mul(_data.rewardWeight).div(_ctx.totalRewardWeight);\\n\\t}\\n\\n\\t/// @dev Gets the accumulated reward weight of a pool.\\n\\t///\\n\\t/// @param _ctx the pool context.\\n\\t///\\n\\t/// @return the accumulated reward weight.\\n\\tfunction getUpdatedAccumulatedRewardWeight(Data storage _data, Context storage _ctx)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (FixedPointMath.uq192x64 memory)\\n\\t{\\n\\t\\tif (_data.totalDeposited == 0) {\\n\\t\\t\\treturn _data.accumulatedRewardWeight;\\n\\t\\t}\\n\\n\\t\\tuint256 _elapsedTime = block.number.sub(_data.lastUpdatedBlock);\\n\\t\\tif (_elapsedTime == 0) {\\n\\t\\t\\treturn _data.accumulatedRewardWeight;\\n\\t\\t}\\n\\n\\t\\tuint256 _rewardRate = _data.getRewardRate(_ctx);\\n\\t\\tuint256 _distributeAmount = _rewardRate.mul(_elapsedTime);\\n\\n\\t\\tif (_distributeAmount == 0) {\\n\\t\\t\\treturn _data.accumulatedRewardWeight;\\n\\t\\t}\\n\\n\\t\\tFixedPointMath.uq192x64 memory _rewardWeight =\\n\\t\\t\\tFixedPointMath.fromU256(_distributeAmount).div(_data.totalDeposited);\\n\\t\\treturn _data.accumulatedRewardWeight.add(_rewardWeight);\\n\\t}\\n\\n\\t/// @dev Adds an element to the list.\\n\\t///\\n\\t/// @param _element the element to add.\\n\\tfunction push(List storage _self, Data memory _element) internal {\\n\\t\\t_self.elements.push(_element);\\n\\t}\\n\\n\\t/// @dev Gets an element from the list.\\n\\t///\\n\\t/// @param _index the index in the list.\\n\\t///\\n\\t/// @return the element at the specified index.\\n\\tfunction get(List storage _self, uint256 _index) internal view returns (Data storage) {\\n\\t\\treturn _self.elements[_index];\\n\\t}\\n\\n\\t/// @dev Gets the last element in the list.\\n\\t///\\n\\t/// This function will revert if there are no elements in the list.\\n\\t///ck\\n\\t/// @return the last element in the list.\\n\\tfunction last(List storage _self) internal view returns (Data storage) {\\n\\t\\treturn _self.elements[_self.lastIndex()];\\n\\t}\\n\\n\\t/// @dev Gets the index of the last element in the list.\\n\\t///\\n\\t/// This function will revert if there are no elements in the list.\\n\\t///\\n\\t/// @return the index of the last element.\\n\\tfunction lastIndex(List storage _self) internal view returns (uint256) {\\n\\t\\tuint256 _length = _self.length();\\n\\t\\treturn _length.sub(1, \\\"Pool.List: list is empty\\\");\\n\\t}\\n\\n\\t/// @dev Gets the number of elements in the list.\\n\\t///\\n\\t/// @return the number of elements.\\n\\tfunction length(List storage _self) internal view returns (uint256) {\\n\\t\\treturn _self.elements.length;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/pools/Stake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport { Math } from \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport { FixedPointMath } from \\\"../math/FixedPointMath.sol\\\";\\nimport { IDetailedERC20 } from \\\"../../interfaces/token/ERC20/IDetailedERC20.sol\\\";\\nimport { Pool } from \\\"./Pool.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title Stake\\n///\\n/// @dev A library which provides the Stake data struct and associated functions.\\nlibrary Stake {\\n\\tusing FixedPointMath for FixedPointMath.uq192x64;\\n\\tusing Pool for Pool.Data;\\n\\tusing SafeMath for uint256;\\n\\tusing Stake for Stake.Data;\\n\\n\\tstruct Data {\\n\\t\\tuint256 totalDeposited;\\n\\t\\tuint256 totalUnclaimed;\\n\\t\\tFixedPointMath.uq192x64 lastAccumulatedWeight;\\n\\t}\\n\\n\\tfunction update(\\n\\t\\tData storage _self,\\n\\t\\tPool.Data storage _pool,\\n\\t\\tPool.Context storage _ctx\\n\\t) internal {\\n\\t\\t_self.totalUnclaimed = _self.getUpdatedTotalUnclaimed(_pool, _ctx);\\n\\t\\t_self.lastAccumulatedWeight = _pool.getUpdatedAccumulatedRewardWeight(_ctx);\\n\\t}\\n\\n\\tfunction getUpdatedTotalUnclaimed(\\n\\t\\tData storage _self,\\n\\t\\tPool.Data storage _pool,\\n\\t\\tPool.Context storage _ctx\\n\\t) internal view returns (uint256) {\\n\\t\\tFixedPointMath.uq192x64 memory _currentAccumulatedWeight = _pool.getUpdatedAccumulatedRewardWeight(_ctx);\\n\\t\\tFixedPointMath.uq192x64 memory _lastAccumulatedWeight = _self.lastAccumulatedWeight;\\n\\n\\t\\tif (_currentAccumulatedWeight.cmp(_lastAccumulatedWeight) == 0) {\\n\\t\\t\\treturn _self.totalUnclaimed;\\n\\t\\t}\\n\\n\\t\\tuint256 _distributedAmount =\\n\\t\\t\\t_currentAccumulatedWeight.sub(_lastAccumulatedWeight).mul(_self.totalDeposited).decode();\\n\\n\\t\\treturn _self.totalUnclaimed.add(_distributedAmount);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/token/ERC20/IDetailedERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.12;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IDetailedERC20 is IERC20 {\\n\\tfunction name() external returns (string memory);\\n\\n\\tfunction symbol() external returns (string memory);\\n\\n\\tfunction decimals() external returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/tokens/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"../../Domain.sol\\\";\\nimport \\\"../../../interfaces/token/ERC20/IDetailedERC20.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n// solhint-disable no-inline-assembly\\n// solhint-disable not-rely-on-time\\n\\n// Data part taken out for building of contracts that receive delegate calls\\ncontract ERC20Data {\\n\\t/// @notice owner > balance mapping.\\n\\tmapping(address => uint256) public balanceOf;\\n\\t/// @notice owner > spender > allowance mapping.\\n\\tmapping(address => mapping(address => uint256)) public allowance;\\n\\t/// @notice owner > nonce mapping. Used in `permit`.\\n\\tmapping(address => uint256) public nonces;\\n\\n\\tstring public name;\\n\\tstring public symbol;\\n\\tuint256 public decimals;\\n}\\n\\ncontract ERC20 is ERC20Data, Domain {\\n\\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\\n\\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n\\n\\t/**\\n\\t * @dev Sets the values for {name} and {symbol}.\\n\\t *\\n\\t * The defaut value of {decimals} is 18. To select a different value for\\n\\t * {decimals} you should overload it.\\n\\t *\\n\\t * All two of these values are immutable: they can only be set once during\\n\\t * construction.\\n\\t */\\n\\tconstructor(string memory name_, string memory symbol_) public {\\n\\t\\tname = name_;\\n\\t\\tsymbol = symbol_;\\n\\t\\tdecimals = 18;\\n\\t}\\n\\n\\t/// @notice Transfers `amount` tokens from `msg.sender` to `to`.\\n\\t/// @param to The address to move the tokens.\\n\\t/// @param amount of the tokens to move.\\n\\t/// @return (bool) Returns True if succeeded.\\n\\tfunction transfer(address to, uint256 amount) public returns (bool) {\\n\\t\\t// If `amount` is 0, or `msg.sender` is `to` nothing happens\\n\\t\\tif (amount != 0) {\\n\\t\\t\\tuint256 srcBalance = balanceOf[msg.sender];\\n\\t\\t\\trequire(srcBalance >= amount, \\\"ERC20::transfer: balance too low\\\");\\n\\t\\t\\tif (msg.sender != to) {\\n\\t\\t\\t\\trequire(to != address(0), \\\"ERC20::transfer: no zero address\\\"); // Moved down so low balance calls safe some gas\\n\\n\\t\\t\\t\\tbalanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\\n\\t\\t\\t\\tbalanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\temit Transfer(msg.sender, to, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\\n\\t/// @param from Address to draw tokens from.\\n\\t/// @param to The address to move the tokens.\\n\\t/// @param amount The token amount to move.\\n\\t/// @return (bool) Returns True if succeeded.\\n\\tfunction transferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) public returns (bool) {\\n\\t\\t// If `amount` is 0, or `from` is `to` nothing happens\\n\\t\\tif (amount != 0) {\\n\\t\\t\\tuint256 srcBalance = balanceOf[from];\\n\\t\\t\\trequire(srcBalance >= amount, \\\"ERC20::transferFrom: balance too low\\\");\\n\\n\\t\\t\\tif (from != to) {\\n\\t\\t\\t\\tuint256 spenderAllowance = allowance[from][msg.sender];\\n\\n\\t\\t\\t\\t// If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\\n\\t\\t\\t\\tif (spenderAllowance != type(uint256).max) {\\n\\t\\t\\t\\t\\trequire(spenderAllowance >= amount, \\\"ERC20::transferFrom: allowance too low\\\");\\n\\t\\t\\t\\t\\tallowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trequire(to != address(0), \\\"ERC20::transferFrom: no zero address\\\"); // Moved down so other failed calls safe some gas\\n\\n\\t\\t\\t\\tbalanceOf[from] = srcBalance - amount; // Underflow is checked\\n\\t\\t\\t\\tbalanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\temit Transfer(from, to, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/// @notice Approves `amount` from sender to be spend by `spender`.\\n\\t/// @param spender Address of the party that can draw from msg.sender's account.\\n\\t/// @param amount The maximum collective amount that `spender` can draw.\\n\\t/// @return (bool) Returns True if approved.\\n\\tfunction approve(address spender, uint256 amount) public returns (bool) {\\n\\t\\tallowance[msg.sender][spender] = amount;\\n\\t\\temit Approval(msg.sender, spender, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// solhint-disable-next-line func-name-mixedcase\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32) {\\n\\t\\treturn _domainSeparator();\\n\\t}\\n\\n\\t// keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\tbytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n\\t/// @notice Approves `value` from `owner_` to be spend by `spender`.\\n\\t/// @param owner_ Address of the owner.\\n\\t/// @param spender The address of the spender that gets approved to draw from `owner_`.\\n\\t/// @param value The maximum collective amount that `spender` can draw.\\n\\t/// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\\n\\tfunction permit(\\n\\t\\taddress owner_,\\n\\t\\taddress spender,\\n\\t\\tuint256 value,\\n\\t\\tuint256 deadline,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external {\\n\\t\\trequire(owner_ != address(0), \\\"ERC20::permit: Owner cannot be 0\\\");\\n\\t\\trequire(block.timestamp < deadline, \\\"ERC20: Expired\\\");\\n\\t\\trequire(\\n\\t\\t\\tecrecover(\\n\\t\\t\\t\\t_getDigest(\\n\\t\\t\\t\\t\\tkeccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\tv,\\n\\t\\t\\t\\tr,\\n\\t\\t\\t\\ts\\n\\t\\t\\t) == owner_,\\n\\t\\t\\t\\\"ERC20::permit: Invalid Signature\\\"\\n\\t\\t);\\n\\t\\tallowance[owner_][spender] = value;\\n\\t\\temit Approval(owner_, spender, value);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Domain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Based on code and smartness by Ross Campbell and Keno\\n// Uses immutable to store the domain separator to reduce gas usage\\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\\npragma solidity 0.6.12;\\n\\n// solhint-disable no-inline-assembly\\n\\ncontract Domain {\\n\\tbytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH =\\n\\t\\tkeccak256(\\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\");\\n\\t// See https://eips.ethereum.org/EIPS/eip-191\\n\\tstring private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \\\"\\\\x19\\\\x01\\\";\\n\\n\\t// solhint-disable var-name-mixedcase\\n\\tbytes32 private immutable _DOMAIN_SEPARATOR;\\n\\tuint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\\n\\n\\t/// @dev Calculate the DOMAIN_SEPARATOR\\n\\tfunction _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\\n\\t\\treturn keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));\\n\\t}\\n\\n\\tconstructor() public {\\n\\t\\tuint256 chainId;\\n\\t\\tassembly {\\n\\t\\t\\tchainId := chainid()\\n\\t\\t}\\n\\t\\t_DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\\n\\t}\\n\\n\\t/// @dev Return the DOMAIN_SEPARATOR\\n\\t// It's named internal to allow making it public from the contract that uses it by creating a simple view function\\n\\t// with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\\n\\t// solhint-disable-next-line func-name-mixedcase\\n\\tfunction _domainSeparator() internal view returns (bytes32) {\\n\\t\\tuint256 chainId;\\n\\t\\tassembly {\\n\\t\\t\\tchainId := chainid()\\n\\t\\t}\\n\\t\\treturn chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\\n\\t}\\n\\n\\tfunction _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\\n\\t\\tdigest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/MockERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"../libraries/tokens/ERC20/ERC20.sol\\\";\\n\\ncontract MockERC20 is ERC20 {\\n\\tuint256 public totalSupply;\\n\\n\\tconstructor(\\n\\t\\tstring memory _name,\\n\\t\\tstring memory _symbol,\\n\\t\\tuint256 _initialAmount\\n\\t) public ERC20(_name, _symbol) {\\n\\t\\t// Give the creator all initial tokens\\n\\t\\tbalanceOf[msg.sender] = _initialAmount;\\n\\t\\t// Update total supply\\n\\t\\ttotalSupply = _initialAmount;\\n\\t}\\n\\n\\tfunction mint(address account, uint256 amount) external {\\n\\t\\trequire(account != address(0), \\\"MockERC20::mint: mint to the zero address\\\");\\n\\n\\t\\ttotalSupply += amount;\\n\\t\\tbalanceOf[account] += amount;\\n\\n\\t\\temit Transfer(address(0), account, amount);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"contracts/MasterChef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./SushiToken.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\ninterface IMigratorChef {\\n\\t// Perform LP token migration from legacy UniswapV2 to SushiSwap.\\n\\t// Take the current LP token address and return the new LP token address.\\n\\t// Migrator should have full access to the caller's LP token.\\n\\t// Return the new LP token address.\\n\\t//\\n\\t// XXX Migrator must have allowance access to UniswapV2 LP tokens.\\n\\t// SushiSwap must mint EXACTLY the same amount of SushiSwap LP tokens or\\n\\t// else something bad will happen. Traditional UniswapV2 does not\\n\\t// do that so be careful!\\n\\tfunction migrate(IERC20 token) external returns (IERC20);\\n}\\n\\n// MasterChef is the master of Sushi. He can make Sushi and he is a fair guy.\\n//\\n// Note that it's ownable and the owner wields tremendous power. The ownership\\n// will be transferred to a governance smart contract once SUSHI is sufficiently\\n// distributed and the community can show to govern itself.\\n//\\n// Have fun reading it. Hopefully it's bug-free. God bless.\\ncontract MasterChef is Ownable {\\n\\tusing SafeMath for uint256;\\n\\tusing SafeERC20 for IERC20;\\n\\t// Info of each user.\\n\\tstruct UserInfo {\\n\\t\\tuint256 amount; // How many LP tokens the user has provided.\\n\\t\\tuint256 rewardDebt; // Reward debt. See explanation below.\\n\\t\\t//\\n\\t\\t// We do some fancy math here. Basically, any point in time, the amount of SUSHIs\\n\\t\\t// entitled to a user but is pending to be distributed is:\\n\\t\\t//\\n\\t\\t//   pending reward = (user.amount * pool.accSushiPerShare) - user.rewardDebt\\n\\t\\t//\\n\\t\\t// Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\\n\\t\\t//   1. The pool's `accSushiPerShare` (and `lastRewardBlock`) gets updated.\\n\\t\\t//   2. User receives the pending reward sent to his/her address.\\n\\t\\t//   3. User's `amount` gets updated.\\n\\t\\t//   4. User's `rewardDebt` gets updated.\\n\\t}\\n\\t// Info of each pool.\\n\\tstruct PoolInfo {\\n\\t\\tIERC20 lpToken; // Address of LP token contract.\\n\\t\\tuint256 allocPoint; // How many allocation points assigned to this pool. SUSHIs to distribute per block.\\n\\t\\tuint256 lastRewardBlock; // Last block number that SUSHIs distribution occurs.\\n\\t\\tuint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.\\n\\t}\\n\\t// The SUSHI TOKEN!\\n\\tSushiToken public sushi;\\n\\t// Dev address.\\n\\taddress public devaddr;\\n\\t// Block number when bonus SUSHI period ends.\\n\\tuint256 public bonusEndBlock;\\n\\t// SUSHI tokens created per block.\\n\\tuint256 public sushiPerBlock;\\n\\t// Bonus muliplier for early sushi makers.\\n\\tuint256 public constant BONUS_MULTIPLIER = 10;\\n\\t// The migrator contract. It has a lot of power. Can only be set through governance (owner).\\n\\tIMigratorChef public migrator;\\n\\t// Info of each pool.\\n\\tPoolInfo[] public poolInfo;\\n\\t// Info of each user that stakes LP tokens.\\n\\tmapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n\\t// Total allocation poitns. Must be the sum of all allocation points in all pools.\\n\\tuint256 public totalAllocPoint = 0;\\n\\t// The block number when SUSHI mining starts.\\n\\tuint256 public startBlock;\\n\\tevent Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n\\tevent Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n\\tevent EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n\\n\\tconstructor(\\n\\t\\tSushiToken _sushi,\\n\\t\\taddress _devaddr,\\n\\t\\tuint256 _sushiPerBlock,\\n\\t\\tuint256 _startBlock,\\n\\t\\tuint256 _bonusEndBlock\\n\\t) public {\\n\\t\\tsushi = _sushi;\\n\\t\\tdevaddr = _devaddr;\\n\\t\\tsushiPerBlock = _sushiPerBlock;\\n\\t\\tbonusEndBlock = _bonusEndBlock;\\n\\t\\tstartBlock = _startBlock;\\n\\t}\\n\\n\\tfunction poolLength() external view returns (uint256) {\\n\\t\\treturn poolInfo.length;\\n\\t}\\n\\n\\t// Add a new lp to the pool. Can only be called by the owner.\\n\\t// XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n\\tfunction add(\\n\\t\\tuint256 _allocPoint,\\n\\t\\tIERC20 _lpToken,\\n\\t\\tbool _withUpdate\\n\\t) public onlyOwner {\\n\\t\\tif (_withUpdate) {\\n\\t\\t\\tmassUpdatePools();\\n\\t\\t}\\n\\t\\tuint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\\n\\t\\ttotalAllocPoint = totalAllocPoint.add(_allocPoint);\\n\\t\\tpoolInfo.push(\\n\\t\\t\\tPoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accSushiPerShare: 0 })\\n\\t\\t);\\n\\t}\\n\\n\\t// Update the given pool's SUSHI allocation point. Can only be called by the owner.\\n\\tfunction set(\\n\\t\\tuint256 _pid,\\n\\t\\tuint256 _allocPoint,\\n\\t\\tbool _withUpdate\\n\\t) public onlyOwner {\\n\\t\\tif (_withUpdate) {\\n\\t\\t\\tmassUpdatePools();\\n\\t\\t}\\n\\t\\ttotalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n\\t\\tpoolInfo[_pid].allocPoint = _allocPoint;\\n\\t}\\n\\n\\t// Set the migrator contract. Can only be called by the owner.\\n\\tfunction setMigrator(IMigratorChef _migrator) public onlyOwner {\\n\\t\\tmigrator = _migrator;\\n\\t}\\n\\n\\t// Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.\\n\\tfunction migrate(uint256 _pid) public {\\n\\t\\trequire(address(migrator) != address(0), \\\"migrate: no migrator\\\");\\n\\t\\tPoolInfo storage pool = poolInfo[_pid];\\n\\t\\tIERC20 lpToken = pool.lpToken;\\n\\t\\tuint256 bal = lpToken.balanceOf(address(this));\\n\\t\\tlpToken.safeApprove(address(migrator), bal);\\n\\t\\tIERC20 newLpToken = migrator.migrate(lpToken);\\n\\t\\trequire(bal == newLpToken.balanceOf(address(this)), \\\"migrate: bad\\\");\\n\\t\\tpool.lpToken = newLpToken;\\n\\t}\\n\\n\\t// Return reward multiplier over the given _from to _to block.\\n\\tfunction getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\\n\\t\\tif (_to <= bonusEndBlock) {\\n\\t\\t\\treturn _to.sub(_from).mul(BONUS_MULTIPLIER);\\n\\t\\t} else if (_from >= bonusEndBlock) {\\n\\t\\t\\treturn _to.sub(_from);\\n\\t\\t} else {\\n\\t\\t\\treturn bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(_to.sub(bonusEndBlock));\\n\\t\\t}\\n\\t}\\n\\n\\t// View function to see pending SUSHIs on frontend.\\n\\tfunction pendingSushi(uint256 _pid, address _user) external view returns (uint256) {\\n\\t\\tPoolInfo storage pool = poolInfo[_pid];\\n\\t\\tUserInfo storage user = userInfo[_pid][_user];\\n\\t\\tuint256 accSushiPerShare = pool.accSushiPerShare;\\n\\t\\tuint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n\\t\\tif (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n\\t\\t\\tuint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n\\t\\t\\tuint256 sushiReward = multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\\n\\t\\t\\taccSushiPerShare = accSushiPerShare.add(sushiReward.mul(1e12).div(lpSupply));\\n\\t\\t}\\n\\t\\treturn user.amount.mul(accSushiPerShare).div(1e12).sub(user.rewardDebt);\\n\\t}\\n\\n\\t// Update reward vairables for all pools. Be careful of gas spending!\\n\\tfunction massUpdatePools() public {\\n\\t\\tuint256 length = poolInfo.length;\\n\\t\\tfor (uint256 pid = 0; pid < length; ++pid) {\\n\\t\\t\\tupdatePool(pid);\\n\\t\\t}\\n\\t}\\n\\n\\t// Update reward variables of the given pool to be up-to-date.\\n\\tfunction updatePool(uint256 _pid) public {\\n\\t\\tPoolInfo storage pool = poolInfo[_pid];\\n\\t\\tif (block.number <= pool.lastRewardBlock) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n\\t\\tif (lpSupply == 0) {\\n\\t\\t\\tpool.lastRewardBlock = block.number;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n\\t\\tuint256 sushiReward = multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\\n\\t\\tsushi.mint(devaddr, sushiReward.div(10));\\n\\t\\tsushi.mint(address(this), sushiReward);\\n\\t\\tpool.accSushiPerShare = pool.accSushiPerShare.add(sushiReward.mul(1e12).div(lpSupply));\\n\\t\\tpool.lastRewardBlock = block.number;\\n\\t}\\n\\n\\t// Deposit LP tokens to MasterChef for SUSHI allocation.\\n\\tfunction deposit(uint256 _pid, uint256 _amount) public {\\n\\t\\tPoolInfo storage pool = poolInfo[_pid];\\n\\t\\tUserInfo storage user = userInfo[_pid][msg.sender];\\n\\t\\tupdatePool(_pid);\\n\\t\\tif (user.amount > 0) {\\n\\t\\t\\tuint256 pending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(user.rewardDebt);\\n\\t\\t\\tsafeSushiTransfer(msg.sender, pending);\\n\\t\\t}\\n\\t\\tpool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\\n\\t\\tuser.amount = user.amount.add(_amount);\\n\\t\\tuser.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\\n\\t\\temit Deposit(msg.sender, _pid, _amount);\\n\\t}\\n\\n\\t// Withdraw LP tokens from MasterChef.\\n\\tfunction withdraw(uint256 _pid, uint256 _amount) public {\\n\\t\\tPoolInfo storage pool = poolInfo[_pid];\\n\\t\\tUserInfo storage user = userInfo[_pid][msg.sender];\\n\\t\\trequire(user.amount >= _amount, \\\"withdraw: not good\\\");\\n\\t\\tupdatePool(_pid);\\n\\t\\tuint256 pending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(user.rewardDebt);\\n\\t\\tsafeSushiTransfer(msg.sender, pending);\\n\\t\\tuser.amount = user.amount.sub(_amount);\\n\\t\\tuser.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\\n\\t\\tpool.lpToken.safeTransfer(address(msg.sender), _amount);\\n\\t\\temit Withdraw(msg.sender, _pid, _amount);\\n\\t}\\n\\n\\t// Withdraw without caring about rewards. EMERGENCY ONLY.\\n\\tfunction emergencyWithdraw(uint256 _pid) public {\\n\\t\\tPoolInfo storage pool = poolInfo[_pid];\\n\\t\\tUserInfo storage user = userInfo[_pid][msg.sender];\\n\\t\\tpool.lpToken.safeTransfer(address(msg.sender), user.amount);\\n\\t\\temit EmergencyWithdraw(msg.sender, _pid, user.amount);\\n\\t\\tuser.amount = 0;\\n\\t\\tuser.rewardDebt = 0;\\n\\t}\\n\\n\\t// Safe sushi transfer function, just in case if rounding error causes pool to not have enough SUSHIs.\\n\\tfunction safeSushiTransfer(address _to, uint256 _amount) internal {\\n\\t\\tuint256 sushiBal = sushi.balanceOf(address(this));\\n\\t\\tif (_amount > sushiBal) {\\n\\t\\t\\tsushi.transfer(_to, sushiBal);\\n\\t\\t} else {\\n\\t\\t\\tsushi.transfer(_to, _amount);\\n\\t\\t}\\n\\t}\\n\\n\\t// Update dev address by the previous dev.\\n\\tfunction dev(address _devaddr) public {\\n\\t\\trequire(msg.sender == devaddr, \\\"dev: wut?\\\");\\n\\t\\tdevaddr = _devaddr;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SushiToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n// SushiToken with Governance.\\ncontract SushiToken is ERC20(\\\"SushiToken\\\", \\\"SUSHI\\\"), Ownable {\\n\\t/// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\\n\\tfunction mint(address _to, uint256 _amount) public onlyOwner {\\n\\t\\t_mint(_to, _amount);\\n\\t\\t_moveDelegates(address(0), _delegates[_to], _amount);\\n\\t}\\n\\n\\t// Copied and modified from YAM code:\\n\\t// https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\\n\\t// https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\\n\\t// Which is copied and modified from COMPOUND:\\n\\t// https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\\n\\n\\t/// @notice A record of each accounts delegate\\n\\tmapping(address => address) internal _delegates;\\n\\n\\t/// @notice A checkpoint for marking number of votes from a given block\\n\\tstruct Checkpoint {\\n\\t\\tuint32 fromBlock;\\n\\t\\tuint256 votes;\\n\\t}\\n\\n\\t/// @notice A record of votes checkpoints for each account, by index\\n\\tmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\\n\\n\\t/// @notice The number of checkpoints for each account\\n\\tmapping(address => uint32) public numCheckpoints;\\n\\n\\t/// @notice The EIP-712 typehash for the contract's domain\\n\\tbytes32 public constant DOMAIN_TYPEHASH =\\n\\t\\tkeccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n\\t/// @notice The EIP-712 typehash for the delegation struct used by the contract\\n\\tbytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n\\t/// @notice A record of states for signing / validating signatures\\n\\tmapping(address => uint256) public nonces;\\n\\n\\t/// @notice An event thats emitted when an account changes its delegate\\n\\tevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n\\t/// @notice An event thats emitted when a delegate account's vote balance changes\\n\\tevent DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\\n\\n\\t/**\\n\\t * @notice Delegate votes from `msg.sender` to `delegatee`\\n\\t * @param delegator The address to get delegatee for\\n\\t */\\n\\tfunction delegates(address delegator) external view returns (address) {\\n\\t\\treturn _delegates[delegator];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Delegate votes from `msg.sender` to `delegatee`\\n\\t * @param delegatee The address to delegate votes to\\n\\t */\\n\\tfunction delegate(address delegatee) external {\\n\\t\\treturn _delegate(msg.sender, delegatee);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Delegates votes from signatory to `delegatee`\\n\\t * @param delegatee The address to delegate votes to\\n\\t * @param nonce The contract state required to match the signature\\n\\t * @param expiry The time at which to expire the signature\\n\\t * @param v The recovery byte of the signature\\n\\t * @param r Half of the ECDSA signature pair\\n\\t * @param s Half of the ECDSA signature pair\\n\\t */\\n\\tfunction delegateBySig(\\n\\t\\taddress delegatee,\\n\\t\\tuint256 nonce,\\n\\t\\tuint256 expiry,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external {\\n\\t\\tbytes32 domainSeparator =\\n\\t\\t\\tkeccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this)));\\n\\n\\t\\tbytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\\n\\n\\t\\tbytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n\\n\\t\\taddress signatory = ecrecover(digest, v, r, s);\\n\\t\\trequire(signatory != address(0), \\\"SUSHI::delegateBySig: invalid signature\\\");\\n\\t\\trequire(nonce == nonces[signatory]++, \\\"SUSHI::delegateBySig: invalid nonce\\\");\\n\\t\\trequire(now <= expiry, \\\"SUSHI::delegateBySig: signature expired\\\");\\n\\t\\treturn _delegate(signatory, delegatee);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Gets the current votes balance for `account`\\n\\t * @param account The address to get votes balance\\n\\t * @return The number of current votes for `account`\\n\\t */\\n\\tfunction getCurrentVotes(address account) external view returns (uint256) {\\n\\t\\tuint32 nCheckpoints = numCheckpoints[account];\\n\\t\\treturn nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Determine the prior number of votes for an account as of a block number\\n\\t * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n\\t * @param account The address of the account to check\\n\\t * @param blockNumber The block number to get the vote balance at\\n\\t * @return The number of votes the account had as of the given block\\n\\t */\\n\\tfunction getPriorVotes(address account, uint256 blockNumber) external view returns (uint256) {\\n\\t\\trequire(blockNumber < block.number, \\\"SUSHI::getPriorVotes: not yet determined\\\");\\n\\n\\t\\tuint32 nCheckpoints = numCheckpoints[account];\\n\\t\\tif (nCheckpoints == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// First check most recent balance\\n\\t\\tif (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n\\t\\t\\treturn checkpoints[account][nCheckpoints - 1].votes;\\n\\t\\t}\\n\\n\\t\\t// Next check implicit zero balance\\n\\t\\tif (checkpoints[account][0].fromBlock > blockNumber) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tuint32 lower = 0;\\n\\t\\tuint32 upper = nCheckpoints - 1;\\n\\t\\twhile (upper > lower) {\\n\\t\\t\\tuint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n\\t\\t\\tCheckpoint memory cp = checkpoints[account][center];\\n\\t\\t\\tif (cp.fromBlock == blockNumber) {\\n\\t\\t\\t\\treturn cp.votes;\\n\\t\\t\\t} else if (cp.fromBlock < blockNumber) {\\n\\t\\t\\t\\tlower = center;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tupper = center - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn checkpoints[account][lower].votes;\\n\\t}\\n\\n\\tfunction _delegate(address delegator, address delegatee) internal {\\n\\t\\taddress currentDelegate = _delegates[delegator];\\n\\t\\tuint256 delegatorBalance = balanceOf(delegator); // balance of underlying SUSHIs (not scaled);\\n\\t\\t_delegates[delegator] = delegatee;\\n\\n\\t\\temit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n\\t\\t_moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n\\t}\\n\\n\\tfunction _moveDelegates(\\n\\t\\taddress srcRep,\\n\\t\\taddress dstRep,\\n\\t\\tuint256 amount\\n\\t) internal {\\n\\t\\tif (srcRep != dstRep && amount > 0) {\\n\\t\\t\\tif (srcRep != address(0)) {\\n\\t\\t\\t\\t// decrease old representative\\n\\t\\t\\t\\tuint32 srcRepNum = numCheckpoints[srcRep];\\n\\t\\t\\t\\tuint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n\\t\\t\\t\\tuint256 srcRepNew = srcRepOld.sub(amount);\\n\\t\\t\\t\\t_writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (dstRep != address(0)) {\\n\\t\\t\\t\\t// increase new representative\\n\\t\\t\\t\\tuint32 dstRepNum = numCheckpoints[dstRep];\\n\\t\\t\\t\\tuint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n\\t\\t\\t\\tuint256 dstRepNew = dstRepOld.add(amount);\\n\\t\\t\\t\\t_writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _writeCheckpoint(\\n\\t\\taddress delegatee,\\n\\t\\tuint32 nCheckpoints,\\n\\t\\tuint256 oldVotes,\\n\\t\\tuint256 newVotes\\n\\t) internal {\\n\\t\\tuint32 blockNumber = safe32(block.number, \\\"SUSHI::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n\\t\\tif (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n\\t\\t\\tcheckpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n\\t\\t} else {\\n\\t\\t\\tcheckpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n\\t\\t\\tnumCheckpoints[delegatee] = nCheckpoints + 1;\\n\\t\\t}\\n\\n\\t\\temit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n\\t}\\n\\n\\tfunction safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\n\\t\\trequire(n < 2**32, errorMessage);\\n\\t\\treturn uint32(n);\\n\\t}\\n\\n\\tfunction getChainId() internal pure returns (uint256) {\\n\\t\\tuint256 chainId;\\n\\t\\tassembly {\\n\\t\\t\\tchainId := chainid()\\n\\t\\t}\\n\\t\\treturn chainId;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pools/IStakingPools.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.12;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IStakingPools {\\n\\tfunction reward() external view returns (IERC20);\\n\\n\\tfunction rewardRate() external view returns (uint256);\\n\\n\\tfunction totalRewardWeight() external view returns (uint256);\\n\\n\\tfunction getPoolToken(uint256 _poolId) external view returns (IERC20);\\n\\n\\tfunction getStakeTotalUnclaimed(address _account, uint256 _poolId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/MasterChefV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport { BoringMath, BoringMath128 } from \\\"./libraries/boring/BoringMath.sol\\\";\\nimport { BoringOwnable } from \\\"./libraries/boring/BoringOwnable.sol\\\";\\nimport { BoringERC20, IERC20 } from \\\"./libraries/boring/BoringERC20.sol\\\";\\nimport { SignedSafeMath } from \\\"./libraries/math/SignedSafeMath.sol\\\";\\n\\nimport { IRewarder } from \\\"./interfaces/sushi/IRewarder.sol\\\";\\nimport { IMasterChef } from \\\"./interfaces/sushi/IMasterChef.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\ninterface IMigratorChef {\\n\\t// Take the current LP token address and return the new LP token address.\\n\\t// Migrator should have full access to the caller's LP token.\\n\\tfunction migrate(IERC20 token) external returns (IERC20);\\n}\\n\\n/// @notice The (older) MasterChef contract gives out a constant number of SUSHI tokens per block.\\n/// It is the only address with minting rights for SUSHI.\\n/// The idea for this MasterChef V2 (MCV2) contract is therefore to be the owner of a dummy token\\n/// that is deposited into the MasterChef V1 (MCV1) contract.\\n/// The allocation point for this pool on MCV1 is the total allocation point for all pools that receive double incentives.\\ncontract MasterChefV2 is BoringOwnable {\\n\\tusing BoringMath for uint256;\\n\\tusing BoringMath128 for uint128;\\n\\tusing BoringERC20 for IERC20;\\n\\tusing SignedSafeMath for int256;\\n\\n\\t/// @notice Info of each MCV2 user.\\n\\t/// `amount` LP token amount the user has provided.\\n\\t/// `rewardDebt` The amount of SUSHI entitled to the user.\\n\\tstruct UserInfo {\\n\\t\\tuint256 amount;\\n\\t\\tint256 rewardDebt;\\n\\t}\\n\\n\\t/// @notice Info of each MCV2 pool.\\n\\t/// `allocPoint` The amount of allocation points assigned to the pool.\\n\\t/// Also known as the amount of SUSHI to distribute per block.\\n\\tstruct PoolInfo {\\n\\t\\tuint128 accSushiPerShare;\\n\\t\\tuint64 lastRewardBlock;\\n\\t\\tuint64 allocPoint;\\n\\t}\\n\\n\\t/// @notice Address of MCV1 contract.\\n\\tIMasterChef public immutable MASTER_CHEF;\\n\\t/// @notice Address of SUSHI contract.\\n\\tIERC20 public immutable SUSHI;\\n\\t/// @notice The index of MCV2 master pool in MCV1.\\n\\tuint256 public immutable MASTER_PID;\\n\\t// @notice The migrator contract. It has a lot of power. Can only be set through governance (owner).\\n\\tIMigratorChef public migrator;\\n\\n\\t/// @notice Info of each MCV2 pool.\\n\\tPoolInfo[] public poolInfo;\\n\\t/// @notice Address of the LP token for each MCV2 pool.\\n\\tIERC20[] public lpToken;\\n\\t/// @notice Address of each `IRewarder` contract in MCV2.\\n\\tIRewarder[] public rewarder;\\n\\n\\t/// @notice Info of each user that stakes LP tokens.\\n\\tmapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n\\t/// @dev Total allocation points. Must be the sum of all allocation points in all pools.\\n\\tuint256 public totalAllocPoint;\\n\\n\\tuint256 private constant MASTERCHEF_SUSHI_PER_BLOCK = 1e20;\\n\\tuint256 private constant ACC_SUSHI_PRECISION = 1e12;\\n\\n\\tevent Deposit(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n\\tevent Withdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n\\tevent EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n\\tevent Harvest(address indexed user, uint256 indexed pid, uint256 amount);\\n\\tevent LogPoolAddition(uint256 indexed pid, uint256 allocPoint, IERC20 indexed lpToken, IRewarder indexed rewarder);\\n\\tevent LogSetPool(uint256 indexed pid, uint256 allocPoint, IRewarder indexed rewarder, bool overwrite);\\n\\tevent LogUpdatePool(uint256 indexed pid, uint64 lastRewardBlock, uint256 lpSupply, uint256 accSushiPerShare);\\n\\tevent LogInit();\\n\\n\\t/// @param _MASTER_CHEF The SushiSwap MCV1 contract address.\\n\\t/// @param _sushi The SUSHI token contract address.\\n\\t/// @param _MASTER_PID The pool ID of the dummy token on the base MCV1 contract.\\n\\tconstructor(\\n\\t\\tIMasterChef _MASTER_CHEF,\\n\\t\\tIERC20 _sushi,\\n\\t\\tuint256 _MASTER_PID\\n\\t) public {\\n\\t\\tMASTER_CHEF = _MASTER_CHEF;\\n\\t\\tSUSHI = _sushi;\\n\\t\\tMASTER_PID = _MASTER_PID;\\n\\t}\\n\\n\\t/// @notice Deposits a dummy token to `MASTER_CHEF` MCV1. This is required because MCV1 holds the minting rights for SUSHI.\\n\\t/// Any balance of transaction sender in `dummyToken` is transferred.\\n\\t/// The allocation point for the pool on MCV1 is the total allocation point for all pools that receive double incentives.\\n\\t/// @param dummyToken The address of the ERC-20 token to deposit into MCV1.\\n\\tfunction init(IERC20 dummyToken) external {\\n\\t\\tuint256 balance = dummyToken.balanceOf(msg.sender);\\n\\t\\trequire(balance != 0, \\\"MasterChefV2: Balance must exceed 0\\\");\\n\\t\\tdummyToken.safeTransferFrom(msg.sender, address(this), balance);\\n\\t\\tdummyToken.approve(address(MASTER_CHEF), balance);\\n\\t\\tMASTER_CHEF.deposit(MASTER_PID, balance);\\n\\t\\temit LogInit();\\n\\t}\\n\\n\\t/// @notice Returns the number of MCV2 pools.\\n\\tfunction poolLength() public view returns (uint256 pools) {\\n\\t\\tpools = poolInfo.length;\\n\\t}\\n\\n\\t/// @notice Add a new LP to the pool. Can only be called by the owner.\\n\\t/// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n\\t/// @param allocPoint AP of the new pool.\\n\\t/// @param _lpToken Address of the LP ERC-20 token.\\n\\t/// @param _rewarder Address of the rewarder delegate.\\n\\tfunction add(\\n\\t\\tuint256 allocPoint,\\n\\t\\tIERC20 _lpToken,\\n\\t\\tIRewarder _rewarder\\n\\t) public onlyOwner {\\n\\t\\tuint256 lastRewardBlock = block.number;\\n\\t\\ttotalAllocPoint = totalAllocPoint.add(allocPoint);\\n\\t\\tlpToken.push(_lpToken);\\n\\t\\trewarder.push(_rewarder);\\n\\n\\t\\tpoolInfo.push(\\n\\t\\t\\tPoolInfo({ allocPoint: allocPoint.to64(), lastRewardBlock: lastRewardBlock.to64(), accSushiPerShare: 0 })\\n\\t\\t);\\n\\t\\temit LogPoolAddition(lpToken.length.sub(1), allocPoint, _lpToken, _rewarder);\\n\\t}\\n\\n\\t/// @notice Update the given pool's SUSHI allocation point and `IRewarder` contract. Can only be called by the owner.\\n\\t/// @param _pid The index of the pool. See `poolInfo`.\\n\\t/// @param _allocPoint New AP of the pool.\\n\\t/// @param _rewarder Address of the rewarder delegate.\\n\\t/// @param overwrite True if _rewarder should be `set`. Otherwise `_rewarder` is ignored.\\n\\tfunction set(\\n\\t\\tuint256 _pid,\\n\\t\\tuint256 _allocPoint,\\n\\t\\tIRewarder _rewarder,\\n\\t\\tbool overwrite\\n\\t) public onlyOwner {\\n\\t\\ttotalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n\\t\\tpoolInfo[_pid].allocPoint = _allocPoint.to64();\\n\\t\\tif (overwrite) {\\n\\t\\t\\trewarder[_pid] = _rewarder;\\n\\t\\t}\\n\\t\\temit LogSetPool(_pid, _allocPoint, overwrite ? _rewarder : rewarder[_pid], overwrite);\\n\\t}\\n\\n\\t/// @notice Set the `migrator` contract. Can only be called by the owner.\\n\\t/// @param _migrator The contract address to set.\\n\\tfunction setMigrator(IMigratorChef _migrator) public onlyOwner {\\n\\t\\tmigrator = _migrator;\\n\\t}\\n\\n\\t/// @notice Migrate LP token to another LP contract through the `migrator` contract.\\n\\t/// @param _pid The index of the pool. See `poolInfo`.\\n\\tfunction migrate(uint256 _pid) public {\\n\\t\\trequire(address(migrator) != address(0), \\\"MasterChefV2: no migrator set\\\");\\n\\t\\tIERC20 _lpToken = lpToken[_pid];\\n\\t\\tuint256 bal = _lpToken.balanceOf(address(this));\\n\\t\\t_lpToken.approve(address(migrator), bal);\\n\\t\\tIERC20 newLpToken = migrator.migrate(_lpToken);\\n\\t\\trequire(bal == newLpToken.balanceOf(address(this)), \\\"MasterChefV2: migrated balance must match\\\");\\n\\t\\tlpToken[_pid] = newLpToken;\\n\\t}\\n\\n\\t/// @notice View function to see pending SUSHI on frontend.\\n\\t/// @param _pid The index of the pool. See `poolInfo`.\\n\\t/// @param _user Address of user.\\n\\t/// @return pending SUSHI reward for a given user.\\n\\tfunction pendingSushi(uint256 _pid, address _user) external view returns (uint256 pending) {\\n\\t\\tPoolInfo memory pool = poolInfo[_pid];\\n\\t\\tUserInfo storage user = userInfo[_pid][_user];\\n\\t\\tuint256 accSushiPerShare = pool.accSushiPerShare;\\n\\t\\tuint256 lpSupply = lpToken[_pid].balanceOf(address(this));\\n\\t\\tif (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n\\t\\t\\tuint256 blocks = block.number.sub(pool.lastRewardBlock);\\n\\t\\t\\tuint256 sushiReward = blocks.mul(sushiPerBlock()).mul(pool.allocPoint) / totalAllocPoint;\\n\\t\\t\\taccSushiPerShare = accSushiPerShare.add(sushiReward.mul(ACC_SUSHI_PRECISION) / lpSupply);\\n\\t\\t}\\n\\t\\tpending = int256(user.amount.mul(accSushiPerShare) / ACC_SUSHI_PRECISION).sub(user.rewardDebt).toUInt256();\\n\\t}\\n\\n\\t/// @notice Update reward variables for all pools. Be careful of gas spending!\\n\\t/// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\\n\\tfunction massUpdatePools(uint256[] calldata pids) external {\\n\\t\\tuint256 len = pids.length;\\n\\t\\tfor (uint256 i = 0; i < len; ++i) {\\n\\t\\t\\tupdatePool(pids[i]);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Calculates and returns the `amount` of SUSHI per block.\\n\\tfunction sushiPerBlock() public view returns (uint256 amount) {\\n\\t\\tamount =\\n\\t\\t\\tuint256(MASTERCHEF_SUSHI_PER_BLOCK).mul(MASTER_CHEF.poolInfo(MASTER_PID).allocPoint) /\\n\\t\\t\\tMASTER_CHEF.totalAllocPoint();\\n\\t}\\n\\n\\t/// @notice Update reward variables of the given pool.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @return pool Returns the pool that was updated.\\n\\tfunction updatePool(uint256 pid) public returns (PoolInfo memory pool) {\\n\\t\\tpool = poolInfo[pid];\\n\\t\\tif (block.number > pool.lastRewardBlock) {\\n\\t\\t\\tuint256 lpSupply = lpToken[pid].balanceOf(address(this));\\n\\t\\t\\tif (lpSupply > 0) {\\n\\t\\t\\t\\tuint256 blocks = block.number.sub(pool.lastRewardBlock);\\n\\t\\t\\t\\tuint256 sushiReward = blocks.mul(sushiPerBlock()).mul(pool.allocPoint) / totalAllocPoint;\\n\\t\\t\\t\\tpool.accSushiPerShare = pool.accSushiPerShare.add(\\n\\t\\t\\t\\t\\t(sushiReward.mul(ACC_SUSHI_PRECISION) / lpSupply).to128()\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tpool.lastRewardBlock = block.number.to64();\\n\\t\\t\\tpoolInfo[pid] = pool;\\n\\t\\t\\temit LogUpdatePool(pid, pool.lastRewardBlock, lpSupply, pool.accSushiPerShare);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Deposit LP tokens to MCV2 for SUSHI allocation.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @param amount LP token amount to deposit.\\n\\t/// @param to The receiver of `amount` deposit benefit.\\n\\tfunction deposit(\\n\\t\\tuint256 pid,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) public {\\n\\t\\tPoolInfo memory pool = updatePool(pid);\\n\\t\\tUserInfo storage user = userInfo[pid][to];\\n\\n\\t\\t// Effects\\n\\t\\tuser.amount = user.amount.add(amount);\\n\\t\\tuser.rewardDebt = user.rewardDebt.add(int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION));\\n\\n\\t\\t// Interactions\\n\\t\\tIRewarder _rewarder = rewarder[pid];\\n\\t\\tif (address(_rewarder) != address(0)) {\\n\\t\\t\\t_rewarder.onSushiReward(pid, to, to, 0, user.amount);\\n\\t\\t}\\n\\n\\t\\tlpToken[pid].safeTransferFrom(msg.sender, address(this), amount);\\n\\n\\t\\temit Deposit(msg.sender, pid, amount, to);\\n\\t}\\n\\n\\t/// @notice Withdraw LP tokens from MCV2.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @param amount LP token amount to withdraw.\\n\\t/// @param to Receiver of the LP tokens.\\n\\tfunction withdraw(\\n\\t\\tuint256 pid,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) public {\\n\\t\\tPoolInfo memory pool = updatePool(pid);\\n\\t\\tUserInfo storage user = userInfo[pid][msg.sender];\\n\\n\\t\\t// Effects\\n\\t\\tuser.rewardDebt = user.rewardDebt.sub(int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION));\\n\\t\\tuser.amount = user.amount.sub(amount);\\n\\n\\t\\t// Interactions\\n\\t\\tIRewarder _rewarder = rewarder[pid];\\n\\t\\tif (address(_rewarder) != address(0)) {\\n\\t\\t\\t_rewarder.onSushiReward(pid, msg.sender, to, 0, user.amount);\\n\\t\\t}\\n\\n\\t\\tlpToken[pid].safeTransfer(to, amount);\\n\\n\\t\\temit Withdraw(msg.sender, pid, amount, to);\\n\\t}\\n\\n\\t/// @notice Harvest proceeds for transaction sender to `to`.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @param to Receiver of SUSHI rewards.\\n\\tfunction harvest(uint256 pid, address to) public {\\n\\t\\tPoolInfo memory pool = updatePool(pid);\\n\\t\\tUserInfo storage user = userInfo[pid][msg.sender];\\n\\t\\tint256 accumulatedSushi = int256(user.amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION);\\n\\t\\tuint256 _pendingSushi = accumulatedSushi.sub(user.rewardDebt).toUInt256();\\n\\n\\t\\t// Effects\\n\\t\\tuser.rewardDebt = accumulatedSushi;\\n\\n\\t\\t// Interactions\\n\\t\\tif (_pendingSushi != 0) {\\n\\t\\t\\tSUSHI.safeTransfer(to, _pendingSushi);\\n\\t\\t}\\n\\n\\t\\tIRewarder _rewarder = rewarder[pid];\\n\\t\\tif (address(_rewarder) != address(0)) {\\n\\t\\t\\t_rewarder.onSushiReward(pid, msg.sender, to, _pendingSushi, user.amount);\\n\\t\\t}\\n\\n\\t\\temit Harvest(msg.sender, pid, _pendingSushi);\\n\\t}\\n\\n\\t/// @notice Withdraw LP tokens from MCV2 and harvest proceeds for transaction sender to `to`.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @param amount LP token amount to withdraw.\\n\\t/// @param to Receiver of the LP tokens and SUSHI rewards.\\n\\tfunction withdrawAndHarvest(\\n\\t\\tuint256 pid,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) public {\\n\\t\\tPoolInfo memory pool = updatePool(pid);\\n\\t\\tUserInfo storage user = userInfo[pid][msg.sender];\\n\\t\\tint256 accumulatedSushi = int256(user.amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION);\\n\\t\\tuint256 _pendingSushi = accumulatedSushi.sub(user.rewardDebt).toUInt256();\\n\\n\\t\\t// Effects\\n\\t\\tuser.rewardDebt = accumulatedSushi.sub(int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION));\\n\\t\\tuser.amount = user.amount.sub(amount);\\n\\n\\t\\t// Interactions\\n\\t\\tSUSHI.safeTransfer(to, _pendingSushi);\\n\\n\\t\\tIRewarder _rewarder = rewarder[pid];\\n\\t\\tif (address(_rewarder) != address(0)) {\\n\\t\\t\\t_rewarder.onSushiReward(pid, msg.sender, to, _pendingSushi, user.amount);\\n\\t\\t}\\n\\n\\t\\tlpToken[pid].safeTransfer(to, amount);\\n\\n\\t\\temit Withdraw(msg.sender, pid, amount, to);\\n\\t\\temit Harvest(msg.sender, pid, _pendingSushi);\\n\\t}\\n\\n\\t/// @notice Harvests SUSHI from `MASTER_CHEF` MCV1 and pool `MASTER_PID` to this MCV2 contract.\\n\\tfunction harvestFromMasterChef() public {\\n\\t\\tMASTER_CHEF.deposit(MASTER_PID, 0);\\n\\t}\\n\\n\\t/// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\\n\\t/// @param pid The index of the pool. See `poolInfo`.\\n\\t/// @param to Receiver of the LP tokens.\\n\\tfunction emergencyWithdraw(uint256 pid, address to) public {\\n\\t\\tUserInfo storage user = userInfo[pid][msg.sender];\\n\\t\\tuint256 amount = user.amount;\\n\\t\\tuser.amount = 0;\\n\\t\\tuser.rewardDebt = 0;\\n\\n\\t\\tIRewarder _rewarder = rewarder[pid];\\n\\t\\tif (address(_rewarder) != address(0)) {\\n\\t\\t\\t_rewarder.onSushiReward(pid, msg.sender, to, 0, 0);\\n\\t\\t}\\n\\n\\t\\t// Note: transfer can fail or succeed if `amount` is zero.\\n\\t\\tlpToken[pid].safeTransfer(to, amount);\\n\\t\\temit EmergencyWithdraw(msg.sender, pid, amount, to);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nlibrary SignedSafeMath {\\n\\tint256 private constant _INT256_MIN = -2**255;\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two signed integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `*` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Multiplication cannot overflow.\\n\\t */\\n\\tfunction mul(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n\\t\\t// benefit is lost if 'b' is also tested.\\n\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n\\t\\tif (a == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\trequire(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n\\t\\tint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two signed integers. Reverts on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\trequire(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n\\t\\trequire(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n\\t\\tint256 c = a / b;\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two signed integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\tint256 c = a - b;\\n\\t\\trequire((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the addition of two signed integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity's `+` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Addition cannot overflow.\\n\\t */\\n\\tfunction add(int256 a, int256 b) internal pure returns (int256) {\\n\\t\\tint256 c = a + b;\\n\\t\\trequire((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\tfunction toUInt256(int256 a) internal pure returns (uint256) {\\n\\t\\trequire(a >= 0, \\\"Integer < 0\\\");\\n\\t\\treturn uint256(a);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/sushi/IMasterChef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport { BoringERC20, IERC20 } from \\\"../../libraries/boring/BoringERC20.sol\\\";\\n\\ninterface IMasterChef {\\n\\tusing BoringERC20 for IERC20;\\n\\tstruct UserInfo {\\n\\t\\tuint256 amount; // How many LP tokens the user has provided.\\n\\t\\tuint256 rewardDebt; // Reward debt. See explanation below.\\n\\t}\\n\\n\\tstruct PoolInfo {\\n\\t\\tIERC20 lpToken; // Address of LP token contract.\\n\\t\\tuint256 allocPoint; // How many allocation points assigned to this pool. SUSHI to distribute per block.\\n\\t\\tuint256 lastRewardBlock; // Last block number that SUSHI distribution occurs.\\n\\t\\tuint256 accSushiPerShare; // Accumulated SUSHI per share, times 1e12. See below.\\n\\t}\\n\\n\\tfunction poolInfo(uint256 pid) external view returns (IMasterChef.PoolInfo memory);\\n\\n\\tfunction totalAllocPoint() external view returns (uint256);\\n\\n\\tfunction deposit(uint256 _pid, uint256 _amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"contract IMasterChefV2\",\"name\":\"_MCV2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OnReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"PoolSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accTokenPerShare\",\"type\":\"uint256\"}],\"name\":\"PoolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"RewardRateUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpToken\",\"type\":\"uint256\"}],\"name\":\"onSushiReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"accTokenPerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"allocPoint\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_pids\",\"type\":\"uint256[]\"}],\"name\":\"setRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"accTokenPerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"allocPoint\",\"type\":\"uint64\"}],\"internalType\":\"struct ALCXRewarder.PoolInfo\",\"name\":\"pool\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ALCXRewarder","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000dbdb4d16eda451d0503b854cf79d55697f90c8df0000000000000000000000000000000000000000000000000000000000002710000000000000000000000000ef0881ec094552b2e128cf945ef17a6752b4ec5d","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}