{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/arch/Hashing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Value.sol\\\";\\n\\nlibrary Hashing {\\n    using Hashing for Value.Data;\\n    using Value for Value.CodePoint;\\n\\n    function keccak1(bytes32 b) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(b));\\n    }\\n\\n    function keccak2(bytes32 a, bytes32 b) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(a, b));\\n    }\\n\\n    function bytes32FromArray(\\n        bytes memory arr,\\n        uint256 offset,\\n        uint256 arrLength\\n    ) internal pure returns (uint256) {\\n        uint256 res = 0;\\n        for (uint256 i = 0; i < 32; i++) {\\n            res = res << 8;\\n            bytes1 b = arrLength > offset + i ? arr[offset + i] : bytes1(0);\\n            res = res | uint256(uint8(b));\\n        }\\n        return res;\\n    }\\n\\n    /*\\n     * !! Note that dataLength must be a power of two !!\\n     *\\n     * If you have an arbitrary data length, you can round it up with roundUpToPow2.\\n     * The boolean return value tells if the data segment data[startOffset..startOffset+dataLength] only included zeroes.\\n     * If pack is true, the returned value is the merkle hash where trailing zeroes are ignored, that is,\\n     *   if h is the smallest height for which all data[startOffset+2**h..] are zero, merkle hash of data[startOffset..startOffset+2**h] is returned.\\n     * If all elements in the data segment are zero (and pack is true), keccak1(bytes32(0)) is returned.\\n     */\\n    function merkleRoot(\\n        bytes memory data,\\n        uint256 rawDataLength,\\n        uint256 startOffset,\\n        uint256 dataLength,\\n        bool pack\\n    ) internal pure returns (bytes32, bool) {\\n        if (dataLength <= 32) {\\n            if (startOffset >= rawDataLength) {\\n                return (keccak1(bytes32(0)), true);\\n            }\\n            bytes32 res = keccak1(bytes32(bytes32FromArray(data, startOffset, rawDataLength)));\\n            return (res, res == keccak1(bytes32(0)));\\n        }\\n        (bytes32 h2, bool zero2) =\\n            merkleRoot(data, rawDataLength, startOffset + dataLength / 2, dataLength / 2, false);\\n        if (zero2 && pack) {\\n            return merkleRoot(data, rawDataLength, startOffset, dataLength / 2, pack);\\n        }\\n        (bytes32 h1, bool zero1) =\\n            merkleRoot(data, rawDataLength, startOffset, dataLength / 2, false);\\n        return (keccak2(h1, h2), zero1 && zero2);\\n    }\\n\\n    function roundUpToPow2(uint256 len) internal pure returns (uint256) {\\n        if (len <= 1) return 1;\\n        else return 2 * roundUpToPow2((len + 1) / 2);\\n    }\\n\\n    function bytesToBufferHash(\\n        bytes memory buf,\\n        uint256 startOffset,\\n        uint256 length\\n    ) internal pure returns (bytes32) {\\n        (bytes32 mhash, ) =\\n            merkleRoot(buf, startOffset + length, startOffset, roundUpToPow2(length), true);\\n        return keccak2(bytes32(uint256(123)), mhash);\\n    }\\n\\n    function hashInt(uint256 val) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(val));\\n    }\\n\\n    function hashCodePoint(Value.CodePoint memory cp) internal pure returns (bytes32) {\\n        assert(cp.immediate.length < 2);\\n        if (cp.immediate.length == 0) {\\n            return\\n                keccak256(abi.encodePacked(Value.codePointTypeCode(), cp.opcode, cp.nextCodePoint));\\n        }\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    Value.codePointTypeCode(),\\n                    cp.opcode,\\n                    cp.immediate[0].hash(),\\n                    cp.nextCodePoint\\n                )\\n            );\\n    }\\n\\n    function hashTuplePreImage(bytes32 innerHash, uint256 valueSize)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(uint8(Value.tupleTypeCode()), innerHash, valueSize));\\n    }\\n\\n    function hash(Value.Data memory val) internal pure returns (bytes32) {\\n        if (val.typeCode == Value.intTypeCode()) {\\n            return hashInt(val.intVal);\\n        } else if (val.typeCode == Value.codePointTypeCode()) {\\n            return hashCodePoint(val.cpVal);\\n        } else if (val.typeCode == Value.tuplePreImageTypeCode()) {\\n            return hashTuplePreImage(bytes32(val.intVal), val.size);\\n        } else if (val.typeCode == Value.tupleTypeCode()) {\\n            Value.Data memory preImage = getTuplePreImage(val.tupleVal);\\n            return preImage.hash();\\n        } else if (val.typeCode == Value.hashOnlyTypeCode()) {\\n            return bytes32(val.intVal);\\n        } else if (val.typeCode == Value.bufferTypeCode()) {\\n            return keccak256(abi.encodePacked(uint256(123), val.bufferHash));\\n        } else {\\n            require(false, \\\"Invalid type code\\\");\\n        }\\n    }\\n\\n    function getTuplePreImage(Value.Data[] memory vals) internal pure returns (Value.Data memory) {\\n        require(vals.length <= 8, \\\"Invalid tuple length\\\");\\n        bytes32[] memory hashes = new bytes32[](vals.length);\\n        uint256 hashCount = hashes.length;\\n        uint256 size = 1;\\n        for (uint256 i = 0; i < hashCount; i++) {\\n            hashes[i] = vals[i].hash();\\n            size += vals[i].size;\\n        }\\n        bytes32 firstHash = keccak256(abi.encodePacked(uint8(hashes.length), hashes));\\n        return Value.newTuplePreImage(firstHash, size);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/IOneStepProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\nimport \\\"../bridge/interfaces/ISequencerInbox.sol\\\";\\n\\ninterface IOneStepProof {\\n    // Bridges is sequencer bridge then delayed bridge\\n    function executeStep(\\n        address[2] calldata bridges,\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes calldata proof,\\n        bytes calldata bproof\\n    )\\n        external\\n        view\\n        returns (\\n            uint64 gas,\\n            uint256 afterMessagesRead,\\n            bytes32[4] memory fields\\n        );\\n\\n    function executeStepDebug(\\n        address[2] calldata bridges,\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes calldata proof,\\n        bytes calldata bproof\\n    ) external view returns (string memory startMachine, string memory afterMachine);\\n}\\n\"\r\n    },\r\n    \"contracts/arch/Machine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Marshaling.sol\\\";\\n\\nimport \\\"../libraries/DebugPrint.sol\\\";\\n\\nlibrary Machine {\\n    using Hashing for Value.Data;\\n\\n    // Make sure these don't conflict with Challenge.MACHINE_UNREACHABLE (currently 100)\\n    uint256 internal constant MACHINE_EXTENSIVE = 0;\\n    uint256 internal constant MACHINE_ERRORSTOP = 1;\\n    uint256 internal constant MACHINE_HALT = 2;\\n\\n    function addStackVal(Value.Data memory stackValHash, Value.Data memory valHash)\\n        internal\\n        pure\\n        returns (Value.Data memory)\\n    {\\n        Value.Data[] memory vals = new Value.Data[](2);\\n        vals[0] = valHash;\\n        vals[1] = stackValHash;\\n\\n        return Hashing.getTuplePreImage(vals);\\n    }\\n\\n    struct Data {\\n        bytes32 instructionStackHash;\\n        Value.Data dataStack;\\n        Value.Data auxStack;\\n        Value.Data registerVal;\\n        Value.Data staticVal;\\n        uint256 arbGasRemaining;\\n        bytes32 errHandlerHash;\\n        uint256 status;\\n    }\\n\\n    function toString(Data memory machine) internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"Machine(\\\",\\n                    DebugPrint.bytes32string(machine.instructionStackHash),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.bytes32string(machine.dataStack.hash()),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.bytes32string(machine.auxStack.hash()),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.bytes32string(machine.registerVal.hash()),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.bytes32string(machine.staticVal.hash()),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.uint2str(machine.arbGasRemaining),\\n                    \\\", \\\\n\\\",\\n                    DebugPrint.bytes32string(machine.errHandlerHash),\\n                    \\\")\\\\n\\\"\\n                )\\n            );\\n    }\\n\\n    function setErrorStop(Data memory machine) internal pure {\\n        machine.status = MACHINE_ERRORSTOP;\\n    }\\n\\n    function setHalt(Data memory machine) internal pure {\\n        machine.status = MACHINE_HALT;\\n    }\\n\\n    function addDataStackValue(Data memory machine, Value.Data memory val) internal pure {\\n        machine.dataStack = addStackVal(machine.dataStack, val);\\n    }\\n\\n    function addAuxStackValue(Data memory machine, Value.Data memory val) internal pure {\\n        machine.auxStack = addStackVal(machine.auxStack, val);\\n    }\\n\\n    function addDataStackInt(Data memory machine, uint256 val) internal pure {\\n        machine.dataStack = addStackVal(machine.dataStack, Value.newInt(val));\\n    }\\n\\n    function hash(Data memory machine) internal pure returns (bytes32) {\\n        if (machine.status == MACHINE_HALT) {\\n            return bytes32(uint256(0));\\n        } else if (machine.status == MACHINE_ERRORSTOP) {\\n            return bytes32(uint256(1));\\n        } else {\\n            return\\n                keccak256(\\n                    abi.encodePacked(\\n                        machine.instructionStackHash,\\n                        machine.dataStack.hash(),\\n                        machine.auxStack.hash(),\\n                        machine.registerVal.hash(),\\n                        machine.staticVal.hash(),\\n                        machine.arbGasRemaining,\\n                        machine.errHandlerHash\\n                    )\\n                );\\n        }\\n    }\\n\\n    function clone(Data memory machine) internal pure returns (Data memory) {\\n        return\\n            Data(\\n                machine.instructionStackHash,\\n                machine.dataStack,\\n                machine.auxStack,\\n                machine.registerVal,\\n                machine.staticVal,\\n                machine.arbGasRemaining,\\n                machine.errHandlerHash,\\n                machine.status\\n            );\\n    }\\n\\n    function deserializeMachine(bytes memory data, uint256 offset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Data memory // machine\\n        )\\n    {\\n        Data memory m;\\n        m.status = MACHINE_EXTENSIVE;\\n        uint256 instructionStack;\\n        uint256 errHandler;\\n        (offset, instructionStack) = Marshaling.deserializeInt(data, offset);\\n\\n        (offset, m.dataStack) = Marshaling.deserializeHashPreImage(data, offset);\\n        (offset, m.auxStack) = Marshaling.deserializeHashPreImage(data, offset);\\n        (offset, m.registerVal) = Marshaling.deserialize(data, offset);\\n        (offset, m.staticVal) = Marshaling.deserialize(data, offset);\\n        (offset, m.arbGasRemaining) = Marshaling.deserializeInt(data, offset);\\n        (offset, errHandler) = Marshaling.deserializeInt(data, offset);\\n\\n        m.instructionStackHash = bytes32(instructionStack);\\n        m.errHandlerHash = bytes32(errHandler);\\n        return (offset, m);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/Marshaling.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./Hashing.sol\\\";\\n\\nimport \\\"../libraries/BytesLib.sol\\\";\\n\\nlibrary Marshaling {\\n    using BytesLib for bytes;\\n    using Value for Value.Data;\\n\\n    // This depends on how it's implemented in arb-os\\n    function deserializeMessage(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            bool,\\n            uint256,\\n            address,\\n            uint8,\\n            bytes memory\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 8, \\\"too short\\\");\\n        uint256 size = 0;\\n        for (uint256 i = 0; i < 8; i++) {\\n            size *= 256;\\n            size += uint8(data[startOffset + 7 - i]);\\n        }\\n        (, uint256 sender) = deserializeInt(data, startOffset + 8);\\n        (, uint256 kind) = deserializeInt(data, startOffset + 8 + 32);\\n        bytes memory res = new bytes(size - 64);\\n        for (uint256 i = 0; i < size - 64; i++) {\\n            res[i] = data[startOffset + 8 + 64 + i];\\n        }\\n        return (true, startOffset + 8 + size, address(uint160(sender)), uint8(kind), res);\\n    }\\n\\n    function deserializeRawMessage(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            bool,\\n            uint256,\\n            bytes memory\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 8, \\\"too short\\\");\\n        uint256 size = 0;\\n        for (uint256 i = 0; i < 8; i++) {\\n            size *= 256;\\n            size += uint8(data[startOffset + 7 - i]);\\n        }\\n        bytes memory res = new bytes(size);\\n        for (uint256 i = 0; i < size; i++) {\\n            res[i] = data[startOffset + 8 + i];\\n        }\\n        return (true, startOffset + 8 + size, res);\\n    }\\n\\n    function deserializeHashPreImage(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint256 offset, Value.Data memory value)\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 64, \\\"too short\\\");\\n        bytes32 hashData;\\n        uint256 size;\\n        (offset, hashData) = extractBytes32(data, startOffset);\\n        (offset, size) = deserializeInt(data, offset);\\n        return (offset, Value.newTuplePreImage(hashData, size));\\n    }\\n\\n    function deserializeInt(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            uint256 // val\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 32, \\\"too short\\\");\\n        return (startOffset + 32, data.toUint(startOffset));\\n    }\\n\\n    function deserializeBytes32(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            bytes32 // val\\n        )\\n    {\\n        require(data.length >= startOffset && data.length - startOffset >= 32, \\\"too short\\\");\\n        return (startOffset + 32, data.toBytes32(startOffset));\\n    }\\n\\n    function deserializeCodePoint(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Value.Data memory // val\\n        )\\n    {\\n        uint256 offset = startOffset;\\n        uint8 immediateType;\\n        uint8 opCode;\\n        Value.Data memory immediate;\\n        bytes32 nextHash;\\n\\n        (offset, immediateType) = extractUint8(data, offset);\\n        (offset, opCode) = extractUint8(data, offset);\\n        if (immediateType == 1) {\\n            (offset, immediate) = deserialize(data, offset);\\n        }\\n        (offset, nextHash) = extractBytes32(data, offset);\\n        if (immediateType == 1) {\\n            return (offset, Value.newCodePoint(opCode, nextHash, immediate));\\n        }\\n        return (offset, Value.newCodePoint(opCode, nextHash));\\n    }\\n\\n    function deserializeTuple(\\n        uint8 memberCount,\\n        bytes memory data,\\n        uint256 startOffset\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Value.Data[] memory // val\\n        )\\n    {\\n        uint256 offset = startOffset;\\n        Value.Data[] memory members = new Value.Data[](memberCount);\\n        for (uint8 i = 0; i < memberCount; i++) {\\n            (offset, members[i]) = deserialize(data, offset);\\n        }\\n        return (offset, members);\\n    }\\n\\n    function deserialize(bytes memory data, uint256 startOffset)\\n        internal\\n        pure\\n        returns (\\n            uint256, // offset\\n            Value.Data memory // val\\n        )\\n    {\\n        require(startOffset < data.length, \\\"invalid offset\\\");\\n        (uint256 offset, uint8 valType) = extractUint8(data, startOffset);\\n        if (valType == Value.intTypeCode()) {\\n            uint256 intVal;\\n            (offset, intVal) = deserializeInt(data, offset);\\n            return (offset, Value.newInt(intVal));\\n        } else if (valType == Value.codePointTypeCode()) {\\n            return deserializeCodePoint(data, offset);\\n        } else if (valType == Value.bufferTypeCode()) {\\n            bytes32 hashVal;\\n            (offset, hashVal) = deserializeBytes32(data, offset);\\n            return (offset, Value.newBuffer(hashVal));\\n        } else if (valType == Value.tuplePreImageTypeCode()) {\\n            return deserializeHashPreImage(data, offset);\\n        } else if (valType >= Value.tupleTypeCode() && valType < Value.valueTypeCode()) {\\n            uint8 tupLength = uint8(valType - Value.tupleTypeCode());\\n            Value.Data[] memory tupleVal;\\n            (offset, tupleVal) = deserializeTuple(tupLength, data, offset);\\n            return (offset, Value.newTuple(tupleVal));\\n        }\\n        require(false, \\\"invalid typecode\\\");\\n    }\\n\\n    function extractUint8(bytes memory data, uint256 startOffset)\\n        private\\n        pure\\n        returns (\\n            uint256, // offset\\n            uint8 // val\\n        )\\n    {\\n        return (startOffset + 1, uint8(data[startOffset]));\\n    }\\n\\n    function extractBytes32(bytes memory data, uint256 startOffset)\\n        private\\n        pure\\n        returns (\\n            uint256, // offset\\n            bytes32 // val\\n        )\\n    {\\n        return (startOffset + 32, data.toBytes32(startOffset));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/OneStepProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./IOneStepProof.sol\\\";\\nimport \\\"./OneStepProofCommon.sol\\\";\\n\\nimport \\\"../bridge/Messages.sol\\\";\\n\\nimport \\\"../libraries/BytesLib.sol\\\";\\n\\n// Originally forked from https://github.com/leapdao/solEVM-enforcer/tree/master\\n\\ncontract OneStepProof is OneStepProofCommon {\\n    using Machine for Machine.Data;\\n    using Hashing for Value.Data;\\n    using Value for Value.Data;\\n    using BytesLib for bytes;\\n\\n    uint256 private constant MAX_PAIRING_COUNT = 30;\\n    uint64 internal constant EC_PAIRING_BASE_GAS_COST = 1000;\\n    uint64 internal constant EC_PAIRING_POINT_GAS_COST = 500000;\\n\\n    /* solhint-disable no-inline-assembly */\\n\\n    // Arithmetic\\n\\n    function binaryMathOp(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        uint256 a = val1.intVal;\\n        uint256 b = val2.intVal;\\n\\n        uint256 c;\\n        if (context.opcode == OP_ADD) {\\n            assembly {\\n                c := add(a, b)\\n            }\\n        } else if (context.opcode == OP_MUL) {\\n            assembly {\\n                c := mul(a, b)\\n            }\\n        } else if (context.opcode == OP_SUB) {\\n            assembly {\\n                c := sub(a, b)\\n            }\\n        } else if (context.opcode == OP_EXP) {\\n            assembly {\\n                c := exp(a, b)\\n            }\\n        } else if (context.opcode == OP_SIGNEXTEND) {\\n            assembly {\\n                c := signextend(a, b)\\n            }\\n        } else if (context.opcode == OP_LT) {\\n            assembly {\\n                c := lt(a, b)\\n            }\\n        } else if (context.opcode == OP_GT) {\\n            assembly {\\n                c := gt(a, b)\\n            }\\n        } else if (context.opcode == OP_SLT) {\\n            assembly {\\n                c := slt(a, b)\\n            }\\n        } else if (context.opcode == OP_SGT) {\\n            assembly {\\n                c := sgt(a, b)\\n            }\\n        } else if (context.opcode == OP_AND) {\\n            assembly {\\n                c := and(a, b)\\n            }\\n        } else if (context.opcode == OP_OR) {\\n            assembly {\\n                c := or(a, b)\\n            }\\n        } else if (context.opcode == OP_XOR) {\\n            assembly {\\n                c := xor(a, b)\\n            }\\n        } else if (context.opcode == OP_BYTE) {\\n            assembly {\\n                c := byte(a, b)\\n            }\\n        } else if (context.opcode == OP_SHL) {\\n            assembly {\\n                c := shl(a, b)\\n            }\\n        } else if (context.opcode == OP_SHR) {\\n            assembly {\\n                c := shr(a, b)\\n            }\\n        } else if (context.opcode == OP_SAR) {\\n            assembly {\\n                c := sar(a, b)\\n            }\\n        } else if (context.opcode == OP_ETHHASH2) {\\n            c = uint256(keccak256(abi.encodePacked(a, b)));\\n        } else {\\n            assert(false);\\n        }\\n\\n        pushVal(context.stack, Value.newInt(c));\\n    }\\n\\n    function binaryMathOpZero(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isInt() || val2.intVal == 0) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        uint256 a = val1.intVal;\\n        uint256 b = val2.intVal;\\n\\n        uint256 c;\\n        if (context.opcode == OP_DIV) {\\n            assembly {\\n                c := div(a, b)\\n            }\\n        } else if (context.opcode == OP_SDIV) {\\n            assembly {\\n                c := sdiv(a, b)\\n            }\\n        } else if (context.opcode == OP_MOD) {\\n            assembly {\\n                c := mod(a, b)\\n            }\\n        } else if (context.opcode == OP_SMOD) {\\n            assembly {\\n                c := smod(a, b)\\n            }\\n        } else {\\n            assert(false);\\n        }\\n\\n        pushVal(context.stack, Value.newInt(c));\\n    }\\n\\n    function executeMathModInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        Value.Data memory val3 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isInt() || !val3.isInt() || val3.intVal == 0) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        uint256 a = val1.intVal;\\n        uint256 b = val2.intVal;\\n        uint256 m = val3.intVal;\\n\\n        uint256 c;\\n\\n        if (context.opcode == OP_ADDMOD) {\\n            assembly {\\n                c := addmod(a, b, m)\\n            }\\n        } else if (context.opcode == OP_MULMOD) {\\n            assembly {\\n                c := mulmod(a, b, m)\\n            }\\n        } else {\\n            assert(false);\\n        }\\n\\n        pushVal(context.stack, Value.newInt(c));\\n    }\\n\\n    function executeEqInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        pushVal(context.stack, Value.newBoolean(val1.hash() == val2.hash()));\\n    }\\n\\n    function executeIszeroInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        if (!val1.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        uint256 a = val1.intVal;\\n        uint256 c;\\n        assembly {\\n            c := iszero(a)\\n        }\\n        pushVal(context.stack, Value.newInt(c));\\n    }\\n\\n    function executeNotInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        if (!val1.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        uint256 a = val1.intVal;\\n        uint256 c;\\n        assembly {\\n            c := not(a)\\n        }\\n        pushVal(context.stack, Value.newInt(c));\\n    }\\n\\n    /* solhint-enable no-inline-assembly */\\n\\n    // Stack ops\\n\\n    function executePopInsn(AssertionContext memory context) internal pure {\\n        popVal(context.stack);\\n    }\\n\\n    function executeSpushInsn(AssertionContext memory context) internal pure {\\n        pushVal(context.stack, context.afterMachine.staticVal);\\n    }\\n\\n    function executeRpushInsn(AssertionContext memory context) internal pure {\\n        pushVal(context.stack, context.afterMachine.registerVal);\\n    }\\n\\n    function executeRsetInsn(AssertionContext memory context) internal pure {\\n        context.afterMachine.registerVal = popVal(context.stack);\\n    }\\n\\n    function executeJumpInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val = popVal(context.stack);\\n        if (!val.isCodePoint()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        context.afterMachine.instructionStackHash = val.hash();\\n    }\\n\\n    function executeCjumpInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        if (!val1.isCodePoint() || !val2.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        if (val2.intVal != 0) {\\n            context.afterMachine.instructionStackHash = val1.hash();\\n        }\\n    }\\n\\n    function executeStackemptyInsn(AssertionContext memory context) internal pure {\\n        bool empty =\\n            context.stack.length == 0 &&\\n                context.afterMachine.dataStack.hash() == Value.newEmptyTuple().hash();\\n        pushVal(context.stack, Value.newBoolean(empty));\\n    }\\n\\n    function executePcpushInsn(AssertionContext memory context) internal pure {\\n        pushVal(context.stack, Value.newHashedValue(context.startMachine.instructionStackHash, 1));\\n    }\\n\\n    function executeAuxpushInsn(AssertionContext memory context) internal pure {\\n        pushVal(context.auxstack, popVal(context.stack));\\n    }\\n\\n    function executeAuxpopInsn(AssertionContext memory context) internal pure {\\n        pushVal(context.stack, popVal(context.auxstack));\\n    }\\n\\n    function executeAuxstackemptyInsn(AssertionContext memory context) internal pure {\\n        bool empty =\\n            context.auxstack.length == 0 &&\\n                context.afterMachine.auxStack.hash() == Value.newEmptyTuple().hash();\\n        pushVal(context.stack, Value.newBoolean(empty));\\n    }\\n\\n    /* solhint-disable-next-line no-empty-blocks */\\n    function executeNopInsn(AssertionContext memory) internal pure {}\\n\\n    function executeErrpushInsn(AssertionContext memory context) internal pure {\\n        pushVal(context.stack, Value.newHashedValue(context.afterMachine.errHandlerHash, 1));\\n    }\\n\\n    function executeErrsetInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val = popVal(context.stack);\\n        if (!val.isCodePoint()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        context.afterMachine.errHandlerHash = val.hash();\\n    }\\n\\n    // Dup ops\\n\\n    function executeDup0Insn(AssertionContext memory context) internal pure {\\n        Value.Data memory val = popVal(context.stack);\\n        pushVal(context.stack, val);\\n        pushVal(context.stack, val);\\n    }\\n\\n    function executeDup1Insn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        pushVal(context.stack, val2);\\n        pushVal(context.stack, val1);\\n        pushVal(context.stack, val2);\\n    }\\n\\n    function executeDup2Insn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        Value.Data memory val3 = popVal(context.stack);\\n        pushVal(context.stack, val3);\\n        pushVal(context.stack, val2);\\n        pushVal(context.stack, val1);\\n        pushVal(context.stack, val3);\\n    }\\n\\n    // Swap ops\\n\\n    function executeSwap1Insn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        pushVal(context.stack, val1);\\n        pushVal(context.stack, val2);\\n    }\\n\\n    function executeSwap2Insn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        Value.Data memory val3 = popVal(context.stack);\\n        pushVal(context.stack, val1);\\n        pushVal(context.stack, val2);\\n        pushVal(context.stack, val3);\\n    }\\n\\n    // Tuple ops\\n\\n    function executeTgetInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isTuple() || val1.intVal >= val2.valLength()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        pushVal(context.stack, val2.tupleVal[val1.intVal]);\\n    }\\n\\n    function executeTsetInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        Value.Data memory val3 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isTuple() || val1.intVal >= val2.valLength()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        Value.Data[] memory tupleVals = val2.tupleVal;\\n        tupleVals[val1.intVal] = val3;\\n        pushVal(context.stack, Value.newTuple(tupleVals));\\n    }\\n\\n    function executeTlenInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        if (!val1.isTuple()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        pushVal(context.stack, Value.newInt(val1.valLength()));\\n    }\\n\\n    function executeXgetInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory auxVal = popVal(context.auxstack);\\n        if (!val1.isInt() || !auxVal.isTuple() || val1.intVal >= auxVal.valLength()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        pushVal(context.auxstack, auxVal);\\n        pushVal(context.stack, auxVal.tupleVal[val1.intVal]);\\n    }\\n\\n    function executeXsetInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        Value.Data memory auxVal = popVal(context.auxstack);\\n        if (!auxVal.isTuple() || !val1.isInt() || val1.intVal >= auxVal.valLength()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        Value.Data[] memory tupleVals = auxVal.tupleVal;\\n        tupleVals[val1.intVal] = val2;\\n        pushVal(context.auxstack, Value.newTuple(tupleVals));\\n    }\\n\\n    // Logging\\n\\n    function executeLogInsn(AssertionContext memory context) internal pure {\\n        context.logAcc = keccak256(abi.encodePacked(context.logAcc, popVal(context.stack).hash()));\\n    }\\n\\n    // System operations\\n\\n    function incrementInbox(AssertionContext memory context)\\n        private\\n        view\\n        returns (Value.Data memory message)\\n    {\\n        bytes memory proof = context.proof;\\n\\n        // [messageHash, prefixHash, messageDataHash]\\n        bytes32[3] memory messageHashes;\\n        uint256 inboxSeqNum;\\n        Value.Data[] memory tupData = new Value.Data[](8);\\n\\n        {\\n            // Get message out of proof\\n            uint8 kind = uint8(proof[context.offset]);\\n            context.offset++;\\n            uint256 l1BlockNumber;\\n            uint256 l1Timestamp;\\n            uint256 gasPriceL1;\\n            address sender = proof.toAddress(context.offset);\\n            context.offset += 20;\\n            (context.offset, l1BlockNumber) = Marshaling.deserializeInt(proof, context.offset);\\n            (context.offset, l1Timestamp) = Marshaling.deserializeInt(proof, context.offset);\\n            (context.offset, inboxSeqNum) = Marshaling.deserializeInt(proof, context.offset);\\n            (context.offset, gasPriceL1) = Marshaling.deserializeInt(proof, context.offset);\\n            uint256 messageDataLength;\\n            (context.offset, messageDataLength) = Marshaling.deserializeInt(proof, context.offset);\\n            bytes32 messageBufHash =\\n                Hashing.bytesToBufferHash(proof, context.offset, messageDataLength);\\n\\n            uint256 offset = context.offset;\\n            bytes32 messageDataHash;\\n            assembly {\\n                messageDataHash := keccak256(add(add(proof, 32), offset), messageDataLength)\\n            }\\n            context.offset += messageDataLength;\\n\\n            messageHashes[0] = Messages.messageHash(\\n                kind,\\n                sender,\\n                l1BlockNumber,\\n                l1Timestamp,\\n                inboxSeqNum,\\n                gasPriceL1,\\n                messageDataHash\\n            );\\n\\n            uint8 expectedSeqKind;\\n            if (messageDataLength > 0) {\\n                // L2_MSG\\n                expectedSeqKind = 3;\\n            } else {\\n                // END_OF_BLOCK_MESSAGE\\n                expectedSeqKind = 6;\\n            }\\n            if (kind == expectedSeqKind && gasPriceL1 == 0) {\\n                // Between the checks in the if statement, inboxSeqNum, and messageHashes[1:],\\n                // this constrains all fields without the full message hash.\\n                messageHashes[1] = keccak256(abi.encodePacked(sender, l1BlockNumber, l1Timestamp));\\n                messageHashes[2] = messageDataHash;\\n            }\\n\\n            tupData[0] = Value.newInt(uint256(kind));\\n            tupData[1] = Value.newInt(l1BlockNumber);\\n            tupData[2] = Value.newInt(l1Timestamp);\\n            tupData[3] = Value.newInt(uint256(sender));\\n            tupData[4] = Value.newInt(inboxSeqNum);\\n            tupData[5] = Value.newInt(gasPriceL1);\\n            tupData[6] = Value.newInt(messageDataLength);\\n            tupData[7] = Value.newHashedValue(messageBufHash, 1);\\n        }\\n\\n        uint256 seqBatchNum;\\n        (context.offset, seqBatchNum) = Marshaling.deserializeInt(proof, context.offset);\\n        uint8 isDelayed = uint8(proof[context.offset]);\\n        context.offset++;\\n        require(isDelayed == 0 || isDelayed == 1, \\\"IS_DELAYED_VAL\\\");\\n\\n        bytes32 acc;\\n        (context.offset, acc) = Marshaling.deserializeBytes32(proof, context.offset);\\n        if (isDelayed == 0) {\\n            // Start the proof at an arbitrary previous accumulator, as we validate the end accumulator.\\n            acc = keccak256(abi.encodePacked(acc, inboxSeqNum, messageHashes[1], messageHashes[2]));\\n\\n            require(inboxSeqNum == context.totalMessagesRead, \\\"WRONG_SEQUENCER_MSG_SEQ_NUM\\\");\\n            inboxSeqNum++;\\n        } else {\\n            // Read in delayed batch info from the proof. These fields are all part of the accumulator hash.\\n            uint256 firstSequencerSeqNum;\\n            uint256 delayedStart;\\n            uint256 delayedEnd;\\n            (context.offset, firstSequencerSeqNum) = Marshaling.deserializeInt(\\n                proof,\\n                context.offset\\n            );\\n            (context.offset, delayedStart) = Marshaling.deserializeInt(proof, context.offset);\\n            (context.offset, delayedEnd) = Marshaling.deserializeInt(proof, context.offset);\\n            bytes32 delayedEndAcc = context.delayedBridge.inboxAccs(delayedEnd - 1);\\n\\n            // Validate the delayed message is included in this sequencer batch.\\n            require(inboxSeqNum >= delayedStart, \\\"DELAYED_START\\\");\\n            require(inboxSeqNum < delayedEnd, \\\"DELAYED_END\\\");\\n\\n            // Validate the delayed message is in the delayed inbox.\\n            bytes32 prevDelayedAcc = 0;\\n            if (inboxSeqNum > 0) {\\n                prevDelayedAcc = context.delayedBridge.inboxAccs(inboxSeqNum - 1);\\n            }\\n            require(\\n                Messages.addMessageToInbox(prevDelayedAcc, messageHashes[0]) ==\\n                    context.delayedBridge.inboxAccs(inboxSeqNum),\\n                \\\"DELAYED_ACC\\\"\\n            );\\n\\n            // Delayed messages are sequenced into a separate sequence number space with the upper bit set.\\n            // Note that messageHash is no longer accurate after this point, as this modifies the message.\\n            tupData[4] = Value.newInt(inboxSeqNum | (1 << 255));\\n            // Confirm that this fits into the correct position of the sequencer sequence.\\n            require(\\n                inboxSeqNum - delayedStart + firstSequencerSeqNum == context.totalMessagesRead,\\n                \\\"WRONG_DELAYED_MSG_SEQ_NUM\\\"\\n            );\\n\\n            acc = keccak256(\\n                abi.encodePacked(\\n                    \\\"Delayed messages:\\\",\\n                    acc,\\n                    firstSequencerSeqNum,\\n                    delayedStart,\\n                    delayedEnd,\\n                    delayedEndAcc\\n                )\\n            );\\n            inboxSeqNum = firstSequencerSeqNum + (delayedEnd - delayedStart);\\n        }\\n\\n        // Get to the end of the batch by hashing in arbitrary future sequencer messages.\\n        while (true) {\\n            // 0 = sequencer message\\n            // 1 = delayed message batch\\n            // 2 = end of batch\\n            isDelayed = uint8(proof[context.offset]);\\n            if (isDelayed == 2) {\\n                break;\\n            }\\n            require(isDelayed == 0 || isDelayed == 1, \\\"REM_IS_DELAYED_VAL\\\");\\n            context.offset++;\\n            if (isDelayed == 0) {\\n                bytes32 newerMessagePrefixHash;\\n                bytes32 newerMessageDataHash;\\n                (context.offset, newerMessagePrefixHash) = Marshaling.deserializeBytes32(\\n                    proof,\\n                    context.offset\\n                );\\n                (context.offset, newerMessageDataHash) = Marshaling.deserializeBytes32(\\n                    proof,\\n                    context.offset\\n                );\\n                acc = keccak256(\\n                    abi.encodePacked(acc, inboxSeqNum, newerMessagePrefixHash, newerMessageDataHash)\\n                );\\n                inboxSeqNum++;\\n            } else {\\n                uint256 delayedStart;\\n                uint256 delayedEnd;\\n                (context.offset, delayedStart) = Marshaling.deserializeInt(proof, context.offset);\\n                (context.offset, delayedEnd) = Marshaling.deserializeInt(proof, context.offset);\\n                acc = keccak256(\\n                    abi.encodePacked(\\n                        \\\"Delayed messages:\\\",\\n                        acc,\\n                        inboxSeqNum,\\n                        delayedStart,\\n                        delayedEnd,\\n                        context.delayedBridge.inboxAccs(delayedEnd - 1)\\n                    )\\n                );\\n                inboxSeqNum += delayedEnd - delayedStart;\\n            }\\n        }\\n\\n        require(acc == context.sequencerBridge.inboxAccs(seqBatchNum), \\\"WRONG_BATCH_ACC\\\");\\n\\n        context.totalMessagesRead++;\\n\\n        return Value.newTuple(tupData);\\n    }\\n\\n    function executeInboxInsn(AssertionContext memory context) internal view {\\n        pushVal(context.stack, incrementInbox(context));\\n    }\\n\\n    function executeSetGasInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        if (!val1.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        context.afterMachine.arbGasRemaining = val1.intVal;\\n    }\\n\\n    function executePushGasInsn(AssertionContext memory context) internal pure {\\n        pushVal(context.stack, Value.newInt(context.afterMachine.arbGasRemaining));\\n    }\\n\\n    function executeErrCodePointInsn(AssertionContext memory context) internal pure {\\n        pushVal(context.stack, Value.newHashedValue(CODE_POINT_ERROR, 1));\\n    }\\n\\n    function executePushInsnInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isCodePoint()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        pushVal(context.stack, Value.newCodePoint(uint8(val1.intVal), val2.hash()));\\n    }\\n\\n    function executePushInsnImmInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        Value.Data memory val3 = popVal(context.stack);\\n        if (!val1.isInt() || !val3.isCodePoint()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        pushVal(context.stack, Value.newCodePoint(uint8(val1.intVal), val3.hash(), val2));\\n    }\\n\\n    function executeSideloadInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        if (!val1.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        Value.Data[] memory values = new Value.Data[](0);\\n        pushVal(context.stack, Value.newTuple(values));\\n    }\\n\\n    function executeECRecoverInsn(AssertionContext memory context) internal pure {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        Value.Data memory val3 = popVal(context.stack);\\n        Value.Data memory val4 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isInt() || !val3.isInt() || !val4.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        bytes32 r = bytes32(val1.intVal);\\n        bytes32 s = bytes32(val2.intVal);\\n        if (val3.intVal != 0 && val3.intVal != 1) {\\n            pushVal(context.stack, Value.newInt(0));\\n            return;\\n        }\\n        uint8 v = uint8(val3.intVal) + 27;\\n        bytes32 message = bytes32(val4.intVal);\\n        address ret = ecrecover(message, v, r, s);\\n        pushVal(context.stack, Value.newInt(uint256(ret)));\\n    }\\n\\n    /* solhint-disable no-inline-assembly */\\n\\n    function executeECAddInsn(AssertionContext memory context) internal view {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        Value.Data memory val3 = popVal(context.stack);\\n        Value.Data memory val4 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isInt() || !val3.isInt() || !val4.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        uint256[4] memory bnAddInput = [val1.intVal, val2.intVal, val3.intVal, val4.intVal];\\n        uint256[2] memory ret;\\n        bool success;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 6, bnAddInput, 0x80, ret, 0x40)\\n        }\\n        if (!success) {\\n            // Must end on empty tuple\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        pushVal(context.stack, Value.newInt(uint256(ret[1])));\\n        pushVal(context.stack, Value.newInt(uint256(ret[0])));\\n    }\\n\\n    function executeECMulInsn(AssertionContext memory context) internal view {\\n        Value.Data memory val1 = popVal(context.stack);\\n        Value.Data memory val2 = popVal(context.stack);\\n        Value.Data memory val3 = popVal(context.stack);\\n        if (!val1.isInt() || !val2.isInt() || !val3.isInt()) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        uint256[3] memory bnAddInput = [val1.intVal, val2.intVal, val3.intVal];\\n        uint256[2] memory ret;\\n        bool success;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 7, bnAddInput, 0x80, ret, 0x40)\\n        }\\n        if (!success) {\\n            // Must end on empty tuple\\n            handleOpcodeError(context);\\n            return;\\n        }\\n        pushVal(context.stack, Value.newInt(uint256(ret[1])));\\n        pushVal(context.stack, Value.newInt(uint256(ret[0])));\\n    }\\n\\n    function executeECPairingInsn(AssertionContext memory context) internal view {\\n        Value.Data memory val = popVal(context.stack);\\n\\n        Value.Data[MAX_PAIRING_COUNT] memory items;\\n        bool postGasError = false;\\n        uint256 count;\\n        for (count = 0; count < MAX_PAIRING_COUNT; count++) {\\n            if (!val.isTuple()) {\\n                postGasError = true;\\n                break;\\n            }\\n            Value.Data[] memory stackTupleVals = val.tupleVal;\\n            if (stackTupleVals.length == 0) {\\n                // We reached the bottom of the stack\\n                break;\\n            }\\n            if (stackTupleVals.length != 2) {\\n                postGasError = true;\\n                break;\\n            }\\n            items[count] = stackTupleVals[0];\\n            val = stackTupleVals[1];\\n        }\\n\\n        if (deductGas(context, uint64(EC_PAIRING_POINT_GAS_COST * count))) {\\n            // When we run out of gas, we only charge for an error + gas_set\\n            // That means we need to deduct the previously charged base cost here\\n            context.gas -= EC_PAIRING_BASE_GAS_COST;\\n            handleError(context);\\n            return;\\n        }\\n\\n        if (postGasError || !val.isTuple() || val.tupleVal.length != 0) {\\n            // Must end on empty tuple\\n            handleOpcodeError(context);\\n            return;\\n        }\\n\\n        // Allocate the maximum amount of space we might need\\n        uint256[MAX_PAIRING_COUNT * 6] memory input;\\n        for (uint256 i = 0; i < count; i++) {\\n            Value.Data memory pointVal = items[i];\\n            if (!pointVal.isTuple()) {\\n                handleOpcodeError(context);\\n                return;\\n            }\\n\\n            Value.Data[] memory pointTupleVals = pointVal.tupleVal;\\n            if (pointTupleVals.length != 6) {\\n                handleOpcodeError(context);\\n                return;\\n            }\\n\\n            for (uint256 j = 0; j < 6; j++) {\\n                if (!pointTupleVals[j].isInt()) {\\n                    handleOpcodeError(context);\\n                    return;\\n                }\\n            }\\n            input[i * 6] = pointTupleVals[0].intVal;\\n            input[i * 6 + 1] = pointTupleVals[1].intVal;\\n            input[i * 6 + 2] = pointTupleVals[3].intVal;\\n            input[i * 6 + 3] = pointTupleVals[2].intVal;\\n            input[i * 6 + 4] = pointTupleVals[5].intVal;\\n            input[i * 6 + 5] = pointTupleVals[4].intVal;\\n        }\\n\\n        uint256 inputSize = count * 6 * 0x20;\\n        uint256[1] memory out;\\n        bool success;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 8, input, inputSize, out, 0x20)\\n        }\\n\\n        if (!success) {\\n            handleOpcodeError(context);\\n            return;\\n        }\\n\\n        pushVal(context.stack, Value.newBoolean(out[0] != 0));\\n    }\\n\\n    /* solhint-enable no-inline-assembly */\\n\\n    function executeErrorInsn(AssertionContext memory context) internal pure {\\n        handleOpcodeError(context);\\n    }\\n\\n    function executeStopInsn(AssertionContext memory context) internal pure {\\n        context.afterMachine.setHalt();\\n    }\\n\\n    function executeNewBuffer(AssertionContext memory context) internal pure {\\n        pushVal(context.stack, Value.newBuffer(keccak256(abi.encodePacked(bytes32(0)))));\\n    }\\n\\n    function opInfo(uint256 opCode)\\n        internal\\n        pure\\n        override\\n        returns (\\n            uint256, // stack pops\\n            uint256, // auxstack pops\\n            uint64, // gas used\\n            function(AssertionContext memory) internal view // impl\\n        )\\n    {\\n        if (opCode == OP_ADD || opCode == OP_MUL || opCode == OP_SUB) {\\n            return (2, 0, 3, binaryMathOp);\\n        } else if (opCode == OP_DIV || opCode == OP_MOD) {\\n            return (2, 0, 4, binaryMathOpZero);\\n        } else if (opCode == OP_SDIV || opCode == OP_SMOD) {\\n            return (2, 0, 7, binaryMathOpZero);\\n        } else if (opCode == OP_ADDMOD || opCode == OP_MULMOD) {\\n            return (3, 0, 4, executeMathModInsn);\\n        } else if (opCode == OP_EXP) {\\n            return (2, 0, 25, binaryMathOp);\\n        } else if (opCode == OP_SIGNEXTEND) {\\n            return (2, 0, 7, binaryMathOp);\\n        } else if (\\n            opCode == OP_LT ||\\n            opCode == OP_GT ||\\n            opCode == OP_SLT ||\\n            opCode == OP_SGT ||\\n            opCode == OP_AND ||\\n            opCode == OP_OR ||\\n            opCode == OP_XOR\\n        ) {\\n            return (2, 0, 2, binaryMathOp);\\n        } else if (opCode == OP_EQ) {\\n            return (2, 0, 2, executeEqInsn);\\n        } else if (opCode == OP_ISZERO) {\\n            return (1, 0, 1, executeIszeroInsn);\\n        } else if (opCode == OP_NOT) {\\n            return (1, 0, 1, executeNotInsn);\\n        } else if (opCode == OP_BYTE || opCode == OP_SHL || opCode == OP_SHR || opCode == OP_SAR) {\\n            return (2, 0, 4, binaryMathOp);\\n        } else if (opCode == OP_POP) {\\n            return (1, 0, 1, executePopInsn);\\n        } else if (opCode == OP_SPUSH) {\\n            return (0, 0, 1, executeSpushInsn);\\n        } else if (opCode == OP_RPUSH) {\\n            return (0, 0, 1, executeRpushInsn);\\n        } else if (opCode == OP_RSET) {\\n            return (1, 0, 2, executeRsetInsn);\\n        } else if (opCode == OP_JUMP) {\\n            return (1, 0, 4, executeJumpInsn);\\n        } else if (opCode == OP_CJUMP) {\\n            return (2, 0, 4, executeCjumpInsn);\\n        } else if (opCode == OP_STACKEMPTY) {\\n            return (0, 0, 2, executeStackemptyInsn);\\n        } else if (opCode == OP_PCPUSH) {\\n            return (0, 0, 1, executePcpushInsn);\\n        } else if (opCode == OP_AUXPUSH) {\\n            return (1, 0, 1, executeAuxpushInsn);\\n        } else if (opCode == OP_AUXPOP) {\\n            return (0, 1, 1, executeAuxpopInsn);\\n        } else if (opCode == OP_AUXSTACKEMPTY) {\\n            return (0, 0, 2, executeAuxstackemptyInsn);\\n        } else if (opCode == OP_NOP) {\\n            return (0, 0, 1, executeNopInsn);\\n        } else if (opCode == OP_ERRPUSH) {\\n            return (0, 0, 1, executeErrpushInsn);\\n        } else if (opCode == OP_ERRSET) {\\n            return (1, 0, 1, executeErrsetInsn);\\n        } else if (opCode == OP_DUP0) {\\n            return (1, 0, 1, executeDup0Insn);\\n        } else if (opCode == OP_DUP1) {\\n            return (2, 0, 1, executeDup1Insn);\\n        } else if (opCode == OP_DUP2) {\\n            return (3, 0, 1, executeDup2Insn);\\n        } else if (opCode == OP_SWAP1) {\\n            return (2, 0, 1, executeSwap1Insn);\\n        } else if (opCode == OP_SWAP2) {\\n            return (3, 0, 1, executeSwap2Insn);\\n        } else if (opCode == OP_TGET) {\\n            return (2, 0, 2, executeTgetInsn);\\n        } else if (opCode == OP_TSET) {\\n            return (3, 0, 40, executeTsetInsn);\\n        } else if (opCode == OP_TLEN) {\\n            return (1, 0, 2, executeTlenInsn);\\n        } else if (opCode == OP_XGET) {\\n            return (1, 1, 3, executeXgetInsn);\\n        } else if (opCode == OP_XSET) {\\n            return (2, 1, 41, executeXsetInsn);\\n        } else if (opCode == OP_BREAKPOINT) {\\n            return (0, 0, 100, executeNopInsn);\\n        } else if (opCode == OP_LOG) {\\n            return (1, 0, 100, executeLogInsn);\\n        } else if (opCode == OP_INBOX) {\\n            return (0, 0, 40, executeInboxInsn);\\n        } else if (opCode == OP_ERROR) {\\n            return (0, 0, ERROR_GAS_COST, executeErrorInsn);\\n        } else if (opCode == OP_STOP) {\\n            return (0, 0, 10, executeStopInsn);\\n        } else if (opCode == OP_SETGAS) {\\n            return (1, 0, 1, executeSetGasInsn);\\n        } else if (opCode == OP_PUSHGAS) {\\n            return (0, 0, 1, executePushGasInsn);\\n        } else if (opCode == OP_ERR_CODE_POINT) {\\n            return (0, 0, 25, executeErrCodePointInsn);\\n        } else if (opCode == OP_PUSH_INSN) {\\n            return (2, 0, 25, executePushInsnInsn);\\n        } else if (opCode == OP_PUSH_INSN_IMM) {\\n            return (3, 0, 25, executePushInsnImmInsn);\\n        } else if (opCode == OP_SIDELOAD) {\\n            return (1, 0, 10, executeSideloadInsn);\\n        } else if (opCode == OP_ECRECOVER) {\\n            return (4, 0, 20000, executeECRecoverInsn);\\n        } else if (opCode == OP_ECADD) {\\n            return (4, 0, 3500, executeECAddInsn);\\n        } else if (opCode == OP_ECMUL) {\\n            return (3, 0, 82000, executeECMulInsn);\\n        } else if (opCode == OP_ECPAIRING) {\\n            return (1, 0, EC_PAIRING_BASE_GAS_COST, executeECPairingInsn);\\n        } else if (opCode == OP_DEBUGPRINT) {\\n            return (1, 0, 1, executePopInsn);\\n        } else if (opCode == OP_NEWBUFFER) {\\n            return (0, 0, 1, executeNewBuffer);\\n        } else if (opCode >= OP_HASH && opCode <= OP_SHA256_F) {\\n            revert(\\\"use another contract to handle hashing opcodes\\\");\\n        } else if ((opCode >= OP_GETBUFFER8 && opCode <= OP_SETBUFFER256) || opCode == OP_SEND) {\\n            revert(\\\"use another contract to handle buffer opcodes\\\");\\n        } else {\\n            return (0, 0, ERROR_GAS_COST, executeErrorInsn);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/arch/OneStepProofCommon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nimport \\\"./IOneStepProof.sol\\\";\\nimport \\\"./Value.sol\\\";\\nimport \\\"./Machine.sol\\\";\\nimport \\\"../bridge/interfaces/IBridge.sol\\\";\\nimport \\\"../bridge/interfaces/ISequencerInbox.sol\\\";\\n\\nabstract contract OneStepProofCommon is IOneStepProof {\\n    using Machine for Machine.Data;\\n    using Hashing for Value.Data;\\n    using Value for Value.Data;\\n\\n    uint256 internal constant MAX_UINT256 = ((1 << 128) + 1) * ((1 << 128) - 1);\\n\\n    uint64 internal constant ERROR_GAS_COST = 5;\\n\\n    string internal constant BAD_IMM_TYP = \\\"BAD_IMM_TYP\\\";\\n    string internal constant NO_IMM = \\\"NO_IMM\\\";\\n    string internal constant STACK_MISSING = \\\"STACK_MISSING\\\";\\n    string internal constant AUX_MISSING = \\\"AUX_MISSING\\\";\\n    string internal constant STACK_MANY = \\\"STACK_MANY\\\";\\n    string internal constant AUX_MANY = \\\"AUX_MANY\\\";\\n    string internal constant INBOX_VAL = \\\"INBOX_VAL\\\";\\n\\n    // Stop and arithmetic ops\\n    uint8 internal constant OP_ADD = 0x01;\\n    uint8 internal constant OP_MUL = 0x02;\\n    uint8 internal constant OP_SUB = 0x03;\\n    uint8 internal constant OP_DIV = 0x04;\\n    uint8 internal constant OP_SDIV = 0x05;\\n    uint8 internal constant OP_MOD = 0x06;\\n    uint8 internal constant OP_SMOD = 0x07;\\n    uint8 internal constant OP_ADDMOD = 0x08;\\n    uint8 internal constant OP_MULMOD = 0x09;\\n    uint8 internal constant OP_EXP = 0x0a;\\n    uint8 internal constant OP_SIGNEXTEND = 0x0b;\\n\\n    // Comparison & bitwise logic\\n    uint8 internal constant OP_LT = 0x10;\\n    uint8 internal constant OP_GT = 0x11;\\n    uint8 internal constant OP_SLT = 0x12;\\n    uint8 internal constant OP_SGT = 0x13;\\n    uint8 internal constant OP_EQ = 0x14;\\n    uint8 internal constant OP_ISZERO = 0x15;\\n    uint8 internal constant OP_AND = 0x16;\\n    uint8 internal constant OP_OR = 0x17;\\n    uint8 internal constant OP_XOR = 0x18;\\n    uint8 internal constant OP_NOT = 0x19;\\n    uint8 internal constant OP_BYTE = 0x1a;\\n    uint8 internal constant OP_SHL = 0x1b;\\n    uint8 internal constant OP_SHR = 0x1c;\\n    uint8 internal constant OP_SAR = 0x1d;\\n\\n    // SHA3\\n    uint8 internal constant OP_HASH = 0x20;\\n    uint8 internal constant OP_TYPE = 0x21;\\n    uint8 internal constant OP_ETHHASH2 = 0x22;\\n    uint8 internal constant OP_KECCAK_F = 0x23;\\n    uint8 internal constant OP_SHA256_F = 0x24;\\n\\n    // Stack, Memory, Storage and Flow Operations\\n    uint8 internal constant OP_POP = 0x30;\\n    uint8 internal constant OP_SPUSH = 0x31;\\n    uint8 internal constant OP_RPUSH = 0x32;\\n    uint8 internal constant OP_RSET = 0x33;\\n    uint8 internal constant OP_JUMP = 0x34;\\n    uint8 internal constant OP_CJUMP = 0x35;\\n    uint8 internal constant OP_STACKEMPTY = 0x36;\\n    uint8 internal constant OP_PCPUSH = 0x37;\\n    uint8 internal constant OP_AUXPUSH = 0x38;\\n    uint8 internal constant OP_AUXPOP = 0x39;\\n    uint8 internal constant OP_AUXSTACKEMPTY = 0x3a;\\n    uint8 internal constant OP_NOP = 0x3b;\\n    uint8 internal constant OP_ERRPUSH = 0x3c;\\n    uint8 internal constant OP_ERRSET = 0x3d;\\n\\n    // Duplication and Exchange operations\\n    uint8 internal constant OP_DUP0 = 0x40;\\n    uint8 internal constant OP_DUP1 = 0x41;\\n    uint8 internal constant OP_DUP2 = 0x42;\\n    uint8 internal constant OP_SWAP1 = 0x43;\\n    uint8 internal constant OP_SWAP2 = 0x44;\\n\\n    // Tuple operations\\n    uint8 internal constant OP_TGET = 0x50;\\n    uint8 internal constant OP_TSET = 0x51;\\n    uint8 internal constant OP_TLEN = 0x52;\\n    uint8 internal constant OP_XGET = 0x53;\\n    uint8 internal constant OP_XSET = 0x54;\\n\\n    // Logging operations\\n    uint8 internal constant OP_BREAKPOINT = 0x60;\\n    uint8 internal constant OP_LOG = 0x61;\\n\\n    // System operations\\n    uint8 internal constant OP_SEND = 0x70;\\n    // OP_INBOX_PEEK has been removed\\n    uint8 internal constant OP_INBOX = 0x72;\\n    uint8 internal constant OP_ERROR = 0x73;\\n    uint8 internal constant OP_STOP = 0x74;\\n    uint8 internal constant OP_SETGAS = 0x75;\\n    uint8 internal constant OP_PUSHGAS = 0x76;\\n    uint8 internal constant OP_ERR_CODE_POINT = 0x77;\\n    uint8 internal constant OP_PUSH_INSN = 0x78;\\n    uint8 internal constant OP_PUSH_INSN_IMM = 0x79;\\n    // uint8 private constant OP_OPEN_INSN = 0x7a;\\n    uint8 internal constant OP_SIDELOAD = 0x7b;\\n\\n    uint8 internal constant OP_ECRECOVER = 0x80;\\n    uint8 internal constant OP_ECADD = 0x81;\\n    uint8 internal constant OP_ECMUL = 0x82;\\n    uint8 internal constant OP_ECPAIRING = 0x83;\\n\\n    uint8 internal constant OP_DEBUGPRINT = 0x90;\\n\\n    // Buffer operations\\n    uint8 internal constant OP_NEWBUFFER = 0xa0;\\n    uint8 internal constant OP_GETBUFFER8 = 0xa1;\\n    uint8 internal constant OP_GETBUFFER64 = 0xa2;\\n    uint8 internal constant OP_GETBUFFER256 = 0xa3;\\n    uint8 internal constant OP_SETBUFFER8 = 0xa4;\\n    uint8 internal constant OP_SETBUFFER64 = 0xa5;\\n    uint8 internal constant OP_SETBUFFER256 = 0xa6;\\n\\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\\n    bytes32 internal constant CODE_POINT_ERROR =\\n        keccak256(abi.encodePacked(CODE_POINT_TYPECODE, uint8(0), bytes32(0)));\\n\\n    uint256 internal constant SEND_SIZE_LIMIT = 10000;\\n\\n    // accs is [sendAcc, logAcc]\\n    function executeStep(\\n        address[2] calldata bridges,\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes calldata proof,\\n        bytes calldata bproof\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            uint64 gas,\\n            uint256 afterMessagesRead,\\n            bytes32[4] memory fields\\n        )\\n    {\\n        AssertionContext memory context =\\n            initializeExecutionContext(initialMessagesRead, accs, proof, bproof, bridges);\\n\\n        executeOp(context);\\n\\n        return returnContext(context);\\n    }\\n\\n    function executeStepDebug(\\n        address[2] calldata bridges,\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes calldata proof,\\n        bytes calldata bproof\\n    ) external view override returns (string memory startMachine, string memory afterMachine) {\\n        AssertionContext memory context =\\n            initializeExecutionContext(initialMessagesRead, accs, proof, bproof, bridges);\\n\\n        executeOp(context);\\n        startMachine = Machine.toString(context.startMachine);\\n        afterMachine = Machine.toString(context.afterMachine);\\n    }\\n\\n    // fields\\n    // startMachineHash,\\n    // endMachineHash,\\n    // afterInboxAcc,\\n    // afterMessagesHash,\\n    // afterLogsHash\\n\\n    function returnContext(AssertionContext memory context)\\n        internal\\n        pure\\n        returns (\\n            uint64 gas,\\n            uint256 afterMessagesRead,\\n            bytes32[4] memory fields\\n        )\\n    {\\n        return (\\n            context.gas,\\n            context.totalMessagesRead,\\n            [\\n                Machine.hash(context.startMachine),\\n                Machine.hash(context.afterMachine),\\n                context.sendAcc,\\n                context.logAcc\\n            ]\\n        );\\n    }\\n\\n    struct ValueStack {\\n        uint256 length;\\n        Value.Data[] values;\\n    }\\n\\n    function popVal(ValueStack memory stack) internal pure returns (Value.Data memory) {\\n        Value.Data memory val = stack.values[stack.length - 1];\\n        stack.length--;\\n        return val;\\n    }\\n\\n    function pushVal(ValueStack memory stack, Value.Data memory val) internal pure {\\n        stack.values[stack.length] = val;\\n        stack.length++;\\n    }\\n\\n    struct AssertionContext {\\n        ISequencerInbox sequencerBridge;\\n        IBridge delayedBridge;\\n        Machine.Data startMachine;\\n        Machine.Data afterMachine;\\n        uint256 totalMessagesRead;\\n        bytes32 sendAcc;\\n        bytes32 logAcc;\\n        uint64 gas;\\n        ValueStack stack;\\n        ValueStack auxstack;\\n        bool hadImmediate;\\n        uint8 opcode;\\n        bytes proof;\\n        uint256 offset;\\n        // merkle proofs for buffer\\n        bytes bufProof;\\n        bool errorOccurred;\\n    }\\n\\n    function handleError(AssertionContext memory context) internal pure {\\n        context.errorOccurred = true;\\n    }\\n\\n    function deductGas(AssertionContext memory context, uint64 amount)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (context.afterMachine.arbGasRemaining < amount) {\\n            // ERROR + GAS_SET\\n            context.gas += ERROR_GAS_COST;\\n            context.afterMachine.arbGasRemaining = MAX_UINT256;\\n            return true;\\n        } else {\\n            context.gas += amount;\\n            context.afterMachine.arbGasRemaining -= amount;\\n            return false;\\n        }\\n    }\\n\\n    function handleOpcodeError(AssertionContext memory context) internal pure {\\n        handleError(context);\\n    }\\n\\n    function initializeExecutionContext(\\n        uint256 initialMessagesRead,\\n        bytes32[2] calldata accs,\\n        bytes memory proof,\\n        bytes memory bproof,\\n        address[2] calldata bridges\\n    ) internal pure returns (AssertionContext memory) {\\n        uint8 opCode = uint8(proof[0]);\\n        uint8 stackCount = uint8(proof[1]);\\n        uint8 auxstackCount = uint8(proof[2]);\\n        uint256 offset = 3;\\n\\n        // Leave some extra space for values pushed on the stack in the proofs\\n        Value.Data[] memory stackVals = new Value.Data[](stackCount + 4);\\n        Value.Data[] memory auxstackVals = new Value.Data[](auxstackCount + 4);\\n        for (uint256 i = 0; i < stackCount; i++) {\\n            (offset, stackVals[i]) = Marshaling.deserialize(proof, offset);\\n        }\\n        for (uint256 i = 0; i < auxstackCount; i++) {\\n            (offset, auxstackVals[i]) = Marshaling.deserialize(proof, offset);\\n        }\\n        Machine.Data memory mach;\\n        (offset, mach) = Machine.deserializeMachine(proof, offset);\\n\\n        uint8 immediate = uint8(proof[offset]);\\n        offset += 1;\\n\\n        AssertionContext memory context;\\n        context.sequencerBridge = ISequencerInbox(bridges[0]);\\n        context.delayedBridge = IBridge(bridges[1]);\\n        context.startMachine = mach;\\n        context.afterMachine = mach.clone();\\n        context.totalMessagesRead = initialMessagesRead;\\n        context.sendAcc = accs[0];\\n        context.logAcc = accs[1];\\n        context.gas = 0;\\n        context.stack = ValueStack(stackCount, stackVals);\\n        context.auxstack = ValueStack(auxstackCount, auxstackVals);\\n        context.hadImmediate = immediate == 1;\\n        context.opcode = opCode;\\n        context.proof = proof;\\n        context.bufProof = bproof;\\n        context.errorOccurred = false;\\n        context.offset = offset;\\n\\n        require(immediate == 0 || immediate == 1, BAD_IMM_TYP);\\n        Value.Data memory cp;\\n        if (immediate == 0) {\\n            cp = Value.newCodePoint(uint8(opCode), context.startMachine.instructionStackHash);\\n        } else {\\n            // If we have an immediate, there must be at least one stack value\\n            require(stackVals.length > 0, NO_IMM);\\n            cp = Value.newCodePoint(\\n                uint8(opCode),\\n                context.startMachine.instructionStackHash,\\n                stackVals[stackCount - 1]\\n            );\\n        }\\n        context.startMachine.instructionStackHash = cp.hash();\\n\\n        // Add the stack and auxstack values to the start machine\\n        uint256 i = 0;\\n        for (i = 0; i < stackCount - immediate; i++) {\\n            context.startMachine.addDataStackValue(stackVals[i]);\\n        }\\n        for (i = 0; i < auxstackCount; i++) {\\n            context.startMachine.addAuxStackValue(auxstackVals[i]);\\n        }\\n\\n        return context;\\n    }\\n\\n    function executeOp(AssertionContext memory context) internal view {\\n        (\\n            uint256 dataPopCount,\\n            uint256 auxPopCount,\\n            uint64 gasCost,\\n            function(AssertionContext memory) internal view impl\\n        ) = opInfo(context.opcode);\\n\\n        // Require the prover to submit the minimal number of stack items\\n        require(\\n            ((dataPopCount > 0 || !context.hadImmediate) && context.stack.length <= dataPopCount) ||\\n                (context.hadImmediate && dataPopCount == 0 && context.stack.length == 1),\\n            STACK_MANY\\n        );\\n        require(context.auxstack.length <= auxPopCount, AUX_MANY);\\n\\n        // Update end machine gas remaining before running opcode\\n        if (context.stack.length < dataPopCount) {\\n            // If we have insufficient values, reject the proof unless the stack has been fully exhausted\\n            require(\\n                context.afterMachine.dataStack.hash() == Value.newEmptyTuple().hash(),\\n                STACK_MISSING\\n            );\\n            deductGas(context, ERROR_GAS_COST);\\n            // If the stack is empty, the instruction underflowed so we have hit an error\\n            handleError(context);\\n        } else if (context.auxstack.length < auxPopCount) {\\n            // If we have insufficient values, reject the proof unless the auxstack has been fully exhausted\\n            require(\\n                context.afterMachine.auxStack.hash() == Value.newEmptyTuple().hash(),\\n                AUX_MISSING\\n            );\\n            deductGas(context, ERROR_GAS_COST);\\n            // If the auxstack is empty, the instruction underflowed so we have hit an error\\n            handleError(context);\\n        } else if (deductGas(context, gasCost)) {\\n            handleError(context);\\n        } else {\\n            impl(context);\\n        }\\n\\n        if (context.errorOccurred) {\\n            if (context.afterMachine.errHandlerHash == CODE_POINT_ERROR) {\\n                context.afterMachine.setErrorStop();\\n            } else {\\n                // Clear error\\n                context.errorOccurred = false;\\n                context.afterMachine.instructionStackHash = context.afterMachine.errHandlerHash;\\n\\n                if (!(context.hadImmediate && dataPopCount == 0)) {\\n                    context.stack.length = 0;\\n                }\\n                context.auxstack.length = 0;\\n            }\\n        }\\n\\n        // Add the stack and auxstack values to the start machine\\n        uint256 i = 0;\\n\\n        for (i = 0; i < context.stack.length; i++) {\\n            context.afterMachine.addDataStackValue(context.stack.values[i]);\\n        }\\n\\n        for (i = 0; i < context.auxstack.length; i++) {\\n            context.afterMachine.addAuxStackValue(context.auxstack.values[i]);\\n        }\\n    }\\n\\n    function opInfo(uint256 opCode)\\n        internal\\n        pure\\n        virtual\\n        returns (\\n            uint256, // stack pops\\n            uint256, // auxstack pops\\n            uint64, // gas used\\n            function(AssertionContext memory) internal view // impl\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/arch/Value.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nlibrary Value {\\n    uint8 internal constant INT_TYPECODE = 0;\\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\\n    uint8 internal constant HASH_PRE_IMAGE_TYPECODE = 2;\\n    uint8 internal constant TUPLE_TYPECODE = 3;\\n    uint8 internal constant BUFFER_TYPECODE = TUPLE_TYPECODE + 9;\\n    // All values received from clients will have type codes less than the VALUE_TYPE_COUNT\\n    uint8 internal constant VALUE_TYPE_COUNT = TUPLE_TYPECODE + 10;\\n\\n    // The following types do not show up in the marshalled format and is\\n    // only used for internal tracking purposes\\n    uint8 internal constant HASH_ONLY = 100;\\n\\n    struct CodePoint {\\n        uint8 opcode;\\n        bytes32 nextCodePoint;\\n        Data[] immediate;\\n    }\\n\\n    struct Data {\\n        uint256 intVal;\\n        CodePoint cpVal;\\n        Data[] tupleVal;\\n        bytes32 bufferHash;\\n        uint8 typeCode;\\n        uint256 size;\\n    }\\n\\n    function tupleTypeCode() internal pure returns (uint8) {\\n        return TUPLE_TYPECODE;\\n    }\\n\\n    function tuplePreImageTypeCode() internal pure returns (uint8) {\\n        return HASH_PRE_IMAGE_TYPECODE;\\n    }\\n\\n    function intTypeCode() internal pure returns (uint8) {\\n        return INT_TYPECODE;\\n    }\\n\\n    function bufferTypeCode() internal pure returns (uint8) {\\n        return BUFFER_TYPECODE;\\n    }\\n\\n    function codePointTypeCode() internal pure returns (uint8) {\\n        return CODE_POINT_TYPECODE;\\n    }\\n\\n    function valueTypeCode() internal pure returns (uint8) {\\n        return VALUE_TYPE_COUNT;\\n    }\\n\\n    function hashOnlyTypeCode() internal pure returns (uint8) {\\n        return HASH_ONLY;\\n    }\\n\\n    function isValidTupleSize(uint256 size) internal pure returns (bool) {\\n        return size <= 8;\\n    }\\n\\n    function typeCodeVal(Data memory val) internal pure returns (Data memory) {\\n        if (val.typeCode == 2) {\\n            // Map HashPreImage to Tuple\\n            return newInt(TUPLE_TYPECODE);\\n        }\\n        return newInt(val.typeCode);\\n    }\\n\\n    function valLength(Data memory val) internal pure returns (uint8) {\\n        if (val.typeCode == TUPLE_TYPECODE) {\\n            return uint8(val.tupleVal.length);\\n        } else {\\n            return 1;\\n        }\\n    }\\n\\n    function isInt(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == INT_TYPECODE;\\n    }\\n\\n    function isInt64(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == INT_TYPECODE && val.intVal < (1 << 64);\\n    }\\n\\n    function isCodePoint(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == CODE_POINT_TYPECODE;\\n    }\\n\\n    function isTuple(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == TUPLE_TYPECODE;\\n    }\\n\\n    function isBuffer(Data memory val) internal pure returns (bool) {\\n        return val.typeCode == BUFFER_TYPECODE;\\n    }\\n\\n    function newEmptyTuple() internal pure returns (Data memory) {\\n        return newTuple(new Data[](0));\\n    }\\n\\n    function newBoolean(bool val) internal pure returns (Data memory) {\\n        if (val) {\\n            return newInt(1);\\n        } else {\\n            return newInt(0);\\n        }\\n    }\\n\\n    function newInt(uint256 _val) internal pure returns (Data memory) {\\n        return\\n            Data(_val, CodePoint(0, 0, new Data[](0)), new Data[](0), 0, INT_TYPECODE, uint256(1));\\n    }\\n\\n    function newHashedValue(bytes32 valueHash, uint256 valueSize)\\n        internal\\n        pure\\n        returns (Data memory)\\n    {\\n        return\\n            Data(\\n                uint256(valueHash),\\n                CodePoint(0, 0, new Data[](0)),\\n                new Data[](0),\\n                0,\\n                HASH_ONLY,\\n                valueSize\\n            );\\n    }\\n\\n    function newTuple(Data[] memory _val) internal pure returns (Data memory) {\\n        require(isValidTupleSize(_val.length), \\\"Tuple must have valid size\\\");\\n        uint256 size = 1;\\n\\n        for (uint256 i = 0; i < _val.length; i++) {\\n            size += _val[i].size;\\n        }\\n\\n        return Data(0, CodePoint(0, 0, new Data[](0)), _val, 0, TUPLE_TYPECODE, size);\\n    }\\n\\n    function newTuplePreImage(bytes32 preImageHash, uint256 size)\\n        internal\\n        pure\\n        returns (Data memory)\\n    {\\n        return\\n            Data(\\n                uint256(preImageHash),\\n                CodePoint(0, 0, new Data[](0)),\\n                new Data[](0),\\n                0,\\n                HASH_PRE_IMAGE_TYPECODE,\\n                size\\n            );\\n    }\\n\\n    function newCodePoint(uint8 opCode, bytes32 nextHash) internal pure returns (Data memory) {\\n        return newCodePoint(CodePoint(opCode, nextHash, new Data[](0)));\\n    }\\n\\n    function newCodePoint(\\n        uint8 opCode,\\n        bytes32 nextHash,\\n        Data memory immediate\\n    ) internal pure returns (Data memory) {\\n        Data[] memory imm = new Data[](1);\\n        imm[0] = immediate;\\n        return newCodePoint(CodePoint(opCode, nextHash, imm));\\n    }\\n\\n    function newCodePoint(CodePoint memory _val) private pure returns (Data memory) {\\n        return Data(0, _val, new Data[](0), 0, CODE_POINT_TYPECODE, uint256(1));\\n    }\\n\\n    function newBuffer(bytes32 bufHash) internal pure returns (Data memory) {\\n        return\\n            Data(\\n                uint256(0),\\n                CodePoint(0, 0, new Data[](0)),\\n                new Data[](0),\\n                bufHash,\\n                BUFFER_TYPECODE,\\n                uint256(1)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/Messages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nlibrary Messages {\\n    function messageHash(\\n        uint8 kind,\\n        address sender,\\n        uint256 blockNumber,\\n        uint256 timestamp,\\n        uint256 inboxSeqNum,\\n        uint256 gasPriceL1,\\n        bytes32 messageDataHash\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    kind,\\n                    sender,\\n                    blockNumber,\\n                    timestamp,\\n                    inboxSeqNum,\\n                    gasPriceL1,\\n                    messageDataHash\\n                )\\n            );\\n    }\\n\\n    function addMessageToInbox(bytes32 inbox, bytes32 message) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(inbox, message));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    );\\n\\n    function deliverMessageToInbox(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function executeCall(\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    // These are only callable by the admin\\n    function setInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    // View functions\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function messageCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/interfaces/ISequencerInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\ninterface ISequencerInbox {\\n    event SequencerBatchDelivered(\\n        uint256 indexed firstMessageNum,\\n        bytes32 indexed beforeAcc,\\n        uint256 newMessageCount,\\n        bytes32 afterAcc,\\n        bytes transactions,\\n        uint256[] lengths,\\n        uint256[] sectionsMetadata,\\n        uint256 seqBatchIndex,\\n        address sequencer\\n    );\\n\\n    event SequencerBatchDeliveredFromOrigin(\\n        uint256 indexed firstMessageNum,\\n        bytes32 indexed beforeAcc,\\n        uint256 newMessageCount,\\n        bytes32 afterAcc,\\n        uint256 seqBatchIndex\\n    );\\n\\n    event DelayedInboxForced(\\n        uint256 indexed firstMessageNum,\\n        bytes32 indexed beforeAcc,\\n        uint256 newMessageCount,\\n        uint256 totalDelayedMessagesRead,\\n        bytes32[2] afterAccAndDelayed,\\n        uint256 seqBatchIndex\\n    );\\n\\n    event SequencerAddressUpdated(address newAddress);\\n\\n    function setSequencer(address newSequencer) external;\\n\\n    function messageCount() external view returns (uint256);\\n\\n    function maxDelayBlocks() external view returns (uint256);\\n\\n    function maxDelaySeconds() external view returns (uint256);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function proveBatchContainsSequenceNumber(bytes calldata proof, uint256 inboxCount)\\n        external\\n        view\\n        returns (uint256, bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\n\\npragma solidity ^0.6.11;\\n\\n/* solhint-disable no-inline-assembly */\\nlibrary BytesLib {\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= (_start + 20), \\\"Read out of bounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1), \\\"Read out of bounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32), \\\"Read out of bounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32), \\\"Read out of bounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n}\\n/* solhint-enable no-inline-assembly */\\n\"\r\n    },\r\n    \"contracts/libraries/DebugPrint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.6.11;\\n\\nlibrary DebugPrint {\\n    function char(bytes1 b) private pure returns (bytes1 c) {\\n        if (uint8(b) < 10) {\\n            return bytes1(uint8(b) + 0x30);\\n        } else {\\n            return bytes1(uint8(b) + 0x57);\\n        }\\n    }\\n\\n    function bytes32string(bytes32 b32) internal pure returns (string memory out) {\\n        bytes memory s = new bytes(64);\\n\\n        for (uint256 i = 0; i < 32; i++) {\\n            bytes1 b = bytes1(b32[i]);\\n            bytes1 hi = bytes1(uint8(b) / 16);\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n            s[i * 2] = char(hi);\\n            s[i * 2 + 1] = char(lo);\\n        }\\n\\n        out = string(s);\\n    }\\n\\n    // Taken from https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\\n    function uint2str(uint256 _iParam) internal pure returns (string memory _uintAsString) {\\n        uint256 _i = _iParam;\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"bridges\",\"type\":\"address[2]\"},{\"internalType\":\"uint256\",\"name\":\"initialMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[2]\",\"name\":\"accs\",\"type\":\"bytes32[2]\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"bproof\",\"type\":\"bytes\"}],\"name\":\"executeStep\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"gas\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"afterMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[4]\",\"name\":\"fields\",\"type\":\"bytes32[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"bridges\",\"type\":\"address[2]\"},{\"internalType\":\"uint256\",\"name\":\"initialMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[2]\",\"name\":\"accs\",\"type\":\"bytes32[2]\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"bproof\",\"type\":\"bytes\"}],\"name\":\"executeStepDebug\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"startMachine\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"afterMachine\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OneStepProof","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}