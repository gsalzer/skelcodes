{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/bancor/BancorFormula.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract BancorFormula {\\n    using SafeMath for uint256;\\n\\n    uint16 public constant version = 6;\\n\\n    uint256 private constant ONE = 1;\\n    uint32 private constant MAX_RATIO = 1000000;\\n    uint8 private constant MIN_PRECISION = 32;\\n    uint8 private constant MAX_PRECISION = 127;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintIntScalingFactors.py'\\n     */\\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintLn2ScalingFactors.py'\\n     */\\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\\n     */\\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintFunctionConstructor.py'\\n     */\\n    uint256[128] private maxExpArray;\\n\\n    constructor() {\\n        //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\\n        //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\\n        //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\\n        //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\\n        //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\\n        //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\\n        //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\\n        //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\\n        //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\\n        //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\\n    }\\n\\n    /**\\n     * @dev given a token supply, reserve balance, ratio and a deposit amount (in the reserve token),\\n     * calculates the return for a given conversion (in the main token)\\n     *\\n     * Formula:\\n     * Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 1000000) - 1)\\n     *\\n     * @param _supply              token total supply\\n     * @param _reserveBalance      total reserve balance\\n     * @param _reserveRatio        reserve ratio, represented in ppm, 1-1000000\\n     * @param _depositAmount       deposit amount, in reserve token\\n     *\\n     * @return purchase return amount\\n     */\\n    function calculatePurchaseReturn(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _depositAmount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 && _reserveBalance > 0 && _reserveRatio > 0 && _reserveRatio <= MAX_RATIO,\\n            \\\"invalid parameters\\\"\\n        );\\n\\n        // special case for 0 deposit amount\\n        if (_depositAmount == 0) return 0;\\n\\n        // special case if the ratio = 100%\\n        if (_reserveRatio == MAX_RATIO) return _supply.mul(_depositAmount) / _reserveBalance;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseN = _depositAmount.add(_reserveBalance);\\n        (result, precision) = power(baseN, _reserveBalance, _reserveRatio, MAX_RATIO);\\n        uint256 temp = _supply.mul(result) >> precision;\\n        return temp - _supply;\\n    }\\n\\n    /**\\n     * @dev given a token supply, reserve balance, ratio and a sell amount (in the main token),\\n     * calculates the return for a given conversion (in the reserve token)\\n     *\\n     * Formula:\\n     * Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1000000 / _reserveRatio))\\n     *\\n     * @param _supply              token total supply\\n     * @param _reserveBalance      total reserve\\n     * @param _reserveRatio        constant reserve Ratio, represented in ppm, 1-1000000\\n     * @param _sellAmount          sell amount, in the token itself\\n     *\\n     * @return sale return amount\\n     */\\n    function calculateSaleReturn(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _sellAmount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 &&\\n                _reserveBalance > 0 &&\\n                _reserveRatio > 0 &&\\n                _reserveRatio <= MAX_RATIO &&\\n                _sellAmount <= _supply,\\n            \\\"invalid parameters\\\"\\n        );\\n\\n        // special case for 0 sell amount\\n        if (_sellAmount == 0) return 0;\\n\\n        // special case for selling the entire supply\\n        if (_sellAmount == _supply) return _reserveBalance;\\n\\n        // special case if the ratio = 100%\\n        if (_reserveRatio == MAX_RATIO) return _reserveBalance.mul(_sellAmount) / _supply;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseD = _supply - _sellAmount;\\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _reserveRatio);\\n        uint256 temp1 = _reserveBalance.mul(result);\\n        uint256 temp2 = _reserveBalance << precision;\\n        return (temp1 - temp2) / result;\\n    }\\n\\n    /**\\n     * @dev given two reserve balances/ratios and a sell amount (in the first reserve token),\\n     * calculates the return for a conversion from the first reserve token to the second reserve token (in the second reserve token)\\n     * note that prior to version 4, you should use 'calculateCrossConnectorReturn' instead\\n     *\\n     * Formula:\\n     * Return = _toReserveBalance * (1 - (_fromReserveBalance / (_fromReserveBalance + _amount)) ^ (_fromReserveRatio / _toReserveRatio))\\n     *\\n     * @param _fromReserveBalance      input reserve balance\\n     * @param _fromReserveRatio        input reserve ratio, represented in ppm, 1-1000000\\n     * @param _toReserveBalance        output reserve balance\\n     * @param _toReserveRatio          output reserve ratio, represented in ppm, 1-1000000\\n     * @param _amount                  input reserve amount\\n     *\\n     * @return second reserve amount\\n     */\\n    function calculateCrossReserveReturn(\\n        uint256 _fromReserveBalance,\\n        uint32 _fromReserveRatio,\\n        uint256 _toReserveBalance,\\n        uint32 _toReserveRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _fromReserveBalance > 0 &&\\n                _fromReserveRatio > 0 &&\\n                _fromReserveRatio <= MAX_RATIO &&\\n                _toReserveBalance > 0 &&\\n                _toReserveRatio > 0 &&\\n                _toReserveRatio <= MAX_RATIO\\n        );\\n\\n        // special case for equal ratios\\n        if (_fromReserveRatio == _toReserveRatio)\\n            return _toReserveBalance.mul(_amount) / _fromReserveBalance.add(_amount);\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseN = _fromReserveBalance.add(_amount);\\n        (result, precision) = power(baseN, _fromReserveBalance, _fromReserveRatio, _toReserveRatio);\\n        uint256 temp1 = _toReserveBalance.mul(result);\\n        uint256 temp2 = _toReserveBalance << precision;\\n        return (temp1 - temp2) / result;\\n    }\\n\\n    /**\\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of requested smart tokens,\\n     * calculates the amount of reserve tokens required for purchasing the given amount of smart tokens\\n     *\\n     * Formula:\\n     * Return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_RATIO / _totalRatio) - 1)\\n     *\\n     * @param _supply              smart token supply\\n     * @param _reserveBalance      reserve token balance\\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\\n     * @param _amount              requested amount of smart tokens\\n     *\\n     * @return amount of reserve tokens\\n     */\\n    function calculateFundCost(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _totalRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 && _reserveBalance > 0 && _totalRatio > 1 && _totalRatio <= MAX_RATIO * 2\\n        );\\n\\n        // special case for 0 amount\\n        if (_amount == 0) return 0;\\n\\n        // special case if the total ratio = 100%\\n        if (_totalRatio == MAX_RATIO) return (_amount.mul(_reserveBalance) - 1) / _supply + 1;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseN = _supply.add(_amount);\\n        (result, precision) = power(baseN, _supply, MAX_RATIO, _totalRatio);\\n        uint256 temp = ((_reserveBalance.mul(result) - 1) >> precision) + 1;\\n        return temp - _reserveBalance;\\n    }\\n\\n    /**\\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of smart tokens to liquidate,\\n     * calculates the amount of reserve tokens received for selling the given amount of smart tokens\\n     *\\n     * Formula:\\n     * Return = _reserveBalance * (1 - ((_supply - _amount) / _supply) ^ (MAX_RATIO / _totalRatio))\\n     *\\n     * @param _supply              smart token supply\\n     * @param _reserveBalance      reserve token balance\\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\\n     * @param _amount              amount of smart tokens to liquidate\\n     *\\n     * @return amount of reserve tokens\\n     */\\n    function calculateLiquidateReturn(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _totalRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 &&\\n                _reserveBalance > 0 &&\\n                _totalRatio > 1 &&\\n                _totalRatio <= MAX_RATIO * 2 &&\\n                _amount <= _supply\\n        );\\n\\n        // special case for 0 amount\\n        if (_amount == 0) return 0;\\n\\n        // special case for liquidating the entire supply\\n        if (_amount == _supply) return _reserveBalance;\\n\\n        // special case if the total ratio = 100%\\n        if (_totalRatio == MAX_RATIO) return _amount.mul(_reserveBalance) / _supply;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseD = _supply - _amount;\\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _totalRatio);\\n        uint256 temp1 = _reserveBalance.mul(result);\\n        uint256 temp2 = _reserveBalance << precision;\\n        return (temp1 - temp2) / result;\\n    }\\n\\n    /**\\n     * @dev General Description:\\n     *     Determine a value of precision.\\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\\n     *     Return the result along with the precision used.\\n     *\\n     * Detailed Description:\\n     *     Instead of calculating \\\"base ^ exp\\\", we calculate \\\"e ^ (log(base) * exp)\\\".\\n     *     The value of \\\"log(base)\\\" is represented with an integer slightly smaller than \\\"log(base) * 2 ^ precision\\\".\\n     *     The larger \\\"precision\\\" is, the more accurately this value represents the real value.\\n     *     However, the larger \\\"precision\\\" is, the more bits are required in order to store this value.\\n     *     And the exponentiation function, which takes \\\"x\\\" and calculates \\\"e ^ x\\\", is limited to a maximum exponent (maximum value of \\\"x\\\").\\n     *     This maximum exponent depends on the \\\"precision\\\" used, and it is given by \\\"maxExpArray[precision] >> (MAX_PRECISION - precision)\\\".\\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\\n     *     This allows us to compute \\\"base ^ exp\\\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\\n     *     This functions assumes that \\\"_expN < 2 ^ 256 / log(MAX_NUM - 1)\\\", otherwise the multiplication should be replaced with a \\\"safeMul\\\".\\n     *     Since we rely on unsigned-integer arithmetic and \\\"base < 1\\\" ==> \\\"log(base) < 0\\\", this function does not support \\\"_baseN < _baseD\\\".\\n     */\\n    function power(\\n        uint256 _baseN,\\n        uint256 _baseD,\\n        uint32 _expN,\\n        uint32 _expD\\n    ) internal view returns (uint256, uint8) {\\n        require(_baseN < MAX_NUM);\\n\\n        uint256 baseLog;\\n        uint256 base = (_baseN * FIXED_1) / _baseD;\\n        if (base < OPT_LOG_MAX_VAL) {\\n            baseLog = optimalLog(base);\\n        } else {\\n            baseLog = generalLog(base);\\n        }\\n\\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\\n        } else {\\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\\n            return (\\n                generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision),\\n                precision\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev computes log(x / FIXED_1) * FIXED_1.\\n     * This functions assumes that \\\"x >= FIXED_1\\\", because the output would be negative otherwise.\\n     */\\n    function generalLog(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\\n        if (x >= FIXED_2) {\\n            uint8 count = floorLog2(x / FIXED_1);\\n            x >>= count; // now x < 2\\n            res = count * FIXED_1;\\n        }\\n\\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\\n        if (x > FIXED_1) {\\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\\n                x = (x * x) / FIXED_1; // now 1 < x < 4\\n                if (x >= FIXED_2) {\\n                    x >>= 1; // now 1 < x < 2\\n                    res += ONE << (i - 1);\\n                }\\n            }\\n        }\\n\\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\\n    }\\n\\n    /**\\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\\n     */\\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\\n        uint8 res = 0;\\n\\n        if (_n < 256) {\\n            // At most 8 iterations\\n            while (_n > 1) {\\n                _n >>= 1;\\n                res += 1;\\n            }\\n        } else {\\n            // Exactly 8 iterations\\n            for (uint8 s = 128; s > 0; s >>= 1) {\\n                if (_n >= (ONE << s)) {\\n                    _n >>= s;\\n                    res |= s;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @dev the global \\\"maxExpArray\\\" is sorted in descending order, and therefore the following statements are equivalent:\\n     * - This function finds the position of [the smallest value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\n     * - This function finds the highest position of [a value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\n     */\\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\\n        uint8 lo = MIN_PRECISION;\\n        uint8 hi = MAX_PRECISION;\\n\\n        while (lo + 1 < hi) {\\n            uint8 mid = (lo + hi) / 2;\\n            if (maxExpArray[mid] >= _x) lo = mid;\\n            else hi = mid;\\n        }\\n\\n        if (maxExpArray[hi] >= _x) return hi;\\n        if (maxExpArray[lo] >= _x) return lo;\\n\\n        require(false);\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\\n     * it approximates \\\"e ^ x\\\" via maclaurin summation: \\\"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\\\".\\n     * it returns \\\"e ^ (x / 2 ^ precision) * 2 ^ precision\\\", that is, the result is upshifted for accuracy.\\n     * the global \\\"maxExpArray\\\" maps each \\\"precision\\\" to \\\"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\\\".\\n     * the maximum permitted value for \\\"x\\\" is therefore given by \\\"maxExpArray[precision] >> (MAX_PRECISION - precision)\\\".\\n     */\\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\\n        uint256 xi = _x;\\n        uint256 res = 0;\\n\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\\n\\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\\n    }\\n\\n    /**\\n     * @dev computes log(x / FIXED_1) * FIXED_1\\n     * Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\\n     * Auto-generated via 'PrintFunctionOptimalLog.py'\\n     * Detailed description:\\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\\n     */\\n    function optimalLog(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        uint256 y;\\n        uint256 z;\\n        uint256 w;\\n\\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\\n            res += 0x40000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\\n        } // add 1 / 2^1\\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\\n            res += 0x20000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\\n        } // add 1 / 2^2\\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\\n            res += 0x10000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\\n        } // add 1 / 2^3\\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\\n            res += 0x08000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\\n        } // add 1 / 2^4\\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\\n            res += 0x04000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\\n        } // add 1 / 2^5\\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\\n            res += 0x02000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\\n        } // add 1 / 2^6\\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\\n            res += 0x01000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\\n        } // add 1 / 2^7\\n        if (x >= 0x808040155aabbbe9451521693554f733) {\\n            res += 0x00800000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\\n        } // add 1 / 2^8\\n\\n        z = y = x - FIXED_1;\\n        w = (y * y) / FIXED_1;\\n        res +=\\n            (z * (0x100000000000000000000000000000000 - y)) /\\n            0x100000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\\n        res +=\\n            (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\\n            0x200000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\\n        res +=\\n            (z * (0x099999999999999999999999999999999 - y)) /\\n            0x300000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\\n        res +=\\n            (z * (0x092492492492492492492492492492492 - y)) /\\n            0x400000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\\n        res +=\\n            (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\\n            0x500000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\\n        res +=\\n            (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\\n            0x600000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\\n        res +=\\n            (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\\n            0x700000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\\n        res +=\\n            (z * (0x088888888888888888888888888888888 - y)) /\\n            0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\\n     * auto-generated via 'PrintFunctionOptimalExp.py'\\n     * Detailed description:\\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\\n     * - The exponentiation of each binary exponent is given (pre-calculated)\\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\\n     */\\n    function optimalExp(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        uint256 y;\\n        uint256 z;\\n\\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\\n\\n        if ((x & 0x010000000000000000000000000000000) != 0)\\n            res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\\n        if ((x & 0x020000000000000000000000000000000) != 0)\\n            res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\\n        if ((x & 0x040000000000000000000000000000000) != 0)\\n            res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\\n        if ((x & 0x080000000000000000000000000000000) != 0)\\n            res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\\n        if ((x & 0x100000000000000000000000000000000) != 0)\\n            res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\\n        if ((x & 0x200000000000000000000000000000000) != 0)\\n            res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\\n        if ((x & 0x400000000000000000000000000000000) != 0)\\n            res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @dev deprecated, backward compatibility\\n     */\\n    function calculateCrossConnectorReturn(\\n        uint256 _fromConnectorBalance,\\n        uint32 _fromConnectorWeight,\\n        uint256 _toConnectorBalance,\\n        uint32 _toConnectorWeight,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        return\\n            calculateCrossReserveReturn(\\n                _fromConnectorBalance,\\n                _fromConnectorWeight,\\n                _toConnectorBalance,\\n                _toConnectorWeight,\\n                _amount\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/GNS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../bancor/BancorFormula.sol\\\";\\nimport \\\"../upgrades/GraphUpgradeable.sol\\\";\\n\\nimport \\\"./IGNS.sol\\\";\\nimport \\\"./GNSStorage.sol\\\";\\n\\n/**\\n * @title GNS\\n * @dev The Graph Name System contract provides a decentralized naming system for subgraphs\\n * used in the scope of the Graph Network. It translates subgraph names into subgraph versions.\\n * Each version is associated with a Subgraph Deployment. The contract has no knowledge of\\n * human-readable names. All human readable names emitted in events.\\n */\\ncontract GNS is GNSV1Storage, GraphUpgradeable, IGNS {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\\n\\n    // 100% in parts per million\\n    uint32 private constant MAX_PPM = 1000000;\\n\\n    // Equates to Connector weight on bancor formula to be CW = 1\\n    uint32 private constant defaultReserveRatio = 1000000;\\n\\n    // -- Events --\\n\\n    /**\\n     * @dev Emitted when graph account sets its default name\\n     */\\n    event SetDefaultName(\\n        address indexed graphAccount,\\n        uint256 nameSystem, // only ENS for now\\n        bytes32 nameIdentifier,\\n        string name\\n    );\\n\\n    /**\\n     * @dev Emitted when graph account sets a subgraphs metadata on IPFS\\n     */\\n    event SubgraphMetadataUpdated(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        bytes32 subgraphMetadata\\n    );\\n\\n    /**\\n     * @dev Emitted when a `graph account` publishes a `subgraph` with a `version`.\\n     * Every time this event is emitted, indicates a new version has been created.\\n     * The event also emits a `metadataHash` with subgraph details and version details.\\n     */\\n    event SubgraphPublished(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        bytes32 indexed subgraphDeploymentID,\\n        bytes32 versionMetadata\\n    );\\n\\n    /**\\n     * @dev Emitted when a graph account deprecated one of its subgraphs\\n     */\\n    event SubgraphDeprecated(address indexed graphAccount, uint256 indexed subgraphNumber);\\n\\n    /**\\n     * @dev Emitted when a graphAccount creates an nSignal bonding curve that\\n     * points to a subgraph deployment\\n     */\\n    event NameSignalEnabled(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        bytes32 indexed subgraphDeploymentID,\\n        uint32 reserveRatio\\n    );\\n\\n    /**\\n     * @dev Emitted when a name curator deposits its vSignal into an nSignal curve to mint nSignal\\n     */\\n    event NSignalMinted(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        address indexed nameCurator,\\n        uint256 nSignalCreated,\\n        uint256 vSignalCreated,\\n        uint256 tokensDeposited\\n    );\\n\\n    /**\\n     * @dev Emitted when a name curator burns its nSignal, which in turn burns\\n     * the vSignal, and receives GRT\\n     */\\n    event NSignalBurned(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        address indexed nameCurator,\\n        uint256 nSignalBurnt,\\n        uint256 vSignalBurnt,\\n        uint256 tokensReceived\\n    );\\n\\n    /**\\n     * @dev Emitted when a graph account upgrades its nSignal curve to point to a new\\n     * subgraph deployment, burning all the old vSignal and depositing the GRT into the\\n     * new vSignal curve, creating new nSignal\\n     */\\n    event NameSignalUpgrade(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        uint256 newVSignalCreated,\\n        uint256 tokensSignalled,\\n        bytes32 indexed subgraphDeploymentID\\n    );\\n\\n    /**\\n     * @dev Emitted when an nSignal curve has been permanently disabled\\n     */\\n    event NameSignalDisabled(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        uint256 withdrawableGRT\\n    );\\n\\n    /**\\n     * @dev Emitted when a nameCurator withdraws its GRT from a deprecated name signal pool\\n     */\\n    event GRTWithdrawn(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        address indexed nameCurator,\\n        uint256 nSignalBurnt,\\n        uint256 withdrawnGRT\\n    );\\n\\n    /**\\n    @dev Modifier that allows a function to be called by owner of a graph account\\n    @param _graphAccount Address of the graph account\\n    */\\n    modifier onlyGraphAccountOwner(address _graphAccount) {\\n        address graphAccountOwner = erc1056Registry.identityOwner(_graphAccount);\\n        require(graphAccountOwner == msg.sender, \\\"GNS: Only graph account owner can call\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize this contract.\\n     */\\n    function initialize(\\n        address _controller,\\n        address _bondingCurve,\\n        address _didRegistry\\n    ) external onlyImpl {\\n        Managed._initialize(_controller);\\n\\n        bondingCurve = _bondingCurve;\\n        erc1056Registry = IEthereumDIDRegistry(_didRegistry);\\n\\n        // Settings\\n        _setOwnerTaxPercentage(500000);\\n    }\\n\\n    /**\\n     * @dev Approve curation contract to pull funds.\\n     */\\n    function approveAll() external override {\\n        graphToken().approve(address(curation()), MAX_UINT256);\\n    }\\n\\n    /**\\n     * @dev Set the owner fee percentage. This is used to prevent a subgraph owner to drain all\\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per hundred.\\n     * @param _ownerTaxPercentage Owner tax percentage\\n     */\\n    function setOwnerTaxPercentage(uint32 _ownerTaxPercentage) external override onlyGovernor {\\n        _setOwnerTaxPercentage(_ownerTaxPercentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the owner tax percentage. This is used to prevent a subgraph owner to drain all\\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per hundred.\\n     * @param _ownerTaxPercentage Owner tax percentage\\n     */\\n    function _setOwnerTaxPercentage(uint32 _ownerTaxPercentage) private {\\n        require(_ownerTaxPercentage <= MAX_PPM, \\\"Owner tax must be MAX_PPM or less\\\");\\n        ownerTaxPercentage = _ownerTaxPercentage;\\n        emit ParameterUpdated(\\\"ownerTaxPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Allows a graph account to set a default name\\n     * @param _graphAccount Account that is setting its name\\n     * @param _nameSystem Name system account already has ownership of a name in\\n     * @param _nameIdentifier The unique identifier that is used to identify the name in the system\\n     * @param _name The name being set as default\\n     */\\n    function setDefaultName(\\n        address _graphAccount,\\n        uint8 _nameSystem,\\n        bytes32 _nameIdentifier,\\n        string calldata _name\\n    ) external override onlyGraphAccountOwner(_graphAccount) {\\n        emit SetDefaultName(_graphAccount, _nameSystem, _nameIdentifier, _name);\\n    }\\n\\n    /**\\n     * @dev Allows a graph account update the metadata of a subgraph they have published\\n     * @param _graphAccount Account that owns the subgraph\\n     * @param _subgraphNumber Subgraph number\\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\\n     */\\n    function updateSubgraphMetadata(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphMetadata\\n    ) public override onlyGraphAccountOwner(_graphAccount) {\\n        emit SubgraphMetadataUpdated(_graphAccount, _subgraphNumber, _subgraphMetadata);\\n    }\\n\\n    /**\\n     * @dev Allows a graph account to publish a new subgraph, which means a new subgraph number\\n     * will be used.\\n     * @param _graphAccount Account that is publishing the subgraph\\n     * @param _subgraphDeploymentID Subgraph deployment ID of the version, linked to the name\\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\\n     */\\n    function publishNewSubgraph(\\n        address _graphAccount,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata,\\n        bytes32 _subgraphMetadata\\n    ) external override notPaused onlyGraphAccountOwner(_graphAccount) {\\n        uint256 subgraphNumber = graphAccountSubgraphNumbers[_graphAccount];\\n        _publishVersion(_graphAccount, subgraphNumber, _subgraphDeploymentID, _versionMetadata);\\n        graphAccountSubgraphNumbers[_graphAccount] = graphAccountSubgraphNumbers[_graphAccount].add(\\n            1\\n        );\\n        updateSubgraphMetadata(_graphAccount, subgraphNumber, _subgraphMetadata);\\n        _enableNameSignal(_graphAccount, subgraphNumber);\\n    }\\n\\n    /**\\n     * @dev Allows a graph account to publish a new version of its subgraph.\\n     * Version is derived from the occurrence of SubgraphPublished being emitted.\\n     * The first time SubgraphPublished is called would be Version 0\\n     * @param _graphAccount Account that is publishing the subgraph\\n     * @param _subgraphNumber Subgraph number for the account\\n     * @param _subgraphDeploymentID Subgraph deployment ID of the version, linked to the name\\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\\n     */\\n    function publishNewVersion(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata\\n    ) external override notPaused onlyGraphAccountOwner(_graphAccount) {\\n        require(\\n            isPublished(_graphAccount, _subgraphNumber),\\n            \\\"GNS: Cannot update version if not published, or has been deprecated\\\"\\n        );\\n        bytes32 oldSubgraphDeploymentID = subgraphs[_graphAccount][_subgraphNumber];\\n        require(\\n            _subgraphDeploymentID != oldSubgraphDeploymentID,\\n            \\\"GNS: Cannot publish a new version with the same subgraph deployment ID\\\"\\n        );\\n\\n        _publishVersion(_graphAccount, _subgraphNumber, _subgraphDeploymentID, _versionMetadata);\\n        _upgradeNameSignal(_graphAccount, _subgraphNumber, _subgraphDeploymentID);\\n    }\\n\\n    /**\\n     * @dev Private function used by both external publishing functions\\n     * @param _graphAccount Account that is publishing the subgraph\\n     * @param _subgraphNumber Subgraph number for the account\\n     * @param _subgraphDeploymentID Subgraph deployment ID of the version, linked to the name\\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\\n     */\\n    function _publishVersion(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata\\n    ) private {\\n        require(_subgraphDeploymentID != 0, \\\"GNS: Cannot set deploymentID to 0 in publish\\\");\\n\\n        // Stores a subgraph deployment ID, which indicates a version has been created\\n        subgraphs[_graphAccount][_subgraphNumber] = _subgraphDeploymentID;\\n\\n        // Emit version and name data\\n        emit SubgraphPublished(\\n            _graphAccount,\\n            _subgraphNumber,\\n            _subgraphDeploymentID,\\n            _versionMetadata\\n        );\\n    }\\n\\n    /**\\n     * @dev Deprecate a subgraph. Can only be done by the graph account owner.\\n     * @param _graphAccount Account that is deprecating the subgraph\\n     * @param _subgraphNumber Subgraph number for the account\\n     */\\n    function deprecateSubgraph(address _graphAccount, uint256 _subgraphNumber)\\n        external\\n        override\\n        notPaused\\n        onlyGraphAccountOwner(_graphAccount)\\n    {\\n        require(\\n            isPublished(_graphAccount, _subgraphNumber),\\n            \\\"GNS: Cannot deprecate a subgraph which does not exist\\\"\\n        );\\n\\n        delete subgraphs[_graphAccount][_subgraphNumber];\\n        emit SubgraphDeprecated(_graphAccount, _subgraphNumber);\\n\\n        _disableNameSignal(_graphAccount, _subgraphNumber);\\n    }\\n\\n    /**\\n     * @dev Enable name signal on a graph accounts numbered subgraph, which points to a subgraph\\n     * deployment\\n     * @param _graphAccount Graph account enabling name signal\\n     * @param _subgraphNumber Subgraph number being used\\n     */\\n    function _enableNameSignal(address _graphAccount, uint256 _subgraphNumber) private {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        namePool.subgraphDeploymentID = subgraphs[_graphAccount][_subgraphNumber];\\n        namePool.reserveRatio = defaultReserveRatio;\\n\\n        emit NameSignalEnabled(\\n            _graphAccount,\\n            _subgraphNumber,\\n            namePool.subgraphDeploymentID,\\n            namePool.reserveRatio\\n        );\\n    }\\n\\n    /**\\n     * @dev Update a name signal on a graph accounts numbered subgraph\\n     * @param _graphAccount Graph account updating name signal\\n     * @param _subgraphNumber Subgraph number being used\\n     * @param _newSubgraphDeploymentID Deployment ID being upgraded to\\n     */\\n    function _upgradeNameSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _newSubgraphDeploymentID\\n    ) private {\\n        // This is to prevent the owner from front running its name curators signal by posting\\n        // its own signal ahead, bringing the name curators in, and dumping on them\\n        ICuration curation = curation();\\n        require(\\n            !curation.isCurated(_newSubgraphDeploymentID),\\n            \\\"GNS: Owner cannot point to a subgraphID that has been pre-curated\\\"\\n        );\\n\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        require(\\n            namePool.nSignal > 0,\\n            \\\"GNS: There must be nSignal on this subgraph for curve math to work\\\"\\n        );\\n        require(namePool.disabled == false, \\\"GNS: Cannot be disabled\\\");\\n\\n        // Burn all version signal in the name pool for tokens\\n        uint256 tokens = curation.burn(namePool.subgraphDeploymentID, namePool.vSignal, 0);\\n\\n        // Take the owner cut of the curation tax, add it to the total\\n        uint32 curationTaxPercentage = curation.curationTaxPercentage();\\n        uint256 tokensWithTax = _chargeOwnerTax(tokens, _graphAccount, curationTaxPercentage);\\n\\n        // Update pool: constant nSignal, vSignal can change\\n        namePool.subgraphDeploymentID = _newSubgraphDeploymentID;\\n        (namePool.vSignal, ) = curation.mint(namePool.subgraphDeploymentID, tokensWithTax, 0);\\n\\n        emit NameSignalUpgrade(\\n            _graphAccount,\\n            _subgraphNumber,\\n            namePool.vSignal,\\n            tokensWithTax,\\n            _newSubgraphDeploymentID\\n        );\\n    }\\n\\n    /**\\n     * @dev Allow a name curator to mint some nSignal by depositing GRT\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number\\n     * @param _tokensIn The amount of tokens the nameCurator wants to deposit\\n     * @param _nSignalOutMin Expected minimum amount of name signal to receive\\n     */\\n    function mintNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _tokensIn,\\n        uint256 _nSignalOutMin\\n    ) external override notPartialPaused {\\n        // Pool checks\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        require(namePool.disabled == false, \\\"GNS: Cannot be disabled\\\");\\n        require(\\n            namePool.subgraphDeploymentID != 0,\\n            \\\"GNS: Must deposit on a name signal that exists\\\"\\n        );\\n\\n        // Pull tokens from sender\\n        require(\\n            graphToken().transferFrom(msg.sender, address(this), _tokensIn),\\n            \\\"GNS: Cannot transfer tokens to mint n signal\\\"\\n        );\\n\\n        // Get name signal to mint for tokens deposited\\n        (uint256 vSignal, ) = curation().mint(namePool.subgraphDeploymentID, _tokensIn, 0);\\n        uint256 nSignal = vSignalToNSignal(_graphAccount, _subgraphNumber, vSignal);\\n\\n        // Slippage protection\\n        require(nSignal >= _nSignalOutMin, \\\"GNS: Slippage protection\\\");\\n\\n        // Update pools\\n        namePool.vSignal = namePool.vSignal.add(vSignal);\\n        namePool.nSignal = namePool.nSignal.add(nSignal);\\n        namePool.curatorNSignal[msg.sender] = namePool.curatorNSignal[msg.sender].add(nSignal);\\n\\n        emit NSignalMinted(_graphAccount, _subgraphNumber, msg.sender, nSignal, vSignal, _tokensIn);\\n    }\\n\\n    /**\\n     * @dev Allow a nameCurator to burn some of its nSignal and get GRT in return\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _nSignal The amount of nSignal the nameCurator wants to burn\\n     * @param _tokensOutMin Expected minimum amount of tokens to receive\\n     */\\n    function burnNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignal,\\n        uint256 _tokensOutMin\\n    ) external override notPartialPaused {\\n        // Pool checks\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        require(namePool.disabled == false, \\\"GNS: Cannot be disabled\\\");\\n\\n        // Curator balance checks\\n        uint256 curatorNSignal = namePool.curatorNSignal[msg.sender];\\n        require(\\n            _nSignal <= curatorNSignal,\\n            \\\"GNS: Curator cannot withdraw more nSignal than they have\\\"\\n        );\\n\\n        // Get tokens for name signal amount to burn\\n        uint256 vSignal = nSignalToVSignal(_graphAccount, _subgraphNumber, _nSignal);\\n        uint256 tokens = curation().burn(namePool.subgraphDeploymentID, vSignal, _tokensOutMin);\\n\\n        // Update pools\\n        namePool.vSignal = namePool.vSignal.sub(vSignal);\\n        namePool.nSignal = namePool.nSignal.sub(_nSignal);\\n        namePool.curatorNSignal[msg.sender] = namePool.curatorNSignal[msg.sender].sub(_nSignal);\\n\\n        // Return the tokens to the nameCurator\\n        require(\\n            graphToken().transfer(msg.sender, tokens),\\n            \\\"GNS: Error sending nameCurators tokens\\\"\\n        );\\n\\n        emit NSignalBurned(_graphAccount, _subgraphNumber, msg.sender, _nSignal, vSignal, tokens);\\n    }\\n\\n    /**\\n     * @dev Owner disables the subgraph. This means the subgraph-number combination can no longer\\n     * be used for name signal. The nSignal curve is destroyed, the vSignal is burned, and the GNS\\n     * contract holds the GRT from burning the vSignal, which all curators can withdraw manually.\\n     * @param _graphAccount Account that is deprecating its name curation\\n     * @param _subgraphNumber Subgraph number\\n     */\\n    function _disableNameSignal(address _graphAccount, uint256 _subgraphNumber) private {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n\\n        // If no nSignal, then no need to burn vSignal\\n        if (namePool.nSignal != 0) {\\n            namePool.withdrawableGRT = curation().burn(\\n                namePool.subgraphDeploymentID,\\n                namePool.vSignal,\\n                0\\n            );\\n            namePool.vSignal = 0;\\n        }\\n\\n        // Set the NameCurationPool fields to make it disabled\\n        namePool.disabled = true;\\n\\n        emit NameSignalDisabled(_graphAccount, _subgraphNumber, namePool.withdrawableGRT);\\n    }\\n\\n    /**\\n     * @dev When the subgraph curve is disabled, all nameCurators can call this function and\\n     * withdraw the GRT they are entitled for its original deposit of vSignal\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     */\\n    function withdraw(address _graphAccount, uint256 _subgraphNumber)\\n        external\\n        override\\n        notPartialPaused\\n    {\\n        // Pool checks\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        require(namePool.disabled == true, \\\"GNS: Name bonding curve must be disabled first\\\");\\n        require(namePool.withdrawableGRT > 0, \\\"GNS: No more GRT to withdraw\\\");\\n\\n        // Curator balance checks\\n        uint256 curatorNSignal = namePool.curatorNSignal[msg.sender];\\n        require(curatorNSignal > 0, \\\"GNS: Curator must have some nSignal to withdraw GRT\\\");\\n\\n        // Get curator share of tokens to be withdrawn\\n        uint256 tokensOut = curatorNSignal.mul(namePool.withdrawableGRT).div(namePool.nSignal);\\n        namePool.curatorNSignal[msg.sender] = 0;\\n        namePool.nSignal = namePool.nSignal.sub(curatorNSignal);\\n        namePool.withdrawableGRT = namePool.withdrawableGRT.sub(tokensOut);\\n\\n        require(\\n            graphToken().transfer(msg.sender, tokensOut),\\n            \\\"GNS: Error withdrawing tokens for nameCurator\\\"\\n        );\\n\\n        emit GRTWithdrawn(_graphAccount, _subgraphNumber, msg.sender, curatorNSignal, tokensOut);\\n    }\\n\\n    /**\\n     * @dev Calculate tax that owner will have to cover for upgrading or deprecating.\\n     * @param _tokens Tokens that were received from deprecating the old subgraph\\n     * @param _owner Subgraph owner\\n     * @param _curationTaxPercentage Tax percentage on curation deposits from Curation contract\\n     * @return Total tokens that will be sent to curation, _tokens + ownerTax\\n     */\\n    function _chargeOwnerTax(\\n        uint256 _tokens,\\n        address _owner,\\n        uint32 _curationTaxPercentage\\n    ) private returns (uint256) {\\n        if (_curationTaxPercentage == 0 || ownerTaxPercentage == 0) {\\n            return 0;\\n        }\\n\\n        // Tax on the total bonding curve funds\\n        uint256 taxOnOriginal = _tokens.mul(_curationTaxPercentage).div(MAX_PPM);\\n        // Total after the tax\\n        uint256 totalWithoutOwnerTax = _tokens.sub(taxOnOriginal);\\n        // The portion of tax that the owner will pay\\n        uint256 ownerTax = taxOnOriginal.mul(ownerTaxPercentage).div(MAX_PPM);\\n\\n        uint256 totalWithOwnerTax = totalWithoutOwnerTax.add(ownerTax);\\n\\n        // The total after tax, plus owner partial repay, divided by\\n        // the tax, to adjust it slightly upwards. ex:\\n        // 100 GRT, 5 GRT Tax, owner pays 100% --> 5 GRT\\n        // To get 100 in the protocol after tax, Owner deposits\\n        // ~5.26, as ~105.26 * .95 = 100\\n        uint256 totalAdjustedUp = totalWithOwnerTax.mul(MAX_PPM).div(\\n            uint256(MAX_PPM).sub(uint256(_curationTaxPercentage))\\n        );\\n\\n        uint256 ownerTaxAdjustedUp = totalAdjustedUp.sub(_tokens);\\n\\n        // Get the owner of the subgraph to reimburse the curation tax\\n        require(\\n            graphToken().transferFrom(_owner, address(this), ownerTaxAdjustedUp),\\n            \\\"GNS: Error reimbursing curation tax\\\"\\n        );\\n        return totalAdjustedUp;\\n    }\\n\\n    /**\\n     * @dev Calculate name signal to be returned for an amount of tokens.\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _tokensIn Tokens being exchanged for name signal\\n     * @return Amount of name signal and curation tax\\n     */\\n    function tokensToNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _tokensIn\\n    )\\n        public\\n        override\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        (uint256 vSignal, uint256 curationTax) = curation().tokensToSignal(\\n            namePool.subgraphDeploymentID,\\n            _tokensIn\\n        );\\n        uint256 nSignal = vSignalToNSignal(_graphAccount, _subgraphNumber, vSignal);\\n        return (vSignal, nSignal, curationTax);\\n    }\\n\\n    /**\\n     * @dev Calculate tokens returned for an amount of name signal.\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _nSignalIn Name signal being exchanged for tokens\\n     * @return Amount of tokens returned for an amount of nSignal\\n     */\\n    function nSignalToTokens(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignalIn\\n    ) public override view returns (uint256, uint256) {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        uint256 vSignal = nSignalToVSignal(_graphAccount, _subgraphNumber, _nSignalIn);\\n        uint256 tokensOut = curation().signalToTokens(namePool.subgraphDeploymentID, vSignal);\\n        return (vSignal, tokensOut);\\n    }\\n\\n    /**\\n     * @dev Calculate nSignal to be returned for an amount of vSignal.\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _vSignalIn Amount of vSignal to exchange for name signal\\n     * @return Amount of nSignal that can be bought\\n     */\\n    function vSignalToNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _vSignalIn\\n    ) public override view returns (uint256) {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n\\n        // Handle initialization by using 1:1 version to name signal\\n        if (namePool.vSignal == 0) {\\n            return _vSignalIn;\\n        }\\n\\n        return\\n            BancorFormula(bondingCurve).calculatePurchaseReturn(\\n                namePool.nSignal,\\n                namePool.vSignal,\\n                namePool.reserveRatio,\\n                _vSignalIn\\n            );\\n    }\\n\\n    /**\\n     * @dev Calculate vSignal to be returned for an amount of name signal.\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _nSignalIn Name signal being exchanged for vSignal\\n     * @return Amount of vSignal that can be returned\\n     */\\n    function nSignalToVSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignalIn\\n    ) public override view returns (uint256) {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        return\\n            BancorFormula(bondingCurve).calculateSaleReturn(\\n                namePool.nSignal,\\n                namePool.vSignal,\\n                namePool.reserveRatio,\\n                _nSignalIn\\n            );\\n    }\\n\\n    /**\\n     * @dev Get the amount of name signal a curator has on a name pool.\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _curator Curator to look up to see n signal balance\\n     * @return Amount of name signal owned by a curator for the name pool\\n     */\\n    function getCuratorNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        address _curator\\n    ) public override view returns (uint256) {\\n        return nameSignals[_graphAccount][_subgraphNumber].curatorNSignal[_curator];\\n    }\\n\\n    /**\\n     * @dev Return whether a subgraph name is published.\\n     * @param _graphAccount Account being checked\\n     * @param _subgraphNumber Subgraph number being checked for publishing\\n     * @return Return true if subgraph is currently published\\n     */\\n    function isPublished(address _graphAccount, uint256 _subgraphNumber)\\n        public\\n        override\\n        view\\n        returns (bool)\\n    {\\n        return subgraphs[_graphAccount][_subgraphNumber] != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/GraphUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IGraphProxy.sol\\\";\\n\\n/**\\n * @title Graph Upgradeable\\n * @dev This contract is intended to be inherited from upgradeable contracts.\\n */\\ncontract GraphUpgradeable {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32\\n        internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Check if the caller is the proxy admin.\\n     */\\n    modifier onlyProxyAdmin(IGraphProxy _proxy) {\\n        require(msg.sender == _proxy.admin(), \\\"Caller must be the proxy admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check if the caller is the implementation.\\n     */\\n    modifier onlyImpl {\\n        require(msg.sender == _implementation(), \\\"Caller must be the implementation\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     * @return impl Address of the current implementation\\n     */\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Accept to be an implementation of proxy.\\n     */\\n    function acceptProxy(IGraphProxy _proxy) external onlyProxyAdmin(_proxy) {\\n        _proxy.acceptUpgrade();\\n    }\\n\\n    /**\\n     * @dev Accept to be an implementation of proxy and then call a function from the new\\n     * implementation as specified by `_data`, which should be an encoded function call. This is\\n     * useful to initialize new storage variables in the proxied contract.\\n     */\\n    function acceptProxyAndCall(IGraphProxy _proxy, bytes calldata _data)\\n        external\\n        onlyProxyAdmin(_proxy)\\n    {\\n        _proxy.acceptUpgradeAndCall(_data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/IGNS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ninterface IGNS {\\n    // -- Pool --\\n\\n    struct NameCurationPool {\\n        uint256 vSignal; // The token of the subgraph deployment bonding curve\\n        uint256 nSignal; // The token of the name curation bonding curve\\n        mapping(address => uint256) curatorNSignal;\\n        bytes32 subgraphDeploymentID;\\n        uint32 reserveRatio;\\n        bool disabled;\\n        uint256 withdrawableGRT;\\n    }\\n\\n    // -- Configuration --\\n\\n    function approveAll() external;\\n\\n    function setOwnerTaxPercentage(uint32 _ownerTaxPercentage) external;\\n\\n    // -- Publishing --\\n\\n    function setDefaultName(\\n        address _graphAccount,\\n        uint8 _nameSystem,\\n        bytes32 _nameIdentifier,\\n        string calldata _name\\n    ) external;\\n\\n    function updateSubgraphMetadata(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphMetadata\\n    ) external;\\n\\n    function publishNewSubgraph(\\n        address _graphAccount,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata,\\n        bytes32 _subgraphMetadata\\n    ) external;\\n\\n    function publishNewVersion(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata\\n    ) external;\\n\\n    function deprecateSubgraph(address _graphAccount, uint256 _subgraphNumber) external;\\n\\n    // -- Curation --\\n\\n    function mintNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _tokensIn,\\n        uint256 _nSignalOutMin\\n    ) external;\\n\\n    function burnNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignal,\\n        uint256 _tokensOutMin\\n    ) external;\\n\\n    function withdraw(address _graphAccount, uint256 _subgraphNumber) external;\\n\\n    // -- Getters --\\n\\n    function tokensToNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _tokensIn\\n    )\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function nSignalToTokens(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignalIn\\n    ) external view returns (uint256, uint256);\\n\\n    function vSignalToNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _vSignalIn\\n    ) external view returns (uint256);\\n\\n    function nSignalToVSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignalIn\\n    ) external view returns (uint256);\\n\\n    function getCuratorNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        address _curator\\n    ) external view returns (uint256);\\n\\n    function isPublished(address _graphAccount, uint256 _subgraphNumber)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/GNSStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../governance/Managed.sol\\\";\\n\\nimport \\\"./erc1056/IEthereumDIDRegistry.sol\\\";\\n\\nimport \\\"./IGNS.sol\\\";\\n\\ncontract GNSV1Storage is Managed {\\n    // -- State --\\n\\n    // In parts per hundred\\n    uint32 public ownerTaxPercentage;\\n\\n    // Bonding curve formula\\n    address public bondingCurve;\\n\\n    // graphAccountID => subgraphNumber => subgraphDeploymentID\\n    // subgraphNumber = A number associated to a graph accounts deployed subgraph. This\\n    //                  is used to point to a subgraphID (graphAccountID + subgraphNumber)\\n    mapping(address => mapping(uint256 => bytes32)) public subgraphs;\\n\\n    // graphAccountID => subgraph deployment counter\\n    mapping(address => uint256) public graphAccountSubgraphNumbers;\\n\\n    // graphAccountID => subgraphNumber => NameCurationPool\\n    mapping(address => mapping(uint256 => IGNS.NameCurationPool)) public nameSignals;\\n\\n    // ERC-1056 contract reference\\n    IEthereumDIDRegistry public erc1056Registry;\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/IGraphProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ninterface IGraphProxy {\\n    function admin() external returns (address);\\n\\n    function setAdmin(address _newAdmin) external;\\n\\n    function implementation() external returns (address);\\n\\n    function pendingImplementation() external returns (address);\\n\\n    function upgradeTo(address _newImplementation) external;\\n\\n    function acceptUpgrade() external;\\n\\n    function acceptUpgradeAndCall(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Managed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IManaged.sol\\\";\\nimport \\\"./IController.sol\\\";\\nimport \\\"../curation/ICuration.sol\\\";\\nimport \\\"../epochs/IEpochManager.sol\\\";\\nimport \\\"../rewards/IRewardsManager.sol\\\";\\nimport \\\"../staking/IStaking.sol\\\";\\nimport \\\"../token/IGraphToken.sol\\\";\\n\\n/**\\n * @title Graph Managed contract\\n * @dev The Managed contract provides an interface for contracts to interact with the Controller\\n * Inspired by Livepeer:\\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\\n */\\ncontract Managed {\\n    // Controller that contract is registered with\\n    IController public controller;\\n    mapping(bytes32 => address) public addressCache;\\n    uint256[10] private __gap;\\n\\n    event ParameterUpdated(string param);\\n    event SetController(address controller);\\n\\n    function _notPartialPaused() internal view {\\n        require(!controller.paused(), \\\"Paused\\\");\\n        require(!controller.partialPaused(), \\\"Partial-paused\\\");\\n    }\\n\\n    function _notPaused() internal view {\\n        require(!controller.paused(), \\\"Paused\\\");\\n    }\\n\\n    function _onlyGovernor() internal view {\\n        require(msg.sender == controller.getGovernor(), \\\"Caller must be Controller governor\\\");\\n    }\\n\\n    modifier notPartialPaused {\\n        _notPartialPaused();\\n        _;\\n    }\\n\\n    modifier notPaused {\\n        _notPaused();\\n        _;\\n    }\\n\\n    // Check if sender is controller\\n    modifier onlyController() {\\n        require(msg.sender == address(controller), \\\"Caller must be Controller\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernor() {\\n        _onlyGovernor();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize the controller\\n     */\\n    function _initialize(address _controller) internal {\\n        _setController(_controller);\\n    }\\n\\n    /**\\n     * @notice Set Controller. Only callable by current controller\\n     * @param _controller Controller contract address\\n     */\\n    function setController(address _controller) external onlyController {\\n        _setController(_controller);\\n    }\\n\\n    /**\\n     * @dev Set controller.\\n     * @param _controller Controller contract address\\n     */\\n    function _setController(address _controller) internal {\\n        require(_controller != address(0), \\\"Controller must be set\\\");\\n        controller = IController(_controller);\\n        emit SetController(_controller);\\n    }\\n\\n    /**\\n     * @dev Return Curation interface\\n     * @return Curation contract registered with Controller\\n     */\\n    function curation() internal view returns (ICuration) {\\n        return ICuration(controller.getContractProxy(keccak256(\\\"Curation\\\")));\\n    }\\n\\n    /**\\n     * @dev Return EpochManager interface\\n     * @return Epoch manager contract registered with Controller\\n     */\\n    function epochManager() internal view returns (IEpochManager) {\\n        return IEpochManager(controller.getContractProxy(keccak256(\\\"EpochManager\\\")));\\n    }\\n\\n    /**\\n     * @dev Return RewardsManager interface\\n     * @return Rewards manager contract registered with Controller\\n     */\\n    function rewardsManager() internal view returns (IRewardsManager) {\\n        return IRewardsManager(controller.getContractProxy(keccak256(\\\"RewardsManager\\\")));\\n    }\\n\\n    /**\\n     * @dev Return Staking interface\\n     * @return Staking contract registered with Controller\\n     */\\n    function staking() internal view returns (IStaking) {\\n        return IStaking(controller.getContractProxy(keccak256(\\\"Staking\\\")));\\n    }\\n\\n    /**\\n     * @dev Return GraphToken interface\\n     * @return Graph token contract registered with Controller\\n     */\\n    function graphToken() internal view returns (IGraphToken) {\\n        return IGraphToken(controller.getContractProxy(keccak256(\\\"GraphToken\\\")));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/erc1056/IEthereumDIDRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.3;\\n\\ninterface IEthereumDIDRegistry {\\n    function identityOwner(address identity) external view returns (address);\\n\\n    function setAttribute(\\n        address identity,\\n        bytes32 name,\\n        bytes calldata value,\\n        uint256 validity\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/IManaged.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ninterface IManaged {\\n    function setController(address _controller) external;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12 <0.8.0;\\n\\ninterface IController {\\n    function getGovernor() external view returns (address);\\n\\n    // -- Registry --\\n\\n    function setContractProxy(bytes32 _id, address _contractAddress) external;\\n\\n    function unsetContractProxy(bytes32 _id) external;\\n\\n    function updateController(bytes32 _id, address _controller) external;\\n\\n    function getContractProxy(bytes32 _id) external view returns (address);\\n\\n    // -- Pausing --\\n\\n    function setPartialPaused(bool _partialPaused) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function setPauseGuardian(address _newPauseGuardian) external;\\n\\n    function paused() external view returns (bool);\\n\\n    function partialPaused() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/curation/ICuration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IGraphCurationToken.sol\\\";\\n\\ninterface ICuration {\\n    // -- Pool --\\n\\n    struct CurationPool {\\n        uint256 tokens; // GRT Tokens stored as reserves for the subgraph deployment\\n        uint32 reserveRatio; // Ratio for the bonding curve\\n        IGraphCurationToken gcs; // Curation token contract for this curation pool\\n    }\\n\\n    // -- Configuration --\\n\\n    function setDefaultReserveRatio(uint32 _defaultReserveRatio) external;\\n\\n    function setMinimumCurationDeposit(uint256 _minimumCurationDeposit) external;\\n\\n    function setCurationTaxPercentage(uint32 _percentage) external;\\n\\n    // -- Curation --\\n\\n    function mint(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokensIn,\\n        uint256 _signalOutMin\\n    ) external returns (uint256, uint256);\\n\\n    function burn(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _signalIn,\\n        uint256 _tokensOutMin\\n    ) external returns (uint256);\\n\\n    function collect(bytes32 _subgraphDeploymentID, uint256 _tokens) external;\\n\\n    // -- Getters --\\n\\n    function isCurated(bytes32 _subgraphDeploymentID) external view returns (bool);\\n\\n    function getCuratorSignal(address _curator, bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCurationPoolSignal(bytes32 _subgraphDeploymentID) external view returns (uint256);\\n\\n    function getCurationPoolTokens(bytes32 _subgraphDeploymentID) external view returns (uint256);\\n\\n    function tokensToSignal(bytes32 _subgraphDeploymentID, uint256 _tokensIn)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function signalToTokens(bytes32 _subgraphDeploymentID, uint256 _signalIn)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function curationTaxPercentage() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/epochs/IEpochManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ninterface IEpochManager {\\n    // -- Configuration --\\n\\n    function setEpochLength(uint256 _epochLength) external;\\n\\n    // -- Epochs\\n\\n    function runEpoch() external;\\n\\n    // -- Getters --\\n\\n    function isCurrentEpochRun() external view returns (bool);\\n\\n    function blockNum() external view returns (uint256);\\n\\n    function blockHash(uint256 _block) external view returns (bytes32);\\n\\n    function currentEpoch() external view returns (uint256);\\n\\n    function currentEpochBlock() external view returns (uint256);\\n\\n    function currentEpochBlockSinceStart() external view returns (uint256);\\n\\n    function epochsSince(uint256 _epoch) external view returns (uint256);\\n\\n    function epochsSinceUpdate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/IRewardsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ninterface IRewardsManager {\\n    /**\\n     * @dev Stores accumulated rewards and snapshots related to a particular SubgraphDeployment.\\n     */\\n    struct Subgraph {\\n        uint256 accRewardsForSubgraph;\\n        uint256 accRewardsForSubgraphSnapshot;\\n        uint256 accRewardsPerSignalSnapshot;\\n        uint256 accRewardsPerAllocatedToken;\\n    }\\n\\n    // -- Params --\\n\\n    function setIssuanceRate(uint256 _issuanceRate) external;\\n\\n    // -- Denylist --\\n\\n    function setSubgraphAvailabilityOracle(address _subgraphAvailabilityOracle) external;\\n\\n    function setDenied(bytes32 _subgraphDeploymentID, bool _deny) external;\\n\\n    function setDeniedMany(bytes32[] calldata _subgraphDeploymentID, bool[] calldata _deny)\\n        external;\\n\\n    function isDenied(bytes32 _subgraphDeploymentID) external view returns (bool);\\n\\n    // -- Getters --\\n\\n    function getNewRewardsPerSignal() external view returns (uint256);\\n\\n    function getAccRewardsPerSignal() external view returns (uint256);\\n\\n    function getAccRewardsForSubgraph(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getAccRewardsPerAllocatedToken(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function getRewards(address _allocationID) external view returns (uint256);\\n\\n    // -- Updates --\\n\\n    function updateAccRewardsPerSignal() external returns (uint256);\\n\\n    function takeRewards(address _allocationID) external returns (uint256);\\n\\n    // -- Hooks --\\n\\n    function onSubgraphSignalUpdate(bytes32 _subgraphDeploymentID) external returns (uint256);\\n\\n    function onSubgraphAllocationUpdate(bytes32 _subgraphDeploymentID) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IStaking {\\n    // -- Allocation Data --\\n\\n    /**\\n     * @dev Possible states an allocation can be\\n     * States:\\n     * - Null = indexer == address(0)\\n     * - Active = not Null && tokens > 0\\n     * - Closed = Active && closedAtEpoch != 0\\n     * - Finalized = Closed && closedAtEpoch + channelDisputeEpochs > now()\\n     * - Claimed = not Null && tokens == 0\\n     */\\n    enum AllocationState { Null, Active, Closed, Finalized, Claimed }\\n\\n    /**\\n     * @dev Allocate GRT tokens for the purpose of serving queries of a subgraph deployment\\n     * An allocation is created in the allocate() function and consumed in claim()\\n     */\\n    struct Allocation {\\n        address indexer;\\n        bytes32 subgraphDeploymentID;\\n        uint256 tokens; // Tokens allocated to a SubgraphDeployment\\n        uint256 createdAtEpoch; // Epoch when it was created\\n        uint256 closedAtEpoch; // Epoch when it was closed\\n        uint256 collectedFees; // Collected fees for the allocation\\n        uint256 effectiveAllocation; // Effective allocation when closed\\n        uint256 accRewardsPerAllocatedToken; // Snapshot used for reward calc\\n    }\\n\\n    /**\\n     * @dev Represents a request to close an allocation with a specific proof of indexing.\\n     * This is passed when calling closeAllocationMany to define the closing parameters for\\n     * each allocation.\\n     */\\n    struct CloseAllocationRequest {\\n        address allocationID;\\n        bytes32 poi;\\n    }\\n\\n    // -- Delegation Data --\\n\\n    /**\\n     * @dev Delegation pool information. One per indexer.\\n     */\\n    struct DelegationPool {\\n        uint32 cooldownBlocks; // Blocks to wait before updating parameters\\n        uint32 indexingRewardCut; // in PPM\\n        uint32 queryFeeCut; // in PPM\\n        uint256 updatedAtBlock; // Block when the pool was last updated\\n        uint256 tokens; // Total tokens as pool reserves\\n        uint256 shares; // Total shares minted in the pool\\n        mapping(address => Delegation) delegators; // Mapping of delegator => Delegation\\n    }\\n\\n    /**\\n     * @dev Individual delegation data of a delegator in a pool.\\n     */\\n    struct Delegation {\\n        uint256 shares; // Shares owned by a delegator in the pool\\n        uint256 tokensLocked; // Tokens locked for undelegation\\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\\n    }\\n\\n    // -- Configuration --\\n\\n    function setMinimumIndexerStake(uint256 _minimumIndexerStake) external;\\n\\n    function setThawingPeriod(uint32 _thawingPeriod) external;\\n\\n    function setCurationPercentage(uint32 _percentage) external;\\n\\n    function setProtocolPercentage(uint32 _percentage) external;\\n\\n    function setChannelDisputeEpochs(uint32 _channelDisputeEpochs) external;\\n\\n    function setMaxAllocationEpochs(uint32 _maxAllocationEpochs) external;\\n\\n    function setRebateRatio(uint32 _alphaNumerator, uint32 _alphaDenominator) external;\\n\\n    function setDelegationRatio(uint32 _delegationRatio) external;\\n\\n    function setDelegationParameters(\\n        uint32 _indexingRewardCut,\\n        uint32 _queryFeeCut,\\n        uint32 _cooldownBlocks\\n    ) external;\\n\\n    function setDelegationParametersCooldown(uint32 _blocks) external;\\n\\n    function setDelegationUnbondingPeriod(uint32 _delegationUnbondingPeriod) external;\\n\\n    function setDelegationTaxPercentage(uint32 _percentage) external;\\n\\n    function setSlasher(address _slasher, bool _allowed) external;\\n\\n    function setAssetHolder(address _assetHolder, bool _allowed) external;\\n\\n    // -- Operation --\\n\\n    function setOperator(address _operator, bool _allowed) external;\\n\\n    function isOperator(address _operator, address _indexer) external view returns (bool);\\n\\n    // -- Staking --\\n\\n    function stake(uint256 _tokens) external;\\n\\n    function stakeTo(address _indexer, uint256 _tokens) external;\\n\\n    function unstake(uint256 _tokens) external;\\n\\n    function slash(\\n        address _indexer,\\n        uint256 _tokens,\\n        uint256 _reward,\\n        address _beneficiary\\n    ) external;\\n\\n    function withdraw() external;\\n\\n    // -- Delegation --\\n\\n    function delegate(address _indexer, uint256 _tokens) external returns (uint256);\\n\\n    function undelegate(address _indexer, uint256 _shares) external returns (uint256);\\n\\n    function withdrawDelegated(address _indexer, address _newIndexer) external returns (uint256);\\n\\n    // -- Channel management and allocations --\\n\\n    function allocate(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function allocateFrom(\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function closeAllocation(address _allocationID, bytes32 _poi) external;\\n\\n    function closeAllocationMany(CloseAllocationRequest[] calldata _requests) external;\\n\\n    function closeAndAllocate(\\n        address _oldAllocationID,\\n        bytes32 _poi,\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function collect(uint256 _tokens, address _allocationID) external;\\n\\n    function claim(address _allocationID, bool _restake) external;\\n\\n    function claimMany(address[] calldata _allocationID, bool _restake) external;\\n\\n    // -- Getters and calculations --\\n\\n    function hasStake(address _indexer) external view returns (bool);\\n\\n    function getIndexerStakedTokens(address _indexer) external view returns (uint256);\\n\\n    function getIndexerCapacity(address _indexer) external view returns (uint256);\\n\\n    function getAllocation(address _allocationID) external view returns (Allocation memory);\\n\\n    function getAllocationState(address _allocationID) external view returns (AllocationState);\\n\\n    function isAllocation(address _allocationID) external view returns (bool);\\n\\n    function getSubgraphAllocatedTokens(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getDelegation(address _indexer, address _delegator)\\n        external\\n        view\\n        returns (Delegation memory);\\n\\n    function isDelegator(address _indexer, address _delegator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/token/IGraphToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IGraphToken is IERC20 {\\n    // -- Mint and Burn --\\n\\n    function burn(uint256 amount) external;\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    // -- Mint Admin --\\n\\n    function addMinter(address _account) external;\\n\\n    function removeMinter(address _account) external;\\n\\n    function renounceMinter() external;\\n\\n    function isMinter(address _account) external view returns (bool);\\n\\n    // -- Permit --\\n\\n    function permit(\\n        address _owner,\\n        address _spender,\\n        uint256 _value,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/curation/IGraphCurationToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IGraphCurationToken is IERC20 {\\n    function burnFrom(address _account, uint256 _amount) external;\\n\\n    function mint(address _to, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/StakingStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../governance/Managed.sol\\\";\\nimport \\\"../staking/IStaking.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\nimport \\\"./libs/Rebates.sol\\\";\\nimport \\\"./libs/Stakes.sol\\\";\\n\\ncontract StakingV1Storage is Managed {\\n    // -- Staking --\\n\\n    // Minimum amount of tokens an indexer needs to stake\\n    uint256 public minimumIndexerStake;\\n\\n    // Time in blocks to unstake\\n    uint32 public thawingPeriod; // in blocks\\n\\n    // Percentage of fees going to curators\\n    // Parts per million. (Allows for 4 decimal points, 999,999 = 99.9999%)\\n    uint32 public curationPercentage;\\n\\n    // Percentage of fees burned as protocol fee\\n    // Parts per million. (Allows for 4 decimal points, 999,999 = 99.9999%)\\n    uint32 public protocolPercentage;\\n\\n    // Period for allocation to be finalized\\n    uint32 public channelDisputeEpochs;\\n\\n    // Maximum allocation time\\n    uint32 public maxAllocationEpochs;\\n\\n    // Rebate ratio\\n    uint32 public alphaNumerator;\\n    uint32 public alphaDenominator;\\n\\n    // Indexer stakes : indexer => Stake\\n    mapping(address => Stakes.Indexer) public stakes;\\n\\n    // Allocations : allocationID => Allocation\\n    mapping(address => IStaking.Allocation) public allocations;\\n\\n    // Subgraph Allocations: subgraphDeploymentID => tokens\\n    mapping(bytes32 => uint256) public subgraphAllocations;\\n\\n    // Rebate pools : epoch => Pool\\n    mapping(uint256 => Rebates.Pool) public rebates;\\n\\n    // -- Slashing --\\n\\n    // List of addresses allowed to slash stakes\\n    mapping(address => bool) public slashers;\\n\\n    // -- Delegation --\\n\\n    // Set the delegation capacity multiplier defined by the delegation ratio\\n    // If delegation ratio is 100, and an Indexer has staked 5 GRT,\\n    // then they can use up to 500 GRT from the delegated stake\\n    uint32 public delegationRatio;\\n\\n    // Time in blocks an indexer needs to wait to change delegation parameters\\n    uint32 public delegationParametersCooldown;\\n\\n    // Time in epochs a delegator needs to wait to withdraw delegated stake\\n    uint32 public delegationUnbondingPeriod; // in epochs\\n\\n    // Percentage of tokens to tax a delegation deposit\\n    // Parts per million. (Allows for 4 decimal points, 999,999 = 99.9999%)\\n    uint32 public delegationTaxPercentage;\\n\\n    // Delegation pools : indexer => DelegationPool\\n    mapping(address => IStaking.DelegationPool) public delegationPools;\\n\\n    // -- Operators --\\n\\n    // Operator auth : indexer => operator\\n    mapping(address => mapping(address => bool)) public operatorAuth;\\n\\n    // -- Asset Holders --\\n\\n    // Allowed AssetHolders: assetHolder => is allowed\\n    mapping(address => bool) public assetHolders;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/libs/Rebates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./Cobbs.sol\\\";\\n\\n/**\\n * @title A collection of data structures and functions to manage Rebates\\n *        Used for low-level state changes, require() conditions should be evaluated\\n *        at the caller function scope.\\n */\\nlibrary Rebates {\\n    using SafeMath for uint256;\\n\\n    // Tracks stats for allocations closed on a particular epoch for claiming\\n    // The pool also keeps tracks of total query fees collected and stake used\\n    // Only one rebate pool exists per epoch\\n    struct Pool {\\n        uint256 fees; // total query fees in the rebate pool\\n        uint256 effectiveAllocatedStake; // total effective allocation of stake\\n        uint256 claimedRewards; // total claimed rewards from the rebate pool\\n        uint32 unclaimedAllocationsCount; // amount of unclaimed allocations\\n        uint32 alphaNumerator; // numerator of `alpha` in the cobb-douglas function\\n        uint32 alphaDenominator; // denominator of `alpha` in the cobb-douglas function\\n    }\\n\\n    /**\\n     * @dev Init the rebate pool with the rebate ratio.\\n     * @param _alphaNumerator Numerator of `alpha` in the cobb-douglas function\\n     * @param _alphaDenominator Denominator of `alpha` in the cobb-douglas function\\n     */\\n    function init(\\n        Rebates.Pool storage pool,\\n        uint32 _alphaNumerator,\\n        uint32 _alphaDenominator\\n    ) internal {\\n        pool.alphaNumerator = _alphaNumerator;\\n        pool.alphaDenominator = _alphaDenominator;\\n    }\\n\\n    /**\\n     * @dev Return true if the rebate pool was already initialized.\\n     */\\n    function exists(Rebates.Pool storage pool) internal view returns (bool) {\\n        return pool.effectiveAllocatedStake > 0;\\n    }\\n\\n    /**\\n     * @dev Return the amount of unclaimed fees.\\n     */\\n    function unclaimedFees(Rebates.Pool storage pool) internal view returns (uint256) {\\n        return pool.fees.sub(pool.claimedRewards);\\n    }\\n\\n    /**\\n     * @dev Deposit tokens into the rebate pool.\\n     * @param _indexerFees Amount of fees collected in tokens\\n     * @param _indexerEffectiveAllocatedStake Effective stake allocated by indexer for a period of epochs\\n     */\\n    function addToPool(\\n        Rebates.Pool storage pool,\\n        uint256 _indexerFees,\\n        uint256 _indexerEffectiveAllocatedStake\\n    ) internal {\\n        pool.fees = pool.fees.add(_indexerFees);\\n        pool.effectiveAllocatedStake = pool.effectiveAllocatedStake.add(\\n            _indexerEffectiveAllocatedStake\\n        );\\n        pool.unclaimedAllocationsCount += 1;\\n    }\\n\\n    /**\\n     * @dev Redeem tokens from the rebate pool.\\n     * @param _indexerFees Amount of fees collected in tokens\\n     * @param _indexerEffectiveAllocatedStake Effective stake allocated by indexer for a period of epochs\\n     * @return Amount of reward tokens according to Cobb-Douglas rebate formula\\n     */\\n    function redeem(\\n        Rebates.Pool storage pool,\\n        uint256 _indexerFees,\\n        uint256 _indexerEffectiveAllocatedStake\\n    ) internal returns (uint256) {\\n        uint256 rebateReward = 0;\\n\\n        // Calculate the rebate rewards for the indexer\\n        if (pool.fees > 0) {\\n            rebateReward = LibCobbDouglas.cobbDouglas(\\n                pool.fees, // totalRewards\\n                _indexerFees,\\n                pool.fees,\\n                _indexerEffectiveAllocatedStake,\\n                pool.effectiveAllocatedStake,\\n                pool.alphaNumerator,\\n                pool.alphaDenominator\\n            );\\n\\n            // Under NO circumstance we will reward more than total fees in the pool\\n            uint256 _unclaimedFees = pool.fees.sub(pool.claimedRewards);\\n            if (rebateReward > _unclaimedFees) {\\n                rebateReward = _unclaimedFees;\\n            }\\n        }\\n\\n        // Update pool state\\n        pool.unclaimedAllocationsCount -= 1;\\n        pool.claimedRewards = pool.claimedRewards.add(rebateReward);\\n\\n        return rebateReward;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/libs/Stakes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @title A collection of data structures and functions to manage the Indexer Stake state.\\n *        Used for low-level state changes, require() conditions should be evaluated\\n *        at the caller function scope.\\n */\\nlibrary Stakes {\\n    using SafeMath for uint256;\\n    using Stakes for Stakes.Indexer;\\n\\n    struct Indexer {\\n        uint256 tokensStaked; // Tokens on the indexer stake (staked by the indexer)\\n        uint256 tokensAllocated; // Tokens used in allocations\\n        uint256 tokensLocked; // Tokens locked for withdrawal subject to thawing period\\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\\n    }\\n\\n    /**\\n     * @dev Deposit tokens to the indexer stake.\\n     * @param stake Stake data\\n     * @param _tokens Amount of tokens to deposit\\n     */\\n    function deposit(Stakes.Indexer storage stake, uint256 _tokens) internal {\\n        stake.tokensStaked = stake.tokensStaked.add(_tokens);\\n    }\\n\\n    /**\\n     * @dev Release tokens from the indexer stake.\\n     * @param stake Stake data\\n     * @param _tokens Amount of tokens to release\\n     */\\n    function release(Stakes.Indexer storage stake, uint256 _tokens) internal {\\n        stake.tokensStaked = stake.tokensStaked.sub(_tokens);\\n    }\\n\\n    /**\\n     * @dev Allocate tokens from the main stack to a SubgraphDeployment.\\n     * @param stake Stake data\\n     * @param _tokens Amount of tokens to allocate\\n     */\\n    function allocate(Stakes.Indexer storage stake, uint256 _tokens) internal {\\n        stake.tokensAllocated = stake.tokensAllocated.add(_tokens);\\n    }\\n\\n    /**\\n     * @dev Unallocate tokens from a SubgraphDeployment back to the main stack.\\n     * @param stake Stake data\\n     * @param _tokens Amount of tokens to unallocate\\n     */\\n    function unallocate(Stakes.Indexer storage stake, uint256 _tokens) internal {\\n        stake.tokensAllocated = stake.tokensAllocated.sub(_tokens);\\n    }\\n\\n    /**\\n     * @dev Lock tokens until a thawing period pass.\\n     * @param stake Stake data\\n     * @param _tokens Amount of tokens to unstake\\n     * @param _period Period in blocks that need to pass before withdrawal\\n     */\\n    function lockTokens(\\n        Stakes.Indexer storage stake,\\n        uint256 _tokens,\\n        uint256 _period\\n    ) internal {\\n        // Take into account period averaging for multiple unstake requests\\n        uint256 lockingPeriod = _period;\\n        if (stake.tokensLocked > 0) {\\n            lockingPeriod = stake.getLockingPeriod(_tokens, _period);\\n        }\\n\\n        // Update balances\\n        stake.tokensLocked = stake.tokensLocked.add(_tokens);\\n        stake.tokensLockedUntil = block.number.add(lockingPeriod);\\n    }\\n\\n    /**\\n     * @dev Unlock tokens.\\n     * @param stake Stake data\\n     * @param _tokens Amount of tokens to unkock\\n     */\\n    function unlockTokens(Stakes.Indexer storage stake, uint256 _tokens) internal {\\n        stake.tokensLocked = stake.tokensLocked.sub(_tokens);\\n        if (stake.tokensLocked == 0) {\\n            stake.tokensLockedUntil = 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Take all tokens out from the locked stake for withdrawal.\\n     * @param stake Stake data\\n     * @return Amount of tokens being withdrawn\\n     */\\n    function withdrawTokens(Stakes.Indexer storage stake) internal returns (uint256) {\\n        // Calculate tokens that can be released\\n        uint256 tokensToWithdraw = stake.tokensWithdrawable();\\n\\n        if (tokensToWithdraw > 0) {\\n            // Reset locked tokens\\n            stake.unlockTokens(tokensToWithdraw);\\n\\n            // Decrease indexer stake\\n            stake.release(tokensToWithdraw);\\n        }\\n\\n        return tokensToWithdraw;\\n    }\\n\\n    /**\\n     * @dev Get the locking period of the tokens to unstake.\\n     * If already unstaked before calculate the weighted average.\\n     * @param stake Stake data\\n     * @param _tokens Amount of tokens to unstake\\n     * @param _thawingPeriod Period in blocks that need to pass before withdrawal\\n     * @return The weighted average locking period\\n     */\\n    function getLockingPeriod(\\n        Stakes.Indexer memory stake,\\n        uint256 _tokens,\\n        uint256 _thawingPeriod\\n    ) internal view returns (uint256) {\\n        uint256 blockNum = block.number;\\n        uint256 periodA = (stake.tokensLockedUntil > blockNum)\\n            ? stake.tokensLockedUntil.sub(blockNum)\\n            : 0;\\n        uint256 periodB = _thawingPeriod;\\n        uint256 stakeA = stake.tokensLocked;\\n        uint256 stakeB = _tokens;\\n        return periodA.mul(stakeA).add(periodB.mul(stakeB)).div(stakeA.add(stakeB));\\n    }\\n\\n    /**\\n     * @dev Return true if there are tokens staked by the Indexer.\\n     * @param stake Stake data\\n     * @return True if staked\\n     */\\n    function hasTokens(Stakes.Indexer memory stake) internal pure returns (bool) {\\n        return stake.tokensStaked > 0;\\n    }\\n\\n    /**\\n     * @dev Return the amount of tokens used in allocations and locked for withdrawal.\\n     * @param stake Stake data\\n     * @return Token amount\\n     */\\n    function tokensUsed(Stakes.Indexer memory stake) internal pure returns (uint256) {\\n        return stake.tokensAllocated.add(stake.tokensLocked);\\n    }\\n\\n    /**\\n     * @dev Return the amount of tokens staked not considering the ones that are already going\\n     * through the thawing period or are ready for withdrawal. We call it secure stake because\\n     * it is not subject to change by a withdraw call from the indexer.\\n     * @param stake Stake data\\n     * @return Token amount\\n     */\\n    function tokensSecureStake(Stakes.Indexer memory stake) internal pure returns (uint256) {\\n        return stake.tokensStaked.sub(stake.tokensLocked);\\n    }\\n\\n    /**\\n     * @dev Tokens free balance on the indexer stake that can be used for any purpose.\\n     * Any token that is allocated cannot be used as well as tokens that are going through the\\n     * thawing period or are withdrawable\\n     * Calc: tokensStaked - tokensAllocated - tokensLocked\\n     * @param stake Stake data\\n     * @return Token amount\\n     */\\n    function tokensAvailable(Stakes.Indexer memory stake) internal pure returns (uint256) {\\n        return stake.tokensAvailableWithDelegation(0);\\n    }\\n\\n    /**\\n     * @dev Tokens free balance on the indexer stake that can be used for allocations.\\n     * This function accepts a parameter for extra delegated capacity that takes into\\n     * account delegated tokens\\n     * @param stake Stake data\\n     * @param _delegatedCapacity Amount of tokens used from delegators to calculate availability\\n     * @return Token amount\\n     */\\n    function tokensAvailableWithDelegation(Stakes.Indexer memory stake, uint256 _delegatedCapacity)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 tokensCapacity = stake.tokensStaked.add(_delegatedCapacity);\\n        uint256 _tokensUsed = stake.tokensUsed();\\n        // If more tokens are used than the current capacity, the indexer is overallocated.\\n        // This means the indexer doesn't have available capacity to create new allocations.\\n        // We can reach this state when the indexer has funds allocated and then any\\n        // of these conditions happen:\\n        // - The delegationCapacity ratio is reduced.\\n        // - The indexer stake is slashed.\\n        // - A delegator removes enough stake.\\n        if (_tokensUsed > tokensCapacity) {\\n            // Indexer stake is over allocated: return 0 to avoid stake to be used until\\n            // the overallocation is restored by staking more tokens, unallocating tokens\\n            // or using more delegated funds\\n            return 0;\\n        }\\n        return tokensCapacity.sub(_tokensUsed);\\n    }\\n\\n    /**\\n     * @dev Tokens available for withdrawal after thawing period.\\n     * @param stake Stake data\\n     * @return Token amount\\n     */\\n    function tokensWithdrawable(Stakes.Indexer memory stake) internal view returns (uint256) {\\n        // No tokens to withdraw before locking period\\n        if (stake.tokensLockedUntil == 0 || block.number < stake.tokensLockedUntil) {\\n            return 0;\\n        }\\n        return stake.tokensLocked;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/libs/Cobbs.sol\": {\r\n      \"content\": \"/*\\n\\n  Copyright 2019 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\n// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibFixedMath.sol\\\";\\n\\nlibrary LibCobbDouglas {\\n    /// @dev The cobb-douglas function used to compute fee-based rewards for\\n    ///      staking pools in a given epoch. This function does not perform\\n    ///      bounds checking on the inputs, but the following conditions\\n    ///      need to be true:\\n    ///         0 <= fees / totalFees <= 1\\n    ///         0 <= stake / totalStake <= 1\\n    ///         0 <= alphaNumerator / alphaDenominator <= 1\\n    /// @param totalRewards collected over an epoch.\\n    /// @param fees Fees attributed to the the staking pool.\\n    /// @param totalFees Total fees collected across all pools that earned rewards.\\n    /// @param stake Stake attributed to the staking pool.\\n    /// @param totalStake Total stake across all pools that earned rewards.\\n    /// @param alphaNumerator Numerator of `alpha` in the cobb-douglas function.\\n    /// @param alphaDenominator Denominator of `alpha` in the cobb-douglas\\n    ///        function.\\n    /// @return rewards Rewards owed to the staking pool.\\n    function cobbDouglas(\\n        uint256 totalRewards,\\n        uint256 fees,\\n        uint256 totalFees,\\n        uint256 stake,\\n        uint256 totalStake,\\n        uint32 alphaNumerator,\\n        uint32 alphaDenominator\\n    ) public pure returns (uint256 rewards) {\\n        int256 feeRatio = LibFixedMath.toFixed(fees, totalFees);\\n        int256 stakeRatio = LibFixedMath.toFixed(stake, totalStake);\\n        if (feeRatio == 0 || stakeRatio == 0) {\\n            return rewards = 0;\\n        }\\n        // The cobb-doublas function has the form:\\n        // `totalRewards * feeRatio ^ alpha * stakeRatio ^ (1-alpha)`\\n        // This is equivalent to:\\n        // `totalRewards * stakeRatio * e^(alpha * (ln(feeRatio / stakeRatio)))`\\n        // However, because `ln(x)` has the domain of `0 < x < 1`\\n        // and `exp(x)` has the domain of `x < 0`,\\n        // and fixed-point math easily overflows with multiplication,\\n        // we will choose the following if `stakeRatio > feeRatio`:\\n        // `totalRewards * stakeRatio / e^(alpha * (ln(stakeRatio / feeRatio)))`\\n\\n        // Compute\\n        // `e^(alpha * ln(feeRatio/stakeRatio))` if feeRatio <= stakeRatio\\n        // or\\n        // `e^(alpa * ln(stakeRatio/feeRatio))` if feeRatio > stakeRatio\\n        int256 n = feeRatio <= stakeRatio\\n            ? LibFixedMath.div(feeRatio, stakeRatio)\\n            : LibFixedMath.div(stakeRatio, feeRatio);\\n        n = LibFixedMath.exp(\\n            LibFixedMath.mulDiv(\\n                LibFixedMath.ln(n),\\n                int256(alphaNumerator),\\n                int256(alphaDenominator)\\n            )\\n        );\\n        // Compute\\n        // `totalRewards * n` if feeRatio <= stakeRatio\\n        // or\\n        // `totalRewards / n` if stakeRatio > feeRatio\\n        // depending on the choice we made earlier.\\n        n = feeRatio <= stakeRatio\\n            ? LibFixedMath.mul(stakeRatio, n)\\n            : LibFixedMath.div(stakeRatio, n);\\n        // Multiply the above with totalRewards.\\n        rewards = LibFixedMath.uintMul(n, totalRewards);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/libs/LibFixedMath.sol\": {\r\n      \"content\": \"/*\\n\\n  Copyright 2017 Bprotocol Foundation, 2019 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\n// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.3;\\n\\n// solhint-disable indent\\n/// @dev Signed, fixed-point, 127-bit precision math library.\\nlibrary LibFixedMath {\\n    // 1\\n    int256 private constant FIXED_1 = int256(\\n        0x0000000000000000000000000000000080000000000000000000000000000000\\n    );\\n    // 2**255\\n    int256 private constant MIN_FIXED_VAL = int256(\\n        0x8000000000000000000000000000000000000000000000000000000000000000\\n    );\\n    // 1^2 (in fixed-point)\\n    int256 private constant FIXED_1_SQUARED = int256(\\n        0x4000000000000000000000000000000000000000000000000000000000000000\\n    );\\n    // 1\\n    int256 private constant LN_MAX_VAL = FIXED_1;\\n    // e ^ -63.875\\n    int256 private constant LN_MIN_VAL = int256(\\n        0x0000000000000000000000000000000000000000000000000000000733048c5a\\n    );\\n    // 0\\n    int256 private constant EXP_MAX_VAL = 0;\\n    // -63.875\\n    int256 private constant EXP_MIN_VAL = -int256(\\n        0x0000000000000000000000000000001ff0000000000000000000000000000000\\n    );\\n\\n    /// @dev Get one as a fixed-point number.\\n    function one() internal pure returns (int256 f) {\\n        f = FIXED_1;\\n    }\\n\\n    /// @dev Returns the addition of two fixed point numbers, reverting on overflow.\\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = _add(a, b);\\n    }\\n\\n    /// @dev Returns the addition of two fixed point numbers, reverting on overflow.\\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\\n        if (b == MIN_FIXED_VAL) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        c = _add(a, -b);\\n    }\\n\\n    /// @dev Returns the multiplication of two fixed point numbers, reverting on overflow.\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = _mul(a, b) / FIXED_1;\\n    }\\n\\n    /// @dev Returns the division of two fixed point numbers.\\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = _div(_mul(a, FIXED_1), b);\\n    }\\n\\n    /// @dev Performs (a * n) / d, without scaling for precision.\\n    function mulDiv(\\n        int256 a,\\n        int256 n,\\n        int256 d\\n    ) internal pure returns (int256 c) {\\n        c = _div(_mul(a, n), d);\\n    }\\n\\n    /// @dev Returns the unsigned integer result of multiplying a fixed-point\\n    ///      number with an integer, reverting if the multiplication overflows.\\n    ///      Negative results are clamped to zero.\\n    function uintMul(int256 f, uint256 u) internal pure returns (uint256) {\\n        if (int256(u) < int256(0)) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        int256 c = _mul(f, int256(u));\\n        if (c <= 0) {\\n            return 0;\\n        }\\n        return uint256(uint256(c) >> 127);\\n    }\\n\\n    /// @dev Returns the absolute value of a fixed point number.\\n    function abs(int256 f) internal pure returns (int256 c) {\\n        if (f == MIN_FIXED_VAL) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        if (f >= 0) {\\n            c = f;\\n        } else {\\n            c = -f;\\n        }\\n    }\\n\\n    /// @dev Returns 1 / `x`, where `x` is a fixed-point number.\\n    function invert(int256 f) internal pure returns (int256 c) {\\n        c = _div(FIXED_1_SQUARED, f);\\n    }\\n\\n    /// @dev Convert signed `n` / 1 to a fixed-point number.\\n    function toFixed(int256 n) internal pure returns (int256 f) {\\n        f = _mul(n, FIXED_1);\\n    }\\n\\n    /// @dev Convert signed `n` / `d` to a fixed-point number.\\n    function toFixed(int256 n, int256 d) internal pure returns (int256 f) {\\n        f = _div(_mul(n, FIXED_1), d);\\n    }\\n\\n    /// @dev Convert unsigned `n` / 1 to a fixed-point number.\\n    ///      Reverts if `n` is too large to fit in a fixed-point number.\\n    function toFixed(uint256 n) internal pure returns (int256 f) {\\n        if (int256(n) < int256(0)) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        f = _mul(int256(n), FIXED_1);\\n    }\\n\\n    /// @dev Convert unsigned `n` / `d` to a fixed-point number.\\n    ///      Reverts if `n` / `d` is too large to fit in a fixed-point number.\\n    function toFixed(uint256 n, uint256 d) internal pure returns (int256 f) {\\n        if (int256(n) < int256(0)) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        if (int256(d) < int256(0)) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        f = _div(_mul(int256(n), FIXED_1), int256(d));\\n    }\\n\\n    /// @dev Convert a fixed-point number to an integer.\\n    function toInteger(int256 f) internal pure returns (int256 n) {\\n        return f / FIXED_1;\\n    }\\n\\n    /// @dev Get the natural logarithm of a fixed-point number 0 < `x` <= LN_MAX_VAL\\n    function ln(int256 x) internal pure returns (int256 r) {\\n        if (x > LN_MAX_VAL) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n        if (x <= 0) {\\n            revert(\\\"too-small\\\");\\n        }\\n        if (x == FIXED_1) {\\n            return 0;\\n        }\\n        if (x <= LN_MIN_VAL) {\\n            return EXP_MIN_VAL;\\n        }\\n\\n        int256 y;\\n        int256 z;\\n        int256 w;\\n\\n        // Rewrite the input as a quotient of negative natural exponents and a single residual q, such that 1 < q < 2\\n        // For example: log(0.3) = log(e^-1 * e^-0.25 * 1.0471028872385522)\\n        //              = 1 - 0.25 - log(1 + 0.0471028872385522)\\n        // e ^ -32\\n        if (x <= int256(0x00000000000000000000000000000000000000000001c8464f76164760000000)) {\\n            r -= int256(0x0000000000000000000000000000001000000000000000000000000000000000); // - 32\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x00000000000000000000000000000000000000000001c8464f76164760000000); // / e ^ -32\\n        }\\n        // e ^ -16\\n        if (x <= int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000800000000000000000000000000000000); // - 16\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000); // / e ^ -16\\n        }\\n        // e ^ -8\\n        if (x <= int256(0x00000000000000000000000000000000000afe10820813d78000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000400000000000000000000000000000000); // - 8\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x00000000000000000000000000000000000afe10820813d78000000000000000); // / e ^ -8\\n        }\\n        // e ^ -4\\n        if (x <= int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000200000000000000000000000000000000); // - 4\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000); // / e ^ -4\\n        }\\n        // e ^ -2\\n        if (x <= int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000100000000000000000000000000000000); // - 2\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000); // / e ^ -2\\n        }\\n        // e ^ -1\\n        if (x <= int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000080000000000000000000000000000000); // - 1\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000); // / e ^ -1\\n        }\\n        // e ^ -0.5\\n        if (x <= int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000040000000000000000000000000000000); // - 0.5\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000); // / e ^ -0.5\\n        }\\n        // e ^ -0.25\\n        if (x <= int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000)) {\\n            r -= int256(0x0000000000000000000000000000000020000000000000000000000000000000); // - 0.25\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000); // / e ^ -0.25\\n        }\\n        // e ^ -0.125\\n        if (x <= int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) {\\n            r -= int256(0x0000000000000000000000000000000010000000000000000000000000000000); // - 0.125\\n            x =\\n                (x * FIXED_1) /\\n                int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d); // / e ^ -0.125\\n        }\\n        // `x` is now our residual in the range of 1 <= x <= 2 (or close enough).\\n\\n        // Add the taylor series for log(1 + z), where z = x - 1\\n        z = y = x - FIXED_1;\\n        w = (y * y) / FIXED_1;\\n        r += (z * (0x100000000000000000000000000000000 - y)) / 0x100000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\\n        r += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\\n        r += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\\n        r += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\\n        r += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\\n        r += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\\n        r += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\\n        r += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\\n    }\\n\\n    /// @dev Compute the natural exponent for a fixed-point number EXP_MIN_VAL <= `x` <= 1\\n    function exp(int256 x) internal pure returns (int256 r) {\\n        if (x < EXP_MIN_VAL) {\\n            // Saturate to zero below EXP_MIN_VAL.\\n            return 0;\\n        }\\n        if (x == 0) {\\n            return FIXED_1;\\n        }\\n        if (x > EXP_MAX_VAL) {\\n            revert(\\\"out-of-bounds\\\");\\n        }\\n\\n        // Rewrite the input as a product of natural exponents and a\\n        // single residual q, where q is a number of small magnitude.\\n        // For example: e^-34.419 = e^(-32 - 2 - 0.25 - 0.125 - 0.044)\\n        //              = e^-32 * e^-2 * e^-0.25 * e^-0.125 * e^-0.044\\n        //              -> q = -0.044\\n\\n        // Multiply with the taylor series for e^q\\n        int256 y;\\n        int256 z;\\n        // q = x % 0.125 (the residual)\\n        z = y = x % 0x0000000000000000000000000000000010000000000000000000000000000000;\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\\n        z = (z * y) / FIXED_1;\\n        r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\\n        r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\\n\\n        // Multiply with the non-residual terms.\\n        x = -x;\\n        // e ^ -32\\n        if ((x & int256(0x0000000000000000000000000000001000000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x00000000000000000000000000000000000000f1aaddd7742e56d32fb9f99744)) /\\n                int256(0x0000000000000000000000000043cbaf42a000812488fc5c220ad7b97bf6e99e); // * e ^ -32\\n        }\\n        // e ^ -16\\n        if ((x & int256(0x0000000000000000000000000000000800000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x00000000000000000000000000000000000afe10820813d65dfe6a33c07f738f)) /\\n                int256(0x000000000000000000000000000005d27a9f51c31b7c2f8038212a0574779991); // * e ^ -16\\n        }\\n        // e ^ -8\\n        if ((x & int256(0x0000000000000000000000000000000400000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x0000000000000000000000000000000002582ab704279e8efd15e0265855c47a)) /\\n                int256(0x0000000000000000000000000000001b4c902e273a58678d6d3bfdb93db96d02); // * e ^ -8\\n        }\\n        // e ^ -4\\n        if ((x & int256(0x0000000000000000000000000000000200000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x000000000000000000000000000000001152aaa3bf81cb9fdb76eae12d029571)) /\\n                int256(0x00000000000000000000000000000003b1cc971a9bb5b9867477440d6d157750); // * e ^ -4\\n        }\\n        // e ^ -2\\n        if ((x & int256(0x0000000000000000000000000000000100000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x000000000000000000000000000000002f16ac6c59de6f8d5d6f63c1482a7c86)) /\\n                int256(0x000000000000000000000000000000015bf0a8b1457695355fb8ac404e7a79e3); // * e ^ -2\\n        }\\n        // e ^ -1\\n        if ((x & int256(0x0000000000000000000000000000000080000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x000000000000000000000000000000004da2cbf1be5827f9eb3ad1aa9866ebb3)) /\\n                int256(0x00000000000000000000000000000000d3094c70f034de4b96ff7d5b6f99fcd8); // * e ^ -1\\n        }\\n        // e ^ -0.5\\n        if ((x & int256(0x0000000000000000000000000000000040000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x0000000000000000000000000000000063afbe7ab2082ba1a0ae5e4eb1b479dc)) /\\n                int256(0x00000000000000000000000000000000a45af1e1f40c333b3de1db4dd55f29a7); // * e ^ -0.5\\n        }\\n        // e ^ -0.25\\n        if ((x & int256(0x0000000000000000000000000000000020000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) /\\n                int256(0x00000000000000000000000000000000910b022db7ae67ce76b441c27035c6a1); // * e ^ -0.25\\n        }\\n        // e ^ -0.125\\n        if ((x & int256(0x0000000000000000000000000000000010000000000000000000000000000000)) != 0) {\\n            r =\\n                (r * int256(0x00000000000000000000000000000000783eafef1c0a8f3978c7f81824d62ebf)) /\\n                int256(0x0000000000000000000000000000000088415abbe9a76bead8d00cf112e4d4a8); // * e ^ -0.125\\n        }\\n    }\\n\\n    /// @dev Returns the multiplication two numbers, reverting on overflow.\\n    function _mul(int256 a, int256 b) private pure returns (int256 c) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        c = a * b;\\n        if (c / a != b || c / b != a) {\\n            revert(\\\"overflow\\\");\\n        }\\n    }\\n\\n    /// @dev Returns the division of two numbers, reverting on division by zero.\\n    function _div(int256 a, int256 b) private pure returns (int256 c) {\\n        if (b == 0) {\\n            revert(\\\"overflow\\\");\\n        }\\n        if (a == MIN_FIXED_VAL && b == -1) {\\n            revert(\\\"overflow\\\");\\n        }\\n        c = a / b;\\n    }\\n\\n    /// @dev Adds two numbers, reverting on overflow.\\n    function _add(int256 a, int256 b) private pure returns (int256 c) {\\n        c = a + b;\\n        if ((a < 0 && b < 0 && c > a) || (a > 0 && b > 0 && c < a)) {\\n            revert(\\\"overflow\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"../upgrades/GraphUpgradeable.sol\\\";\\n\\nimport \\\"./IStaking.sol\\\";\\nimport \\\"./StakingStorage.sol\\\";\\nimport \\\"./libs/Rebates.sol\\\";\\nimport \\\"./libs/Stakes.sol\\\";\\n\\n/**\\n * @title Staking contract\\n */\\ncontract Staking is StakingV1Storage, GraphUpgradeable, IStaking {\\n    using SafeMath for uint256;\\n    using Stakes for Stakes.Indexer;\\n    using Rebates for Rebates.Pool;\\n\\n    // 100% in parts per million\\n    uint32 private constant MAX_PPM = 1000000;\\n\\n    // -- Events --\\n\\n    /**\\n     * @dev Emitted when `indexer` update the delegation parameters for its delegation pool.\\n     */\\n    event DelegationParametersUpdated(\\n        address indexed indexer,\\n        uint32 indexingRewardCut,\\n        uint32 queryFeeCut,\\n        uint32 cooldownBlocks\\n    );\\n\\n    /**\\n     * @dev Emitted when `indexer` stake `tokens` amount.\\n     */\\n    event StakeDeposited(address indexed indexer, uint256 tokens);\\n\\n    /**\\n     * @dev Emitted when `indexer` unstaked and locked `tokens` amount `until` block.\\n     */\\n    event StakeLocked(address indexed indexer, uint256 tokens, uint256 until);\\n\\n    /**\\n     * @dev Emitted when `indexer` withdrew `tokens` staked.\\n     */\\n    event StakeWithdrawn(address indexed indexer, uint256 tokens);\\n\\n    /**\\n     * @dev Emitted when `indexer` was slashed for a total of `tokens` amount.\\n     * Tracks `reward` amount of tokens given to `beneficiary`.\\n     */\\n    event StakeSlashed(\\n        address indexed indexer,\\n        uint256 tokens,\\n        uint256 reward,\\n        address beneficiary\\n    );\\n\\n    /**\\n     * @dev Emitted when `delegator` delegated `tokens` to the `indexer`, the delegator\\n     * gets `shares` for the delegation pool proportionally to the tokens staked.\\n     */\\n    event StakeDelegated(\\n        address indexed indexer,\\n        address indexed delegator,\\n        uint256 tokens,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Emitted when `delegator` undelegated `tokens` from `indexer`.\\n     * Tokens get locked for withdrawal after a period of time.\\n     */\\n    event StakeDelegatedLocked(\\n        address indexed indexer,\\n        address indexed delegator,\\n        uint256 tokens,\\n        uint256 shares,\\n        uint256 until\\n    );\\n\\n    /**\\n     * @dev Emitted when `delegator` withdrew delegated `tokens` from `indexer`.\\n     */\\n    event StakeDelegatedWithdrawn(\\n        address indexed indexer,\\n        address indexed delegator,\\n        uint256 tokens\\n    );\\n\\n    /**\\n     * @dev Emitted when `indexer` allocated `tokens` amount to `subgraphDeploymentID`\\n     * during `epoch`.\\n     * `allocationID` indexer derived address used to identify the allocation.\\n     * `metadata` additional information related to the allocation.\\n     */\\n    event AllocationCreated(\\n        address indexed indexer,\\n        bytes32 indexed subgraphDeploymentID,\\n        uint256 epoch,\\n        uint256 tokens,\\n        address indexed allocationID,\\n        bytes32 metadata\\n    );\\n\\n    /**\\n     * @dev Emitted when `indexer` collected `tokens` amount in `epoch` for `allocationID`.\\n     * These funds are related to `subgraphDeploymentID`.\\n     * The `from` value is the sender of the collected funds.\\n     */\\n    event AllocationCollected(\\n        address indexed indexer,\\n        bytes32 indexed subgraphDeploymentID,\\n        uint256 epoch,\\n        uint256 tokens,\\n        address indexed allocationID,\\n        address from,\\n        uint256 curationFees,\\n        uint256 rebateFees\\n    );\\n\\n    /**\\n     * @dev Emitted when `indexer` close an allocation in `epoch` for `allocationID`.\\n     * An amount of `tokens` get unallocated from `subgraphDeploymentID`.\\n     * The `effectiveAllocation` are the tokens allocated from creation to closing.\\n     * This event also emits the POI (proof of indexing) submitted by the indexer.\\n     * `isDelegator` is true if the sender was one of the indexer's delegators.\\n     */\\n    event AllocationClosed(\\n        address indexed indexer,\\n        bytes32 indexed subgraphDeploymentID,\\n        uint256 epoch,\\n        uint256 tokens,\\n        address indexed allocationID,\\n        uint256 effectiveAllocation,\\n        address sender,\\n        bytes32 poi,\\n        bool isDelegator\\n    );\\n\\n    /**\\n     * @dev Emitted when `indexer` claimed a rebate on `subgraphDeploymentID` during `epoch`\\n     * related to the `forEpoch` rebate pool.\\n     * The rebate is for `tokens` amount and `unclaimedAllocationsCount` are left for claim\\n     * in the rebate pool. `delegationFees` collected and sent to delegation pool.\\n     */\\n    event RebateClaimed(\\n        address indexed indexer,\\n        bytes32 indexed subgraphDeploymentID,\\n        address indexed allocationID,\\n        uint256 epoch,\\n        uint256 forEpoch,\\n        uint256 tokens,\\n        uint256 unclaimedAllocationsCount,\\n        uint256 delegationFees\\n    );\\n\\n    /**\\n     * @dev Emitted when `caller` set `slasher` address as `allowed` to slash stakes.\\n     */\\n    event SlasherUpdate(address indexed caller, address indexed slasher, bool allowed);\\n\\n    /**\\n     * @dev Emitted when `caller` set `assetHolder` address as `allowed` to send funds\\n     * to staking contract.\\n     */\\n    event AssetHolderUpdate(address indexed caller, address indexed assetHolder, bool allowed);\\n\\n    /**\\n     * @dev Emitted when `indexer` set `operator` access.\\n     */\\n    event SetOperator(address indexed indexer, address indexed operator, bool allowed);\\n\\n    /**\\n     * @dev Check if the caller is the slasher.\\n     */\\n    modifier onlySlasher {\\n        require(slashers[msg.sender] == true, \\\"!slasher\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check if the caller is authorized (indexer or operator)\\n     */\\n    function _isAuth(address _indexer) private view returns (bool) {\\n        return msg.sender == _indexer || isOperator(msg.sender, _indexer) == true;\\n    }\\n\\n    /**\\n     * @dev Initialize this contract.\\n     */\\n    function initialize(\\n        address _controller,\\n        uint256 _minimumIndexerStake,\\n        uint32 _thawingPeriod,\\n        uint32 _protocolPercentage,\\n        uint32 _curationPercentage,\\n        uint32 _channelDisputeEpochs,\\n        uint32 _maxAllocationEpochs,\\n        uint32 _delegationUnbondingPeriod,\\n        uint32 _delegationRatio,\\n        uint32 _rebateAlphaNumerator,\\n        uint32 _rebateAlphaDenominator\\n    ) external onlyImpl {\\n        Managed._initialize(_controller);\\n\\n        // Settings\\n        _setMinimumIndexerStake(_minimumIndexerStake);\\n        _setThawingPeriod(_thawingPeriod);\\n\\n        _setProtocolPercentage(_protocolPercentage);\\n        _setCurationPercentage(_curationPercentage);\\n\\n        _setChannelDisputeEpochs(_channelDisputeEpochs);\\n        _setMaxAllocationEpochs(_maxAllocationEpochs);\\n\\n        _setDelegationUnbondingPeriod(_delegationUnbondingPeriod);\\n        _setDelegationRatio(_delegationRatio);\\n        _setDelegationParametersCooldown(0);\\n        _setDelegationTaxPercentage(0);\\n\\n        _setRebateRatio(_rebateAlphaNumerator, _rebateAlphaDenominator);\\n    }\\n\\n    /**\\n     * @dev Set the minimum indexer stake required to.\\n     * @param _minimumIndexerStake Minimum indexer stake\\n     */\\n    function setMinimumIndexerStake(uint256 _minimumIndexerStake) external override onlyGovernor {\\n        _setMinimumIndexerStake(_minimumIndexerStake);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the minimum indexer stake required.\\n     * @param _minimumIndexerStake Minimum indexer stake\\n     */\\n    function _setMinimumIndexerStake(uint256 _minimumIndexerStake) private {\\n        require(_minimumIndexerStake > 0, \\\"!minimumIndexerStake\\\");\\n        minimumIndexerStake = _minimumIndexerStake;\\n        emit ParameterUpdated(\\\"minimumIndexerStake\\\");\\n    }\\n\\n    /**\\n     * @dev Set the thawing period for unstaking.\\n     * @param _thawingPeriod Period in blocks to wait for token withdrawals after unstaking\\n     */\\n    function setThawingPeriod(uint32 _thawingPeriod) external override onlyGovernor {\\n        _setThawingPeriod(_thawingPeriod);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the thawing period for unstaking.\\n     * @param _thawingPeriod Period in blocks to wait for token withdrawals after unstaking\\n     */\\n    function _setThawingPeriod(uint32 _thawingPeriod) private {\\n        require(_thawingPeriod > 0, \\\"!thawingPeriod\\\");\\n        thawingPeriod = _thawingPeriod;\\n        emit ParameterUpdated(\\\"thawingPeriod\\\");\\n    }\\n\\n    /**\\n     * @dev Set the curation percentage of query fees sent to curators.\\n     * @param _percentage Percentage of query fees sent to curators\\n     */\\n    function setCurationPercentage(uint32 _percentage) external override onlyGovernor {\\n        _setCurationPercentage(_percentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the curation percentage of query fees sent to curators.\\n     * @param _percentage Percentage of query fees sent to curators\\n     */\\n    function _setCurationPercentage(uint32 _percentage) private {\\n        // Must be within 0% to 100% (inclusive)\\n        require(_percentage <= MAX_PPM, \\\">percentage\\\");\\n        curationPercentage = _percentage;\\n        emit ParameterUpdated(\\\"curationPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Set a protocol percentage to burn when collecting query fees.\\n     * @param _percentage Percentage of query fees to burn as protocol fee\\n     */\\n    function setProtocolPercentage(uint32 _percentage) external override onlyGovernor {\\n        _setProtocolPercentage(_percentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set a protocol percentage to burn when collecting query fees.\\n     * @param _percentage Percentage of query fees to burn as protocol fee\\n     */\\n    function _setProtocolPercentage(uint32 _percentage) private {\\n        // Must be within 0% to 100% (inclusive)\\n        require(_percentage <= MAX_PPM, \\\">percentage\\\");\\n        protocolPercentage = _percentage;\\n        emit ParameterUpdated(\\\"protocolPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Set the period in epochs that need to pass before fees in rebate pool can be claimed.\\n     * @param _channelDisputeEpochs Period in epochs\\n     */\\n    function setChannelDisputeEpochs(uint32 _channelDisputeEpochs) external override onlyGovernor {\\n        _setChannelDisputeEpochs(_channelDisputeEpochs);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the period in epochs that need to pass before fees in rebate pool can be claimed.\\n     * @param _channelDisputeEpochs Period in epochs\\n     */\\n    function _setChannelDisputeEpochs(uint32 _channelDisputeEpochs) private {\\n        require(_channelDisputeEpochs > 0, \\\"!channelDisputeEpochs\\\");\\n        channelDisputeEpochs = _channelDisputeEpochs;\\n        emit ParameterUpdated(\\\"channelDisputeEpochs\\\");\\n    }\\n\\n    /**\\n     * @dev Set the max time allowed for indexers stake on allocations.\\n     * @param _maxAllocationEpochs Allocation duration limit in epochs\\n     */\\n    function setMaxAllocationEpochs(uint32 _maxAllocationEpochs) external override onlyGovernor {\\n        _setMaxAllocationEpochs(_maxAllocationEpochs);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the max time allowed for indexers stake on allocations.\\n     * @param _maxAllocationEpochs Allocation duration limit in epochs\\n     */\\n    function _setMaxAllocationEpochs(uint32 _maxAllocationEpochs) private {\\n        maxAllocationEpochs = _maxAllocationEpochs;\\n        emit ParameterUpdated(\\\"maxAllocationEpochs\\\");\\n    }\\n\\n    /**\\n     * @dev Set the rebate ratio (fees to allocated stake).\\n     * @param _alphaNumerator Numerator of `alpha` in the cobb-douglas function\\n     * @param _alphaDenominator Denominator of `alpha` in the cobb-douglas function\\n     */\\n    function setRebateRatio(uint32 _alphaNumerator, uint32 _alphaDenominator)\\n        external\\n        override\\n        onlyGovernor\\n    {\\n        _setRebateRatio(_alphaNumerator, _alphaDenominator);\\n    }\\n\\n    /**\\n     * @dev Set the rebate ratio (fees to allocated stake).\\n     * @param _alphaNumerator Numerator of `alpha` in the cobb-douglas function\\n     * @param _alphaDenominator Denominator of `alpha` in the cobb-douglas function\\n     */\\n    function _setRebateRatio(uint32 _alphaNumerator, uint32 _alphaDenominator) private {\\n        require(_alphaNumerator > 0 && _alphaDenominator > 0, \\\"!alpha\\\");\\n        alphaNumerator = _alphaNumerator;\\n        alphaDenominator = _alphaDenominator;\\n        emit ParameterUpdated(\\\"rebateRatio\\\");\\n    }\\n\\n    /**\\n     * @dev Set the delegation ratio.\\n     * If set to 10 it means the indexer can use up to 10x the indexer staked amount\\n     * from their delegated tokens\\n     * @param _delegationRatio Delegation capacity multiplier\\n     */\\n    function setDelegationRatio(uint32 _delegationRatio) external override onlyGovernor {\\n        _setDelegationRatio(_delegationRatio);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the delegation ratio.\\n     * If set to 10 it means the indexer can use up to 10x the indexer staked amount\\n     * from their delegated tokens\\n     * @param _delegationRatio Delegation capacity multiplier\\n     */\\n    function _setDelegationRatio(uint32 _delegationRatio) private {\\n        delegationRatio = _delegationRatio;\\n        emit ParameterUpdated(\\\"delegationRatio\\\");\\n    }\\n\\n    /**\\n     * @dev Set the delegation parameters.\\n     * @param _indexingRewardCut Percentage of indexing rewards left for delegators\\n     * @param _queryFeeCut Percentage of query fees left for delegators\\n     * @param _cooldownBlocks Period that need to pass to update delegation parameters\\n     */\\n    function setDelegationParameters(\\n        uint32 _indexingRewardCut,\\n        uint32 _queryFeeCut,\\n        uint32 _cooldownBlocks\\n    ) public override {\\n        address indexer = msg.sender;\\n\\n        // Incentives must be within bounds\\n        require(_queryFeeCut <= MAX_PPM, \\\">queryFeeCut\\\");\\n        require(_indexingRewardCut <= MAX_PPM, \\\">indexingRewardCut\\\");\\n\\n        // Cooldown period set by indexer cannot be below protocol global setting\\n        require(_cooldownBlocks >= delegationParametersCooldown, \\\"<cooldown\\\");\\n\\n        // Verify the cooldown period passed\\n        DelegationPool storage pool = delegationPools[indexer];\\n        require(\\n            pool.updatedAtBlock == 0 ||\\n                pool.updatedAtBlock.add(uint256(pool.cooldownBlocks)) <= block.number,\\n            \\\"!cooldown\\\"\\n        );\\n\\n        // Update delegation params\\n        pool.indexingRewardCut = _indexingRewardCut;\\n        pool.queryFeeCut = _queryFeeCut;\\n        pool.cooldownBlocks = _cooldownBlocks;\\n        pool.updatedAtBlock = block.number;\\n\\n        emit DelegationParametersUpdated(\\n            indexer,\\n            _indexingRewardCut,\\n            _queryFeeCut,\\n            _cooldownBlocks\\n        );\\n    }\\n\\n    /**\\n     * @dev Set the time in blocks an indexer needs to wait to change delegation parameters.\\n     * @param _blocks Number of blocks to set the delegation parameters cooldown period\\n     */\\n    function setDelegationParametersCooldown(uint32 _blocks) external override onlyGovernor {\\n        _setDelegationParametersCooldown(_blocks);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the time in blocks an indexer needs to wait to change delegation parameters.\\n     * @param _blocks Number of blocks to set the delegation parameters cooldown period\\n     */\\n    function _setDelegationParametersCooldown(uint32 _blocks) private {\\n        delegationParametersCooldown = _blocks;\\n        emit ParameterUpdated(\\\"delegationParametersCooldown\\\");\\n    }\\n\\n    /**\\n     * @dev Set the period for undelegation of stake from indexer.\\n     * @param _delegationUnbondingPeriod Period in epochs to wait for token withdrawals after undelegating\\n     */\\n    function setDelegationUnbondingPeriod(uint32 _delegationUnbondingPeriod)\\n        external\\n        override\\n        onlyGovernor\\n    {\\n        _setDelegationUnbondingPeriod(_delegationUnbondingPeriod);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the period for undelegation of stake from indexer.\\n     * @param _delegationUnbondingPeriod Period in epochs to wait for token withdrawals after undelegating\\n     */\\n    function _setDelegationUnbondingPeriod(uint32 _delegationUnbondingPeriod) private {\\n        require(_delegationUnbondingPeriod > 0, \\\"!delegationUnbondingPeriod\\\");\\n        delegationUnbondingPeriod = _delegationUnbondingPeriod;\\n        emit ParameterUpdated(\\\"delegationUnbondingPeriod\\\");\\n    }\\n\\n    /**\\n     * @dev Set a delegation tax percentage to burn when delegated funds are deposited.\\n     * @param _percentage Percentage of delegated tokens to burn as delegation tax\\n     */\\n    function setDelegationTaxPercentage(uint32 _percentage) external override onlyGovernor {\\n        _setDelegationTaxPercentage(_percentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set a delegation tax percentage to burn when delegated funds are deposited.\\n     * @param _percentage Percentage of delegated tokens to burn as delegation tax\\n     */\\n    function _setDelegationTaxPercentage(uint32 _percentage) private {\\n        // Must be within 0% to 100% (inclusive)\\n        require(_percentage <= MAX_PPM, \\\">percentage\\\");\\n        delegationTaxPercentage = _percentage;\\n        emit ParameterUpdated(\\\"delegationTaxPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Set or unset an address as allowed slasher.\\n     * @param _slasher Address of the party allowed to slash indexers\\n     * @param _allowed True if slasher is allowed\\n     */\\n    function setSlasher(address _slasher, bool _allowed) external override onlyGovernor {\\n        require(_slasher != address(0), \\\"!slasher\\\");\\n        slashers[_slasher] = _allowed;\\n        emit SlasherUpdate(msg.sender, _slasher, _allowed);\\n    }\\n\\n    /**\\n     * @dev Set an address as allowed asset holder.\\n     * @param _assetHolder Address of allowed source for state channel funds\\n     * @param _allowed True if asset holder is allowed\\n     */\\n    function setAssetHolder(address _assetHolder, bool _allowed) external override onlyGovernor {\\n        require(_assetHolder != address(0), \\\"!assetHolder\\\");\\n        assetHolders[_assetHolder] = _allowed;\\n        emit AssetHolderUpdate(msg.sender, _assetHolder, _allowed);\\n    }\\n\\n    /**\\n     * @dev Return if allocationID is used.\\n     * @param _allocationID Address used as signer by the indexer for an allocation\\n     * @return True if allocationID already used\\n     */\\n    function isAllocation(address _allocationID) external override view returns (bool) {\\n        return _getAllocationState(_allocationID) != AllocationState.Null;\\n    }\\n\\n    /**\\n     * @dev Getter that returns if an indexer has any stake.\\n     * @param _indexer Address of the indexer\\n     * @return True if indexer has staked tokens\\n     */\\n    function hasStake(address _indexer) external override view returns (bool) {\\n        return stakes[_indexer].hasTokens();\\n    }\\n\\n    /**\\n     * @dev Return the allocation by ID.\\n     * @param _allocationID Address used as allocation identifier\\n     * @return Allocation data\\n     */\\n    function getAllocation(address _allocationID)\\n        external\\n        override\\n        view\\n        returns (Allocation memory)\\n    {\\n        return allocations[_allocationID];\\n    }\\n\\n    /**\\n     * @dev Return the current state of an allocation.\\n     * @param _allocationID Address used as the allocation identifier\\n     * @return AllocationState\\n     */\\n    function getAllocationState(address _allocationID)\\n        external\\n        override\\n        view\\n        returns (AllocationState)\\n    {\\n        return _getAllocationState(_allocationID);\\n    }\\n\\n    /**\\n     * @dev Return the total amount of tokens allocated to subgraph.\\n     * @param _subgraphDeploymentID Address used as the allocation identifier\\n     * @return Total tokens allocated to subgraph\\n     */\\n    function getSubgraphAllocatedTokens(bytes32 _subgraphDeploymentID)\\n        external\\n        override\\n        view\\n        returns (uint256)\\n    {\\n        return subgraphAllocations[_subgraphDeploymentID];\\n    }\\n\\n    /**\\n     * @dev Return the delegation from a delegator to an indexer.\\n     * @param _indexer Address of the indexer where funds have been delegated\\n     * @param _delegator Address of the delegator\\n     * @return Delegation data\\n     */\\n    function getDelegation(address _indexer, address _delegator)\\n        external\\n        override\\n        view\\n        returns (Delegation memory)\\n    {\\n        return delegationPools[_indexer].delegators[_delegator];\\n    }\\n\\n    /**\\n     * @dev Return whether the delegator has delegated to the indexer.\\n     * @param _indexer Address of the indexer where funds have been delegated\\n     * @param _delegator Address of the delegator\\n     * @return True if delegator of indexer\\n     */\\n    function isDelegator(address _indexer, address _delegator) public override view returns (bool) {\\n        return delegationPools[_indexer].delegators[_delegator].shares > 0;\\n    }\\n\\n    /**\\n     * @dev Get the total amount of tokens staked by the indexer.\\n     * @param _indexer Address of the indexer\\n     * @return Amount of tokens staked by the indexer\\n     */\\n    function getIndexerStakedTokens(address _indexer) external override view returns (uint256) {\\n        return stakes[_indexer].tokensStaked;\\n    }\\n\\n    /**\\n     * @dev Get the total amount of tokens available to use in allocations.\\n     * This considers the indexer stake and delegated tokens according to delegation ratio\\n     * @param _indexer Address of the indexer\\n     * @return Amount of tokens staked by the indexer\\n     */\\n    function getIndexerCapacity(address _indexer) public override view returns (uint256) {\\n        Stakes.Indexer memory indexerStake = stakes[_indexer];\\n        uint256 tokensDelegated = delegationPools[_indexer].tokens;\\n\\n        uint256 tokensDelegatedCap = indexerStake.tokensSecureStake().mul(uint256(delegationRatio));\\n        uint256 tokensDelegatedCapacity = (tokensDelegated < tokensDelegatedCap)\\n            ? tokensDelegated\\n            : tokensDelegatedCap;\\n\\n        return indexerStake.tokensAvailableWithDelegation(tokensDelegatedCapacity);\\n    }\\n\\n    /**\\n     * @dev Returns amount of delegated tokens ready to be withdrawn after unbonding period.\\n     * @param _delegation Delegation of tokens from delegator to indexer\\n     * @return Amount of tokens to withdraw\\n     */\\n    function getWithdraweableDelegatedTokens(Delegation memory _delegation)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        // There must be locked tokens and period passed\\n        uint256 currentEpoch = epochManager().currentEpoch();\\n        if (_delegation.tokensLockedUntil > 0 && currentEpoch >= _delegation.tokensLockedUntil) {\\n            return _delegation.tokensLocked;\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Authorize or unauthorize an address to be an operator.\\n     * @param _operator Address to authorize\\n     * @param _allowed Whether authorized or not\\n     */\\n    function setOperator(address _operator, bool _allowed) external override {\\n        require(_operator != msg.sender, \\\"operator == sender\\\");\\n        operatorAuth[msg.sender][_operator] = _allowed;\\n        emit SetOperator(msg.sender, _operator, _allowed);\\n    }\\n\\n    /**\\n     * @dev Return true if operator is allowed for indexer.\\n     * @param _operator Address of the operator\\n     * @param _indexer Address of the indexer\\n     */\\n    function isOperator(address _operator, address _indexer) public override view returns (bool) {\\n        return operatorAuth[_indexer][_operator];\\n    }\\n\\n    /**\\n     * @dev Deposit tokens on the indexer stake.\\n     * @param _tokens Amount of tokens to stake\\n     */\\n    function stake(uint256 _tokens) external override {\\n        stakeTo(msg.sender, _tokens);\\n    }\\n\\n    /**\\n     * @dev Deposit tokens on the indexer stake.\\n     * @param _indexer Address of the indexer\\n     * @param _tokens Amount of tokens to stake\\n     */\\n    function stakeTo(address _indexer, uint256 _tokens) public override notPartialPaused {\\n        require(_tokens > 0, \\\"!tokens\\\");\\n\\n        // Ensure minimum stake\\n        require(\\n            stakes[_indexer].tokensSecureStake().add(_tokens) >= minimumIndexerStake,\\n            \\\"!minimumIndexerStake\\\"\\n        );\\n\\n        // Transfer tokens to stake from caller to this contract\\n        require(graphToken().transferFrom(msg.sender, address(this), _tokens), \\\"!transfer\\\");\\n\\n        // Stake the transferred tokens\\n        _stake(_indexer, _tokens);\\n    }\\n\\n    /**\\n     * @dev Unstake tokens from the indexer stake, lock them until thawing period expires.\\n     * @param _tokens Amount of tokens to unstake\\n     */\\n    function unstake(uint256 _tokens) external override notPartialPaused {\\n        address indexer = msg.sender;\\n        Stakes.Indexer storage indexerStake = stakes[indexer];\\n\\n        require(_tokens > 0, \\\"!tokens\\\");\\n        require(indexerStake.hasTokens(), \\\"!stake\\\");\\n        require(indexerStake.tokensAvailable() >= _tokens, \\\"!stake-avail\\\");\\n\\n        // Ensure minimum stake\\n        uint256 newStake = indexerStake.tokensSecureStake().sub(_tokens);\\n        require(newStake == 0 || newStake >= minimumIndexerStake, \\\"!minimumIndexerStake\\\");\\n\\n        // Before locking more tokens, withdraw any unlocked ones\\n        uint256 tokensToWithdraw = indexerStake.tokensWithdrawable();\\n        if (tokensToWithdraw > 0) {\\n            _withdraw(indexer);\\n        }\\n\\n        indexerStake.lockTokens(_tokens, thawingPeriod);\\n\\n        emit StakeLocked(indexer, indexerStake.tokensLocked, indexerStake.tokensLockedUntil);\\n    }\\n\\n    /**\\n     * @dev Withdraw indexer tokens once the thawing period has passed.\\n     */\\n    function withdraw() external override notPaused {\\n        _withdraw(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Slash the indexer stake. Delegated tokens are not subject to slashing.\\n     * Can only be called by the slasher role.\\n     * @param _indexer Address of indexer to slash\\n     * @param _tokens Amount of tokens to slash from the indexer stake\\n     * @param _reward Amount of reward tokens to send to a beneficiary\\n     * @param _beneficiary Address of a beneficiary to receive a reward for the slashing\\n     */\\n    function slash(\\n        address _indexer,\\n        uint256 _tokens,\\n        uint256 _reward,\\n        address _beneficiary\\n    ) external override onlySlasher notPartialPaused {\\n        Stakes.Indexer storage indexerStake = stakes[_indexer];\\n\\n        // Only able to slash a non-zero number of tokens\\n        require(_tokens > 0, \\\"!tokens\\\");\\n\\n        // Rewards comes from tokens slashed balance\\n        require(_tokens >= _reward, \\\"rewards>slash\\\");\\n\\n        // Cannot slash stake of an indexer without any or enough stake\\n        require(indexerStake.hasTokens(), \\\"!stake\\\");\\n        require(_tokens <= indexerStake.tokensStaked, \\\"slash>stake\\\");\\n\\n        // Validate beneficiary of slashed tokens\\n        require(_beneficiary != address(0), \\\"!beneficiary\\\");\\n\\n        // Slashing more tokens than freely available (over allocation condition)\\n        // Unlock locked tokens to avoid the indexer to withdraw them\\n        if (_tokens > indexerStake.tokensAvailable() && indexerStake.tokensLocked > 0) {\\n            uint256 tokensOverAllocated = _tokens.sub(indexerStake.tokensAvailable());\\n            uint256 tokensToUnlock = (tokensOverAllocated > indexerStake.tokensLocked)\\n                ? indexerStake.tokensLocked\\n                : tokensOverAllocated;\\n            indexerStake.unlockTokens(tokensToUnlock);\\n        }\\n\\n        // Remove tokens to slash from the stake\\n        indexerStake.release(_tokens);\\n\\n        // -- Interactions --\\n\\n        IGraphToken graphToken = graphToken();\\n\\n        // Set apart the reward for the beneficiary and burn remaining slashed stake\\n        _burnTokens(graphToken, _tokens.sub(_reward));\\n\\n        // Give the beneficiary a reward for slashing\\n        if (_reward > 0) {\\n            require(graphToken.transfer(_beneficiary, _reward), \\\"!transfer\\\");\\n        }\\n\\n        emit StakeSlashed(_indexer, _tokens, _reward, _beneficiary);\\n    }\\n\\n    /**\\n     * @dev Delegate tokens to an indexer.\\n     * @param _indexer Address of the indexer to delegate tokens to\\n     * @param _tokens Amount of tokens to delegate\\n     * @return Amount of shares issued of the delegation pool\\n     */\\n    function delegate(address _indexer, uint256 _tokens)\\n        external\\n        override\\n        notPartialPaused\\n        returns (uint256)\\n    {\\n        address delegator = msg.sender;\\n\\n        // Transfer tokens to delegate to this contract\\n        require(graphToken().transferFrom(delegator, address(this), _tokens), \\\"!transfer\\\");\\n\\n        // Update state\\n        return _delegate(delegator, _indexer, _tokens);\\n    }\\n\\n    /**\\n     * @dev Undelegate tokens from an indexer.\\n     * @param _indexer Address of the indexer where tokens had been delegated\\n     * @param _shares Amount of shares to return and undelegate tokens\\n     * @return Amount of tokens returned for the shares of the delegation pool\\n     */\\n    function undelegate(address _indexer, uint256 _shares)\\n        external\\n        override\\n        notPartialPaused\\n        returns (uint256)\\n    {\\n        return _undelegate(msg.sender, _indexer, _shares);\\n    }\\n\\n    /**\\n     * @dev Withdraw delegated tokens once the unbonding period has passed.\\n     * @param _indexer Withdraw available tokens delegated to indexer\\n     * @param _delegateToIndexer Re-delegate to indexer address if non-zero, withdraw if zero address\\n     */\\n    function withdrawDelegated(address _indexer, address _delegateToIndexer)\\n        external\\n        override\\n        notPaused\\n        returns (uint256)\\n    {\\n        return _withdrawDelegated(msg.sender, _indexer, _delegateToIndexer);\\n    }\\n\\n    /**\\n     * @dev Allocate available tokens to a subgraph deployment.\\n     * @param _subgraphDeploymentID ID of the SubgraphDeployment where tokens will be allocated\\n     * @param _tokens Amount of tokens to allocate\\n     * @param _allocationID The allocation identifier\\n     * @param _metadata IPFS hash for additional information about the allocation\\n     * @param _proof A 65-bytes Ethereum signed message of `keccak256(indexerAddress,allocationID)`\\n     */\\n    function allocate(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external override notPaused {\\n        _allocate(msg.sender, _subgraphDeploymentID, _tokens, _allocationID, _metadata, _proof);\\n    }\\n\\n    /**\\n     * @dev Allocate available tokens to a subgraph deployment.\\n     * @param _indexer Indexer address to allocate funds from.\\n     * @param _subgraphDeploymentID ID of the SubgraphDeployment where tokens will be allocated\\n     * @param _tokens Amount of tokens to allocate\\n     * @param _allocationID The allocation identifier\\n     * @param _metadata IPFS hash for additional information about the allocation\\n     * @param _proof A 65-bytes Ethereum signed message of `keccak256(indexerAddress,allocationID)`\\n     */\\n    function allocateFrom(\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external override notPaused {\\n        _allocate(_indexer, _subgraphDeploymentID, _tokens, _allocationID, _metadata, _proof);\\n    }\\n\\n    /**\\n     * @dev Close an allocation and free the staked tokens.\\n     * To be eligible for rewards a proof of indexing must be presented.\\n     * Presenting a bad proof is subject to slashable condition.\\n     * To opt out for rewards set _poi to 0x0\\n     * @param _allocationID The allocation identifier\\n     * @param _poi Proof of indexing submitted for the allocated period\\n     */\\n    function closeAllocation(address _allocationID, bytes32 _poi) external override notPaused {\\n        _closeAllocation(_allocationID, _poi);\\n    }\\n\\n    /**\\n     * @dev Close multiple allocations and free the staked tokens.\\n     * To be eligible for rewards a proof of indexing must be presented.\\n     * Presenting a bad proof is subject to slashable condition.\\n     * To opt out for rewards set _poi to 0x0\\n     * @param _requests An array of CloseAllocationRequest\\n     */\\n    function closeAllocationMany(CloseAllocationRequest[] calldata _requests)\\n        external\\n        override\\n        notPaused\\n    {\\n        for (uint256 i = 0; i < _requests.length; i++) {\\n            _closeAllocation(_requests[i].allocationID, _requests[i].poi);\\n        }\\n    }\\n\\n    /**\\n     * @dev Close and allocate. This will perform a close and then create a new Allocation\\n     * atomically on the same transaction.\\n     * @param _closingAllocationID The identifier of the allocation to be closed\\n     * @param _poi Proof of indexing submitted for the allocated period\\n     * @param _indexer Indexer address to allocate funds from.\\n     * @param _subgraphDeploymentID ID of the SubgraphDeployment where tokens will be allocated\\n     * @param _tokens Amount of tokens to allocate\\n     * @param _allocationID The allocation identifier\\n     * @param _metadata IPFS hash for additional information about the allocation\\n     * @param _proof A 65-bytes Ethereum signed message of `keccak256(indexerAddress,allocationID)`\\n     */\\n    function closeAndAllocate(\\n        address _closingAllocationID,\\n        bytes32 _poi,\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external override notPaused {\\n        _closeAllocation(_closingAllocationID, _poi);\\n        _allocate(_indexer, _subgraphDeploymentID, _tokens, _allocationID, _metadata, _proof);\\n    }\\n\\n    /**\\n     * @dev Collect query fees for an allocation from state channels.\\n     * Funds received are only accepted from a valid sender.\\n     * @param _tokens Amount of tokens to collect\\n     * @param _allocationID Allocation where the tokens will be assigned\\n     */\\n    function collect(uint256 _tokens, address _allocationID) external override {\\n        // Allocation identifier validation\\n        require(_allocationID != address(0), \\\"!alloc\\\");\\n\\n        // The contract caller must be an authorized asset holder\\n        require(assetHolders[msg.sender] == true, \\\"!assetHolder\\\");\\n\\n        // Allocation must exist\\n        AllocationState allocState = _getAllocationState(_allocationID);\\n        require(allocState != AllocationState.Null, \\\"!collect\\\");\\n\\n        // Get allocation\\n        Allocation storage alloc = allocations[_allocationID];\\n        uint256 queryFees = _tokens;\\n        uint256 curationFees = 0;\\n        bytes32 subgraphDeploymentID = alloc.subgraphDeploymentID;\\n\\n        // Process query fees only if non-zero amount\\n        if (queryFees > 0) {\\n            // Pull tokens to collect from the authorized sender\\n            IGraphToken graphToken = graphToken();\\n            require(graphToken.transferFrom(msg.sender, address(this), _tokens), \\\"!transfer\\\");\\n\\n            // -- Collect protocol tax --\\n            // If the Allocation is not active or closed we are going to charge a 100% protocol tax\\n            uint256 usedProtocolPercentage = (allocState == AllocationState.Active ||\\n                allocState == AllocationState.Closed)\\n                ? protocolPercentage\\n                : MAX_PPM;\\n            uint256 protocolTax = _collectTax(graphToken, queryFees, usedProtocolPercentage);\\n            queryFees = queryFees.sub(protocolTax);\\n\\n            // -- Collect curation fees --\\n            // Only if the subgraph deployment is curated\\n            curationFees = _collectCurationFees(\\n                graphToken,\\n                subgraphDeploymentID,\\n                queryFees,\\n                curationPercentage\\n            );\\n            queryFees = queryFees.sub(curationFees);\\n\\n            // Add funds to the allocation\\n            alloc.collectedFees = alloc.collectedFees.add(queryFees);\\n\\n            // When allocation is closed redirect funds to the rebate pool\\n            // This way we can keep collecting tokens even after the allocation is closed and\\n            // before it gets to the finalized state.\\n            if (allocState == AllocationState.Closed) {\\n                Rebates.Pool storage rebatePool = rebates[alloc.closedAtEpoch];\\n                rebatePool.fees = rebatePool.fees.add(queryFees);\\n            }\\n        }\\n\\n        emit AllocationCollected(\\n            alloc.indexer,\\n            subgraphDeploymentID,\\n            epochManager().currentEpoch(),\\n            _tokens,\\n            _allocationID,\\n            msg.sender,\\n            curationFees,\\n            queryFees\\n        );\\n    }\\n\\n    /**\\n     * @dev Claim tokens from the rebate pool.\\n     * @param _allocationID Allocation from where we are claiming tokens\\n     * @param _restake True if restake fees instead of transfer to indexer\\n     */\\n    function claim(address _allocationID, bool _restake) external override notPaused {\\n        _claim(_allocationID, _restake);\\n    }\\n\\n    /**\\n     * @dev Claim tokens from the rebate pool for many allocations.\\n     * @param _allocationID Array of allocations from where we are claiming tokens\\n     * @param _restake True if restake fees instead of transfer to indexer\\n     */\\n    function claimMany(address[] calldata _allocationID, bool _restake)\\n        external\\n        override\\n        notPaused\\n    {\\n        for (uint256 i = 0; i < _allocationID.length; i++) {\\n            _claim(_allocationID[i], _restake);\\n        }\\n    }\\n\\n    /**\\n     * @dev Stake tokens on the indexer.\\n     * This function does not check minimum indexer stake requirement to allow\\n     * to be called by functions that increase the stake when collecting rewards\\n     * without reverting\\n     * @param _indexer Address of staking party\\n     * @param _tokens Amount of tokens to stake\\n     */\\n    function _stake(address _indexer, uint256 _tokens) private {\\n        // Deposit tokens into the indexer stake\\n        stakes[_indexer].deposit(_tokens);\\n\\n        // Initialize the delegation pool the first time\\n        if (delegationPools[_indexer].updatedAtBlock == 0) {\\n            setDelegationParameters(MAX_PPM, MAX_PPM, delegationParametersCooldown);\\n        }\\n\\n        emit StakeDeposited(_indexer, _tokens);\\n    }\\n\\n    /**\\n     * @dev Withdraw indexer tokens once the thawing period has passed.\\n     * @param _indexer Address of indexer to withdraw funds from\\n     */\\n    function _withdraw(address _indexer) private {\\n        // Get tokens available for withdraw and update balance\\n        uint256 tokensToWithdraw = stakes[_indexer].withdrawTokens();\\n        require(tokensToWithdraw > 0, \\\"!tokens\\\");\\n\\n        // Return tokens to the indexer\\n        require(graphToken().transfer(_indexer, tokensToWithdraw), \\\"!transfer\\\");\\n\\n        emit StakeWithdrawn(_indexer, tokensToWithdraw);\\n    }\\n\\n    /**\\n     * @dev Allocate available tokens to a subgraph deployment.\\n     * @param _indexer Indexer address to allocate funds from.\\n     * @param _subgraphDeploymentID ID of the SubgraphDeployment where tokens will be allocated\\n     * @param _tokens Amount of tokens to allocate\\n     * @param _allocationID The allocationID will work to identify collected funds related to this allocation\\n     * @param _metadata Metadata related to the allocation\\n     * @param _proof A 65-bytes Ethereum signed message of `keccak256(indexerAddress,allocationID)`\\n     */\\n    function _allocate(\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) private {\\n        require(_isAuth(_indexer), \\\"!auth\\\");\\n\\n        // Only allocations with a non-zero token amount are allowed\\n        require(_tokens > 0, \\\"!tokens\\\");\\n\\n        // Check allocation\\n        require(_allocationID != address(0), \\\"!alloc\\\");\\n        require(_getAllocationState(_allocationID) == AllocationState.Null, \\\"!null\\\");\\n\\n        // Caller must prove that they own the private key for the allocationID adddress\\n        // The proof is an Ethereum signed message of KECCAK256(indexerAddress,allocationID)\\n        bytes32 messageHash = keccak256(abi.encodePacked(_indexer, _allocationID));\\n        bytes32 digest = ECDSA.toEthSignedMessageHash(messageHash);\\n        require(ECDSA.recover(digest, _proof) == _allocationID, \\\"!proof\\\");\\n\\n        // Needs to have free capacity not used for other purposes to allocate\\n        require(getIndexerCapacity(_indexer) >= _tokens, \\\"!capacity\\\");\\n\\n        // Creates an allocation\\n        // Allocation identifiers are not reused\\n        // The assetHolder address can send collected funds to the allocation\\n        Allocation memory alloc = Allocation(\\n            _indexer,\\n            _subgraphDeploymentID,\\n            _tokens, // Tokens allocated\\n            epochManager().currentEpoch(), // createdAtEpoch\\n            0, // closedAtEpoch\\n            0, // Initialize collected fees\\n            0, // Initialize effective allocation\\n            _updateRewards(_subgraphDeploymentID) // Initialize accumulated rewards per stake allocated\\n        );\\n        allocations[_allocationID] = alloc;\\n\\n        // Mark allocated tokens as used\\n        stakes[_indexer].allocate(alloc.tokens);\\n\\n        // Track total allocations per subgraph\\n        // Used for rewards calculations\\n        subgraphAllocations[alloc.subgraphDeploymentID] = subgraphAllocations[alloc\\n            .subgraphDeploymentID]\\n            .add(alloc.tokens);\\n\\n        emit AllocationCreated(\\n            _indexer,\\n            _subgraphDeploymentID,\\n            alloc.createdAtEpoch,\\n            alloc.tokens,\\n            _allocationID,\\n            _metadata\\n        );\\n    }\\n\\n    /**\\n     * @dev Close an allocation and free the staked tokens.\\n     * @param _allocationID The allocation identifier\\n     * @param _poi Proof of indexing submitted for the allocated period\\n     */\\n    function _closeAllocation(address _allocationID, bytes32 _poi) private {\\n        // Allocation must exist and be active\\n        AllocationState allocState = _getAllocationState(_allocationID);\\n        require(allocState == AllocationState.Active, \\\"!active\\\");\\n\\n        // Get allocation\\n        Allocation memory alloc = allocations[_allocationID];\\n\\n        // Validate that an allocation cannot be closed before one epoch\\n        alloc.closedAtEpoch = epochManager().currentEpoch();\\n        uint256 epochs = alloc.createdAtEpoch < alloc.closedAtEpoch\\n            ? alloc.closedAtEpoch.sub(alloc.createdAtEpoch)\\n            : 0;\\n        require(epochs > 0, \\\"<epochs\\\");\\n\\n        // Indexer or operator can close an allocation\\n        // Delegators are also allowed but only after maxAllocationEpochs passed\\n        bool isIndexer = _isAuth(alloc.indexer);\\n        if (epochs > maxAllocationEpochs) {\\n            require(isIndexer || isDelegator(alloc.indexer, msg.sender), \\\"!auth-or-del\\\");\\n        } else {\\n            require(isIndexer, \\\"!auth\\\");\\n        }\\n\\n        // Calculate effective allocation for the amount of epochs it remained allocated\\n        alloc.effectiveAllocation = _getEffectiveAllocation(\\n            maxAllocationEpochs,\\n            alloc.tokens,\\n            epochs\\n        );\\n\\n        // Close the allocation and start counting a period to settle remaining payments from\\n        // state channels.\\n        allocations[_allocationID].closedAtEpoch = alloc.closedAtEpoch;\\n        allocations[_allocationID].effectiveAllocation = alloc.effectiveAllocation;\\n\\n        // Account collected fees and effective allocation in rebate pool for the epoch\\n        Rebates.Pool storage rebatePool = rebates[alloc.closedAtEpoch];\\n        if (!rebatePool.exists()) {\\n            rebatePool.init(alphaNumerator, alphaDenominator);\\n        }\\n        rebatePool.addToPool(alloc.collectedFees, alloc.effectiveAllocation);\\n\\n        // Distribute rewards if proof of indexing was presented by the indexer or operator\\n        if (isIndexer && _poi != 0) {\\n            _distributeRewards(_allocationID, alloc.indexer);\\n        }\\n\\n        // Free allocated tokens from use\\n        stakes[alloc.indexer].unallocate(alloc.tokens);\\n\\n        // Track total allocations per subgraph\\n        // Used for rewards calculations\\n        subgraphAllocations[alloc.subgraphDeploymentID] = subgraphAllocations[alloc\\n            .subgraphDeploymentID]\\n            .sub(alloc.tokens);\\n\\n        emit AllocationClosed(\\n            alloc.indexer,\\n            alloc.subgraphDeploymentID,\\n            alloc.closedAtEpoch,\\n            alloc.tokens,\\n            _allocationID,\\n            alloc.effectiveAllocation,\\n            msg.sender,\\n            _poi,\\n            !isIndexer\\n        );\\n    }\\n\\n    /**\\n     * @dev Claim tokens from the rebate pool.\\n     * @param _allocationID Allocation from where we are claiming tokens\\n     * @param _restake True if restake fees instead of transfer to indexer\\n     */\\n    function _claim(address _allocationID, bool _restake) private {\\n        // Funds can only be claimed after a period of time passed since allocation was closed\\n        AllocationState allocState = _getAllocationState(_allocationID);\\n        require(allocState == AllocationState.Finalized, \\\"!finalized\\\");\\n\\n        // Get allocation\\n        Allocation memory alloc = allocations[_allocationID];\\n\\n        // Only the indexer or operator can decide if to restake\\n        bool restake = _isAuth(alloc.indexer) ? _restake : false;\\n\\n        // Process rebate reward\\n        Rebates.Pool storage rebatePool = rebates[alloc.closedAtEpoch];\\n        uint256 tokensToClaim = rebatePool.redeem(alloc.collectedFees, alloc.effectiveAllocation);\\n\\n        // Add delegation rewards to the delegation pool\\n        uint256 delegationRewards = _collectDelegationQueryRewards(alloc.indexer, tokensToClaim);\\n        tokensToClaim = tokensToClaim.sub(delegationRewards);\\n\\n        // Purge allocation data except for:\\n        // - indexer: used in disputes and to avoid reusing an allocationID\\n        // - subgraphDeploymentID: used in disputes\\n        allocations[_allocationID].tokens = 0; // This avoid collect(), close() and claim() to be called\\n        allocations[_allocationID].createdAtEpoch = 0;\\n        allocations[_allocationID].closedAtEpoch = 0;\\n        allocations[_allocationID].collectedFees = 0;\\n        allocations[_allocationID].effectiveAllocation = 0;\\n        allocations[_allocationID].accRewardsPerAllocatedToken = 0;\\n\\n        // -- Interactions --\\n\\n        IGraphToken graphToken = graphToken();\\n\\n        // When all allocations processed then burn unclaimed fees and prune rebate pool\\n        if (rebatePool.unclaimedAllocationsCount == 0) {\\n            _burnTokens(graphToken, rebatePool.unclaimedFees());\\n            delete rebates[alloc.closedAtEpoch];\\n        }\\n\\n        // When there are tokens to claim from the rebate pool, transfer or restake\\n        if (tokensToClaim > 0) {\\n            // Assign claimed tokens\\n            if (restake) {\\n                // Restake to place fees into the indexer stake\\n                _stake(alloc.indexer, tokensToClaim);\\n            } else {\\n                // Transfer funds back to the indexer\\n                require(graphToken.transfer(alloc.indexer, tokensToClaim), \\\"!transfer\\\");\\n            }\\n        }\\n\\n        emit RebateClaimed(\\n            alloc.indexer,\\n            alloc.subgraphDeploymentID,\\n            _allocationID,\\n            epochManager().currentEpoch(),\\n            alloc.closedAtEpoch,\\n            tokensToClaim,\\n            rebatePool.unclaimedAllocationsCount,\\n            delegationRewards\\n        );\\n    }\\n\\n    /**\\n     * @dev Delegate tokens to an indexer.\\n     * @param _delegator Address of the delegator\\n     * @param _indexer Address of the indexer to delegate tokens to\\n     * @param _tokens Amount of tokens to delegate\\n     * @return Amount of shares issued of the delegation pool\\n     */\\n    function _delegate(\\n        address _delegator,\\n        address _indexer,\\n        uint256 _tokens\\n    ) private returns (uint256) {\\n        // Only delegate a non-zero amount of tokens\\n        require(_tokens > 0, \\\"!tokens\\\");\\n        // Only delegate to non-empty address\\n        require(_indexer != address(0), \\\"!indexer\\\");\\n        // Only delegate to staked indexer\\n        require(stakes[_indexer].hasTokens(), \\\"!stake\\\");\\n\\n        // Get the delegation pool of the indexer\\n        DelegationPool storage pool = delegationPools[_indexer];\\n        Delegation storage delegation = pool.delegators[_delegator];\\n\\n        // Collect delegation tax\\n        uint256 delegationTax = _collectTax(graphToken(), _tokens, delegationTaxPercentage);\\n        uint256 delegatedTokens = _tokens.sub(delegationTax);\\n\\n        // Calculate shares to issue\\n        uint256 shares = (pool.tokens == 0)\\n            ? delegatedTokens\\n            : delegatedTokens.mul(pool.shares).div(pool.tokens);\\n\\n        // Update the delegation pool\\n        pool.tokens = pool.tokens.add(delegatedTokens);\\n        pool.shares = pool.shares.add(shares);\\n\\n        // Update the delegation\\n        delegation.shares = delegation.shares.add(shares);\\n\\n        emit StakeDelegated(_indexer, _delegator, delegatedTokens, shares);\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Undelegate tokens from an indexer.\\n     * @param _delegator Address of the delegator\\n     * @param _indexer Address of the indexer where tokens had been delegated\\n     * @param _shares Amount of shares to return and undelegate tokens\\n     * @return Amount of tokens returned for the shares of the delegation pool\\n     */\\n    function _undelegate(\\n        address _delegator,\\n        address _indexer,\\n        uint256 _shares\\n    ) private returns (uint256) {\\n        // Can only undelegate a non-zero amount of shares\\n        require(_shares > 0, \\\"!shares\\\");\\n\\n        // Get the delegation pool of the indexer\\n        DelegationPool storage pool = delegationPools[_indexer];\\n        Delegation storage delegation = pool.delegators[_delegator];\\n\\n        // Delegator need to have enough shares in the pool to undelegate\\n        require(delegation.shares >= _shares, \\\"!shares-avail\\\");\\n\\n        // Withdraw tokens if available\\n        if (getWithdraweableDelegatedTokens(delegation) > 0) {\\n            _withdrawDelegated(_delegator, _indexer, address(0));\\n        }\\n\\n        // Calculate tokens to get in exchange for the shares\\n        uint256 tokens = _shares.mul(pool.tokens).div(pool.shares);\\n\\n        // Update the delegation pool\\n        pool.tokens = pool.tokens.sub(tokens);\\n        pool.shares = pool.shares.sub(_shares);\\n\\n        // Update the delegation\\n        delegation.shares = delegation.shares.sub(_shares);\\n        delegation.tokensLocked = delegation.tokensLocked.add(tokens);\\n        delegation.tokensLockedUntil = epochManager().currentEpoch().add(delegationUnbondingPeriod);\\n\\n        emit StakeDelegatedLocked(\\n            _indexer,\\n            _delegator,\\n            tokens,\\n            _shares,\\n            delegation.tokensLockedUntil\\n        );\\n\\n        return tokens;\\n    }\\n\\n    /**\\n     * @dev Withdraw delegated tokens once the unbonding period has passed.\\n     * @param _delegator Delegator that is withdrawing tokens\\n     * @param _indexer Withdraw available tokens delegated to indexer\\n     * @param _delegateToIndexer Re-delegate to indexer address if non-zero, withdraw if zero address\\n     */\\n    function _withdrawDelegated(\\n        address _delegator,\\n        address _indexer,\\n        address _delegateToIndexer\\n    ) private returns (uint256) {\\n        // Get the delegation pool of the indexer\\n        DelegationPool storage pool = delegationPools[_indexer];\\n        Delegation storage delegation = pool.delegators[_delegator];\\n\\n        // Validation\\n        uint256 tokensToWithdraw = getWithdraweableDelegatedTokens(delegation);\\n        require(tokensToWithdraw > 0, \\\"!tokens\\\");\\n\\n        // Reset lock\\n        delegation.tokensLocked = 0;\\n        delegation.tokensLockedUntil = 0;\\n\\n        emit StakeDelegatedWithdrawn(_indexer, _delegator, tokensToWithdraw);\\n\\n        // -- Interactions --\\n\\n        if (_delegateToIndexer != address(0)) {\\n            // Re-delegate tokens to a new indexer\\n            _delegate(_delegator, _delegateToIndexer, tokensToWithdraw);\\n        } else {\\n            // Return tokens to the delegator\\n            require(graphToken().transfer(_delegator, tokensToWithdraw), \\\"!transfer\\\");\\n        }\\n\\n        return tokensToWithdraw;\\n    }\\n\\n    /**\\n     * @dev Collect the delegation rewards for query fees.\\n     * This function will assign the collected fees to the delegation pool.\\n     * @param _indexer Indexer to which the tokens to distribute are related\\n     * @param _tokens Total tokens received used to calculate the amount of fees to collect\\n     * @return Amount of delegation rewards\\n     */\\n    function _collectDelegationQueryRewards(address _indexer, uint256 _tokens)\\n        private\\n        returns (uint256)\\n    {\\n        uint256 delegationRewards = 0;\\n        DelegationPool storage pool = delegationPools[_indexer];\\n        if (pool.tokens > 0 && pool.queryFeeCut < MAX_PPM) {\\n            uint256 indexerCut = uint256(pool.queryFeeCut).mul(_tokens).div(MAX_PPM);\\n            delegationRewards = _tokens.sub(indexerCut);\\n            pool.tokens = pool.tokens.add(delegationRewards);\\n        }\\n        return delegationRewards;\\n    }\\n\\n    /**\\n     * @dev Collect the delegation rewards for indexing.\\n     * This function will assign the collected fees to the delegation pool.\\n     * @param _indexer Indexer to which the tokens to distribute are related\\n     * @param _tokens Total tokens received used to calculate the amount of fees to collect\\n     * @return Amount of delegation rewards\\n     */\\n    function _collectDelegationIndexingRewards(address _indexer, uint256 _tokens)\\n        private\\n        returns (uint256)\\n    {\\n        uint256 delegationRewards = 0;\\n        DelegationPool storage pool = delegationPools[_indexer];\\n        if (pool.tokens > 0 && pool.indexingRewardCut < MAX_PPM) {\\n            uint256 indexerCut = uint256(pool.indexingRewardCut).mul(_tokens).div(MAX_PPM);\\n            delegationRewards = _tokens.sub(indexerCut);\\n            pool.tokens = pool.tokens.add(delegationRewards);\\n        }\\n        return delegationRewards;\\n    }\\n\\n    /**\\n     * @dev Collect the curation fees for a subgraph deployment from an amount of tokens.\\n     * This function transfer curation fees to the Curation contract by calling Curation.collect\\n     * @param _graphToken Token to collect\\n     * @param _subgraphDeploymentID Subgraph deployment to which the curation fees are related\\n     * @param _tokens Total tokens received used to calculate the amount of fees to collect\\n     * @param _curationPercentage Percentage of tokens to collect as fees\\n     * @return Amount of curation fees\\n     */\\n    function _collectCurationFees(\\n        IGraphToken _graphToken,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        uint256 _curationPercentage\\n    ) private returns (uint256) {\\n        if (_tokens == 0) {\\n            return 0;\\n        }\\n\\n        ICuration curation = curation();\\n        bool isCurationEnabled = _curationPercentage > 0 && address(curation) != address(0);\\n\\n        if (isCurationEnabled && curation.isCurated(_subgraphDeploymentID)) {\\n            uint256 curationFees = uint256(_curationPercentage).mul(_tokens).div(MAX_PPM);\\n            if (curationFees > 0) {\\n                // Transfer and call collect()\\n                // This function transfer tokens to a trusted protocol contracts\\n                // Then we call collect() to do the transfer bookeeping\\n                require(_graphToken.transfer(address(curation), curationFees), \\\"!transfer\\\");\\n                curation.collect(_subgraphDeploymentID, curationFees);\\n            }\\n            return curationFees;\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Collect tax to burn for an amount of tokens.\\n     * @param _graphToken Token to burn\\n     * @param _tokens Total tokens received used to calculate the amount of tax to collect\\n     * @param _percentage Percentage of tokens to burn as tax\\n     * @return Amount of tax charged\\n     */\\n    function _collectTax(\\n        IGraphToken _graphToken,\\n        uint256 _tokens,\\n        uint256 _percentage\\n    ) private returns (uint256) {\\n        uint256 tax = uint256(_percentage).mul(_tokens).div(MAX_PPM);\\n        _burnTokens(_graphToken, tax); // Burn tax if any\\n        return tax;\\n    }\\n\\n    /**\\n     * @dev Return the current state of an allocation\\n     * @param _allocationID Allocation identifier\\n     * @return AllocationState\\n     */\\n    function _getAllocationState(address _allocationID) private view returns (AllocationState) {\\n        Allocation storage alloc = allocations[_allocationID];\\n\\n        if (alloc.indexer == address(0)) {\\n            return AllocationState.Null;\\n        }\\n        if (alloc.tokens == 0) {\\n            return AllocationState.Claimed;\\n        }\\n\\n        uint256 closedAtEpoch = alloc.closedAtEpoch;\\n        if (closedAtEpoch == 0) {\\n            return AllocationState.Active;\\n        }\\n\\n        uint256 epochs = epochManager().epochsSince(closedAtEpoch);\\n        if (epochs >= channelDisputeEpochs) {\\n            return AllocationState.Finalized;\\n        }\\n        return AllocationState.Closed;\\n    }\\n\\n    /**\\n     * @dev Get the effective stake allocation considering epochs from allocation to closing.\\n     * @param _maxAllocationEpochs Max amount of epochs to cap the allocated stake\\n     * @param _tokens Amount of tokens allocated\\n     * @param _numEpochs Number of epochs that passed from allocation to closing\\n     * @return Effective allocated tokens across epochs\\n     */\\n    function _getEffectiveAllocation(\\n        uint256 _maxAllocationEpochs,\\n        uint256 _tokens,\\n        uint256 _numEpochs\\n    ) private pure returns (uint256) {\\n        bool shouldCap = _maxAllocationEpochs > 0 && _numEpochs > _maxAllocationEpochs;\\n        return _tokens.mul((shouldCap) ? _maxAllocationEpochs : _numEpochs);\\n    }\\n\\n    /**\\n     * @dev Triggers an update of rewards due to a change in allocations.\\n     * @param _subgraphDeploymentID Subgraph deployment updated\\n     */\\n    function _updateRewards(bytes32 _subgraphDeploymentID) private returns (uint256) {\\n        IRewardsManager rewardsManager = rewardsManager();\\n        if (address(rewardsManager) == address(0)) {\\n            return 0;\\n        }\\n        return rewardsManager.onSubgraphAllocationUpdate(_subgraphDeploymentID);\\n    }\\n\\n    /**\\n     * @dev Assign rewards for the closed allocation to indexer and delegators.\\n     * @param _allocationID Allocation\\n     */\\n    function _distributeRewards(address _allocationID, address _indexer) private {\\n        IRewardsManager rewardsManager = rewardsManager();\\n        if (address(rewardsManager) == address(0)) {\\n            return;\\n        }\\n        // Automatically triggers update of rewards snapshot as allocation will change\\n        // after this call. Take rewards mint tokens for the Staking contract to distribute\\n        // between indexer and delegators\\n        uint256 totalRewards = rewardsManager.takeRewards(_allocationID);\\n        if (totalRewards == 0) {\\n            return;\\n        }\\n\\n        // Calculate delegation rewards and add them to the delegation pool\\n        uint256 delegationRewards = _collectDelegationIndexingRewards(_indexer, totalRewards);\\n        uint256 indexerRewards = totalRewards.sub(delegationRewards);\\n\\n        // Add the rest of the rewards to the indexer stake\\n        if (indexerRewards > 0) {\\n            _stake(_indexer, indexerRewards);\\n        }\\n    }\\n\\n    /**\\n     * @dev Burn tokens held by this contract.\\n     * @param _graphToken Token to burn\\n     * @param _amount Amount of tokens to burn\\n     */\\n    function _burnTokens(IGraphToken _graphToken, uint256 _amount) private {\\n        if (_amount > 0) {\\n            _graphToken.burn(_amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tests/RebatePoolMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../staking/libs/Rebates.sol\\\";\\nimport \\\"../staking/libs/Cobbs.sol\\\";\\n\\n// Mock contract used for testing rebates\\ncontract RebatePoolMock {\\n    using Rebates for Rebates.Pool;\\n\\n    // -- State --\\n\\n    uint32 public alphaNumerator;\\n    uint32 public alphaDenominator;\\n\\n    Rebates.Pool public rebatePool;\\n\\n    // -- Events --\\n\\n    event Redeemed(uint256 value);\\n\\n    // Set the alpha for rebates\\n    function setRebateRatio(uint32 _alphaNumerator, uint32 _alphaDenominator) external {\\n        rebatePool.init(_alphaNumerator, _alphaDenominator);\\n    }\\n\\n    // Add fees and stake to the rebate pool\\n    function add(uint256 _indexerFees, uint256 _indexerAllocatedStake) external {\\n        rebatePool.addToPool(_indexerFees, _indexerAllocatedStake);\\n    }\\n\\n    // Remove rewards from rebate pool\\n    function pop(uint256 _indexerFees, uint256 _indexerAllocatedStake) external returns (uint256) {\\n        uint256 value = rebatePool.redeem(_indexerFees, _indexerAllocatedStake);\\n        emit Redeemed(value);\\n        return value;\\n    }\\n\\n    // Stub to test the cobb-douglas formula directly\\n    function cobbDouglas(\\n        uint256 _totalRewards,\\n        uint256 _fees,\\n        uint256 _totalFees,\\n        uint256 _stake,\\n        uint256 _totalStake,\\n        uint32 _alphaNumerator,\\n        uint32 _alphaDenominator\\n    ) external pure returns (uint256) {\\n        if (_totalFees == 0) {\\n            return 0;\\n        }\\n\\n        return\\n            LibCobbDouglas.cobbDouglas(\\n                _totalRewards,\\n                _fees,\\n                _totalFees,\\n                _stake,\\n                _totalStake,\\n                _alphaNumerator,\\n                _alphaDenominator\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/GraphToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../governance/Governed.sol\\\";\\n\\n/**\\n * @title GraphToken contract\\n * @dev This is the implementation of the ERC20 Graph Token.\\n * The implementation exposes a Permit() function to allow for a spender to send a signed message\\n * and approve funds to a spender following EIP2612 to make integration with other contracts easier.\\n *\\n * The token is initially owned by the deployer address that can mint tokens to create the initial\\n * distribution. For convenience, an initial supply can be passed in the constructor that will be\\n * assigned to the deployer.\\n *\\n * The governor can add the RewardsManager contract to mint indexing rewards.\\n *\\n */\\ncontract GraphToken is Governed, ERC20, ERC20Burnable {\\n    using SafeMath for uint256;\\n\\n    // -- EIP712 --\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#definition-of-domainseparator\\n\\n    bytes32 private constant DOMAIN_TYPE_HASH = keccak256(\\n        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\\\"\\n    );\\n    bytes32 private constant DOMAIN_NAME_HASH = keccak256(\\\"Graph Token\\\");\\n    bytes32 private constant DOMAIN_VERSION_HASH = keccak256(\\\"0\\\");\\n    bytes32\\n        private constant DOMAIN_SALT = 0x51f3d585afe6dfeb2af01bba0889a36c1db03beec88c6a4d0c53817069026afa; // Randomly generated salt\\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\\n        \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n    );\\n\\n    // -- State --\\n\\n    bytes32 private DOMAIN_SEPARATOR;\\n    mapping(address => bool) private _minters;\\n    mapping(address => uint256) public nonces;\\n\\n    // -- Events --\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender), \\\"Only minter can call\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Graph Token Contract Constructor.\\n     * @param _initialSupply Initial supply of GRT\\n     */\\n    constructor(uint256 _initialSupply) ERC20(\\\"Graph Token\\\", \\\"GRT\\\") {\\n        Governed._initialize(msg.sender);\\n\\n        // The Governor has the initial supply of tokens\\n        _mint(msg.sender, _initialSupply);\\n\\n        // The Governor is the default minter\\n        _addMinter(msg.sender);\\n\\n        // EIP-712 domain separator\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPE_HASH,\\n                DOMAIN_NAME_HASH,\\n                DOMAIN_VERSION_HASH,\\n                _getChainID(),\\n                address(this),\\n                DOMAIN_SALT\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Approve token allowance by validating a message signed by the holder.\\n     * @param _owner Address of the token holder\\n     * @param _spender Address of the approved spender\\n     * @param _value Amount of tokens to approve the spender\\n     * @param _deadline Expiration time of the signed permit\\n     * @param _v Signature version\\n     * @param _r Signature r value\\n     * @param _s Signature s value\\n     */\\n    function permit(\\n        address _owner,\\n        address _spender,\\n        uint256 _value,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        _owner,\\n                        _spender,\\n                        _value,\\n                        nonces[_owner],\\n                        _deadline\\n                    )\\n                )\\n            )\\n        );\\n        nonces[_owner] = nonces[_owner].add(1);\\n\\n        address recoveredAddress = ECDSA.recover(digest, abi.encodePacked(_r, _s, _v));\\n        require(_owner == recoveredAddress, \\\"GRT: invalid permit\\\");\\n        require(_deadline == 0 || block.timestamp <= _deadline, \\\"GRT: expired permit\\\");\\n\\n        _approve(_owner, _spender, _value);\\n    }\\n\\n    /**\\n     * @dev Add a new minter.\\n     * @param _account Address of the minter\\n     */\\n    function addMinter(address _account) external onlyGovernor {\\n        _addMinter(_account);\\n    }\\n\\n    /**\\n     * @dev Remove a minter.\\n     * @param _account Address of the minter\\n     */\\n    function removeMinter(address _account) external onlyGovernor {\\n        _removeMinter(_account);\\n    }\\n\\n    /**\\n     * @dev Renounce to be a minter.\\n     */\\n    function renounceMinter() external {\\n        _removeMinter(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Mint new tokens.\\n     * @param _to Address to send the newly minted tokens\\n     * @param _amount Amount of tokens to mint\\n     */\\n    function mint(address _to, uint256 _amount) external onlyMinter {\\n        _mint(_to, _amount);\\n    }\\n\\n    /**\\n     * @dev Return if the `_account` is a minter or not.\\n     * @param _account Address to check\\n     * @return True if the `_account` is minter\\n     */\\n    function isMinter(address _account) public view returns (bool) {\\n        return _minters[_account];\\n    }\\n\\n    /**\\n     * @dev Add a new minter.\\n     * @param _account Address of the minter\\n     */\\n    function _addMinter(address _account) private {\\n        _minters[_account] = true;\\n        emit MinterAdded(_account);\\n    }\\n\\n    /**\\n     * @dev Remove a minter.\\n     * @param _account Address of the minter\\n     */\\n    function _removeMinter(address _account) private {\\n        _minters[_account] = false;\\n        emit MinterRemoved(_account);\\n    }\\n\\n    /**\\n     * @dev Get the running network chain ID.\\n     * @return The chain ID\\n     */\\n    function _getChainID() private pure returns (uint256) {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Governed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\n/**\\n * @title Graph Governance contract\\n * @dev All contracts that will be owned by a Governor entity should extend this contract.\\n */\\ncontract Governed {\\n    // -- State --\\n\\n    address public governor;\\n    address public pendingGovernor;\\n\\n    // -- Events --\\n\\n    event NewPendingOwnership(address indexed from, address indexed to);\\n    event NewOwnership(address indexed from, address indexed to);\\n\\n    /**\\n     * @dev Check if the caller is the governor.\\n     */\\n    modifier onlyGovernor {\\n        require(msg.sender == governor, \\\"Only Governor can call\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize the governor to the contract caller.\\n     */\\n    function _initialize(address _initGovernor) internal {\\n        governor = _initGovernor;\\n    }\\n\\n    /**\\n     * @dev Admin function to begin change of governor. The `_newGovernor` must call\\n     * `acceptOwnership` to finalize the transfer.\\n     * @param _newGovernor Address of new `governor`\\n     */\\n    function transferOwnership(address _newGovernor) external onlyGovernor {\\n        require(_newGovernor != address(0), \\\"Governor must be set\\\");\\n\\n        address oldPendingGovernor = pendingGovernor;\\n        pendingGovernor = _newGovernor;\\n\\n        emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\\n    }\\n\\n    /**\\n     * @dev Admin function for pending governor to accept role and update governor.\\n     * This function must called by the pending governor.\\n     */\\n    function acceptOwnership() external {\\n        require(\\n            pendingGovernor != address(0) && msg.sender == pendingGovernor,\\n            \\\"Caller must be pending governor\\\"\\n        );\\n\\n        address oldGovernor = governor;\\n        address oldPendingGovernor = pendingGovernor;\\n\\n        governor = pendingGovernor;\\n        pendingGovernor = address(0);\\n\\n        emit NewOwnership(oldGovernor, governor);\\n        emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/GraphProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../governance/Governed.sol\\\";\\n\\nimport \\\"./IGraphProxy.sol\\\";\\nimport \\\"./GraphUpgradeable.sol\\\";\\n\\n/** \\n * @title GraphProxyAdmin\\n * @dev This is the owner of upgradeable proxy contracts.\\n * Proxy contracts use a TransparentProxy pattern, any admin related call\\n * like upgrading a contract or changing the admin needs to be send through\\n * this contract.\\n */\\ncontract GraphProxyAdmin is Governed {\\n\\n    /** \\n     * @dev Contract constructor.\\n     */\\n    constructor() {\\n        Governed._initialize(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation of a proxy.\\n     * This is needed because only the proxy admin can query it.\\n     * @return The address of the current implementation of the proxy.\\n     */\\n    function getProxyImplementation(IGraphProxy _proxy) public view returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(_proxy).staticcall(hex\\\"5c60da1b\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the pending implementation of a proxy.\\n     * This is needed because only the proxy admin can query it.\\n     * @return The address of the pending implementation of the proxy.\\n     */\\n    function getProxyPendingImplementation(IGraphProxy _proxy) public view returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"pendingImplementation()\\\")) == 0x396f7b23\\n        (bool success, bytes memory returndata) = address(_proxy).staticcall(hex\\\"396f7b23\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the admin of a proxy. Only the admin can query it.\\n     * @return The address of the current admin of the proxy.\\n     */\\n    function getProxyAdmin(IGraphProxy _proxy) public view returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(_proxy).staticcall(hex\\\"f851a440\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of a proxy.\\n     * @param _proxy Proxy to change admin.\\n     * @param _newAdmin Address to transfer proxy administration to.\\n     */\\n    function changeProxyAdmin(IGraphProxy _proxy, address _newAdmin) public onlyGovernor {\\n        _proxy.setAdmin(_newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades a proxy to the newest implementation of a contract.\\n     * @param _proxy Proxy to be upgraded.\\n     * @param _implementation the address of the Implementation.\\n     */\\n    function upgrade(IGraphProxy _proxy, address _implementation) public onlyGovernor {\\n        _proxy.upgradeTo(_implementation);\\n    }\\n\\n    /**\\n     * @dev Accepts a proxy.\\n     * @param _implementation Address of the implementation accepting the proxy.\\n     * @param _proxy Address of the proxy being accepted.\\n     */\\n    function acceptProxy(GraphUpgradeable _implementation, IGraphProxy _proxy) public onlyGovernor {\\n        _implementation.acceptProxy(_proxy);\\n    }\\n\\n    /**\\n     * @dev Accepts a proxy and call a function on the implementation.\\n     * @param _implementation Address of the implementation accepting the proxy.\\n     * @param _proxy Address of the proxy being accepted.\\n     * @param _data Encoded function to call on the implementation after accepting the proxy.\\n     */\\n    function acceptProxyAndCall(\\n        GraphUpgradeable _implementation,\\n        IGraphProxy _proxy,\\n        bytes calldata _data\\n    ) external onlyGovernor {\\n        _implementation.acceptProxyAndCall(_proxy, _data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/RewardsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../upgrades/GraphUpgradeable.sol\\\";\\n\\nimport \\\"./RewardsManagerStorage.sol\\\";\\nimport \\\"./IRewardsManager.sol\\\";\\n\\ncontract RewardsManager is RewardsManagerV1Storage, GraphUpgradeable, IRewardsManager {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant TOKEN_DECIMALS = 1e18;\\n    uint256 private constant MIN_ISSUANCE_RATE = 1e18;\\n\\n    // -- Events --\\n\\n    /**\\n     * @dev Emitted when rewards are assigned to an indexer.\\n     */\\n    event RewardsAssigned(\\n        address indexed indexer,\\n        address indexed allocationID,\\n        uint256 epoch,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted when rewards are denied to an indexer.\\n     */\\n    event RewardsDenied(address indexed indexer, address indexed allocationID, uint256 epoch);\\n\\n    /**\\n     * @dev Emitted when a subgraph is denied for claiming rewards.\\n     */\\n    event RewardsDenylistUpdated(bytes32 indexed subgraphDeploymentID, uint256 sinceBlock);\\n\\n    // -- Modifiers --\\n\\n    modifier onlySubgraphAvailabilityOracle() {\\n        require(\\n            msg.sender == address(subgraphAvailabilityOracle),\\n            \\\"Caller must be the subgraph availability oracle\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize this contract.\\n     */\\n    function initialize(address _controller, uint256 _issuanceRate) external onlyImpl {\\n        Managed._initialize(_controller);\\n\\n        // Settings\\n        _setIssuanceRate(_issuanceRate);\\n    }\\n\\n    /**\\n     * @dev Sets the issuance rate.\\n     * The issuance rate is defined as a percentage increase of the total supply per block.\\n     * This means that it needs to be greater than 1.0, any number under 1.0 is not\\n     * allowed and an issuance rate of 1.0 means no issuance.\\n     * To accommodate a high precision the issuance rate is expressed in wei.\\n     * @param _issuanceRate Issuance rate expressed in wei\\n     */\\n    function setIssuanceRate(uint256 _issuanceRate) external override onlyGovernor {\\n        _setIssuanceRate(_issuanceRate);\\n    }\\n\\n    /**\\n     * @dev Sets the issuance rate.\\n     * @param _issuanceRate Issuance rate\\n     */\\n    function _setIssuanceRate(uint256 _issuanceRate) private {\\n        require(_issuanceRate >= MIN_ISSUANCE_RATE, \\\"Issuance rate under minimum allowed\\\");\\n\\n        // Called since `issuance rate` will change\\n        updateAccRewardsPerSignal();\\n\\n        issuanceRate = _issuanceRate;\\n        emit ParameterUpdated(\\\"issuanceRate\\\");\\n    }\\n\\n    /**\\n     * @dev Sets the subgraph oracle allowed to denegate distribution of rewards to subgraphs.\\n     * @param _subgraphAvailabilityOracle Address of the subgraph availability oracle\\n     */\\n    function setSubgraphAvailabilityOracle(address _subgraphAvailabilityOracle)\\n        external\\n        override\\n        onlyGovernor\\n    {\\n        subgraphAvailabilityOracle = _subgraphAvailabilityOracle;\\n        emit ParameterUpdated(\\\"subgraphAvailabilityOracle\\\");\\n    }\\n\\n    /**\\n     * @dev Denies to claim rewards for a subgraph.\\n     * NOTE: Can only be called by the subgraph availability oracle\\n     * @param _subgraphDeploymentID Subgraph deployment ID\\n     * @param _deny Whether to set the subgraph as denied for claiming rewards or not\\n     */\\n    function setDenied(bytes32 _subgraphDeploymentID, bool _deny)\\n        external\\n        override\\n        onlySubgraphAvailabilityOracle\\n    {\\n        _setDenied(_subgraphDeploymentID, _deny);\\n    }\\n\\n    /**\\n     * @dev Denies to claim rewards for multiple subgraph.\\n     * NOTE: Can only be called by the subgraph availability oracle\\n     * @param _subgraphDeploymentID Array of subgraph deployment ID\\n     * @param _deny Array of denied status for claiming rewards for each subgraph\\n     */\\n    function setDeniedMany(bytes32[] calldata _subgraphDeploymentID, bool[] calldata _deny)\\n        external\\n        override\\n        onlySubgraphAvailabilityOracle\\n    {\\n        require(_subgraphDeploymentID.length == _deny.length, \\\"!length\\\");\\n        for (uint256 i = 0; i < _subgraphDeploymentID.length; i++) {\\n            _setDenied(_subgraphDeploymentID[i], _deny[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal: Denies to claim rewards for a subgraph.\\n     * @param _subgraphDeploymentID Subgraph deployment ID\\n     * @param _deny Whether to set the subgraph as denied for claiming rewards or not\\n     */\\n    function _setDenied(bytes32 _subgraphDeploymentID, bool _deny) private {\\n        uint256 sinceBlock = _deny ? block.number : 0;\\n        denylist[_subgraphDeploymentID] = sinceBlock;\\n        emit RewardsDenylistUpdated(_subgraphDeploymentID, sinceBlock);\\n    }\\n\\n    /**\\n     * @dev Tells if subgraph is in deny list\\n     * @param _subgraphDeploymentID Subgraph deployment ID to check\\n     */\\n    function isDenied(bytes32 _subgraphDeploymentID) public override view returns (bool) {\\n        return denylist[_subgraphDeploymentID] > 0;\\n    }\\n\\n    /**\\n     * @dev Gets the issuance of rewards per signal since last updated.\\n     *\\n     * Compound interest formula: `a = p(1 + r/n)^nt`\\n     * The formula is simplified with `n = 1` as we apply the interest once every time step.\\n     * The `r` is passed with +1 included. So for 10% instead of 0.1 it is 1.1\\n     * The simplified formula is `a = p * r^t`\\n     *\\n     * Notation:\\n     * t: time steps are in blocks since last updated\\n     * p: total supply of GRT tokens\\n     * a: inflated amount of total supply for the period `t` when interest `r` is applied\\n     * x: newly accrued rewards token for the period `t`\\n     *\\n     * @return newly accrued rewards per signal since last update\\n     */\\n    function getNewRewardsPerSignal() public override view returns (uint256) {\\n        // Calculate time steps\\n        uint256 t = block.number.sub(accRewardsPerSignalLastBlockUpdated);\\n        // Optimization to skip calculations if zero time steps elapsed\\n        if (t == 0) {\\n            return 0;\\n        }\\n\\n        // Zero issuance under a rate of 1.0\\n        if (issuanceRate <= MIN_ISSUANCE_RATE) {\\n            return 0;\\n        }\\n\\n        // Zero issuance if no signalled tokens\\n        IGraphToken graphToken = graphToken();\\n        uint256 signalledTokens = graphToken.balanceOf(address(curation()));\\n        if (signalledTokens == 0) {\\n            return 0;\\n        }\\n\\n        uint256 r = issuanceRate;\\n        uint256 p = graphToken.totalSupply();\\n        uint256 a = p.mul(_pow(r, t, TOKEN_DECIMALS)).div(TOKEN_DECIMALS);\\n\\n        // New issuance per signalled token during time steps\\n        uint256 x = a.sub(p);\\n\\n        // We multiply the decimals to keep the precision as fixed-point number\\n        return x.mul(TOKEN_DECIMALS).div(signalledTokens);\\n    }\\n\\n    /**\\n     * @dev Gets the currently accumulated rewards per signal.\\n     */\\n    function getAccRewardsPerSignal() public override view returns (uint256) {\\n        return accRewardsPerSignal.add(getNewRewardsPerSignal());\\n    }\\n\\n    /**\\n     * @dev Gets the accumulated rewards for the subgraph.\\n     * @param _subgraphDeploymentID Subgraph deployment\\n     * @return Accumulated rewards for subgraph\\n     */\\n    function getAccRewardsForSubgraph(bytes32 _subgraphDeploymentID)\\n        public\\n        override\\n        view\\n        returns (uint256)\\n    {\\n        Subgraph storage subgraph = subgraphs[_subgraphDeploymentID];\\n\\n        uint256 newAccrued = getAccRewardsPerSignal().sub(subgraph.accRewardsPerSignalSnapshot);\\n        uint256 subgraphSignalledTokens = curation().getCurationPoolTokens(_subgraphDeploymentID);\\n        if (subgraphSignalledTokens == 0) {\\n            return 0;\\n        }\\n\\n        uint256 newValue = newAccrued.mul(subgraphSignalledTokens).div(TOKEN_DECIMALS);\\n        return subgraph.accRewardsForSubgraph.add(newValue);\\n    }\\n\\n    /**\\n     * @dev Gets the accumulated rewards per allocated token for the subgraph.\\n     * @param _subgraphDeploymentID Subgraph deployment\\n     * @return Accumulated rewards per allocated token for the subgraph\\n     * @return Accumulated rewards for subgraph\\n     */\\n    function getAccRewardsPerAllocatedToken(bytes32 _subgraphDeploymentID)\\n        public\\n        override\\n        view\\n        returns (uint256, uint256)\\n    {\\n        Subgraph storage subgraph = subgraphs[_subgraphDeploymentID];\\n\\n        uint256 accRewardsForSubgraph = getAccRewardsForSubgraph(_subgraphDeploymentID);\\n        uint256 newAccrued = accRewardsForSubgraph.sub(subgraph.accRewardsForSubgraphSnapshot);\\n\\n        uint256 subgraphAllocatedTokens = staking().getSubgraphAllocatedTokens(\\n            _subgraphDeploymentID\\n        );\\n        if (subgraphAllocatedTokens == 0) {\\n            return (0, accRewardsForSubgraph);\\n        }\\n\\n        uint256 newValue = newAccrued.mul(TOKEN_DECIMALS).div(subgraphAllocatedTokens);\\n        return (subgraph.accRewardsPerAllocatedToken.add(newValue), accRewardsForSubgraph);\\n    }\\n\\n    /**\\n     * @dev Updates the accumulated rewards per signal and save checkpoint block number.\\n     * Must be called before `issuanceRate` or `total signalled GRT` changes\\n     * Called from the Curation contract on mint() and burn()\\n     * @return Accumulated rewards per signal\\n     */\\n    function updateAccRewardsPerSignal() public override returns (uint256) {\\n        accRewardsPerSignal = getAccRewardsPerSignal();\\n        accRewardsPerSignalLastBlockUpdated = block.number;\\n        return accRewardsPerSignal;\\n    }\\n\\n    /**\\n     * @dev Triggers an update of rewards for a subgraph.\\n     * Must be called before `signalled GRT` on a subgraph changes.\\n     * Note: Hook called from the Curation contract on mint() and burn()\\n     * @param _subgraphDeploymentID Subgraph deployment\\n     * @return Accumulated rewards for subgraph\\n     */\\n    function onSubgraphSignalUpdate(bytes32 _subgraphDeploymentID)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        // Called since `total signalled GRT` will change\\n        updateAccRewardsPerSignal();\\n\\n        // Updates the accumulated rewards for a subgraph\\n        Subgraph storage subgraph = subgraphs[_subgraphDeploymentID];\\n        subgraph.accRewardsForSubgraph = getAccRewardsForSubgraph(_subgraphDeploymentID);\\n        subgraph.accRewardsPerSignalSnapshot = accRewardsPerSignal;\\n        return subgraph.accRewardsForSubgraph;\\n    }\\n\\n    /**\\n     * @dev Triggers an update of rewards for a subgraph.\\n     * Must be called before allocation on a subgraph changes.\\n     * NOTE: Hook called from the Staking contract on allocate() and close()\\n     *\\n     * @param _subgraphDeploymentID Subgraph deployment\\n     * @return Accumulated rewards per allocated token for a subgraph\\n     */\\n    function onSubgraphAllocationUpdate(bytes32 _subgraphDeploymentID)\\n        public\\n        override\\n        returns (uint256)\\n    {\\n        Subgraph storage subgraph = subgraphs[_subgraphDeploymentID];\\n        (\\n            uint256 accRewardsPerAllocatedToken,\\n            uint256 accRewardsForSubgraph\\n        ) = getAccRewardsPerAllocatedToken(_subgraphDeploymentID);\\n        subgraph.accRewardsPerAllocatedToken = accRewardsPerAllocatedToken;\\n        subgraph.accRewardsForSubgraphSnapshot = accRewardsForSubgraph;\\n        return subgraph.accRewardsPerAllocatedToken;\\n    }\\n\\n    /**\\n     * @dev Calculate current rewards for a given allocation on demand.\\n     * @param _allocationID Allocation\\n     * @return Rewards amount for an allocation\\n     */\\n    function getRewards(address _allocationID) external override view returns (uint256) {\\n        IStaking.Allocation memory alloc = staking().getAllocation(_allocationID);\\n\\n        (uint256 accRewardsPerAllocatedToken, ) = getAccRewardsPerAllocatedToken(\\n            alloc.subgraphDeploymentID\\n        );\\n        return\\n            _calcRewards(\\n                alloc.tokens,\\n                alloc.accRewardsPerAllocatedToken,\\n                accRewardsPerAllocatedToken\\n            );\\n    }\\n\\n    /**\\n     * @dev Calculate current rewards for a given allocation.\\n     * @param _tokens Tokens allocated\\n     * @param _startAccRewardsPerAllocatedToken Allocation start accumulated rewards\\n     * @param _endAccRewardsPerAllocatedToken Allocation end accumulated rewards\\n     * @return Rewards amount\\n     */\\n    function _calcRewards(\\n        uint256 _tokens,\\n        uint256 _startAccRewardsPerAllocatedToken,\\n        uint256 _endAccRewardsPerAllocatedToken\\n    ) private pure returns (uint256) {\\n        uint256 newAccrued = _endAccRewardsPerAllocatedToken.sub(_startAccRewardsPerAllocatedToken);\\n        return newAccrued.mul(_tokens).div(TOKEN_DECIMALS);\\n    }\\n\\n    /**\\n     * @dev Pull rewards from the contract for a particular allocation.\\n     * This function can only be called by the Staking contract.\\n     * This function will mint the necessary tokens to reward based on the inflation calculation.\\n     * @param _allocationID Allocation\\n     * @return Assigned rewards amount\\n     */\\n    function takeRewards(address _allocationID) external override returns (uint256) {\\n        // Only Staking contract is authorized as caller\\n        IStaking staking = staking();\\n        require(msg.sender == address(staking), \\\"Caller must be the staking contract\\\");\\n\\n        IGraphToken graphToken = graphToken();\\n        IStaking.Allocation memory alloc = staking.getAllocation(_allocationID);\\n\\n        uint256 accRewardsPerAllocatedToken = onSubgraphAllocationUpdate(\\n            alloc.subgraphDeploymentID\\n        );\\n\\n        // Do not do rewards on denied subgraph deployments ID\\n        if (isDenied(alloc.subgraphDeploymentID)) {\\n            emit RewardsDenied(alloc.indexer, _allocationID, alloc.closedAtEpoch);\\n            return 0;\\n        }\\n\\n        // Calculate rewards accrued by this allocation\\n        uint256 rewards = _calcRewards(\\n            alloc.tokens,\\n            alloc.accRewardsPerAllocatedToken,\\n            accRewardsPerAllocatedToken\\n        );\\n\\n        // Mint directly to staking contract for the reward amount\\n        // The staking contract will do bookkeeping of the reward and\\n        // assign in proportion to each stakeholder incentive\\n        graphToken.mint(address(staking), rewards);\\n\\n        emit RewardsAssigned(alloc.indexer, _allocationID, alloc.closedAtEpoch, rewards);\\n\\n        return rewards;\\n    }\\n\\n    /**\\n     * @dev Raises x to the power of n with scaling factor of base.\\n     * Based on: https://github.com/makerdao/dss/blob/master/src/pot.sol#L81\\n     * @param x Base of the exponentiation\\n     * @param n Exponent\\n     * @param base Scaling factor\\n     * @return z Exponential of n with base x\\n     */\\n    function _pow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 base\\n    ) private pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n                case 0 {\\n                    switch n\\n                        case 0 {\\n                            z := base\\n                        }\\n                        default {\\n                            z := 0\\n                        }\\n                }\\n                default {\\n                    switch mod(n, 2)\\n                        case 0 {\\n                            z := base\\n                        }\\n                        default {\\n                            z := x\\n                        }\\n                    let half := div(base, 2) // for rounding.\\n                    for {\\n                        n := div(n, 2)\\n                    } n {\\n                        n := div(n, 2)\\n                    } {\\n                        let xx := mul(x, x)\\n                        if iszero(eq(div(xx, x), x)) {\\n                            revert(0, 0)\\n                        }\\n                        let xxRound := add(xx, half)\\n                        if lt(xxRound, xx) {\\n                            revert(0, 0)\\n                        }\\n                        x := div(xxRound, base)\\n                        if mod(n, 2) {\\n                            let zx := mul(z, x)\\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\\n                                revert(0, 0)\\n                            }\\n                            let zxRound := add(zx, half)\\n                            if lt(zxRound, zx) {\\n                                revert(0, 0)\\n                            }\\n                            z := div(zxRound, base)\\n                        }\\n                    }\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/RewardsManagerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IRewardsManager.sol\\\";\\nimport \\\"../governance/Managed.sol\\\";\\n\\ncontract RewardsManagerV1Storage is Managed {\\n    // -- State --\\n\\n    uint256 public issuanceRate;\\n    uint256 public accRewardsPerSignal;\\n    uint256 public accRewardsPerSignalLastBlockUpdated;\\n\\n    // Address of role allowed to deny rewards on subgraphs\\n    address public subgraphAvailabilityOracle;\\n\\n    // Subgraph related rewards: subgraph deployment ID => subgraph rewards\\n    mapping(bytes32 => IRewardsManager.Subgraph) public subgraphs;\\n\\n    // Subgraph denylist : subgraph deployment ID => block when added or zero (if not denied)\\n    mapping(bytes32 => uint256) public denylist;\\n}\\n\"\r\n    },\r\n    \"contracts/epochs/EpochManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../upgrades/GraphUpgradeable.sol\\\";\\n\\nimport \\\"./EpochManagerStorage.sol\\\";\\nimport \\\"./IEpochManager.sol\\\";\\n\\n/**\\n * @title EpochManager contract\\n * @dev Produce epochs based on a number of blocks to coordinate contracts in the protocol.\\n */\\ncontract EpochManager is EpochManagerV1Storage, GraphUpgradeable, IEpochManager {\\n    using SafeMath for uint256;\\n\\n    // -- Events --\\n\\n    event EpochRun(uint256 indexed epoch, address caller);\\n    event EpochLengthUpdate(uint256 indexed epoch, uint256 epochLength);\\n\\n    /**\\n     * @dev Initialize this contract.\\n     */\\n    function initialize(address _controller, uint256 _epochLength) external onlyImpl {\\n        require(_epochLength > 0, \\\"Epoch length cannot be 0\\\");\\n\\n        Managed._initialize(_controller);\\n\\n        lastLengthUpdateEpoch = 0;\\n        lastLengthUpdateBlock = blockNum();\\n        epochLength = _epochLength;\\n\\n        emit EpochLengthUpdate(lastLengthUpdateEpoch, epochLength);\\n    }\\n\\n    /**\\n     * @dev Set the epoch length.\\n     * @notice Set epoch length to `_epochLength` blocks\\n     * @param _epochLength Epoch length in blocks\\n     */\\n    function setEpochLength(uint256 _epochLength) external override onlyGovernor {\\n        require(_epochLength > 0, \\\"Epoch length cannot be 0\\\");\\n        require(_epochLength != epochLength, \\\"Epoch length must be different to current\\\");\\n\\n        lastLengthUpdateEpoch = currentEpoch();\\n        lastLengthUpdateBlock = currentEpochBlock();\\n        epochLength = _epochLength;\\n\\n        emit EpochLengthUpdate(lastLengthUpdateEpoch, epochLength);\\n    }\\n\\n    /**\\n     * @dev Run a new epoch, should be called once at the start of any epoch.\\n     * @notice Perform state changes for the current epoch\\n     */\\n    function runEpoch() external override {\\n        // Check if already called for the current epoch\\n        require(!isCurrentEpochRun(), \\\"Current epoch already run\\\");\\n\\n        lastRunEpoch = currentEpoch();\\n\\n        // Hook for protocol general state updates\\n\\n        emit EpochRun(lastRunEpoch, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Return true if the current epoch has already run.\\n     * @return Return true if current epoch is the last epoch that has run\\n     */\\n    function isCurrentEpochRun() public override view returns (bool) {\\n        return lastRunEpoch == currentEpoch();\\n    }\\n\\n    /**\\n     * @dev Return current block number.\\n     * @return Block number\\n     */\\n    function blockNum() public override view returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @dev Return blockhash for a block.\\n     * @return BlockHash for `_block` number\\n     */\\n    function blockHash(uint256 _block) external override view returns (bytes32) {\\n        uint256 currentBlock = blockNum();\\n\\n        require(_block < currentBlock, \\\"Can only retrieve past block hashes\\\");\\n        require(\\n            currentBlock < 256 || _block >= currentBlock - 256,\\n            \\\"Can only retrieve hashes for last 256 blocks\\\"\\n        );\\n\\n        return blockhash(_block);\\n    }\\n\\n    /**\\n     * @dev Return the current epoch, it may have not been run yet.\\n     * @return The current epoch based on epoch length\\n     */\\n    function currentEpoch() public override view returns (uint256) {\\n        return lastLengthUpdateEpoch.add(epochsSinceUpdate());\\n    }\\n\\n    /**\\n     * @dev Return block where the current epoch started.\\n     * @return The block number when the current epoch started\\n     */\\n    function currentEpochBlock() public override view returns (uint256) {\\n        return lastLengthUpdateBlock.add(epochsSinceUpdate().mul(epochLength));\\n    }\\n\\n    /**\\n     * @dev Return the number of blocks that passed since current epoch started.\\n     * @return Blocks that passed since start of epoch\\n     */\\n    function currentEpochBlockSinceStart() external override view returns (uint256) {\\n        return blockNum() - currentEpochBlock();\\n    }\\n\\n    /**\\n     * @dev Return the number of epoch that passed since another epoch.\\n     * @param _epoch Epoch to use as since epoch value\\n     * @return Number of epochs and current epoch\\n     */\\n    function epochsSince(uint256 _epoch) external override view returns (uint256) {\\n        uint256 epoch = currentEpoch();\\n        return _epoch < epoch ? epoch.sub(_epoch) : 0;\\n    }\\n\\n    /**\\n     * @dev Return number of epochs passed since last epoch length update.\\n     * @return The number of epoch that passed since last epoch length update\\n     */\\n    function epochsSinceUpdate() public override view returns (uint256) {\\n        return blockNum().sub(lastLengthUpdateBlock).div(epochLength);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/epochs/EpochManagerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../governance/Managed.sol\\\";\\n\\ncontract EpochManagerV1Storage is Managed {\\n    // -- State --\\n\\n    // Epoch length in blocks\\n    uint256 public epochLength;\\n\\n    // Epoch that was last run\\n    uint256 public lastRunEpoch;\\n\\n    // Block and epoch when epoch length was last updated\\n    uint256 public lastLengthUpdateEpoch;\\n    uint256 public lastLengthUpdateBlock;\\n}\\n\"\r\n    },\r\n    \"contracts/disputes/DisputeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"../governance/Managed.sol\\\";\\nimport \\\"../upgrades/GraphUpgradeable.sol\\\";\\n\\nimport \\\"./DisputeManagerStorage.sol\\\";\\nimport \\\"./IDisputeManager.sol\\\";\\n\\n/*\\n * @title DisputeManager\\n * @dev Provides a way to align the incentives of participants by having slashing as deterrent\\n * for incorrect behaviour.\\n *\\n * There are two types of disputes that can be created: Query disputes and Indexing disputes.\\n *\\n * Query Disputes:\\n * Graph nodes receive queries and return responses with signed receipts called attestations.\\n * An attestation can be disputed if the consumer thinks the query response was invalid.\\n * Indexers use the derived private key for an allocation to sign attestations.\\n *\\n * Indexing Disputes:\\n * Indexers present a Proof of Indexing (POI) when they close allocations to prove\\n * they were indexing a subgraph. The Staking contract emits that proof with the format\\n * keccak256(indexer.address, POI).\\n * Any challenger can dispute the validity of a POI by submitting a dispute to this contract\\n * along with a deposit.\\n *\\n * Arbitration:\\n * Disputes can only be accepted, rejected or drawn by the arbitrator role that can be delegated\\n * to a EOA or DAO.\\n */\\ncontract DisputeManager is DisputeManagerV1Storage, GraphUpgradeable, IDisputeManager {\\n    using SafeMath for uint256;\\n\\n    // -- EIP-712  --\\n\\n    bytes32 private constant DOMAIN_TYPE_HASH = keccak256(\\n        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\\\"\\n    );\\n    bytes32 private constant DOMAIN_NAME_HASH = keccak256(\\\"Graph Protocol\\\");\\n    bytes32 private constant DOMAIN_VERSION_HASH = keccak256(\\\"0\\\");\\n    bytes32\\n        private constant DOMAIN_SALT = 0xa070ffb1cd7409649bf77822cce74495468e06dbfaef09556838bf188679b9c2;\\n    bytes32 private constant RECEIPT_TYPE_HASH = keccak256(\\n        \\\"Receipt(bytes32 requestCID,bytes32 responseCID,bytes32 subgraphDeploymentID)\\\"\\n    );\\n\\n    // -- Constants --\\n\\n    uint256 private constant ATTESTATION_SIZE_BYTES = 161;\\n    uint256 private constant RECEIPT_SIZE_BYTES = 96;\\n\\n    uint256 private constant SIG_R_LENGTH = 32;\\n    uint256 private constant SIG_S_LENGTH = 32;\\n    uint256 private constant SIG_R_OFFSET = RECEIPT_SIZE_BYTES;\\n    uint256 private constant SIG_S_OFFSET = RECEIPT_SIZE_BYTES + SIG_R_LENGTH;\\n    uint256 private constant SIG_V_OFFSET = RECEIPT_SIZE_BYTES + SIG_R_LENGTH + SIG_S_LENGTH;\\n\\n    uint256 private constant UINT8_BYTE_LENGTH = 1;\\n    uint256 private constant BYTES32_BYTE_LENGTH = 32;\\n\\n    uint256 private constant MAX_PPM = 1000000; // 100% in parts per million\\n\\n    // -- Events --\\n\\n    /**\\n     * @dev Emitted when a query dispute is created for `subgraphDeploymentID` and `indexer`\\n     * by `fisherman`.\\n     * The event emits the amount of `tokens` deposited by the fisherman and `attestation` submitted.\\n     */\\n    event QueryDisputeCreated(\\n        bytes32 indexed disputeID,\\n        address indexed indexer,\\n        address indexed fisherman,\\n        uint256 tokens,\\n        bytes32 subgraphDeploymentID,\\n        bytes attestation\\n    );\\n\\n    /**\\n     * @dev Emitted when an indexing dispute is created for `allocationID` and `indexer`\\n     * by `fisherman`.\\n     * The event emits the amount of `tokens` deposited by the fisherman.\\n     */\\n    event IndexingDisputeCreated(\\n        bytes32 indexed disputeID,\\n        address indexed indexer,\\n        address indexed fisherman,\\n        uint256 tokens,\\n        address allocationID\\n    );\\n\\n    /**\\n     * @dev Emitted when arbitrator accepts a `disputeID` to `indexer` created by `fisherman`.\\n     * The event emits the amount `tokens` transferred to the fisherman, the deposit plus reward.\\n     */\\n    event DisputeAccepted(\\n        bytes32 indexed disputeID,\\n        address indexed indexer,\\n        address indexed fisherman,\\n        uint256 tokens\\n    );\\n\\n    /**\\n     * @dev Emitted when arbitrator rejects a `disputeID` for `indexer` created by `fisherman`.\\n     * The event emits the amount `tokens` burned from the fisherman deposit.\\n     */\\n    event DisputeRejected(\\n        bytes32 indexed disputeID,\\n        address indexed indexer,\\n        address indexed fisherman,\\n        uint256 tokens\\n    );\\n\\n    /**\\n     * @dev Emitted when arbitrator draw a `disputeID` for `indexer` created by `fisherman`.\\n     * The event emits the amount `tokens` used as deposit and returned to the fisherman.\\n     */\\n    event DisputeDrawn(\\n        bytes32 indexed disputeID,\\n        address indexed indexer,\\n        address indexed fisherman,\\n        uint256 tokens\\n    );\\n\\n    /**\\n     * @dev Emitted when two disputes are in conflict to link them.\\n     * This event will be emitted after each DisputeCreated event is emitted\\n     * for each of the individual disputes.\\n     */\\n    event DisputeLinked(bytes32 indexed disputeID1, bytes32 indexed disputeID2);\\n\\n    /**\\n     * @dev Check if the caller is the arbitrator.\\n     */\\n    modifier onlyArbitrator {\\n        require(msg.sender == arbitrator, \\\"Caller is not the Arbitrator\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize this contract.\\n     * @param _arbitrator Arbitrator role\\n     * @param _minimumDeposit Minimum deposit required to create a Dispute\\n     * @param _fishermanRewardPercentage Percent of slashed funds for fisherman (ppm)\\n     * @param _slashingPercentage Percentage of indexer stake slashed (ppm)\\n     */\\n    function initialize(\\n        address _controller,\\n        address _arbitrator,\\n        uint256 _minimumDeposit,\\n        uint32 _fishermanRewardPercentage,\\n        uint32 _slashingPercentage\\n    ) external onlyImpl {\\n        Managed._initialize(_controller);\\n\\n        // Settings\\n        _setArbitrator(_arbitrator);\\n        _setMinimumDeposit(_minimumDeposit);\\n        _setFishermanRewardPercentage(_fishermanRewardPercentage);\\n        _setSlashingPercentage(_slashingPercentage);\\n\\n        // EIP-712 domain separator\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPE_HASH,\\n                DOMAIN_NAME_HASH,\\n                DOMAIN_VERSION_HASH,\\n                _getChainID(),\\n                address(this),\\n                DOMAIN_SALT\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Set the arbitrator address.\\n     * @notice Update the arbitrator to `_arbitrator`\\n     * @param _arbitrator The address of the arbitration contract or party\\n     */\\n    function setArbitrator(address _arbitrator) external override onlyGovernor {\\n        _setArbitrator(_arbitrator);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the arbitrator address.\\n     * @notice Update the arbitrator to `_arbitrator`\\n     * @param _arbitrator The address of the arbitration contract or party\\n     */\\n    function _setArbitrator(address _arbitrator) private {\\n        require(_arbitrator != address(0), \\\"Arbitrator must be set\\\");\\n        arbitrator = _arbitrator;\\n        emit ParameterUpdated(\\\"arbitrator\\\");\\n    }\\n\\n    /**\\n     * @dev Set the minimum deposit required to create a dispute.\\n     * @notice Update the minimum deposit to `_minimumDeposit` Graph Tokens\\n     * @param _minimumDeposit The minimum deposit in Graph Tokens\\n     */\\n    function setMinimumDeposit(uint256 _minimumDeposit) external override onlyGovernor {\\n        _setMinimumDeposit(_minimumDeposit);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the minimum deposit required to create a dispute.\\n     * @notice Update the minimum deposit to `_minimumDeposit` Graph Tokens\\n     * @param _minimumDeposit The minimum deposit in Graph Tokens\\n     */\\n    function _setMinimumDeposit(uint256 _minimumDeposit) private {\\n        require(_minimumDeposit > 0, \\\"Minimum deposit must be set\\\");\\n        minimumDeposit = _minimumDeposit;\\n        emit ParameterUpdated(\\\"minimumDeposit\\\");\\n    }\\n\\n    /**\\n     * @dev Set the percent reward that the fisherman gets when slashing occurs.\\n     * @notice Update the reward percentage to `_percentage`\\n     * @param _percentage Reward as a percentage of indexer stake\\n     */\\n    function setFishermanRewardPercentage(uint32 _percentage) external override onlyGovernor {\\n        _setFishermanRewardPercentage(_percentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the percent reward that the fisherman gets when slashing occurs.\\n     * @notice Update the reward percentage to `_percentage`\\n     * @param _percentage Reward as a percentage of indexer stake\\n     */\\n    function _setFishermanRewardPercentage(uint32 _percentage) private {\\n        // Must be within 0% to 100% (inclusive)\\n        require(_percentage <= MAX_PPM, \\\"Reward percentage must be below or equal to MAX_PPM\\\");\\n        fishermanRewardPercentage = _percentage;\\n        emit ParameterUpdated(\\\"fishermanRewardPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Set the percentage used for slashing indexers.\\n     * @param _percentage Percentage used for slashing\\n     */\\n    function setSlashingPercentage(uint32 _percentage) external override onlyGovernor {\\n        _setSlashingPercentage(_percentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the percentage used for slashing indexers.\\n     * @param _percentage Percentage used for slashing\\n     */\\n    function _setSlashingPercentage(uint32 _percentage) private {\\n        // Must be within 0% to 100% (inclusive)\\n        require(_percentage <= MAX_PPM, \\\"Slashing percentage must be below or equal to MAX_PPM\\\");\\n        slashingPercentage = _percentage;\\n        emit ParameterUpdated(\\\"slashingPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Return whether a dispute exists or not.\\n     * @notice Return if dispute with ID `_disputeID` exists\\n     * @param _disputeID True if dispute already exists\\n     */\\n    function isDisputeCreated(bytes32 _disputeID) public override view returns (bool) {\\n        return disputes[_disputeID].fisherman != address(0);\\n    }\\n\\n    /**\\n     * @dev Get the message hash that an indexer used to sign the receipt.\\n     * Encodes a receipt using a domain separator, as described on\\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification.\\n     * @notice Return the message hash used to sign the receipt\\n     * @param _receipt Receipt returned by indexer and submitted by fisherman\\n     * @return Message hash used to sign the receipt\\n     */\\n    function encodeHashReceipt(Receipt memory _receipt) public override view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\", // EIP-191 encoding pad, EIP-712 version 1\\n                    DOMAIN_SEPARATOR,\\n                    keccak256(\\n                        abi.encode(\\n                            RECEIPT_TYPE_HASH,\\n                            _receipt.requestCID,\\n                            _receipt.responseCID,\\n                            _receipt.subgraphDeploymentID\\n                        ) // EIP 712-encoded message hash\\n                    )\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns if two attestations are conflicting.\\n     * Everything must match except for the responseID.\\n     * @param _attestation1 Attestation\\n     * @param _attestation2 Attestation\\n     * @return True if the two attestations are conflicting\\n     */\\n    function areConflictingAttestations(\\n        Attestation memory _attestation1,\\n        Attestation memory _attestation2\\n    ) public override pure returns (bool) {\\n        return (_attestation1.requestCID == _attestation2.requestCID &&\\n            _attestation1.subgraphDeploymentID == _attestation2.subgraphDeploymentID &&\\n            _attestation1.responseCID != _attestation2.responseCID);\\n    }\\n\\n    /**\\n     * @dev Returns the indexer that signed an attestation.\\n     * @param _attestation Attestation\\n     * @return Indexer address\\n     */\\n    function getAttestationIndexer(Attestation memory _attestation)\\n        public\\n        override\\n        view\\n        returns (address)\\n    {\\n        // Get attestation signer, allocationID\\n        address allocationID = _recoverAttestationSigner(_attestation);\\n\\n        IStaking.Allocation memory alloc = staking().getAllocation(allocationID);\\n        require(alloc.indexer != address(0), \\\"Indexer cannot be found for the attestation\\\");\\n        require(\\n            alloc.subgraphDeploymentID == _attestation.subgraphDeploymentID,\\n            \\\"Allocation and attestation subgraphDeploymentID must match\\\"\\n        );\\n        return alloc.indexer;\\n    }\\n\\n    /**\\n     * @dev Get the fisherman reward for a given indexer stake.\\n     * @notice Return the fisherman reward based on the `_indexer` stake\\n     * @param _indexer Indexer to be slashed\\n     * @return Reward calculated as percentage of the indexer slashed funds\\n     */\\n    function getTokensToReward(address _indexer) public override view returns (uint256) {\\n        uint256 tokens = getTokensToSlash(_indexer);\\n        if (tokens == 0) {\\n            return 0;\\n        }\\n        return uint256(fishermanRewardPercentage).mul(tokens).div(MAX_PPM);\\n    }\\n\\n    /**\\n     * @dev Get the amount of tokens to slash for an indexer based on the current stake.\\n     * @param _indexer Address of the indexer\\n     * @return Amount of tokens to slash\\n     */\\n    function getTokensToSlash(address _indexer) public override view returns (uint256) {\\n        uint256 tokens = staking().getIndexerStakedTokens(_indexer); // slashable tokens\\n        if (tokens == 0) {\\n            return 0;\\n        }\\n        return uint256(slashingPercentage).mul(tokens).div(MAX_PPM);\\n    }\\n\\n    /**\\n     * @dev Create a query dispute for the arbitrator to resolve.\\n     * This function is called by a fisherman that will need to `_deposit` at\\n     * least `minimumDeposit` GRT tokens.\\n     * @param _attestationData Attestation bytes submitted by the fisherman\\n     * @param _deposit Amount of tokens staked as deposit\\n     */\\n    function createQueryDispute(bytes calldata _attestationData, uint256 _deposit)\\n        external\\n        override\\n        returns (bytes32)\\n    {\\n        // Get funds from submitter\\n        _pullSubmitterDeposit(_deposit);\\n\\n        // Create a dispute\\n        return\\n            _createQueryDisputeWithAttestation(\\n                msg.sender,\\n                _deposit,\\n                _parseAttestation(_attestationData),\\n                _attestationData\\n            );\\n    }\\n\\n    /**\\n     * @dev Create query disputes for two conflicting attestations.\\n     * A conflicting attestation is a proof presented by two different indexers\\n     * where for the same request on a subgraph the response is different.\\n     * For this type of dispute the submitter is not required to present a deposit\\n     * as one of the attestation is considered to be right.\\n     * Two linked disputes will be created and if the arbitrator resolve one, the other\\n     * one will be automatically resolved.\\n     * @param _attestationData1 First attestation data submitted\\n     * @param _attestationData2 Second attestation data submitted\\n     * @return DisputeID1, DisputeID2\\n     */\\n    function createQueryDisputeConflict(\\n        bytes calldata _attestationData1,\\n        bytes calldata _attestationData2\\n    ) external override returns (bytes32, bytes32) {\\n        address fisherman = msg.sender;\\n\\n        // Parse each attestation\\n        Attestation memory attestation1 = _parseAttestation(_attestationData1);\\n        Attestation memory attestation2 = _parseAttestation(_attestationData2);\\n\\n        // Test that attestations are conflicting\\n        require(\\n            areConflictingAttestations(attestation1, attestation2),\\n            \\\"Attestations must be in conflict\\\"\\n        );\\n\\n        // Create the disputes\\n        // The deposit is zero for conflicting attestations\\n        bytes32 dID1 = _createQueryDisputeWithAttestation(\\n            fisherman,\\n            0,\\n            attestation1,\\n            _attestationData1\\n        );\\n        bytes32 dID2 = _createQueryDisputeWithAttestation(\\n            fisherman,\\n            0,\\n            attestation2,\\n            _attestationData2\\n        );\\n\\n        // Store the linked disputes to be resolved\\n        disputes[dID1].relatedDisputeID = dID2;\\n        disputes[dID2].relatedDisputeID = dID1;\\n\\n        // Emit event that links the two created disputes\\n        emit DisputeLinked(dID1, dID2);\\n\\n        return (dID1, dID2);\\n    }\\n\\n    /**\\n     * @dev Create a query dispute passing the parsed attestation.\\n     * To be used in createQueryDispute() and createQueryDisputeConflict()\\n     * to avoid calling parseAttestation() multiple times\\n     * `_attestationData` is only passed to be emitted\\n     * @param _fisherman Creator of dispute\\n     * @param _deposit Amount of tokens staked as deposit\\n     * @param _attestation Attestation struct parsed from bytes\\n     * @param _attestationData Attestation bytes submitted by the fisherman\\n     * @return DisputeID\\n     */\\n    function _createQueryDisputeWithAttestation(\\n        address _fisherman,\\n        uint256 _deposit,\\n        Attestation memory _attestation,\\n        bytes memory _attestationData\\n    ) private returns (bytes32) {\\n        // Get the indexer that signed the attestation\\n        address indexer = getAttestationIndexer(_attestation);\\n\\n        // The indexer is disputable\\n        require(staking().hasStake(indexer), \\\"Dispute indexer has no stake\\\");\\n\\n        // Create a disputeID\\n        bytes32 disputeID = keccak256(\\n            abi.encodePacked(\\n                _attestation.requestCID,\\n                _attestation.responseCID,\\n                _attestation.subgraphDeploymentID,\\n                indexer,\\n                _fisherman\\n            )\\n        );\\n\\n        // Only one dispute for a (indexer, subgraphDeploymentID) at a time\\n        require(!isDisputeCreated(disputeID), \\\"Dispute already created\\\");\\n\\n        // Store dispute\\n        disputes[disputeID] = Dispute(\\n            indexer,\\n            _fisherman,\\n            _deposit,\\n            0 // no related dispute\\n        );\\n\\n        emit QueryDisputeCreated(\\n            disputeID,\\n            indexer,\\n            _fisherman,\\n            _deposit,\\n            _attestation.subgraphDeploymentID,\\n            _attestationData\\n        );\\n\\n        return disputeID;\\n    }\\n\\n    /**\\n     * @dev Create an indexing dispute for the arbitrator to resolve.\\n     * The disputes are created in reference to an allocationID\\n     * This function is called by a challenger that will need to `_deposit` at\\n     * least `minimumDeposit` GRT tokens.\\n     * @param _allocationID The allocation to dispute\\n     * @param _deposit Amount of tokens staked as deposit\\n     */\\n    function createIndexingDispute(address _allocationID, uint256 _deposit)\\n        external\\n        override\\n        returns (bytes32)\\n    {\\n        // Get funds from submitter\\n        _pullSubmitterDeposit(_deposit);\\n\\n        // Create a dispute\\n        return _createIndexingDisputeWithAllocation(msg.sender, _deposit, _allocationID);\\n    }\\n\\n    /**\\n     * @dev Create indexing dispute internal function.\\n     * @param _fisherman The challenger creating the dispute\\n     * @param _deposit Amount of tokens staked as deposit\\n     * @param _allocationID Allocation disputed\\n     */\\n\\n    function _createIndexingDisputeWithAllocation(\\n        address _fisherman,\\n        uint256 _deposit,\\n        address _allocationID\\n    ) private returns (bytes32) {\\n        // Create a disputeID\\n        bytes32 disputeID = keccak256(abi.encodePacked(_allocationID));\\n\\n        // Only one dispute for an allocationID at a time\\n        require(!isDisputeCreated(disputeID), \\\"Dispute already created\\\");\\n\\n        // Allocation must exist\\n        IStaking.Allocation memory alloc = staking().getAllocation(_allocationID);\\n        require(alloc.indexer != address(0), \\\"Dispute allocation must exist\\\");\\n\\n        // The indexer must be disputable\\n        require(staking().hasStake(alloc.indexer), \\\"Dispute indexer has no stake\\\");\\n\\n        // Store dispute\\n        disputes[disputeID] = Dispute(alloc.indexer, _fisherman, _deposit, 0);\\n\\n        emit IndexingDisputeCreated(disputeID, alloc.indexer, _fisherman, _deposit, _allocationID);\\n\\n        return disputeID;\\n    }\\n\\n    /**\\n     * @dev The arbitrator accepts a dispute as being valid.\\n     * @notice Accept a dispute with ID `_disputeID`\\n     * @param _disputeID ID of the dispute to be accepted\\n     */\\n    function acceptDispute(bytes32 _disputeID) external override onlyArbitrator {\\n        Dispute memory dispute = _resolveDispute(_disputeID);\\n\\n        // Slash\\n        uint256 tokensToReward = _slashIndexer(dispute.indexer, dispute.fisherman);\\n\\n        // Give the fisherman their deposit back\\n        if (dispute.deposit > 0) {\\n            require(\\n                graphToken().transfer(dispute.fisherman, dispute.deposit),\\n                \\\"Error sending dispute deposit\\\"\\n            );\\n        }\\n\\n        // Resolve the conflicting dispute if any\\n        _resolveDisputeInConflict(dispute);\\n\\n        emit DisputeAccepted(\\n            _disputeID,\\n            dispute.indexer,\\n            dispute.fisherman,\\n            dispute.deposit.add(tokensToReward)\\n        );\\n    }\\n\\n    /**\\n     * @dev The arbitrator rejects a dispute as being invalid.\\n     * @notice Reject a dispute with ID `_disputeID`\\n     * @param _disputeID ID of the dispute to be rejected\\n     */\\n    function rejectDispute(bytes32 _disputeID) external override onlyArbitrator {\\n        Dispute memory dispute = _resolveDispute(_disputeID);\\n\\n        // Handle conflicting dispute if any\\n        require(\\n            !_isDisputeInConflict(dispute),\\n            \\\"Dispute for conflicting attestation, must accept the related ID to reject\\\"\\n        );\\n\\n        // Burn the fisherman's deposit\\n        if (dispute.deposit > 0) {\\n            graphToken().burn(dispute.deposit);\\n        }\\n\\n        emit DisputeRejected(_disputeID, dispute.indexer, dispute.fisherman, dispute.deposit);\\n    }\\n\\n    /**\\n     * @dev The arbitrator draws dispute.\\n     * @notice Ignore a dispute with ID `_disputeID`\\n     * @param _disputeID ID of the dispute to be disregarded\\n     */\\n    function drawDispute(bytes32 _disputeID) external override onlyArbitrator {\\n        Dispute memory dispute = _resolveDispute(_disputeID);\\n\\n        // Return deposit to the fisherman\\n        if (dispute.deposit > 0) {\\n            require(\\n                graphToken().transfer(dispute.fisherman, dispute.deposit),\\n                \\\"Error sending dispute deposit\\\"\\n            );\\n        }\\n\\n        // Resolve the conflicting dispute if any\\n        _resolveDisputeInConflict(dispute);\\n\\n        emit DisputeDrawn(_disputeID, dispute.indexer, dispute.fisherman, dispute.deposit);\\n    }\\n\\n    /**\\n     * @dev Resolve a dispute by removing it from storage and returning a memory copy.\\n     * @param _disputeID ID of the dispute to resolve\\n     * @return Dispute\\n     */\\n    function _resolveDispute(bytes32 _disputeID) private returns (Dispute memory) {\\n        require(isDisputeCreated(_disputeID), \\\"Dispute does not exist\\\");\\n\\n        Dispute memory dispute = disputes[_disputeID];\\n\\n        // Resolve dispute\\n        delete disputes[_disputeID]; // Re-entrancy\\n\\n        return dispute;\\n    }\\n\\n    /**\\n     * @dev Returns whether the dispute is for a conflicting attestation or not.\\n     * @param _dispute Dispute\\n     * @return True conflicting attestation dispute\\n     */\\n    function _isDisputeInConflict(Dispute memory _dispute) private pure returns (bool) {\\n        return _dispute.relatedDisputeID != 0;\\n    }\\n\\n    /**\\n     * @dev Resolve the conflicting dispute if there is any for the one passed to this function.\\n     * @param _dispute Dispute\\n     * @return True if resolved\\n     */\\n    function _resolveDisputeInConflict(Dispute memory _dispute) private returns (bool) {\\n        if (_isDisputeInConflict(_dispute)) {\\n            bytes32 relatedDisputeID = _dispute.relatedDisputeID;\\n            delete disputes[relatedDisputeID];\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Pull deposit from submitter account.\\n     * @param _deposit Amount of tokens to deposit\\n     */\\n    function _pullSubmitterDeposit(uint256 _deposit) private {\\n        // Ensure that fisherman has staked at least the minimum amount\\n        require(_deposit >= minimumDeposit, \\\"Dispute deposit is under minimum required\\\");\\n\\n        // Transfer tokens to deposit from fisherman to this contract\\n        require(\\n            graphToken().transferFrom(msg.sender, address(this), _deposit),\\n            \\\"Cannot transfer tokens to deposit\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Make the staking contract slash the indexer and reward the challenger.\\n     * Give the challenger a reward equal to the fishermanRewardPercentage of slashed amount\\n     * @param _indexer Address of the indexer\\n     * @param _challenger Address of the challenger\\n     * @return Dispute reward tokens\\n     */\\n    function _slashIndexer(address _indexer, address _challenger) private returns (uint256) {\\n        // Have staking contract slash the indexer and reward the fisherman\\n        // Give the fisherman a reward equal to the fishermanRewardPercentage of slashed amount\\n        uint256 tokensToSlash = getTokensToSlash(_indexer);\\n        uint256 tokensToReward = getTokensToReward(_indexer);\\n\\n        require(tokensToSlash > 0, \\\"Dispute has zero tokens to slash\\\");\\n        staking().slash(_indexer, tokensToSlash, tokensToReward, _challenger);\\n\\n        return tokensToReward;\\n    }\\n\\n    /**\\n     * @dev Recover the signer address of the `_attestation`.\\n     * @param _attestation The attestation struct\\n     * @return Signer address\\n     */\\n    function _recoverAttestationSigner(Attestation memory _attestation)\\n        private\\n        view\\n        returns (address)\\n    {\\n        // Obtain the hash of the fully-encoded message, per EIP-712 encoding\\n        Receipt memory receipt = Receipt(\\n            _attestation.requestCID,\\n            _attestation.responseCID,\\n            _attestation.subgraphDeploymentID\\n        );\\n        bytes32 messageHash = encodeHashReceipt(receipt);\\n\\n        // Obtain the signer of the fully-encoded EIP-712 message hash\\n        // NOTE: The signer of the attestation is the indexer that served the request\\n        return\\n            ECDSA.recover(\\n                messageHash,\\n                abi.encodePacked(_attestation.r, _attestation.s, _attestation.v)\\n            );\\n    }\\n\\n    /**\\n     * @dev Get the running network chain ID\\n     * @return The chain ID\\n     */\\n    function _getChainID() private pure returns (uint256) {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n\\n    /**\\n     * @dev Parse the bytes attestation into a struct from `_data`.\\n     * @return Attestation struct\\n     */\\n    function _parseAttestation(bytes memory _data) private pure returns (Attestation memory) {\\n        // Check attestation data length\\n        require(_data.length == ATTESTATION_SIZE_BYTES, \\\"Attestation must be 161 bytes long\\\");\\n\\n        // Decode receipt\\n        (bytes32 requestCID, bytes32 responseCID, bytes32 subgraphDeploymentID) = abi.decode(\\n            _data,\\n            (bytes32, bytes32, bytes32)\\n        );\\n\\n        // Decode signature\\n        // Signature is expected to be in the order defined in the Attestation struct\\n        bytes32 r = _toBytes32(_data, SIG_R_OFFSET);\\n        bytes32 s = _toBytes32(_data, SIG_S_OFFSET);\\n        uint8 v = _toUint8(_data, SIG_V_OFFSET);\\n\\n        return Attestation(requestCID, responseCID, subgraphDeploymentID, r, s, v);\\n    }\\n\\n    /**\\n     * @dev Parse a uint8 from `_bytes` starting at offset `_start`.\\n     * @return uint8 value\\n     */\\n    function _toUint8(bytes memory _bytes, uint256 _start) private pure returns (uint8) {\\n        require(_bytes.length >= (_start + UINT8_BYTE_LENGTH), \\\"Bytes: out of bounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    /**\\n     * @dev Parse a bytes32 from `_bytes` starting at offset `_start`.\\n     * @return bytes32 value\\n     */\\n    function _toBytes32(bytes memory _bytes, uint256 _start) private pure returns (bytes32) {\\n        require(_bytes.length >= (_start + BYTES32_BYTE_LENGTH), \\\"Bytes: out of bounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/disputes/DisputeManagerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../governance/Managed.sol\\\";\\n\\nimport \\\"./IDisputeManager.sol\\\";\\n\\ncontract DisputeManagerV1Storage is Managed {\\n    // -- State --\\n\\n    bytes32 internal DOMAIN_SEPARATOR;\\n\\n    // The arbitrator is solely in control of arbitrating disputes\\n    address public arbitrator;\\n\\n    // Minimum deposit required to create a Dispute\\n    uint256 public minimumDeposit;\\n\\n    // Percentage of indexer slashed funds to assign as a reward to fisherman in successful dispute\\n    // Parts per million. (Allows for 4 decimal points, 999,999 = 99.9999%)\\n    uint32 public fishermanRewardPercentage;\\n\\n    // Percentage of indexer stake to slash on disputes\\n    // Parts per million. (Allows for 4 decimal points, 999,999 = 99.9999%)\\n    uint32 public slashingPercentage;\\n\\n    // Disputes created : disputeID => Dispute\\n    // disputeID - check creation functions to see how disputeID is built\\n    mapping(bytes32 => IDisputeManager.Dispute) public disputes;\\n}\\n\"\r\n    },\r\n    \"contracts/disputes/IDisputeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\ninterface IDisputeManager {\\n    // -- Dispute --\\n\\n    // Disputes contain info necessary for the Arbitrator to verify and resolve\\n    struct Dispute {\\n        address indexer;\\n        address fisherman;\\n        uint256 deposit;\\n        bytes32 relatedDisputeID;\\n    }\\n\\n    // -- Attestation --\\n\\n    // Receipt content sent from indexer in response to request\\n    struct Receipt {\\n        bytes32 requestCID;\\n        bytes32 responseCID;\\n        bytes32 subgraphDeploymentID;\\n    }\\n\\n    // Attestation sent from indexer in response to a request\\n    struct Attestation {\\n        bytes32 requestCID;\\n        bytes32 responseCID;\\n        bytes32 subgraphDeploymentID;\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n    }\\n\\n    // -- Configuration --\\n\\n    function setArbitrator(address _arbitrator) external;\\n\\n    function setMinimumDeposit(uint256 _minimumDeposit) external;\\n\\n    function setFishermanRewardPercentage(uint32 _percentage) external;\\n\\n    function setSlashingPercentage(uint32 _percentage) external;\\n\\n    // -- Getters --\\n\\n    function isDisputeCreated(bytes32 _disputeID) external view returns (bool);\\n\\n    function encodeHashReceipt(Receipt memory _receipt) external view returns (bytes32);\\n\\n    function areConflictingAttestations(\\n        Attestation memory _attestation1,\\n        Attestation memory _attestation2\\n    ) external pure returns (bool);\\n\\n    function getAttestationIndexer(Attestation memory _attestation) external view returns (address);\\n\\n    function getTokensToReward(address _indexer) external view returns (uint256);\\n\\n    function getTokensToSlash(address _indexer) external view returns (uint256);\\n\\n    // -- Dispute --\\n\\n    function createQueryDispute(bytes calldata _attestationData, uint256 _deposit)\\n        external\\n        returns (bytes32);\\n\\n    function createQueryDisputeConflict(\\n        bytes calldata _attestationData1,\\n        bytes calldata _attestationData2\\n    ) external returns (bytes32, bytes32);\\n\\n    function createIndexingDispute(address _allocationID, uint256 _deposit)\\n        external\\n        returns (bytes32);\\n\\n    function acceptDispute(bytes32 _disputeID) external;\\n\\n    function rejectDispute(bytes32 _disputeID) external;\\n\\n    function drawDispute(bytes32 _disputeID) external;\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/ServiceRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../governance/Managed.sol\\\";\\nimport \\\"../upgrades/GraphUpgradeable.sol\\\";\\n\\nimport \\\"./ServiceRegistryStorage.sol\\\";\\nimport \\\"./IServiceRegistry.sol\\\";\\n\\n/**\\n * @title ServiceRegistry contract\\n * @dev This contract supports the service discovery process by allowing indexers to\\n * register their service url and any other relevant information.\\n */\\ncontract ServiceRegistry is ServiceRegistryV1Storage, GraphUpgradeable, IServiceRegistry {\\n    // -- Events --\\n\\n    event ServiceRegistered(address indexed indexer, string url, string geohash);\\n    event ServiceUnregistered(address indexed indexer);\\n\\n    /**\\n     * @dev Check if the caller is authorized (indexer or operator)\\n     */\\n    function _isAuth(address _indexer) internal view returns (bool) {\\n        return msg.sender == _indexer || staking().isOperator(msg.sender, _indexer) == true;\\n    }\\n\\n    /**\\n     * @dev Initialize this contract.\\n     */\\n    function initialize(address _controller) external onlyImpl {\\n        Managed._initialize(_controller);\\n    }\\n\\n    /**\\n     * @dev Register an indexer service\\n     * @param _url URL of the indexer service\\n     * @param _geohash Geohash of the indexer service location\\n     */\\n    function register(string calldata _url, string calldata _geohash) external override {\\n        _register(msg.sender, _url, _geohash);\\n    }\\n\\n    /**\\n     * @dev Register an indexer service\\n     * @param _indexer Address of the indexer\\n     * @param _url URL of the indexer service\\n     * @param _geohash Geohash of the indexer service location\\n     */\\n    function registerFor(\\n        address _indexer,\\n        string calldata _url,\\n        string calldata _geohash\\n    ) external override {\\n        _register(_indexer, _url, _geohash);\\n    }\\n\\n    /**\\n     * @dev Internal: Register an indexer service\\n     * @param _indexer Address of the indexer\\n     * @param _url URL of the indexer service\\n     * @param _geohash Geohash of the indexer service location\\n     */\\n    function _register(\\n        address _indexer,\\n        string calldata _url,\\n        string calldata _geohash\\n    ) private {\\n        require(_isAuth(_indexer), \\\"!auth\\\");\\n        require(bytes(_url).length > 0, \\\"Service must specify a URL\\\");\\n\\n        services[_indexer] = IndexerService(_url, _geohash);\\n\\n        emit ServiceRegistered(_indexer, _url, _geohash);\\n    }\\n\\n    /**\\n     * @dev Unregister an indexer service\\n     */\\n    function unregister() external override {\\n        _unregister(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Unregister an indexer service\\n     * @param _indexer Address of the indexer\\n     */\\n    function unregisterFor(address _indexer) external override {\\n        _unregister(_indexer);\\n    }\\n\\n    /**\\n     * @dev Unregister an indexer service\\n     * @param _indexer Address of the indexer\\n     */\\n    function _unregister(address _indexer) private {\\n        require(_isAuth(_indexer), \\\"!auth\\\");\\n        require(isRegistered(_indexer), \\\"Service already unregistered\\\");\\n\\n        delete services[_indexer];\\n        emit ServiceUnregistered(_indexer);\\n    }\\n\\n    /**\\n     * @dev Return the registration status of an indexer service\\n     * @return True if the indexer service is registered\\n     */\\n    function isRegistered(address _indexer) public override view returns (bool) {\\n        return bytes(services[_indexer].url).length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/ServiceRegistryStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../governance/Managed.sol\\\";\\n\\nimport \\\"./IServiceRegistry.sol\\\";\\n\\ncontract ServiceRegistryV1Storage is Managed {\\n    // -- State --\\n\\n    mapping(address => IServiceRegistry.IndexerService) public services;\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/IServiceRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ninterface IServiceRegistry {\\n    struct IndexerService {\\n        string url;\\n        string geohash;\\n    }\\n\\n    function register(string calldata _url, string calldata _geohash) external;\\n\\n    function registerFor(\\n        address _indexer,\\n        string calldata _url,\\n        string calldata _geohash\\n    ) external;\\n\\n    function unregister() external;\\n\\n    function unregisterFor(address _indexer) external;\\n\\n    function isRegistered(address _indexer) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/curation/Curation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../bancor/BancorFormula.sol\\\";\\nimport \\\"../upgrades/GraphUpgradeable.sol\\\";\\n\\nimport \\\"./CurationStorage.sol\\\";\\nimport \\\"./ICuration.sol\\\";\\nimport \\\"./GraphCurationToken.sol\\\";\\n\\n/**\\n * @title Curation contract\\n * @dev Allows curators to signal on subgraph deployments that might be relevant to indexers by\\n * staking Graph Tokens (GRT). Additionally, curators earn fees from the Query Market related to the\\n * subgraph deployment they curate.\\n * A curators deposit goes to a curation pool along with the deposits of other curators,\\n * only one such pool exists for each subgraph deployment.\\n * The contract mints Graph Curation Shares (GCS) according to a bonding curve for each individual\\n * curation pool where GRT is deposited.\\n * Holders can burn GCS using this contract to get GRT tokens back according to the\\n * bonding curve.\\n */\\ncontract Curation is CurationV1Storage, GraphUpgradeable, ICuration {\\n    using SafeMath for uint256;\\n\\n    // 100% in parts per million\\n    uint32 private constant MAX_PPM = 1000000;\\n\\n    // Amount of signal you get with your minimum token deposit\\n    uint256 private constant SIGNAL_PER_MINIMUM_DEPOSIT = 1e18; // 1 signal as 18 decimal number\\n\\n    // -- Events --\\n\\n    /**\\n     * @dev Emitted when `curator` deposited `tokens` on `subgraphDeploymentID` as curation signal.\\n     * The `curator` receives `signal` amount according to the curation pool bonding curve.\\n     * An amount of `curationTax` will be collected and burned.\\n     */\\n    event Signalled(\\n        address indexed curator,\\n        bytes32 indexed subgraphDeploymentID,\\n        uint256 tokens,\\n        uint256 signal,\\n        uint256 curationTax\\n    );\\n\\n    /**\\n     * @dev Emitted when `curator` burned `signal` for a `subgraphDeploymentID`.\\n     * The curator will receive `tokens` according to the value of the bonding curve.\\n     */\\n    event Burned(\\n        address indexed curator,\\n        bytes32 indexed subgraphDeploymentID,\\n        uint256 tokens,\\n        uint256 signal\\n    );\\n\\n    /**\\n     * @dev Emitted when `tokens` amount were collected for `subgraphDeploymentID` as part of fees\\n     * distributed by an indexer from query fees received from state channels.\\n     */\\n    event Collected(bytes32 indexed subgraphDeploymentID, uint256 tokens);\\n\\n    /**\\n     * @dev Initialize this contract.\\n     */\\n    function initialize(\\n        address _controller,\\n        address _bondingCurve,\\n        uint32 _defaultReserveRatio,\\n        uint32 _curationTaxPercentage,\\n        uint256 _minimumCurationDeposit\\n    ) external onlyImpl {\\n        Managed._initialize(_controller);\\n\\n        require(_bondingCurve != address(0), \\\"Bonding curve must be set\\\");\\n        bondingCurve = _bondingCurve;\\n\\n        // Settings\\n        _setDefaultReserveRatio(_defaultReserveRatio);\\n        _setCurationTaxPercentage(_curationTaxPercentage);\\n        _setMinimumCurationDeposit(_minimumCurationDeposit);\\n    }\\n\\n    /**\\n     * @dev Set the default reserve ratio percentage for a curation pool.\\n     * @notice Update the default reserver ratio to `_defaultReserveRatio`\\n     * @param _defaultReserveRatio Reserve ratio (in PPM)\\n     */\\n    function setDefaultReserveRatio(uint32 _defaultReserveRatio) external override onlyGovernor {\\n        _setDefaultReserveRatio(_defaultReserveRatio);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the default reserve ratio percentage for a curation pool.\\n     * @notice Update the default reserver ratio to `_defaultReserveRatio`\\n     * @param _defaultReserveRatio Reserve ratio (in PPM)\\n     */\\n    function _setDefaultReserveRatio(uint32 _defaultReserveRatio) private {\\n        // Reserve Ratio must be within 0% to 100% (inclusive, in PPM)\\n        require(_defaultReserveRatio > 0, \\\"Default reserve ratio must be > 0\\\");\\n        require(\\n            _defaultReserveRatio <= MAX_PPM,\\n            \\\"Default reserve ratio cannot be higher than MAX_PPM\\\"\\n        );\\n\\n        defaultReserveRatio = _defaultReserveRatio;\\n        emit ParameterUpdated(\\\"defaultReserveRatio\\\");\\n    }\\n\\n    /**\\n     * @dev Set the minimum deposit amount for curators.\\n     * @notice Update the minimum deposit amount to `_minimumCurationDeposit`\\n     * @param _minimumCurationDeposit Minimum amount of tokens required deposit\\n     */\\n    function setMinimumCurationDeposit(uint256 _minimumCurationDeposit)\\n        external\\n        override\\n        onlyGovernor\\n    {\\n        _setMinimumCurationDeposit(_minimumCurationDeposit);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the minimum deposit amount for curators.\\n     * @notice Update the minimum deposit amount to `_minimumCurationDeposit`\\n     * @param _minimumCurationDeposit Minimum amount of tokens required deposit\\n     */\\n    function _setMinimumCurationDeposit(uint256 _minimumCurationDeposit) private {\\n        require(_minimumCurationDeposit > 0, \\\"Minimum curation deposit cannot be 0\\\");\\n\\n        minimumCurationDeposit = _minimumCurationDeposit;\\n        emit ParameterUpdated(\\\"minimumCurationDeposit\\\");\\n    }\\n\\n    /**\\n     * @dev Set the curation tax percentage to charge when a curator deposits GRT tokens.\\n     * @param _percentage Curation tax percentage charged when depositing GRT tokens\\n     */\\n    function setCurationTaxPercentage(uint32 _percentage) external override onlyGovernor {\\n        _setCurationTaxPercentage(_percentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the curation tax percentage to charge when a curator deposits GRT tokens.\\n     * @param _percentage Curation tax percentage charged when depositing GRT tokens\\n     */\\n    function _setCurationTaxPercentage(uint32 _percentage) private {\\n        require(\\n            _percentage <= MAX_PPM,\\n            \\\"Curation tax percentage must be below or equal to MAX_PPM\\\"\\n        );\\n\\n        _curationTaxPercentage = _percentage;\\n        emit ParameterUpdated(\\\"curationTaxPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Assign Graph Tokens collected as curation fees to the curation pool reserve.\\n     * This function can only be called by the Staking contract and will do the bookeeping of\\n     * transferred tokens into this contract.\\n     * @param _subgraphDeploymentID SubgraphDeployment where funds should be allocated as reserves\\n     * @param _tokens Amount of Graph Tokens to add to reserves\\n     */\\n    function collect(bytes32 _subgraphDeploymentID, uint256 _tokens) external override {\\n        // Only Staking contract is authorized as caller\\n        require(msg.sender == address(staking()), \\\"Caller must be the staking contract\\\");\\n\\n        // Must be curated to accept tokens\\n        require(\\n            isCurated(_subgraphDeploymentID),\\n            \\\"Subgraph deployment must be curated to collect fees\\\"\\n        );\\n\\n        // Collect new funds into reserve\\n        CurationPool storage curationPool = pools[_subgraphDeploymentID];\\n        curationPool.tokens = curationPool.tokens.add(_tokens);\\n\\n        emit Collected(_subgraphDeploymentID, _tokens);\\n    }\\n\\n    /**\\n     * @dev Deposit Graph Tokens in exchange for signal of a SubgraphDeployment curation pool.\\n     * @param _subgraphDeploymentID Subgraph deployment pool from where to mint signal\\n     * @param _tokensIn Amount of Graph Tokens to deposit\\n     * @param _signalOutMin Expected minimum amount of signal to receive\\n     * @return Signal minted and deposit tax\\n     */\\n    function mint(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokensIn,\\n        uint256 _signalOutMin\\n    ) external override notPartialPaused returns (uint256, uint256) {\\n        // Need to deposit some funds\\n        require(_tokensIn > 0, \\\"Cannot deposit zero tokens\\\");\\n\\n        // Exchange GRT tokens for GCS of the subgraph pool\\n        (uint256 signalOut, uint256 curationTax) = tokensToSignal(_subgraphDeploymentID, _tokensIn);\\n\\n        // Slippage protection\\n        require(signalOut >= _signalOutMin, \\\"Slippage protection\\\");\\n\\n        address curator = msg.sender;\\n        CurationPool storage curationPool = pools[_subgraphDeploymentID];\\n\\n        // If it hasn't been curated before then initialize the curve\\n        if (!isCurated(_subgraphDeploymentID)) {\\n            // Initialize\\n            curationPool.reserveRatio = defaultReserveRatio;\\n\\n            // If no signal token for the pool - create one\\n            if (address(curationPool.gcs) == address(0)) {\\n                // TODO: Use a minimal proxy to reduce gas cost\\n                // https://github.com/graphprotocol/contracts/issues/405\\n                // --abarmat-- 20201113\\n                curationPool.gcs = IGraphCurationToken(\\n                    address(new GraphCurationToken(address(this)))\\n                );\\n            }\\n        }\\n\\n        // Trigger update rewards calculation snapshot\\n        _updateRewards(_subgraphDeploymentID);\\n\\n        // Transfer tokens from the curator to this contract\\n        // This needs to happen after _updateRewards snapshot as that function\\n        // is using balanceOf(curation)\\n        IGraphToken graphToken = graphToken();\\n        require(\\n            graphToken.transferFrom(curator, address(this), _tokensIn),\\n            \\\"Cannot transfer tokens to deposit\\\"\\n        );\\n\\n        // Burn withdrawal fees\\n        if (curationTax > 0) {\\n            graphToken.burn(curationTax);\\n        }\\n\\n        // Update curation pool\\n        curationPool.tokens = curationPool.tokens.add(_tokensIn.sub(curationTax));\\n        curationPool.gcs.mint(curator, signalOut);\\n\\n        emit Signalled(curator, _subgraphDeploymentID, _tokensIn, signalOut, curationTax);\\n\\n        return (signalOut, curationTax);\\n    }\\n\\n    /**\\n     * @dev Return an amount of signal to get tokens back.\\n     * @notice Burn _signal from the SubgraphDeployment curation pool\\n     * @param _subgraphDeploymentID SubgraphDeployment the curator is returning signal\\n     * @param _signalIn Amount of signal to return\\n     * @param _tokensOutMin Expected minimum amount of tokens to receive\\n     * @return Tokens returned\\n     */\\n    function burn(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _signalIn,\\n        uint256 _tokensOutMin\\n    ) external override notPartialPaused returns (uint256) {\\n        address curator = msg.sender;\\n\\n        // Validations\\n        require(_signalIn > 0, \\\"Cannot burn zero signal\\\");\\n        require(\\n            getCuratorSignal(curator, _subgraphDeploymentID) >= _signalIn,\\n            \\\"Cannot burn more signal than you own\\\"\\n        );\\n\\n        // Get the amount of tokens to refund based on returned signal\\n        uint256 tokensOut = signalToTokens(_subgraphDeploymentID, _signalIn);\\n\\n        // Slippage protection\\n        require(tokensOut >= _tokensOutMin, \\\"Slippage protection\\\");\\n\\n        // Trigger update rewards calculation\\n        _updateRewards(_subgraphDeploymentID);\\n\\n        // Update curation pool\\n        CurationPool storage curationPool = pools[_subgraphDeploymentID];\\n        curationPool.tokens = curationPool.tokens.sub(tokensOut);\\n        curationPool.gcs.burnFrom(curator, _signalIn);\\n\\n        // If all signal burnt delete the curation pool\\n        if (getCurationPoolSignal(_subgraphDeploymentID) == 0) {\\n            delete pools[_subgraphDeploymentID];\\n        }\\n\\n        // Return the tokens to the curator\\n        require(graphToken().transfer(curator, tokensOut), \\\"Error sending curator tokens\\\");\\n\\n        emit Burned(curator, _subgraphDeploymentID, tokensOut, _signalIn);\\n\\n        return tokensOut;\\n    }\\n\\n    /**\\n     * @dev Check if any GRT tokens are deposited for a SubgraphDeployment.\\n     * @param _subgraphDeploymentID SubgraphDeployment to check if curated\\n     * @return True if curated\\n     */\\n    function isCurated(bytes32 _subgraphDeploymentID) public override view returns (bool) {\\n        return pools[_subgraphDeploymentID].tokens > 0;\\n    }\\n\\n    /**\\n     * @dev Get the amount of signal a curator has in a curation pool.\\n     * @param _curator Curator owning the signal tokens\\n     * @param _subgraphDeploymentID Subgraph deployment curation pool\\n     * @return Amount of signal owned by a curator for the subgraph deployment\\n     */\\n    function getCuratorSignal(address _curator, bytes32 _subgraphDeploymentID)\\n        public\\n        override\\n        view\\n        returns (uint256)\\n    {\\n        if (address(pools[_subgraphDeploymentID].gcs) == address(0)) {\\n            return 0;\\n        }\\n        return pools[_subgraphDeploymentID].gcs.balanceOf(_curator);\\n    }\\n\\n    /**\\n     * @dev Get the amount of signal in a curation pool.\\n     * @param _subgraphDeploymentID Subgraph deployment curation poool\\n     * @return Amount of signal minted for the subgraph deployment\\n     */\\n    function getCurationPoolSignal(bytes32 _subgraphDeploymentID)\\n        public\\n        override\\n        view\\n        returns (uint256)\\n    {\\n        if (address(pools[_subgraphDeploymentID].gcs) == address(0)) {\\n            return 0;\\n        }\\n        return pools[_subgraphDeploymentID].gcs.totalSupply();\\n    }\\n\\n    /**\\n     * @dev Get the amount of token reserves in a curation pool.\\n     * @param _subgraphDeploymentID Subgraph deployment curation poool\\n     * @return Amount of token reserves in the curation pool\\n     */\\n    function getCurationPoolTokens(bytes32 _subgraphDeploymentID)\\n        external\\n        override\\n        view\\n        returns (uint256)\\n    {\\n        return pools[_subgraphDeploymentID].tokens;\\n    }\\n\\n    /**\\n     * @dev Get curation tax percentage\\n     * @return Amount the curation tax percentage in PPM\\n     */\\n    function curationTaxPercentage() external override view returns (uint32) {\\n        return _curationTaxPercentage;\\n    }\\n\\n    /**\\n     * @dev Calculate amount of signal that can be bought with tokens in a curation pool.\\n     * This function considers and excludes the deposit tax.\\n     * @param _subgraphDeploymentID Subgraph deployment to mint signal\\n     * @param _tokensIn Amount of tokens used to mint signal\\n     * @return Amount of signal that can be bought and tokens subtracted for the tax\\n     */\\n    function tokensToSignal(bytes32 _subgraphDeploymentID, uint256 _tokensIn)\\n        public\\n        override\\n        view\\n        returns (uint256, uint256)\\n    {\\n        uint256 curationTax = _tokensIn.mul(uint256(_curationTaxPercentage)).div(MAX_PPM);\\n        uint256 signalOut = _tokensToSignal(_subgraphDeploymentID, _tokensIn.sub(curationTax));\\n        return (signalOut, curationTax);\\n    }\\n\\n    /**\\n     * @dev Calculate amount of signal that can be bought with tokens in a curation pool.\\n     * @param _subgraphDeploymentID Subgraph deployment to mint signal\\n     * @param _tokensIn Amount of tokens used to mint signal\\n     * @return Amount of signal that can be bought with tokens\\n     */\\n    function _tokensToSignal(bytes32 _subgraphDeploymentID, uint256 _tokensIn)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        // Get curation pool tokens and signal\\n        CurationPool memory curationPool = pools[_subgraphDeploymentID];\\n\\n        // Init curation pool\\n        if (curationPool.tokens == 0) {\\n            require(\\n                _tokensIn >= minimumCurationDeposit,\\n                \\\"Curation deposit is below minimum required\\\"\\n            );\\n            return\\n                BancorFormula(bondingCurve)\\n                    .calculatePurchaseReturn(\\n                    SIGNAL_PER_MINIMUM_DEPOSIT,\\n                    minimumCurationDeposit,\\n                    defaultReserveRatio,\\n                    _tokensIn.sub(minimumCurationDeposit)\\n                )\\n                    .add(SIGNAL_PER_MINIMUM_DEPOSIT);\\n        }\\n\\n        return\\n            BancorFormula(bondingCurve).calculatePurchaseReturn(\\n                getCurationPoolSignal(_subgraphDeploymentID),\\n                curationPool.tokens,\\n                curationPool.reserveRatio,\\n                _tokensIn\\n            );\\n    }\\n\\n    /**\\n     * @dev Calculate number of tokens to get when burning signal from a curation pool.\\n     * @param _subgraphDeploymentID Subgraph deployment to burn signal\\n     * @param _signalIn Amount of signal to burn\\n     * @return Amount of tokens to get for an amount of signal\\n     */\\n    function signalToTokens(bytes32 _subgraphDeploymentID, uint256 _signalIn)\\n        public\\n        override\\n        view\\n        returns (uint256)\\n    {\\n        CurationPool memory curationPool = pools[_subgraphDeploymentID];\\n        uint256 curationPoolSignal = getCurationPoolSignal(_subgraphDeploymentID);\\n        require(\\n            curationPool.tokens > 0,\\n            \\\"Subgraph deployment must be curated to perform calculations\\\"\\n        );\\n        require(\\n            curationPoolSignal >= _signalIn,\\n            \\\"Signal must be above or equal to signal issued in the curation pool\\\"\\n        );\\n\\n        return\\n            BancorFormula(bondingCurve).calculateSaleReturn(\\n                curationPoolSignal,\\n                curationPool.tokens,\\n                curationPool.reserveRatio,\\n                _signalIn\\n            );\\n    }\\n\\n    /**\\n     * @dev Triggers an update of rewards due to a change in signal.\\n     * @param _subgraphDeploymentID Subgraph deployment updated\\n     */\\n    function _updateRewards(bytes32 _subgraphDeploymentID) private {\\n        IRewardsManager rewardsManager = rewardsManager();\\n        if (address(rewardsManager) != address(0)) {\\n            rewardsManager.onSubgraphSignalUpdate(_subgraphDeploymentID);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/curation/CurationStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./ICuration.sol\\\";\\nimport \\\"../governance/Managed.sol\\\";\\n\\ncontract CurationV1Storage is Managed {\\n    // -- State --\\n\\n    // Tax charged when curator deposit funds\\n    // Parts per million. (Allows for 4 decimal points, 999,999 = 99.9999%)\\n    uint32 internal _curationTaxPercentage;\\n\\n    // Default reserve ratio to configure curator shares bonding curve\\n    // Parts per million. (Allows for 4 decimal points, 999,999 = 99.9999%)\\n    uint32 public defaultReserveRatio;\\n\\n    // Minimum amount allowed to be deposited by curators to initialize a pool\\n    // This is the `startPoolBalance` for the bonding curve\\n    uint256 public minimumCurationDeposit;\\n\\n    // Bonding curve formula\\n    address public bondingCurve;\\n\\n    // Mapping of subgraphDeploymentID => CurationPool\\n    // There is only one CurationPool per SubgraphDeploymentID\\n    mapping(bytes32 => ICuration.CurationPool) public pools;\\n}\\n\"\r\n    },\r\n    \"contracts/curation/GraphCurationToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\nimport \\\"../governance/Governed.sol\\\";\\n\\n/**\\n * @title GraphCurationToken contract\\n * @dev This is the implementation of the Curation ERC20 token (GCS).\\n * GCS are created for each subgraph deployment curated in the Curation contract.\\n * The Curation contract is the owner of GCS tokens and the only one allowed to mint or\\n * burn them. GCS tokens are transferrable and their holders can do any action allowed\\n * in a standard ERC20 token implementation except for burning them.\\n */\\ncontract GraphCurationToken is ERC20, Governed {\\n    /**\\n     * @dev Graph Curation Token Contract Constructor.\\n     * @param _owner Address of the contract issuing this token\\n     */\\n    constructor(address _owner) ERC20(\\\"Graph Curation Share\\\", \\\"GCS\\\") {\\n        Governed._initialize(_owner);\\n    }\\n\\n    /**\\n     * @dev Mint new tokens.\\n     * @param _to Address to send the newly minted tokens\\n     * @param _amount Amount of tokens to mint\\n     */\\n    function mint(address _to, uint256 _amount) public onlyGovernor {\\n        _mint(_to, _amount);\\n    }\\n\\n    /**\\n     * @dev Burn tokens from an address.\\n     * @param _account Address from where tokens will be burned\\n     * @param _amount Amount of tokens to burn\\n     */\\n    function burnFrom(address _account, uint256 _amount) public onlyGovernor {\\n        _burn(_account, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tests/testnet/GDAI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"../../governance/Governed.sol\\\";\\n\\n/**\\n * @title Graph Testnet stablecoin contract\\n * @dev This is the implementation of an ERC20 stablecoin used for experiments on testnet.\\n */\\ncontract GDAI is Governed, ERC20, ERC20Burnable {\\n    address public GSR;\\n\\n    /**\\n     * @dev GDAI constructor.\\n     */\\n    constructor() ERC20(\\\"Graph DAI\\\", \\\"GDAI\\\") {\\n        Governed._initialize(msg.sender);\\n\\n        // The Governor is sent all tokens\\n        _mint(msg.sender, 100000000 ether); // 100,000,000 GDAI\\n    }\\n\\n    /**\\n     * @dev Check if the caller is the governor.\\n     */\\n    modifier onlyGovernorOrGSR {\\n        require(msg.sender == governor || msg.sender == GSR, \\\"Only Governor or GSR can call\\\");\\n        _;\\n    }\\n\\n    function setGSR(address _GSR) external onlyGovernor {\\n        GSR = _GSR;\\n    }\\n\\n    /**\\n     * @dev Mint new tokens.\\n     * @param _to Address to send the newly minted tokens\\n     * @param _amount Amount of tokens to mint\\n     */\\n    function mint(address _to, uint256 _amount) external onlyGovernorOrGSR {\\n        _mint(_to, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tests/testnet/GSRManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../../governance/Governed.sol\\\";\\nimport \\\"./GDAI.sol\\\";\\n\\n/**\\n * @title Graph Saving Rate contract\\n * Heavily influenced by Maker DAI savings rate\\n * https://github.com/makerdao/dss/blob/master/src/pot.sol\\n * @dev This contracts receives GDAI deposits and provides an interests rate for use in testnet.\\n */\\n\\ncontract GSRManager is Governed {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant ISSUANCE_RATE_DECIMALS = 1e18;\\n    uint256 public savingsRate; // savings rate being earned (dsr in DSR)\\n    uint256 public reserves; // total interest bearing GDAI (Pie in DSR)\\n    uint256 public cumulativeInterestRate; // cumulative interest rate of the contract (chi in DSR)\\n    uint256 public lastDripTime; // Last time drip was called (rho in DSR)\\n    mapping(address => uint256) public balances; // balance of interest bearing GDAI (pie in DSR)\\n    GDAI public token; // GDAI\\n\\n    event SetRate(uint256 newRate);\\n    event Drip(uint256 cumulativeInterestRate, uint256 lastDripTime);\\n    event Join(address indexed account, uint256 gdai, uint256 gsrBalance);\\n    event Exit(address indexed account, uint256 gsrBalance, uint256 gdai);\\n\\n    /**\\n     * @dev Graph Saving Rate constructor.\\n     */\\n    constructor(uint256 _savingsRate, address _gdai) {\\n        require(_savingsRate != 0, \\\"Savings rate can't be zero\\\");\\n        Governed._initialize(msg.sender);\\n        cumulativeInterestRate = ISSUANCE_RATE_DECIMALS;\\n        lastDripTime = block.timestamp;\\n        savingsRate = _savingsRate;\\n        token = GDAI(_gdai);\\n    }\\n\\n    // Governance sets savings rate\\n    function setRate(uint256 _newRate) external onlyGovernor {\\n        require(_newRate != 0, \\\"Savings rate can't be zero\\\");\\n        drip();\\n        savingsRate = _newRate;\\n        emit SetRate(savingsRate);\\n    }\\n\\n    // Update the rate and mint tokens\\n    // We enforce drip to always be called by all state changing functions. Lessens require statements\\n    function drip() public returns (uint256 updatedRate) {\\n        updatedRate = calcUpdatedRate();\\n        uint256 rateDifference = updatedRate.sub(cumulativeInterestRate);\\n        cumulativeInterestRate = updatedRate;\\n        lastDripTime = block.timestamp;\\n        token.mint(address(this), reserves.mul(rateDifference).div(ISSUANCE_RATE_DECIMALS));\\n        emit Drip(cumulativeInterestRate, lastDripTime);\\n    }\\n\\n    // Someone enters\\n    function join(uint256 _amount) external {\\n        drip();\\n        uint256 savingsBalance = _amount.mul(ISSUANCE_RATE_DECIMALS).div(cumulativeInterestRate);\\n        balances[msg.sender] = balances[msg.sender].add(savingsBalance);\\n        reserves = reserves.add(savingsBalance);\\n        token.transferFrom(msg.sender, address(this), _amount);\\n        emit Join(msg.sender, _amount, savingsBalance);\\n    }\\n\\n    // Someone exits\\n    function exit(uint256 _amount) external {\\n        drip();\\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\\n        uint256 withdrawnAmount = _amount.mul(cumulativeInterestRate).div(ISSUANCE_RATE_DECIMALS);\\n        reserves = reserves.sub(_amount);\\n        token.transfer(msg.sender, withdrawnAmount);\\n        emit Exit(msg.sender, _amount, withdrawnAmount);\\n    }\\n\\n    // Calculate the new cumulative interest rate\\n    function calcUpdatedRate() public view returns (uint256 updatedRate) {\\n        updatedRate = cumulativeInterestRate\\n            .mul(_pow(savingsRate, block.timestamp - lastDripTime, ISSUANCE_RATE_DECIMALS))\\n            .div(ISSUANCE_RATE_DECIMALS);\\n    }\\n\\n    // Calculate the total balance a user would have if they withdrew\\n    function calcReturn(address _account) external view returns (uint256 totalBalance) {\\n        uint256 updatedRate = calcUpdatedRate();\\n        totalBalance = balances[_account].mul(updatedRate).div(ISSUANCE_RATE_DECIMALS);\\n    }\\n\\n    /** TODO - have a math library and use it here and in RewardsMAnager\\n     * @dev Raises x to the power of n with scaling factor of base.\\n     * Based on: https://github.com/makerdao/dss/blob/master/src/pot.sol#L81\\n     * @param x Base of the exponentiation\\n     * @param n Exponent\\n     * @param base Scaling factor\\n     * @return z Exponential of n with base x\\n     */\\n    function _pow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 base\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n                case 0 {\\n                    switch n\\n                        case 0 {\\n                            z := base\\n                        }\\n                        default {\\n                            z := 0\\n                        }\\n                }\\n                default {\\n                    switch mod(n, 2)\\n                        case 0 {\\n                            z := base\\n                        }\\n                        default {\\n                            z := x\\n                        }\\n                    let half := div(base, 2) // for rounding.\\n                    for {\\n                        n := div(n, 2)\\n                    } n {\\n                        n := div(n, 2)\\n                    } {\\n                        let xx := mul(x, x)\\n                        if iszero(eq(div(xx, x), x)) {\\n                            revert(0, 0)\\n                        }\\n                        let xxRound := add(xx, half)\\n                        if lt(xxRound, xx) {\\n                            revert(0, 0)\\n                        }\\n                        x := div(xxRound, base)\\n                        if mod(n, 2) {\\n                            let zx := mul(z, x)\\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\\n                                revert(0, 0)\\n                            }\\n                            let zxRound := add(zx, half)\\n                            if lt(zxRound, zx) {\\n                                revert(0, 0)\\n                            }\\n                            z := div(zxRound, base)\\n                        }\\n                    }\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@statechannels/nitro-protocol/contracts/ERC20AssetHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\nimport './AssetHolder.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/**\\n * @dev Ther ERC20AssetHolder contract extends the AssetHolder contract, and adds the following functionality: it allows ERC20 tokens to be escrowed against a state channelId and to be transferred to external destinations.\\n */\\ncontract ERC20AssetHolder is AssetHolder {\\n    using SafeMath for uint256;\\n\\n    IERC20 public Token;\\n\\n    /**\\n     * @notice Constructor function storing the AdjudicatorAddress and instantiating an interface to an ERC20 Token contract.\\n     * @dev Constructor function storing the AdjudicatorAddress and instantiating an interface to an ERC20 Token contract.\\n     * @param _AdjudicatorAddress Address of an Adjudicator  contract, supplied at deploy-time.\\n     * @param _TokenAddress Address of an ERC20 Token  contract, supplied at deploy-time.\\n     */\\n    constructor(address _AdjudicatorAddress, address _TokenAddress) {\\n        AdjudicatorAddress = _AdjudicatorAddress;\\n        Token = IERC20(_TokenAddress);\\n    }\\n\\n    /**\\n     * @notice Deposit ERC20 tokens against a given destination.\\n     * @dev Deposit ERC20 tokens against a given destination.\\n     * @param destination ChannelId to be credited.\\n     * @param expectedHeld The amount of tokens that the depositor believes are _already_ escrowed against the channelId.\\n     * @param amount The intended number of tokens to be deposited.\\n     */\\n    function deposit(\\n        bytes32 destination,\\n        uint256 expectedHeld,\\n        uint256 amount\\n    ) public {\\n        require(!_isExternalDestination(destination), 'Cannot deposit to external destination');\\n        uint256 amountDeposited;\\n        // this allows participants to reduce the wait between deposits, while protecting them from losing funds by depositing too early. Specifically it protects against the scenario:\\n        // 1. Participant A deposits\\n        // 2. Participant B sees A's deposit, which means it is now safe for them to deposit\\n        // 3. Participant B submits their deposit\\n        // 4. The chain re-orgs, leaving B's deposit in the chain but not A's\\n        require(\\n            holdings[destination] >= expectedHeld,\\n            'Deposit | holdings[destination] is less than expected'\\n        );\\n        require(\\n            holdings[destination] < expectedHeld.add(amount),\\n            'Deposit | holdings[destination] already meets or exceeds expectedHeld + amount'\\n        );\\n\\n        // The depositor wishes to increase the holdings against channelId to amount + expectedHeld\\n        // The depositor need only deposit (at most) amount + (expectedHeld - holdings) (the term in parentheses is non-positive)\\n\\n        amountDeposited = expectedHeld.add(amount).sub(holdings[destination]); // strictly positive\\n        // require successful deposit before updating holdings (protect against reentrancy)\\n        require(\\n            Token.transferFrom(msg.sender, address(this), amountDeposited),\\n            'Could not deposit ERC20s'\\n        );\\n        holdings[destination] = holdings[destination].add(amountDeposited);\\n        emit Deposited(destination, amountDeposited, holdings[destination]);\\n    }\\n\\n    /**\\n     * @notice Transfers the given amount of ERC20 tokens to a supplied ethereum address.\\n     * @dev Transfers the given amount of ERC20 tokens to a supplied ethereum address.\\n     * @param destination Ethereum address to be credited.\\n     * @param amount Quantity of tokens to be transferred.\\n     */\\n    function _transferAsset(address payable destination, uint256 amount) internal virtual override {\\n        require(Token.transfer(destination, amount), 'Could not transfer ERC20 tokens');\\n    }\\n}\\n\"\r\n    },\r\n    \"@statechannels/nitro-protocol/contracts/AssetHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\nimport './Outcome.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport './interfaces/IAssetHolder.sol';\\n\\n/**\\n * @dev An implementation of the IAssetHolder interface. The AssetHolder contract escrows ETH or tokens against state channels. It allows assets to be internally accounted for, and ultimately prepared for transfer from one channel to other channel and/or external destinations, as well as for guarantees to be claimed. Note there is no deposit function and the _transferAsset function is unimplemented; inheriting contracts should implement these functions in a manner appropriate to the asset type (e.g. ETH or ERC20 tokens).\\n */\\ncontract AssetHolder is IAssetHolder {\\n    using SafeMath for uint256;\\n\\n    address public AdjudicatorAddress;\\n\\n    mapping(bytes32 => uint256) public holdings;\\n\\n    mapping(bytes32 => bytes32) public assetOutcomeHashes;\\n\\n\\n    // **************\\n    // Public methods\\n    // **************\\n\\n    /**\\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     * @param destination External destination or channel to transfer funds *to*.\\n     */\\n    function transfer(bytes32 fromChannelId, bytes memory allocationBytes, bytes32 destination) public {\\n        // checks\\n        _requireCorrectAllocationHash(fromChannelId, allocationBytes);\\n        // effects and interactions\\n        _transfer(fromChannelId, allocationBytes, destination);\\n    }\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. Checks against the storage in this contract.\\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. Checks against the storage in this contract.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     */\\n    function transferAll(bytes32 channelId, bytes memory allocationBytes) public override {\\n        // checks\\n        _requireCorrectAllocationHash(channelId, allocationBytes);\\n        // effects and interactions\\n        _transferAll(channelId, allocationBytes);\\n    }\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\\n     */\\n    function claimAll(\\n        bytes32 guarantorChannelId,\\n        bytes memory guaranteeBytes,\\n        bytes memory allocationBytes\\n    ) public override {\\n        // checks\\n        _requireCorrectGuaranteeHash(guarantorChannelId, guaranteeBytes);\\n        Outcome.Guarantee memory guarantee = abi.decode(guaranteeBytes, (Outcome.Guarantee));\\n        _requireCorrectAllocationHash(guarantee.targetChannelId, allocationBytes);\\n        // effects and interactions\\n        _claimAll(guarantorChannelId,guarantee, allocationBytes);\\n    }\\n\\n\\n    \\n    // **************\\n    // Permissioned methods\\n    // **************\\n\\n    modifier AdjudicatorOnly {\\n        require(msg.sender == AdjudicatorAddress, 'Only the NitroAdjudicator is authorized');\\n        _;\\n    }\\n\\n        /**\\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     */\\n    function transferAllAdjudicatorOnly(bytes32 channelId, bytes calldata allocationBytes)\\n        external\\n        virtual\\n        AdjudicatorOnly\\n    {\\n        // no checks\\n        //\\n        // effects and interactions\\n        _transferAll(channelId, allocationBytes);\\n    }\\n\\n\\n    /**\\n     * @notice Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\\n     */\\n    function setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash)\\n        external\\n        AdjudicatorOnly\\n        returns (bool success)\\n    {\\n        _setAssetOutcomeHash(channelId, assetOutcomeHash);\\n        return true;\\n    }\\n\\n    // **************\\n    // Internal methods\\n    // **************\\n    \\n    /**\\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries. Does not check allocationBytes against on chain storage.\\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries. Does not check allocationBytes against on chain storage.\\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     * @param destination External destination or channel to transfer funds *to*.\\n     */\\n    function _transfer(bytes32 fromChannelId, bytes memory allocationBytes, bytes32 destination) internal {\\n        Outcome.AllocationItem[] memory allocation = abi.decode(\\n            allocationBytes,\\n            (Outcome.AllocationItem[])\\n        );\\n        uint256 balance = holdings[fromChannelId];\\n        uint256 affordsForDestination;\\n        uint256 residualAllocationAmount;\\n        uint256 _amount;\\n        uint256 i;\\n        bool deleteHash = false;\\n\\n        // loop over allocations and decrease balance until we hit the specified destination\\n        for (i = 0; i < allocation.length; i++) {\\n            if (balance == 0) {\\n                revert('_transfer | fromChannel affords 0 for destination');\\n            }\\n            _amount = allocation[i].amount;\\n            if (allocation[i].destination == destination) {\\n                 if (balance < _amount) {\\n                    affordsForDestination = balance;\\n                    residualAllocationAmount = _amount - balance;\\n                    balance = 0;\\n                } else {\\n                    affordsForDestination = _amount;\\n                    residualAllocationAmount = 0;\\n                    balance = balance.sub(_amount);\\n                }\\n            break; // means that i holds the index of the destination that may need to be altered or removed\\n            }\\n            if (balance < _amount) {\\n                balance = 0;\\n            } else {\\n                balance = balance.sub(_amount);\\n            }\\n        }\\n\\n        require(affordsForDestination > 0, '_transfer fromChannel allocates 0 to destination');\\n        \\n        // effects\\n        holdings[fromChannelId] -= affordsForDestination;\\n\\n        // construct new outcome\\n\\n        bytes memory encodedAllocation; \\n\\n        if (residualAllocationAmount > 0) {\\n            // new allocation identical save for a single entry \\n            Outcome.AllocationItem[] memory newAllocation = new Outcome.AllocationItem[](\\n                allocation.length\\n            );\\n            for (uint256 k = 0; k < allocation.length; k++) {\\n                newAllocation[k] = allocation[k];\\n                if (allocation[k].destination == destination) {\\n                    newAllocation[k].amount = residualAllocationAmount;\\n                }\\n            }\\n            encodedAllocation = abi.encode(newAllocation);\\n        }\\n\\n        if (residualAllocationAmount == 0) {\\n            Outcome.AllocationItem[] memory splicedAllocation = new Outcome.AllocationItem[](\\n                allocation.length - 1\\n            );\\n            // full payout so we want to splice a shorter outcome\\n            for (uint256 k = 0; k < i; k++) {\\n                splicedAllocation[k] = allocation[k];\\n            }\\n            for (uint256 k = i + 1; k < allocation.length; k++) {\\n                splicedAllocation[k - 1] = allocation[k];\\n            }\\n            if (splicedAllocation.length == 0) {\\n                deleteHash = true;\\n            }\\n            encodedAllocation = abi.encode(splicedAllocation);\\n        }\\n\\n        // replace or delete hash\\n        if (deleteHash) {\\n            delete assetOutcomeHashes[fromChannelId];\\n        } else {\\n            assetOutcomeHashes[fromChannelId] = keccak256(\\n                abi.encode(\\n                    Outcome.AssetOutcome(\\n                        uint8(Outcome.AssetOutcomeType.Allocation),\\n                        encodedAllocation\\n                    )\\n                )\\n            );\\n        } \\n\\n\\n        // storage updated BEFORE external contracts called (prevent reentrancy attacks)\\n        if (_isExternalDestination(destination)) {\\n            _transferAsset(_bytes32ToAddress(destination), affordsForDestination);    \\n        } else {\\n            holdings[destination] += affordsForDestination;\\n        }\\n        // Event emitted regardless of success of external calls\\n        emit AssetTransferred(fromChannelId, destination, affordsForDestination);\\n\\n        \\n    }\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. Does not check allocationBytes against on chain storage.\\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. Does not check allocationBytes against on chain storage.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     */\\n    function _transferAll(bytes32 channelId, bytes memory allocationBytes) internal {\\n        Outcome.AllocationItem[] memory allocation = abi.decode(\\n            allocationBytes,\\n            (Outcome.AllocationItem[])\\n        );\\n        uint256 balance = holdings[channelId];\\n        uint256 numPayouts = 0;\\n        uint256 numNewAllocationItems = allocation.length;\\n        uint256 _amount;\\n        bool overlap;\\n        uint256 finalPayoutAmount;\\n        uint256 firstNewAllocationItemAmount;\\n\\n        for (uint256 i = 0; i < allocation.length; i++) {\\n            if (balance == 0) {\\n                // if funds are completely depleted, keep the allocationItem and do not pay out\\n                break;\\n            } else {\\n                _amount = allocation[i].amount;\\n                if (balance < _amount) {\\n                    // if funds still exist but are insufficient for this allocationItem, payout what's available and keep the allocationItem (but reduce the amount allocated)\\n                    // this block is never executed more than once\\n                    numPayouts++;\\n                    overlap = true;\\n                    finalPayoutAmount = balance;\\n                    firstNewAllocationItemAmount = _amount.sub(balance);\\n                    balance = 0;\\n                } else {\\n                    // if ample funds still exist, pay them out and discard the allocationItem\\n                    numPayouts++;\\n                    numNewAllocationItems = numNewAllocationItems.sub(1);\\n                    balance = balance.sub(_amount);\\n                }\\n            }\\n        }\\n\\n        // effects\\n        holdings[channelId] = balance;\\n\\n        if (numNewAllocationItems > 0) {\\n            // construct newAllocation\\n            Outcome.AllocationItem[] memory newAllocation = new Outcome.AllocationItem[](\\n                numNewAllocationItems\\n            );\\n            for (uint256 k = 0; k < numNewAllocationItems; k++) {\\n                newAllocation[k] = allocation[allocation.length.sub(numNewAllocationItems).add(k)];\\n                if (overlap && k == 0) {\\n                    newAllocation[k].amount = firstNewAllocationItemAmount;\\n                }\\n            }\\n\\n            // store hash\\n            assetOutcomeHashes[channelId] = keccak256(\\n                abi.encode(\\n                    Outcome.AssetOutcome(\\n                        uint8(Outcome.AssetOutcomeType.Allocation),\\n                        abi.encode(newAllocation)\\n                    )\\n                )\\n            );\\n        } else {\\n            delete assetOutcomeHashes[channelId];\\n        }\\n\\n\\n        // holdings updated BEFORE asset transferred (prevent reentrancy attacks)\\n        uint256 payoutAmount;\\n        for (uint256 m = 0; m < numPayouts; m++) {\\n            if (overlap && m == numPayouts.sub(1)) {\\n                payoutAmount = finalPayoutAmount;\\n            } else {\\n                payoutAmount = allocation[m].amount;\\n            }\\n            if (_isExternalDestination(allocation[m].destination)) {\\n                _transferAsset(_bytes32ToAddress(allocation[m].destination), payoutAmount);\\n            } else {\\n                holdings[allocation[m].destination] += payoutAmount;\\n            }\\n            // Event emitted regardless of success of external calls\\n            emit AssetTransferred(channelId, allocation[m].destination, payoutAmount);\\n        }\\n    }\\n\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Does not check allocationBytes against on chain storage.\\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Does not check allocationBytes against on chain storage.\\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\\n     * @param guarantee The guarantee\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\\n     */\\n    function _claimAll(\\n        bytes32 guarantorChannelId,\\n        Outcome.Guarantee memory guarantee,\\n        bytes memory allocationBytes\\n    ) internal {\\n        uint256 balance = holdings[guarantorChannelId];\\n\\n        Outcome.AllocationItem[] memory allocation = abi.decode(\\n            allocationBytes,\\n            (Outcome.AllocationItem[])\\n        ); // this remains constant length\\n\\n        uint256[] memory payouts = new uint256[](allocation.length);\\n        uint256 newAllocationLength = allocation.length;\\n\\n        // first increase payouts according to guarantee\\n        for (uint256 i = 0; i < guarantee.destinations.length; i++) {\\n            if (balance == 0) {\\n                break;\\n            }\\n            // for each destination in the guarantee\\n            bytes32 _destination = guarantee.destinations[i];\\n            for (uint256 j = 0; j < allocation.length; j++) {\\n                if (balance == 0) {\\n                    break;\\n                }\\n                if (_destination == allocation[j].destination) {\\n                    // find amount allocated to that destination (if it exists in channel alllocation)\\n                    uint256 _amount = allocation[j].amount;\\n                    if (_amount > 0) {\\n                        if (balance >= _amount) {\\n                            balance = balance.sub(_amount);\\n                            allocation[j].amount = 0; // subtract _amount;\\n                            newAllocationLength = newAllocationLength.sub(1);\\n                            payouts[j] += _amount;\\n                            break;\\n                        } else {\\n                            allocation[j].amount = _amount.sub(balance);\\n                            payouts[j] += balance;\\n                            balance = 0;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // next, increase payouts according to original allocation order\\n        // this block only has an effect if balance > 0\\n        for (uint256 j = 0; j < allocation.length; j++) {\\n            // for each entry in the target channel's outcome\\n            if (balance == 0) {\\n                break;\\n            }\\n            uint256 _amount = allocation[j].amount;\\n            if (_amount > 0) {\\n                if (balance >= _amount) {\\n                    balance = balance.sub(_amount);\\n                    allocation[j].amount = 0; // subtract _amount;\\n                    newAllocationLength = newAllocationLength.sub(1);\\n                    payouts[j]+= _amount;\\n                } else {\\n                    allocation[j].amount = _amount.sub(balance);\\n                    payouts[j]+= balance;\\n                    balance = 0;\\n                }\\n            }\\n        }\\n\\n        // EFFECTS\\n        holdings[guarantorChannelId] = balance;\\n       \\n\\n        // at this point have payouts array of uint256s, each corresponding to original destinations\\n        // and allocations has some zero amounts which we want to prune\\n        Outcome.AllocationItem[] memory newAllocation;\\n        if (newAllocationLength > 0) {\\n            newAllocation = new Outcome.AllocationItem[](newAllocationLength);\\n        }\\n\\n        uint256 k = 0;\\n        for (uint256 j = 0; j < allocation.length; j++) {\\n            // for each destination in the target channel's allocation\\n            if (allocation[j].amount > 0) {\\n                newAllocation[k] = allocation[j];\\n                k++;\\n            }\\n        }\\n        assert(k == newAllocationLength);\\n\\n        if (newAllocationLength > 0) {\\n            // store hash\\n            assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\\n                abi.encode(\\n                    Outcome.AssetOutcome(\\n                        uint8(Outcome.AssetOutcomeType.Allocation),\\n                        abi.encode(newAllocation)\\n                    )\\n                )\\n            );\\n        } else {\\n            delete assetOutcomeHashes[guarantorChannelId];\\n            delete assetOutcomeHashes[guarantee.targetChannelId];\\n        }\\n\\n        // INTERACTIONS\\n        for (uint256 j = 0; j < allocation.length; j++) {\\n            // for each destination in the target channel's allocation\\n            if (payouts[j] > 0) {\\n                if (_isExternalDestination(allocation[j].destination)) {\\n                    _transferAsset(_bytes32ToAddress(allocation[j].destination), payouts[j]);\\n                } else {\\n                    holdings[allocation[j].destination] += payouts[j];\\n                }\\n            emit AssetTransferred(\\n                        guarantorChannelId,\\n                        allocation[j].destination,\\n                        payouts[j]\\n                    );\\n            }\\n        }\\n    }\\n   \\n\\n    /**\\n     * @notice Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping\\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping\\n     * @param channelId Unique identifier for a state channel.\\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\\n     */\\n    function _setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash) internal {\\n        require(assetOutcomeHashes[channelId] == bytes32(0), 'Outcome hash already exists');\\n        assetOutcomeHashes[channelId] = assetOutcomeHash;\\n    }\\n\\n    /**\\n     * @notice Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\\n     * @dev Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\\n     * @param destination ethereum address to be credited.\\n     * @param amount Quantity of assets to be transferred.\\n     */\\n    function _transferAsset(address payable destination, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @notice Checks if a given destination is external (and can therefore have assets transferred to it) or not.\\n     * @dev Checks if a given destination is external (and can therefore have assets transferred to it) or not.\\n     * @param destination Destination to be checked.\\n     * @return True if the destination is external, false otherwise.\\n     */\\n    function _isExternalDestination(bytes32 destination) internal pure returns (bool) {\\n        return uint96(bytes12(destination)) == 0;\\n    }\\n\\n    /**\\n     * @notice Converts an ethereum address to a nitro external destination.\\n     * @dev Converts an ethereum address to a nitro external destination.\\n     * @param participant The address to be converted.\\n     * @return The input address left-padded with zeros.\\n     */\\n    function _addressToBytes32(address participant) internal pure returns (bytes32) {\\n        return bytes32(uint256(participant));\\n    }\\n\\n    /**\\n     * @notice Converts a nitro destination to an ethereum address.\\n     * @dev Converts a nitro destination to an ethereum address.\\n     * @param destination The destination to be converted.\\n     * @return The rightmost 160 bits of the input string.\\n     */\\n    function _bytes32ToAddress(bytes32 destination) internal pure returns (address payable) {\\n        return address(uint160(uint256(destination)));\\n    }\\n\\n    // **************\\n    // Requirers\\n    // **************\\n\\n    function _requireCorrectAllocationHash(bytes32 channelId, bytes memory allocationBytes) internal view {\\n        require(\\n            assetOutcomeHashes[channelId] ==\\n                keccak256(\\n                    abi.encode(\\n                        Outcome.AssetOutcome(\\n                            uint8(Outcome.AssetOutcomeType.Allocation),\\n                            allocationBytes\\n                        )\\n                    )\\n                ),\\n            'AssetHolder | submitted allocationBytes data does not match stored assetOutcomeHash'\\n        );\\n    }\\n\\n    function _requireCorrectGuaranteeHash(bytes32 guarantorChannelId, bytes memory guaranteeBytes) internal view {\\n        require(\\n            assetOutcomeHashes[guarantorChannelId] ==\\n                keccak256(\\n                    abi.encode(\\n                        Outcome.AssetOutcome(\\n                            uint8(Outcome.AssetOutcomeType.Guarantee),\\n                            guaranteeBytes\\n                        )\\n                    )\\n                ),\\n            'AssetHolder | submitted guaranteeBytes data does not match stored assetOutcomeHash'\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@statechannels/nitro-protocol/contracts/Outcome.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Outcome {\\n    //An outcome is an array of OutcomeItems\\n    // Outcome = OutcomeItem[]\\n    // OutcomeItem = (AssetHolderAddress, AssetOutcome)\\n    // AssetOutcome = (AssetOutcomeType, Allocation | Guarantee)\\n    // Allocation = AllocationItem[]\\n    // AllocationItem = (Destination, Amount)\\n    // Guarantee = (ChannelAddress, Destination[])\\n    // Destination = ChannelAddress | ExternalDestination\\n\\n    struct OutcomeItem {\\n        address assetHolderAddress;\\n        bytes assetOutcomeBytes; // abi.encode(AssetOutcome)\\n    }\\n\\n    enum AssetOutcomeType {Allocation, Guarantee}\\n\\n    struct AssetOutcome {\\n        uint8 assetOutcomeType; // AssetOutcomeType.Allocation or AssetOutcomeType.Guarantee\\n        bytes allocationOrGuaranteeBytes; // abi.encode(AllocationItem[]) or abi.encode(Guarantee), depending on OutcomeType\\n    }\\n\\n    // reserve Allocation to refer to AllocationItem[]\\n    struct AllocationItem {\\n        bytes32 destination;\\n        uint256 amount;\\n    }\\n\\n    struct Guarantee {\\n        bytes32 targetChannelId;\\n        bytes32[] destinations;\\n    }\\n}\\n\"\r\n    },\r\n    \"@statechannels/nitro-protocol/contracts/interfaces/IAssetHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev The IAssetHolder interface calls for functions that allow assets to be transferred from one channel to other channel and/or external destinations, as well as for guarantees to be claimed.\\n */\\ninterface IAssetHolder {\\n    /**\\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel.\\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel.\\n     * @param channelId Unique identifier for a state channel.\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\\n     */\\n    function transferAll(bytes32 channelId, bytes calldata allocationBytes) external;\\n\\n    /**\\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\\n     */\\n    function claimAll(\\n        bytes32 guarantorChannelId,\\n        bytes calldata guaranteeBytes,\\n        bytes calldata allocationBytes\\n    ) external;\\n\\n    /**\\n     * @dev Indicates that `amountDeposited` has been deposited into `destination`.\\n     * @param destination The channel being deposited into.\\n     * @param amountDeposited The amount being deposited.\\n     * @param destinationHoldings The new holdings for `destination`.\\n     */\\n    event Deposited(\\n        bytes32 indexed destination,\\n        uint256 amountDeposited,\\n        uint256 destinationHoldings\\n    );\\n\\n    /**\\n     * @dev Indicates that `amount` assets have been transferred (internally or externally) to the destination denoted by `destination`.\\n     * @param channelId The channelId of the funds being withdrawn.\\n     * @param destination An internal destination (channelId) of external destination (padded ethereum address)\\n     * @param amount Number of assets transferred (wei or tokens).\\n     */\\n    event AssetTransferred(bytes32 indexed channelId, bytes32 indexed destination, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/statechannels/GRTAssetHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@statechannels/nitro-protocol/contracts/ERC20AssetHolder.sol\\\";\\n\\nimport \\\"../governance/IController.sol\\\";\\nimport \\\"../staking/IStaking.sol\\\";\\n\\n/// @title GRTAssetHolder - Container for funds used to pay an indexer off-chain\\ncontract GRTAssetHolder is ERC20AssetHolder {\\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\\n\\n    IController public Controller;\\n\\n    constructor(\\n        address _AdjudicatorAddress,\\n        address _TokenAddress,\\n        IController _Controller\\n    ) ERC20AssetHolder(_AdjudicatorAddress, _TokenAddress) {\\n        AdjudicatorAddress = _AdjudicatorAddress;\\n        Controller = _Controller;\\n    }\\n\\n    function staking() public view returns (IStaking) {\\n        return IStaking(Controller.getContractProxy(keccak256(\\\"Staking\\\")));\\n    }\\n\\n    function approveAll() external {\\n        require(\\n            Token.approve(address(staking()), MAX_UINT256),\\n            \\\"GRTAssetHolder: Token approval failed\\\"\\n        );\\n    }\\n\\n    function _transferAsset(address payable destination, uint256 amount) internal override {\\n        IStaking _staking = staking();\\n\\n        if (_staking.isAllocation(destination)) {\\n            _staking.collect(amount, destination);\\n            return;\\n        }\\n\\n        require(Token.transfer(destination, amount), \\\"GRTAssetHolder: transferring tokens failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Controller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IController.sol\\\";\\nimport \\\"./IManaged.sol\\\";\\nimport \\\"./Governed.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\n/**\\n * @title Graph Controller contract\\n * @dev Controller is a registry of contracts for convenience. Inspired by Livepeer:\\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\\n */\\ncontract Controller is Governed, Pausable, IController {\\n    // Track contract ids to contract proxy address\\n    mapping(bytes32 => address) private registry;\\n\\n    event SetContractProxy(bytes32 indexed id, address contractAddress);\\n\\n    /** \\n     * @dev Contract constructor.\\n     */\\n    constructor() {\\n        Governed._initialize(msg.sender);\\n\\n        _setPaused(true);\\n    }\\n\\n    /**\\n     * @dev Check if the caller is the governor or pause guardian.\\n     */\\n    modifier onlyGovernorOrGuardian {\\n        require(\\n            msg.sender == governor || msg.sender == pauseGuardian,\\n            \\\"Only Governor or Guardian can call\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Getter to access governor\\n     */\\n    function getGovernor() external override view returns (address) {\\n        return governor;\\n    }\\n\\n    // -- Registry --\\n\\n    /**\\n     * @notice Register contract id and mapped address\\n     * @param _id Contract id (keccak256 hash of contract name)\\n     * @param _contractAddress Contract address\\n     */\\n    function setContractProxy(bytes32 _id, address _contractAddress)\\n        external\\n        override\\n        onlyGovernor\\n    {\\n        require(_contractAddress != address(0), \\\"Contract address must be set\\\");\\n        registry[_id] = _contractAddress;\\n        emit SetContractProxy(_id, _contractAddress);\\n    }\\n\\n    /**\\n     * @notice Unregister a contract address\\n     * @param _id Contract id (keccak256 hash of contract name)\\n     */\\n    function unsetContractProxy(bytes32 _id)\\n        external\\n        override\\n        onlyGovernor\\n    {\\n        registry[_id] = address(0);\\n        emit SetContractProxy(_id, address(0));\\n    }\\n\\n    /**\\n     * @notice Get contract proxy address by its id\\n     * @param _id Contract id\\n     */\\n    function getContractProxy(bytes32 _id) public override view returns (address) {\\n        return registry[_id];\\n    }\\n\\n    /**\\n     * @notice Update contract's controller\\n     * @param _id Contract id (keccak256 hash of contract name)\\n     * @param _controller Controller address\\n     */\\n    function updateController(bytes32 _id, address _controller) external override onlyGovernor {\\n        require(_controller != address(0), \\\"Controller must be set\\\");\\n        return IManaged(registry[_id]).setController(_controller);\\n    }\\n\\n    // -- Pausing --\\n\\n    /**\\n     * @notice Change the partial paused state of the contract\\n     * Partial pause is intended as a partial pause of the protocol\\n     */\\n    function setPartialPaused(bool _partialPaused) external override onlyGovernorOrGuardian {\\n        _setPartialPaused(_partialPaused);\\n    }\\n\\n    /**\\n     * @notice Change the paused state of the contract\\n     * Full pause most of protocol functions\\n     */\\n    function setPaused(bool _paused) external override onlyGovernorOrGuardian {\\n        _setPaused(_paused);\\n    }\\n\\n    /**\\n     * @notice Change the Pause Guardian\\n     * @param _newPauseGuardian The address of the new Pause Guardian\\n     */\\n    function setPauseGuardian(address _newPauseGuardian) external override onlyGovernor {\\n        require(_newPauseGuardian != address(0), \\\"PauseGuardian must be set\\\");\\n        _setPauseGuardian(_newPauseGuardian);\\n    }\\n\\n    /**\\n     * @notice Getter to access paused\\n     */\\n    function paused() external override view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @notice Getter to access partial pause status\\n     */\\n    function partialPaused() external override view returns (bool) {\\n        return _partialPaused;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ncontract Pausable {\\n    // Partial paused paused exit and enter functions for GRT, but not internal\\n    // functions, such as allocating\\n    bool internal _partialPaused;\\n    // Paused will pause all major protocol functions\\n    bool internal _paused;\\n\\n    // Time last paused for both pauses\\n    uint256 public lastPausePartialTime;\\n    uint256 public lastPauseTime;\\n\\n    // Pause guardian is a separate entity from the governor that can pause\\n    address public pauseGuardian;\\n\\n    event PartialPauseChanged(bool isPaused);\\n    event PauseChanged(bool isPaused);\\n    event NewPauseGuardian(address indexed oldPauseGuardian, address indexed pauseGuardian);\\n\\n    /**\\n     * @notice Change the partial paused state of the contract\\n     */\\n    function _setPartialPaused(bool _toPause) internal {\\n        if (_toPause == _partialPaused) {\\n            return;\\n        }\\n        _partialPaused = _toPause;\\n        if (_partialPaused) {\\n            lastPausePartialTime = block.timestamp;\\n        }\\n        emit PartialPauseChanged(_partialPaused);\\n    }\\n\\n    /**\\n     * @notice Change the paused state of the contract\\n     */\\n    function _setPaused(bool _toPause) internal {\\n        if (_toPause == _paused) {\\n            return;\\n        }\\n        _paused = _toPause;\\n        if (_paused) {\\n            lastPauseTime = block.timestamp;\\n        }\\n        emit PauseChanged(_paused);\\n    }\\n\\n    /**\\n     * @notice Change the Pause Guardian\\n     * @param newPauseGuardian The address of the new Pause Guardian\\n     */\\n    function _setPauseGuardian(address newPauseGuardian) internal {\\n        address oldPauseGuardian = pauseGuardian;\\n        pauseGuardian = newPauseGuardian;\\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tests/GovernedMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../governance/Governed.sol\\\";\\n\\n/**\\n * @title GovernedMock contract\\n */\\ncontract GovernedMock is Governed {\\n    constructor() {\\n        Governed._initialize(msg.sender);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"NewOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"NewPendingOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GraphCurationToken","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008fe00a685bcb3b2cc296ff6ffeab10aca4ce1538","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}