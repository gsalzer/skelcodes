{"status":"1","message":"OK","result":[{"SourceCode":"{\"GorvernorAlpha.sol\":{\"content\":\"pragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./SafeMath.sol\\\";\\n// File: contracts/governance/GovernorAlpha.sol\\n\\n\\n// Original work from Compound: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\\n// Modified to work in the YAM system\\n\\n// all votes work on underlying _auscBalances[address], not balanceOf(address)\\n\\n// Original audit: https://blog.openzeppelin.com/compound-alpha-governance-system-audit/\\n// Overview:\\n//    No Critical\\n//    High:\\n//      Issue:\\n//        Approved proposal may be impossible to queue, cancel or execute\\n//        Fixed with `proposalMaxOperations`\\n//      Issue:\\n//        Queued proposal with repeated actions cannot be executed\\n//        Fixed by explicitly disallow proposals with repeated actions to be queued in the Timelock contract.\\n//\\n// Changes made by YAM after audit:\\n//    Formatting, naming, \\u0026 uint256 instead of uint\\n//    Since YAM supply changes, updated quorum \\u0026 proposal requirements\\n//    If any uint96, changed to uint256 to match YAM as opposed to comp\\n\\ncontract GovernorStorage {\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n\\n        /// @notice Whether or not the voter supports the proposal\\n        bool support;\\n\\n        /// @notice The number of votes the voter had, which were cast\\n        uint256 votes;\\n    }\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint256 id;\\n\\n        /// @notice Creator of the proposal\\n        address proposer;\\n\\n        /// @notice Approver of the proposal\\n        address approver;\\n        \\n        /// @notice The block number the proposal is created on\\n        uint256 createBlock;\\n\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint256 eta;\\n\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint[] values;\\n\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint256 startBlock;\\n\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint256 endBlock;\\n\\n        /// @notice Current number of votes in favor of this proposal\\n        uint256 forVotes;\\n\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint256 againstVotes;\\n\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping (address =\\u003e Receipt) receipts;\\n    }\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Created,\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed\\n    }\\n\\n}\\n\\ncontract GovernorEvents {\\n     /// @notice An event emitted when a new proposal is created\\n    event ProposalCreated(uint256 id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, string description);\\n\\n    /// @notice An event emitted when a proposal is added to pending\\n    event ProposalApproved(uint256 id, address approver,  uint256 startBlock, uint256 endBlock);\\n\\n    /// @notice An event emitted when a vote has been cast on a proposal\\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\\n\\n    /// @notice An event emitted when a proposal has been canceled\\n    event ProposalCanceled(uint256 id, address callerAddress);\\n\\n    /// @notice An event emitted when a proposal has been queued in the Timelock\\n    event ProposalQueued(uint256 id, uint256 eta, address callerAddress);\\n\\n    /// @notice An event emitted when a proposal has been executed in the Timelock\\n    event ProposalExecuted(uint256 id, address callerAddress);\\n\\n    event VotingDelaySet(uint oldVotingDelay, uint newVotingDelay);\\n\\n    /// @notice An event emitted when the voting period is set\\n    event VotingPeriodSet(uint oldVotingPeriod, uint newVotingPeriod);\\n\\n    /// @notice Emitted when approve Percent is set\\n    event ApprovePercentSet(uint oldProposalPercent, uint newProposalPercent);\\n\\n    /// @notice Emitted when Quorum Percent is set\\n    event QuorumPercentSet(uint oldPercent, uint quorumPercent);\\n\\n    /// @notice Emitted when pendingAdmin is changed\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n}\\n\\ncontract AUSCMGovernor is GovernorStorage, GovernorEvents {\\n    /// @notice The name of this contract\\n    string public constant NAME = \\\"AUSCM Governor\\\";\\n    \\n    /// @notice The minimum setable approve threshold\\n    uint public constant MIN_APPROVE_THRESHOLD = 50; // 0.5% voting power\\n\\n    /// @notice The maximum setable approve threshold\\n    uint public constant MAX_APPROVE_THRESHOLD = 500; // 5% voting power\\n\\n    /// @notice The minimum setable quorum threshold\\n    uint public constant MIN_QUORUM_THRESHOLD = 50; // 0.5% voting power\\n\\n    /// @notice The maximum setable quorum threshold\\n    uint public constant MAX_QUORUM_THRESHOLD = 1000; // 10% voting power\\n\\n    /// @notice The minimum setable voting period\\n    uint public constant MIN_VOTING_PERIOD = 5760; // About 24 hours\\n\\n    /// @notice The max setable voting period\\n    uint public constant MAX_VOTING_PERIOD = 80640; // About 2 weeks\\n\\n    /// @notice The min setable voting delay\\n    uint public constant MIN_VOTING_DELAY = 1; // 1 block\\n\\n    /// @notice The max setable voting delay\\n    uint public constant MAX_VOTING_DELAY = 40320; // About 1 week\\n    \\n    /// @notice Percentage of votes needed for a proposal to pass multiplied by 100 (to accomodate 2 decimal point) i.e. 125 = 1.25%\\n    uint public quorumPercent = 400; // 4% by default\\n    \\n    /// @notice Percentage of votes needed for a proposal to be approved\\n    uint public approvePercent = 100; // 1% voting power\\n    \\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\\n    uint public votingDelay = 1; // 1 block\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    uint public votingPeriod =  17280; // ~3 days in blocks (assuming 15s blocks)\\n\\n    /// @notice The duration of the approval phase of a proposal\\n    uint public approvalPeriod = 5760; // ~1 day in blocks (assuming 15s blocks)\\n\\n    /// @notice The maximum number of actions that can be included in a proposal\\n    function proposalMaxOperations() public pure returns (uint256) { return 10; } // 10 actions\\n\\n    /// @notice The address of the Timelock\\n    TimelockInterface public timelock;\\n\\n    /// @notice The address of the governance token\\n    AUSCInterface public ausc;\\n\\n    /// @notice The address of the Governor Guardian\\n    address public guardian;\\n    \\n    /// @notice The address of the Governor Admin\\n    address public admin;\\n    \\n    /// @notice The address of the pending Admin\\n    address public pendingAdmin;\\n\\n    /// @notice The total number of proposals\\n    uint256 public proposalCount;\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping (uint256 =\\u003e Proposal) public proposals;\\n\\n    /// @notice The latest proposal for each proposer\\n    mapping (address =\\u003e uint256) public latestProposalIds;\\n\\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    function quorumVotes() public view returns (uint256) {\\n        uint256 minimumVotes =  SafeMath.div(ausc.initSupply(), 10000); // Quorum requirement is always a multiple of 0.01% of AUSC supply\\n        return SafeMath.mul(minimumVotes, quorumPercent); \\n    }\\n    \\n    /// @notice The number of votes required in order for a voter to approve a proposal\\n    function approveVotes() public view returns (uint256) {\\n        uint256 minimumVotes =  SafeMath.div(ausc.initSupply(), 10000); // Approval requirement is always a multiple of 0.01% of AUSC supply\\n        return SafeMath.mul(minimumVotes, approvePercent);\\n    }\\n\\n    /// @notice The number of Tokens required in order for a voter to create a proposal\\n    function createVotes() public pure returns (uint256) { return 9000; }\\n\\n    /// @notice The EIP-712 typehash for the contract\\u0027s domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,bool support)\\\");\\n\\n\\n    constructor(address timelock_, address ausc_) public {\\n        timelock = TimelockInterface(timelock_);\\n        ausc = AUSCInterface(ausc_);\\n        guardian = msg.sender;\\n        admin = msg.sender;\\n    }\\n\\n    function propose(\\n        address[] memory targets,\\n        uint[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas,\\n        string memory description\\n    )\\n        public\\n        returns (uint256)\\n    {\\n        require(ausc.balanceOf(msg.sender) \\u003e= createVotes(), \\\"POWERLEVEL UNDER 9000!!! Proposer balance below create threshold\\\");\\n        require(targets.length == values.length \\u0026\\u0026 targets.length == signatures.length \\u0026\\u0026 targets.length == calldatas.length, \\\"AUSCMGovernor::propose: proposal function information arity mismatch\\\");\\n        require(targets.length != 0, \\\"AUSCMGovernor::propose: must provide actions\\\");\\n        require(targets.length \\u003c= proposalMaxOperations(), \\\"AUSCMGovernor::propose: too many actions\\\");\\n\\n        uint256 latestProposalId = latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n          ProposalState proposersLatestProposalState = state(latestProposalId);\\n           require(proposersLatestProposalState != ProposalState.Pending, \\\"AUSCMGovernor::propose: one live proposal per proposer, found an already unapproved proposal\\\");\\n          require(proposersLatestProposalState != ProposalState.Active, \\\"AUSCMGovernor::propose: one live proposal per proposer, found an already active proposal\\\");\\n          require(proposersLatestProposalState != ProposalState.Created, \\\"AUSCMGovernor::propose: one live proposal per proposer, found an already created proposal\\\");\\n        }\\n\\n        uint256 startBlock = block.number;\\n        uint256 endBlock = SafeMath.add(startBlock, approvalPeriod);\\n\\n        proposalCount++;\\n        Proposal memory newProposal = Proposal({\\n            id: proposalCount,\\n            proposer: msg.sender,\\n            approver: address(0),\\n            createBlock: block.number,\\n            eta: 0,\\n            targets: targets,\\n            values: values,\\n            signatures: signatures,\\n            calldatas: calldatas,\\n            startBlock: startBlock,\\n            endBlock: endBlock,\\n            forVotes: 0,\\n            againstVotes: 0,\\n            canceled: false,\\n            executed: false\\n        });\\n\\n        proposals[newProposal.id] = newProposal;\\n        latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n        emit ProposalCreated(\\n            newProposal.id,\\n            msg.sender,\\n            targets,\\n            values,\\n            signatures,\\n            calldatas,\\n            description\\n        );\\n        return newProposal.id;\\n    }\\n    \\n    function approve(uint256 proposalId)\\n        public\\n    {\\n        require(state(proposalId) == ProposalState.Created, \\\"AUSCMGovernor::add: proposal already approved or expired\\\");\\n        require(ausc.getPriorVotes(msg.sender, SafeMath.sub(block.number, 1)) \\u003e= approveVotes(), \\\"AUSCMGovernor::propose: approver votes below approval threshold\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        uint256 startBlock = SafeMath.add(block.number, votingDelay);\\n        uint256 endBlock = SafeMath.add(startBlock, votingPeriod);\\n        proposal.approver = msg.sender;\\n        proposal.startBlock = startBlock;\\n        proposal.endBlock = endBlock;\\n        \\n        emit ProposalApproved(\\n            proposal.id,\\n            msg.sender,\\n            startBlock,\\n            endBlock\\n        );\\n\\n    }\\n\\n    function queue(uint256 proposalId)\\n        public\\n    {\\n        require(state(proposalId) == ProposalState.Succeeded, \\\"AUSCMGovernor::queue: proposal can only be queued if it is succeeded\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        uint256 eta = SafeMath.add(block.timestamp, timelock.delay());\\n        for (uint256 i = 0; i \\u003c proposal.targets.length; i++) {\\n            _queueOrRevert(\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                eta\\n            );\\n        }\\n        proposal.eta = eta;\\n        emit ProposalQueued(proposalId, eta, msg.sender);\\n    }\\n\\n    function _queueOrRevert(\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data,\\n        uint256 eta\\n    )\\n        internal\\n    {\\n        require(!timelock.queuedTransactions(\\n              keccak256(\\n                  abi.encode(\\n                      target,\\n                      value,\\n                      signature,\\n                      data,\\n                      eta\\n                  )\\n              )\\n          ),\\n          \\\"AUSCMGovernor::_queueOrRevert: proposal action already queued at eta\\\"\\n        );\\n\\n        timelock.queueTransaction(target, value, signature, data, eta);\\n    }\\n\\n    function execute(uint256 proposalId)\\n        public\\n        payable\\n    {\\n        require(state(proposalId) == ProposalState.Queued, \\\"AUSCMGovernor::execute: proposal can only be executed if it is queued\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        proposal.executed = true;\\n        for (uint256 i = 0; i \\u003c proposal.targets.length; i++) {\\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n        emit ProposalExecuted(proposalId, msg.sender);\\n    }\\n\\n    function cancel(uint256 proposalId)\\n        public\\n    {\\n        ProposalState state = state(proposalId);\\n        require(state != ProposalState.Executed, \\\"AUSCMGovernor::cancel: cannot cancel executed proposal\\\");\\n\\n        Proposal storage proposal = proposals[proposalId];\\n        require(msg.sender == guardian || msg.sender == proposal.proposer || ausc.balanceOf(proposal.approver) \\u003c approveVotes(), \\\"AUSCMGovernor::cancel: proposer above threshold\\\");\\n\\n        proposal.canceled = true;\\n        for (uint256 i = 0; i \\u003c proposal.targets.length; i++) {\\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n\\n        emit ProposalCanceled(proposalId, msg.sender);\\n    }\\n\\n    function getActions(uint256 proposalId)\\n        public\\n        view\\n        returns (\\n            address[] memory targets,\\n            uint[] memory values,\\n            string[] memory signatures,\\n            bytes[] memory calldatas\\n        )\\n    {\\n        Proposal storage p = proposals[proposalId];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    function getReceipt(uint256 proposalId, address voter)\\n        public\\n        view\\n        returns (Receipt memory)\\n    {\\n        return proposals[proposalId].receipts[voter];\\n    }\\n\\n    function state(uint256 proposalId)\\n        public\\n        view\\n        returns (ProposalState)\\n    {\\n        require(proposalCount \\u003e= proposalId \\u0026\\u0026 proposalId \\u003e 0, \\\"AUSCMGovernor::state: invalid proposal id\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (proposal.approver == address(0) \\u0026\\u0026 block.number \\u003e= SafeMath.add(proposal.createBlock, approvalPeriod)) {\\n            return ProposalState.Expired;\\n        } else if (proposal.approver == address(0)) {\\n            return ProposalState.Created;\\n        } else if (block.number \\u003c= proposal.startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number \\u003c= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (proposal.forVotes \\u003c= proposal.againstVotes || proposal.forVotes \\u003c quorumVotes()) {\\n            return ProposalState.Defeated;\\n        } else if (proposal.eta == 0) {\\n            return ProposalState.Succeeded;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.timestamp \\u003e= SafeMath.add(proposal.eta, timelock.GRACE_PERIOD())) {\\n            return ProposalState.Expired;\\n        } else {\\n            return ProposalState.Queued;\\n        }\\n    }\\n\\n    function castVote(uint256 proposalId, bool support)\\n        public\\n    {\\n        return _castVote(msg.sender, proposalId, support);\\n    }\\n\\n    function _castVote(\\n        address voter,\\n        uint256 proposalId,\\n        bool support\\n    )\\n        internal\\n    {\\n        require(state(proposalId) == ProposalState.Active, \\\"AUSCMGovernor::_castVote: voting is closed\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        Receipt storage receipt = proposal.receipts[voter];\\n        require(receipt.hasVoted == false, \\\"AUSCMGovernor::_castVote: voter already voted\\\");\\n        uint256 votes = ausc.getPriorVotes(voter, proposal.startBlock);\\n\\n        if (support) {\\n            proposal.forVotes = SafeMath.add(proposal.forVotes, votes);\\n        } else {\\n            proposal.againstVotes = SafeMath.add(proposal.againstVotes, votes);\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support;\\n        receipt.votes = votes;\\n\\n        emit VoteCast(voter, proposalId, support, votes);\\n    }\\n\\n    /**\\n      * @notice Admin function for setting the voting delay\\n      * @param newVotingDelay new voting delay, in blocks\\n      */\\n    function _setVotingDelay(uint newVotingDelay) external {\\n        require(msg.sender == admin, \\\"AUSCMGovernor::_setVotingDelay: admin only\\\");\\n        require(newVotingDelay \\u003e= MIN_VOTING_DELAY \\u0026\\u0026 newVotingDelay \\u003c= MAX_VOTING_DELAY, \\\"AUSCMGovernor::_setVotingDelay: invalid voting delay\\\");\\n        uint oldVotingDelay = votingDelay;\\n        votingDelay = newVotingDelay;\\n\\n        emit VotingDelaySet(oldVotingDelay,votingDelay);\\n    }\\n\\n    /**\\n      * @notice Admin function for setting the voting period\\n      * @param newVotingPeriod new voting period, in blocks\\n      */\\n    function _setVotingPeriod(uint newVotingPeriod) external {\\n        require(msg.sender == admin, \\\"AUSCMGovernor::_setVotingPeriod: admin only\\\");\\n        require(newVotingPeriod \\u003e= MIN_VOTING_PERIOD \\u0026\\u0026 newVotingPeriod \\u003c= MAX_VOTING_PERIOD, \\\"AUSCMGovernor::_setVotingPeriod: invalid voting period\\\");\\n        uint oldVotingPeriod = votingPeriod;\\n        votingPeriod = newVotingPeriod;\\n\\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\\n    }\\n\\n    /**\\n      * @notice Admin function for setting the approve threshold\\n      * @dev newApprovePercent must be greater than the hardcoded min\\n      * @param newApprovePercent new approve threshold\\n      */\\n    function _setApprovePercent(uint newApprovePercent) external {\\n        require(msg.sender == admin, \\\"AUSCMGovernor::_setProposalThreshold: admin only\\\");\\n        require(newApprovePercent \\u003e= MIN_APPROVE_THRESHOLD \\u0026\\u0026 newApprovePercent \\u003c= MAX_APPROVE_THRESHOLD, \\\"AUSCMGovernor::_setProposalThreshold: invalid approve threshold\\\");\\n        uint oldApprovePercent = approvePercent;\\n        approvePercent = newApprovePercent;\\n\\n        emit ApprovePercentSet(oldApprovePercent, approvePercent);\\n    }\\n\\n    /**\\n      * @notice Admin function for setting the Quorum Percent\\n      * @dev newQuorum must be greater than the hardcoded min\\n      * @param newQuorum new quorum threshold\\n      */\\n    function _setQuorumPercent(uint newQuorum) public {\\n        require(msg.sender == admin, \\\"AUSCMGovernor::_setQuorumPercent admin only\\\");\\n        require(newQuorum \\u003e= MIN_QUORUM_THRESHOLD \\u0026\\u0026 newQuorum \\u003c= MAX_QUORUM_THRESHOLD, \\\"AUSCMGovernor::_setQuorumPercent: invalid quorum percent\\\");\\n        uint oldQuorumPercent = quorumPercent;\\n        quorumPercent = newQuorum;\\n\\n        emit QuorumPercentSet(oldQuorumPercent, quorumPercent);\\n    }\\n        /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      */\\n    function _setPendingAdmin(address newPendingAdmin) external {\\n        // Check caller = admin\\n        require(msg.sender == admin, \\\"AUSCMGovernor:_setPendingAdmin: admin only\\\");\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      */\\n    function _acceptAdmin() external {\\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\\n        require(msg.sender == pendingAdmin \\u0026\\u0026 msg.sender != address(0), \\\"AUSCMGovernor:_acceptAdmin: pending admin only\\\");\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n    \\n    function _acceptTimelockAdmin()\\n        public\\n    {\\n        require(msg.sender == guardian, \\\"AUSCMGovernor::_acceptTimelockAdmin: sender must be gov guardian\\\");\\n        timelock.acceptAdmin();\\n    }\\n\\n    function __abdicate()\\n        public\\n    {\\n        require(msg.sender == guardian, \\\"AUSCMGovernor::__abdicate: sender must be gov guardian\\\");\\n        guardian = address(0);\\n    }\\n\\n    function __queueSetTimelockPendingAdmin(\\n        address newPendingAdmin,\\n        uint256 eta\\n    )\\n        public\\n    {\\n        require(msg.sender == guardian, \\\"AUSCMGovernor::__queueSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.queueTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin), eta);\\n    }\\n\\n    function __executeSetTimelockPendingAdmin(\\n        address newPendingAdmin,\\n        uint256 eta\\n    )\\n        public\\n    {\\n        require(msg.sender == guardian, \\\"AUSCMGovernor::__executeSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.executeTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin), eta);\\n    }\\n}\\n\\ninterface TimelockInterface {\\n    function delay() external view returns (uint256);\\n    function GRACE_PERIOD() external view returns (uint256);\\n    function acceptAdmin() external;\\n    function queuedTransactions(bytes32 hash) external view returns (bool);\\n    function queueTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external returns (bytes32);\\n    function cancelTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external;\\n    function executeTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external payable returns (bytes memory);\\n}\\n\\ninterface AUSCInterface {\\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function initSupply() external view returns (uint256);\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"timelock_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ausc_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldProposalPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProposalPercent\",\"type\":\"uint256\"}],\"name\":\"ApprovePercentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"}],\"name\":\"ProposalApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"callerAddress\",\"type\":\"address\"}],\"name\":\"ProposalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"callerAddress\",\"type\":\"address\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"callerAddress\",\"type\":\"address\"}],\"name\":\"ProposalQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quorumPercent\",\"type\":\"uint256\"}],\"name\":\"QuorumPercentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVotingDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotingDelay\",\"type\":\"uint256\"}],\"name\":\"VotingDelaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVotingPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotingPeriod\",\"type\":\"uint256\"}],\"name\":\"VotingPeriodSet\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"BALLOT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_APPROVE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_QUORUM_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_VOTING_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_VOTING_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_APPROVE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_QUORUM_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_VOTING_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_VOTING_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"__abdicate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"__executeSetTimelockPendingAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"__queueSetTimelockPendingAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptTimelockAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newApprovePercent\",\"type\":\"uint256\"}],\"name\":\"_setApprovePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newQuorum\",\"type\":\"uint256\"}],\"name\":\"_setQuorumPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVotingDelay\",\"type\":\"uint256\"}],\"name\":\"_setVotingDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVotingPeriod\",\"type\":\"uint256\"}],\"name\":\"_setVotingPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approvalPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approvePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approveVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ausc\",\"outputs\":[{\"internalType\":\"contract AUSCInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"castVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"createVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getActions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"internalType\":\"struct GovernorStorage.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"latestProposalIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalMaxOperations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quorumPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum GovernorStorage.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"contract TimelockInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AUSCMGovernor","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f588903bcc1d6a9d13fc624b2553479fee8252d20000000000000000000000001c7bbadc81e18f7177a95eb1593e5f5f35861b10","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://5a1c0d94b328778cc29c97f4e93b53f5a2fc624a7f1f4459d12fba992805aa52"}]}