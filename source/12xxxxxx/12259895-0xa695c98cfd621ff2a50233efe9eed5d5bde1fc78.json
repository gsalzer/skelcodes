{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.3;\n\n\n\n// Part: IRarible\n\ninterface IRarible {\n    enum AssetType {ETH, ERC20, ERC1155, ERC721, ERC721Deprecated}\n\n    struct Asset {\n        address token;\n        uint tokenId;\n        AssetType assetType;\n    }\n\n    struct OrderKey {\n        /* who signed the order */\n        address owner;\n        /* random number */\n        uint salt;\n\n        /* what has owner */\n        Asset sellAsset;\n\n        /* what wants owner */\n        Asset buyAsset;\n    }\n\n    struct Order {\n        OrderKey key;\n\n        /* how much has owner (in wei, or UINT256_MAX if ERC-721) */\n        uint selling;\n        /* how much wants owner (in wei, or UINT256_MAX if ERC-721) */\n        uint buying;\n\n        /* fee for selling */\n        uint sellerFee;\n    }\n\n    /* An ECDSA signature. */\n    struct Sig {\n        /* v parameter */\n        uint8 v;\n        /* r parameter */\n        bytes32 r;\n        /* s parameter */\n        bytes32 s;\n    }\n\n    function exchange(\n        Order memory order,\n        Sig memory sig,\n        uint buyerFee,\n        Sig memory buyerFeeSig,\n        uint amount,\n        address buyer\n    ) payable external;\n}\n\n// File: RaribleMarket.sol\n\nlibrary RaribleMarket {\n    address public constant RARIBLE = 0xcd4EC7b66fbc029C116BA9Ffb3e59351c20B5B06;\n\n    struct RaribleBuy {\n        IRarible.Order order;\n        IRarible.Sig sig;\n        uint buyerFee;\n        IRarible.Sig buyerFeeSig;\n        uint amount;\n    }\n\n    function buyAssetsForEth(bytes memory data, address recipient) public {\n        RaribleBuy[] memory raribleBuys;\n\n        (raribleBuys) = abi.decode(\n            data,\n            (RaribleBuy[])\n        );\n\n        for (uint256 i = 0; i < raribleBuys.length; i++) {\n            uint256 price = raribleBuys[i].order.buying*raribleBuys[i].amount/raribleBuys[i].order.selling;\n            price = price+(price*raribleBuys[i].buyerFee/10000);\n            _buyAssetForEth(\n                price,\n                raribleBuys[i].amount, \n                raribleBuys[i].buyerFee, \n                raribleBuys[i].order, \n                raribleBuys[i].sig, \n                raribleBuys[i].buyerFeeSig, \n                recipient\n            );\n        }\n    }\n\n    function estimateBatchAssetPriceInEth(bytes memory data) public view returns(uint256 totalCost) {\n        RaribleBuy[] memory raribleBuys;\n\n        (raribleBuys) = abi.decode(\n            data,\n            (RaribleBuy[])\n        );\n\n        for (uint256 i = 0; i < raribleBuys.length; i++) {\n            uint256 price = raribleBuys[i].order.buying*raribleBuys[i].amount/raribleBuys[i].order.selling;\n            totalCost += price+(price*raribleBuys[i].buyerFee/10000);\n        }\n    }\n\n    function _buyAssetForEth(\n        uint256 _price, \n        uint256 _amount, \n        uint256 _buyerFee, \n        IRarible.Order memory _order, \n        IRarible.Sig memory _sig, \n        IRarible.Sig memory _buyerFeeSig, \n        address _recipient\n    ) internal {\n        bytes memory _data = abi.encodeWithSelector(IRarible(RARIBLE).exchange.selector, _order, _sig, _buyerFee, _buyerFeeSig, _amount, _recipient);\n        (bool success, ) = RARIBLE.call{value:_price}(_data);\n        require(success, \"_buyAssetForEth: rarible buy failed.\");\n    }\n}\n","ABI":"[{\"inputs\":[],\"name\":\"RARIBLE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"estimateBatchAssetPriceInEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RaribleMarket","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}