{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AllowanceTarget.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./interfaces/IAllowanceTarget.sol\\\";\\n\\n/**\\n * @dev AllowanceTarget contract\\n */\\ncontract AllowanceTarget is IAllowanceTarget {\\n    using Address for address;\\n\\n    uint256 constant private TIME_LOCK_DURATION = 1 days;\\n\\n    address public spender;\\n    address public newSpender;\\n    uint256 public timelockExpirationTime;\\n\\n    modifier onlySpender() {\\n        require(spender == msg.sender, \\\"AllowanceTarget: not the spender\\\");\\n        _;\\n    }\\n\\n\\n    constructor(address _spender) public {\\n        require(_spender != address(0), \\\"AllowanceTarget: _spender should not be 0\\\");\\n\\n        // Set spender\\n        spender = _spender;\\n    }\\n\\n\\n    function setSpenderWithTimelock(address _newSpender) override external onlySpender {\\n        require(_newSpender.isContract(), \\\"AllowanceTarget: new spender not a contract\\\");\\n        require(newSpender == address(0) && timelockExpirationTime == 0, \\\"AllowanceTarget: SetSpender in progress\\\");\\n\\n        timelockExpirationTime = now + TIME_LOCK_DURATION;\\n        newSpender = _newSpender;\\n    }\\n\\n    function completeSetSpender() override external {\\n        require(timelockExpirationTime != 0, \\\"AllowanceTarget: no pending SetSpender\\\");\\n        require(now >= timelockExpirationTime, \\\"AllowanceTarget: time lock not expired yet\\\");\\n\\n        // Set new spender\\n        spender = newSpender;\\n        // Reset\\n        timelockExpirationTime = 0;\\n        newSpender = address(0);\\n    }\\n\\n\\n    function teardown() override external onlySpender {\\n        selfdestruct(payable(spender));\\n    }\\n\\n\\n    /// @dev Execute an arbitrary call. Only an authority can call this.\\n    /// @param target The call target.\\n    /// @param callData The call data.\\n    /// @return resultData The data returned by the call.\\n    function executeCall(\\n        address payable target,\\n        bytes calldata callData\\n    )\\n        override\\n        external\\n        onlySpender\\n        returns (bytes memory resultData)\\n    {\\n        bool success;\\n        (success, resultData) = target.call(callData);\\n        if (!success) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAllowanceTarget.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IAllowanceTarget {\\n    function setSpenderWithTimelock(address _newSpender) external;\\n    function completeSetSpender() external;\\n    function executeCall(address payable _target, bytes calldata _callData) external returns (bytes memory resultData);\\n    function teardown() external;\\n}\"\r\n    },\r\n    \"contracts/Spender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/IAllowanceTarget.sol\\\";\\n\\n/**\\n * @dev Spender contract\\n */\\ncontract Spender {\\n    using SafeMath for uint256;\\n\\n    // Constants do not have storage slot.\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n    uint256 constant private TIME_LOCK_DURATION = 1 days;\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    address public pendingOperator;\\n    address public allowanceTarget;\\n    mapping(address => bool) private authorized;\\n    mapping(address => bool) private tokenBlacklist;\\n    uint256 public numPendingAuthorized;\\n    mapping(uint256 => address) public pendingAuthorized;\\n    uint256 public timelockExpirationTime;\\n    uint256 public contractDeployedTime;\\n    bool public timelockActivated;\\n    mapping(address => bool) public consumeGasERC20Tokens;\\n\\n    // System events\\n    event TimeLockActivated(uint256 activatedTimeStamp);\\n    // Operator events\\n    event TransferOwnership(address newOperator);\\n    event SetAllowanceTarget(address allowanceTarget);\\n    event SetNewSpender(address newSpender);\\n    event SetConsumeGasERC20Token(address token);\\n    event TearDownAllowanceTarget(uint256 tearDownTimeStamp);\\n    event BlackListToken(address token, bool isBlacklisted);\\n    event AuthorizeSpender(address spender, bool isAuthorized);\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"Spender: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyAuthorized() {\\n        require(authorized[msg.sender], \\\"Spender: not authorized\\\");\\n        _;\\n    }\\n\\n    function setNewOperator(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"Spender: operator can not be zero address\\\");\\n        pendingOperator = _newOperator;\\n    }\\n\\n    function acceptAsOperator() external {\\n        require(pendingOperator == msg.sender, \\\"Spender: only nominated one can accept as new operator\\\");\\n        operator = pendingOperator;\\n        pendingOperator = address(0);\\n        emit TransferOwnership(pendingOperator);\\n    }\\n\\n\\n    /************************************************************\\n    *                    Timelock management                    *\\n    *************************************************************/\\n    /// @dev Everyone can activate timelock after the contract has been deployed for more than 1 day.\\n    function activateTimelock() external {\\n        bool canActivate = block.timestamp.sub(contractDeployedTime) > 1 days;\\n        require(canActivate && ! timelockActivated, \\\"Spender: can not activate timelock yet or has been activated\\\");\\n        timelockActivated = true;\\n\\n        emit TimeLockActivated(block.timestamp);\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    constructor(address _operator, address[] memory _consumeGasERC20Tokens) public {\\n        require(_operator != address(0), \\\"Spender: _operator should not be 0\\\");\\n\\n        // Set operator\\n        operator = _operator;\\n        timelockActivated = false;\\n        contractDeployedTime = block.timestamp;\\n\\n        for (uint256 i = 0; i < _consumeGasERC20Tokens.length; i++) {\\n            consumeGasERC20Tokens[_consumeGasERC20Tokens[i]] = true;\\n        }\\n    }\\n\\n    function setAllowanceTarget(address _allowanceTarget) external onlyOperator {\\n        require(allowanceTarget == address(0), \\\"Spender: can not reset allowance target\\\");\\n\\n        // Set allowanceTarget\\n        allowanceTarget = _allowanceTarget;\\n\\n        emit SetAllowanceTarget(_allowanceTarget);\\n    }\\n\\n\\n\\n    /************************************************************\\n    *          AllowanceTarget interaction functions            *\\n    *************************************************************/\\n    function setNewSpender(address _newSpender) external onlyOperator {\\n        IAllowanceTarget(allowanceTarget).setSpenderWithTimelock(_newSpender);\\n\\n        emit SetNewSpender(_newSpender);\\n    }\\n\\n    function teardownAllowanceTarget() external onlyOperator {\\n        IAllowanceTarget(allowanceTarget).teardown();\\n\\n        emit TearDownAllowanceTarget(block.timestamp);\\n    }\\n\\n\\n\\n    /************************************************************\\n    *           Whitelist and blacklist functions               *\\n    *************************************************************/\\n    function isBlacklisted(address _tokenAddr) external view returns (bool) {\\n        return tokenBlacklist[_tokenAddr];\\n    }\\n\\n    function blacklist(address[] calldata _tokenAddrs, bool[] calldata _isBlacklisted) external onlyOperator {\\n        require(_tokenAddrs.length == _isBlacklisted.length, \\\"Spender: length mismatch\\\");\\n        for (uint256 i = 0; i < _tokenAddrs.length; i++) {\\n            tokenBlacklist[_tokenAddrs[i]] = _isBlacklisted[i];\\n\\n            emit BlackListToken(_tokenAddrs[i], _isBlacklisted[i]);\\n        }\\n    }\\n    \\n    function isAuthorized(address _caller) external view returns (bool) {\\n        return authorized[_caller];\\n    }\\n\\n    function authorize(address[] calldata _pendingAuthorized) external onlyOperator {\\n        require(_pendingAuthorized.length > 0, \\\"Spender: authorize list is empty\\\");\\n        require(numPendingAuthorized == 0 && timelockExpirationTime == 0, \\\"Spender: an authorize current in progress\\\");\\n\\n        if (timelockActivated) {\\n            numPendingAuthorized = _pendingAuthorized.length;\\n            for (uint256 i = 0; i < _pendingAuthorized.length; i++) {\\n                require(_pendingAuthorized[i] != address(0), \\\"Spender: can not authorize zero address\\\");\\n                pendingAuthorized[i] = _pendingAuthorized[i];\\n            }\\n            timelockExpirationTime = now + TIME_LOCK_DURATION;\\n        } else {\\n            for (uint256 i = 0; i < _pendingAuthorized.length; i++) {\\n                require(_pendingAuthorized[i] != address(0), \\\"Spender: can not authorize zero address\\\");\\n                authorized[_pendingAuthorized[i]] = true;\\n\\n                emit AuthorizeSpender(_pendingAuthorized[i], true);\\n            }\\n        }\\n    }\\n\\n    function completeAuthorize() external {\\n        require(timelockExpirationTime != 0, \\\"Spender: no pending authorize\\\");\\n        require(now >= timelockExpirationTime, \\\"Spender: time lock not expired yet\\\");\\n\\n        for (uint256 i = 0; i < numPendingAuthorized; i++) {\\n            authorized[pendingAuthorized[i]] = true;\\n            emit AuthorizeSpender(pendingAuthorized[i], true);\\n            delete pendingAuthorized[i];\\n        }\\n        timelockExpirationTime = 0;\\n        numPendingAuthorized = 0;\\n    }\\n\\n    function deauthorize(address[] calldata _deauthorized) external onlyOperator {\\n        for (uint256 i = 0; i < _deauthorized.length; i++) {\\n            authorized[_deauthorized[i]] = false;\\n\\n            emit AuthorizeSpender(_deauthorized[i], false);\\n        }\\n    }\\n\\n    function setConsumeGasERC20Tokens(address[] memory _consumeGasERC20Tokens) external onlyOperator {\\n        for (uint256 i = 0; i < _consumeGasERC20Tokens.length; i++) {\\n            consumeGasERC20Tokens[_consumeGasERC20Tokens[i]] = true;\\n\\n            emit SetConsumeGasERC20Token(_consumeGasERC20Tokens[i]);\\n        }\\n    }\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    /// @dev Spend tokens on user's behalf. Only an authority can call this.\\n    /// @param _user The user to spend token from.\\n    /// @param _tokenAddr The address of the token.\\n    /// @param _amount Amount to spend.\\n    function spendFromUser(address _user, address _tokenAddr, uint256 _amount) external onlyAuthorized {\\n        require(! tokenBlacklist[_tokenAddr], \\\"Spender: token is blacklisted\\\");\\n\\n        // Fix gas stipend for non standard ERC20 transfer in case token contract's SafeMath violation is triggered\\n        // and all gas are consumed.\\n        uint256 gasStipend;\\n        if(consumeGasERC20Tokens[_tokenAddr]) gasStipend = 80000;\\n        else gasStipend = gasleft();\\n\\n        if (_tokenAddr != ETH_ADDRESS && _tokenAddr != ZERO_ADDRESS) {\\n\\n            uint256 balanceBefore = IERC20(_tokenAddr).balanceOf(msg.sender);\\n            (bool callSucceed, bytes memory returndata) = address(allowanceTarget).call{gas: gasStipend}(\\n                abi.encodeWithSelector(\\n                    IAllowanceTarget.executeCall.selector,\\n                    _tokenAddr,\\n                    abi.encodeWithSelector(\\n                        IERC20.transferFrom.selector,\\n                        _user,\\n                        msg.sender,\\n                        _amount\\n                    )\\n                )\\n            );\\n            require(callSucceed, \\\"Spender: ERC20 transferFrom failed\\\");\\n            bytes memory decodedReturnData = abi.decode(returndata, (bytes));\\n            if (decodedReturnData.length > 0) { // Return data is optional\\n                // Tokens like ZRX returns false on failed transfer\\n                require(abi.decode(decodedReturnData, (bool)), \\\"Spender: ERC20 transferFrom failed\\\");\\n            }\\n            // Check balance\\n            uint256 balanceAfter = IERC20(_tokenAddr).balanceOf(msg.sender);\\n            require(balanceAfter.sub(balanceBefore) == _amount, \\\"Spender: ERC20 transferFrom amount mismatch\\\");\\n        }\\n    }\\n\\n    /// @dev Spend tokens on user's behalf. Only an authority can call this.\\n    /// @param _user The user to spend token from.\\n    /// @param _tokenAddr The address of the token.\\n    /// @param _receiver The receiver of the token.\\n    /// @param _amount Amount to spend.\\n    function spendFromUserTo(address _user, address _tokenAddr, address _receiver, uint256 _amount) external onlyAuthorized {\\n        require(! tokenBlacklist[_tokenAddr], \\\"Spender: token is blacklisted\\\");\\n\\n        // Fix gas stipend for non standard ERC20 transfer in case token contract's SafeMath violation is triggered\\n        // and all gas are consumed.\\n        uint256 gasStipend;\\n        if(consumeGasERC20Tokens[_tokenAddr]) gasStipend = 80000;\\n        else gasStipend = gasleft();\\n\\n        if (_tokenAddr != ETH_ADDRESS && _tokenAddr != ZERO_ADDRESS) {\\n\\n            uint256 balanceBefore = IERC20(_tokenAddr).balanceOf(msg.sender);\\n            (bool callSucceed, bytes memory returndata) = address(allowanceTarget).call{gas: gasStipend}(\\n                abi.encodeWithSelector(\\n                    IAllowanceTarget.executeCall.selector,\\n                    _tokenAddr,\\n                    abi.encodeWithSelector(\\n                        IERC20.transferFrom.selector,\\n                        _user,\\n                        _receiver,\\n                        _amount\\n                    )\\n                )\\n            );\\n            require(callSucceed, \\\"Spender: ERC20 transferFrom failed\\\");\\n            bytes memory decodedReturnData = abi.decode(returndata, (bytes));\\n            if (decodedReturnData.length > 0) { // Return data is optional\\n                // Tokens like ZRX returns false on failed transfer\\n                require(abi.decode(decodedReturnData, (bool)), \\\"Spender: ERC20 transferFrom failed\\\");\\n            }\\n            // Check balance\\n            uint256 balanceAfter = IERC20(_tokenAddr).balanceOf(msg.sender);\\n            require(balanceAfter.sub(balanceBefore) == _amount, \\\"Spender: ERC20 transferFrom amount mismatch\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/stub/UserProxyStub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../interfaces/IAMM.sol\\\";\\n\\ncontract UserProxyStub {\\n    using SafeERC20 for IERC20;\\n\\n    // Constants do not have storage slot.\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n\\n    /**\\n     * @dev Below are the variables which consume storage slots.\\n     */\\n    address public operator;\\n    address public weth;\\n    address public ammWrapperAddr;\\n    address public pmmAddr;\\n    address public rfqAddr;\\n\\n    receive() external payable {\\n    }\\n\\n    /**\\n     * @dev Access control and ownership management.\\n     */\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"UserProxyStub: not the operator\\\");\\n        _;\\n    }\\n    /* End of access control and ownership management */\\n\\n\\n    /**\\n     * @dev Replacing constructor and initialize the contract. This function should only be called once.\\n     */\\n    constructor(address _weth) public {\\n        operator = msg.sender;\\n        weth = _weth;\\n    }\\n\\n    function upgradePMM(address _pmmAddr) external onlyOperator {\\n        pmmAddr = _pmmAddr;\\n    }\\n\\n    function upgradeAMMWrapper(address _ammWrapperAddr) external onlyOperator {\\n        ammWrapperAddr = _ammWrapperAddr;\\n    }\\n\\n    function upgradeRFQ(address _rfqAddr) external onlyOperator {\\n        rfqAddr = _rfqAddr;\\n    }\\n\\n    function toAMM(bytes calldata _payload) external payable {\\n        (bool callSucceed,) = ammWrapperAddr.call{value: msg.value}(_payload);\\n        if (callSucceed == false) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n\\n    function toPMM(bytes calldata _payload) external payable {\\n        (bool callSucceed,) = pmmAddr.call{value: msg.value}(_payload);\\n        if (callSucceed == false) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n\\n    function toRFQ(bytes calldata _payload) external payable {\\n        (bool callSucceed,) = rfqAddr.call{value: msg.value}(_payload);\\n        if (callSucceed == false) {\\n            // Get the error message returned\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAMM.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./ISetAllowance.sol\\\";\\n\\ninterface IAMM is ISetAllowance {\\n    function trade(\\n        address _makerAddress,\\n        address _fromAssetAddress,\\n        address _toAssetAddress,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _feeFactor,\\n        address _spender,\\n        address payable _receiver,\\n        uint256 _nonce,\\n        uint256 _deadline,\\n        bytes memory _sig\\n    ) payable external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISetAllowance.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface ISetAllowance {\\n    function setAllowance(address[] memory tokenList, address spender) external;\\n    function closeAllowance(address[] memory tokenList, address spender) external;\\n}\"\r\n    },\r\n    \"contracts/stub/ERC1271WalletStub.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../interfaces/ISetAllowance.sol\\\";\\nimport \\\"../interfaces/IERC1271Wallet.sol\\\";\\n\\ncontract ERC1271WalletStub is\\n    ISetAllowance,\\n    IERC1271Wallet\\n{\\n    using SafeERC20 for IERC20;\\n    // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\"))\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\\n\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n    bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    address public operator;\\n\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"Quoter: not the operator\\\");\\n        _;\\n    }\\n\\n    constructor (address _operator) public {\\n        operator = _operator;\\n    }\\n\\n    function setAllowance(address[] memory _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] memory _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, 0);\\n        }\\n    }\\n\\n    function isValidSignature(\\n        bytes calldata _data,\\n        bytes calldata _signature)\\n        override\\n        external\\n        view\\n        returns (bytes4 magicValue)\\n    {\\n        return ERC1271_MAGICVALUE;\\n    }\\n\\n    function isValidSignature(\\n        bytes32 _hash,\\n        bytes calldata _signature)\\n        override\\n        external\\n        view\\n        returns (bytes4 magicValue)\\n    {\\n        return ERC1271_MAGICVALUE_BYTES32;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC1271Wallet.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\ninterface  IERC1271Wallet {\\n\\n  /**\\n   * @notice Verifies whether the provided signature is valid with respect to the provided data\\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided data\\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n   *   > This function MAY modify Ethereum's state\\n   * @param _data       Arbitrary length data signed on the behalf of address(this)\\n   * @param _signature  Signature byte array associated with _data\\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\\n   *\\n   */\\n  function isValidSignature(\\n    bytes calldata _data,\\n    bytes calldata _signature)\\n    external\\n    view\\n    returns (bytes4 magicValue);\\n\\n  /**\\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n   *   > This function MAY modify Ethereum's state\\n   * @param _hash       keccak256 hash that was signed\\n   * @param _signature  Signature byte array associated with _data\\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\\n   */\\n  function isValidSignature(\\n    bytes32 _hash,\\n    bytes calldata _signature)\\n    external\\n    view\\n    returns (bytes4 magicValue);\\n}\"\r\n    },\r\n    \"contracts/RFQ.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./interfaces/ISpender.sol\\\";\\nimport \\\"./interfaces/IWeth.sol\\\";\\nimport \\\"./interfaces/IRFQ.sol\\\";\\nimport \\\"./interfaces/IPermanentStorage.sol\\\";\\nimport \\\"./interfaces/IERC1271Wallet.sol\\\";\\nimport \\\"./utils/RFQLibEIP712.sol\\\";\\n\\ncontract RFQ is\\n    ReentrancyGuard,\\n    IRFQ,\\n    RFQLibEIP712,\\n    SignatureValidator\\n{\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n\\n    // Constants do not have storage slot.\\n    string public constant version = \\\"5.2.0\\\";\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    string public constant SOURCE = \\\"RFQ v1\\\";\\n    uint256 private constant BPS_MAX = 10000;\\n    address public immutable userProxy;\\n    IPermanentStorage public immutable permStorage;\\n    IWETH public immutable weth;\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    ISpender public spender;\\n\\n    struct GroupedVars {\\n        bytes32 orderHash;\\n        bytes32 transactionHash;\\n    }\\n\\n    // Operator events\\n    event TransferOwnership(address newOperator);\\n    event UpgradeSpender(address newSpender);\\n    event AllowTransfer(address spender);\\n    event DisallowTransfer(address spender);\\n    event DepositETH(uint256 ethBalance);\\n\\n    event FillOrder(\\n        string source,\\n        bytes32 indexed transactionHash,\\n        bytes32 indexed orderHash,\\n        address indexed userAddr,\\n        address takerAssetAddr,\\n        uint256 takerAssetAmount,\\n        address makerAddr,\\n        address makerAssetAddr,\\n        uint256 makerAssetAmount,\\n        address receiverAddr,\\n        uint256 settleAmount,\\n        uint16 feeFactor\\n    );\\n\\n\\n    receive() external payable {}\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator {\\n        require(operator == msg.sender, \\\"RFQ: not operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyUserProxy() {\\n        require(address(userProxy) == msg.sender, \\\"RFQ: not the UserProxy contract\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"RFQ: operator can not be zero address\\\");\\n        operator = _newOperator;\\n\\n        emit TransferOwnership(_newOperator);\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    constructor (\\n        address _operator, \\n        address _userProxy, \\n        ISpender _spender, \\n        IPermanentStorage _permStorage, \\n        IWETH _weth\\n    ) public {\\n        operator = _operator;\\n        userProxy = _userProxy;\\n        spender = _spender;\\n        permStorage = _permStorage;\\n        weth = _weth;\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    /**\\n     * @dev set new Spender\\n     */\\n    function upgradeSpender(address _newSpender) external onlyOperator {\\n        require(_newSpender != address(0), \\\"RFQ: spender can not be zero address\\\");\\n        spender = ISpender(_newSpender);\\n\\n        emit UpgradeSpender(_newSpender);\\n    }\\n\\n    /**\\n     * @dev approve spender to transfer tokens from this contract. This is used to collect fee.\\n     */\\n    function setAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, MAX_UINT);\\n\\n            emit AllowTransfer(_spender);\\n        }\\n    }\\n\\n    function closeAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, 0);\\n\\n            emit DisallowTransfer(_spender);\\n        }\\n    }\\n\\n    /**\\n     * @dev convert collected ETH to WETH\\n     */\\n    function depositETH() external onlyOperator {\\n        uint256 balance = address(this).balance;\\n        if (balance > 0) {\\n            weth.deposit{value: balance}();\\n\\n            emit DepositETH(balance);\\n        }\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function fill(\\n        RFQLibEIP712.Order memory _order,\\n        bytes memory _mmSignature,\\n        bytes memory _userSignature\\n    )\\n        override\\n        payable\\n        external\\n        nonReentrant\\n        onlyUserProxy\\n        returns (uint256)\\n    {\\n        // check the order deadline and fee factor\\n        require(_order.deadline >= block.timestamp, \\\"RFQ: expired order\\\");\\n        require(_order.feeFactor < BPS_MAX, \\\"RFQ: invalid fee factor\\\");\\n\\n        GroupedVars memory vars;\\n\\n        // Validate signatures\\n        vars.orderHash = _getOrderHash(_order);\\n        require(\\n            isValidSignature(\\n                _order.makerAddr,\\n                _getOrderSignDigestFromHash(vars.orderHash),\\n                bytes(\\\"\\\"),\\n                _mmSignature\\n            ),\\n            \\\"RFQ: invalid MM signature\\\"\\n        );\\n        vars.transactionHash = _getTransactionHash(_order);\\n        require(\\n            isValidSignature(\\n                _order.takerAddr,\\n                _getTransactionSignDigestFromHash(vars.transactionHash),\\n                bytes(\\\"\\\"),\\n                _userSignature\\n            ),\\n            \\\"RFQ: invalid user signature\\\"\\n        );\\n\\n        // Set transaction as seen, PermanentStorage would throw error if transaction already seen.\\n        permStorage.setRFQTransactionSeen(vars.transactionHash);\\n\\n        // Deposit to WETH if taker asset is ETH, else transfer from user\\n        if (address(weth) == _order.takerAssetAddr) {\\n            require(\\n                msg.value == _order.takerAssetAmount,\\n                \\\"RFQ: insufficient ETH\\\"\\n            );\\n            weth.deposit{value: msg.value}();\\n        } else {\\n            spender.spendFromUser(_order.takerAddr, _order.takerAssetAddr, _order.takerAssetAmount);\\n        }\\n        // Transfer from maker\\n        spender.spendFromUser(_order.makerAddr, _order.makerAssetAddr, _order.makerAssetAmount);\\n\\n        // settle token/ETH to user\\n        return _settle(_order, vars);\\n    }\\n\\n    // settle\\n    function _settle(\\n        RFQLibEIP712.Order memory _order,\\n        GroupedVars memory _vars\\n    ) internal returns(uint256) {\\n        // Transfer taker asset to maker\\n        IERC20(_order.takerAssetAddr).safeTransfer(_order.makerAddr, _order.takerAssetAmount);\\n\\n        // Transfer maker asset to taker, sub fee\\n        uint256 settleAmount = _order.makerAssetAmount;\\n        if (_order.feeFactor > 0) {\\n            // settleAmount = settleAmount * (10000 - feeFactor) / 10000\\n            settleAmount = settleAmount.mul((BPS_MAX).sub(_order.feeFactor)).div(BPS_MAX);\\n        }\\n\\n        // Transfer token/Eth to receiver\\n        if (_order.makerAssetAddr == address(weth)){\\n            weth.withdraw(settleAmount);\\n            payable(_order.receiverAddr).transfer(settleAmount);\\n        } else {\\n            IERC20(_order.makerAssetAddr).safeTransfer(_order.receiverAddr, settleAmount);\\n        }\\n\\n        emit FillOrder(\\n            SOURCE,\\n            _vars.transactionHash,\\n            _vars.orderHash,\\n            _order.takerAddr,\\n            _order.takerAssetAddr,\\n            _order.takerAssetAmount,\\n            _order.makerAddr,\\n            _order.makerAssetAddr,\\n            _order.makerAssetAmount,\\n            _order.receiverAddr,\\n            settleAmount,\\n            uint16(_order.feeFactor)\\n        );\\n\\n        return settleAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISpender.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface ISpender {\\n    function spendFromUser(address _user, address _tokenAddr, uint256 _amount) external;\\n    function spendFromUserTo(address _user, address _tokenAddr, address _receiverAddr, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWeth.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IWETH {\\n    function balanceOf(address account) external view returns (uint256);\\n    function deposit() external payable;\\n    function withdraw(uint256 amount) external;\\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRFQ.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../utils/RFQLibEIP712.sol\\\";\\nimport \\\"./ISetAllowance.sol\\\";\\n\\ninterface IRFQ is ISetAllowance {\\n    function fill(\\n        RFQLibEIP712.Order memory _order,\\n        bytes memory _mmSignature,\\n        bytes memory _userSignature\\n    ) external payable returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPermanentStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ninterface IPermanentStorage {\\n    function wethAddr() external view returns (address);\\n    function getCurvePoolInfo(address _makerAddr, address _takerAssetAddr, address _makerAssetAddr) external view returns (int128 takerAssetIndex, int128 makerAssetIndex, uint16 swapMethod, bool supportGetDx);\\n    function setCurvePoolInfo(address _makerAddr, address[] calldata _underlyingCoins, address[] calldata _coins, bool _supportGetDx) external;\\n    function isTransactionSeen(bytes32 _transactionHash) external view returns (bool);  // Kept for backward compatability. Should be removed from AMM 5.2.1 upward\\n    function isAMMTransactionSeen(bytes32 _transactionHash) external view returns (bool);\\n    function isRFQTransactionSeen(bytes32 _transactionHash) external view returns (bool);\\n    function isRelayerValid(address _relayer) external view returns (bool);\\n    function setTransactionSeen(bytes32 _transactionHash) external;  // Kept for backward compatability. Should be removed from AMM 5.2.1 upward\\n    function setAMMTransactionSeen(bytes32 _transactionHash) external;\\n    function setRFQTransactionSeen(bytes32 _transactionHash) external;\\n    function setRelayersValid(address[] memory _relayers, bool[] memory _isValids) external;\\n}\"\r\n    },\r\n    \"contracts/utils/RFQLibEIP712.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./BaseLibEIP712.sol\\\";\\nimport \\\"./SignatureValidator.sol\\\";\\n\\ncontract RFQLibEIP712 is BaseLibEIP712 {\\n    /***********************************|\\n    |             Constants             |\\n    |__________________________________*/\\n    \\n\\n    struct Order {\\n        address takerAddr;\\n        address makerAddr;\\n        address takerAssetAddr;\\n        address makerAssetAddr;\\n        uint256 takerAssetAmount;\\n        uint256 makerAssetAmount;\\n        address receiverAddr;\\n        uint256 salt;\\n        uint256 deadline;\\n        uint256 feeFactor;\\n    }\\n\\n    bytes32 public constant ORDER_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            \\\"Order(\\\",\\n            \\\"address takerAddr,\\\",\\n            \\\"address makerAddr,\\\",\\n            \\\"address takerAssetAddr,\\\",\\n            \\\"address makerAssetAddr,\\\",\\n            \\\"uint256 takerAssetAmount,\\\",\\n            \\\"uint256 makerAssetAmount,\\\",\\n            \\\"uint256 salt,\\\",\\n            \\\"uint256 deadline,\\\",\\n            \\\"uint256 feeFactor\\\",\\n            \\\")\\\"\\n        )\\n    );\\n\\n    function _getOrderHash(Order memory _order) internal pure returns (bytes32 orderHash) {\\n        orderHash = keccak256(\\n            abi.encode(\\n                ORDER_TYPEHASH,\\n                _order.takerAddr,\\n                _order.makerAddr,\\n                _order.takerAssetAddr,\\n                _order.makerAssetAddr,\\n                _order.takerAssetAmount,\\n                _order.makerAssetAmount,\\n                _order.salt,\\n                _order.deadline,\\n                _order.feeFactor\\n            )\\n        );\\n    }\\n\\n    function _getOrderSignDigest(Order memory _order) internal view returns (bytes32 orderSignDigest) {\\n        orderSignDigest = keccak256(\\n            abi.encodePacked(\\n                EIP191_HEADER,\\n                EIP712_DOMAIN_SEPARATOR,\\n                _getOrderHash(_order)\\n            )\\n        );\\n    }\\n\\n    function _getOrderSignDigestFromHash(bytes32 _orderHash) internal view returns (bytes32 orderSignDigest) {\\n        orderSignDigest = keccak256(\\n            abi.encodePacked(\\n                EIP191_HEADER,\\n                EIP712_DOMAIN_SEPARATOR,\\n                _orderHash\\n            )\\n        );\\n    }\\n\\n    bytes32 public constant FILL_WITH_PERMIT_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            \\\"fillWithPermit(\\\",\\n            \\\"address makerAddr,\\\",\\n            \\\"address takerAssetAddr,\\\",\\n            \\\"address makerAssetAddr,\\\",\\n            \\\"uint256 takerAssetAmount,\\\",\\n            \\\"uint256 makerAssetAmount,\\\",\\n            \\\"address takerAddr,\\\",\\n            \\\"address receiverAddr,\\\",\\n            \\\"uint256 salt,\\\",\\n            \\\"uint256 deadline,\\\",\\n            \\\"uint256 feeFactor\\\",\\n            \\\")\\\"\\n        )\\n    );\\n\\n    function _getTransactionHash(Order memory _order) internal pure returns(bytes32 transactionHash) {\\n        transactionHash = keccak256(\\n            abi.encode(\\n                FILL_WITH_PERMIT_TYPEHASH,\\n                _order.makerAddr,\\n                _order.takerAssetAddr,\\n                _order.makerAssetAddr,\\n                _order.takerAssetAmount,\\n                _order.makerAssetAmount,\\n                _order.takerAddr,\\n                _order.receiverAddr,\\n                _order.salt,\\n                _order.deadline,\\n                _order.feeFactor\\n            )\\n        );\\n    }\\n\\n    function _getTransactionSignDigest(Order memory _order) internal view returns (bytes32 transactionSignDigest) {\\n        transactionSignDigest = keccak256(\\n            abi.encodePacked(\\n                EIP191_HEADER,\\n                EIP712_DOMAIN_SEPARATOR,\\n                _getTransactionHash(_order)\\n            )\\n        );\\n    }\\n\\n    function _getTransactionSignDigestFromHash(bytes32 _txHash) internal view returns (bytes32 transactionSignDigest) {\\n        transactionSignDigest = keccak256(\\n            abi.encodePacked(\\n                EIP191_HEADER,\\n                EIP712_DOMAIN_SEPARATOR,\\n                _txHash\\n            )\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/BaseLibEIP712.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ncontract BaseLibEIP712 {\\n    /***********************************|\\n    |             Constants             |\\n    |__________________________________*/\\n\\n    // EIP-191 Header\\n    string public constant EIP191_HEADER = \\\"\\\\x19\\\\x01\\\";\\n\\n    // EIP712Domain\\n    string public constant EIP712_DOMAIN_NAME = \\\"Tokenlon\\\";\\n    string public constant EIP712_DOMAIN_VERSION = \\\"v5\\\";\\n\\n    // EIP712Domain Separator\\n    bytes32 public immutable EIP712_DOMAIN_SEPARATOR = keccak256(\\n        abi.encode(\\n            keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\\n            getChainID(),\\n            address(this)\\n        )\\n    );\\n\\n    /**\\n        * @dev Return `chainId`\\n        */\\n    function getChainID() internal pure returns (uint) {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return chainId;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/SignatureValidator.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../interfaces/IERC1271Wallet.sol\\\";\\nimport \\\"./LibBytes.sol\\\";\\n\\ninterface IWallet {\\n    /// @dev Verifies that a signature is valid.\\n    /// @param hash Message hash that is signed.\\n    /// @param signature Proof of signing.\\n    /// @return isValid Validity of order signature.\\n    function isValidSignature(\\n        bytes32 hash,\\n        bytes memory signature\\n    )\\n        external\\n        view\\n        returns (bool isValid);\\n}\\n\\n/**\\n * @dev Contains logic for signature validation.\\n * Signatures from wallet contracts assume ERC-1271 support (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md)\\n * Notes: Methods are strongly inspired by contracts in https://github.com/0xProject/0x-monorepo/blob/development/\\n */\\ncontract SignatureValidator {\\n  using LibBytes for bytes;\\n\\n  /***********************************|\\n  |             Variables             |\\n  |__________________________________*/\\n\\n  // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\"))\\n  bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\\n\\n  // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n  bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\\n\\n  // keccak256(\\\"isValidWalletSignature(bytes32,address,bytes)\\\")\\n  bytes4 constant internal ERC1271_FALLBACK_MAGICVALUE_BYTES32 = 0xb0671381;\\n\\n  // Allowed signature types.\\n  enum SignatureType {\\n    Illegal,                     // 0x00, default value\\n    Invalid,                     // 0x01\\n    EIP712,                      // 0x02\\n    EthSign,                     // 0x03\\n    WalletBytes,                 // 0x04  standard 1271 wallet type\\n    WalletBytes32,               // 0x05  standard 1271 wallet type\\n    Wallet,                      // 0x06  0x wallet type for signature compatibility\\n    NSignatureTypes              // 0x07, number of signature types. Always leave at end.\\n  }\\n\\n  /***********************************|\\n  |        Signature Functions        |\\n  |__________________________________*/\\n\\n  /**\\n   * @dev Verifies that a hash has been signed by the given signer.\\n   * @param _signerAddress  Address that should have signed the given hash.\\n   * @param _hash           Hash of the EIP-712 encoded data\\n   * @param _data           Full EIP-712 data structure that was hashed and signed\\n   * @param _sig            Proof that the hash has been signed by signer.\\n   *      For non wallet signatures, _sig is expected to be an array tightly encoded as\\n   *      (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType)\\n   * @return isValid True if the address recovered from the provided signature matches the input signer address.\\n   */\\n  function isValidSignature(\\n    address _signerAddress,\\n    bytes32 _hash,\\n    bytes memory _data,\\n    bytes memory _sig\\n  )\\n    public\\n    view\\n    returns (bool isValid)\\n  {\\n    require(\\n      _sig.length > 0,\\n      \\\"SignatureValidator#isValidSignature: length greater than 0 required\\\"\\n    );\\n\\n    require(\\n      _signerAddress != address(0x0),\\n      \\\"SignatureValidator#isValidSignature: invalid signer\\\"\\n    );\\n\\n    // Pop last byte off of signature byte array.\\n    uint8 signatureTypeRaw = uint8(_sig.popLastByte());\\n\\n    // Ensure signature is supported\\n    require(\\n      signatureTypeRaw < uint8(SignatureType.NSignatureTypes),\\n      \\\"SignatureValidator#isValidSignature: unsupported signature\\\"\\n    );\\n\\n    // Extract signature type\\n    SignatureType signatureType = SignatureType(signatureTypeRaw);\\n\\n    // Variables are not scoped in Solidity.\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n    address recovered;\\n\\n    // Always illegal signature.\\n    // This is always an implicit option since a signer can create a\\n    // signature array with invalid type or length. We may as well make\\n    // it an explicit option. This aids testing and analysis. It is\\n    // also the initialization value for the enum type.\\n    if (signatureType == SignatureType.Illegal) {\\n      revert(\\\"SignatureValidator#isValidSignature: illegal signature\\\");\\n\\n\\n    // Signature using EIP712\\n    } else if (signatureType == SignatureType.EIP712) {\\n      require(\\n        _sig.length == 97,\\n        \\\"SignatureValidator#isValidSignature: length 97 required\\\"\\n      );\\n      r = _sig.readBytes32(0);\\n      s = _sig.readBytes32(32);\\n      v = uint8(_sig[64]);\\n      recovered = ecrecover(_hash, v, r, s);\\n      isValid = _signerAddress == recovered;\\n      return isValid;\\n\\n\\n    // Signed using web3.eth_sign() or Ethers wallet.signMessage()\\n    } else if (signatureType == SignatureType.EthSign) {\\n      require(\\n        _sig.length == 97,\\n        \\\"SignatureValidator#isValidSignature: length 97 required\\\"\\n      );\\n      r = _sig.readBytes32(0);\\n      s = _sig.readBytes32(32);\\n      v = uint8(_sig[64]);\\n      recovered = ecrecover(\\n        keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash)),\\n        v,\\n        r,\\n        s\\n      );\\n      isValid = _signerAddress == recovered;\\n      return isValid;\\n\\n\\n    // Signature verified by wallet contract with data validation.\\n    } else if (signatureType == SignatureType.WalletBytes) {\\n      isValid = ERC1271_MAGICVALUE == IERC1271Wallet(_signerAddress).isValidSignature(_data, _sig);\\n      return isValid;\\n\\n\\n    // Signature verified by wallet contract without data validation.\\n    } else if (signatureType == SignatureType.WalletBytes32) {\\n      isValid = ERC1271_MAGICVALUE_BYTES32 == IERC1271Wallet(_signerAddress).isValidSignature(_hash, _sig);\\n      return isValid;\\n\\n\\n    } else if (signatureType == SignatureType.Wallet) {\\n      isValid = isValidWalletSignature(\\n          _hash,\\n          _signerAddress,\\n          _sig\\n      );\\n      return isValid;\\n    }\\n\\n    // Anything else is illegal (We do not return false because\\n    // the signature may actually be valid, just not in a format\\n    // that we currently support. In this case returning false\\n    // may lead the caller to incorrectly believe that the\\n    // signature was invalid.)\\n    revert(\\\"SignatureValidator#isValidSignature: unsupported signature\\\");\\n  }\\n\\n  /// @dev Verifies signature using logic defined by Wallet contract.\\n  /// @param hash Any 32 byte hash.\\n  /// @param walletAddress Address that should have signed the given hash\\n  ///                      and defines its own signature verification method.\\n  /// @param signature Proof that the hash has been signed by signer.\\n  /// @return isValid True if signature is valid for given wallet..\\n  function isValidWalletSignature(\\n      bytes32 hash,\\n      address walletAddress,\\n      bytes memory signature\\n  )\\n      internal\\n      view\\n      returns (bool isValid)\\n  {\\n      bytes memory _calldata = abi.encodeWithSelector(\\n          IWallet(walletAddress).isValidSignature.selector,\\n          hash,\\n          signature\\n      );\\n      bytes32 magic_salt = bytes32(bytes4(keccak256(\\\"isValidWalletSignature(bytes32,address,bytes)\\\")));\\n      assembly {\\n          if iszero(extcodesize(walletAddress)) {\\n              // Revert with `Error(\\\"WALLET_ERROR\\\")`\\n              mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n              mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n              mstore(64, 0x0000000c57414c4c45545f4552524f5200000000000000000000000000000000)\\n              mstore(96, 0)\\n              revert(0, 100)\\n          }\\n\\n          let cdStart := add(_calldata, 32)\\n          let success := staticcall(\\n              gas(),              // forward all gas\\n              walletAddress,    // address of Wallet contract\\n              cdStart,          // pointer to start of input\\n              mload(_calldata),  // length of input\\n              cdStart,          // write output over input\\n              32                // output size is 32 bytes\\n          )\\n\\n          if iszero(eq(returndatasize(), 32)) {\\n              // Revert with `Error(\\\"WALLET_ERROR\\\")`\\n              mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n              mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n              mstore(64, 0x0000000c57414c4c45545f4552524f5200000000000000000000000000000000)\\n              mstore(96, 0)\\n              revert(0, 100)\\n          }\\n\\n          switch success\\n          case 0 {\\n              // Revert with `Error(\\\"WALLET_ERROR\\\")`\\n              mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n              mstore(32, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n              mstore(64, 0x0000000c57414c4c45545f4552524f5200000000000000000000000000000000)\\n              mstore(96, 0)\\n              revert(0, 100)\\n          }\\n          case 1 {\\n              // Signature is valid if call did not revert and returned true\\n              isValid := eq(\\n                  and(mload(cdStart), 0xffffffff00000000000000000000000000000000000000000000000000000000),\\n                  and(magic_salt, 0xffffffff00000000000000000000000000000000000000000000000000000000)\\n              )\\n          }\\n      }\\n      return isValid;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibBytes.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2018 ZeroEx Intl.\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n  http://www.apache.org/licenses/LICENSE-2.0\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n  This is a truncated version of the original LibBytes.sol library from ZeroEx.\\n*/\\n\\npragma solidity ^0.6.0;\\n\\n\\nlibrary LibBytes {\\n  using LibBytes for bytes;\\n\\n  /***********************************|\\n  |        Pop Bytes Functions        |\\n  |__________________________________*/\\n\\n  /**\\n   * @dev Pops the last byte off of a byte array by modifying its length.\\n   * @param b Byte array that will be modified.\\n   * @return result The byte that was popped off.\\n   */\\n  function popLastByte(bytes memory b)\\n    internal\\n    pure\\n    returns (bytes1 result)\\n  {\\n    require(\\n      b.length > 0,\\n      \\\"LibBytes#popLastByte: greater than zero length required\\\"\\n    );\\n\\n    // Store last byte.\\n    result = b[b.length - 1];\\n\\n    assembly {\\n      // Decrement length of byte array.\\n      let newLen := sub(mload(b), 1)\\n      mstore(b, newLen)\\n    }\\n    return result;\\n  }\\n\\n  /// @dev Reads an address from a position in a byte array.\\n  /// @param b Byte array containing an address.\\n  /// @param index Index in byte array of address.\\n  /// @return result address from byte array.\\n  function readAddress(\\n    bytes memory b,\\n    uint256 index\\n  )\\n    internal\\n    pure\\n    returns (address result)\\n  {\\n    require(\\n      b.length >= index + 20,  // 20 is length of address\\n      \\\"LibBytes#readAddress greater or equal to 20 length required\\\"\\n    );\\n\\n    // Add offset to index:\\n    // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\\n    // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\\n    index += 20;\\n\\n    // Read address from array memory\\n    assembly {\\n      // 1. Add index to address of bytes array\\n      // 2. Load 32-byte word from memory\\n      // 3. Apply 20-byte mask to obtain address\\n      result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n    }\\n    return result;\\n  }\\n\\n  /***********************************|\\n  |        Read Bytes Functions       |\\n  |__________________________________*/\\n\\n  /**\\n   * @dev Reads a bytes32 value from a position in a byte array.\\n   * @param b Byte array containing a bytes32 value.\\n   * @param index Index in byte array of bytes32 value.\\n   * @return result bytes32 value from byte array.\\n   */\\n  function readBytes32(\\n    bytes memory b,\\n    uint256 index\\n  )\\n    internal\\n    pure\\n    returns (bytes32 result)\\n  {\\n    require(\\n      b.length >= index + 32,\\n      \\\"LibBytes#readBytes32 greater or equal to 32 length required\\\"\\n    );\\n\\n    // Arrays are prefixed by a 256 bit length parameter\\n    index += 32;\\n\\n    // Read the bytes32 from array memory\\n    assembly {\\n      result := mload(add(b, index))\\n    }\\n    return result;\\n  }\\n\\n  /// @dev Reads an unpadded bytes4 value from a position in a byte array.\\n  /// @param b Byte array containing a bytes4 value.\\n  /// @param index Index in byte array of bytes4 value.\\n  /// @return result bytes4 value from byte array.\\n  function readBytes4(\\n    bytes memory b,\\n    uint256 index\\n  )\\n    internal\\n    pure\\n    returns (bytes4 result)\\n  {\\n    require(\\n      b.length >= index + 4,\\n      \\\"LibBytes#readBytes4 greater or equal to 4 length required\\\"\\n    );\\n\\n    // Arrays are prefixed by a 32 byte length field\\n    index += 32;\\n\\n    // Read the bytes4 from array memory\\n    assembly {\\n      result := mload(add(b, index))\\n      // Solidity does not require us to clean the trailing bytes.\\n      // We do it anyway\\n      result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\\n    }\\n    return result;\\n  }\\n\\n  function readBytes2(\\n    bytes memory b,\\n    uint256 index\\n  )\\n    internal\\n    pure\\n    returns (bytes2 result)\\n  {\\n    require(\\n      b.length >= index + 2,\\n      \\\"LibBytes#readBytes2 greater or equal to 2 length required\\\"\\n    );\\n\\n    // Arrays are prefixed by a 32 byte length field\\n    index += 32;\\n\\n    // Read the bytes4 from array memory\\n    assembly {\\n      result := mload(add(b, index))\\n      // Solidity does not require us to clean the trailing bytes.\\n      // We do it anyway\\n      result := and(result, 0xFFFF000000000000000000000000000000000000000000000000000000000000)\\n    }\\n    return result;\\n  }\\n}\"\r\n    },\r\n    \"contracts/multi_sig/MultiSig.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport \\\"../utils/LibBytes.sol\\\";\\nimport \\\"./MultiSigLibEIP712.sol\\\";\\n\\n/**\\n * @title MultiSig\\n * @author dYdX\\n *\\n * Multi-Signature Wallet.\\n * Allows multiple parties to agree on transactions before execution.\\n * Adapted from Stefan George's MultiSigWallet contract.\\n *\\n * Logic Changes:\\n *  - Removed the fallback function\\n *  - Ensure newOwner is notNull\\n *\\n * Syntax Changes:\\n *  - Update Solidity syntax for 0.5.X: use `emit` keyword (events), use `view` keyword (functions)\\n *  - Add braces to all `if` and `for` statements\\n *  - Remove named return variables\\n *  - Add space before and after comparison operators\\n *  - Add ADDRESS_ZERO as a constant\\n *  - uint => uint256\\n *  - external_call => externalCall\\n */\\ncontract MultiSig is MultiSigLibEIP712 {\\n    using LibBytes for bytes;\\n\\n    // ============ Events ============\\n\\n    event Deposit(address indexed depositer, uint256 amount);\\n    event Confirmation(address indexed sender, uint256 indexed transactionId);\\n    event Revocation(address indexed sender, uint256 indexed transactionId);\\n    event Submission(uint256 indexed transactionId);\\n    event Execution(uint256 indexed transactionId);\\n    event ExecutionFailure(uint256 indexed transactionId);\\n    event OwnerAddition(address indexed owner);\\n    event OwnerRemoval(address indexed owner);\\n    event RequirementChange(uint256 required);\\n\\n    // ============ Constants ============\\n\\n    uint256 constant public MAX_OWNER_COUNT = 50;\\n    address constant ADDRESS_ZERO = address(0x0);\\n\\n    // ============ Storage ============\\n\\n    mapping (uint256 => Transaction) public transactions;\\n    mapping (uint256 => mapping (address => bool)) public confirmations;\\n    mapping (address => bool) public isOwner;\\n    address[] public owners;\\n    uint256 public required;\\n    uint256 public transactionCount;\\n\\n    // ============ Structs ============\\n\\n    struct Transaction {\\n        address destination;\\n        uint256 value;\\n        bytes data;\\n        bool executed;\\n    }\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyWallet() {\\n        /* solium-disable-next-line error-reason */\\n        require(msg.sender == address(this));\\n        _;\\n    }\\n\\n    modifier ownerDoesNotExist(\\n        address owner\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(!isOwner[owner]);\\n        _;\\n    }\\n\\n    modifier ownerExists(\\n        address owner\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(isOwner[owner]);\\n        _;\\n    }\\n\\n    modifier transactionExists(\\n        uint256 transactionId\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(transactions[transactionId].destination != ADDRESS_ZERO);\\n        _;\\n    }\\n\\n    modifier confirmed(\\n        uint256 transactionId,\\n        address owner\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(confirmations[transactionId][owner]);\\n        _;\\n    }\\n\\n    modifier notConfirmed(\\n        uint256 transactionId,\\n        address owner\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(!confirmations[transactionId][owner]);\\n        _;\\n    }\\n\\n    modifier notExecuted(\\n        uint256 transactionId\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(!transactions[transactionId].executed);\\n        _;\\n    }\\n\\n    modifier notNull(\\n        address _address\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(_address != ADDRESS_ZERO);\\n        _;\\n    }\\n\\n    modifier validRequirement(\\n        uint256 ownerCount,\\n        uint256 _required\\n    ) {\\n        /* solium-disable-next-line error-reason */\\n        require(\\n            ownerCount <= MAX_OWNER_COUNT\\n            && _required <= ownerCount\\n            && _required != 0\\n            && ownerCount != 0\\n        );\\n        _;\\n    }\\n\\n    // ========= Fallback function ==========\\n    receive() external payable {\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    // ============ Constructor ============\\n\\n    /**\\n     * Contract constructor sets initial owners and required number of confirmations.\\n     *\\n     * @param  _owners    List of initial owners.\\n     * @param  _required  Number of required confirmations.\\n     */\\n    constructor(\\n        address[] memory _owners,\\n        uint256 _required\\n    )\\n        public\\n        validRequirement(_owners.length, _required)\\n        MultiSigLibEIP712()\\n    {\\n        for (uint256 i = 0; i < _owners.length; i++) {\\n            /* solium-disable-next-line error-reason */\\n            require(!isOwner[_owners[i]] && _owners[i] != ADDRESS_ZERO);\\n            isOwner[_owners[i]] = true;\\n        }\\n        owners = _owners;\\n        required = _required;\\n    }\\n\\n    // ============ Wallet-Only Functions ============\\n\\n    /**\\n     * Allows to add a new owner. Transaction has to be sent by wallet.\\n     *\\n     * @param  owner  Address of new owner.\\n     */\\n    function addOwner(\\n        address owner\\n    )\\n        public\\n        onlyWallet\\n        ownerDoesNotExist(owner)\\n        notNull(owner)\\n        validRequirement(owners.length + 1, required)\\n    {\\n        isOwner[owner] = true;\\n        owners.push(owner);\\n        emit OwnerAddition(owner);\\n    }\\n\\n    /**\\n     * Allows to remove an owner. Transaction has to be sent by wallet.\\n     *\\n     * @param  owner  Address of owner.\\n     */\\n    function removeOwner(\\n        address owner\\n    )\\n        public\\n        onlyWallet\\n        ownerExists(owner)\\n    {\\n        isOwner[owner] = false;\\n        for (uint256 i = 0; i < owners.length - 1; i++) {\\n            if (owners[i] == owner) {\\n                owners[i] = owners[owners.length - 1];\\n                break;\\n            }\\n        }\\n        delete owners[owners.length - 1];\\n        if (required > owners.length) {\\n            changeRequirement(owners.length);\\n        }\\n        emit OwnerRemoval(owner);\\n    }\\n\\n    /**\\n     * Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\\n     *\\n     * @param  owner     Address of owner to be replaced.\\n     * @param  newOwner  Address of new owner.\\n     */\\n    function replaceOwner(\\n        address owner,\\n        address newOwner\\n    )\\n        public\\n        onlyWallet\\n        ownerExists(owner)\\n        ownerDoesNotExist(newOwner)\\n        notNull(newOwner)\\n    {\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            if (owners[i] == owner) {\\n                owners[i] = newOwner;\\n                break;\\n            }\\n        }\\n        isOwner[owner] = false;\\n        isOwner[newOwner] = true;\\n        emit OwnerRemoval(owner);\\n        emit OwnerAddition(newOwner);\\n    }\\n\\n    /**\\n     * Allows to change the number of required confirmations. Transaction has to be sent by wallet.\\n     *\\n     * @param  _required  Number of required confirmations.\\n     */\\n    function changeRequirement(\\n        uint256 _required\\n    )\\n        public\\n        onlyWallet\\n        validRequirement(owners.length, _required)\\n    {\\n        required = _required;\\n        emit RequirementChange(_required);\\n    }\\n\\n    // ============ Owner Functions ============\\n\\n    /**\\n     * Allows an owner to submit and confirm a transaction.\\n     *\\n     * @param  destination  Transaction target address.\\n     * @param  value        Transaction ether value.\\n     * @param  data         Transaction data payload.\\n     * @return              Transaction ID.\\n     */\\n    function submitTransaction(\\n        address destination,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        public\\n        returns (uint256)\\n    {\\n        uint256 transactionId = addTransaction(destination, value, data);\\n        confirmTransaction(transactionId);\\n        return transactionId;\\n    }\\n\\n    /**\\n     * Allows an owner to submit and confirm a transaction via meta transaction.\\n     *\\n     * @param  signer           Signer of the meta transaction.\\n     * @param  transactionId    Transaction ID of this transaction.\\n     * @param  destination      Transaction target address.\\n     * @param  value            Transaction ether value.\\n     * @param  data             Transaction data payload.\\n     * @param  sig              Signature.\\n     * @return                  Transaction ID.\\n     */\\n    function submitTransaction(\\n        address signer,\\n        uint256 transactionId,\\n        address destination,\\n        uint256 value,\\n        bytes memory data,\\n        bytes memory sig\\n    )\\n        public\\n        ownerExists(signer)\\n        returns (uint256)\\n    {\\n        // SUBMIT_TRANSACTION_TYPE_HASH = keccak256(\\\"submitTransaction(uint256 transactionId,address destination,uint256 value,bytes data)\\\");\\n        bytes32 EIP712SignDigest = keccak256(\\n            abi.encodePacked(\\n                bytes1(0x19),\\n                bytes1(0x01),\\n                EIP712_DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        SUBMIT_TRANSACTION_TYPE_HASH,\\n                        transactionId,\\n                        destination,\\n                        value,\\n                        data\\n                    )\\n                )\\n            )\\n        );\\n        validateSignature(signer, EIP712SignDigest, sig);\\n\\n        uint256 _transactionId = addTransaction(destination, value, data);\\n\\n        require(transactionId == _transactionId);\\n\\n        confirmTransactionBySigner(signer, transactionId);\\n        return transactionId;\\n    }\\n\\n    // confirm transaction on behalf of signer, not msg.sender\\n    function confirmTransactionBySigner(\\n        address signer,\\n        uint256 transactionId\\n    )\\n        internal\\n        transactionExists(transactionId)\\n        notConfirmed(transactionId, signer)\\n    {\\n        // Confirm\\n        confirmations[transactionId][signer] = true;\\n        emit Confirmation(signer, transactionId);\\n\\n        // Execute\\n        executeTransactionBySigner(signer, transactionId);\\n    }\\n\\n    // execute transaction on behalf of signer, not msg.sender\\n    function executeTransactionBySigner(\\n        address signer,\\n        uint256 transactionId\\n    )\\n        internal\\n        notExecuted(transactionId)\\n    {\\n        if (isConfirmed(transactionId)) {\\n            Transaction storage txn = transactions[transactionId];\\n            txn.executed = true;\\n            if (externalCall(\\n                txn.destination,\\n                txn.value,\\n                txn.data.length,\\n                txn.data)\\n            ) {\\n                emit Execution(transactionId);\\n            } else {\\n                emit ExecutionFailure(transactionId);\\n                txn.executed = false;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Allows an owner to confirm a transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     */\\n    function confirmTransaction(\\n        uint256 transactionId\\n    )\\n        public\\n        virtual\\n        ownerExists(msg.sender)\\n        transactionExists(transactionId)\\n        notConfirmed(transactionId, msg.sender)\\n    {\\n        confirmations[transactionId][msg.sender] = true;\\n        emit Confirmation(msg.sender, transactionId);\\n        executeTransaction(transactionId);\\n    }\\n\\n    /**\\n     * Allows an owner to confirm a transaction via meta transaction.\\n     *\\n     * @param  signer           Signer of the meta transaction.\\n     * @param  transactionId    Transaction ID.\\n     * @param  sig              Signature.\\n     */\\n    function confirmTransaction(\\n        address signer,\\n        uint256 transactionId,\\n        bytes memory sig\\n    )\\n        public\\n        virtual\\n        ownerExists(signer)\\n        transactionExists(transactionId)\\n        notConfirmed(transactionId, signer)\\n    {\\n        // CONFIRM_TRANSACTION_TYPE_HASH = keccak256(\\\"confirmTransaction(uint256 transactionId)\\\");\\n        bytes32 EIP712SignDigest = keccak256(\\n            abi.encodePacked(\\n                bytes1(0x19),\\n                bytes1(0x01),\\n                EIP712_DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        CONFIRM_TRANSACTION_TYPE_HASH,\\n                        transactionId\\n                    )\\n                )\\n            )\\n        );\\n        validateSignature(signer, EIP712SignDigest, sig);\\n\\n        confirmations[transactionId][signer] = true;\\n        emit Confirmation(signer, transactionId);\\n        executeTransactionBySigner(signer, transactionId);\\n    }\\n\\n    /**\\n     * Allows an owner to revoke a confirmation for a transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     */\\n    function revokeConfirmation(\\n        uint256 transactionId\\n    )\\n        public\\n        ownerExists(msg.sender)\\n        confirmed(transactionId, msg.sender)\\n        notExecuted(transactionId)\\n    {\\n        confirmations[transactionId][msg.sender] = false;\\n        emit Revocation(msg.sender, transactionId);\\n    }\\n\\n    /**\\n     * Allows an owner to execute a confirmed transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     */\\n    function executeTransaction(\\n        uint256 transactionId\\n    )\\n        public\\n        virtual\\n        ownerExists(msg.sender)\\n        confirmed(transactionId, msg.sender)\\n        notExecuted(transactionId)\\n    {\\n        if (isConfirmed(transactionId)) {\\n            Transaction storage txn = transactions[transactionId];\\n            txn.executed = true;\\n            if (externalCall(\\n                txn.destination,\\n                txn.value,\\n                txn.data.length,\\n                txn.data)\\n            ) {\\n                emit Execution(transactionId);\\n            } else {\\n                emit ExecutionFailure(transactionId);\\n                txn.executed = false;\\n            }\\n        }\\n    }\\n\\n    // ============ Getter Functions ============\\n\\n    /**\\n     * Returns the confirmation status of a transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     * @return                Confirmation status.\\n     */\\n    function isConfirmed(\\n        uint256 transactionId\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            if (confirmations[transactionId][owners[i]]) {\\n                count += 1;\\n            }\\n            if (count == required) {\\n                return true;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Returns number of confirmations of a transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     * @return                Number of confirmations.\\n     */\\n    function getConfirmationCount(\\n        uint256 transactionId\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            if (confirmations[transactionId][owners[i]]) {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    /**\\n     * Returns total number of transactions after filers are applied.\\n     *\\n     * @param  pending   Include pending transactions.\\n     * @param  executed  Include executed transactions.\\n     * @return           Total number of transactions after filters are applied.\\n     */\\n    function getTransactionCount(\\n        bool pending,\\n        bool executed\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < transactionCount; i++) {\\n            if (\\n                pending && !transactions[i].executed\\n                || executed && transactions[i].executed\\n            ) {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    /**\\n     * Returns array of owners.\\n     *\\n     * @return  Array of owner addresses.\\n     */\\n    function getOwners()\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return owners;\\n    }\\n\\n    /**\\n     * Returns array with owner addresses, which confirmed transaction.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     * @return                Array of owner addresses.\\n     */\\n    function getConfirmations(\\n        uint256 transactionId\\n    )\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        address[] memory confirmationsTemp = new address[](owners.length);\\n        uint256 count = 0;\\n        uint256 i;\\n        for (i = 0; i < owners.length; i++) {\\n            if (confirmations[transactionId][owners[i]]) {\\n                confirmationsTemp[count] = owners[i];\\n                count += 1;\\n            }\\n        }\\n        address[] memory _confirmations = new address[](count);\\n        for (i = 0; i < count; i++) {\\n            _confirmations[i] = confirmationsTemp[i];\\n        }\\n        return _confirmations;\\n    }\\n\\n    /**\\n     * Returns list of transaction IDs in defined range.\\n     *\\n     * @param  from      Index start position of transaction array.\\n     * @param  to        Index end position of transaction array.\\n     * @param  pending   Include pending transactions.\\n     * @param  executed  Include executed transactions.\\n     * @return           Array of transaction IDs.\\n     */\\n    function getTransactionIds(\\n        uint256 from,\\n        uint256 to,\\n        bool pending,\\n        bool executed\\n    )\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory transactionIdsTemp = new uint256[](transactionCount);\\n        uint256 count = 0;\\n        uint256 i;\\n        for (i = 0; i < transactionCount; i++) {\\n            if (\\n                pending && !transactions[i].executed\\n                || executed && transactions[i].executed\\n            ) {\\n                transactionIdsTemp[count] = i;\\n                count += 1;\\n            }\\n        }\\n        uint256[] memory _transactionIds = new uint256[](to - from);\\n        for (i = from; i < to; i++) {\\n            _transactionIds[i - from] = transactionIdsTemp[i];\\n        }\\n        return _transactionIds;\\n    }\\n\\n    // ============ Helper Functions ============\\n\\n    function validateSignature(\\n        address signer,\\n        bytes32 digest,\\n        bytes memory sig\\n    )\\n        internal\\n    {\\n        require(sig.length == 65);\\n        uint8 v = uint8(sig[64]);\\n        bytes32 r = sig.readBytes32(0);\\n        bytes32 s = sig.readBytes32(32);\\n        address recovered = ecrecover(digest, v, r, s);\\n        require(signer == recovered);\\n    }\\n\\n    // call has been separated into its own function in order to take advantage\\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\\n    function externalCall(\\n        address destination,\\n        uint256 value,\\n        uint256 dataLength,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        bool result;\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            let x := mload(0x40)   // \\\"Allocate\\\" memory for output (0x40 is where \\\"free memory\\\" pointer is stored by convention)\\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\\n            result := call(\\n                sub(gas(), 34710),   // 34710 is the value that solidity is currently emitting\\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\\n                destination,\\n                value,\\n                d,\\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\\n                x,\\n                0                  // Output is ignored, therefore the output size is zero\\n            )\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * Adds a new transaction to the transaction mapping, if transaction does not exist yet.\\n     *\\n     * @param  destination  Transaction target address.\\n     * @param  value        Transaction ether value.\\n     * @param  data         Transaction data payload.\\n     * @return              Transaction ID.\\n     */\\n    function addTransaction(\\n        address destination,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        notNull(destination)\\n        returns (uint256)\\n    {\\n        uint256 transactionId = transactionCount;\\n        transactions[transactionId] = Transaction({\\n            destination: destination,\\n            value: value,\\n            data: data,\\n            executed: false\\n        });\\n        transactionCount += 1;\\n        emit Submission(transactionId);\\n        return transactionId;\\n    }\\n}\"\r\n    },\r\n    \"contracts/multi_sig/MultiSigLibEIP712.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ncontract MultiSigLibEIP712 {\\n    /***********************************|\\n  |             Constants             |\\n  |__________________________________*/\\n\\n    // EIP712Domain\\n    string public constant EIP712_DOMAIN_NAME = \\\"MultiSig\\\";\\n    string public constant EIP712_DOMAIN_VERSION = \\\"v1\\\";\\n\\n    // EIP712Domain Separator\\n    bytes32 public EIP712_DOMAIN_SEPARATOR;\\n\\n    // SUBMIT_TRANSACTION_TYPE_HASH = keccak256(\\\"submitTransaction(uint256 transactionId,address destination,uint256 value,bytes data)\\\");\\n    bytes32 public constant SUBMIT_TRANSACTION_TYPE_HASH = 0x2c78e27c3bb2592e67e8d37ad1a95bfccd188e77557c22593b1af0b920a08295;\\n\\n    // CONFIRM_TRANSACTION_TYPE_HASH = keccak256(\\\"confirmTransaction(uint256 transactionId)\\\");\\n    bytes32 public constant CONFIRM_TRANSACTION_TYPE_HASH = 0x3e96bdc38d4133bc81813a187b2d41bc74332643ce7dbe82c7d94ead8366a65f;\\n\\n    constructor() public {\\n        EIP712_DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\\n                getChainID(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n    * @dev Return `chainId`\\n    */\\n    function getChainID() internal pure returns (uint) {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return chainId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/multi_sig/MiningTreasury.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport \\\"./MultiSig.sol\\\";\\n\\ncontract MiningTreasury is MultiSig {\\n    constructor (\\n        address[] memory _owners,\\n        uint256 _required\\n    )\\n        public\\n        MultiSig(_owners, _required)\\n    {\\n    }\\n}\"\r\n    },\r\n    \"contracts/multi_sig/DelayedMultiSig.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport \\\"./MultiSig.sol\\\";\\n\\n// File: contracts/external/multisig/DelayedMultiSig.sol\\n\\n/**\\n * @title DelayedMultiSig\\n * @author dYdX\\n *\\n * Multi-Signature Wallet with delay in execution.\\n * Allows multiple parties to execute a transaction after a time lock has passed.\\n * Adapted from Amir Bandeali's MultiSigWalletWithTimeLock contract.\\n\\n * Logic Changes:\\n *  - Only owners can execute transactions\\n *  - Require that each transaction succeeds\\n *  - Added function to execute multiple transactions within the same Ethereum transaction\\n */\\ncontract DelayedMultiSig is\\n    MultiSig\\n{\\n    // ============ Events ============\\n\\n    event ConfirmationTimeSet(uint256 indexed transactionId, uint256 confirmationTime);\\n    event TimeLockChange(uint32 secondsTimeLocked);\\n\\n    // ============ Storage ============\\n\\n    uint32 public secondsTimeLocked;\\n    mapping (uint256 => uint256) public confirmationTimes;\\n\\n    // ============ Modifiers ============\\n\\n    modifier notFullyConfirmed(\\n        uint256 transactionId\\n    ) {\\n        require(\\n            !isConfirmed(transactionId),\\n            \\\"TX_FULLY_CONFIRMED\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier fullyConfirmed(\\n        uint256 transactionId\\n    ) {\\n        require(\\n            isConfirmed(transactionId),\\n            \\\"TX_NOT_FULLY_CONFIRMED\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier pastTimeLock(\\n        uint256 transactionId\\n    ) virtual {\\n        require(\\n            block.timestamp >= confirmationTimes[transactionId] + secondsTimeLocked,\\n            \\\"TIME_LOCK_INCOMPLETE\\\"\\n        );\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    /**\\n     * Contract constructor sets initial owners, required number of confirmations, and time lock.\\n     *\\n     * @param  _owners             List of initial owners.\\n     * @param  _required           Number of required confirmations.\\n     * @param  _secondsTimeLocked  Duration needed after a transaction is confirmed and before it\\n     *                             becomes executable, in seconds.\\n     */\\n    constructor (\\n        address[] memory _owners,\\n        uint256 _required,\\n        uint32 _secondsTimeLocked\\n    )\\n        public\\n        MultiSig(_owners, _required)\\n    {\\n        secondsTimeLocked = _secondsTimeLocked;\\n    }\\n\\n    // ============ Wallet-Only Functions ============\\n\\n    /**\\n     * Changes the duration of the time lock for transactions.\\n     *\\n     * @param  _secondsTimeLocked  Duration needed after a transaction is confirmed and before it\\n     *                             becomes executable, in seconds.\\n     */\\n    function changeTimeLock(\\n        uint32 _secondsTimeLocked\\n    )\\n        public\\n        onlyWallet\\n    {\\n        secondsTimeLocked = _secondsTimeLocked;\\n        emit TimeLockChange(_secondsTimeLocked);\\n    }\\n\\n    // ============ Owner Functions ============\\n\\n    /**\\n     * Allows an owner to confirm a transaction.\\n     * Overrides the function in MultiSig.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     */\\n    function confirmTransaction(\\n        uint256 transactionId\\n    )\\n        public\\n        override\\n        ownerExists(msg.sender)\\n        transactionExists(transactionId)\\n        notConfirmed(transactionId, msg.sender)\\n        notFullyConfirmed(transactionId)\\n    {\\n        confirmations[transactionId][msg.sender] = true;\\n        emit Confirmation(msg.sender, transactionId);\\n        if (isConfirmed(transactionId)) {\\n            setConfirmationTime(transactionId, block.timestamp);\\n        }\\n    }\\n\\n    /**\\n     * Allows an owner to confirm a transaction via meta transaction.\\n     * Overrides the function in MultiSig.\\n     *\\n     * @param  signer           Signer of the meta transaction.\\n     * @param  transactionId    Transaction ID.\\n     * @param  sig              Signature.\\n     */\\n    function confirmTransaction(\\n        address signer,\\n        uint256 transactionId,\\n        bytes memory sig\\n    )\\n        public\\n        override\\n        ownerExists(signer)\\n        transactionExists(transactionId)\\n        notConfirmed(transactionId, signer)\\n        notFullyConfirmed(transactionId)\\n    {\\n        // CONFIRM_TRANSACTION_TYPE_HASH = keccak256(\\\"confirmTransaction(uint256 transactionId)\\\");\\n        bytes32 EIP712SignDigest = keccak256(\\n            abi.encodePacked(\\n                bytes1(0x19),\\n                bytes1(0x01),\\n                EIP712_DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        CONFIRM_TRANSACTION_TYPE_HASH,\\n                        transactionId\\n                    )\\n                )\\n            )\\n        );\\n        validateSignature(signer, EIP712SignDigest, sig);\\n\\n        confirmations[transactionId][signer] = true;\\n        emit Confirmation(signer, transactionId);\\n        if (isConfirmed(transactionId)) {\\n            setConfirmationTime(transactionId, block.timestamp);\\n        }\\n    }\\n\\n    /**\\n     * Allows an owner to execute a confirmed transaction.\\n     * Overrides the function in MultiSig.\\n     *\\n     * @param  transactionId  Transaction ID.\\n     */\\n    function executeTransaction(\\n        uint256 transactionId\\n    )\\n        public\\n        override\\n        ownerExists(msg.sender)\\n        notExecuted(transactionId)\\n        fullyConfirmed(transactionId)\\n        pastTimeLock(transactionId)\\n    {\\n        Transaction storage txn = transactions[transactionId];\\n        txn.executed = true;\\n        bool success = externalCall(\\n            txn.destination,\\n            txn.value,\\n            txn.data.length,\\n            txn.data\\n        );\\n        require(\\n            success,\\n            \\\"TX_REVERTED\\\"\\n        );\\n        emit Execution(transactionId);\\n    }\\n\\n    /**\\n     * Allows an owner to execute multiple confirmed transactions.\\n     *\\n     * @param  transactionIds  List of transaction IDs.\\n     */\\n    function executeMultipleTransactions(\\n        uint256[] memory transactionIds\\n    )\\n        public\\n        ownerExists(msg.sender)\\n    {\\n        for (uint256 i = 0; i < transactionIds.length; i++) {\\n            executeTransaction(transactionIds[i]);\\n        }\\n    }\\n\\n    // ============ Helper Functions ============\\n\\n    /**\\n     * Sets the time of when a submission first passed.\\n     */\\n    function setConfirmationTime(\\n        uint256 transactionId,\\n        uint256 confirmationTime\\n    )\\n        internal\\n    {\\n        confirmationTimes[transactionId] = confirmationTime;\\n        emit ConfirmationTimeSet(transactionId, confirmationTime);\\n    }\\n}\"\r\n    },\r\n    \"contracts/multi_sig/PartiallyDelayedMultiSig.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\nimport \\\"./DelayedMultiSig.sol\\\";\\n\\n// File: contracts/external/multisig/PartiallyDelayedMultiSig.sol\\n\\n/**\\n * @title PartiallyDelayedMultiSig\\n * @author dYdX\\n *\\n * Multi-Signature Wallet with delay in execution except for some function selectors.\\n */\\ncontract PartiallyDelayedMultiSig is\\n    DelayedMultiSig\\n{\\n    // ============ Events ============\\n\\n    event SelectorSet(address destination, bytes4 selector, bool approved);\\n\\n    // ============ Constants ============\\n\\n    bytes4 constant internal BYTES_ZERO = bytes4(0x0);\\n\\n    // ============ Storage ============\\n\\n    // destination => function selector => can bypass timelock\\n    mapping (address => mapping (bytes4 => bool)) public instantData;\\n\\n    // ============ Modifiers ============\\n\\n    // Overrides old modifier that requires a timelock for every transaction\\n    modifier pastTimeLock(\\n        uint256 transactionId\\n    ) override {\\n        // if the function selector is not exempt from timelock, then require timelock\\n        require(\\n            block.timestamp >= confirmationTimes[transactionId] + secondsTimeLocked\\n            || txCanBeExecutedInstantly(transactionId),\\n            \\\"TIME_LOCK_INCOMPLETE\\\"\\n        );\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    /**\\n     * Contract constructor sets initial owners, required number of confirmations, and time lock.\\n     *\\n     * @param  _owners               List of initial owners.\\n     * @param  _required             Number of required confirmations.\\n     * @param  _secondsTimeLocked    Duration needed after a transaction is confirmed and before it\\n     *                               becomes executable, in seconds.\\n     * @param  _noDelayDestinations  List of destinations that correspond with the selectors.\\n     *                               Zero address allows the function selector to be used with any\\n     *                               address.\\n     * @param  _noDelaySelectors     All function selectors that do not require a delay to execute.\\n     *                               Fallback function is 0x00000000.\\n     */\\n    constructor (\\n        address[] memory _owners,\\n        uint256 _required,\\n        uint32 _secondsTimeLocked,\\n        address[] memory _noDelayDestinations,\\n        bytes4[] memory _noDelaySelectors\\n    )\\n        public\\n        DelayedMultiSig(_owners, _required, _secondsTimeLocked)\\n    {\\n        require(\\n            _noDelayDestinations.length == _noDelaySelectors.length,\\n            \\\"ADDRESS_AND_SELECTOR_MISMATCH\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _noDelaySelectors.length; i++) {\\n            address destination = _noDelayDestinations[i];\\n            bytes4 selector = _noDelaySelectors[i];\\n            instantData[destination][selector] = true;\\n            emit SelectorSet(destination, selector, true);\\n        }\\n    }\\n\\n    // ============ Wallet-Only Functions ============\\n\\n    /**\\n     * Adds or removes functions that can be executed instantly. Transaction must be sent by wallet.\\n     *\\n     * @param  destination  Destination address of function. Zero address allows the function to be\\n     *                      sent to any address.\\n     * @param  selector     4-byte selector of the function. Fallback function is 0x00000000.\\n     * @param  approved     True if adding approval, false if removing approval.\\n     */\\n    function setSelector(\\n        address destination,\\n        bytes4 selector,\\n        bool approved\\n    )\\n        public\\n        onlyWallet\\n    {\\n        instantData[destination][selector] = approved;\\n        emit SelectorSet(destination, selector, approved);\\n    }\\n\\n    // ============ Helper Functions ============\\n\\n    /**\\n     * Returns true if transaction can be executed instantly (without timelock).\\n     */\\n    function txCanBeExecutedInstantly(\\n        uint256 transactionId\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // get transaction from storage\\n        Transaction memory txn = transactions[transactionId];\\n        address dest = txn.destination;\\n        bytes memory data = txn.data;\\n\\n        // fallback function\\n        if (data.length == 0) {\\n            return selectorCanBeExecutedInstantly(dest, BYTES_ZERO);\\n        }\\n\\n        // invalid function selector\\n        if (data.length < 4) {\\n            return false;\\n        }\\n\\n        // check first four bytes (function selector)\\n        bytes32 rawData;\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            rawData := mload(add(data, 32))\\n        }\\n        bytes4 selector = bytes4(rawData);\\n\\n        return selectorCanBeExecutedInstantly(dest, selector);\\n    }\\n\\n    /**\\n     * Function selector is in instantData for address dest (or for address zero).\\n     */\\n    function selectorCanBeExecutedInstantly(\\n        address destination,\\n        bytes4 selector\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return instantData[destination][selector]\\n            || instantData[ADDRESS_ZERO][selector];\\n    }\\n}\"\r\n    },\r\n    \"contracts/pmm/0xLibs/LibDecoder.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibOrder.sol\\\";\\nimport \\\"../../utils/LibBytes.sol\\\";\\n\\ncontract LibDecoder {\\n    using LibBytes for bytes;\\n\\n    function decodeFillOrder(bytes memory data) internal pure returns(LibOrder.Order memory order, uint256 takerFillAmount, bytes memory mmSignature) {\\n        require(\\n            data.length > 800,\\n            \\\"LibDecoder: LENGTH_LESS_800\\\"\\n        );\\n\\n        // compare method_id\\n        // 0x64a3bc15 is fillOrKillOrder's method id.\\n        require(\\n            data.readBytes4(0) == 0x64a3bc15,\\n            \\\"LibDecoder: WRONG_METHOD_ID\\\"\\n        );\\n        \\n        bytes memory dataSlice;\\n        assembly {\\n            dataSlice := add(data, 4)\\n        }\\n        return abi.decode(dataSlice, (LibOrder.Order, uint256, bytes));\\n\\n    }\\n\\n    function decodeMmSignature(bytes memory signature) internal pure returns(uint8 v, bytes32 r, bytes32 s) {\\n        v = uint8(signature[0]);\\n        r = signature.readBytes32(1);\\n        s = signature.readBytes32(33);\\n\\n        return (v, r, s);\\n    }\\n\\n    function decodeUserSignatureWithoutSign(bytes memory signature) internal pure returns(address receiver) {\\n        require(\\n            signature.length == 85 || signature.length == 86,\\n            \\\"LibDecoder: LENGTH_85_REQUIRED\\\"\\n        );\\n        receiver = signature.readAddress(65);\\n\\n        return receiver;\\n    }\\n\\n    function decodeUserSignature(bytes memory signature) internal pure returns(uint8 v, bytes32 r, bytes32 s, address receiver) {\\n        receiver = decodeUserSignatureWithoutSign(signature);\\n\\n        v = uint8(signature[0]);\\n        r = signature.readBytes32(1);\\n        s = signature.readBytes32(33);\\n\\n        return (v, r, s, receiver);\\n    }\\n\\n    function decodeERC20Asset(bytes memory assetData) internal pure returns(address) {\\n        require(\\n            assetData.length == 36,\\n            \\\"LibDecoder: LENGTH_36_REQUIRED\\\"\\n        );\\n\\n        return assetData.readAddress(16);\\n    }\\n}\"\r\n    },\r\n    \"contracts/pmm/0xLibs/LibOrder.sol\": {\r\n      \"content\": \"/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./LibEIP712.sol\\\";\\n\\n\\ncontract LibOrder is\\n    LibEIP712\\n{\\n    // Hash for the EIP712 Order Schema\\n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(abi.encodePacked(\\n        \\\"Order(\\\",\\n        \\\"address makerAddress,\\\",\\n        \\\"address takerAddress,\\\",\\n        \\\"address feeRecipientAddress,\\\",\\n        \\\"address senderAddress,\\\",\\n        \\\"uint256 makerAssetAmount,\\\",\\n        \\\"uint256 takerAssetAmount,\\\",\\n        \\\"uint256 makerFee,\\\",\\n        \\\"uint256 takerFee,\\\",\\n        \\\"uint256 expirationTimeSeconds,\\\",\\n        \\\"uint256 salt,\\\",\\n        \\\"bytes makerAssetData,\\\",\\n        \\\"bytes takerAssetData\\\",\\n        \\\")\\\"\\n    ));\\n\\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\\n    // An order's state is unaffected by external factors, like account balances.\\n    enum OrderStatus {\\n        INVALID,                     // Default value\\n        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\\n        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\\n        FILLABLE,                    // Order is fillable\\n        EXPIRED,                     // Order has already expired\\n        FULLY_FILLED,                // Order is fully filled\\n        CANCELLED                    // Order has been cancelled\\n    }\\n\\n    // solhint-disable max-line-length\\n    struct Order {\\n        address makerAddress;           // Address that created the order.      \\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.          \\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.      \\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.        \\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.        \\n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.          \\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.     \\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\\n    }\\n    // solhint-enable max-line-length\\n\\n    struct OrderInfo {\\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\\n        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\\n    }\\n\\n    /// @dev Calculates Keccak-256 hash of the order.\\n    /// @param order The order structure.\\n    /// @return orderHash Keccak-256 EIP712 hash of the order.\\n    function getOrderHash(Order memory order)\\n        internal\\n        view\\n        returns (bytes32 orderHash)\\n    {\\n        orderHash = hashEIP712Message(hashOrder(order));\\n        return orderHash;\\n    }\\n\\n    /// @dev Calculates EIP712 hash of the order.\\n    /// @param order The order structure.\\n    /// @return result EIP712 hash of the order.\\n    function hashOrder(Order memory order)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\\n\\n        // Assembly for more efficiently computing:\\n        // keccak256(abi.encodePacked(\\n        //     EIP712_ORDER_SCHEMA_HASH,\\n        //     bytes32(order.makerAddress),\\n        //     bytes32(order.takerAddress),\\n        //     bytes32(order.feeRecipientAddress),\\n        //     bytes32(order.senderAddress),\\n        //     order.makerAssetAmount,\\n        //     order.takerAssetAmount,\\n        //     order.makerFee,\\n        //     order.takerFee,\\n        //     order.expirationTimeSeconds,\\n        //     order.salt,\\n        //     keccak256(order.makerAssetData),\\n        //     keccak256(order.takerAssetData)\\n        // ));\\n\\n        assembly {\\n            // Calculate memory addresses that will be swapped out before hashing\\n            let pos1 := sub(order, 32)\\n            let pos2 := add(order, 320)\\n            let pos3 := add(order, 352)\\n\\n            // Backup\\n            let temp1 := mload(pos1)\\n            let temp2 := mload(pos2)\\n            let temp3 := mload(pos3)\\n            \\n            // Hash in place\\n            mstore(pos1, schemaHash)\\n            mstore(pos2, makerAssetDataHash)\\n            mstore(pos3, takerAssetDataHash)\\n            result := keccak256(pos1, 416)\\n            \\n            // Restore\\n            mstore(pos1, temp1)\\n            mstore(pos2, temp2)\\n            mstore(pos3, temp3)\\n        }\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/pmm/0xLibs/LibEIP712.sol\": {\r\n      \"content\": \"/*\\n\\n  Copyright 2018 ZeroEx Intl.\\n\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n\\n*/\\n\\npragma solidity ^0.6.0;\\n\\n\\ncontract LibEIP712 {\\n\\n    // EIP191 header for EIP712 prefix\\n    string constant internal EIP191_HEADER = \\\"\\\\x19\\\\x01\\\";\\n\\n    // EIP712 Domain Name value\\n    string constant internal EIP712_DOMAIN_NAME = \\\"0x Protocol\\\";\\n\\n    // EIP712 Domain Version value\\n    string constant internal EIP712_DOMAIN_VERSION = \\\"2\\\";\\n\\n    // Hash of the EIP712 Domain Separator Schema\\n    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\\n        \\\"EIP712Domain(\\\",\\n        \\\"string name,\\\",\\n        \\\"string version,\\\",\\n        \\\"address verifyingContract\\\",\\n        \\\")\\\"\\n    ));\\n\\n    // Hash of the EIP712 Domain Separator data\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 public EIP712_DOMAIN_HASH;\\n\\n    constructor ()\\n        public\\n    {\\n        EIP712_DOMAIN_HASH = keccak256(abi.encodePacked(\\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\\n            bytes12(0),\\n            address(this)\\n        ));\\n    }\\n\\n    /// @dev Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\\n    /// @param hashStruct The EIP712 hash struct.\\n    /// @return result EIP712 hash applied to this EIP712 Domain.\\n    function hashEIP712Message(bytes32 hashStruct)\\n        internal\\n        view\\n        returns (bytes32 result)\\n    {\\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\\n\\n        // Assembly for more efficient computing:\\n        // keccak256(abi.encodePacked(\\n        //     EIP191_HEADER,\\n        //     EIP712_DOMAIN_HASH,\\n        //     hashStruct    \\n        // ));\\n\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\\n\\n            // Compute hash\\n            result := keccak256(memPtr, 66)\\n        }\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/PMM.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./pmm/0xLibs/LibOrder.sol\\\";\\nimport \\\"./pmm/0xLibs/LibDecoder.sol\\\";\\nimport \\\"./pmm/0xLibs/LibEncoder.sol\\\";\\nimport \\\"./interfaces/ISpender.sol\\\";\\nimport \\\"./interfaces/IZeroExchange.sol\\\";\\nimport \\\"./interfaces/IWeth.sol\\\";\\nimport \\\"./interfaces/IPMM.sol\\\";\\nimport \\\"./interfaces/IPermanentStorage.sol\\\";\\nimport \\\"./interfaces/IERC1271Wallet.sol\\\";\\n\\ncontract PMM is\\n    ReentrancyGuard,\\n    IPMM,\\n    LibOrder,\\n    LibDecoder,\\n    LibEncoder\\n{\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n\\n    // Constants do not have storage slot.\\n    string public constant version = \\\"5.0.0\\\";\\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    string public constant SOURCE = \\\"0x v2\\\";\\n    uint256 private constant BPS_MAX = 10000;\\n    bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;  // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n    address public immutable userProxy;\\n    ISpender public immutable spender;\\n    IPermanentStorage public immutable permStorage;\\n    IZeroExchange public immutable zeroExchange;\\n    address public immutable zxERC20Proxy;\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n\\n    struct TradeInfo {\\n        address user;\\n        address receiver;\\n        uint16 feeFactor;\\n        address makerAssetAddr;\\n        address takerAssetAddr;\\n        bytes32 transactionHash;\\n        bytes32 orderHash;\\n    }\\n\\n    // events\\n    event FillOrder(\\n        string source,\\n        bytes32 indexed transactionHash,\\n        bytes32 indexed orderHash,\\n        address indexed userAddr,\\n        address takerAssetAddr,\\n        uint256 takerAssetAmount,\\n        address makerAddr,\\n        address makerAssetAddr,\\n        uint256 makerAssetAmount,\\n        address receiverAddr,\\n        uint256 settleAmount,\\n        uint16 feeFactor\\n    );\\n\\n\\n    receive() external payable {}\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator {\\n        require(operator == msg.sender, \\\"PMM: not operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyUserProxy() {\\n        require(address(userProxy) == msg.sender, \\\"PMM: not the UserProxy contract\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"AMMWrapper: operator can not be zero address\\\");\\n        operator = _newOperator;\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    constructor (address _operator, address _userProxy, ISpender _spender, IPermanentStorage _permStorage, IZeroExchange _zeroExchange, address _zxERC20Proxy) public {\\n        operator = _operator;\\n        userProxy = _userProxy;\\n        spender = _spender;\\n        permStorage = _permStorage;\\n        zeroExchange = _zeroExchange;\\n        zxERC20Proxy = _zxERC20Proxy;\\n        // This constant follows ZX_EXCHANGE address\\n        EIP712_DOMAIN_HASH = keccak256(\\n            abi.encodePacked(\\n                EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\\n                bytes12(0),\\n                address(_zeroExchange)\\n            )\\n        );\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    /**\\n     * @dev approve spender to transfer tokens from this contract. This is used to collect fee.\\n     */\\n    function setAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, 0);\\n        }\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function fill(\\n        uint256 userSalt,\\n        bytes memory data,\\n        bytes memory userSignature\\n    )\\n        override\\n        public\\n        payable\\n        onlyUserProxy\\n        nonReentrant\\n        returns (uint256)\\n    {\\n        // decode & assert\\n        (LibOrder.Order memory order,\\n        TradeInfo memory tradeInfo) = _assertTransaction(userSalt, data, userSignature);\\n\\n        // Deposit to WETH if taker asset is ETH, else transfer from user\\n        IWETH weth = IWETH(permStorage.wethAddr());\\n        if (address(weth) == tradeInfo.takerAssetAddr) {\\n            require(\\n                msg.value == order.takerAssetAmount,\\n                \\\"PMM: insufficient ETH\\\"\\n            );\\n            weth.deposit{value: msg.value}();\\n        } else {\\n            spender.spendFromUser(tradeInfo.user, tradeInfo.takerAssetAddr, order.takerAssetAmount);\\n        }\\n\\n        IERC20(tradeInfo.takerAssetAddr).safeIncreaseAllowance(zxERC20Proxy, order.takerAssetAmount);\\n\\n        // send tx to 0x\\n        zeroExchange.executeTransaction(\\n            userSalt,\\n            address(this),\\n            data,\\n            \\\"\\\"\\n        );\\n\\n        // settle token/ETH to user\\n        uint256 settleAmount = _settle(weth, tradeInfo.receiver, tradeInfo.makerAssetAddr, order.makerAssetAmount, tradeInfo.feeFactor);\\n        IERC20(tradeInfo.takerAssetAddr).safeApprove(zxERC20Proxy, 0);\\n\\n        emit FillOrder(\\n            SOURCE,\\n            tradeInfo.transactionHash,\\n            tradeInfo.orderHash,\\n            tradeInfo.user,\\n            tradeInfo.takerAssetAddr,\\n            order.takerAssetAmount,\\n            order.makerAddress,\\n            tradeInfo.makerAssetAddr,\\n            order.makerAssetAmount,\\n            tradeInfo.receiver,\\n            settleAmount,\\n            tradeInfo.feeFactor\\n        );\\n        return settleAmount;\\n    }\\n\\n    /**\\n     * @dev internal function of `fill`.\\n     * It decodes and validates transaction data.\\n     */\\n    function _assertTransaction(\\n        uint256 userSalt,\\n        bytes memory data,\\n        bytes memory userSignature\\n    )\\n        internal\\n        view\\n        returns(\\n            LibOrder.Order memory order,\\n            TradeInfo memory tradeInfo\\n        )\\n    {\\n        // decode fillOrder data\\n        uint256 takerFillAmount;\\n        bytes memory mmSignature;\\n        (order, takerFillAmount, mmSignature) = decodeFillOrder(data);\\n\\n        require(\\n            order.takerAddress == address(this),\\n            \\\"PMM: incorrect taker\\\"\\n        );\\n        require(\\n            order.takerAssetAmount == takerFillAmount,\\n            \\\"PMM: incorrect fill amount\\\"\\n        );\\n\\n        // generate transactionHash\\n        tradeInfo.transactionHash = encodeTransactionHash(\\n            userSalt,\\n            address(this),\\n            data\\n        );\\n\\n        tradeInfo.orderHash = getOrderHash(order);\\n        tradeInfo.feeFactor = uint16(order.salt);\\n        tradeInfo.receiver = decodeUserSignatureWithoutSign(userSignature);\\n        tradeInfo.user = _ecrecoverAddress(tradeInfo.transactionHash, userSignature);\\n\\n        if (tradeInfo.user != order.feeRecipientAddress) {\\n            require(\\n                order.feeRecipientAddress.isContract(),\\n                \\\"PMM: invalid contract address\\\"\\n            );\\n            // isValidSignature() should return magic value: bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n            require(\\n                ERC1271_MAGICVALUE_BYTES32 == IERC1271Wallet(order.feeRecipientAddress)\\n                    .isValidSignature(\\n                        tradeInfo.transactionHash,\\n                        userSignature\\n                    ),\\n                \\\"PMM: invalid ERC1271 signer\\\"\\n            );\\n            tradeInfo.user = order.feeRecipientAddress;\\n        }\\n\\n        require(\\n            tradeInfo.feeFactor < BPS_MAX,\\n            \\\"PMM: invalid fee factor\\\"\\n        );\\n\\n        require(\\n            tradeInfo.receiver != address(0),\\n            \\\"PMM: invalid receiver\\\"\\n        );\\n\\n        // decode asset\\n        // just support ERC20\\n        tradeInfo.makerAssetAddr = decodeERC20Asset(order.makerAssetData);\\n        tradeInfo.takerAssetAddr = decodeERC20Asset(order.takerAssetData);\\n        return (\\n            order,\\n            tradeInfo\\n        );        \\n    }\\n\\n    // settle\\n    function _settle(IWETH weth, address receiver, address makerAssetAddr, uint256 makerAssetAmount, uint16 feeFactor) internal returns(uint256) {\\n        uint256 settleAmount = makerAssetAmount;\\n        if (feeFactor > 0) {\\n            // settleAmount = settleAmount * (10000 - feeFactor) / 10000\\n            settleAmount = settleAmount.mul((BPS_MAX).sub(feeFactor)).div(BPS_MAX);\\n        }\\n\\n        if (makerAssetAddr == address(weth)){\\n            weth.withdraw(settleAmount);\\n            payable(receiver).transfer(settleAmount);\\n        } else {\\n            IERC20(makerAssetAddr).safeTransfer(receiver, settleAmount);\\n        }\\n\\n        return settleAmount;\\n    }\\n\\n    function _ecrecoverAddress(bytes32 transactionHash, bytes memory signature) internal pure returns (address){\\n        (uint8 v, bytes32 r, bytes32 s, address receiver) = decodeUserSignature(signature);\\n        return ecrecover(\\n            keccak256(\\n                abi.encodePacked(\\n                    transactionHash,\\n                    receiver\\n                )),\\n            v, r, s\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pmm/0xLibs/LibEncoder.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibEIP712.sol\\\";\\n\\ncontract LibEncoder is\\n    LibEIP712\\n{\\n    // Hash for the EIP712 ZeroEx Transaction Schema\\n    bytes32 constant internal EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH = keccak256(\\n        abi.encodePacked(\\n        \\\"ZeroExTransaction(\\\",\\n        \\\"uint256 salt,\\\",\\n        \\\"address signerAddress,\\\",\\n        \\\"bytes data\\\",\\n        \\\")\\\"\\n    ));\\n\\n    function encodeTransactionHash(\\n        uint256 salt,\\n        address signerAddress,\\n        bytes memory data\\n    )\\n        internal\\n        view \\n        returns (bytes32 result)\\n    {\\n        bytes32 schemaHash = EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH;\\n        bytes32 dataHash = keccak256(data);\\n\\n        // Assembly for more efficiently computing:\\n        // keccak256(abi.encodePacked(\\n        //     EIP712_ZEROEX_TRANSACTION_SCHEMA_HASH,\\n        //     salt,\\n        //     bytes32(signerAddress),\\n        //     keccak256(data)\\n        // ));\\n\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            mstore(memPtr, schemaHash)                                                               // hash of schema\\n            mstore(add(memPtr, 32), salt)                                                            // salt\\n            mstore(add(memPtr, 64), and(signerAddress, 0xffffffffffffffffffffffffffffffffffffffff))  // signerAddress\\n            mstore(add(memPtr, 96), dataHash)                                                        // hash of data\\n\\n            // Compute hash\\n            result := keccak256(memPtr, 128)\\n        }\\n        result = hashEIP712Message(result);\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IZeroExchange.sol\": {\r\n      \"content\": \"/*\\n  Copyright 2018 ZeroEx Intl.\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n    http://www.apache.org/licenses/LICENSE-2.0\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License.\\n*/\\n\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IZeroExchange {\\n    function executeTransaction(\\n        uint256 salt,\\n        address signerAddress,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPMM.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../pmm/0xLibs/LibOrder.sol\\\";\\nimport \\\"./ISetAllowance.sol\\\";\\n\\ninterface IPMM is ISetAllowance {\\n    function fill(\\n        uint256 userSalt,\\n        bytes memory data,\\n        bytes memory userSignature\\n    ) external payable returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/stub/PermanentStorageStub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"../interfaces/IPermanentStorage.sol\\\";\\nimport \\\"../utils/lib_storage/PSStorage.sol\\\";\\n\\ncontract PermanentStorageStub is IPermanentStorage {\\n\\n    // Supported Curve pools\\n    address public constant CURVE_COMPOUND_POOL = 0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56;\\n    address public constant CURVE_USDT_POOL = 0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C;\\n    address public constant CURVE_Y_POOL = 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;\\n    address public constant CURVE_3_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\\n    address public constant CURVE_sUSD_POOL = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\\n    address public constant CURVE_BUSD_POOL = 0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27;\\n    address public constant CURVE_renBTC_POOL = 0x93054188d876f558f4a66B2EF1d97d16eDf0895B;\\n    address public constant CURVE_sBTC_POOL = 0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714;\\n    address public constant CURVE_hBTC_POOL = 0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F;\\n    address public constant CURVE_sETH_POOL = 0xc5424B857f758E906013F3555Dad202e4bdB4567;\\n\\n    // Curve coins\\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address private constant cDAI = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\\n    address private constant cUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\\n    address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address private constant TUSD = 0x0000000000085d4780B73119b644AE5ecd22b376;\\n    address private constant Y_POOL_yDAI = 0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01;\\n    address private constant Y_POOL_yUSDC = 0xd6aD7a6750A7593E092a9B218d66C0A814a3436e;\\n    address private constant Y_POOL_yUSDT = 0x83f798e925BcD4017Eb265844FDDAbb448f1707D;\\n    address private constant Y_POOL_yTUSD = 0x73a052500105205d34Daf004eAb301916DA8190f;\\n    address private constant sUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\\n    address private constant BUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53;\\n    address private constant BUSD_POOL_yDAI = 0xC2cB1040220768554cf699b0d863A3cd4324ce32;\\n    address private constant BUSD_POOL_yUSDC = 0x26EA744E5B887E5205727f55dFBE8685e3b21951;\\n    address private constant BUSD_POOL_yUSDT = 0xE6354ed5bC4b393a5Aad09f21c46E101e692d447;\\n    address private constant BUSD_POOL_yBUSD = 0x04bC0Ab673d88aE9dbC9DA2380cB6B79C4BCa9aE;\\n    address private constant renBTC = 0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D;\\n    address private constant wBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n    address private constant sBTC = 0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6;\\n    address private constant hBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;\\n    address private constant sETH = 0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb;\\n\\n    constructor() public {\\n        // register WETH address\\n        PSStorage.getStorage().wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n        // register Compound pool\\n        // underlying_coins, exchange_underlying\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_COMPOUND_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_COMPOUND_POOL][USDC] = 2;\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_COMPOUND_POOL][cDAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_COMPOUND_POOL][cUSDC] = 2;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_COMPOUND_POOL] = true; // support get_dx or get_dx_underlying for quoting\\n\\n        // register USDT pool\\n        // underlying_coins, exchange_underlying\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_USDT_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_USDT_POOL][USDC] = 2;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_USDT_POOL][USDT] = 3;\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_USDT_POOL][cDAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_USDT_POOL][cUSDC] = 2;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_USDT_POOL][USDT] = 3;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_USDT_POOL] = true;\\n\\n        // register Y pool\\n        // underlying_coins, exchange_underlying\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_Y_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_Y_POOL][USDC] = 2;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_Y_POOL][USDT] = 3;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_Y_POOL][TUSD] = 4;\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_Y_POOL][Y_POOL_yDAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_Y_POOL][Y_POOL_yUSDC] = 2;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_Y_POOL][Y_POOL_yUSDT] = 3;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_Y_POOL][Y_POOL_yTUSD] = 4;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_Y_POOL] = true;\\n\\n        // register 3 pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_3_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_3_POOL][USDC] = 2;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_3_POOL][USDT] = 3;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_3_POOL] = false; // only support get_dy and get_dy_underlying for exactly the same functionality\\n\\n        // register sUSD pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sUSD_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sUSD_POOL][USDC] = 2;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sUSD_POOL][USDT] = 3;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sUSD_POOL][sUSD] = 4;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_sUSD_POOL] = false;\\n\\n        // register BUSD pool\\n        // underlying_coins, exchange_underlying\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_BUSD_POOL][DAI] = 1;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_BUSD_POOL][USDC] = 2;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_BUSD_POOL][USDT] = 3;\\n        AMMWrapperStorage.getStorage().curveTokenIndexes[CURVE_BUSD_POOL][BUSD] = 4;\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_BUSD_POOL][BUSD_POOL_yDAI] = 1;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_BUSD_POOL][BUSD_POOL_yUSDC] = 2;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_BUSD_POOL][BUSD_POOL_yUSDT] = 3;\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_BUSD_POOL][BUSD_POOL_yBUSD] = 4;\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_BUSD_POOL] = true;\\n\\n        // register renBTC pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_renBTC_POOL][renBTC] = 1; // renBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_renBTC_POOL][wBTC] = 2; // wBTC\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_renBTC_POOL] = false;\\n\\n        // register sBTC pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sBTC_POOL][renBTC] = 1; // renBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sBTC_POOL][wBTC] = 2; // wBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sBTC_POOL][sBTC] = 3; // sBTC\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_sBTC_POOL] = false;\\n\\n        // register hBTC pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_hBTC_POOL][hBTC] = 1; // hBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_hBTC_POOL][wBTC] = 2; // wBTC\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_hBTC_POOL] = false;\\n\\n        // register sETH pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sETH_POOL][ETH] = 1; // ETH\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sETH_POOL][sETH] = 2; // sETH\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_sETH_POOL] = false;\\n    }\\n\\n    /************************************************************\\n    *                     Getter functions                      *\\n    *************************************************************/\\n    function ammWrapperAddr() public view returns (address) {\\n        return PSStorage.getStorage().ammWrapperAddr;\\n    }\\n\\n    function pmmAddr() public view returns (address) {\\n        return PSStorage.getStorage().pmmAddr;\\n    }\\n\\n    function rfqAddr() public view returns (address) {\\n        return PSStorage.getStorage().rfqAddr;\\n    }\\n\\n    function wethAddr() override external view returns (address) {\\n        return PSStorage.getStorage().wethAddr;\\n    }\\n\\n    function getCurvePoolInfo(address _makerAddr, address _takerAssetAddr, address _makerAssetAddr) override external view returns (int128 takerAssetIndex, int128 makerAssetIndex, uint16 swapMethod, bool supportGetDx) {\\n        // underlying_coins\\n        int128 i = AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_takerAssetAddr];\\n        int128 j = AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_makerAssetAddr];\\n        supportGetDx = AMMWrapperStorage.getStorage().curveSupportGetDx[_makerAddr];\\n\\n        swapMethod = 0;\\n        if (i != 0 && j != 0) {\\n            // in underlying_coins list\\n            takerAssetIndex = i;\\n            makerAssetIndex = j;\\n            // exchange_underlying\\n            swapMethod = 2;\\n        } else {\\n            // in coins list\\n            int128 iWrapped = AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][_takerAssetAddr];\\n            int128 jWrapped = AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][_makerAssetAddr];\\n            if (iWrapped != 0 && jWrapped != 0) {\\n                takerAssetIndex = iWrapped;\\n                makerAssetIndex = jWrapped;\\n                // exchange\\n                swapMethod = 1;\\n            } else {\\n                revert(\\\"PermanentStorage: invalid pair\\\");\\n            }\\n        }\\n        return (takerAssetIndex, makerAssetIndex, swapMethod, supportGetDx);\\n    }\\n\\n    function isTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isAMMTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isRFQTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return RFQStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isRelayerValid(address _relayer) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().relayerValid[_relayer];\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    /// @dev Update AMMWrapper contract address.\\n    function upgradeAMMWrapper(address _newAMMWrapper) external {\\n        PSStorage.getStorage().ammWrapperAddr = _newAMMWrapper;\\n    }\\n\\n    /// @dev Update PMM contract address.\\n    function upgradePMM(address _newPMM) external {\\n        PSStorage.getStorage().pmmAddr = _newPMM;\\n    }\\n\\n    /// @dev Update RFQ contract address.\\n    function upgradeRFQ(address _newRFQ) external {\\n        PSStorage.getStorage().rfqAddr = _newRFQ;\\n    }\\n\\n    /// @dev Update WETH contract address.\\n    function upgradeWETH(address _newWETH) external {\\n        PSStorage.getStorage().wethAddr = _newWETH;\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function setCurvePoolInfo(address _makerAddr, address[] calldata _underlyingCoins, address[] calldata _coins, bool _supportGetDx) override external {\\n        int128 underlyingCoinsLength = int128(_underlyingCoins.length);\\n        for (int128 i = 0 ; i < underlyingCoinsLength; i++) {\\n            address assetAddr = _underlyingCoins[uint256(i)];\\n            // underlying coins for original DAI, USDC, TUSD\\n            AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][assetAddr] = i + 1;\\n        }\\n\\n        int128 coinsLength = int128(_coins.length);\\n        for (int128 i = 0 ; i < coinsLength; i++) {\\n            address assetAddr = _coins[uint256(i)];\\n            // wrapped coins for cDAI, cUSDC, yDAI, yUSDC, yTUSD, yBUSD\\n            AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][assetAddr] = i + 1;\\n        }\\n\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[_makerAddr] = _supportGetDx;\\n    }\\n\\n    function setTransactionSeen(bytes32 _transactionHash) override external {\\n        require(!AMMWrapperStorage.getStorage().transactionSeen[_transactionHash], \\\"PermanentStorage: transaction seen before\\\");\\n        AMMWrapperStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setAMMTransactionSeen(bytes32 _transactionHash) override external {\\n        require(!AMMWrapperStorage.getStorage().transactionSeen[_transactionHash], \\\"PermanentStorage: transaction seen before\\\");\\n        AMMWrapperStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setRFQTransactionSeen(bytes32 _transactionHash) override external {\\n        require(!RFQStorage.getStorage().transactionSeen[_transactionHash], \\\"PermanentStorage: transaction seen before\\\");\\n        RFQStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setRelayersValid(address[] calldata _relayers, bool[] calldata _isValids) override external {\\n        require(_relayers.length == _isValids.length, \\\"PermanentStorage: inputs length mismatch\\\");\\n        for (uint256 i = 0; i < _relayers.length; i++) {\\n            AMMWrapperStorage.getStorage().relayerValid[_relayers[i]] = _isValids[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/lib_storage/PSStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.5;\\npragma experimental ABIEncoderV2;\\n\\nlibrary PSStorage {\\n    bytes32 private constant STORAGE_SLOT = 0x92dd52b981a2dd69af37d8a3febca29ed6a974aede38ae66e4ef773173aba471;\\n\\n    struct Storage {\\n        address ammWrapperAddr;\\n        address pmmAddr;\\n        address wethAddr;\\n        address rfqAddr;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.storage.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary AMMWrapperStorage {\\n    bytes32 private constant STORAGE_SLOT = 0xd38d862c9fa97c2fa857a46e08022d272a3579c114ca4f335f1e5fcb692c045e;\\n\\n    struct Storage {\\n        mapping(bytes32 => bool) transactionSeen;\\n        // curve pool => underlying token address => underlying token index\\n        mapping(address => mapping(address => int128)) curveTokenIndexes;\\n        mapping(address => bool) relayerValid;\\n        // 5.1.0 appended storage\\n        // curve pool => wrapped token address => wrapped token index\\n        mapping(address => mapping(address => int128)) curveWrappedTokenIndexes;\\n        mapping(address => bool) curveSupportGetDx;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.ammwrapper.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\\n\\nlibrary RFQStorage {\\n    bytes32 private constant STORAGE_SLOT = 0x9174e76494cfb023ddc1eb0effb6c12e107165382bbd0ecfddbc38ea108bbe52;\\n\\n    struct Storage {\\n        mapping(bytes32 => bool) transactionSeen;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\\\"permanent.rfq.storage\\\")) - 1));\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor_slot := slot }\\n    }\\n}\"\r\n    },\r\n    \"contracts/PermanentStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.5;\\n\\nimport \\\"./interfaces/IPermanentStorage.sol\\\";\\nimport \\\"./utils/lib_storage/PSStorage.sol\\\";\\n\\ncontract PermanentStorage is IPermanentStorage {\\n\\n    // Constants do not have storage slot.\\n    bytes32 public constant curveTokenIndexStorageId = 0xf4c750cdce673f6c35898d215e519b86e3846b1f0532fb48b84fe9d80f6de2fc; // keccak256(\\\"curveTokenIndex\\\")\\n    bytes32 public constant transactionSeenStorageId = 0x695d523b8578c6379a2121164fd8de334b9c5b6b36dff5408bd4051a6b1704d0;  // keccak256(\\\"transactionSeen\\\")\\n    bytes32 public constant relayerValidStorageId = 0x2c97779b4deaf24e9d46e02ec2699240a957d92782b51165b93878b09dd66f61;  // keccak256(\\\"relayerValid\\\")\\n\\n    // New supported Curve pools\\n    address public constant CURVE_renBTC_POOL = 0x93054188d876f558f4a66B2EF1d97d16eDf0895B;\\n    address public constant CURVE_sBTC_POOL = 0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714;\\n    address public constant CURVE_hBTC_POOL = 0x4CA9b3063Ec5866A4B82E437059D2C43d1be596F;\\n    address public constant CURVE_sETH_POOL = 0xc5424B857f758E906013F3555Dad202e4bdB4567;\\n\\n    // Curve coins\\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant renBTC = 0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D;\\n    address private constant wBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n    address private constant sBTC = 0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6;\\n    address private constant hBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;\\n    address private constant sETH = 0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb;\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    string public version;  // Current version of the contract\\n    mapping(bytes32 => mapping(address => bool)) private permission;\\n\\n\\n    // Operator events\\n    event TransferOwnership(address newOperator);\\n    event SetPermission(bytes32 storageId, address role, bool enabled);\\n    event UpgradeAMMWrapper(address newAMMWrapper);\\n    event UpgradePMM(address newPMM);\\n    event UpgradeRFQ(address newRFQ);\\n    event UpgradeWETH(address newWETH);\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"PermanentStorage: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier validRole(bool _enabled, address _role) {\\n        if (_enabled) {\\n            require(\\n                (_role == operator) || (_role == ammWrapperAddr()) || (_role == pmmAddr() || (_role == rfqAddr())),\\n                \\\"PermanentStorage: not a valid role\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    modifier isPermitted(bytes32 _storageId, address _role) {\\n        require(permission[_storageId][_role], \\\"PermanentStorage: has no permission\\\");\\n        _;\\n    }\\n\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"PermanentStorage: operator can not be zero address\\\");\\n        operator = _newOperator;\\n\\n        emit TransferOwnership(_newOperator);\\n    }\\n\\n    /// @dev Set permission for entity to write certain storage.\\n    function setPermission(bytes32 _storageId, address _role, bool _enabled) external onlyOperator validRole(_enabled, _role) {\\n        permission[_storageId][_role] = _enabled;\\n\\n        emit SetPermission(_storageId, _role, _enabled);\\n    }\\n\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    /// @dev Replacing constructor and initialize the contract. This function should only be called once.\\n    function initialize() external {\\n        require(\\n            keccak256(abi.encodePacked(version)) == keccak256(abi.encodePacked(\\\"5.1.0\\\")),\\n            \\\"PermanentStorage: not upgrading from 5.1.0 version\\\"\\n        );\\n        // upgrade from 5.1.0 to 5.2.0\\n        version = \\\"5.2.0\\\";\\n        // register renBTC pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_renBTC_POOL][renBTC] = 1; // renBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_renBTC_POOL][wBTC] = 2; // wBTC\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_renBTC_POOL] = false;\\n\\n        // register sBTC pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sBTC_POOL][renBTC] = 1; // renBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sBTC_POOL][wBTC] = 2; // wBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sBTC_POOL][sBTC] = 3; // sBTC\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_sBTC_POOL] = false;\\n\\n        // register hBTC pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_hBTC_POOL][hBTC] = 1; // hBTC\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_hBTC_POOL][wBTC] = 2; // wBTC\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_hBTC_POOL] = false;\\n\\n        // register sETH pool\\n        // coins, exchange\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sETH_POOL][ETH] = 1; // ETH\\n        AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[CURVE_sETH_POOL][sETH] = 2; // sETH\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[CURVE_sETH_POOL] = false;\\n    }\\n\\n\\n    /************************************************************\\n    *                     Getter functions                      *\\n    *************************************************************/\\n    function hasPermission(bytes32 _storageId, address _role) external view returns (bool) {\\n        return permission[_storageId][_role];\\n    }\\n\\n    function ammWrapperAddr() public view returns (address) {\\n        return PSStorage.getStorage().ammWrapperAddr;\\n    }\\n\\n    function pmmAddr() public view returns (address) {\\n        return PSStorage.getStorage().pmmAddr;\\n    }\\n\\n    function rfqAddr() public view returns (address) {\\n        return PSStorage.getStorage().rfqAddr;\\n    }\\n\\n    function wethAddr() override external view returns (address) {\\n        return PSStorage.getStorage().wethAddr;\\n    }\\n\\n    function getCurvePoolInfo(address _makerAddr, address _takerAssetAddr, address _makerAssetAddr) override external view returns (int128 takerAssetIndex, int128 makerAssetIndex, uint16 swapMethod, bool supportGetDx) {\\n        // underlying_coins\\n        int128 i = AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_takerAssetAddr];\\n        int128 j = AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_makerAssetAddr];\\n        supportGetDx = AMMWrapperStorage.getStorage().curveSupportGetDx[_makerAddr];\\n\\n        swapMethod = 0;\\n        if (i != 0 && j != 0) {\\n            // in underlying_coins list\\n            takerAssetIndex = i;\\n            makerAssetIndex = j;\\n            // exchange_underlying\\n            swapMethod = 2;\\n        } else {\\n            // in coins list\\n            int128 iWrapped = AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][_takerAssetAddr];\\n            int128 jWrapped = AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][_makerAssetAddr];\\n            if (iWrapped != 0 && jWrapped != 0) {\\n                takerAssetIndex = iWrapped;\\n                makerAssetIndex = jWrapped;\\n                // exchange\\n                swapMethod = 1;\\n            } else {\\n                revert(\\\"PermanentStorage: invalid pair\\\");\\n            }\\n        }\\n        return (takerAssetIndex, makerAssetIndex, swapMethod, supportGetDx);\\n    }\\n\\n    /* \\n    NOTE: `isTransactionSeen` is replaced by `isAMMTransactionSeen`. It is kept for backward compatability.\\n    It should be removed from AMM 5.2.1 upward.\\n    */\\n    function isTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isAMMTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isRFQTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\\n        return RFQStorage.getStorage().transactionSeen[_transactionHash];\\n    }\\n\\n    function isRelayerValid(address _relayer) override external view returns (bool) {\\n        return AMMWrapperStorage.getStorage().relayerValid[_relayer];\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    /// @dev Update AMMWrapper contract address.\\n    function upgradeAMMWrapper(address _newAMMWrapper) external onlyOperator {\\n        PSStorage.getStorage().ammWrapperAddr = _newAMMWrapper;\\n\\n        emit UpgradeAMMWrapper(_newAMMWrapper);\\n    }\\n\\n    /// @dev Update PMM contract address.\\n    function upgradePMM(address _newPMM) external onlyOperator {\\n        PSStorage.getStorage().pmmAddr = _newPMM;\\n\\n        emit UpgradePMM(_newPMM);\\n    }\\n\\n    /// @dev Update RFQ contract address.\\n    function upgradeRFQ(address _newRFQ) external onlyOperator {\\n        PSStorage.getStorage().rfqAddr = _newRFQ;\\n\\n        emit UpgradeRFQ(_newRFQ);\\n    }\\n\\n    /// @dev Update WETH contract address.\\n    function upgradeWETH(address _newWETH) external onlyOperator {\\n        PSStorage.getStorage().wethAddr = _newWETH;\\n\\n        emit UpgradeWETH(_newWETH);\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function setCurvePoolInfo(address _makerAddr, address[] calldata _underlyingCoins, address[] calldata _coins, bool _supportGetDx) override external isPermitted(curveTokenIndexStorageId, msg.sender) {\\n        int128 underlyingCoinsLength = int128(_underlyingCoins.length);\\n        for (int128 i = 0 ; i < underlyingCoinsLength; i++) {\\n            address assetAddr = _underlyingCoins[uint256(i)];\\n            // underlying coins for original DAI, USDC, TUSD\\n            AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][assetAddr] = i + 1;  // Start the index from 1\\n        }\\n\\n        int128 coinsLength = int128(_coins.length);\\n        for (int128 i = 0 ; i < coinsLength; i++) {\\n            address assetAddr = _coins[uint256(i)];\\n            // wrapped coins for cDAI, cUSDC, yDAI, yUSDC, yTUSD, yBUSD\\n            AMMWrapperStorage.getStorage().curveWrappedTokenIndexes[_makerAddr][assetAddr] = i + 1;  // Start the index from 1\\n        }\\n\\n        AMMWrapperStorage.getStorage().curveSupportGetDx[_makerAddr] = _supportGetDx;\\n    }\\n\\n    /* \\n    NOTE: `setTransactionSeen` is replaced by `setAMMTransactionSeen`. It is kept for backward compatability.\\n    It should be removed from AMM 5.2.1 upward.\\n    */\\n    function setTransactionSeen(bytes32 _transactionHash) override external isPermitted(transactionSeenStorageId, msg.sender) {\\n        require(!AMMWrapperStorage.getStorage().transactionSeen[_transactionHash], \\\"PermanentStorage: transaction seen before\\\");\\n        AMMWrapperStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setAMMTransactionSeen(bytes32 _transactionHash) override external isPermitted(transactionSeenStorageId, msg.sender) {\\n        require(!AMMWrapperStorage.getStorage().transactionSeen[_transactionHash], \\\"PermanentStorage: transaction seen before\\\");\\n        AMMWrapperStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setRFQTransactionSeen(bytes32 _transactionHash) override external isPermitted(transactionSeenStorageId, msg.sender) {\\n        require(!RFQStorage.getStorage().transactionSeen[_transactionHash], \\\"PermanentStorage: transaction seen before\\\");\\n        RFQStorage.getStorage().transactionSeen[_transactionHash] = true;\\n    }\\n\\n    function setRelayersValid(address[] calldata _relayers, bool[] calldata _isValids) override external isPermitted(relayerValidStorageId, msg.sender) {\\n        require(_relayers.length == _isValids.length, \\\"PermanentStorage: inputs length mismatch\\\");\\n        for (uint256 i = 0; i < _relayers.length; i++) {\\n            AMMWrapperStorage.getStorage().relayerValid[_relayers[i]] = _isValids[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AMMWrapperWithPath.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./AMMWrapper.sol\\\";\\nimport \\\"./interfaces/ISpender.sol\\\";\\nimport \\\"./interfaces/IUniswapRouterV2.sol\\\";\\nimport \\\"./interfaces/IUniswapV3SwapRouter.sol\\\";\\nimport \\\"./interfaces/IPermanentStorage.sol\\\";\\nimport \\\"./utils/UniswapV3PathLib.sol\\\";\\n\\ncontract AMMWrapperWithPath is AMMWrapper {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using Path for bytes;\\n\\n    // Constants do not have storage slot.\\n    address public constant UNISWAP_V3_ROUTER_ADDRESS = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n\\n    event Swapped(\\n        TxMetaData,\\n        Order order\\n    );\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    constructor (\\n        address _operator,\\n        uint256 _subsidyFactor,\\n        address _userProxy,\\n        ISpender _spender,\\n        IPermanentStorage _permStorage,\\n        IWETH _weth\\n    ) public AMMWrapper(_operator, _subsidyFactor, _userProxy, _spender, _permStorage, _weth) {}\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function trade(\\n        Order memory _order,\\n        uint256 _feeFactor,\\n        bytes calldata _sig,\\n        bytes calldata _makerSpecificData,\\n        address[] calldata _path\\n    )\\n        payable\\n        external\\n        nonReentrant\\n        onlyUserProxy\\n        returns (uint256) \\n    {\\n        require(_order.deadline >= block.timestamp, \\\"AMMWrapper: expired order\\\");\\n        TxMetaData memory txMetaData;\\n        InternalTxData memory internalTxData;\\n\\n        // These variables are copied straight from function parameters and\\n        // used to bypass stack too deep error.\\n        txMetaData.subsidyFactor = uint16(subsidyFactor);\\n        txMetaData.feeFactor = uint16(_feeFactor);\\n        internalTxData.makerSpecificData = _makerSpecificData;\\n        internalTxData.path = _path;\\n        if (! permStorage.isRelayerValid(tx.origin)) {\\n            txMetaData.feeFactor = (txMetaData.subsidyFactor > txMetaData.feeFactor) ? txMetaData.subsidyFactor : txMetaData.feeFactor;\\n            txMetaData.subsidyFactor = 0;\\n        }\\n\\n        // Assign trade vairables\\n        internalTxData.fromEth = (_order.takerAssetAddr == ZERO_ADDRESS || _order.takerAssetAddr == ETH_ADDRESS);\\n        internalTxData.toEth = (_order.makerAssetAddr == ZERO_ADDRESS || _order.makerAssetAddr == ETH_ADDRESS);\\n        if(_isCurve(_order.makerAddr)) {\\n            // PermanetStorage can recognize `ETH_ADDRESS` but not `ZERO_ADDRESS`.\\n            // Convert it to `ETH_ADDRESS` as passed in `_order.takerAssetAddr` or `_order.makerAssetAddr` might be `ZERO_ADDRESS`.\\n            internalTxData.takerAssetInternalAddr = internalTxData.fromEth ? ETH_ADDRESS : _order.takerAssetAddr;\\n            internalTxData.makerAssetInternalAddr = internalTxData.toEth ? ETH_ADDRESS : _order.makerAssetAddr;\\n        } else {\\n            internalTxData.takerAssetInternalAddr = internalTxData.fromEth ? address(weth) : _order.takerAssetAddr;\\n            internalTxData.makerAssetInternalAddr = internalTxData.toEth ? address(weth) : _order.makerAssetAddr;\\n        }\\n\\n        txMetaData.transactionHash = _verify(\\n            _order,\\n            _sig\\n        );\\n\\n        _prepare(_order, internalTxData);\\n\\n        (txMetaData.source, txMetaData.receivedAmount) = _swapWithPath(\\n            _order,\\n            txMetaData,\\n            internalTxData\\n        );\\n\\n        // Settle\\n        txMetaData.settleAmount = _settle(\\n            _order,\\n            txMetaData,\\n            internalTxData\\n        );\\n\\n        emit Swapped(\\n            txMetaData,\\n            _order\\n        );\\n\\n        return txMetaData.settleAmount;\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * Used to tell if maker is Curve.\\n     */\\n    function _isCurve(address _makerAddr) override internal pure returns (bool) {\\n        if (\\n            _makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\\n            _makerAddr == UNISWAP_V3_ROUTER_ADDRESS ||\\n            _makerAddr == SUSHISWAP_ROUTER_ADDRESS\\n        ) return false;\\n        else return true;\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * It executes the swap on chosen AMM.\\n     */\\n    function _swapWithPath(\\n        Order memory _order,\\n        TxMetaData memory _txMetaData,\\n        InternalTxData memory _internalTxData\\n    )\\n        internal\\n        approveTakerAsset(_internalTxData.takerAssetInternalAddr, _order.makerAddr)\\n        returns (string memory source, uint256 receivedAmount)\\n    {\\n        // Swap\\n        // minAmount = makerAssetAmount * (10000 - subsidyFactor) / 10000\\n        uint256 minAmount = _order.makerAssetAmount.mul((BPS_MAX.sub(_txMetaData.subsidyFactor))).div(BPS_MAX);\\n\\n        if (_order.makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\\n            _order.makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\\n            source = (_order.makerAddr == SUSHISWAP_ROUTER_ADDRESS) ? \\\"SushiSwap\\\" : \\\"Uniswap V2\\\";\\n            // Sushiswap shares the same interface as Uniswap's\\n            receivedAmount = _tradeUniswapV2TokenToToken(\\n                _order.makerAddr,\\n                _internalTxData.takerAssetInternalAddr,\\n                _internalTxData.makerAssetInternalAddr,\\n                _order.takerAssetAmount,\\n                minAmount,\\n                _order.deadline,\\n                _internalTxData.path\\n            );\\n        } else if (_order.makerAddr == UNISWAP_V3_ROUTER_ADDRESS) {\\n            source = \\\"Uniswap V3\\\";\\n            receivedAmount = _tradeUniswapV3TokenToToken(\\n                _order.makerAddr,\\n                _internalTxData.takerAssetInternalAddr,\\n                _internalTxData.makerAssetInternalAddr,\\n                _order.deadline,\\n                _order.takerAssetAmount,\\n                minAmount,\\n                _internalTxData.makerSpecificData\\n            );\\n        } else {\\n            CurveData memory curveData;\\n            (\\n                curveData.fromTokenCurveIndex,\\n                curveData.toTokenCurveIndex,\\n                curveData.swapMethod,\\n            ) = permStorage.getCurvePoolInfo(\\n                _order.makerAddr,\\n                _internalTxData.takerAssetInternalAddr,\\n                _internalTxData.makerAssetInternalAddr\\n            );\\n            require(curveData.swapMethod != 0,\\\"AMMWrapper: swap method not registered\\\");\\n            if (curveData.fromTokenCurveIndex > 0 && curveData.toTokenCurveIndex > 0) {\\n                source = \\\"Curve\\\";\\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\\n                curveData.fromTokenCurveIndex = curveData.fromTokenCurveIndex - 1;\\n                curveData.toTokenCurveIndex = curveData.toTokenCurveIndex - 1;\\n                // Curve does not return amount swapped so we need to record balance change instead.\\n                uint256 balanceBeforeTrade = _getSelfBalance(_internalTxData.makerAssetInternalAddr);\\n                _tradeCurveTokenToToken(\\n                    _order.makerAddr,\\n                    curveData.fromTokenCurveIndex,\\n                    curveData.toTokenCurveIndex,\\n                    _order.takerAssetAmount,\\n                    minAmount,\\n                    curveData.swapMethod\\n                );\\n                uint256 balanceAfterTrade = _getSelfBalance(_internalTxData.makerAssetInternalAddr);\\n                receivedAmount = balanceAfterTrade.sub(balanceBeforeTrade);\\n            } else {\\n                revert(\\\"AMMWrapper: unsupported makerAddr\\\");\\n            }\\n        }\\n    }\\n\\n    function _tradeUniswapV2TokenToToken(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _deadline,\\n        address[] memory _path\\n    )\\n        internal \\n        returns (uint256) \\n    {\\n        IUniswapRouterV2 router = IUniswapRouterV2(_makerAddr);\\n        if (_path.length == 0) {\\n            _path = new address[](2);\\n            _path[0] = _takerAssetAddr;\\n            _path[1] = _makerAssetAddr;\\n        } else {\\n            require(_path.length >= 2, \\\"AMMWrapper: path length must be at least two\\\");\\n            require(_path[0] == _takerAssetAddr, \\\"AMMWrapper: first element of path must match taker asset\\\");\\n            require(_path[_path.length - 1] == _makerAssetAddr, \\\"AMMWrapper: last element of path must match maker asset\\\");\\n        }\\n        uint256[] memory amounts = router.swapExactTokensForTokens(\\n            _takerAssetAmount,\\n            _makerAssetAmount,\\n            _path,\\n            address(this),\\n            _deadline\\n        );\\n        return amounts[amounts.length - 1];\\n    }\\n\\n    function _validateUniswapV3Path(\\n        bytes memory _path,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr\\n    ) internal {\\n        (address tokenA, address tokenB, ) = _path.decodeFirstPool();\\n\\n        if (_path.hasMultiplePools()) {\\n            _path = _path.skipToken();\\n            while (_path.hasMultiplePools()) {\\n                _path = _path.skipToken();\\n            }\\n            (, tokenB, ) = _path.decodeFirstPool();\\n        }\\n\\n        require(tokenA == _takerAssetAddr, \\\"AMMWrapper: first element of path must match taker asset\\\");\\n        require(tokenB == _makerAssetAddr, \\\"AMMWrapper: last element of path must match maker asset\\\");\\n    }\\n\\n    function _tradeUniswapV3TokenToToken(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _deadline,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        bytes memory _makerSpecificData\\n    )\\n        internal \\n        returns (uint256 amountOut) \\n    {\\n        ISwapRouter router = ISwapRouter(_makerAddr);\\n        // swapType:\\n        // 1: exactInputSingle, 2: exactInput\\n        uint8 swapType = uint8(uint256(_makerSpecificData.readBytes32(0)));\\n\\n        if (swapType == 1) {\\n            (, uint24 poolFee) = abi.decode(_makerSpecificData, (uint8, uint24));\\n            ISwapRouter.ExactInputSingleParams memory exactInputSingleParams;\\n            exactInputSingleParams.tokenIn = _takerAssetAddr;\\n            exactInputSingleParams.tokenOut = _makerAssetAddr;\\n            exactInputSingleParams.fee = poolFee;\\n            exactInputSingleParams.recipient = address(this);\\n            exactInputSingleParams.deadline = _deadline;\\n            exactInputSingleParams.amountIn = _takerAssetAmount;\\n            exactInputSingleParams.amountOutMinimum = _makerAssetAmount;\\n            exactInputSingleParams.sqrtPriceLimitX96 = 0;\\n\\n            amountOut = router.exactInputSingle(exactInputSingleParams);\\n        } else if (swapType == 2) {\\n            (, bytes memory path) = abi.decode(_makerSpecificData, (uint8, bytes));\\n            _validateUniswapV3Path(path, _takerAssetAddr, _makerAssetAddr);\\n            ISwapRouter.ExactInputParams memory exactInputParams;\\n            exactInputParams.path = path;\\n            exactInputParams.recipient = address(this);\\n            exactInputParams.deadline = _deadline;\\n            exactInputParams.amountIn = _takerAssetAmount;\\n            exactInputParams.amountOutMinimum = _makerAssetAmount;\\n\\n            amountOut = router.exactInput(exactInputParams);\\n        } else {\\n            revert(\\\"AMMWrapper: unsupported UniswapV3 swap type\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AMMWrapper.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/ISpender.sol\\\";\\nimport \\\"./interfaces/IUniswapExchange.sol\\\";\\nimport \\\"./interfaces/IUniswapFactory.sol\\\";\\nimport \\\"./interfaces/IUniswapRouterV2.sol\\\";\\nimport \\\"./interfaces/ICurveFi.sol\\\";\\nimport \\\"./interfaces/IAMM.sol\\\";\\nimport \\\"./interfaces/IWeth.sol\\\";\\nimport \\\"./interfaces/IPermanentStorage.sol\\\";\\nimport \\\"./utils/AMMLibEIP712.sol\\\";\\nimport \\\"./utils/SignatureValidator.sol\\\";\\n\\ncontract AMMWrapper is\\n    IAMM,\\n    ReentrancyGuard,\\n    AMMLibEIP712,\\n    SignatureValidator\\n{\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Constants do not have storage slot.\\n    string public constant version = \\\"5.2.0\\\";\\n    uint256 internal constant MAX_UINT = 2**256 - 1;\\n    uint256 internal constant BPS_MAX = 10000;\\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address internal constant ZERO_ADDRESS = address(0);\\n    address public immutable userProxy;\\n    IWETH public immutable weth;\\n    IPermanentStorage public immutable permStorage;\\n    address public constant UNISWAP_V2_ROUTER_02_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address public constant SUSHISWAP_ROUTER_ADDRESS = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\\n\\n    // Below are the variables which consume storage slots.\\n    address public operator;\\n    uint256 public subsidyFactor;\\n    ISpender public spender;\\n\\n    /* Struct and event declaration */\\n    // Group the local variables together to prevent\\n    // Compiler error: Stack too deep, try removing local variables.\\n    struct TxMetaData {\\n        string source;\\n        bytes32 transactionHash;\\n        uint256 settleAmount;\\n        uint256 receivedAmount;\\n        uint16 feeFactor;\\n        uint16 subsidyFactor;\\n    }\\n\\n    struct InternalTxData {\\n        bool fromEth;\\n        bool toEth;\\n        address takerAssetInternalAddr;\\n        address makerAssetInternalAddr;\\n        address[] path;\\n        bytes makerSpecificData;\\n    }\\n\\n    struct CurveData {\\n        int128 fromTokenCurveIndex;\\n        int128 toTokenCurveIndex;\\n        uint16 swapMethod;\\n    }\\n\\n    // Operator events\\n    event TransferOwnership(address newOperator);\\n    event UpgradeSpender(address newSpender);\\n    event SetSubsidyFactor(uint256 newSubisdyFactor);\\n    event AllowTransfer(address spender);\\n    event DisallowTransfer(address spender);\\n    event DepositETH(uint256 ethBalance);\\n\\n    event Swapped(\\n        string source,\\n        bytes32 indexed transactionHash,\\n        address indexed userAddr,\\n        address takerAssetAddr,\\n        uint256 takerAssetAmount,\\n        address makerAddr,\\n        address makerAssetAddr,\\n        uint256 makerAssetAmount,\\n        address receiverAddr,\\n        uint256 settleAmount,\\n        uint256 receivedAmount,\\n        uint16 feeFactor,\\n        uint16 subsidyFactor\\n    );\\n\\n\\n    receive() external payable {}\\n\\n\\n    /************************************************************\\n    *          Access control and ownership management          *\\n    *************************************************************/\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"AMMWrapper: not the operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyUserProxy() {\\n        require(address(userProxy) == msg.sender, \\\"AMMWrapper: not the UserProxy contract\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address _newOperator) external onlyOperator {\\n        require(_newOperator != address(0), \\\"AMMWrapper: operator can not be zero address\\\");\\n        operator = _newOperator;\\n\\n        emit TransferOwnership(_newOperator);\\n    }\\n\\n    /************************************************************\\n    *                 Internal function modifier                *\\n    *************************************************************/\\n    modifier approveTakerAsset(address _takerAssetInternalAddr, address _makerAddr) {\\n        bool isTakerAssetETH = _isInternalAssetETH(_takerAssetInternalAddr);\\n        if (! isTakerAssetETH) IERC20(_takerAssetInternalAddr).safeApprove(_makerAddr, MAX_UINT);\\n\\n        _;\\n\\n        if (! isTakerAssetETH) IERC20(_takerAssetInternalAddr).safeApprove(_makerAddr, 0);\\n    }\\n\\n    /************************************************************\\n    *              Constructor and init functions               *\\n    *************************************************************/\\n    constructor (\\n        address _operator,\\n        uint256 _subsidyFactor,\\n        address _userProxy,\\n        ISpender _spender,\\n        IPermanentStorage _permStorage,\\n        IWETH _weth\\n    ) public {\\n        operator = _operator;\\n        subsidyFactor = _subsidyFactor;\\n        userProxy = _userProxy;\\n        spender = _spender;\\n        permStorage = _permStorage;\\n        weth = _weth;\\n    }\\n\\n\\n    /************************************************************\\n    *           Management functions for Operator               *\\n    *************************************************************/\\n    /**\\n     * @dev set new Spender\\n     */\\n    function upgradeSpender(address _newSpender) external onlyOperator {\\n        require(_newSpender != address(0), \\\"AMMWrapper: spender can not be zero address\\\");\\n        spender = ISpender(_newSpender);\\n\\n        emit UpgradeSpender(_newSpender);\\n    }\\n\\n    function setSubsidyFactor(uint256 _subsidyFactor) external onlyOperator {\\n        subsidyFactor = _subsidyFactor;\\n\\n        emit SetSubsidyFactor(_subsidyFactor);\\n    }\\n\\n    /**\\n     * @dev approve spender to transfer tokens from this contract. This is used to collect fee.\\n     */\\n    function setAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, MAX_UINT);\\n\\n            emit AllowTransfer(_spender);\\n        }\\n    }\\n\\n    function closeAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\\n        for (uint256 i = 0 ; i < _tokenList.length; i++) {\\n            IERC20(_tokenList[i]).safeApprove(_spender, 0);\\n\\n            emit DisallowTransfer(_spender);\\n        }\\n    }\\n\\n    /**\\n     * @dev convert collected ETH to WETH\\n     */\\n    function depositETH() external onlyOperator {\\n        uint256 balance = address(this).balance;\\n        if (balance > 0) {\\n            weth.deposit{value: balance}();\\n\\n            emit DepositETH(balance);\\n        }\\n    }\\n\\n\\n    /************************************************************\\n    *                   External functions                      *\\n    *************************************************************/\\n    function trade(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _feeFactor,\\n        address _userAddr,\\n        address payable _receiverAddr,\\n        uint256 _salt,\\n        uint256 _deadline,\\n        bytes calldata _sig\\n    )\\n        override\\n        payable\\n        external\\n        nonReentrant\\n        onlyUserProxy\\n        returns (uint256) \\n    {\\n        Order memory order = Order(\\n            _makerAddr,\\n            _takerAssetAddr,\\n            _makerAssetAddr,\\n            _takerAssetAmount,\\n            _makerAssetAmount,\\n            _userAddr,\\n            _receiverAddr,\\n            _salt,\\n            _deadline\\n        );\\n        require(order.deadline >= block.timestamp, \\\"AMMWrapper: expired order\\\");\\n        TxMetaData memory txMetaData;\\n        InternalTxData memory internalTxData;\\n\\n        // These variables are copied straight from function parameters and\\n        // used to bypass stack too deep error.\\n        txMetaData.subsidyFactor = uint16(subsidyFactor);\\n        txMetaData.feeFactor = uint16(_feeFactor);\\n        if (! permStorage.isRelayerValid(tx.origin)) {\\n            txMetaData.feeFactor = (txMetaData.subsidyFactor > txMetaData.feeFactor) ? txMetaData.subsidyFactor : txMetaData.feeFactor;\\n            txMetaData.subsidyFactor = 0;\\n        }\\n\\n        // Assign trade vairables\\n        internalTxData.fromEth = (order.takerAssetAddr == ZERO_ADDRESS || order.takerAssetAddr == ETH_ADDRESS);\\n        internalTxData.toEth = (order.makerAssetAddr == ZERO_ADDRESS || order.makerAssetAddr == ETH_ADDRESS);\\n        if(_isCurve(order.makerAddr)) {\\n            // PermanetStorage can recognize `ETH_ADDRESS` but not `ZERO_ADDRESS`.\\n            // Convert it to `ETH_ADDRESS` as passed in `order.takerAssetAddr` or `order.makerAssetAddr` might be `ZERO_ADDRESS`.\\n            internalTxData.takerAssetInternalAddr = internalTxData.fromEth ? ETH_ADDRESS : order.takerAssetAddr;\\n            internalTxData.makerAssetInternalAddr = internalTxData.toEth ? ETH_ADDRESS : order.makerAssetAddr;\\n        } else {\\n            internalTxData.takerAssetInternalAddr = internalTxData.fromEth ? address(weth) : order.takerAssetAddr;\\n            internalTxData.makerAssetInternalAddr = internalTxData.toEth ? address(weth) : order.makerAssetAddr;\\n        }\\n\\n        txMetaData.transactionHash = _verify(\\n            order,\\n            _sig\\n        );\\n\\n        _prepare(order, internalTxData);\\n\\n        (txMetaData.source, txMetaData.receivedAmount) = _swap(\\n            order,\\n            txMetaData,\\n            internalTxData\\n        );\\n\\n        // Settle\\n        txMetaData.settleAmount = _settle(\\n            order,\\n            txMetaData,\\n            internalTxData\\n        );\\n\\n        emit Swapped(\\n            txMetaData.source,\\n            txMetaData.transactionHash,\\n            order.userAddr,\\n            order.takerAssetAddr,\\n            order.takerAssetAmount,\\n            order.makerAddr,\\n            order.makerAssetAddr,\\n            order.makerAssetAmount,\\n            order.receiverAddr,\\n            txMetaData.settleAmount,\\n            txMetaData.receivedAmount,\\n            txMetaData.feeFactor,\\n            txMetaData.subsidyFactor\\n        );\\n\\n        return txMetaData.settleAmount;\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * Used to tell if maker is Curve.\\n     */\\n    function _isCurve(address _makerAddr) virtual internal pure returns (bool) {\\n        if (\\n            _makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\\n            _makerAddr == SUSHISWAP_ROUTER_ADDRESS\\n        ) return false;\\n        else return true;\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * Used to tell if internal asset is ETH.\\n     */\\n    function _isInternalAssetETH(address _internalAssetAddr) internal pure returns (bool) {\\n        if (_internalAssetAddr == ETH_ADDRESS || _internalAssetAddr == ZERO_ADDRESS) return true;\\n        else return false;\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * Get this contract's eth balance or token balance.\\n     */\\n    function _getSelfBalance(address _makerAssetInternalAddr) internal view returns (uint256) {\\n        if (_isInternalAssetETH(_makerAssetInternalAddr)) {\\n            return address(this).balance;\\n        } else {\\n            return IERC20(_makerAssetInternalAddr).balanceOf(address(this));\\n        }\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * It verifies user signature and store tx hash to prevent replay attack.\\n     */\\n    function _verify(\\n        Order memory _order,\\n        bytes calldata _sig\\n    ) internal returns (bytes32 transactionHash) {\\n        // Verify user signature\\n        // TRADE_WITH_PERMIT_TYPEHASH = keccak256(\\\"tradeWithPermit(address makerAddr,address takerAssetAddr,address makerAssetAddr,uint256 takerAssetAmount,uint256 makerAssetAmount,address userAddr,address receiverAddr,uint256 salt,uint256 deadline)\\\");\\n        transactionHash = keccak256(\\n            abi.encode(\\n                TRADE_WITH_PERMIT_TYPEHASH,\\n                _order.makerAddr,\\n                _order.takerAssetAddr,\\n                _order.makerAssetAddr,\\n                _order.takerAssetAmount,\\n                _order.makerAssetAmount,\\n                _order.userAddr,\\n                _order.receiverAddr,\\n                _order.salt,\\n                _order.deadline\\n            )\\n        );\\n        bytes32 EIP712SignDigest = keccak256(\\n            abi.encodePacked(\\n                EIP191_HEADER,\\n                EIP712_DOMAIN_SEPARATOR,\\n                transactionHash\\n            )\\n        );\\n        require(isValidSignature(_order.userAddr, EIP712SignDigest, bytes(\\\"\\\"), _sig), \\\"AMMWrapper: invalid user signature\\\");\\n        // Set transaction as seen, PermanentStorage would throw error if transaction already seen.\\n        permStorage.setAMMTransactionSeen(transactionHash);\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * It executes the swap on chosen AMM.\\n     */\\n    function _prepare(Order memory _order, InternalTxData memory _internalTxData) internal {\\n        // Transfer asset from user and deposit to weth if needed\\n        if (_internalTxData.fromEth) {\\n            require(msg.value > 0, \\\"AMMWrapper: msg.value is zero\\\");\\n            require(_order.takerAssetAmount == msg.value, \\\"AMMWrapper: msg.value doesn't match\\\");\\n            // Deposit ETH to WETH if internal asset is WETH instead of ETH\\n            if (! _isInternalAssetETH(_internalTxData.takerAssetInternalAddr)) {\\n                weth.deposit{value: msg.value}();\\n            }\\n        } else {\\n            // other ERC20 tokens\\n            spender.spendFromUser(_order.userAddr, _order.takerAssetAddr, _order.takerAssetAmount);\\n        }\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * It executes the swap on chosen AMM.\\n     */\\n    function _swap(\\n        Order memory _order,\\n        TxMetaData memory _txMetaData,\\n        InternalTxData memory _internalTxData\\n    )\\n        internal\\n        approveTakerAsset(_internalTxData.takerAssetInternalAddr, _order.makerAddr)\\n        returns (string memory source, uint256 receivedAmount)\\n    {\\n        // Swap\\n        // minAmount = makerAssetAmount * (10000 - subsidyFactor) / 10000\\n        uint256 minAmount = _order.makerAssetAmount.mul((BPS_MAX.sub(_txMetaData.subsidyFactor))).div(BPS_MAX);\\n\\n        if (_order.makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\\n            _order.makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\\n            source = (_order.makerAddr == SUSHISWAP_ROUTER_ADDRESS) ? \\\"SushiSwap\\\" : \\\"Uniswap V2\\\";\\n            // Sushiswap shares the same interface as Uniswap's\\n            receivedAmount = _tradeUniswapV2TokenToToken(\\n                _order.makerAddr,\\n                _internalTxData.takerAssetInternalAddr,\\n                _internalTxData.makerAssetInternalAddr,\\n                _order.takerAssetAmount,\\n                minAmount,\\n                _order.deadline\\n            );\\n        } else {\\n            CurveData memory curveData;\\n            (\\n                curveData.fromTokenCurveIndex,\\n                curveData.toTokenCurveIndex,\\n                curveData.swapMethod,\\n            ) = permStorage.getCurvePoolInfo(\\n                _order.makerAddr,\\n                _internalTxData.takerAssetInternalAddr,\\n                _internalTxData.makerAssetInternalAddr\\n            );\\n            require(curveData.swapMethod != 0, \\\"AMMWrapper: swap method not registered\\\");\\n            if (curveData.fromTokenCurveIndex > 0 && curveData.toTokenCurveIndex > 0) {\\n                source = \\\"Curve\\\";\\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\\n                curveData.fromTokenCurveIndex = curveData.fromTokenCurveIndex - 1;\\n                curveData.toTokenCurveIndex = curveData.toTokenCurveIndex - 1;\\n                // Curve does not return amount swapped so we need to record balance change instead.\\n                uint256 balanceBeforeTrade = _getSelfBalance(_internalTxData.makerAssetInternalAddr);\\n                _tradeCurveTokenToToken(\\n                    _order.makerAddr,\\n                    curveData.fromTokenCurveIndex,\\n                    curveData.toTokenCurveIndex,\\n                    _order.takerAssetAmount,\\n                    minAmount,\\n                    curveData.swapMethod\\n                );\\n                uint256 balanceAfterTrade = _getSelfBalance(_internalTxData.makerAssetInternalAddr);\\n                receivedAmount = balanceAfterTrade.sub(balanceBeforeTrade);\\n            } else {\\n                revert(\\\"AMMWrapper: unsupported makerAddr\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev internal function of `trade`.\\n     * It collects fee from the trade or compensates the trade based on the actual amount swapped.\\n     */\\n    function _settle(\\n        Order memory _order,\\n        TxMetaData memory _txMetaData,\\n        InternalTxData memory _internalTxData\\n    )\\n        internal\\n        returns (uint256 settleAmount)\\n    {\\n        // Convert var type from uint16 to uint256\\n        uint256 _feeFactor = _txMetaData.feeFactor;\\n        uint256 _subsidyFactor = _txMetaData.subsidyFactor;\\n\\n        if (_txMetaData.receivedAmount == _order.makerAssetAmount) {\\n            settleAmount = _txMetaData.receivedAmount;\\n        } else if (_txMetaData.receivedAmount > _order.makerAssetAmount) {\\n            // shouldCollectFee = ((receivedAmount - makerAssetAmount) / receivedAmount) > (feeFactor / 10000)\\n            bool shouldCollectFee = _txMetaData.receivedAmount.sub(_order.makerAssetAmount).mul(BPS_MAX) > _feeFactor.mul(_txMetaData.receivedAmount);\\n            if (shouldCollectFee) {\\n                // settleAmount = receivedAmount * (1 - feeFactor) / 10000\\n                settleAmount = _txMetaData.receivedAmount.mul(BPS_MAX.sub(_feeFactor)).div(BPS_MAX);\\n            } else {\\n                settleAmount = _order.makerAssetAmount;\\n            }\\n        } else {\\n            require(_subsidyFactor > 0, \\\"AMMWrapper: this trade will not be subsidized\\\");\\n\\n            // If fee factor is smaller than subsidy factor, choose fee factor as actual subsidy factor\\n            // since we should subsidize less if we charge less.\\n            uint256 actualSubsidyFactor = (_subsidyFactor < _feeFactor) ? _subsidyFactor : _feeFactor;\\n\\n            // inSubsidyRange = ((makerAssetAmount - receivedAmount) / receivedAmount) > (actualSubsidyFactor / 10000)\\n            bool inSubsidyRange = _order.makerAssetAmount.sub(_txMetaData.receivedAmount).mul(BPS_MAX) <= actualSubsidyFactor.mul(_txMetaData.receivedAmount);\\n            require(inSubsidyRange, \\\"AMMWrapper: amount difference larger than subsidy amount\\\");\\n\\n            uint256 selfBalance = _getSelfBalance(_internalTxData.makerAssetInternalAddr);\\n            bool hasEnoughToSubsidize = selfBalance >= _order.makerAssetAmount;\\n            if (! hasEnoughToSubsidize && _isInternalAssetETH(_internalTxData.makerAssetInternalAddr)) {\\n                // We treat ETH and WETH the same so we have to convert WETH to ETH if ETH balance is not enough.\\n                uint256 amountShort = _order.makerAssetAmount.sub(selfBalance);\\n                if (amountShort <= weth.balanceOf(address(this))) {\\n                    // Withdraw the amount short from WETH\\n                    weth.withdraw(amountShort);\\n                    // Now we have enough\\n                    hasEnoughToSubsidize = true;\\n                }\\n            }\\n            require(hasEnoughToSubsidize, \\\"AMMWrapper: not enough savings to subsidize\\\");\\n\\n            settleAmount = _order.makerAssetAmount;\\n        }\\n\\n        // Transfer token/ETH to receiver\\n        if (_internalTxData.toEth) {\\n            // Withdraw from WETH if internal maker asset is WETH\\n            if (! _isInternalAssetETH(_internalTxData.makerAssetInternalAddr)) {\\n                weth.withdraw(settleAmount);\\n            }\\n            _order.receiverAddr.transfer(settleAmount);\\n        } else {\\n            // other ERC20 tokens\\n            IERC20(_order.makerAssetAddr).safeTransfer(_order.receiverAddr, settleAmount);\\n        }\\n    }\\n\\n    function _tradeCurveTokenToToken(\\n        address _makerAddr,\\n        int128 i,\\n        int128 j,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint16 swapMethod\\n    ) \\n        internal\\n    {\\n        ICurveFi curve = ICurveFi(_makerAddr);\\n        if (swapMethod == 1) {\\n            curve.exchange{value: msg.value}(i, j, _takerAssetAmount, _makerAssetAmount);\\n        } else if (swapMethod == 2) {\\n            curve.exchange_underlying{value: msg.value}(i, j, _takerAssetAmount, _makerAssetAmount);\\n        }\\n    }\\n\\n    function _tradeUniswapV2TokenToToken(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        uint256 _makerAssetAmount,\\n        uint256 _deadline\\n    )\\n        internal \\n        returns (uint256) \\n    {\\n        IUniswapRouterV2 router = IUniswapRouterV2(_makerAddr);\\n        address[] memory path = new address[](2);\\n        path[0] = _takerAssetAddr;\\n        path[1] = _makerAssetAddr;\\n        uint256[] memory amounts = router.swapExactTokensForTokens(\\n            _takerAssetAmount,\\n            _makerAssetAmount,\\n            path,\\n            address(this),\\n            _deadline\\n        );\\n        return amounts[1];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapRouterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.8.0;\\n\\ninterface IUniswapRouterV2 {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3SwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\"\r\n    },\r\n    \"contracts/utils/UniswapV3PathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nlibrary BytesLib {\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n                case 0 {\\n                    // Get a location of some free memory and store it in tempBytes as\\n                    // Solidity does for memory variables.\\n                    tempBytes := mload(0x40)\\n\\n                    // The first word of the slice result is potentially a partial\\n                    // word read from the original array. To read it, we calculate\\n                    // the length of that partial word and start copying that many\\n                    // bytes into the array. The first word we copy will start with\\n                    // data we don't care about, but the last `lengthmod` bytes will\\n                    // land at the beginning of the contents of the new array. When\\n                    // we're done copying, we overwrite the full first word with\\n                    // the actual length of the slice.\\n                    let lengthmod := and(_length, 31)\\n\\n                    // The multiplication in the next line is necessary\\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                    // the following copy loop was copying the origin's length\\n                    // and then ending prematurely not copying everything it should.\\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                    let end := add(mc, _length)\\n\\n                    for {\\n                        // The multiplication in the next line has the same exact purpose\\n                        // as the one above.\\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                    } lt(mc, end) {\\n                        mc := add(mc, 0x20)\\n                        cc := add(cc, 0x20)\\n                    } {\\n                        mstore(mc, mload(cc))\\n                    }\\n\\n                    mstore(tempBytes, _length)\\n\\n                    //update free-memory pointer\\n                    //allocating the array padded to 32 bytes like the compiler does now\\n                    mstore(0x40, and(add(mc, 31), not(31)))\\n                }\\n                //if we want a zero-length slice let's just return a zero-length array\\n                default {\\n                    tempBytes := mload(0x40)\\n                    //zero out the 32 bytes slice we are about to return\\n                    //we need to do it because Solidity does not garbage collect\\n                    mstore(tempBytes, 0)\\n\\n                    mstore(0x40, add(tempBytes, 0x20))\\n                }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3, \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n}\\n\\n/// @title Functions for manipulating path data for multihop swaps\\nlibrary Path {\\n    using BytesLib for bytes;\\n\\n    /// @dev The length of the bytes encoded address\\n    uint256 private constant ADDR_SIZE = 20;\\n    /// @dev The length of the bytes encoded fee\\n    uint256 private constant FEE_SIZE = 3;\\n\\n    /// @dev The offset of a single token address and pool fee\\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\\n    /// @dev The offset of an encoded pool key\\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\\n    /// @dev The minimum length of an encoding that contains 2 or more pools\\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\\n\\n    /// @notice Returns true iff the path contains two or more pools\\n    /// @param path The encoded swap path\\n    /// @return True if path contains two or more pools, otherwise false\\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\\n    }\\n\\n    /// @notice Decodes the first pool in path\\n    /// @param path The bytes encoded swap path\\n    /// @return tokenA The first token of the given pool\\n    /// @return tokenB The second token of the given pool\\n    /// @return fee The fee level of the pool\\n    function decodeFirstPool(bytes memory path)\\n        internal\\n        pure\\n        returns (\\n            address tokenA,\\n            address tokenB,\\n            uint24 fee\\n        )\\n    {\\n        tokenA = path.toAddress(0);\\n        fee = path.toUint24(ADDR_SIZE);\\n        tokenB = path.toAddress(NEXT_OFFSET);\\n    }\\n\\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\\n    /// @param path The swap path\\n    /// @return The remaining token + fee elements in the path\\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUniswapExchange.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\n\\ninterface IUniswapExchange {\\n    // Address of ERC20 token sold on this exchange\\n    function tokenAddress() external view returns (address token);\\n    // Address of Uniswap Factory\\n    function factoryAddress() external view returns (address factory);\\n    // Provide Liquidity\\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\\n    // Get Prices\\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\\n    // Trade ETH to ERC20\\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256 tokens_bought);\\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\\n    // Trade ERC20 to ETH\\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\\n    // Trade ERC20 to ERC20\\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\\n    // Trade ERC20 to Custom Pool\\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\\n    // ERC20 comaptibility for liquidity tokens\\n    function name() external view returns (bytes32);\\n    function symbol() external view returns (bytes32);\\n    function decimals() external view returns (uint256);\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n    function balanceOf(address _owner) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    // Never use\\n    function setup(address token_addr) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\n\\ninterface IUniswapFactory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n    function allPairsLength() external view returns (uint256);\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n\\n    // Create Exchange\\n    function createExchange(address token) external returns (address exchange);\\n    // Get Exchange and Token Info\\n    function getExchange(address token) external view returns (address exchange);\\n    function getToken(address exchange) external view returns (address token);\\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\\n    // Never use\\n    function initializeFactory(address template) external;\\n}\\n\\n    \\n\\n    \"\r\n    },\r\n    \"contracts/interfaces/ICurveFi.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.8.0;\\n\\ninterface ICurveFi {\\n    function get_virtual_price() external returns (uint256 out);\\n    function add_liquidity(\\n        uint256[2] calldata amounts,\\n        uint256 deadline\\n    ) external;\\n\\n    function add_liquidity(\\n        // sBTC pool\\n        uint256[3] calldata amounts,\\n        uint256 min_mint_amount\\n    ) external;\\n\\n    function add_liquidity(\\n        // bUSD pool\\n        uint256[4] calldata amounts,\\n        uint256 min_mint_amount\\n    ) external;\\n\\n    function get_dx(\\n        int128 i,\\n        int128 j,\\n        uint256 dy\\n    ) external view returns (uint256 out);\\n\\n    function get_dx_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dy\\n    ) external view returns (uint256 out);\\n\\n    function get_dy(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external view returns (uint256 out);\\n\\n    function get_dy_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external view returns (uint256 out);\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external payable;\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function exchange_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external payable;\\n\\n    function exchange_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function remove_liquidity(\\n        uint256 _amount,\\n        uint256 deadline,\\n        uint256[2] calldata min_amounts\\n    ) external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[2] calldata amounts,\\n        uint256 deadline\\n    ) external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[3] calldata amounts,\\n        uint256 max_burn_amount\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[3] calldata amounts)\\n        external;\\n\\n    function remove_liquidity_imbalance(\\n        uint256[4] calldata amounts,\\n        uint256 max_burn_amount\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[4] calldata amounts)\\n        external;\\n\\n    function commit_new_parameters(\\n        int128 amplification,\\n        int128 new_fee,\\n        int128 new_admin_fee\\n    ) external;\\n\\n    function apply_new_parameters() external;\\n\\n    function revert_new_parameters() external;\\n\\n    function commit_transfer_ownership(address _owner) external;\\n\\n    function apply_transfer_ownership() external;\\n\\n    function revert_transfer_ownership() external;\\n\\n    function withdraw_admin_fees() external;\\n\\n    function coins(int128 arg0) external returns (address out);\\n\\n    function underlying_coins(int128 arg0) external returns (address out);\\n\\n    function balances(int128 arg0) external returns (uint256 out);\\n\\n    function A() external returns (int128 out);\\n\\n    function fee() external returns (int128 out);\\n\\n    function admin_fee() external returns (int128 out);\\n\\n    function owner() external returns (address out);\\n\\n    function admin_actions_deadline() external returns (uint256 out);\\n\\n    function transfer_ownership_deadline() external returns (uint256 out);\\n\\n    function future_A() external returns (int128 out);\\n\\n    function future_fee() external returns (int128 out);\\n\\n    function future_admin_fee() external returns (int128 out);\\n\\n    function future_owner() external returns (address out);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/AMMLibEIP712.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./BaseLibEIP712.sol\\\";\\n\\ncontract AMMLibEIP712 is BaseLibEIP712 {\\n    /***********************************|\\n    |             Constants             |\\n    |__________________________________*/\\n\\n    struct Order {\\n        address makerAddr;\\n        address takerAssetAddr;\\n        address makerAssetAddr;\\n        uint256 takerAssetAmount;\\n        uint256 makerAssetAmount;\\n        address userAddr;\\n        address payable receiverAddr;\\n        uint256 salt;\\n        uint256 deadline;\\n    }\\n\\n    // keccak256(\\\"tradeWithPermit(address makerAddr,address takerAssetAddr,address makerAssetAddr,uint256 takerAssetAmount,uint256 makerAssetAmount,address userAddr,address receiverAddr,uint256 salt,uint256 deadline)\\\");\\n    bytes32 public constant TRADE_WITH_PERMIT_TYPEHASH = keccak256(\\n        abi.encodePacked(\\n            \\\"tradeWithPermit(\\\",\\n            \\\"address makerAddr,\\\",\\n            \\\"address takerAssetAddr,\\\",\\n            \\\"address makerAssetAddr,\\\",\\n            \\\"uint256 takerAssetAmount,\\\",\\n            \\\"uint256 makerAssetAmount,\\\",\\n            \\\"address userAddr,\\\",\\n            \\\"address receiverAddr,\\\",\\n            \\\"uint256 salt,\\\",\\n            \\\"uint256 deadline\\\",\\n            \\\")\\\"\\n        )\\n    );\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0 <0.8.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/MarketMakerProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./interfaces/IWeth.sol\\\";\\nimport \\\"./pmm/mmp/Ownable.sol\\\";\\nimport \\\"./pmm/0xLibs/LibDecoder.sol\\\";\\n\\ninterface IIMBTC {\\n    function burn(uint256 amount, bytes calldata data) external;\\n}\\n\\ninterface IWBTC {\\n    function burn(uint256 value) external;\\n}\\n\\ncontract MarketMakerProxy is \\n    Ownable,\\n    LibDecoder\\n{\\n    using SafeERC20 for IERC20;\\n\\n    string public constant version = \\\"5.0.0\\\";\\n    uint256 constant MAX_UINT = 2**256 - 1;\\n    address public SIGNER;\\n\\n    // auto withdraw weth to eth\\n    address public WETH_ADDR;\\n    address public withdrawer;\\n    mapping (address => bool) public isWithdrawWhitelist;\\n\\n    modifier onlyWithdrawer() {\\n        require(\\n            msg.sender == withdrawer,\\n            \\\"MarketMakerProxy: only contract withdrawer\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor () public {\\n        owner = msg.sender;\\n        operator = msg.sender;\\n    }\\n\\n    receive() external payable {}\\n\\n    // Manage\\n    function setSigner(address _signer) public onlyOperator {\\n        SIGNER = _signer;\\n    }\\n\\n    function setConfig(address _weth) public onlyOperator {\\n        WETH_ADDR = _weth;\\n    }\\n\\n    function setWithdrawer(address _withdrawer) public onlyOperator {\\n        withdrawer = _withdrawer;\\n    }\\n\\n    function setAllowance(address[] memory token_addrs, address spender) public onlyOperator {\\n        for (uint i = 0; i < token_addrs.length; i++) {\\n            address token = token_addrs[i];\\n            IERC20(token).safeApprove(spender, MAX_UINT);\\n        }\\n    }\\n\\n    function closeAllowance(address[] memory token_addrs, address spender) public onlyOperator {\\n        for (uint i = 0; i < token_addrs.length; i++) {\\n            address token = token_addrs[i];\\n            IERC20(token).safeApprove(spender, 0);\\n        }\\n    }\\n\\n    function registerWithdrawWhitelist(address _addr, bool _add) public onlyOperator {\\n        isWithdrawWhitelist[_addr] = _add;\\n    }\\n\\n    function withdraw(address token, address payable to, uint256 amount) public onlyWithdrawer {\\n        require(\\n            isWithdrawWhitelist[to],\\n            \\\"MarketMakerProxy: not in withdraw whitelist\\\"\\n        );\\n        if(token == WETH_ADDR) {\\n            IWETH(WETH_ADDR).withdraw(amount);\\n            to.transfer(amount);\\n        } else {\\n            IERC20(token).safeTransfer(to , amount);\\n        }\\n    }\\n\\n    function withdrawETH(address payable to, uint256 amount) public onlyWithdrawer {\\n        require(\\n            isWithdrawWhitelist[to],\\n            \\\"MarketMakerProxy: not in withdraw whitelist\\\"\\n        );\\n        to.transfer(amount);\\n    }\\n\\n\\n    function isValidSignature(bytes32 orderHash, bytes memory signature) public view returns (bytes32) {\\n        require(\\n            SIGNER == _ecrecoverAddress(orderHash, signature),\\n            \\\"MarketMakerProxy: invalid signature\\\"\\n        );\\n        return keccak256(\\\"isValidWalletSignature(bytes32,address,bytes)\\\");\\n    }\\n\\n    function _ecrecoverAddress(bytes32 orderHash, bytes memory signature) internal pure returns (address) {\\n        (uint8 v, bytes32 r, bytes32 s) = decodeMmSignature(signature);\\n        return ecrecover(\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    orderHash\\n                )),\\n            v, r, s\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pmm/mmp/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\ncontract Ownable {\\n  address public owner;\\n  address public operator;\\n\\n  constructor ()\\n    public\\n  {\\n    owner = msg.sender;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(\\n      msg.sender == owner,\\n      \\\"Ownable: only contract owner\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier onlyOperator() {\\n    require(\\n      msg.sender == operator,\\n      \\\"Ownable: only contract operator\\\"\\n    );\\n    _;\\n  }\\n\\n  function transferOwnership(address newOwner)\\n    public\\n    onlyOwner\\n  {\\n    if (newOwner != address(0)) {\\n      owner = newOwner;\\n    }\\n  }\\n\\n  function setOperator(address newOperator)\\n    public\\n    onlyOwner \\n  {\\n    operator = newOperator;\\n  }\\n}\"\r\n    },\r\n    \"contracts/AMMQuoter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/IUniswapExchange.sol\\\";\\nimport \\\"./interfaces/IUniswapFactory.sol\\\";\\nimport \\\"./interfaces/IUniswapRouterV2.sol\\\";\\nimport \\\"./interfaces/ICurveFi.sol\\\";\\nimport \\\"./interfaces/IWeth.sol\\\";\\nimport \\\"./interfaces/IPermanentStorage.sol\\\";\\nimport \\\"./interfaces/IUniswapV3Quoter.sol\\\";\\nimport \\\"./utils/LibBytes.sol\\\";\\n\\n/// This contract is designed to be called off-chain.\\n/// At T1, 4 requests would be made in order to get quote, which is for Uniswap v2, v3, Sushiswap and others.\\n/// For those source without path design, we can find best out amount in this contract.\\n/// For Uniswap and Sushiswap, best path would be calculated off-chain, we only verify out amount in this contract.\\n\\ncontract AMMQuoter {\\n    using SafeMath for uint256;\\n    using LibBytes for bytes;\\n\\n    /* Constants */\\n    string public constant version = \\\"5.2.0\\\";\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address private constant ZERO_ADDRESS = address(0);\\n    address public constant UNISWAP_V2_ROUTER_02_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address public constant UNISWAP_V3_ROUTER_ADDRESS = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n    address public constant UNISWAP_V3_QUOTER_ADDRESS = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;\\n    address public constant SUSHISWAP_ROUTER_ADDRESS = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\\n    address public immutable weth;\\n    IPermanentStorage public immutable permStorage;\\n\\n    struct GroupedVars {\\n        address makerAddr;\\n        address takerAssetAddr;\\n        address makerAssetAddr;\\n        uint256 takerAssetAmount;\\n        uint256 makerAssetAmount;\\n        address[] path;\\n    }\\n\\n    event CurveTokenAdded(\\n        address indexed makerAddress,\\n        address indexed assetAddress,\\n        int128 index\\n    );\\n\\n    constructor (IPermanentStorage _permStorage, address _weth) public {\\n        permStorage = _permStorage;\\n        weth = _weth;\\n    }\\n\\n    function isETH(address assetAddress) public pure returns (bool) {\\n        return (assetAddress == ZERO_ADDRESS || assetAddress == ETH_ADDRESS);\\n    }\\n\\n    function getMakerOutAmountWithPath(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount,\\n        address[] calldata _path,\\n        bytes memory _makerSpecificData\\n    )\\n        public\\n        returns (uint256 makerAssetAmount)\\n    {\\n        GroupedVars memory vars;\\n        vars.makerAddr = _makerAddr;\\n        vars.takerAssetAddr = _takerAssetAddr;\\n        vars.makerAssetAddr = _makerAssetAddr;\\n        vars.takerAssetAmount = _takerAssetAmount;\\n        vars.path = _path;\\n        if (vars.makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\\n            vars.makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(vars.makerAddr);\\n            uint256[] memory amounts = router.getAmountsOut(vars.takerAssetAmount, vars.path);\\n            makerAssetAmount = amounts[amounts.length-1];\\n        } else if (vars.makerAddr == UNISWAP_V3_ROUTER_ADDRESS) {\\n            IUniswapV3Quoter quoter = IUniswapV3Quoter(UNISWAP_V3_QUOTER_ADDRESS);\\n            // swapType:\\n            // 1: exactInputSingle, 2: exactInput, 3: exactOuputSingle, 4: exactOutput\\n            uint8 swapType = uint8(uint256(_makerSpecificData.readBytes32(0)));\\n            if (swapType == 1) {\\n                address v3TakerInternalAsset = isETH(vars.takerAssetAddr) ? weth : vars.takerAssetAddr;\\n                address v3MakerInternalAsset = isETH(vars.makerAssetAddr) ? weth : vars.makerAssetAddr;\\n                (, uint24 poolFee) = abi.decode(_makerSpecificData, (uint8, uint24));\\n                makerAssetAmount = quoter.quoteExactInputSingle(v3TakerInternalAsset, v3MakerInternalAsset, poolFee, vars.takerAssetAmount, 0);\\n            } else if (swapType == 2) {\\n                (, bytes memory path) = abi.decode(_makerSpecificData, (uint8, bytes));\\n                makerAssetAmount = quoter.quoteExactInput(path, vars.takerAssetAmount);\\n            } else {\\n                revert(\\\"AMMQuoter: Invalid UniswapV3 swap type\\\");\\n            }\\n        } else {\\n            address curveTakerIntenalAsset = isETH(vars.takerAssetAddr) ? ETH_ADDRESS : vars.takerAssetAddr;\\n            address curveMakerIntenalAsset = isETH(vars.makerAssetAddr) ? ETH_ADDRESS : vars.makerAssetAddr;\\n            (int128 fromTokenCurveIndex, int128 toTokenCurveIndex, uint16 swapMethod,) = permStorage.getCurvePoolInfo(vars.makerAddr, curveTakerIntenalAsset, curveMakerIntenalAsset);\\n            if (fromTokenCurveIndex > 0 && toTokenCurveIndex > 0) {\\n                require(swapMethod != 0, \\\"AMMQuoter: swap method not registered\\\");\\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\\n                fromTokenCurveIndex = fromTokenCurveIndex - 1;\\n                toTokenCurveIndex = toTokenCurveIndex - 1;\\n                ICurveFi curve = ICurveFi(vars.makerAddr);\\n                if (swapMethod == 1) {\\n                    makerAssetAmount = curve.get_dy(fromTokenCurveIndex, toTokenCurveIndex, vars.takerAssetAmount).sub(1);\\n                } else if (swapMethod == 2) {\\n                    makerAssetAmount = curve.get_dy_underlying(fromTokenCurveIndex, toTokenCurveIndex, vars.takerAssetAmount).sub(1);\\n                }\\n            } else {\\n                revert(\\\"AMMQuoter: Unsupported makerAddr\\\");\\n            }\\n        }\\n        return makerAssetAmount;\\n    }\\n\\n    function getMakerOutAmount(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 makerAssetAmount;\\n        if (_makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\\n            _makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(_makerAddr);\\n            address[] memory path = new address[](2);\\n            if (isETH(_takerAssetAddr)) {\\n                path[0] = weth;\\n                path[1] = _makerAssetAddr;\\n            } else if (isETH(_makerAssetAddr)) {\\n                path[0] = _takerAssetAddr;\\n                path[1] = weth;\\n            } else {\\n                path[0] = _takerAssetAddr;\\n                path[1] = _makerAssetAddr;\\n            }\\n            uint256[] memory amounts = router.getAmountsOut(_takerAssetAmount, path);\\n            makerAssetAmount = amounts[1];\\n        } else {\\n            address curveTakerIntenalAsset = isETH(_takerAssetAddr) ? ETH_ADDRESS : _takerAssetAddr;\\n            address curveMakerIntenalAsset = isETH(_makerAssetAddr) ? ETH_ADDRESS : _makerAssetAddr;\\n            (int128 fromTokenCurveIndex, int128 toTokenCurveIndex, uint16 swapMethod,) = permStorage.getCurvePoolInfo(_makerAddr, curveTakerIntenalAsset, curveMakerIntenalAsset);\\n            if (fromTokenCurveIndex > 0 && toTokenCurveIndex > 0) {\\n                require(swapMethod != 0, \\\"AMMQuoter: swap method not registered\\\");\\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\\n                fromTokenCurveIndex = fromTokenCurveIndex - 1;\\n                toTokenCurveIndex = toTokenCurveIndex - 1;\\n                ICurveFi curve = ICurveFi(_makerAddr);\\n                if (swapMethod == 1) {\\n                    makerAssetAmount = curve.get_dy(fromTokenCurveIndex, toTokenCurveIndex, _takerAssetAmount).sub(1);\\n                } else if (swapMethod == 2) {\\n                    makerAssetAmount = curve.get_dy_underlying(fromTokenCurveIndex, toTokenCurveIndex, _takerAssetAmount).sub(1);\\n                }\\n            } else {\\n                revert(\\\"AMMQuoter: Unsupported makerAddr\\\");\\n            }\\n        }\\n        return makerAssetAmount;\\n    }\\n\\n    /// @dev This function is designed for finding best out amount among AMM makers other than Uniswap and Sushiswap\\n    function getBestOutAmount(\\n        address[] calldata _makerAddresses,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _takerAssetAmount\\n    )\\n        external\\n        view\\n        returns (address bestMaker, uint256 bestAmount)\\n    {\\n        bestAmount = 0;\\n        uint256 poolLength = _makerAddresses.length;\\n        for (uint256 i = 0; i < poolLength; i++) {\\n            address makerAddress = _makerAddresses[i];\\n            uint256 makerAssetAmount = getMakerOutAmount(makerAddress, _takerAssetAddr, _makerAssetAddr, _takerAssetAmount);\\n            if (makerAssetAmount > bestAmount) {\\n                bestAmount = makerAssetAmount;\\n                bestMaker = makerAddress;\\n            }\\n        }\\n        return (bestMaker, bestAmount);\\n    }\\n\\n    function getTakerInAmountWithPath(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _makerAssetAmount,\\n        address[] calldata _path,\\n        bytes memory _makerSpecificData\\n    )\\n        public\\n        returns (uint256 takerAssetAmount)\\n    {\\n        GroupedVars memory vars;\\n        vars.makerAddr = _makerAddr;\\n        vars.takerAssetAddr = _takerAssetAddr;\\n        vars.makerAssetAddr = _makerAssetAddr;\\n        vars.makerAssetAmount = _makerAssetAmount;\\n        vars.path = _path;\\n        if (vars.makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\\n            vars.makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(vars.makerAddr);\\n            uint256[] memory amounts = router.getAmountsIn(vars.makerAssetAmount, _path);\\n            takerAssetAmount = amounts[0];\\n        } else if (vars.makerAddr == UNISWAP_V3_ROUTER_ADDRESS) {\\n            IUniswapV3Quoter quoter = IUniswapV3Quoter(UNISWAP_V3_QUOTER_ADDRESS);\\n            // swapType:\\n            // 1: exactInputSingle, 2: exactInput, 3: exactOuputSingle, 4: exactOutput\\n            uint8 swapType = uint8(uint256(_makerSpecificData.readBytes32(0)));\\n            if (swapType == 3) {\\n                address v3TakerInternalAsset = isETH(vars.takerAssetAddr) ? weth : vars.takerAssetAddr;\\n                address v3MakerInternalAsset = isETH(vars.makerAssetAddr) ? weth : vars.makerAssetAddr;\\n                (, uint24 poolFee) = abi.decode(_makerSpecificData, (uint8, uint24));\\n                takerAssetAmount = quoter.quoteExactOutputSingle(v3TakerInternalAsset, v3MakerInternalAsset, poolFee, vars.makerAssetAmount, 0);\\n            } else if (swapType == 4) {\\n                (, bytes memory path) = abi.decode(_makerSpecificData, (uint8, bytes));\\n                takerAssetAmount = quoter.quoteExactOutput(path, vars.makerAssetAmount);\\n            } else {\\n                revert(\\\"AMMQuoter: Invalid UniswapV3 swap type\\\");\\n            }\\n        } else {\\n            address curveTakerIntenalAsset = isETH(vars.takerAssetAddr) ? ETH_ADDRESS : vars.takerAssetAddr;\\n            address curveMakerIntenalAsset = isETH(vars.makerAssetAddr) ? ETH_ADDRESS : vars.makerAssetAddr;\\n            (int128 fromTokenCurveIndex, int128 toTokenCurveIndex, uint16 swapMethod, bool supportGetDx) = permStorage.getCurvePoolInfo(vars.makerAddr, curveTakerIntenalAsset, curveMakerIntenalAsset);\\n            if (fromTokenCurveIndex > 0 && toTokenCurveIndex > 0) {\\n                require(swapMethod != 0, \\\"AMMQuoter: swap method not registered\\\");\\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\\n                fromTokenCurveIndex = fromTokenCurveIndex - 1;\\n                toTokenCurveIndex = toTokenCurveIndex - 1;\\n                ICurveFi curve = ICurveFi(vars.makerAddr);\\n                if (supportGetDx) {\\n                    if (swapMethod == 1) {\\n                        takerAssetAmount = curve.get_dx(fromTokenCurveIndex, toTokenCurveIndex, vars.makerAssetAmount);\\n                    } else if (swapMethod == 2) {\\n                        takerAssetAmount = curve.get_dx_underlying(fromTokenCurveIndex, toTokenCurveIndex, vars.makerAssetAmount);\\n                    }\\n                } else {\\n                    if (swapMethod == 1) {\\n                        // does not support get_dx_underlying, try to get an estimated rate here\\n                        takerAssetAmount = curve.get_dy(toTokenCurveIndex, fromTokenCurveIndex, vars.makerAssetAmount);\\n                    } else if (swapMethod == 2) {\\n                        takerAssetAmount = curve.get_dy_underlying(toTokenCurveIndex, fromTokenCurveIndex, vars.makerAssetAmount);\\n                    }\\n                }\\n            } else {\\n                revert(\\\"AMMQuoter: Unsupported makerAddr\\\");\\n            }\\n        }\\n        return takerAssetAmount;\\n    }\\n\\n    function getTakerInAmount(\\n        address _makerAddr,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _makerAssetAmount\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 takerAssetAmount;\\n        if (_makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\\n            _makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\\n            IUniswapRouterV2 router = IUniswapRouterV2(_makerAddr);\\n            address[] memory path = new address[](2);\\n            if (isETH(_takerAssetAddr)) {\\n                path[0] = weth;\\n                path[1] = _makerAssetAddr;\\n            } else if (isETH(_makerAssetAddr)) {\\n                path[0] = _takerAssetAddr;\\n                path[1] = weth;\\n            } else {\\n                path[0] = _takerAssetAddr;\\n                path[1] = _makerAssetAddr;\\n            }\\n            uint256[] memory amounts = router.getAmountsIn(_makerAssetAmount, path);\\n            takerAssetAmount = amounts[0];\\n        } else {\\n            address curveTakerIntenalAsset = isETH(_takerAssetAddr) ? ETH_ADDRESS : _takerAssetAddr;\\n            address curveMakerIntenalAsset = isETH(_makerAssetAddr) ? ETH_ADDRESS : _makerAssetAddr;\\n            (int128 fromTokenCurveIndex, int128 toTokenCurveIndex, uint16 swapMethod, bool supportGetDx) = permStorage.getCurvePoolInfo(_makerAddr, curveTakerIntenalAsset, curveMakerIntenalAsset);\\n            if (fromTokenCurveIndex > 0 && toTokenCurveIndex > 0) {\\n                require(swapMethod != 0, \\\"AMMQuoter: swap method not registered\\\");\\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\\n                fromTokenCurveIndex = fromTokenCurveIndex - 1;\\n                toTokenCurveIndex = toTokenCurveIndex - 1;\\n                ICurveFi curve = ICurveFi(_makerAddr);\\n                if (supportGetDx) {\\n                    if (swapMethod == 1) {\\n                        takerAssetAmount = curve.get_dx(fromTokenCurveIndex, toTokenCurveIndex, _makerAssetAmount);\\n                    } else if (swapMethod == 2) {\\n                        takerAssetAmount = curve.get_dx_underlying(fromTokenCurveIndex, toTokenCurveIndex, _makerAssetAmount);\\n                    }\\n                } else {\\n                    if (swapMethod == 1) {\\n                        // does not support get_dx_underlying, try to get an estimated rate here\\n                        takerAssetAmount = curve.get_dy(toTokenCurveIndex, fromTokenCurveIndex, _makerAssetAmount);\\n                    } else if (swapMethod == 2) {\\n                        takerAssetAmount = curve.get_dy_underlying(toTokenCurveIndex, fromTokenCurveIndex, _makerAssetAmount);\\n                    }\\n                }\\n            } else {\\n                revert(\\\"AMMQuoter: Unsupported makerAddr\\\");\\n            }\\n        }\\n        return takerAssetAmount;\\n    }\\n\\n    /// @dev This function is designed for finding best in amount among AMM makers other than Uniswap and Sushiswap\\n    function getBestInAmount(\\n        address[] calldata _makerAddresses,\\n        address _takerAssetAddr,\\n        address _makerAssetAddr,\\n        uint256 _makerAssetAmount\\n    )\\n        external\\n        view\\n        returns (address bestMaker, uint256 bestAmount)\\n    {\\n        bestAmount = 2**256 - 1;\\n        uint256 poolLength = _makerAddresses.length;\\n        for (uint256 i = 0; i < poolLength; i++) {\\n            address makerAddress = _makerAddresses[i];\\n            uint256 takerAssetAmount = getTakerInAmount(makerAddress, _takerAssetAddr, _makerAssetAddr, _makerAssetAmount);\\n            if (takerAssetAmount < bestAmount) {\\n                bestAmount = takerAssetAmount;\\n                bestMaker = makerAddress;\\n            }\\n        }\\n        return (bestMaker, bestAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3Quoter.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n/// @title Quoter Interface\\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\\ninterface IUniswapV3Quoter {\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountIn The amount of the first token to swap\\n    /// @return amountOut The amount of the last token that would be received\\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountIn The desired input amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountOut The amount of `tokenOut` that would be received\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n    /// @param amountOut The amount of the last token to receive\\n    /// @return amountIn The amount of first token required to be paid\\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountOut The desired output amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/SpenderSimulation.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"./interfaces/IHasBlackListERC20Token.sol\\\";\\nimport \\\"./interfaces/ISpender.sol\\\";\\n\\ncontract SpenderSimulation {\\n    ISpender public immutable spender;\\n\\n    mapping(address => bool) public hasBlackListERC20Tokens;\\n\\n    modifier checkBlackList(address _tokenAddr, address _user) {\\n        if (hasBlackListERC20Tokens[_tokenAddr]) {\\n            IHasBlackListERC20Token hasBlackListERC20Token = IHasBlackListERC20Token(_tokenAddr);\\n            require(!hasBlackListERC20Token.isBlackListed(_user), \\\"SpenderSimulation: user in token's blacklist\\\");\\n        }\\n        _;\\n    }\\n\\n    /************************************************************\\n    *                       Constructor                         *\\n    *************************************************************/\\n    constructor (ISpender _spender, address[] memory _hasBlackListERC20Tokens) public {\\n        spender = _spender;\\n\\n        for (uint256 i = 0; i < _hasBlackListERC20Tokens.length; i++) {\\n            hasBlackListERC20Tokens[_hasBlackListERC20Tokens[i]] = true;\\n        }\\n    }\\n\\n    /************************************************************\\n    *                    Helper functions                       *\\n    *************************************************************/\\n    /// @dev Spend tokens on user's behalf but reverts if succeed.\\n    /// This is only intended to be run off-chain to check if the transfer will succeed.\\n    /// @param _user The user to spend token from.\\n    /// @param _tokenAddr The address of the token.\\n    /// @param _amount Amount to spend.\\n    function simulate(address _user, address _tokenAddr, uint256 _amount) external checkBlackList(_tokenAddr, _user) {\\n        spender.spendFromUser(_user, _tokenAddr, _amount);\\n\\n        // All checks passed: revert with success reason string\\n        revert(\\\"SpenderSimulation: transfer simulation success\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHasBlackListERC20Token.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IHasBlackListERC20Token is IERC20 {\\n    function isBlackListed(address user) external returns (bool);\\n    function addBlackList(address user) external;\\n    function removeBlackList(address user) external;\\n}\"\r\n    },\r\n    \"contracts/Tokenlon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./upgrade_proxy/TransparentUpgradeableProxy.sol\\\";\\n\\ncontract Tokenlon is TransparentUpgradeableProxy {\\n    constructor(address _logic, address _admin, bytes memory _data) public payable TransparentUpgradeableProxy(_logic, _admin, _data) {}\\n}\"\r\n    },\r\n    \"contracts/upgrade_proxy/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n * \\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n * \\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n * \\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n * \\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\\n     */\\n    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(_admin);\\n    }\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _admin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     * \\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     * \\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address) {\\n        return _admin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     * \\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     * \\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address) {\\n        return _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     * \\n     * Emits an {AdminChanged} event.\\n     * \\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external ifAdmin {\\n        require(newAdmin != address(0), \\\"TransparentUpgradeableProxy: new admin is the zero address\\\");\\n        emit AdminChanged(_admin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     * \\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     * \\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeTo(newImplementation);\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success,) = newImplementation.delegatecall(data);\\n        require(success);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view returns (address adm) {\\n        bytes32 slot = _ADMIN_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            adm := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        bytes32 slot = _ADMIN_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newAdmin)\\n        }\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal override virtual {\\n        require(msg.sender != _admin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrade_proxy/UpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"./Proxy.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n * \\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\\n * {TransparentUpgradeableProxy}.\\n */\\ncontract UpgradeableProxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     * \\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) public payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if(_data.length > 0) {\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success,) = _logic.delegatecall(_data);\\n            require(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal override view returns (address impl) {\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the proxy to a new implementation.\\n     * \\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableProxy: new implementation is not a contract\\\");\\n\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrade_proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n * \\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n * \\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     * \\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal virtual view returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     * \\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () payable external {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () payable external {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     * \\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subsidyFactor\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_userProxy\",\"type\":\"address\"},{\"internalType\":\"contract ISpender\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"contract IPermanentStorage\",\"name\":\"_permStorage\",\"type\":\"address\"},{\"internalType\":\"contract IWETH\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"AllowTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethBalance\",\"type\":\"uint256\"}],\"name\":\"DepositETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"DisallowTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSubisdyFactor\",\"type\":\"uint256\"}],\"name\":\"SetSubsidyFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"source\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"settleAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"feeFactor\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"subsidyFactor\",\"type\":\"uint16\"}],\"indexed\":false,\"internalType\":\"struct AMMWrapper.TxMetaData\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"makerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"receiverAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct AMMLibEIP712.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"source\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"takerAssetAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"makerAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"makerAssetAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiverAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"settleAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"feeFactor\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"subsidyFactor\",\"type\":\"uint16\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSpender\",\"type\":\"address\"}],\"name\":\"UpgradeSpender\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EIP191_HEADER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUSHISWAP_ROUTER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRADE_WITH_PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V2_ROUTER_02_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V3_ROUTER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenList\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"closeAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permStorage\",\"outputs\":[{\"internalType\":\"contract IPermanentStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenList\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"setAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subsidyFactor\",\"type\":\"uint256\"}],\"name\":\"setSubsidyFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spender\",\"outputs\":[{\"internalType\":\"contract ISpender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subsidyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_makerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_takerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_makerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeFactor\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_receiverAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"makerAssetAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"receiverAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct AMMLibEIP712.Order\",\"name\":\"_order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_feeFactor\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_makerSpecificData\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSpender\",\"type\":\"address\"}],\"name\":\"upgradeSpender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"AMMWrapperWithPath","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000009afc226dc049b99342ad6774eeb08bfa2f874465000000000000000000000000000000000000000000000000000000000000001400000000000000000000000003f34be1bf910116595db1b11e9d1b2ca5d596590000000000000000000000003c68dfc45dc92c9c605d92b49858073e10b857a60000000000000000000000006d9cc14a1d36e6ff13fc6efa9e9326fcd12e7903000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}