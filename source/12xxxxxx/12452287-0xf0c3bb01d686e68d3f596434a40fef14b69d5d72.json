{"status":"1","message":"OK","result":[{"SourceCode":"{\"ChangeNowMasterPayinV5.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.8.0;\\n\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./PreparedPayinV5.sol\\u0027;\\n\\ncontract ChangeNowMasterPayinV5 {\\n    address public owner;\\n    address public successor = address(0);\\n    uint256 public payins = 0;\\n\\n    bytes constant payinBytecode = type(PreparedPayinV5).creationCode;\\n    bytes32 constant payinBytecodeHash = keccak256(payinBytecode);\\n\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n\\n    /**\\n     * @notice Checks that caller is owner.\\n     */\\n    modifier isOwner() {\\n        require(msg.sender == owner, \\\"Caller is not owner\\\");\\n        _;\\n    }\\n\\n\\n    /**\\n     * @notice Checks that caller is successor.\\n     */\\n    modifier isSuccessor() {\\n        require(msg.sender == successor, \\\"Caller is not successor\\\");\\n        _;\\n    }\\n\\n\\n    /**\\n     * @notice Sets new successor (only owner).\\n     */\\n    function setSuccessor(address newSuccessor) external isOwner {\\n        successor = newSuccessor;\\n    }\\n\\n\\n    /**\\n     * @notice Takes ownership (only successor).\\n     */\\n    function takeOwnership() external isSuccessor {\\n        owner = successor;\\n        successor = address(0);\\n    }\\n\\n\\n    /**\\n     * @notice Converts payin index into subcontract address. Indexing starts from 0.\\n     *\\n     * @param {uint256} index - the payin index.\\n     *\\n     * @return {address} the corresponding payin subcontract address.\\n     */\\n    function payinAddress(uint256 index)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(uint256(keccak256(abi.encodePacked(\\n            hex\\u0027ff\\u0027,\\n            address(this),\\n            bytes32(index),\\n            payinBytecodeHash\\n        ))));\\n    }\\n\\n    /**\\n     * @notice Helper function to call payin contract in non-standard way\\n     * (place selector and following args after token address)\\n     *\\n     */\\n    function _payin_withdrawERC20(address token, address payin, address toAddress, uint256 amount)\\n        internal\\n    {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, 0x80))\\n\\n            mstore(ptr, shl(224, 0xa9059cbb)) // \\\"transfer(address,uint256)\\\" [ERC20 method]\\n            mstore(add(ptr, 0x4), toAddress)  // 1st arg\\n            mstore(add(ptr, 0x24), amount)    // 2nd arg\\n            mstore(add(ptr, 0x44), token)     // (token address)\\n\\n            let result := call(gas(), payin, 0, ptr, 0x64, 0, 0)\\n\\n            if iszero(result) { revert(0, 0) }\\n        }\\n    }\\n\\n    /**\\n     * @notice Generates next batch of payin subcontracts, up to maxCount\\n     * (as much as enough gas left), but not less than minCount (be sure you\\n     * have enough gas to covert the minimum).\\n     *\\n     * @param {uint256} minCount - the minimum payins count to generate.\\n     * @param {uint256} maxCount - the maximum payins count to generate.\\n     *\\n     * @return {uint256,uint256} - the tuple (fromIndex, count) of:\\n     * lowest payin index of generated batch and the batch size.\\n     *\\n     * NOTE: the function is not restricted by the isOwner modifier\\n     *       since there is nothing to protect: the subcontracts are owned\\n     *       by the factory (this contract) and this one is owned by the\\n     *       owner, anyone can spend gas to help us to generate the pool.\\n     */\\n    function generateNextBatch(uint256 minCount, uint256 maxCount)\\n        external\\n        returns (uint256, uint256)\\n    {\\n        require(minCount \\u003e 0, \\u0027assert: minCount \\u003e 0\\u0027);\\n        require(maxCount \\u003e= minCount, \\u0027assert: maxCount \\u003e minCount\\u0027);\\n\\n        uint256 fromIndex = payins;\\n        uint256 calcSinceIndex = fromIndex + minCount;\\n        uint256 toIndex = fromIndex + maxCount;\\n        uint256 totalGasUsed = 0;\\n\\n        uint256 index = fromIndex;\\n\\n        bytes memory bytecode = payinBytecode;\\n\\n        while (index \\u003c toIndex) {\\n            if (index \\u003e= calcSinceIndex) {\\n                uint256 avgGas = (totalGasUsed / (index - fromIndex));\\n\\n                // is there enough gas left (with extra 5k) to generate next?\\n                if (gasleft() \\u003c (avgGas + 5000)) {\\n                    break;\\n                }\\n            }\\n\\n            uint256 gasBefore = gasleft();\\n\\n            // create payin subcontract\\n            bytes32 salt = bytes32(index);\\n            address payin;\\n            assembly {\\n                payin := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n            }\\n\\n            totalGasUsed += gasBefore - gasleft();\\n            index++;\\n        }\\n\\n        // save new generated payins count\\n        payins = index;\\n\\n        // return (idx, count)\\n        return (fromIndex, index - fromIndex);\\n    }\\n\\n    /**\\n     * @notice Harvests (withdraw whole balance) ERC20 tokens from batch of payins.\\n     *\\n     * @param {address} token - the ERC20 token address to harvest for.\\n     * @param {uint256} fromIndex - the lowest index of payin of batch to harvest from.\\n     * @param {uint256} count - the count of payins (batch size) to harvest from.\\n     * @param {address} toAddress - the destination address to send harvested tokens to.\\n     *\\n     * @return {uint256} totalAmount - the total harvested amount.\\n     */\\n    function harvestERC20Batch(address token, uint256 fromIndex, uint256 count, address toAddress)\\n        external\\n        isOwner\\n        returns (uint256)\\n    {\\n        require(toAddress != address(this), \\u0027toAddress is this\\u0027);\\n        require(toAddress != address(0), \\u0027toAddress is zero\\u0027);\\n\\n        uint256 toIndex = fromIndex + count;\\n        uint256 totalAmount = 0;\\n\\n        require(toIndex \\u003c= payins, \\u0027not enough payins\\u0027);\\n\\n        // send from payins (batch)\\n        while (fromIndex \\u003c toIndex) {\\n            address payin = payinAddress(fromIndex);\\n            uint256 amount = IERC20(token).balanceOf(payin);\\n\\n            if (amount \\u003e 0) {\\n                _payin_withdrawERC20(token, payin, toAddress, amount);\\n                totalAmount += amount;\\n            }\\n\\n            fromIndex++;\\n        }\\n\\n        return totalAmount;\\n    }\\n\\n\\n    /**\\n     * @notice Harvests (withdraw whole balance) ERC20 tokens from batch of payins.\\n     *\\n     * @param {address} token - the ERC20 token address to harvest for.\\n     * @param {address[]} batch - the batch of addresses to harvest from.\\n     * @param {address} toAddress - the destination address to send harvested tokens to.\\n     *\\n     * @return {uint256} totalAmount - the total harvested amount.\\n     */\\n    function harvestERC20BatchFor(address token, address[] calldata batch, address toAddress)\\n    external isOwner returns (uint256)\\n    {\\n        require(toAddress != address(this), \\u0027toAddress is this\\u0027);\\n        require(toAddress != address(0), \\u0027toAddress is zero\\u0027);\\n\\n        uint256 totalAmount = 0;\\n\\n        // send from given payins (batch)\\n        for (uint256 i = 0; i \\u003c batch.length; i++) {\\n            address payin = batch[i];\\n            uint256 amount = IERC20(token).balanceOf(payin);\\n\\n            if (amount \\u003e 0) {\\n                _payin_withdrawERC20(token, payin, toAddress, amount);\\n                totalAmount += amount;\\n            }\\n        }\\n\\n        return totalAmount;\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.8.0;\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address owner) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\\n\"},\"PreparedPayinV5.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.8.0;\\n\\ncontract PreparedPayinV5 {\\n    address private factory;\\n\\n    constructor() {\\n        factory = msg.sender;\\n    }\\n\\n    fallback() external {\\n        require(msg.sender == factory);\\n\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, 0x64)\\n\\n            let result := call(\\n                gas(),\\n                mload(add(ptr, 0x44)),\\n                0,\\n                ptr,\\n                0x44,\\n                0,\\n                0\\n            )\\n\\n            if iszero(result) { revert(0, 0) }\\n        }\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCount\",\"type\":\"uint256\"}],\"name\":\"generateNextBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"harvestERC20Batch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"batch\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"harvestERC20BatchFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"payinAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSuccessor\",\"type\":\"address\"}],\"name\":\"setSuccessor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"successor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ChangeNowMasterPayinV5","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e2baf1462a9d0a02df3fe8b013a93decf3ee8593c239c0581261235283c934d4"}]}