{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.2;\r\n\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\nstruct BassetPersonal {\r\n    // Address of the bAsset\r\n    address addr;\r\n    // Address of the bAsset\r\n    address integrator;\r\n    // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\r\n    bool hasTxFee; // takes a byte in storage\r\n    // Status of the bAsset\r\n    BassetStatus status;\r\n}\r\n\r\nstruct BassetData {\r\n    // 1 Basset * ratio / ratioScale == x Masset (relative value)\r\n    // If ratio == 10e8 then 1 bAsset = 10 mAssets\r\n    // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\r\n    uint128 ratio;\r\n    // Amount of the Basset that is held in Collateral\r\n    uint128 vaultBalance;\r\n}\r\n\r\n// Status of the Basset - has it broken its peg?\r\nenum BassetStatus {\r\n    Default,\r\n    Normal,\r\n    BrokenBelowPeg,\r\n    BrokenAbovePeg,\r\n    Blacklisted,\r\n    Liquidating,\r\n    Liquidated,\r\n    Failed\r\n}\r\n\r\nstruct BasketState {\r\n    bool undergoingRecol;\r\n    bool failed;\r\n}\r\n\r\nstruct InvariantConfig {\r\n    uint256 a;\r\n    WeightLimits limits;\r\n}\r\n\r\nstruct WeightLimits {\r\n    uint128 min;\r\n    uint128 max;\r\n}\r\n\r\nstruct FeederConfig {\r\n    uint256 supply;\r\n    uint256 a;\r\n    WeightLimits limits;\r\n}\r\n\r\nstruct AmpData {\r\n    uint64 initialA;\r\n    uint64 targetA;\r\n    uint64 rampStartTime;\r\n    uint64 rampEndTime;\r\n}\r\n\r\nstruct FeederData {\r\n    uint256 swapFee;\r\n    uint256 redemptionFee;\r\n    uint256 govFee;\r\n    uint256 pendingFees;\r\n    uint256 cacheSize;\r\n    BassetPersonal[] bAssetPersonal;\r\n    BassetData[] bAssetData;\r\n    AmpData ampData;\r\n    WeightLimits weightLimits;\r\n}\r\n\r\nstruct AssetData {\r\n    uint8 idx;\r\n    uint256 amt;\r\n    BassetPersonal personal;\r\n}\r\n\r\nstruct Asset {\r\n    uint8 idx;\r\n    address addr;\r\n    bool exists;\r\n}\r\n\r\nabstract contract IFeederPool {\r\n    // Mint\r\n    function mint(\r\n        address _input,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mintOutput);\r\n\r\n    function mintMulti(\r\n        address[] calldata _inputs,\r\n        uint256[] calldata _inputQuantities,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mintOutput);\r\n\r\n    function getMintOutput(address _input, uint256 _inputQuantity)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 mintOutput);\r\n\r\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 mintOutput);\r\n\r\n    // Swaps\r\n    function swap(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 swapOutput);\r\n\r\n    function getSwapOutput(\r\n        address _input,\r\n        address _output,\r\n        uint256 _inputQuantity\r\n    ) external view virtual returns (uint256 swapOutput);\r\n\r\n    // Redemption\r\n    function redeem(\r\n        address _output,\r\n        uint256 _mAssetQuantity,\r\n        uint256 _minOutputQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 outputQuantity);\r\n\r\n    function redeemProportionately(\r\n        uint256 _mAssetQuantity,\r\n        uint256[] calldata _minOutputQuantities,\r\n        address _recipient\r\n    ) external virtual returns (uint256[] memory outputQuantities);\r\n\r\n    function redeemExactBassets(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities,\r\n        uint256 _maxMassetQuantity,\r\n        address _recipient\r\n    ) external virtual returns (uint256 mAssetRedeemed);\r\n\r\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 bAssetOutput);\r\n\r\n    function getRedeemExactBassetsOutput(\r\n        address[] calldata _outputs,\r\n        uint256[] calldata _outputQuantities\r\n    ) external view virtual returns (uint256 mAssetAmount);\r\n\r\n    // Views\r\n    function getPrice() public view virtual returns (uint256 price, uint256 k);\r\n\r\n    function getConfig() external view virtual returns (FeederConfig memory config);\r\n\r\n    function getBasset(address _token)\r\n        external\r\n        view\r\n        virtual\r\n        returns (BassetPersonal memory personal, BassetData memory data);\r\n\r\n    function getBassets()\r\n        external\r\n        view\r\n        virtual\r\n        returns (BassetPersonal[] memory personal, BassetData[] memory data);\r\n\r\n    // SavingsManager\r\n    function collectPlatformInterest()\r\n        external\r\n        virtual\r\n        returns (uint256 mintAmount, uint256 newSupply);\r\n}\r\n\r\ncontract ModuleKeys {\r\n    // Governance\r\n    // ===========\r\n    // keccak256(\"Governance\");\r\n    bytes32 internal constant KEY_GOVERNANCE =\r\n        0x9409903de1e6fd852dfc61c9dacb48196c48535b60e25abf92acc92dd689078d;\r\n    //keccak256(\"Staking\");\r\n    bytes32 internal constant KEY_STAKING =\r\n        0x1df41cd916959d1163dc8f0671a666ea8a3e434c13e40faef527133b5d167034;\r\n    //keccak256(\"ProxyAdmin\");\r\n    bytes32 internal constant KEY_PROXY_ADMIN =\r\n        0x96ed0203eb7e975a4cbcaa23951943fa35c5d8288117d50c12b3d48b0fab48d1;\r\n\r\n    // mStable\r\n    // =======\r\n    // keccak256(\"OracleHub\");\r\n    bytes32 internal constant KEY_ORACLE_HUB =\r\n        0x8ae3a082c61a7379e2280f3356a5131507d9829d222d853bfa7c9fe1200dd040;\r\n    // keccak256(\"Manager\");\r\n    bytes32 internal constant KEY_MANAGER =\r\n        0x6d439300980e333f0256d64be2c9f67e86f4493ce25f82498d6db7f4be3d9e6f;\r\n    //keccak256(\"Recollateraliser\");\r\n    bytes32 internal constant KEY_RECOLLATERALISER =\r\n        0x39e3ed1fc335ce346a8cbe3e64dd525cf22b37f1e2104a755e761c3c1eb4734f;\r\n    //keccak256(\"MetaToken\");\r\n    bytes32 internal constant KEY_META_TOKEN =\r\n        0xea7469b14936af748ee93c53b2fe510b9928edbdccac3963321efca7eb1a57a2;\r\n    // keccak256(\"SavingsManager\");\r\n    bytes32 internal constant KEY_SAVINGS_MANAGER =\r\n        0x12fe936c77a1e196473c4314f3bed8eeac1d757b319abb85bdda70df35511bf1;\r\n    // keccak256(\"Liquidator\");\r\n    bytes32 internal constant KEY_LIQUIDATOR =\r\n        0x1e9cb14d7560734a61fa5ff9273953e971ff3cd9283c03d8346e3264617933d4;\r\n    // keccak256(\"InterestValidator\");\r\n    bytes32 internal constant KEY_INTEREST_VALIDATOR =\r\n        0xc10a28f028c7f7282a03c90608e38a4a646e136e614e4b07d119280c5f7f839f;\r\n}\r\n\r\ninterface INexus {\r\n    function governor() external view returns (address);\r\n\r\n    function getModule(bytes32 key) external view returns (address);\r\n\r\n    function proposeModule(bytes32 _key, address _addr) external;\r\n\r\n    function cancelProposedModule(bytes32 _key) external;\r\n\r\n    function acceptProposedModule(bytes32 _key) external;\r\n\r\n    function acceptProposedModules(bytes32[] calldata _keys) external;\r\n\r\n    function requestLockModule(bytes32 _key) external;\r\n\r\n    function cancelLockModule(bytes32 _key) external;\r\n\r\n    function lockModule(bytes32 _key) external;\r\n}\r\n\r\nabstract contract ImmutableModule is ModuleKeys {\r\n    INexus public immutable nexus;\r\n\r\n    /**\r\n     * @dev Initialization function for upgradable proxy contracts\r\n     * @param _nexus Nexus contract address\r\n     */\r\n    constructor(address _nexus) {\r\n        require(_nexus != address(0), \"Nexus address is zero\");\r\n        nexus = INexus(_nexus);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governor.\r\n     */\r\n    modifier onlyGovernor() {\r\n        _onlyGovernor();\r\n        _;\r\n    }\r\n\r\n    function _onlyGovernor() internal view {\r\n        require(msg.sender == _governor(), \"Only governor can execute\");\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governance.\r\n     *      Governance is either Governor address or Governance address.\r\n     */\r\n    modifier onlyGovernance() {\r\n        require(\r\n            msg.sender == _governor() || msg.sender == _governance(),\r\n            \"Only governance can execute\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the ProxyAdmin.\r\n     */\r\n    modifier onlyProxyAdmin() {\r\n        require(msg.sender == _proxyAdmin(), \"Only ProxyAdmin can execute\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Manager.\r\n     */\r\n    modifier onlyManager() {\r\n        require(msg.sender == _manager(), \"Only manager can execute\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governor address from the Nexus\r\n     * @return Address of Governor Contract\r\n     */\r\n    function _governor() internal view returns (address) {\r\n        return nexus.governor();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governance Module address from the Nexus\r\n     * @return Address of the Governance (Phase 2)\r\n     */\r\n    function _governance() internal view returns (address) {\r\n        return nexus.getModule(KEY_GOVERNANCE);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Staking Module address from the Nexus\r\n     * @return Address of the Staking Module contract\r\n     */\r\n    function _staking() internal view returns (address) {\r\n        return nexus.getModule(KEY_STAKING);\r\n    }\r\n\r\n    /**\r\n     * @dev Return ProxyAdmin Module address from the Nexus\r\n     * @return Address of the ProxyAdmin Module contract\r\n     */\r\n    function _proxyAdmin() internal view returns (address) {\r\n        return nexus.getModule(KEY_PROXY_ADMIN);\r\n    }\r\n\r\n    /**\r\n     * @dev Return MetaToken Module address from the Nexus\r\n     * @return Address of the MetaToken Module contract\r\n     */\r\n    function _metaToken() internal view returns (address) {\r\n        return nexus.getModule(KEY_META_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * @dev Return OracleHub Module address from the Nexus\r\n     * @return Address of the OracleHub Module contract\r\n     */\r\n    function _oracleHub() internal view returns (address) {\r\n        return nexus.getModule(KEY_ORACLE_HUB);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Manager Module address from the Nexus\r\n     * @return Address of the Manager Module contract\r\n     */\r\n    function _manager() internal view returns (address) {\r\n        return nexus.getModule(KEY_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return SavingsManager Module address from the Nexus\r\n     * @return Address of the SavingsManager Module contract\r\n     */\r\n    function _savingsManager() internal view returns (address) {\r\n        return nexus.getModule(KEY_SAVINGS_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Recollateraliser Module address from the Nexus\r\n     * @return  Address of the Recollateraliser Module contract (Phase 2)\r\n     */\r\n    function _recollateraliser() internal view returns (address) {\r\n        return nexus.getModule(KEY_RECOLLATERALISER);\r\n    }\r\n}\r\n\r\nabstract contract PausableModule is ImmutableModule {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by Governor\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by Governor\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool internal _paused = false;\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     * Hooks into the Module to give the Governor ability to pause\r\n     * @param _nexus Nexus contract address\r\n     */\r\n    constructor(address _nexus) ImmutableModule(_nexus) {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     * @return Returns `true` when paused, otherwise `false`\r\n     */\r\n    function paused() external view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the Governor to pause, triggers stopped state.\r\n     */\r\n    function pause() external onlyGovernor whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by Governor to unpause, returns to normal state.\r\n     */\r\n    function unpause() external onlyGovernor whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title   InterestValidator\r\n * @author  mStable\r\n * @notice  Simply validates the platform interest collection from the Feeder Pools. Normally this function\r\n *          is supported by the SavingsManager, which then distributes the inflated tokens to SAVE contracts.\r\n *          However, given that fPools collect value internally, we simply want to provide protections here\r\n *          without actually inflating supply. As such, this code is forked from `savings/SavingsManager.sol`.\r\n * @dev     VERSION: 1.0\r\n *          DATE:    2021-03-01\r\n */\r\ncontract InterestValidator is PausableModule {\r\n    event InterestCollected(\r\n        address indexed feederPool,\r\n        uint256 interest,\r\n        uint256 newTotalSupply,\r\n        uint256 apy\r\n    );\r\n\r\n    // Utils to help keep interest under check\r\n    uint256 private constant SECONDS_IN_YEAR = 365 days;\r\n    // Theoretical cap on APY to avoid excess inflation\r\n    uint256 private constant MAX_APY = 15e18;\r\n\r\n    mapping(address => uint256) public lastBatchCollected;\r\n\r\n    constructor(address _nexus) PausableModule(_nexus) {}\r\n\r\n    /**\r\n     * @notice Collects and validates the interest of n feeder pools.\r\n     * @dev First calls to calculate the interest that has accrued, and then validates the potential inflation\r\n     * with respect to the previous timestamp.\r\n     * @param _feeders     Addresses of the feeder pools on which to accrue interest\r\n     */\r\n    function collectAndValidateInterest(address[] calldata _feeders) external whenNotPaused {\r\n        uint256 currentTime = block.timestamp;\r\n\r\n        uint256 len = _feeders.length;\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            address feeder = _feeders[i];\r\n\r\n            uint256 previousBatch = lastBatchCollected[feeder];\r\n            uint256 timeSincePreviousBatch = currentTime - previousBatch;\r\n            require(timeSincePreviousBatch > 12 hours, \"Cannot collect twice in 12 hours\");\r\n            lastBatchCollected[feeder] = currentTime;\r\n\r\n            // Batch collect\r\n            (uint256 interestCollected, uint256 totalSupply) =\r\n                IFeederPool(feeder).collectPlatformInterest();\r\n\r\n            if (interestCollected > 0) {\r\n                // Validate APY\r\n                uint256 apy =\r\n                    _validateCollection(totalSupply, interestCollected, timeSincePreviousBatch);\r\n\r\n                emit InterestCollected(feeder, interestCollected, totalSupply, apy);\r\n            } else {\r\n                emit InterestCollected(feeder, interestCollected, totalSupply, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Validates that an interest collection does not exceed a maximum APY. If last collection\r\n     * was under 30 mins ago, simply check it does not exceed 10bps\r\n     * @param _newSupply               New total supply of the mAsset\r\n     * @param _interest                Increase in total supply since last collection\r\n     * @param _timeSinceLastCollection Seconds since last collection\r\n     */\r\n    function _validateCollection(\r\n        uint256 _newSupply,\r\n        uint256 _interest,\r\n        uint256 _timeSinceLastCollection\r\n    ) internal pure returns (uint256 extrapolatedAPY) {\r\n        // Percentage increase in total supply\r\n        // e.g. (1e20 * 1e18) / 1e24 = 1e14 (or a 0.01% increase)\r\n        // e.g. (5e18 * 1e18) / 1.2e24 = 4.1667e12\r\n        // e.g. (1e19 * 1e18) / 1e21 = 1e16\r\n        uint256 oldSupply = _newSupply - _interest;\r\n        uint256 percentageIncrease = (_interest * 1e18) / oldSupply;\r\n\r\n        //      If over 30 mins, extrapolate APY\r\n        // e.g. day: (86400 * 1e18) / 3.154e7 = 2.74..e15\r\n        // e.g. 30 mins: (1800 * 1e18) / 3.154e7 = 5.7..e13\r\n        // e.g. epoch: (1593596907 * 1e18) / 3.154e7 = 50.4..e18\r\n        uint256 yearsSinceLastCollection = (_timeSinceLastCollection * 1e18) / SECONDS_IN_YEAR;\r\n\r\n        // e.g. 0.01% (1e14 * 1e18) / 2.74..e15 = 3.65e16 or 3.65% apr\r\n        // e.g. (4.1667e12 * 1e18) / 5.7..e13 = 7.1e16 or 7.1% apr\r\n        // e.g. (1e16 * 1e18) / 50e18 = 2e14\r\n        extrapolatedAPY = (percentageIncrease * 1e18) / yearsSinceLastCollection;\r\n\r\n        require(extrapolatedAPY < MAX_APY, \"Interest protected from inflating past maxAPY\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nexus\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feederPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"}],\"name\":\"InterestCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_feeders\",\"type\":\"address[]\"}],\"name\":\"collectAndValidateInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBatchCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nexus\",\"outputs\":[{\"internalType\":\"contract INexus\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"InterestValidator","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000afce80b19a8ce13dec0739a1aab7a028d6845eb3","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://aad75382e9b5cad45f99f0cbf0233440c332b24da8d05c14c61a0924f8b369e9"}]}