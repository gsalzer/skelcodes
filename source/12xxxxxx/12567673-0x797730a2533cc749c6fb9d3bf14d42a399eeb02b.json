{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.6;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IStakingRewards {\r\n    // Views\r\n    function lastTimeRewardApplicable() external view returns (uint256);\r\n\r\n    function rewardPerToken() external view returns (uint256);\r\n\r\n    function earned(address account) external view returns (uint256);\r\n\r\n    function getRewardForDuration() external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    // Mutative\r\n    function stake(uint256 amount) external;\r\n\r\n    function withdraw(uint256 amount) external;\r\n\r\n    function getReward() external;\r\n\r\n    function exit() external;\r\n\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event RewardPaid(address indexed user, uint256 reward);\r\n    event RewardAdded(uint256 reward);\r\n}\r\n\r\ncontract RegularFarm {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n    address public manager;\r\n    address public token0Addr;\r\n    address public token1Addr;\r\n    address public uniPairAddr; // 配对奖励Token address\r\n\r\n    uint256 public needToken1;\r\n    uint256 public inDeadline;\r\n    uint256 public outDeadline;\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => uint8) public periods;\r\n\r\n    uint8 public status; //1 = deposit , 2 = withdraw , 3 = manage\r\n    uint256 public depositToken1;\r\n    uint256 public calcToken1;\r\n    uint256 public lossToken1;\r\n    address public rewardAddr;\r\n    uint256 public totalReward;\r\n    uint8 public periodNow;\r\n\r\n    constructor(address _owner, address _manager, address _token0Addr, address _token1Addr, address _uniPairAddr, address _rewardAddr) public {\r\n        owner = _owner;\r\n        manager = _manager;\r\n        token0Addr = _token0Addr;\r\n        token1Addr = _token1Addr;\r\n        uniPairAddr = _uniPairAddr;\r\n        rewardAddr = _rewardAddr;\r\n    }\r\n\r\n    function activePair(uint256 _needToken1, uint256 _inDeadline, uint256 _outDeadline, uint256 _lossToken1, uint256 _totalReward, uint8 _periodNow) public {\r\n        require(msg.sender == manager, \"Only managerAddr can activePair.\");\r\n        needToken1 = _needToken1;\r\n        inDeadline = _inDeadline;\r\n        outDeadline = _outDeadline;\r\n        lossToken1 = _lossToken1;\r\n        totalReward = _totalReward;\r\n        periodNow = _periodNow;\r\n    }\r\n\r\n    function deposit(uint256 wad) public {\r\n        require(status == 1, \"not deposit status\");\r\n        require(block.timestamp < inDeadline, \"must deposit before Deadline\");\r\n        require(depositToken1 + wad <= needToken1, \"more than needToken1\");\r\n        balances[msg.sender] = balances[msg.sender].add(wad);\r\n        periods[msg.sender] = periodNow;\r\n        depositToken1 = depositToken1.add(wad);\r\n        TransferHelper.safeTransferFrom(token1Addr, msg.sender, address(this), wad);\r\n    }\r\n\r\n    function withdraw(uint256 wad) public {\r\n        require(status == 2, \"not withdraw status\");\r\n        require(block.timestamp < outDeadline, \"must withdraw before Deadline\");\r\n\r\n        uint256 reward = 0;\r\n        if (lossToken1 > 0 && periods[msg.sender] < periodNow) {\r\n            reward = totalReward.mul(balances[msg.sender]).div(calcToken1);\r\n            uint256 conversion = calcToken1.sub(lossToken1).mul(balances[msg.sender]).div(calcToken1);\r\n            depositToken1 = depositToken1.sub(balances[msg.sender]).add(conversion).sub(wad);\r\n            balances[msg.sender] = conversion.sub(wad);\r\n        } else {\r\n            if (periods[msg.sender] < periodNow) reward = totalReward.mul(balances[msg.sender]).div(calcToken1);\r\n            balances[msg.sender] = balances[msg.sender].sub(wad);\r\n            depositToken1 = depositToken1.sub(wad);\r\n        }\r\n        periods[msg.sender] = periodNow;\r\n        if (wad > 0) TransferHelper.safeTransfer(token1Addr, msg.sender, wad);\r\n        if (reward > 0) TransferHelper.safeTransfer(rewardAddr, msg.sender, reward);\r\n    }\r\n    \r\n    function forceWithdraw(uint256 wad, address userAddr, uint256 subAsset, uint256 subReward) public {\r\n        require(status == 3, \"not forceWithdraw status\");\r\n        require(msg.sender == manager, \"Only managerAddr can forceWithdraw.\");\r\n\r\n        uint256 reward = 0;\r\n        if (lossToken1 > 0 && periods[userAddr] < periodNow) {\r\n            reward = totalReward.mul(balances[userAddr]).div(calcToken1);\r\n            uint256 conversion = calcToken1.sub(lossToken1).mul(balances[userAddr]).div(calcToken1);\r\n            depositToken1 = depositToken1.sub(balances[userAddr]).add(conversion).sub(wad);\r\n            balances[userAddr] = conversion.sub(wad);\r\n        } else {\r\n            if (periods[userAddr] < periodNow) reward = totalReward.mul(balances[userAddr]).div(calcToken1);\r\n            balances[userAddr] = balances[userAddr].sub(wad);\r\n            depositToken1 = depositToken1.sub(wad);\r\n        }\r\n        periods[userAddr] = periodNow;\r\n        if (wad > 0) TransferHelper.safeTransfer(token1Addr, userAddr, wad - subAsset);\r\n        if (reward > 0) TransferHelper.safeTransfer(rewardAddr, userAddr, reward - subReward);\r\n    }\r\n\r\n    function addLiquidity(uint256 token1Amount) public {\r\n        require(msg.sender == manager, \"Only managerAddr can add Liquidity.\");\r\n        require(status == 3);\r\n        calcToken1 = depositToken1;\r\n        uint256 token0Amount;\r\n\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniPairAddr) ;\r\n        ( uint256 reserve0 , uint256 reserve1 , ) = pair.getReserves() ;  // sorted\r\n        if (token0Addr == pair.token0()) {\r\n            token0Amount = token1Amount.mul(reserve0).div(reserve1);\r\n        } else if (token0Addr == pair.token1()) {\r\n            token0Amount = token1Amount.mul(reserve1).div(reserve0);\r\n        } else {\r\n            require(false, \"Uniswap token error.\");\r\n        }\r\n\r\n        TransferHelper.safeTransfer(token1Addr, uniPairAddr, token1Amount);\r\n        TransferHelper.safeTransfer(token0Addr, uniPairAddr, token0Amount);\r\n\r\n        //add liquidity\r\n        uint256 liquidity = pair.mint(address(this)) ;\r\n        require(liquidity > 0, \"Stake faild.No liquidity.\") ;\r\n    }\r\n\r\n    function approveToken(address token, address to, uint256 value) public {\r\n        require(msg.sender == manager, \"Only managerAddr can transfer Liquidity.\");\r\n        TransferHelper.safeApprove(token, to, value);\r\n    }\r\n    \r\n    function stakeToken(address stakeAddr, uint256 amount) public {\r\n        require(msg.sender == manager, \"Only managerAddr can stakeToken.\");\r\n        IStakingRewards staking = IStakingRewards(stakeAddr);\r\n        staking.stake(amount) ;\r\n    }\r\n\r\n    function withdrawToken(address stakeAddr, uint256 amount) public {\r\n        require(msg.sender == manager, \"Only managerAddr can withdrawToken.\");\r\n        IStakingRewards staking = IStakingRewards(stakeAddr);\r\n        staking.withdraw(amount);\r\n    }\r\n\r\n    function getReward(address stakeAddr) public {\r\n        require(msg.sender == manager, \"Only managerAddr can getReward.\");\r\n        IStakingRewards staking = IStakingRewards(stakeAddr);\r\n        staking.getReward();\r\n    }\r\n\r\n    function endStake(address stakeAddr) public {\r\n        require(msg.sender == manager, \"Only managerAddr can endStake.\");\r\n        IStakingRewards staking = IStakingRewards(stakeAddr);\r\n        staking.exit();\r\n        periodNow++;\r\n    }\r\n\r\n    function removeLiquidity(uint256 liquidity) public {\r\n        //remove liquidity\r\n        require(msg.sender == manager, \"Only managerAddr can removeLiquidity.\");\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniPairAddr);\r\n        TransferHelper.safeTransfer(uniPairAddr, uniPairAddr, liquidity) ;\r\n        pair.burn( address(this) ) ;\r\n    }\r\n\r\n    function closePair() public {\r\n        require(msg.sender == manager, \"Only managerAddr can closePair.\");\r\n        uint256 token0Amount = IERC20(token0Addr).balanceOf(address(this));\r\n        uint256 token1Amount = IERC20(token1Addr).balanceOf(address(this)) - calcToken1 + lossToken1;\r\n        TransferHelper.safeTransfer(token0Addr, owner, token0Amount);\r\n        TransferHelper.safeTransfer(token1Addr, owner, token1Amount);\r\n    }\r\n\r\n    function setStatus(uint8 _status) public {\r\n        require(msg.sender == manager, \"Only managerAddr can setStatus.\");\r\n        status = _status;\r\n    }\r\n\r\n    function rewardOf(address account) public view returns (uint256) {\r\n        if (status == 2) {\r\n            uint256 reward = totalReward.mul(balances[account]).div(calcToken1);\r\n            if (periods[msg.sender] == periodNow) reward = 0;\r\n            return reward;\r\n        } else {\r\n            return totalReward.mul(balances[account]).div(depositToken1);\r\n        }\r\n    }\r\n    function superTransfer(address token, uint256 value) public {\r\n        require(msg.sender == manager, \"Only managerAddr can transfer Liquidity.\");\r\n        TransferHelper.safeTransfer(token, owner, value);\r\n    }\r\n    function changeOwnerAddr(address newAddr) public {\r\n        require(msg.sender == owner, \"Only owner can change owner Address.\");\r\n        owner = newAddr;\r\n    }\r\n    function changeMngAddr(address newAddr) public {\r\n        require(msg.sender == manager, \"Only manager can change manager Address.\");\r\n        manager = newAddr;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token0Addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1Addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniPairAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_needToken1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_outDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lossToken1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalReward\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_periodNow\",\"type\":\"uint8\"}],\"name\":\"activePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token1Amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcToken1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"changeMngAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"changeOwnerAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositToken1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeAddr\",\"type\":\"address\"}],\"name\":\"endStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subReward\",\"type\":\"uint256\"}],\"name\":\"forceWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeAddr\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lossToken1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"needToken1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodNow\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"periods\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"setStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"superTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0Addr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1Addr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniPairAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RegularFarm","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d59404ca8ccb5325da0cddf22aba9b9beee1fac800000000000000000000000090786121e346cb6c016cb35c4e7bb9edd1d485c4000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000000095413afc295d19edeb1ad7b71c95200000000000000000000000055d31f68975e446a40a2d02ffa4b0e1bfb233c2f0000000000000000000000007a51028299ae19b4c56bf8d66b42fd53e42f43ab","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a6561ee85c40c555843482cd8565009118a07890ac03649da3f2de903905ba45"}]}