{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Pair {\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function getAmountsOut(address factory, uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface V3Pair {\r\n     function swap(\r\n        address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96,\r\n        bytes calldata data) external returns (int256 amount0, int256 amount1);\r\n}\r\n\r\ninterface IERC20 {\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value );\r\n}\r\n\r\n\r\n \r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'MY ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'MY ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'MY ds-math-mul-overflow');\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"MY SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n}\r\n\r\ncontract scmswp{\r\n    using SafeMath  for uint;\r\n\r\n\taddress payable targetInterface;\r\n\taddress payable uniInterface;\r\n\taddress payable owner;\r\n\taddress private tempToken;\r\n\t\r\n\taddress payable ETHO;\r\n\tmapping(address=>bool) public allowed;\r\n\tuint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private blockTimer;\r\n    uint256 private blok;\r\n    uint256 private Tbal;\r\n    uint256 private Cbal;\r\n\r\n    uint256 private _status;\r\n    \r\n    constructor() public payable {\r\n        owner = msg.sender;\r\n        _status = _NOT_ENTERED;\r\n        blok = block.number;\r\n    }\r\n    \r\n\tmodifier onlyOwner {\r\n\t    require(tx.origin==owner,'not owner');\r\n\t    _;\r\n\t}\r\n\t\r\n\tmodifier NiceTry {\r\n        require(_status != _ENTERED, \"Only Once May You Pass\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\t\r\n\tfunction allow(address _addr) public {\r\n        require(msg.sender==owner, 'Not Yours');\r\n        allowed[_addr]=true;\r\n    }\r\n\t\r\n\tfunction straightUp(address Token, address Token1, address pair, uint toked, uint amount0, uint amount1) public payable NiceTry{\r\n\t    require(ETHO == address(0) ||  blok + blockTimer <= block.number);\r\n\t    targetInterface = payable(Token);\r\n        uniInterface = payable(pair);\r\n        uint256 first = IERC20(targetInterface).balanceOf(address(this));\r\n        require(first.add(toked) > first,\"tokens qty diff\");\r\n        require(IERC20(targetInterface).transferFrom(msg.sender,address(this),toked),\"transferFrom Failed\");\r\n        uint256 second = IERC20(targetInterface).balanceOf(address(this));\r\n        require(first.add(second) == first.add(toked));\r\n        require(IERC20(targetInterface).transfer(address(uniInterface),toked),\"transferFrom Failed\");\r\n\t    IUniswapV2Pair(uniInterface).swap(amount0, amount1, address(this), new bytes(0) );\r\n        uniInterface = address(0);\r\n        targetInterface = address(0);\r\n        uint256 wBal = IERC20(Token1).balanceOf(address(this));\r\n        uint256 Two  = wBal.mul(100).div(50).div(100);    // 2%\r\n        IERC20(Token1).transfer(msg.sender, wBal.sub(Two));\r\n        IERC20(Token1).transfer(owner, Two);\r\n        targetInterface = address(0);\r\n        uniInterface = address(0);\r\n\t}\r\n\t\r\n\tfunction HaveMeCommitted(uint256 Usersell, address UserToken) public NiceTry{\r\n\t    require(ETHO == address(0) || blok + blockTimer <= block.number, \"Not Ready Yet\");\r\n\t    blok = block.number;\r\n\t    blockTimer = 100;  //about 20 minutes\r\n\t    ETHO = payable(tx.origin);\r\n\t    allowed[msg.sender] = true;\r\n\t    tempToken = UserToken;\r\n\t    Tbal = IERC20(tempToken).balanceOf(address(this));\r\n\t    Cbal = Usersell;\r\n\t}\r\n\t\r\n\tfunction CommitedSwapper(address pair, address Token0, address Token1, uint256 AmountPull, bool ZeroOrOne, bool V2, uint160 V3sqrtPriceLimitX96) public NiceTry{\r\n\t    require(ETHO == msg.sender && allowed[msg.sender] && blok + blockTimer > block.number, \"Not time yet\");\r\n\t    targetInterface = payable(Token0);\r\n        uniInterface = payable(pair);\r\n        uint256 second = IERC20(targetInterface).balanceOf(address(this));\r\n        require(second == Tbal.add(Cbal),\"Tokens Balance Mismatch ? token qty\");\r\n        uint256 amount0 = ZeroOrOne ? 0 : AmountPull;\r\n        uint256 amount1 = ZeroOrOne ? AmountPull : 0;\r\n        uint256 send = second.sub(Tbal);\r\n        if(V2){\r\n            IERC20(targetInterface).transfer(address(uniInterface), send );\r\n            IUniswapV2Pair(uniInterface).swap(amount0, amount1, address(this), new bytes(0) );\r\n        }else{\r\n            bytes memory data = abi.encode(send);\r\n            V3Pair(uniInterface).swap(address(this), ZeroOrOne, int256(AmountPull), V3sqrtPriceLimitX96, data);\r\n        }\r\n\t    Cbal = 0;\r\n\t    blockTimer = 0;\r\n\t    blok = block.number;\r\n        ETHO  =  address(0);\r\n        tempToken = address(0);\r\n        uniInterface = address(0);\r\n        targetInterface = address(0);\r\n\t    allowed[msg.sender] = false;\r\n\t    uint256 wBal = IERC20(Token1).balanceOf(address(this)).sub(Tbal);\r\n\t    Tbal = 0;\r\n        uint256 Two  = wBal.mul(100).div(50).div(100);    // 2%\r\n        IERC20(Token1).transfer(msg.sender, wBal.sub(Two));\r\n        IERC20(Token1).transfer(owner, Two);\r\n\t}\r\n\t\r\n\tfunction ViewEtho() public view returns(bool,uint256,bool){\r\n\t    bool ETO = ETHO == address(0);\r\n\t    uint256 BL = blok + blockTimer;\r\n\t    bool TL = block.number > BL;\r\n\t    return(ETO,BL,TL);\r\n\t}\r\n\t\r\n\tfunction uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata data) external {\r\n\t    (uint256 send) = abi.decode(data,(uint256));\r\n        IERC20(targetInterface).transfer(address(uniInterface), send );\r\n\t}\r\n    \r\n    // owner only functions Emergency Recovery\r\n    // and kill code in case contract becomes useless (to recover gass)\r\n    function withdraw() external onlyOwner{\r\n        owner.transfer(address(this).balance);\r\n    }\r\n    \r\n    function TokeMistaken(address _toke, uint amt) external onlyOwner{\r\n        IERC20(_toke).transfer(owner,amt);\r\n    }\r\n    \r\n    function kill(address[] calldata tokes, uint[] calldata qty) external onlyOwner{\r\n        require(tokes.length == qty.length);\r\n        for(uint i = 0; i < tokes.length; i++){\r\n            IERC20(tokes[i]).transfer(owner,qty[i]);\r\n        }\r\n        selfdestruct(owner);\r\n    }\r\n    receive () external payable {}\r\n    fallback () external payable {}\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"AmountPull\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ZeroOrOne\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"V2\",\"type\":\"bool\"},{\"internalType\":\"uint160\",\"name\":\"V3sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"name\":\"CommitedSwapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Usersell\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"UserToken\",\"type\":\"address\"}],\"name\":\"HaveMeCommitted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toke\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"TokeMistaken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ViewEtho\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"allow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokes\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"qty\",\"type\":\"uint256[]\"}],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"straightUp\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"scmswp","CompilerVersion":"v0.6.2+commit.bacdbe57","OptimizationUsed":"1","Runs":"777","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2f795dc353c207fed9051aa055dc0dcc36088e9636d6046d41a48a036b1b0489"}]}