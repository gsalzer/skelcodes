{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n * \r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n * \r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { cs := extcodesize(self) }\r\n        return cs == 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuardUpgradeable is Initializable {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    function __ReentrancyGuard_init() internal initializer {\r\n        __ReentrancyGuard_init_unchained();\r\n    }\r\n\r\n    function __ReentrancyGuard_init_unchained() internal initializer {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    uint256[49] private __gap;\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath128 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        uint128 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint128 a,\r\n        uint128 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint128) {\r\n        require(b <= a, errorMessage);\r\n        uint128 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint128 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint128 a,\r\n        uint128 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint128) {\r\n        require(b > 0, errorMessage);\r\n        uint128 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint128 a,\r\n        uint128 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint128) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface ILXTToken {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function burn(uint256 value) external returns (bool);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @dev Litex will run an auction to incentivise efficiency in coordinators,\r\n * meaning that they need to be very effective and include as many transactions\r\n * as they can in the slots in order to compensate for their bidding costs, gas\r\n * costs and operations costs.The general porpouse of this smartcontract is to\r\n * define the rules to coordinate this auction where the bids will be placed\r\n * only in LXT utility token.\r\n */\r\ninterface ILitexAuctionProtocol {\r\n    /**\r\n     * @notice Getter of the current `_slotDeadline`\r\n     * @return The `_slotDeadline` value\r\n     */\r\n    function getSlotDeadline() external view returns (uint8);\r\n\r\n    /**\r\n     * @notice Allows to change the `_slotDeadline` if it's called by the owner\r\n     * @param newDeadline new `_slotDeadline`\r\n     * Events: `NewSlotDeadline`\r\n     */\r\n    function setSlotDeadline(uint8 newDeadline) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_openAuctionSlots`\r\n     * @return The `_openAuctionSlots` value\r\n     */\r\n    function getOpenAuctionSlots() external view returns (uint16);\r\n\r\n    /**\r\n     * @notice Allows to change the `_openAuctionSlots` if it's called by the owner\r\n     * @dev Max newOpenAuctionSlots = 65536 slots\r\n     * @param newOpenAuctionSlots new `_openAuctionSlots`\r\n     * Events: `NewOpenAuctionSlots`\r\n     * Note: the governance could set this parameter equal to `ClosedAuctionSlots`, this means that it can prevent bids\r\n     * from being made and that only the boot coordinator can forge\r\n     */\r\n    function setOpenAuctionSlots(uint16 newOpenAuctionSlots) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_closedAuctionSlots`\r\n     * @return The `_closedAuctionSlots` value\r\n     */\r\n    function getClosedAuctionSlots() external view returns (uint16);\r\n\r\n    /**\r\n     * @notice Allows to change the `_closedAuctionSlots` if it's called by the owner\r\n     * @dev Max newClosedAuctionSlots = 65536 slots\r\n     * @param newClosedAuctionSlots new `_closedAuctionSlots`\r\n     * Events: `NewClosedAuctionSlots`\r\n     * Note: the governance could set this parameter equal to `OpenAuctionSlots`, this means that it can prevent bids\r\n     * from being made and that only the boot coordinator can forge\r\n     */\r\n    function setClosedAuctionSlots(uint16 newClosedAuctionSlots) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_outbidding`\r\n     * @return The `_outbidding` value\r\n     */\r\n    function getOutbidding() external view returns (uint16);\r\n\r\n    /**\r\n     * @notice Allows to change the `_outbidding` if it's called by the owner\r\n     * @dev newOutbidding between 0.00% and 655.36%\r\n     * @param newOutbidding new `_outbidding`\r\n     * Events: `NewOutbidding`\r\n     */\r\n    function setOutbidding(uint16 newOutbidding) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_allocationRatio`\r\n     * @return The `_allocationRatio` array\r\n     */\r\n    function getAllocationRatio() external view returns (uint16[3] memory);\r\n\r\n    /**\r\n     * @notice Allows to change the `_allocationRatio` array if it's called by the owner\r\n     * @param newAllocationRatio new `_allocationRatio` uint8[3] array\r\n     * Events: `NewAllocationRatio`\r\n     */\r\n    function setAllocationRatio(uint16[3] memory newAllocationRatio) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_donationAddress`\r\n     * @return The `_donationAddress`\r\n     */\r\n    function getDonationAddress() external view returns (address);\r\n\r\n    /**\r\n     * @notice Allows to change the `_donationAddress` if it's called by the owner\r\n     * @param newDonationAddress new `_donationAddress`\r\n     * Events: `NewDonationAddress`\r\n     */\r\n    function setDonationAddress(address newDonationAddress) external;\r\n\r\n    /**\r\n     * @notice Getter of the current `_bootCoordinator`\r\n     * @return The `_bootCoordinator`\r\n     */\r\n    function getBootCoordinator() external view returns (address);\r\n\r\n    /**\r\n     * @notice Allows to change the `_bootCoordinator` if it's called by the owner\r\n     * @param newBootCoordinator new `_bootCoordinator` uint8[3] array\r\n     * Events: `NewBootCoordinator`\r\n     */\r\n    function setBootCoordinator(\r\n        address newBootCoordinator,\r\n        string memory newBootCoordinatorURL\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Allows to change the change the min bid for an slotSet if it's called by the owner.\r\n     * @dev If an slotSet has the value of 0 it's considered decentralized, so the minbid cannot be modified\r\n     * @param slotSet the slotSet to update\r\n     * @param newInitialMinBid the minBid\r\n     * Events: `NewDefaultSlotSetBid`\r\n     */\r\n    function changeDefaultSlotSetBid(uint128 slotSet, uint128 newInitialMinBid)\r\n        external;\r\n\r\n    /**\r\n     * @notice Allows to register a new coordinator\r\n     * @dev The `msg.sender` will be considered the `bidder`, who can change the forger address and the url\r\n     * @param forger the address allowed to forger batches\r\n     * @param coordinatorURL endopoint for this coordinator\r\n     * Events: `NewCoordinator`\r\n     */\r\n    function setCoordinator(address forger, string memory coordinatorURL)\r\n        external;\r\n\r\n    /**\r\n     * @notice Function to process a single bid\r\n     * @dev If the bytes calldata permit parameter is empty the smart contract assume that it has enough allowance to\r\n     * make the transferFrom. In case you want to use permit, you need to send the data of the permit call in bytes\r\n     * @param amount the amount of tokens that have been sent\r\n     * @param slot the slot for which the caller is bidding\r\n     * @param bidAmount the amount of the bidding\r\n     */\r\n    function processBid(\r\n        uint128 amount,\r\n        uint128 slot,\r\n        uint128 bidAmount,\r\n        bytes calldata permit\r\n    ) external;\r\n\r\n    /**\r\n     * @notice function to process a multi bid\r\n     * @dev If the bytes calldata permit parameter is empty the smart contract assume that it has enough allowance to\r\n     * make the transferFrom. In case you want to use permit, you need to send the data of the permit call in bytes\r\n     * @param amount the amount of tokens that have been sent\r\n     * @param startingSlot the first slot to bid\r\n     * @param endingSlot the last slot to bid\r\n     * @param slotSets the set of slots to which the coordinator wants to bid\r\n     * @param maxBid the maximum bid that is allowed\r\n     * @param minBid the minimum that you want to bid\r\n     */\r\n    function processMultiBid(\r\n        uint128 amount,\r\n        uint128 startingSlot,\r\n        uint128 endingSlot,\r\n        bool[6] memory slotSets,\r\n        uint128 maxBid,\r\n        uint128 minBid,\r\n        bytes calldata permit\r\n    ) external;\r\n\r\n    /**\r\n     * @notice function to process the forging\r\n     * @param forger the address of the coodirnator's forger\r\n     * Events: `NewForgeAllocated` and `NewForge`\r\n     */\r\n    function forge(address forger) external;\r\n\r\n    /**\r\n     * @notice function to know if a certain address can forge into a certain block\r\n     * @param forger the address of the coodirnator's forger\r\n     * @param blockNumber block number to check\r\n     * @return a bool true in case it can forge, false otherwise\r\n     */\r\n    function canForge(address forger, uint256 blockNumber)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Litex will run an auction to incentivise efficiency in coordinators,\r\n * meaning that they need to be very effective and include as many transactions\r\n * as they can in the slots in order to compensate for their bidding costs, gas\r\n * costs and operations costs.The general porpouse of this smartcontract is to\r\n * define the rules to coordinate this auction where the bids will be placed\r\n * only in LXT utility token.\r\n */\r\ncontract LitexAuctionProtocol is\r\n    Initializable,\r\n    ReentrancyGuardUpgradeable,\r\n    ILitexAuctionProtocol\r\n{\r\n    using SafeMath128 for uint128;\r\n\r\n    struct Coordinator {\r\n        address forger; // Address allowed by the bidder to forge a batch\r\n        string coordinatorURL;\r\n    }\r\n\r\n    // The closedMinBid is the minimum bidding with which it has been closed a slot and may be\r\n    // higher than the bidAmount. This means that the funds must be returned to whoever has bid\r\n    struct SlotState {\r\n        address bidder;\r\n        bool fulfilled;\r\n        bool forgerCommitment;\r\n        uint128 bidAmount; // Since the total supply of LXT will be less than 100M, with 128 bits it is enough to\r\n        uint128 closedMinBid; // store the bidAmount and closed minBid. bidAmount is the bidding for an specific slot.\r\n    }\r\n\r\n    // bytes4 private constant _PERMIT_SIGNATURE =\r\n    //    bytes4(keccak256(bytes(\"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\")));\r\n    bytes4 private constant _PERMIT_SIGNATURE = 0xd505accf;\r\n\r\n    // Blocks per slot\r\n    uint8 public constant BLOCKS_PER_SLOT = 40;\r\n    // Minimum bid when no one has bid yet\r\n    uint128 public constant INITIAL_MINIMAL_BIDDING = 1000000 * (1e18);\r\n\r\n    // Litex Network Token with which the bids will be made\r\n    ILXTToken public tokenLXT;\r\n    // LitexRollup smartcontract address\r\n    address public litexRollup;\r\n    // Litex Governance smartcontract address who controls some parameters and collects LXT fee\r\n    address public governanceAddress;\r\n    // Boot Donation Address\r\n    address private _donationAddress;\r\n    // Boot Coordinator Address\r\n    address private _bootCoordinator;\r\n    // boot coordinator URL\r\n    string public bootCoordinatorURL;\r\n    // The minimum bid value in a series of 6 slots\r\n    uint128[6] private _defaultSlotSetBid;\r\n    // First block where the first slot begins\r\n    uint128 public genesisBlock;\r\n    // Number of closed slots after the current slot ( 2 Slots = 2 * 40 Blocks = 20 min )\r\n    uint16 private _closedAuctionSlots;\r\n    // Total number of open slots which you can bid ( 30 days = 4320 slots )\r\n    uint16 private _openAuctionSlots;\r\n    // How the LXT tokens deposited by the slot winner are distributed ( Burn: 40.00% - Donation: 40.00% - HGT: 20.00% )\r\n    uint16[3] private _allocationRatio; // Two decimal precision\r\n    // Minimum outbid (percentage, two decimal precision) over the previous one to consider it valid\r\n    uint16 private _outbidding; // Two decimal precision\r\n    // Number of blocks after the beginning of a slot after which any coordinator can forge if the winner has not forged\r\n    // any batch in that slot\r\n    uint8 private _slotDeadline;\r\n\r\n    // Mapping to control slot state\r\n    mapping(uint128 => SlotState) public slots;\r\n    // Mapping to control balances pending to claim\r\n    mapping(address => uint128) public pendingBalances;\r\n    // Mapping to register all the coordinators. The address used for the mapping is the bidder address\r\n    mapping(address => Coordinator) public coordinators;\r\n\r\n    event NewBid(\r\n        uint128 indexed slot,\r\n        uint128 bidAmount,\r\n        address indexed bidder\r\n    );\r\n    event NewSlotDeadline(uint8 newSlotDeadline);\r\n    event NewClosedAuctionSlots(uint16 newClosedAuctionSlots);\r\n    event NewOutbidding(uint16 newOutbidding);\r\n    event NewDonationAddress(address indexed newDonationAddress);\r\n    event NewBootCoordinator(\r\n        address indexed newBootCoordinator,\r\n        string newBootCoordinatorURL\r\n    );\r\n    event NewOpenAuctionSlots(uint16 newOpenAuctionSlots);\r\n    event NewAllocationRatio(uint16[3] newAllocationRatio);\r\n    event SetCoordinator(\r\n        address indexed bidder,\r\n        address indexed forger,\r\n        string coordinatorURL\r\n    );\r\n    event NewForgeAllocated(\r\n        address indexed bidder,\r\n        address indexed forger,\r\n        uint128 indexed slotToForge,\r\n        uint128 burnAmount,\r\n        uint128 donationAmount,\r\n        uint128 governanceAmount\r\n    );\r\n    event NewDefaultSlotSetBid(uint128 slotSet, uint128 newInitialMinBid);\r\n    event NewForge(address indexed forger, uint128 indexed slotToForge);\r\n    event LXTClaimed(address indexed owner, uint128 amount);\r\n\r\n    // Event emitted when the contract is initialized\r\n    event InitializeLitexAuctionProtocolEvent(\r\n        address donationAddress,\r\n        address bootCoordinatorAddress,\r\n        string bootCoordinatorURL,\r\n        uint16 outbidding,\r\n        uint8 slotDeadline,\r\n        uint16 closedAuctionSlots,\r\n        uint16 openAuctionSlots,\r\n        uint16[3] allocationRatio\r\n    );\r\n\r\n    modifier onlyGovernance() {\r\n        require(\r\n            governanceAddress == msg.sender,\r\n            \"LitexAuctionProtocol::onlyGovernance: ONLY_GOVERNANCE\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initializer function (equivalent to the constructor). Since we use\r\n     * upgradeable smartcontracts the state vars have to be initialized here.\r\n     * @param token Litex Network token with which the bids will be made\r\n     * @param litexRollupAddress address authorized to forge\r\n     * @param donationAddress address that can claim donated tokens\r\n     * @param _governanceAddress Litex Governance smartcontract\r\n     * @param bootCoordinatorAddress Boot Coordinator Address\r\n     */\r\n    function litexAuctionProtocolInitializer(\r\n        address token,\r\n        uint128 genesis,\r\n        address litexRollupAddress,\r\n        address _governanceAddress,\r\n        address donationAddress,\r\n        address bootCoordinatorAddress,\r\n        string memory _bootCoordinatorURL\r\n    ) public initializer {\r\n        __ReentrancyGuard_init_unchained();\r\n\r\n        require(\r\n            litexRollupAddress != address(0),\r\n            \"LitexAuctionProtocol::litexAuctionProtocolInitializer ADDRESS_0_NOT_VALID\"\r\n        );\r\n\r\n        _outbidding = 1000;\r\n        _slotDeadline = 20;\r\n        _closedAuctionSlots = 2;\r\n        _openAuctionSlots = 4320;\r\n        _allocationRatio = [4000, 4000, 2000];\r\n        _defaultSlotSetBid = [\r\n            INITIAL_MINIMAL_BIDDING,\r\n            INITIAL_MINIMAL_BIDDING,\r\n            INITIAL_MINIMAL_BIDDING,\r\n            INITIAL_MINIMAL_BIDDING,\r\n            INITIAL_MINIMAL_BIDDING,\r\n            INITIAL_MINIMAL_BIDDING\r\n        ];\r\n\r\n        require(\r\n            genesis >= block.number,\r\n            \"LitexAuctionProtocol::litexAuctionProtocolInitializer GENESIS_BELOW_MINIMAL\"\r\n        );\r\n\r\n        tokenLXT = ILXTToken(token);\r\n\r\n        genesisBlock = genesis;\r\n        litexRollup = litexRollupAddress;\r\n        governanceAddress = _governanceAddress;\r\n        _donationAddress = donationAddress;\r\n        _bootCoordinator = bootCoordinatorAddress;\r\n        bootCoordinatorURL = _bootCoordinatorURL;\r\n\r\n        emit InitializeLitexAuctionProtocolEvent(\r\n            donationAddress,\r\n            bootCoordinatorAddress,\r\n            _bootCoordinatorURL,\r\n            _outbidding,\r\n            _slotDeadline,\r\n            _closedAuctionSlots,\r\n            _openAuctionSlots,\r\n            _allocationRatio\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the current `_slotDeadline`\r\n     * @return The `_slotDeadline` value\r\n     */\r\n    function getSlotDeadline() external override view returns (uint8) {\r\n        return _slotDeadline;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to change the `_slotDeadline` if it's called by the owner\r\n     * @param newDeadline new `_slotDeadline`\r\n     * Events: `NewSlotDeadline`\r\n     */\r\n    function setSlotDeadline(uint8 newDeadline)\r\n        external\r\n        override\r\n        onlyGovernance\r\n    {\r\n        require(\r\n            newDeadline <= BLOCKS_PER_SLOT,\r\n            \"LitexAuctionProtocol::setSlotDeadline: GREATER_THAN_BLOCKS_PER_SLOT\"\r\n        );\r\n        _slotDeadline = newDeadline;\r\n        emit NewSlotDeadline(_slotDeadline);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the current `_openAuctionSlots`\r\n     * @return The `_openAuctionSlots` value\r\n     */\r\n    function getOpenAuctionSlots() external override view returns (uint16) {\r\n        return _openAuctionSlots;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to change the `_openAuctionSlots` if it's called by the owner\r\n     * @dev Max newOpenAuctionSlots = 65536 slots\r\n     * @param newOpenAuctionSlots new `_openAuctionSlots`\r\n     * Events: `NewOpenAuctionSlots`\r\n     * Note: the governance could set this parameter equal to `ClosedAuctionSlots`, this means that it can prevent bids\r\n     * from being made and that only the boot coordinator can forge\r\n     */\r\n    function setOpenAuctionSlots(uint16 newOpenAuctionSlots)\r\n        external\r\n        override\r\n        onlyGovernance\r\n    {\r\n        _openAuctionSlots = newOpenAuctionSlots;\r\n        emit NewOpenAuctionSlots(_openAuctionSlots);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the current `_closedAuctionSlots`\r\n     * @return The `_closedAuctionSlots` value\r\n     */\r\n    function getClosedAuctionSlots() external override view returns (uint16) {\r\n        return _closedAuctionSlots;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to change the `_closedAuctionSlots` if it's called by the owner\r\n     * @dev Max newClosedAuctionSlots = 65536 slots\r\n     * @param newClosedAuctionSlots new `_closedAuctionSlots`\r\n     * Events: `NewClosedAuctionSlots`\r\n     * Note: the governance could set this parameter equal to `OpenAuctionSlots`, this means that it can prevent bids\r\n     * from being made and that only the boot coordinator can forge\r\n     */\r\n    function setClosedAuctionSlots(uint16 newClosedAuctionSlots)\r\n        external\r\n        override\r\n        onlyGovernance\r\n    {\r\n        _closedAuctionSlots = newClosedAuctionSlots;\r\n        emit NewClosedAuctionSlots(_closedAuctionSlots);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the current `_outbidding`\r\n     * @return The `_outbidding` value\r\n     */\r\n    function getOutbidding() external override view returns (uint16) {\r\n        return _outbidding;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to change the `_outbidding` if it's called by the owner\r\n     * @dev newOutbidding between 0.01% and 100.00%\r\n     * @param newOutbidding new `_outbidding`\r\n     * Events: `NewOutbidding`\r\n     */\r\n    function setOutbidding(uint16 newOutbidding)\r\n        external\r\n        override\r\n        onlyGovernance\r\n    {\r\n        require(\r\n            newOutbidding > 1 && newOutbidding < 10000,\r\n            \"LitexAuctionProtocol::setOutbidding: OUTBIDDING_NOT_VALID\"\r\n        );\r\n        _outbidding = newOutbidding;\r\n        emit NewOutbidding(_outbidding);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the current `_allocationRatio`\r\n     * @return The `_allocationRatio` array\r\n     */\r\n    function getAllocationRatio()\r\n        external\r\n        override\r\n        view\r\n        returns (uint16[3] memory)\r\n    {\r\n        return _allocationRatio;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to change the `_allocationRatio` array if it's called by the owner\r\n     * @param newAllocationRatio new `_allocationRatio` uint8[3] array\r\n     * Events: `NewAllocationRatio`\r\n     */\r\n    function setAllocationRatio(uint16[3] memory newAllocationRatio)\r\n        external\r\n        override\r\n        onlyGovernance\r\n    {\r\n        require(\r\n            newAllocationRatio[0] <= 10000 &&\r\n                newAllocationRatio[1] <= 10000 &&\r\n                newAllocationRatio[2] <= 10000 &&\r\n                newAllocationRatio[0] +\r\n                    newAllocationRatio[1] +\r\n                    newAllocationRatio[2] ==\r\n                10000,\r\n            \"LitexAuctionProtocol::setAllocationRatio: ALLOCATION_RATIO_NOT_VALID\"\r\n        );\r\n        _allocationRatio = newAllocationRatio;\r\n        emit NewAllocationRatio(_allocationRatio);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the current `_donationAddress`\r\n     * @return The `_donationAddress`\r\n     */\r\n    function getDonationAddress() external override view returns (address) {\r\n        return _donationAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to change the `_donationAddress` if it's called by the owner\r\n     * @param newDonationAddress new `_donationAddress`\r\n     * Events: `NewDonationAddress`\r\n     */\r\n    function setDonationAddress(address newDonationAddress)\r\n        external\r\n        override\r\n        onlyGovernance\r\n    {\r\n        require(\r\n            newDonationAddress != address(0),\r\n            \"LitexAuctionProtocol::setDonationAddress: NOT_VALID_ADDRESS\"\r\n        );\r\n        _donationAddress = newDonationAddress;\r\n        emit NewDonationAddress(_donationAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the current `_bootCoordinator`\r\n     * @return The `_bootCoordinator`\r\n     */\r\n    function getBootCoordinator() external override view returns (address) {\r\n        return _bootCoordinator;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to change the `_bootCoordinator` if it's called by the owner\r\n     * @param newBootCoordinator new `_bootCoordinator` uint8[3] array\r\n     * Events: `NewBootCoordinator`\r\n     */\r\n    function setBootCoordinator(\r\n        address newBootCoordinator,\r\n        string memory newBootCoordinatorURL\r\n    ) external override onlyGovernance {\r\n        _bootCoordinator = newBootCoordinator;\r\n        bootCoordinatorURL = newBootCoordinatorURL;\r\n        emit NewBootCoordinator(_bootCoordinator, newBootCoordinatorURL);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the minimum default bid for an slotSet\r\n     * @param slotSet to obtain the minimum default bid\r\n     * @return the minimum default bid for an slotSet\r\n     */\r\n    function getDefaultSlotSetBid(uint8 slotSet) public view returns (uint128) {\r\n        return _defaultSlotSetBid[slotSet];\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to change the change the min bid for an slotSet if it's called by the owner.\r\n     * @dev If an slotSet has the value of 0 it's considered decentralized, so the minbid cannot be modified\r\n     * @param slotSet the slotSet to update\r\n     * @param newInitialMinBid the minBid\r\n     * Events: `NewDefaultSlotSetBid`\r\n     */\r\n    function changeDefaultSlotSetBid(uint128 slotSet, uint128 newInitialMinBid)\r\n        external\r\n        override\r\n        onlyGovernance\r\n    {\r\n        require(\r\n            slotSet < _defaultSlotSetBid.length,\r\n            \"LitexAuctionProtocol::changeDefaultSlotSetBid: NOT_VALID_SLOT_SET\"\r\n        );\r\n        require(\r\n            _defaultSlotSetBid[slotSet] != 0,\r\n            \"LitexAuctionProtocol::changeDefaultSlotSetBid: SLOT_DECENTRALIZED\"\r\n        );\r\n\r\n        uint128 current = getCurrentSlotNumber();\r\n        // This prevents closed bids from being modified\r\n        for (uint128 i = current; i <= current + _closedAuctionSlots; i++) {\r\n            // Save the minbid in case it has not been previously set\r\n            if (slots[i].closedMinBid == 0) {\r\n                slots[i].closedMinBid = _defaultSlotSetBid[getSlotSet(i)];\r\n            }\r\n        }\r\n        _defaultSlotSetBid[slotSet] = newInitialMinBid;\r\n        emit NewDefaultSlotSetBid(slotSet, newInitialMinBid);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to register a new coordinator\r\n     * @dev The `msg.sender` will be considered the `bidder`, who can change the forger address and the url\r\n     * @param forger the address allowed to forger batches\r\n     * @param coordinatorURL endopoint for this coordinator\r\n     * Events: `NewCoordinator`\r\n     */\r\n    function setCoordinator(address forger, string memory coordinatorURL)\r\n        external\r\n        override\r\n    {\r\n        require(\r\n            keccak256(abi.encodePacked(coordinatorURL)) !=\r\n                keccak256(abi.encodePacked(\"\")),\r\n            \"LitexAuctionProtocol::setCoordinator: NOT_VALID_URL\"\r\n        );\r\n        coordinators[msg.sender].forger = forger;\r\n        coordinators[msg.sender].coordinatorURL = coordinatorURL;\r\n        emit SetCoordinator(msg.sender, forger, coordinatorURL);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current slot number\r\n     * @return slotNumber an uint128 with the current slot\r\n     */\r\n    function getCurrentSlotNumber() public view returns (uint128) {\r\n        return getSlotNumber(uint128(block.number));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the slot number of a given block\r\n     * @param blockNumber from which to calculate the slot\r\n     * @return slotNumber an uint128 with the slot calculated\r\n     */\r\n    function getSlotNumber(uint128 blockNumber) public view returns (uint128) {\r\n        return\r\n            (blockNumber >= genesisBlock)\r\n                ? ((blockNumber - genesisBlock) / BLOCKS_PER_SLOT)\r\n                : uint128(0);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns an slotSet given an slot\r\n     * @param slot from which to calculate the slotSet\r\n     * @return the slotSet of the slot\r\n     */\r\n    function getSlotSet(uint128 slot) public view returns (uint128) {\r\n        return slot.mod(uint128(_defaultSlotSetBid.length));\r\n    }\r\n\r\n    /**\r\n     * @notice gets the minimum bid that someone has to bid to win the slot for a given slot\r\n     * @dev it will revert in case of trying to obtain the minimum bid for a closed slot\r\n     * @param slot from which to get the minimum bid\r\n     * @return the minimum amount to bid\r\n     */\r\n    function getMinBidBySlot(uint128 slot) public view returns (uint128) {\r\n        require(\r\n            slot > (getCurrentSlotNumber() + _closedAuctionSlots),\r\n            \"LitexAuctionProtocol::getMinBidBySlot: AUCTION_CLOSED\"\r\n        );\r\n        uint128 slotSet = getSlotSet(slot);\r\n        // If the bidAmount for a slot is 0 it means that it has not yet been bid, so the midBid will be the minimum\r\n        // bid for the slot time plus the outbidding set, otherwise it will be the bidAmount plus the outbidding\r\n        return\r\n            (slots[slot].bidAmount == 0)\r\n                ? _defaultSlotSetBid[slotSet].add(\r\n                    _defaultSlotSetBid[slotSet].mul(_outbidding).div(\r\n                        uint128(10000) // two decimal precision\r\n                    )\r\n                )\r\n                : slots[slot].bidAmount.add(\r\n                    slots[slot].bidAmount.mul(_outbidding).div(uint128(10000)) // two decimal precision\r\n                );\r\n    }\r\n\r\n    /**\r\n     * @notice Function to process a single bid\r\n     * @dev If the bytes calldata permit parameter is empty the smart contract assume that it has enough allowance to\r\n     * make the transferFrom. In case you want to use permit, you need to send the data of the permit call in bytes\r\n     * @param amount the amount of tokens that have been sent\r\n     * @param slot the slot for which the caller is bidding\r\n     * @param bidAmount the amount of the bidding\r\n     */\r\n    function processBid(\r\n        uint128 amount,\r\n        uint128 slot,\r\n        uint128 bidAmount,\r\n        bytes calldata permit\r\n    ) external override {\r\n        // To avoid possible mistakes we don't allow anyone to bid without setting a forger\r\n        require(\r\n            coordinators[msg.sender].forger != address(0),\r\n            \"LitexAuctionProtocol::processBid: COORDINATOR_NOT_REGISTERED\"\r\n        );\r\n        require(\r\n            slot > (getCurrentSlotNumber() + _closedAuctionSlots),\r\n            \"LitexAuctionProtocol::processBid: AUCTION_CLOSED\"\r\n        );\r\n        require(\r\n            bidAmount >= getMinBidBySlot(slot),\r\n            \"LitexAuctionProtocol::processBid: BELOW_MINIMUM\"\r\n        );\r\n\r\n        require(\r\n            slot <=\r\n                (getCurrentSlotNumber() +\r\n                    _closedAuctionSlots +\r\n                    _openAuctionSlots),\r\n            \"LitexAuctionProtocol::processBid: AUCTION_NOT_OPEN\"\r\n        );\r\n\r\n        if (permit.length != 0) {\r\n            _permit(amount, permit);\r\n        }\r\n\r\n        require(\r\n            tokenLXT.transferFrom(msg.sender, address(this), amount),\r\n            \"LitexAuctionProtocol::processBid: TOKEN_TRANSFER_FAILED\"\r\n        );\r\n        pendingBalances[msg.sender] = pendingBalances[msg.sender].add(amount);\r\n\r\n        require(\r\n            pendingBalances[msg.sender] >= bidAmount,\r\n            \"LitexAuctionProtocol::processBid: NOT_ENOUGH_BALANCE\"\r\n        );\r\n        _doBid(slot, bidAmount, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice function to process a multi bid\r\n     * @dev If the bytes calldata permit parameter is empty the smart contract assume that it has enough allowance to\r\n     * make the transferFrom. In case you want to use permit, you need to send the data of the permit call in bytes\r\n     * @param amount the amount of tokens that have been sent\r\n     * @param startingSlot the first slot to bid\r\n     * @param endingSlot the last slot to bid\r\n     * @param slotSets the set of slots to which the coordinator wants to bid\r\n     * @param maxBid the maximum bid that is allowed\r\n     * @param minBid the minimum that you want to bid\r\n     */\r\n    function processMultiBid(\r\n        uint128 amount,\r\n        uint128 startingSlot,\r\n        uint128 endingSlot,\r\n        bool[6] memory slotSets,\r\n        uint128 maxBid,\r\n        uint128 minBid,\r\n        bytes calldata permit\r\n    ) external override {\r\n        require(\r\n            startingSlot > (getCurrentSlotNumber() + _closedAuctionSlots),\r\n            \"LitexAuctionProtocol::processMultiBid AUCTION_CLOSED\"\r\n        );\r\n        require(\r\n            endingSlot <=\r\n                (getCurrentSlotNumber() +\r\n                    _closedAuctionSlots +\r\n                    _openAuctionSlots),\r\n            \"LitexAuctionProtocol::processMultiBid AUCTION_NOT_OPEN\"\r\n        );\r\n        require(\r\n            maxBid >= minBid,\r\n            \"LitexAuctionProtocol::processMultiBid MAXBID_GREATER_THAN_MINBID\"\r\n        );\r\n        // To avoid possible mistakes we don't allow anyone to bid without setting a forger\r\n        require(\r\n            coordinators[msg.sender].forger != address(0),\r\n            \"LitexAuctionProtocol::processMultiBid COORDINATOR_NOT_REGISTERED\"\r\n        );\r\n\r\n        if (permit.length != 0) {\r\n            _permit(amount, permit);\r\n        }\r\n\r\n        require(\r\n            tokenLXT.transferFrom(msg.sender, address(this), amount),\r\n            \"LitexAuctionProtocol::processMultiBid: TOKEN_TRANSFER_FAILED\"\r\n        );\r\n        pendingBalances[msg.sender] = pendingBalances[msg.sender].add(amount);\r\n\r\n        uint128 bidAmount;\r\n        for (uint128 slot = startingSlot; slot <= endingSlot; slot++) {\r\n            uint128 minBidBySlot = getMinBidBySlot(slot);\r\n            // In case that the minimum bid is below the desired minimum bid, we will use this lower limit as the bid\r\n            if (minBidBySlot <= minBid) {\r\n                bidAmount = minBid;\r\n                // If the `minBidBySlot` is between the upper (`maxBid`) and lower limit (`minBid`) we will use\r\n                // this value `minBidBySlot` as the bid\r\n            } else if (minBidBySlot > minBid && minBidBySlot <= maxBid) {\r\n                bidAmount = minBidBySlot;\r\n                // if the `minBidBySlot` is higher than the upper limit `maxBid`, we will not bid for this slot\r\n            } else {\r\n                continue;\r\n            }\r\n\r\n            // check if it is a selected slotSet\r\n            if (slotSets[getSlotSet(slot)]) {\r\n                require(\r\n                    pendingBalances[msg.sender] >= bidAmount,\r\n                    \"LitexAuctionProtocol::processMultiBid NOT_ENOUGH_BALANCE\"\r\n                );\r\n                _doBid(slot, bidAmount, msg.sender);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice function to call token permit function\r\n     * @param _amount the quantity that is expected to be allowed\r\n     * @param _permitData the raw data of the call `permit` of the token\r\n     */\r\n    function _permit(uint256 _amount, bytes calldata _permitData) internal {\r\n        bytes4 sig = abi.decode(_permitData, (bytes4));\r\n\r\n        require(\r\n            sig == _PERMIT_SIGNATURE,\r\n            \"LitexAuctionProtocol::_permit: NOT_VALID_CALL\"\r\n        );\r\n        (\r\n            address owner,\r\n            address spender,\r\n            uint256 value,\r\n            uint256 deadline,\r\n            uint8 v,\r\n            bytes32 r,\r\n            bytes32 s\r\n        ) = abi.decode(\r\n            _permitData[4:],\r\n            (address, address, uint256, uint256, uint8, bytes32, bytes32)\r\n        );\r\n        require(\r\n            owner == msg.sender,\r\n            \"LitexAuctionProtocol::_permit: OWNER_NOT_EQUAL_SENDER\"\r\n        );\r\n        require(\r\n            spender == address(this),\r\n            \"LitexAuctionProtocol::_permit: SPENDER_NOT_EQUAL_THIS\"\r\n        );\r\n        require(\r\n            value == _amount,\r\n            \"LitexAuctionProtocol::_permit: WRONG_AMOUNT\"\r\n        );\r\n\r\n        // we call without checking the result, in case it fails and he doesn't have enough balance\r\n        // the following transferFrom should be fail. This prevents DoS attacks from using a signature\r\n        // before the smartcontract call\r\n        /* solhint-disable avoid-low-level-calls avoid-call-value */\r\n        address(tokenLXT).call(\r\n            abi.encodeWithSelector(\r\n                _PERMIT_SIGNATURE,\r\n                owner,\r\n                spender,\r\n                value,\r\n                deadline,\r\n                v,\r\n                r,\r\n                s\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to make the bid\r\n     * @dev will only be called by processBid or processMultiBid\r\n     * @param slot the slot for which the caller is bidding\r\n     * @param bidAmount the amount of the bidding\r\n     * @param bidder the address of the bidder\r\n     * Events: `NewBid`\r\n     */\r\n    function _doBid(\r\n        uint128 slot,\r\n        uint128 bidAmount,\r\n        address bidder\r\n    ) private {\r\n        address prevBidder = slots[slot].bidder;\r\n        uint128 prevBidValue = slots[slot].bidAmount;\r\n        require(\r\n            bidAmount > prevBidValue,\r\n            \"LitexAuctionProtocol::_doBid: BID_MUST_BE_HIGHER\"\r\n        );\r\n\r\n        pendingBalances[bidder] = pendingBalances[bidder].sub(bidAmount);\r\n\r\n        slots[slot].bidder = bidder;\r\n        slots[slot].bidAmount = bidAmount;\r\n\r\n        // If there is a previous bid we must return the LXT tokens\r\n        if (prevBidder != address(0) && prevBidValue != 0) {\r\n            pendingBalances[prevBidder] = pendingBalances[prevBidder].add(\r\n                prevBidValue\r\n            );\r\n        }\r\n        emit NewBid(slot, bidAmount, bidder);\r\n    }\r\n\r\n    /**\r\n     * @notice function to know if a certain address can forge into a certain block\r\n     * @param forger the address of the coodirnator's forger\r\n     * @param blockNumber block number to check\r\n     * @return a bool true in case it can forge, false otherwise\r\n     */\r\n    function canForge(address forger, uint256 blockNumber)\r\n        external\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _canForge(forger, blockNumber);\r\n    }\r\n\r\n    /**\r\n     * @notice function to know if a certain address can forge into a certain block\r\n     * @param forger the address of the coodirnator's forger\r\n     * @param blockNumber block number to check\r\n     * @return a bool true in case it can forge, false otherwise\r\n     */\r\n    function _canForge(address forger, uint256 blockNumber)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(\r\n            blockNumber < 2**128,\r\n            \"LitexAuctionProtocol::canForge WRONG_BLOCKNUMBER\"\r\n        );\r\n        require(\r\n            blockNumber >= genesisBlock,\r\n            \"LitexAuctionProtocol::canForge AUCTION_NOT_STARTED\"\r\n        );\r\n\r\n        uint128 slotToForge = getSlotNumber(uint128(blockNumber));\r\n        // Get the relativeBlock to check if the slotDeadline has been exceeded\r\n        uint128 relativeBlock = uint128(blockNumber).sub(\r\n            (slotToForge.mul(BLOCKS_PER_SLOT)).add(genesisBlock)\r\n        );\r\n        // If the closedMinBid is 0 it means that we have to take as minBid the one that is set for this slot set,\r\n        // otherwise the one that has been saved will be used\r\n        uint128 minBid = (slots[slotToForge].closedMinBid == 0)\r\n            ? _defaultSlotSetBid[getSlotSet(slotToForge)]\r\n            : slots[slotToForge].closedMinBid;\r\n\r\n        // if the relative block has exceeded the slotDeadline and no batch has been forged, anyone can forge\r\n        if (\r\n            !slots[slotToForge].forgerCommitment &&\r\n            (relativeBlock >= _slotDeadline)\r\n        ) {\r\n            return true;\r\n            //if forger bidAmount has exceeded the minBid it can forge\r\n        } else if (\r\n            (coordinators[slots[slotToForge].bidder].forger == forger) &&\r\n            (slots[slotToForge].bidAmount >= minBid)\r\n        ) {\r\n            return true;\r\n            //if it's the boot coordinator and it has not been bid or the bid is below the minimum it can forge\r\n        } else if (\r\n            (_bootCoordinator == forger) &&\r\n            ((slots[slotToForge].bidAmount < minBid) ||\r\n                (slots[slotToForge].bidAmount == 0))\r\n        ) {\r\n            return true;\r\n            // if it is not any of these three cases will not be able to forge\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice function to process the forging\r\n     * @param forger the address of the coodirnator's forger\r\n     * Events: `NewForgeAllocated` and `NewForge`\r\n     */\r\n    function forge(address forger) external override {\r\n        require(\r\n            msg.sender == litexRollup,\r\n            \"LitexAuctionProtocol::forge: ONLY_HERMEZ_ROLLUP\"\r\n        );\r\n        require(\r\n            _canForge(forger, block.number),\r\n            \"LitexAuctionProtocol::forge: CANNOT_FORGE\"\r\n        );\r\n        uint128 slotToForge = getCurrentSlotNumber();\r\n\r\n        if (!slots[slotToForge].forgerCommitment) {\r\n            // Get the relativeBlock to check if the slotDeadline has been exceeded\r\n            uint128 relativeBlock = uint128(block.number).sub(\r\n                (slotToForge.mul(BLOCKS_PER_SLOT)).add(genesisBlock)\r\n            );\r\n            if (relativeBlock < _slotDeadline) {\r\n                slots[slotToForge].forgerCommitment = true;\r\n            }\r\n        }\r\n\r\n        // Default values:** Burn: 40% - Donation: 40% - HGT: 20%\r\n        // Allocated is used to know if we have already distributed the LXT tokens\r\n        if (!slots[slotToForge].fulfilled) {\r\n            slots[slotToForge].fulfilled = true;\r\n\r\n            if (slots[slotToForge].bidAmount != 0) {\r\n                // If the closedMinBid is 0 it means that we have to take as minBid the one that is set for this slot set,\r\n                // otherwise the one that has been saved will be used\r\n                uint128 minBid = (slots[slotToForge].closedMinBid == 0)\r\n                    ? _defaultSlotSetBid[getSlotSet(slotToForge)]\r\n                    : slots[slotToForge].closedMinBid;\r\n\r\n                // If the bootcoordinator is forging and there has been a previous bid that is lower than the slot min bid,\r\n                // we must return the tokens to the bidder and the tokens have not been distributed\r\n                if (slots[slotToForge].bidAmount < minBid) {\r\n                    // We save the minBid that this block has had\r\n                    pendingBalances[slots[slotToForge]\r\n                        .bidder] = pendingBalances[slots[slotToForge].bidder]\r\n                        .add(slots[slotToForge].bidAmount);\r\n                    // In case the winner is forging we have to allocate the tokens according to the desired distribution\r\n                } else {\r\n                    uint128 bidAmount = slots[slotToForge].bidAmount;\r\n                    // calculation of token distribution\r\n\r\n                    uint128 amountToBurn = bidAmount\r\n                        .mul(_allocationRatio[0])\r\n                        .div(uint128(10000)); // Two decimal precision\r\n                    uint128 donationAmount = bidAmount\r\n                        .mul(_allocationRatio[1])\r\n                        .div(uint128(10000)); // Two decimal precision\r\n                    uint128 governanceAmount = bidAmount\r\n                        .mul(_allocationRatio[2])\r\n                        .div(uint128(10000)); // Two decimal precision\r\n\r\n                    // Tokens to burn\r\n                    require(\r\n                        tokenLXT.burn(amountToBurn),\r\n                        \"LitexAuctionProtocol::forge: TOKEN_BURN_FAILED\"\r\n                    );\r\n\r\n                    // Tokens to donate\r\n                    pendingBalances[_donationAddress] = pendingBalances[_donationAddress]\r\n                        .add(donationAmount);\r\n                    // Tokens for the governace address\r\n                    pendingBalances[governanceAddress] = pendingBalances[governanceAddress]\r\n                        .add(governanceAmount);\r\n\r\n                    emit NewForgeAllocated(\r\n                        slots[slotToForge].bidder,\r\n                        forger,\r\n                        slotToForge,\r\n                        amountToBurn,\r\n                        donationAmount,\r\n                        governanceAmount\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        emit NewForge(forger, slotToForge);\r\n    }\r\n\r\n    function claimPendingLXT(uint128 slot) public {\r\n        require(\r\n            slot < getCurrentSlotNumber(),\r\n            \"LitexAuctionProtocol::claimPendingLXT: ONLY_IF_PREVIOUS_SLOT\"\r\n        );\r\n        require(\r\n            !slots[slot].fulfilled,\r\n            \"LitexAuctionProtocol::claimPendingLXT: ONLY_IF_NOT_FULFILLED\"\r\n        );\r\n        // If the closedMinBid is 0 it means that we have to take as minBid the one that is set for this slot set,\r\n        // otherwise the one that has been saved will be used\r\n        uint128 minBid = (slots[slot].closedMinBid == 0)\r\n            ? _defaultSlotSetBid[getSlotSet(slot)]\r\n            : slots[slot].closedMinBid;\r\n\r\n        require(\r\n            slots[slot].bidAmount < minBid,\r\n            \"LitexAuctionProtocol::claimPendingLXT: ONLY_IF_NOT_FULFILLED\"\r\n        );\r\n\r\n        slots[slot].closedMinBid = minBid;\r\n        slots[slot].fulfilled = true;\r\n\r\n        pendingBalances[slots[slot].bidder] = pendingBalances[slots[slot]\r\n            .bidder]\r\n            .add(slots[slot].bidAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice function to know how much LXT tokens are pending to be claimed for an address\r\n     * @param bidder address to query\r\n     * @return the total claimable LXT by an address\r\n     */\r\n    function getClaimableLXT(address bidder) public view returns (uint128) {\r\n        return pendingBalances[bidder];\r\n    }\r\n\r\n    /**\r\n     * @notice distributes the tokens to msg.sender address\r\n     * Events: `LXTClaimed`\r\n     */\r\n    function claimLXT() public nonReentrant {\r\n        uint128 pending = getClaimableLXT(msg.sender);\r\n        require(\r\n            pending > 0,\r\n            \"LitexAuctionProtocol::claimLXT: NOT_ENOUGH_BALANCE\"\r\n        );\r\n        pendingBalances[msg.sender] = 0;\r\n        require(\r\n            tokenLXT.transfer(msg.sender, pending),\r\n            \"LitexAuctionProtocol::claimLXT: TOKEN_TRANSFER_FAILED\"\r\n        );\r\n        emit LXTClaimed(msg.sender, pending);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"donationAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bootCoordinatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"bootCoordinatorURL\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"outbidding\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"slotDeadline\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"closedAuctionSlots\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"openAuctionSlots\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16[3]\",\"name\":\"allocationRatio\",\"type\":\"uint16[3]\"}],\"name\":\"InitializeLitexAuctionProtocolEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"LXTClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16[3]\",\"name\":\"newAllocationRatio\",\"type\":\"uint16[3]\"}],\"name\":\"NewAllocationRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"slot\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"bidAmount\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"NewBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBootCoordinator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newBootCoordinatorURL\",\"type\":\"string\"}],\"name\":\"NewBootCoordinator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newClosedAuctionSlots\",\"type\":\"uint16\"}],\"name\":\"NewClosedAuctionSlots\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"slotSet\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newInitialMinBid\",\"type\":\"uint128\"}],\"name\":\"NewDefaultSlotSetBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDonationAddress\",\"type\":\"address\"}],\"name\":\"NewDonationAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"forger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"slotToForge\",\"type\":\"uint128\"}],\"name\":\"NewForge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"forger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"slotToForge\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"burnAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"donationAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"governanceAmount\",\"type\":\"uint128\"}],\"name\":\"NewForgeAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newOpenAuctionSlots\",\"type\":\"uint16\"}],\"name\":\"NewOpenAuctionSlots\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newOutbidding\",\"type\":\"uint16\"}],\"name\":\"NewOutbidding\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newSlotDeadline\",\"type\":\"uint8\"}],\"name\":\"NewSlotDeadline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"forger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"coordinatorURL\",\"type\":\"string\"}],\"name\":\"SetCoordinator\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BLOCKS_PER_SLOT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_MINIMAL_BIDDING\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bootCoordinatorURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"canForge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"slotSet\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"newInitialMinBid\",\"type\":\"uint128\"}],\"name\":\"changeDefaultSlotSetBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLXT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"slot\",\"type\":\"uint128\"}],\"name\":\"claimPendingLXT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"coordinators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"forger\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"coordinatorURL\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forger\",\"type\":\"address\"}],\"name\":\"forge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisBlock\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllocationRatio\",\"outputs\":[{\"internalType\":\"uint16[3]\",\"name\":\"\",\"type\":\"uint16[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBootCoordinator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"getClaimableLXT\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClosedAuctionSlots\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSlotNumber\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slotSet\",\"type\":\"uint8\"}],\"name\":\"getDefaultSlotSetBid\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDonationAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"slot\",\"type\":\"uint128\"}],\"name\":\"getMinBidBySlot\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenAuctionSlots\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOutbidding\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSlotDeadline\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"blockNumber\",\"type\":\"uint128\"}],\"name\":\"getSlotNumber\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"slot\",\"type\":\"uint128\"}],\"name\":\"getSlotSet\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"genesis\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"litexRollupAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governanceAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"donationAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bootCoordinatorAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_bootCoordinatorURL\",\"type\":\"string\"}],\"name\":\"litexAuctionProtocolInitializer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"litexRollup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingBalances\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"slot\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"bidAmount\",\"type\":\"uint128\"},{\"internalType\":\"bytes\",\"name\":\"permit\",\"type\":\"bytes\"}],\"name\":\"processBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"startingSlot\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endingSlot\",\"type\":\"uint128\"},{\"internalType\":\"bool[6]\",\"name\":\"slotSets\",\"type\":\"bool[6]\"},{\"internalType\":\"uint128\",\"name\":\"maxBid\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minBid\",\"type\":\"uint128\"},{\"internalType\":\"bytes\",\"name\":\"permit\",\"type\":\"bytes\"}],\"name\":\"processMultiBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[3]\",\"name\":\"newAllocationRatio\",\"type\":\"uint16[3]\"}],\"name\":\"setAllocationRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBootCoordinator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"newBootCoordinatorURL\",\"type\":\"string\"}],\"name\":\"setBootCoordinator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newClosedAuctionSlots\",\"type\":\"uint16\"}],\"name\":\"setClosedAuctionSlots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forger\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"coordinatorURL\",\"type\":\"string\"}],\"name\":\"setCoordinator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDonationAddress\",\"type\":\"address\"}],\"name\":\"setDonationAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newOpenAuctionSlots\",\"type\":\"uint16\"}],\"name\":\"setOpenAuctionSlots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newOutbidding\",\"type\":\"uint16\"}],\"name\":\"setOutbidding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newDeadline\",\"type\":\"uint8\"}],\"name\":\"setSlotDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"slots\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"forgerCommitment\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"bidAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"closedMinBid\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenLXT\",\"outputs\":[{\"internalType\":\"contract ILXTToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LitexAuctionProtocol","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c8416a678f1469e924bc47866f18c7ba87d80c31a6066c76ae7c96bebb48394a"}]}