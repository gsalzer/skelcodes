{"status":"1","message":"OK","result":[{"SourceCode":"{\"AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n\\r\\n  function decimals() external view returns (uint8);\\r\\n  function description() external view returns (string memory);\\r\\n  function version() external view returns (uint256);\\r\\n\\r\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\r\\n  // if they do not have data to report, instead of returning unset values\\r\\n  // which could be misinterpreted as actual reported values.\\r\\n  function getRoundData(uint80 _roundId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      uint256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      uint256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n}\"},\"Babylonian.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n// computes square roots using the babylonian method\\r\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\r\\nlibrary Babylonian {\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y \\u003e 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x \\u003c z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n        // else z = 0\\r\\n    }\\r\\n}\\r\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () internal { }\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"},\"FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\nimport \\u0027./Babylonian.sol\\u0027;\\r\\n\\r\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\r\\nlibrary FixedPoint {\\r\\n    // range: [0, 2**112 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq112x112 {\\r\\n        uint224 _x;\\r\\n    }\\r\\n\\r\\n    // range: [0, 2**144 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq144x112 {\\r\\n        uint _x;\\r\\n    }\\r\\n\\r\\n    uint8 private constant RESOLUTION = 112;\\r\\n    uint private constant Q112 = uint(1) \\u003c\\u003c RESOLUTION;\\r\\n    uint private constant Q224 = Q112 \\u003c\\u003c RESOLUTION;\\r\\n\\r\\n    // encode a uint112 as a UQ112x112\\r\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\r\\n        return uq112x112(uint224(x) \\u003c\\u003c RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // encodes a uint144 as a UQ144x112\\r\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\r\\n        return uq144x112(uint256(x) \\u003c\\u003c RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\r\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\r\\n        require(x != 0, \\u0027FixedPoint: DIV_BY_ZERO\\u0027);\\r\\n        return uq112x112(self._x / uint224(x));\\r\\n    }\\r\\n\\r\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\r\\n    // reverts on overflow\\r\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\r\\n        uint z;\\r\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\r\\n        return uq144x112(z);\\r\\n    }\\r\\n\\r\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\r\\n    // equivalent to encode(numerator).div(denominator)\\r\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\r\\n        require(denominator \\u003e 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\r\\n        return uq112x112((uint224(numerator) \\u003c\\u003c RESOLUTION) / denominator);\\r\\n    }\\r\\n\\r\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\r\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\r\\n        return uint112(self._x \\u003e\\u003e RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\r\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\r\\n        return uint144(self._x \\u003e\\u003e RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // take the reciprocal of a UQ112x112\\r\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        require(self._x != 0, \\u0027FixedPoint: ZERO_RECIPROCAL\\u0027);\\r\\n        return uq112x112(uint224(Q224 / self._x));\\r\\n    }\\r\\n\\r\\n    // square root of a UQ112x112\\r\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) \\u003c\\u003c 56));\\r\\n    }\\r\\n}\\r\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"IUniswapV2Pair.sol\":{\"content\":\"pragma solidity ^0.6.0;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\"},\"IXAUToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\ninterface IXAUToken {\\r\\n\\r\\n    // EIP20 optional\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    // EIP20\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address who) external view returns(uint256);\\r\\n    function transfer(address to, uint256 value) external returns(bool);\\r\\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\\r\\n    function allowance(address owner_, address spender) external view returns(uint256);\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    // ERC20 non-standard methods to mitigate the well-known issues around setting allowances\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\r\\n\\r\\n    // Rebasing related functionality\\r\\n    event Rebase(uint256 epoch, uint256 oldScalingFactor, uint256 newScalingFactor);\\r\\n    event NewRebaser(address oldRebaser, address newRebaser);\\r\\n    function maxScalingFactor() external view returns (uint256);\\r\\n    function scalingFactor() external view returns (uint256);\\r\\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);  // onlyRebaser\\r\\n    function fromUnderlying(uint256 underlying) external view returns (uint256);\\r\\n    function toUnderlying(uint256 value) external view returns (uint256);\\r\\n    function balanceOfUnderlying(address who) external view returns(uint256);\\r\\n    function rebaser() external view returns (address);\\r\\n    function setRebaser(address _rebaser) external;  // onlyOwner\\r\\n\\r\\n    // Fee on transfer related functionality\\r\\n    event NewTransferHandler(address oldTransferHandler, address newTransferHandler);\\r\\n    event NewFeeDistributor(address oldFeeDistributor, address newFeeDistributor);\\r\\n    function transferHandler() external view returns (address);\\r\\n    function setTransferHandler(address _transferHandler) external;  // onlyOwner\\r\\n    function feeDistributor() external view returns (address);\\r\\n    function setFeeDistributor(address _feeDistributor) external;  // onlyOwner\\r\\n\\r\\n    // Service functionality\\r\\n    function recoverERC20(address token, address to, uint256 amount) external returns (bool);  // onlyOwner\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"},\"Rebaser.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\u0027./IUniswapV2Pair.sol\\u0027;\\r\\nimport \\\"./UniswapV2OracleLibrary.sol\\\";\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IXAUToken.sol\\\";\\r\\nimport \\\"./AggregatorV3Interface.sol\\\";\\r\\n\\r\\n// https://docs.balancer.finance/api/api#gulp\\r\\ninterface BAL {\\r\\n    function gulp(address token) external;\\r\\n}\\r\\n\\r\\ncontract Rebaser is Context, Ownable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    AggregatorV3Interface public targetRateOracle1;\\r\\n    AggregatorV3Interface public targetRateOracle2;\\r\\n    uint256 public targetRateOracleScale;\\r\\n    \\r\\n    struct Transaction {\\r\\n        bool enabled;\\r\\n        address destination;\\r\\n        bytes data;\\r\\n    }\\r\\n\\r\\n    /// @notice an event emitted when a transaction fails\\r\\n    event TransactionFailed(address indexed destination, uint index, bytes data);\\r\\n\\r\\n    /// @notice an event emitted when deviationThreshold is changed\\r\\n    event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\\r\\n\\r\\n    /// @notice an event emitted when maxRebaseRatio is changed\\r\\n    event NewMaxRebaseRatio(uint256 oldMaxRebaseRatio, uint256 newMaxRebaseRatio);\\r\\n\\r\\n    // Stable ordering is not guaranteed.\\r\\n    Transaction[] public transactions;\\r\\n\\r\\n    /// @notice Spreads out getting to the target price\\r\\n    uint256 public rebaseLag;\\r\\n\\r\\n    /// @notice Peg target\\r\\n    uint256 public targetRate;\\r\\n\\r\\n    // If the current exchange rate is within this fractional distance from the target, no supply\\r\\n    // update is performed. Fixed point number--same format as the rate.\\r\\n    // (ie) abs(rate - targetRate) / targetRate \\u003c deviationThreshold, then no supply change.\\r\\n    uint256 public deviationThreshold;\\r\\n\\r\\n    /// @notice Max scalingFactor change ratio per one rebase iteration\\r\\n    uint256 public maxRebaseRatio;\\r\\n\\r\\n    /// @notice More than this much time must pass between rebase operations.\\r\\n    uint256 public minRebaseTimeIntervalSec;\\r\\n\\r\\n    /// @notice Block timestamp of last rebase operation\\r\\n    uint256 public lastRebaseTimestampSec;\\r\\n\\r\\n    /// @notice The rebase window begins this many seconds into the minRebaseTimeInterval period.\\r\\n    // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\\r\\n    uint256 public rebaseWindowOffsetSec;\\r\\n\\r\\n    /// @notice The length of the time window where a rebase operation is allowed to execute, in seconds.\\r\\n    uint256 public rebaseWindowLengthSec;\\r\\n\\r\\n    /// @notice The number of rebase cycles since inception\\r\\n    uint256 public epoch;\\r\\n\\r\\n    // rebasing is not active initially. It can be activated at T+12 hours from\\r\\n    // deployment time\\r\\n    ///@notice boolean showing rebase activation status\\r\\n    bool public rebasingActive;\\r\\n\\r\\n    /// @notice delays rebasing activation to facilitate liquidity\\r\\n    uint256 public rebaseDelay; \\r\\n\\r\\n    /// @notice Time of TWAP initialization\\r\\n    uint256 public timeOfTWAPInit;\\r\\n\\r\\n    /// @notice XAU token address\\r\\n    address public xauToken;\\r\\n\\r\\n    /// @notice reserve token\\r\\n    address public reserveToken;\\r\\n\\r\\n    /// @notice pair for reserveToken \\u003c\\u003e xauToken\\r\\n    address public uniswapPair;\\r\\n\\r\\n    /// @notice list of uniswap pairs to sync\\r\\n    address[] public uniSyncPairs;\\r\\n\\r\\n    /// @notice list of balancer pairs to gulp\\r\\n    address[] public balGulpPairs;\\r\\n\\r\\n    /// @notice last TWAP update time\\r\\n    uint32 public blockTimestampLast;\\r\\n\\r\\n    /// @notice last TWAP cumulative price;\\r\\n    uint256 public priceCumulativeLast;\\r\\n\\r\\n    /// @notice Whether or not this token is first in uniswap YAM\\u003c\\u003eReserve pair\\r\\n    bool public isToken0;\\r\\n\\r\\n    uint256 public constant BASE = 10**18;\\r\\n\\r\\n    constructor(\\r\\n        address xauToken_,\\r\\n        address reserveToken_,\\r\\n        address uniswapPair_,\\r\\n        address targetRateOracle1Address_,\\r\\n        address targetRateOracle2Address_,\\r\\n        uint256 targetRateOracleDecimals_,\\r\\n        uint256 _minRebaseTimeIntervalSec,\\r\\n        uint256 _rebaseWindowOffsetSec,\\r\\n        uint256 _rebaseWindowLengthSec,\\r\\n        uint256 _rebaseDelay\\r\\n    )\\r\\n        public\\r\\n    {\\r\\n          minRebaseTimeIntervalSec = _minRebaseTimeIntervalSec;\\r\\n          rebaseWindowOffsetSec = _rebaseWindowOffsetSec; // 8am/8pm UTC rebases\\r\\n\\r\\n          (address token0, ) = sortTokens(xauToken_, reserveToken_);\\r\\n\\r\\n          targetRateOracle1 = AggregatorV3Interface(targetRateOracle1Address_);\\r\\n          targetRateOracle2 = AggregatorV3Interface(targetRateOracle2Address_);\\r\\n          targetRateOracleScale = 10**targetRateOracleDecimals_;\\r\\n\\r\\n          // used for interacting with uniswap\\r\\n          if (token0 == xauToken_) {\\r\\n              isToken0 = true;\\r\\n          } else {\\r\\n              isToken0 = false;\\r\\n          }\\r\\n\\r\\n          uniswapPair = uniswapPair_;\\r\\n\\r\\n          uniSyncPairs.push(uniswapPair);\\r\\n\\r\\n          xauToken = xauToken_;\\r\\n\\r\\n          // Reserve token is not mutable. Must deploy a new rebaser to update it\\r\\n          reserveToken = reserveToken_;\\r\\n\\r\\n          // 1 YYCRV\\r\\n          targetRate = BASE;\\r\\n\\r\\n          // twice daily rebase, with targeting reaching peg in 5 days\\r\\n          rebaseLag = 5;\\r\\n\\r\\n          // 5%\\r\\n          deviationThreshold = 5 * 10**16;\\r\\n\\r\\n          // 2.0x (we can rebase up to 2.0x or down to 0.5x in one step)\\r\\n          maxRebaseRatio = 2 * 10**18;\\r\\n\\r\\n          // 60 minutes\\r\\n          rebaseWindowLengthSec = _rebaseWindowLengthSec;\\r\\n\\r\\n          // 3 days\\r\\n          rebaseDelay = _rebaseDelay;\\r\\n    }\\r\\n\\r\\n    function removeUniPair(uint256 index) public onlyOwner {\\r\\n        if (index \\u003e= uniSyncPairs.length) return;\\r\\n\\r\\n        uint256 totalUniPairs = uniSyncPairs.length;\\r\\n\\r\\n        for (uint256 i = index; i \\u003c totalUniPairs - 1; i++) {\\r\\n            uniSyncPairs[i] = uniSyncPairs[i + 1];\\r\\n        }\\r\\n        // uniSyncPairs.length--;\\r\\n        delete uniSyncPairs[totalUniPairs.sub(1)];\\r\\n    }\\r\\n\\r\\n    function removeBalPair(uint256 index) public onlyOwner {\\r\\n        if (index \\u003e= balGulpPairs.length) return;\\r\\n\\r\\n        uint256 totalGulpPairs = balGulpPairs.length;\\r\\n\\r\\n        for (uint256 i = index; i \\u003c totalGulpPairs - 1; i++) {\\r\\n            balGulpPairs[i] = balGulpPairs[i + 1];\\r\\n        }\\r\\n        // uniSyncPairs.length--;\\r\\n        delete balGulpPairs[totalGulpPairs.sub(1)];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    @notice Adds pairs to sync\\r\\n    *\\r\\n    */\\r\\n    function addUniSyncPairs(address[] memory uniSyncPairs_)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        for (uint256 i = 0; i \\u003c uniSyncPairs_.length; i++) {\\r\\n            uniSyncPairs.push(uniSyncPairs_[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    @notice Adds pairs to sync\\r\\n    *\\r\\n    */\\r\\n    function addGulpSyncPairs(address[] memory balGulpPairs_)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        for (uint256 i = 0; i \\u003c balGulpPairs_.length; i++) {\\r\\n            balGulpPairs.push(balGulpPairs_[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    @notice Uniswap synced pairs\\r\\n    *\\r\\n    */\\r\\n    function getUniSyncPairs()\\r\\n        public\\r\\n        view\\r\\n        returns (address[] memory)\\r\\n    {\\r\\n        address[] memory pairs = uniSyncPairs;\\r\\n        return pairs;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    @notice Uniswap synced pairs\\r\\n    *\\r\\n    */\\r\\n    function getBalGulpPairs()\\r\\n        public\\r\\n        view\\r\\n        returns (address[] memory)\\r\\n    {\\r\\n        address[] memory pairs = balGulpPairs;\\r\\n        return pairs;\\r\\n    }\\r\\n\\r\\n    /** @notice Initializes TWAP start point, starts countdown to first rebase\\r\\n    *\\r\\n    */\\r\\n    function initTWAP()\\r\\n        public\\r\\n    {\\r\\n        require(timeOfTWAPInit == 0, \\\"already activated\\\");\\r\\n        (uint priceCumulative, uint32 blockTimestamp) =\\r\\n           UniswapV2OracleLibrary.currentCumulativePrices(uniswapPair, isToken0);\\r\\n        require(blockTimestamp \\u003e 0, \\\"no trades\\\");\\r\\n        blockTimestampLast = blockTimestamp;\\r\\n        priceCumulativeLast = priceCumulative;\\r\\n        timeOfTWAPInit = blockTimestamp;\\r\\n    }\\r\\n\\r\\n    /** @notice Activates rebasing\\r\\n    *   @dev One way function, cannot be undone, callable by anyone\\r\\n    */\\r\\n    function activateRebasing()\\r\\n        public\\r\\n    {\\r\\n        require(timeOfTWAPInit \\u003e 0, \\\"twap wasnt intitiated, call initTWAP()\\\");\\r\\n        // cannot enable prior to end of rebaseDelay\\r\\n        require(now \\u003e= timeOfTWAPInit + rebaseDelay, \\\"!end_delay\\\");\\r\\n\\r\\n        rebasingActive = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\\r\\n     *\\r\\n     * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\\r\\n     *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\\r\\n     *      and targetRate is 1e18\\r\\n     */\\r\\n    function rebase()\\r\\n        public\\r\\n    {\\r\\n        // EOA only or gov\\r\\n        require(msg.sender == tx.origin || msg.sender == owner()); \\r\\n\\r\\n        // ensure rebasing at correct time\\r\\n        _inRebaseWindow(); \\r\\n\\r\\n        // This comparison also ensures there is no reentrancy.\\r\\n        require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) \\u003c= now);  // FIX: [\\u003c] -\\u003e [\\u003c=] to allow rebase from 0th second of each window\\r\\n\\r\\n        require(updateTargetRate(), \\\"Target rate was not defined\\\");\\r\\n\\r\\n        \\r\\n        // Snap the rebase time to the start of this window.\\r\\n        lastRebaseTimestampSec = now.sub( \\r\\n            now.mod(minRebaseTimeIntervalSec)).add(rebaseWindowOffsetSec); \\r\\n\\r\\n        epoch = epoch.add(1); \\r\\n\\r\\n        // get twap from uniswap v2;\\r\\n        uint256 exchangeRate = getTWAP();\\r\\n\\r\\n        // calculates % change to supply\\r\\n        (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate); // 999999452912662667\\r\\n\\r\\n        uint256 indexDelta = offPegPerc;\\r\\n\\r\\n        // Apply the Dampening factor.\\r\\n        indexDelta = indexDelta.div(rebaseLag);\\r\\n\\r\\n        // Clip indexDelta to stay within interval of [1/maxRebaseRatio - 1, maxRebaseRatio - 1] so that\\r\\n        // scalingFactor will get multiplied/divided up to maxRebaseRatio times.\\r\\n        indexDelta = obeyMaxRebaseRatio(indexDelta, positive);\\r\\n\\r\\n        IXAUToken xau = IXAUToken(xauToken);\\r\\n\\r\\n        if (positive) {\\r\\n            require(xau.scalingFactor().mul(BASE.add(indexDelta)).div(BASE) \\u003c xau.maxScalingFactor(), \\\"new scaling factor will be too big\\\");\\r\\n        }\\r\\n\\r\\n        // rebase, ignore returned var\\r\\n        xau.rebase(epoch, indexDelta, positive);\\r\\n\\r\\n        // perform actions after rebase\\r\\n        afterRebase(offPegPerc); \\r\\n    }\\r\\n\\r\\n    function afterRebase(\\r\\n        uint256 /* offPegPerc */\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        // update uniswap pairs\\r\\n        for (uint256 i = 0; i \\u003c uniSyncPairs.length; i++) {\\r\\n            IUniswapV2Pair(uniSyncPairs[i]).sync();\\r\\n        }\\r\\n\\r\\n        // update balancer pairs\\r\\n        for (uint256 i = 0; i \\u003c balGulpPairs.length; i++) {\\r\\n            BAL(balGulpPairs[i]).gulp(xauToken);\\r\\n        }\\r\\n\\r\\n        // call any extra functions\\r\\n        for (uint i = 0; i \\u003c transactions.length; i++) {\\r\\n            Transaction storage t = transactions[i];\\r\\n            if (t.enabled) {\\r\\n                bool result =\\r\\n                    externalCall(t.destination, t.data);\\r\\n                if (!result) {\\r\\n                    emit TransactionFailed(t.destination, i, t.data);\\r\\n                    revert(\\\"Transaction Failed\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates TWAP from uniswap\\r\\n     *\\r\\n     * @dev When liquidity is low, this can be manipulated by an end of block -\\u003e next block\\r\\n     *      attack. We delay the activation of rebases 12 hours after liquidity incentives\\r\\n     *      to reduce this attack vector. Additional there is very little supply\\r\\n     *      to be able to manipulate this during that time period of highest vuln.\\r\\n     */\\r\\n    function getTWAP()\\r\\n        internal\\r\\n        returns (uint256)\\r\\n    {\\r\\n        (uint priceCumulative, uint32 blockTimestamp) =\\r\\n            UniswapV2OracleLibrary.currentCumulativePrices(uniswapPair, isToken0);\\r\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\r\\n\\r\\n        // no period check as is done in isRebaseWindow\\r\\n\\r\\n\\r\\n        // overflow is desired\\r\\n        uint256 priceAverage = uint256(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\\r\\n\\r\\n        priceCumulativeLast = priceCumulative;\\r\\n        blockTimestampLast = blockTimestamp;\\r\\n\\r\\n        // BASE is on order of 1e18, which takes 2^60 bits\\r\\n        // multiplication will revert if priceAverage \\u003e 2^196\\r\\n        // (which it can because it overflows intentially)\\r\\n        if (priceAverage \\u003e uint192(-1)) {\\r\\n           // eat loss of precision\\r\\n           // effectively: (x / 2**112) * 1e18\\r\\n           return (priceAverage \\u003e\\u003e 112) * BASE;\\r\\n        }\\r\\n        // cant overflow\\r\\n        // effectively: (x * 1e18 / 2**112)\\r\\n        return (priceAverage * BASE) \\u003e\\u003e 112;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates current TWAP from uniswap\\r\\n     * \\r\\n     * @dev Has to be called in context, where blockTimestamp \\u003e blockTimestampLast, \\r\\n     *      i.e. in different block after last initTWAP()/getTWAP() call.\\r\\n     *\\r\\n     */\\r\\n    function getCurrentTWAP()\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        (uint priceCumulative, uint32 blockTimestamp) =\\r\\n            UniswapV2OracleLibrary.currentCumulativePrices(uniswapPair, isToken0);\\r\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\r\\n\\r\\n        // no period check as is done in isRebaseWindow\\r\\n\\r\\n        // overflow is desired\\r\\n        uint256 priceAverage = uint256(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\\r\\n\\r\\n        // BASE is on order of 1e18, which takes 2^60 bits\\r\\n        // multiplication will revert if priceAverage \\u003e 2^196\\r\\n        // (which it can because it overflows intentially)\\r\\n        if (priceAverage \\u003e uint192(-1)) {\\r\\n            // eat loss of precision\\r\\n            // effectively: (x / 2**112) * 1e18\\r\\n            return (priceAverage \\u003e\\u003e 112) * BASE;\\r\\n        }\\r\\n        // cant overflow\\r\\n        // effectively: (x * 1e18 / 2**112)\\r\\n        return (priceAverage * BASE) \\u003e\\u003e 112;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the deviation threshold fraction. If the exchange rate given by the market\\r\\n     *         oracle is within this fractional distance from the targetRate, then no supply\\r\\n     *         modifications are made.\\r\\n     * @param deviationThreshold_ The new exchange rate threshold fraction.\\r\\n     */\\r\\n    function setDeviationThreshold(uint256 deviationThreshold_)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(deviationThreshold_ \\u003e 0);  // FIX: fixed YAM bug: require should validate argument, not member\\r\\n        uint256 oldDeviationThreshold = deviationThreshold;\\r\\n        deviationThreshold = deviationThreshold_;\\r\\n        emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the deviation threshold fraction. If the exchange rate given by the market\\r\\n     *         oracle is within this fractional distance from the targetRate, then no supply\\r\\n     *         modifications are made.\\r\\n     * @param maxRebaseRatio_ The new exchange rate threshold fraction.\\r\\n     */\\r\\n    function setMaxRebaseRatio(uint256 maxRebaseRatio_)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(maxRebaseRatio_ \\u003e 1 * 10**18);\\r\\n        uint256 oldMaxRebaseRatio = maxRebaseRatio;\\r\\n        maxRebaseRatio = maxRebaseRatio_;\\r\\n        emit NewMaxRebaseRatio(oldMaxRebaseRatio, maxRebaseRatio_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param indexDelta The indexDelta to be clipped using maxRebaseRatio.\\r\\n     * @param positive Sign of indexDelta.\\r\\n     * @return unchanged indexDelta if resulting scalingFactor will stay within\\r\\n     *         [scalingFactor / maxRebaseRatio, scalingFactor * maxRebaseRatio] interval,\\r\\n     *         or maxIndexDelta derived from direction and maxRebaseRatio (saturation)\\r\\n     */\\r\\n    function obeyMaxRebaseRatio(uint256 indexDelta, bool positive)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 maxIndexDelta = (positive ? maxRebaseRatio.sub(BASE) : BASE.sub((BASE*BASE).div(maxRebaseRatio)));\\r\\n        return (indexDelta \\u003c= maxIndexDelta ? indexDelta : maxIndexDelta);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the rebase lag parameter.\\r\\n               It is used to dampen the applied supply adjustment by 1 / rebaseLag\\r\\n               If the rebase lag R, equals 1, the smallest value for R, then the full supply\\r\\n               correction is applied on each rebase cycle.\\r\\n               If it is greater than 1, then a correction of 1/R of is applied on each rebase.\\r\\n     * @param rebaseLag_ The new rebase lag parameter.\\r\\n     */\\r\\n    function setRebaseLag(uint256 rebaseLag_)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(rebaseLag_ \\u003e 0);\\r\\n        rebaseLag = rebaseLag_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the targetRate parameter.\\r\\n     * @param targetRate_ The new target rate parameter.\\r\\n     */\\r\\n    function setTargetRate(uint256 targetRate_)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(targetRate_ \\u003e 0);\\r\\n        targetRate = targetRate_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the parameters which control the timing and frequency of\\r\\n     *         rebase operations.\\r\\n     *         a) the minimum time period that must elapse between rebase cycles.\\r\\n     *         b) the rebase window offset parameter.\\r\\n     *         c) the rebase window length parameter.\\r\\n     * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\\r\\n     *        operations, in seconds.\\r\\n     * @param rebaseWindowOffsetSec_ The number of seconds from the beginning of\\r\\n              the rebase interval, where the rebase window begins.\\r\\n     * @param rebaseWindowLengthSec_ The length of the rebase window in seconds.\\r\\n     */\\r\\n    function setRebaseTimingParameters(\\r\\n        uint256 minRebaseTimeIntervalSec_,\\r\\n        uint256 rebaseWindowOffsetSec_,\\r\\n        uint256 rebaseWindowLengthSec_)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(minRebaseTimeIntervalSec_ \\u003e 0);\\r\\n        require(rebaseWindowOffsetSec_ \\u003c minRebaseTimeIntervalSec_);\\r\\n        require(rebaseWindowOffsetSec_ + rebaseWindowLengthSec_ \\u003c= minRebaseTimeIntervalSec_);  // FIX: [\\u003c] -\\u003e [\\u003c=] to allow window length to span whole interval if needed\\r\\n        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\\r\\n        rebaseWindowOffsetSec = rebaseWindowOffsetSec_;\\r\\n        rebaseWindowLengthSec = rebaseWindowLengthSec_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return If the latest block timestamp is within the rebase time window it, returns true.\\r\\n     *         Otherwise, returns false.\\r\\n     */\\r\\n    function inRebaseWindow() public view returns (bool) {\\r\\n\\r\\n        // rebasing is delayed until there is a liquid market\\r\\n        _inRebaseWindow();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _inRebaseWindow() internal view {\\r\\n\\r\\n        // rebasing is delayed until there is a liquid market\\r\\n        require(rebasingActive, \\\"rebasing not active\\\");\\r\\n\\r\\n        require(now.mod(minRebaseTimeIntervalSec) \\u003e= rebaseWindowOffsetSec, \\\"too early\\\");\\r\\n        require(now.mod(minRebaseTimeIntervalSec) \\u003c (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)), \\\"too late\\\");\\r\\n    }\\r\\n\\r\\n    function isRebaseEffective() external view returns (bool) {\\r\\n        return        \\r\\n            rebasingActive \\u0026\\u0026 \\r\\n            now.mod(minRebaseTimeIntervalSec) \\u003e= rebaseWindowOffsetSec \\u0026\\u0026\\r\\n            now.mod(minRebaseTimeIntervalSec) \\u003c (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)) \\u0026\\u0026\\r\\n            lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) \\u003c= now \\u0026\\u0026\\r\\n            !withinDeviationThreshold(getCurrentTWAP(), getCurrentTargetRate())\\r\\n            ;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return Computes in % how far off market is from peg\\r\\n     */\\r\\n    function computeOffPegPerc(uint256 rate)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256, bool)\\r\\n    {\\r\\n        if (withinDeviationThreshold(rate, targetRate)) {\\r\\n            return (0, false);\\r\\n        }\\r\\n\\r\\n        // indexDelta =  (rate - targetRate) / targetRate\\r\\n        if (rate \\u003e targetRate) {\\r\\n            return (rate.sub(targetRate).mul(BASE).div(targetRate), true);\\r\\n        } else {\\r\\n            return (targetRate.sub(rate).mul(BASE).div(targetRate), false);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _currentRate The current exchange rate, an 18 decimal fixed point number.\\r\\n     * @param _targetRate The current target rate, an 18 decimal fixed point number.\\r\\n     * @return If the rate is within the deviation threshold from the target rate, returns true.\\r\\n     *         Otherwise, returns false.\\r\\n     */\\r\\n    function withinDeviationThreshold(uint256 _currentRate, uint256 _targetRate)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint256 absoluteDeviationThreshold = _targetRate.mul(deviationThreshold)\\r\\n            .div(10 ** 18);\\r\\n\\r\\n        return (_currentRate \\u003e= _targetRate \\u0026\\u0026 _currentRate.sub(_targetRate) \\u003c absoluteDeviationThreshold)\\r\\n            || (_currentRate \\u003c _targetRate \\u0026\\u0026 _targetRate.sub(_currentRate) \\u003c absoluteDeviationThreshold);\\r\\n    }\\r\\n\\r\\n    /* - Constructor Helpers - */\\r\\n\\r\\n    // calculates the CREATE2 address for a pair without making any external calls\\r\\n    function pairFor(\\r\\n        address factory,\\r\\n        address token0,\\r\\n        address token1\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (address pair)\\r\\n    {\\r\\n        pair = address(uint(keccak256(abi.encodePacked(\\r\\n                hex\\u0027ff\\u0027,\\r\\n                factory,\\r\\n                keccak256(abi.encodePacked(token0, token1)),\\r\\n                hex\\u002796e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\u0027 // init code hash\\r\\n            ))));\\r\\n    }\\r\\n\\r\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\r\\n    function sortTokens(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (address token0, address token1)\\r\\n    {\\r\\n        require(tokenA != tokenB, \\u0027UniswapV2Library: IDENTICAL_ADDRESSES\\u0027);\\r\\n        (token0, token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\r\\n        require(token0 != address(0), \\u0027UniswapV2Library: ZERO_ADDRESS\\u0027);\\r\\n    }\\r\\n\\r\\n    /* -- Rebase helpers -- */\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a transaction that gets called for a downstream receiver of rebases\\r\\n     * @param destination Address of contract destination\\r\\n     * @param data Transaction data payload\\r\\n     */\\r\\n    function addTransaction(address destination, bytes calldata data)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        transactions.push(Transaction({\\r\\n            enabled: true,\\r\\n            destination: destination,\\r\\n            data: data\\r\\n        }));\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @param index Index of transaction to remove.\\r\\n     *              Transaction ordering may have changed since adding.\\r\\n     */\\r\\n    function removeTransaction(uint index)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(index \\u003c transactions.length, \\\"index out of bounds\\\");\\r\\n\\r\\n        if (index \\u003c transactions.length - 1) {\\r\\n            transactions[index] = transactions[transactions.length - 1];\\r\\n        }\\r\\n\\r\\n        // transactions.length--;\\r\\n        transactions.pop();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param index Index of transaction. Transaction ordering may have changed since adding.\\r\\n     * @param enabled True for enabled, false for disabled.\\r\\n     */\\r\\n    function setTransactionEnabled(uint index, bool enabled)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(index \\u003c transactions.length, \\\"index must be in range of stored tx list\\\");\\r\\n        transactions[index].enabled = enabled;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev wrapper to call the encoded transactions on downstream consumers.\\r\\n     * @param destination Address of destination contract.\\r\\n     * @param data The encoded data payload.\\r\\n     * @return True on success\\r\\n     */\\r\\n    function externalCall(address destination, bytes memory data)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        bool result;\\r\\n        assembly {  // solhint-disable-line no-inline-assembly\\r\\n            // \\\"Allocate\\\" memory for output\\r\\n            // (0x40 is where \\\"free memory\\\" pointer is stored by convention)\\r\\n            let outputAddress := mload(0x40)\\r\\n\\r\\n            // First 32 bytes are the padded length of data, so exclude that\\r\\n            let dataAddress := add(data, 32)\\r\\n\\r\\n            result := call(\\r\\n                // 34710 is the value that solidity is currently emitting\\r\\n                // It includes callGas (700) + callVeryLow (3, to pay for SUB)\\r\\n                // + callValueTransferGas (9000) + callNewAccountGas\\r\\n                // (25000, in case the destination address does not exist and needs creating)\\r\\n                sub(gas(), 34710),\\r\\n\\r\\n\\r\\n                destination,\\r\\n                0, // transfer value in wei\\r\\n                dataAddress,\\r\\n                mload(data),  // Size of the input, in bytes. Stored in position 0 of the array.\\r\\n                outputAddress,\\r\\n                0  // Output is ignored, therefore the output size is zero\\r\\n            )\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n    \\r\\n    // Gives governance ability to recover any ERC20 tokens mistakenly sent to this contract address.\\r\\n    function recoverERC20(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    )\\r\\n        external\\r\\n        onlyOwner\\r\\n        returns (bool)\\r\\n    {\\r\\n        return IERC20(token).transfer(to, amount);\\r\\n    }\\r\\n\\r\\n    function setTargetRateOracle1(AggregatorV3Interface oracleAddress_) public onlyOwner {\\r\\n        targetRateOracle1 = oracleAddress_;\\r\\n    }\\r\\n\\r\\n    function setTargetRateOracle2(AggregatorV3Interface oracleAddress_) public onlyOwner {\\r\\n        targetRateOracle2 = oracleAddress_;\\r\\n    }\\r\\n\\r\\n    function setTargetRateOracleDecimals(uint256 targetRateOracleDecimals_) public onlyOwner {\\r\\n        targetRateOracleScale = 10**targetRateOracleDecimals_;\\r\\n    }\\r\\n\\r\\n    function getTargetRateOracle1Price() public view returns (uint256) {\\r\\n        return getChainLinkOraclePrice(targetRateOracle1);\\r\\n    }\\r\\n\\r\\n    function getTargetRateOracle2Price() public view returns (uint256) {\\r\\n        return getChainLinkOraclePrice(targetRateOracle2);\\r\\n    }\\r\\n\\r\\n    function getUniswapPairAddress() public view returns (address) {\\r\\n        return uniswapPair;\\r\\n    }\\r\\n\\r\\n    function getChainLinkOraclePrice(AggregatorV3Interface chainLinkOracle) internal view returns (uint256) {\\r\\n        (\\r\\n            , // uint80 roundID, \\r\\n            uint price,\\r\\n            , // uint startedAt,\\r\\n            uint timeStamp,\\r\\n              // uint80 answeredInRound\\r\\n        ) = chainLinkOracle.latestRoundData();        \\r\\n        require(timeStamp \\u003e 0, \\\"Round not complete\\\");  // If the round is not complete yet, timestamp is 0\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    function getCurrentTargetRate() public view returns (uint256) {\\r\\n        if (address(targetRateOracle1) != address(0)) {\\r\\n            if (address(targetRateOracle2) != address(0)) {\\r\\n                // Two oracle mode (i.e.: 1: [comodity/USD], 2: [ETH/USD]; [base/quote])\\r\\n                return getChainLinkOraclePrice(targetRateOracle1).mul(BASE).div(getChainLinkOraclePrice(targetRateOracle2));  // [comodity/USD] / [ETH/USD] = [comodity/USD] * [USD/ETH] = [comodity/ETH])\\r\\n            } else {\\r\\n                // Single oracle mode (direct), scale is important\\r\\n                return getChainLinkOraclePrice(targetRateOracle1).mul(BASE).div(targetRateOracleScale);\\r\\n            }\\r\\n        } else if (address(targetRateOracle2) != address(0)) {\\r\\n            // Single oracle mode (inverted), scale is important\\r\\n            return BASE.mul(targetRateOracleScale).div(getChainLinkOraclePrice(targetRateOracle2));\\r\\n        } else {\\r\\n            // No oracle mode, fixed targetRate\\r\\n            return targetRate;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function updateTargetRate() public returns (bool) {\\r\\n        AggregatorV3Interface _targetRateOracle1 = targetRateOracle1;  // cache storage values to save duplicit SLOAD gas\\r\\n        AggregatorV3Interface _targetRateOracle2 = targetRateOracle2;\\r\\n        if (address(_targetRateOracle1) != address(0)) {\\r\\n            if (address(_targetRateOracle2) != address(0)) {\\r\\n                // Two oracle mode (i.e.: 1: [comodity/USD], 2: [ETH/USD]; [base/quote])\\r\\n                targetRate = getChainLinkOraclePrice(_targetRateOracle1).mul(BASE).div(getChainLinkOraclePrice(_targetRateOracle2));  // [comodity/USD] / [ETH/USD] = [comodity/USD] * [USD/ETH] = [comodity/ETH])\\r\\n            } else {\\r\\n                // Single oracle mode (direct), scale is important\\r\\n                targetRate = getChainLinkOraclePrice(_targetRateOracle1).mul(BASE).div(targetRateOracleScale);\\r\\n            }\\r\\n        } else if (address(_targetRateOracle2) != address(0)) {\\r\\n            // Single oracle mode (inverted), scale is important\\r\\n            targetRate = BASE.mul(targetRateOracleScale).div(getChainLinkOraclePrice(_targetRateOracle2));\\r\\n        } else {\\r\\n            // No oracle mode, fixed targetRate\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"UniswapV2OracleLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\nimport \\u0027./IUniswapV2Pair.sol\\u0027;\\r\\nimport \\u0027./FixedPoint.sol\\u0027;\\r\\n\\r\\n// library with helper methods for oracles that are concerned with computing average prices\\r\\nlibrary UniswapV2OracleLibrary {\\r\\n    using FixedPoint for *;\\r\\n\\r\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\r\\n    function currentBlockTimestamp() internal view returns (uint32) {\\r\\n        return uint32(block.timestamp % 2 ** 32);\\r\\n    }\\r\\n\\r\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\r\\n    function currentCumulativePrices(\\r\\n        address pair,\\r\\n        bool isToken0\\r\\n    ) internal view returns (uint priceCumulative, uint32 blockTimestamp) {\\r\\n        blockTimestamp = currentBlockTimestamp();\\r\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\r\\n        if (isToken0) {\\r\\n          priceCumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\r\\n\\r\\n          // if time has elapsed since the last update on the pair, mock the accumulated price values\\r\\n          if (blockTimestampLast != blockTimestamp) {\\r\\n              // subtraction overflow is desired\\r\\n              uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\r\\n              // addition overflow is desired\\r\\n              // counterfactual\\r\\n              priceCumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\r\\n          }\\r\\n        } else {\\r\\n          priceCumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\r\\n          // if time has elapsed since the last update on the pair, mock the accumulated price values\\r\\n          if (blockTimestampLast != blockTimestamp) {\\r\\n              // subtraction overflow is desired\\r\\n              uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\r\\n              // addition overflow is desired\\r\\n              // counterfactual\\r\\n              priceCumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\r\\n          }\\r\\n        }\\r\\n\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"xauToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reserveToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapPair_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetRateOracle1Address_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetRateOracle2Address_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetRateOracleDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minRebaseTimeIntervalSec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rebaseWindowOffsetSec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rebaseWindowLengthSec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rebaseDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDeviationThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeviationThreshold\",\"type\":\"uint256\"}],\"name\":\"NewDeviationThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxRebaseRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxRebaseRatio\",\"type\":\"uint256\"}],\"name\":\"NewMaxRebaseRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"TransactionFailed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateRebasing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"balGulpPairs_\",\"type\":\"address[]\"}],\"name\":\"addGulpSyncPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"addTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"uniSyncPairs_\",\"type\":\"address[]\"}],\"name\":\"addUniSyncPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balGulpPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimestampLast\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deviationThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalGulpPairs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTWAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTargetRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTargetRateOracle1Price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTargetRateOracle2Price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUniSyncPairs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUniswapPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inRebaseWindow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initTWAP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRebaseEffective\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isToken0\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebaseTimestampSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRebaseRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRebaseTimeIntervalSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceCumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseWindowLengthSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseWindowOffsetSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebasingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeBalPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeUniPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deviationThreshold_\",\"type\":\"uint256\"}],\"name\":\"setDeviationThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxRebaseRatio_\",\"type\":\"uint256\"}],\"name\":\"setMaxRebaseRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rebaseLag_\",\"type\":\"uint256\"}],\"name\":\"setRebaseLag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minRebaseTimeIntervalSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebaseWindowOffsetSec_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebaseWindowLengthSec_\",\"type\":\"uint256\"}],\"name\":\"setRebaseTimingParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetRate_\",\"type\":\"uint256\"}],\"name\":\"setTargetRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"oracleAddress_\",\"type\":\"address\"}],\"name\":\"setTargetRateOracle1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"oracleAddress_\",\"type\":\"address\"}],\"name\":\"setTargetRateOracle2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetRateOracleDecimals_\",\"type\":\"uint256\"}],\"name\":\"setTargetRateOracleDecimals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setTransactionEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetRateOracle1\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetRateOracle2\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetRateOracleScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeOfTWAPInit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uniSyncPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateTargetRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xauToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Rebaser","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"50000","ConstructorArguments":"0000000000000000000000006d9a869d2a62a5f920843b8ca050892ed6ecfa87000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000064ccb9bed3d48f4de5ad6b8a57f9bcff0b26e9e7000000000000000000000000214ed9da11d2fbe465a6fc601a91e62ebec1a0d60000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000001518000000000000000000000000000000000000000000000000000000000000070800000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000015180","EVMVersion":"istanbul","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b67ca8ec24271c94624a455bf24a60e77b846b2333b73c273dca6510b20d5420"}]}