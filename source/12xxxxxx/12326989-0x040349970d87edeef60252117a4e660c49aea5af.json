{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n\n\n// Part: BConst\n\ncontract BConst {\n  uint public constant BONE = 10**18;\n\n  uint public constant MIN_BOUND_TOKENS = 2;\n  uint public constant MAX_BOUND_TOKENS = 8;\n\n  uint public constant MIN_FEE = BONE / 10**6;\n  uint public constant MAX_FEE = BONE / 10;\n  uint public constant EXIT_FEE = 0;\n\n  uint public constant MIN_WEIGHT = BONE;\n  uint public constant MAX_WEIGHT = BONE * 50;\n  uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\n  uint public constant MIN_BALANCE = BONE / 10**12;\n\n  uint public constant INIT_POOL_SUPPLY = BONE * 100;\n\n  uint public constant MIN_BPOW_BASE = 1 wei;\n  uint public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n  uint public constant BPOW_PRECISION = BONE / 10**10;\n\n  uint public constant MAX_IN_RATIO = BONE / 2;\n  uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n\n// Part: IBalancerPool\n\ninterface IBalancerPool {\n  function getFinalTokens() external view returns (address[] memory);\n\n  function getNormalizedWeight(address token) external view returns (uint);\n\n  function getSwapFee() external view returns (uint);\n\n  function getNumTokens() external view returns (uint);\n\n  function getBalance(address token) external view returns (uint);\n\n  function totalSupply() external view returns (uint);\n\n  function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\n\n  function swapExactAmountOut(\n    address tokenIn,\n    uint maxAmountIn,\n    address tokenOut,\n    uint tokenAmountOut,\n    uint maxPrice\n  ) external returns (uint tokenAmountIn, uint spotPriceAfter);\n\n  function joinswapExternAmountIn(\n    address tokenIn,\n    uint tokenAmountIn,\n    uint minPoolAmountOut\n  ) external returns (uint poolAmountOut);\n\n  function exitPool(uint poolAmoutnIn, uint[] calldata minAmountsOut) external;\n\n  function exitswapExternAmountOut(\n    address tokenOut,\n    uint tokenAmountOut,\n    uint maxPoolAmountIn\n  ) external returns (uint poolAmountIn);\n}\n\n// Part: IBaseOracle\n\ninterface IBaseOracle {\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\n  /// @param token The ERC-20 token to check the value.\n  function getETHPx(address token) external view returns (uint);\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@3.4.0/SafeMath\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n// Part: BNum\n\ncontract BNum is BConst {\n  function btoi(uint a) internal pure returns (uint) {\n    return a / BONE;\n  }\n\n  function bfloor(uint a) internal pure returns (uint) {\n    return btoi(a) * BONE;\n  }\n\n  function badd(uint a, uint b) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, 'ERR_ADD_OVERFLOW');\n    return c;\n  }\n\n  function bsub(uint a, uint b) internal pure returns (uint) {\n    (uint c, bool flag) = bsubSign(a, b);\n    require(!flag, 'ERR_SUB_UNDERFLOW');\n    return c;\n  }\n\n  function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\n    if (a >= b) {\n      return (a - b, false);\n    } else {\n      return (b - a, true);\n    }\n  }\n\n  function bmul(uint a, uint b) internal pure returns (uint) {\n    uint c0 = a * b;\n    require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\n    uint c1 = c0 + (BONE / 2);\n    require(c1 >= c0, 'ERR_MUL_OVERFLOW');\n    uint c2 = c1 / BONE;\n    return c2;\n  }\n\n  function bdiv(uint a, uint b) internal pure returns (uint) {\n    require(b != 0, 'ERR_DIV_ZERO');\n    uint c0 = a * BONE;\n    require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\n    uint c1 = c0 + (b / 2);\n    require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\n    uint c2 = c1 / b;\n    return c2;\n  }\n\n  // DSMath.wpow\n  function bpowi(uint a, uint n) internal pure returns (uint) {\n    uint z = n % 2 != 0 ? a : BONE;\n\n    for (n /= 2; n != 0; n /= 2) {\n      a = bmul(a, a);\n\n      if (n % 2 != 0) {\n        z = bmul(z, a);\n      }\n    }\n    return z;\n  }\n\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\n  // of approximation of b^0.w\n  function bpow(uint base, uint exp) internal pure returns (uint) {\n    require(base >= MIN_BPOW_BASE, 'ERR_BPOW_BASE_TOO_LOW');\n    require(base <= MAX_BPOW_BASE, 'ERR_BPOW_BASE_TOO_HIGH');\n\n    uint whole = bfloor(exp);\n    uint remain = bsub(exp, whole);\n\n    uint wholePow = bpowi(base, btoi(whole));\n\n    if (remain == 0) {\n      return wholePow;\n    }\n\n    uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n    return bmul(wholePow, partialResult);\n  }\n\n  function bpowApprox(\n    uint base,\n    uint exp,\n    uint precision\n  ) internal pure returns (uint) {\n    // term 0:\n    uint a = exp;\n    (uint x, bool xneg) = bsubSign(base, BONE);\n    uint term = BONE;\n    uint sum = term;\n    bool negative = false;\n\n    // term(k) = numer / denom\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\n    // continue until term is less than precision\n    for (uint i = 1; term >= precision; i++) {\n      uint bigK = i * BONE;\n      (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n      term = bmul(term, bmul(c, x));\n      term = bdiv(term, bigK);\n      if (term == 0) break;\n\n      if (xneg) negative = !negative;\n      if (cneg) negative = !negative;\n      if (negative) {\n        sum = bsub(sum, term);\n      } else {\n        sum = badd(sum, term);\n      }\n    }\n\n    return sum;\n  }\n}\n\n// Part: UsingBaseOracle\n\ncontract UsingBaseOracle {\n  IBaseOracle public immutable base; // Base oracle source\n\n  constructor(IBaseOracle _base) public {\n    base = _base;\n  }\n}\n\n// File: BalancerPairOracle.sol\n\ncontract BalancerPairOracle is UsingBaseOracle, IBaseOracle, BNum {\n  using SafeMath for uint;\n\n  constructor(IBaseOracle _base) public UsingBaseOracle(_base) {}\n\n  /// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.\n  /// @param resA Reserve of the first asset\n  /// @param resB Reserve of the second asset\n  /// @param wA Weight of the first asset\n  /// @param wB Weight of the second asset\n  /// @param pxA Fair price of the first asset\n  /// @param pxB Fair price of the second asset\n  function computeFairReserves(\n    uint resA,\n    uint resB,\n    uint wA,\n    uint wB,\n    uint pxA,\n    uint pxB\n  ) internal pure returns (uint fairResA, uint fairResB) {\n    // NOTE: wA + wB = 1 (normalize weights)\n    // constant product = resA^wA * resB^wB\n    // constraints:\n    // - fairResA^wA * fairResB^wB = constant product\n    // - fairResA * pxA / wA = fairResB * pxB / wB\n    // Solving equations:\n    // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n    // --> fairResA / r1^wB = constant product\n    // --> fairResA = resA^wA * resB^wB * r1^wB\n    // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n    uint r0 = bdiv(resA, resB);\n    uint r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\n    // fairResA = resA * (r1 / r0) ^ wB\n    // fairResB = resB * (r0 / r1) ^ wA\n    if (r0 > r1) {\n      uint ratio = bdiv(r1, r0);\n      fairResA = bmul(resA, bpow(ratio, wB));\n      fairResB = bdiv(resB, bpow(ratio, wA));\n    } else {\n      uint ratio = bdiv(r0, r1);\n      fairResA = bdiv(resA, bpow(ratio, wB));\n      fairResB = bmul(resB, bpow(ratio, wA));\n    }\n  }\n\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\n  /// @param token The ERC-20 token to check the value.\n  function getETHPx(address token) external view override returns (uint) {\n    IBalancerPool pool = IBalancerPool(token);\n    require(pool.getNumTokens() == 2, 'num tokens must be 2');\n    address[] memory tokens = pool.getFinalTokens();\n    address tokenA = tokens[0];\n    address tokenB = tokens[1];\n    uint pxA = base.getETHPx(tokenA);\n    uint pxB = base.getETHPx(tokenB);\n    (uint fairResA, uint fairResB) =\n      computeFairReserves(\n        pool.getBalance(tokenA),\n        pool.getBalance(tokenB),\n        pool.getNormalizedWeight(tokenA),\n        pool.getNormalizedWeight(tokenB),\n        pxA,\n        pxB\n      );\n    // use fairReserveA and fairReserveB to compute LP token price\n    // LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n    return fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply());\n  }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"contract IBaseOracle\",\"name\":\"_base\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"base\",\"outputs\":[{\"internalType\":\"contract IBaseOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getETHPx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BalancerPairOracle","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006be987c6d72e25f02f6f061f94417d83a6aa13fc","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}