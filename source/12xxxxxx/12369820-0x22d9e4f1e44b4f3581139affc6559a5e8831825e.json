{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'FBond' token contract\r\n//\r\n// Deployed to : 0x22d9e4f1e44b4f3581139affc6559a5e8831825e\r\n// Symbol      : FBond\r\n// Name        : FBond Token\r\n// Total supply: 100\r\n// Decimals    : 18\r\n//\r\n// author: ffyring\r\n// version: 20210504_1100\r\n// ----------------------------------------------------------\r\n\r\nlibrary IterableMapping {\r\n     // Iterable mapping from address to uint;\r\n     struct Map {\r\n         address[] keys;\r\n         mapping(address => uint) values;\r\n         mapping(address => uint) indexOf;\r\n         mapping(address => bool) inserted;\r\n     }\r\n\r\n     function get(Map storage map, address key) public view returns (uint) {\r\n         return map.values[key];\r\n     }\r\n\r\n     function getOrDefault(Map storage map, address key, uint d) public view returns (uint) {\r\n         if(map.inserted[key]) {\r\n             return map.values[key];\r\n         }\r\n         else {\r\n             return d;\r\n         }\r\n     }\r\n\r\n     function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\r\n         return map.keys[index];\r\n     }\r\n\r\n     function size(Map storage map) public view returns (uint) {\r\n         return map.keys.length;\r\n     }\r\n\r\n     function set(Map storage map, address key, uint val) public {\r\n         if (map.inserted[key]) {\r\n             map.values[key] = val;\r\n         } else {\r\n             map.inserted[key] = true;\r\n             map.values[key] = val;\r\n             map.indexOf[key] = map.keys.length;\r\n             map.keys.push(key);\r\n         }\r\n     }\r\n\r\n     function remove(Map storage map, address key) public {\r\n         if (!map.inserted[key]) {\r\n             return;\r\n         }\r\n\r\n         delete map.inserted[key];\r\n         delete map.values[key];\r\n\r\n         uint index = map.indexOf[key];\r\n         uint lastIndex = map.keys.length - 1;\r\n         address lastKey = map.keys[lastIndex];\r\n\r\n         map.indexOf[lastKey] = index;\r\n         delete map.indexOf[key];\r\n\r\n         map.keys[index] = lastKey;\r\n         map.keys.pop();\r\n     }\r\n}\r\n\r\n//----------------------------------------------------------------------------\r\n// Safe maths\r\n//----------------------------------------------------------------------------\r\ncontract SafeMath\r\n{\r\n     function safeAdd(uint a, uint b) internal pure returns (uint c) {\r\n         c = a + b;\r\n         require(c >= a);\r\n     }\r\n     function safeSub(uint a, uint b) internal pure returns (uint c) {\r\n         require(b <= a);\r\n         c = a - b;\r\n     }\r\n     function safeMul(uint a, uint b) internal pure returns (uint c) {\r\n         c = a * b;\r\n         require(a == 0 || c / a == b);\r\n     }\r\n     function safeDiv(uint a, uint b) internal pure returns (uint c) {\r\n         require(b > 0);\r\n         c = a / b;\r\n     }\r\n}\r\n\r\n//----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n//----------------------------------------------------------------------------\r\ninterface ERC20Interface\r\n{\r\n     function totalSupply() external returns (uint);\r\n     function balanceOf(address tokenOwner) external returns (uint balance);\r\n     function allowance(address tokenOwner, address spender) external returns (uint remaining);\r\n     function transfer(address payable to, uint tokens) external returns (bool success);\r\n     function approve(address payable spender, uint tokens) external returns (bool success);\r\n     function transferFrom(address payable from, address payable to, uint tokens) external returns (bool success);\r\n\r\n     event Transfer(address payable indexed from, address indexed to, uint tokens);\r\n     event Approval(address indexed tokenOwner, address indexed spender, uint tokens); }\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\ninterface ApproveAndCallFallBack\r\n{\r\n     function receiveApproval(address payable from, uint256 tokens, address token, bytes memory data) external; }\r\n\r\n\r\n//----------------------------------------------------------------------------\r\n// Owned contract\r\n//----------------------------------------------------------------------------\r\ncontract Owned\r\n{\r\n     address payable public owner;\r\n     address payable public newOwner;\r\n\r\n     event OwnershipTransferred(address payable indexed _from, address payable indexed _to);\r\n\r\n     constructor() payable\r\n     {\r\n         owner = payable(msg.sender);\r\n     }\r\n\r\n     modifier onlyOwner\r\n     {\r\n         require(msg.sender == owner);\r\n         _;\r\n     }\r\n\r\n     function transferOwnership(address payable _newOwner) public onlyOwner\r\n     {\r\n         newOwner = _newOwner;\r\n     }\r\n\r\n     function acceptOwnership() public\r\n     {\r\n         require(msg.sender == newOwner);\r\n         emit OwnershipTransferred(owner, newOwner);\r\n         owner = newOwner;\r\n         newOwner = payable(address(0));\r\n     }\r\n}\r\n\r\n\r\n//----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers.\r\n//\r\n// The contract holds all issued tokens and gives proceeds to issuer when someone buys a // contract. In v2 the contract will give tokens to issuer as proof of the lending \r\n// ----------------------------------------------------------------------------\r\ncontract FBondToken is ERC20Interface, Owned, SafeMath {\r\n     /*\r\n         The bond has a _totalSupply which is the issued amount. The issuer, who creates the bond\r\n         could perhaps be short it. Have to check a bit how to make it work\r\n     */\r\n     using IterableMapping for IterableMapping.Map;\r\n\r\n     string public symbol;\r\n     string public name;\r\n     uint8 public decimals;\r\n     uint public issueDate;\r\n     uint public maturityDate;\r\n     address public issuer;\r\n     address public administrator;\r\n     // How many bonds per eth (other way around than usual nomenclature)\r\n     uint16 constant denomination = 1000;\r\n     // We issue 100 bonds, nominal value 1/denomination (1 finney, approx 23 kr) per bond\r\n     uint16 constant issuedAmount = 100;\r\n     uint16 private _totalSupply;\r\n     uint constant weiMultiplier = 1e18/denomination;\r\n     uint constant weiRateMultiplier = (weiMultiplier/100)*120; //20% interest\r\n     IterableMapping.Map private balances;\r\n     mapping(address => mapping(address => uint)) private allowed;\r\n\r\n     event Print(string msg, uint v);\r\n     //------------------------------------------------------------------------\r\n     // Constructor\r\n     //------------------------------------------------------------------------\r\n     constructor() payable\r\n     {\r\n         symbol = \"FYR\";\r\n         name = \"FBond Token\";\r\n         //decimals = 18;\r\n         decimals = 0;\r\n         issueDate = block.timestamp;\r\n         maturityDate = block.timestamp + 1 weeks;\r\n         _totalSupply = issuedAmount;\r\n         issuer = address(this);\r\n         administrator = msg.sender;\r\n         owner = payable(issuer); //Let the contract own the bond and not the creator\r\n         balances.set(issuer, _totalSupply);\r\n         emit Transfer(payable(address(0)), payable(issuer), _totalSupply);\r\n     }\r\n\r\n     //------------------------------------------------------------------------\r\n     // Total supply\r\n     //------------------------------------------------------------------------\r\n     function totalSupply() public view override returns (uint)\r\n     {\r\n         return _totalSupply;\r\n     }\r\n     function noOfOwners() public view returns (uint)\r\n     {\r\n         return balances.size() - 1; //Don't count issuer as owner\r\n     }\r\n     //------------------------------------------------------------------------\r\n     // Get the token balance for account `tokenOwner`\r\n     //-----------------------------------------------------------------------\r\n     function balanceOf(address tokenOwner) public view override returns (uint balance)\r\n     {\r\n         return balances.get(tokenOwner);\r\n     }\r\n\r\n     //------------------------------------------------------------------------\r\n     // Transfer the balance from token owner's account to `to` account\r\n     // - Owner's account must have sufficient balance to transfer\r\n     // - 0 value transfers are allowed\r\n     //------------------------------------------------------------------------\r\n     function transfer(address payable to, uint tokens) public override returns (bool success)\r\n     {\r\n         balances.set(msg.sender, safeSub(balances.get(msg.sender), tokens));\r\n         balances.set(to, safeAdd(balances.getOrDefault(to, 0), tokens));\r\n         emit Transfer(payable(msg.sender), to, tokens);\r\n         return true;\r\n     }\r\n\r\n\r\n     //------------------------------------------------------------------------\r\n     // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n     // from the token owner's account\r\n     //\r\n     //https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n     // recommends that there are no checks for the approval double-spend attack\r\n     // as this should be implemented in user interfaces\r\n     //------------------------------------------------------------------------\r\n     function approve(address payable spender, uint tokens) public override returns (bool success)\r\n     {\r\n         allowed[msg.sender][spender] = tokens;\r\n         emit Approval(msg.sender, spender, tokens);\r\n         return true;\r\n     }\r\n\r\n\r\n     //------------------------------------------------------------------------\r\n     // Transfer `tokens` from the `from` account to the `to` account\r\n     //\r\n     // The calling account must already have sufficient tokens approve(...)-d\r\n     // for spending from the `from` account and\r\n     // - From account must have sufficient balance to transfer\r\n     // - Spender must have sufficient allowance to transfer\r\n     // - 0 value transfers are allowed\r\n     //------------------------------------------------------------------------\r\n     function transferFrom(address payable from, address payable to, uint tokens) public override returns (bool success)\r\n     {\r\n         balances.set(from, safeSub(balances.get(from), tokens));\r\n         allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n         balances.set(to, safeAdd(balances.getOrDefault(to,0), tokens));\r\n         emit Transfer(from, to, tokens);\r\n         return true;\r\n     }\r\n\r\n\r\n     //------------------------------------------------------------------------\r\n     // Returns the amount of tokens approved by the owner that can be\r\n     // transferred to the spender's account\r\n     //------------------------------------------------------------------------\r\n     function allowance(address tokenOwner, address spender) public view override returns (uint remaining)\r\n     {\r\n         return allowed[tokenOwner][spender];\r\n     }\r\n\r\n     // ------------------------------------------------------------------------\r\n     // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n     // from the token owner's account. The `spender` contract function\r\n     // `receiveApproval(...)` is then executed\r\n     // ------------------------------------------------------------------------\r\n     function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success)\r\n     {\r\n         allowed[msg.sender][spender] = tokens;\r\n         Approval(msg.sender, spender, tokens);\r\n         \r\n         ApproveAndCallFallBack(payable(spender)).receiveApproval(payable(msg.sender), tokens, address(this), data);\r\n         return true;\r\n     }\r\n\r\n      function transferTokens(address payable fromAddress, address payable toAddress, uint tokens) private returns (bool success)\r\n     {\r\n         balances.set(fromAddress, safeSub(balances.get(fromAddress), tokens));\r\n         balances.set(toAddress, safeAdd(balances.getOrDefault(toAddress, 0), tokens));\r\n         emit Transfer(fromAddress, toAddress, tokens);\r\n         return true;\r\n     }\r\n\r\n     // ------------------------------------------------------------------------\r\n     // Issuer can call bond at or after maturityDate.\r\n     // This is a three-step process: first deposit correct funds into contract and then repay holders. Optionally repay\r\n     // every other fund in contract\r\n     //\r\n     function callBondTransferFunds(uint repayAmnt) public payable returns (bool success)\r\n     {\r\n         /*\r\n             This is called by administrator to repay full amount. To make sure\r\n             we accidentally don't send wrong funds we must send exactly outstanding amount.\r\n\r\n         */\r\n         // require(block.timestamp >= maturityDate, 'Cannot call before maturity.')\r\n        require(msg.sender == administrator, 'Only administrator can call bond');\r\n        require(msg.value == repayAmnt * 1e15, 'Did you mean to send this amount? Argument is in Finney');\r\n        require(msg.value == (issuedAmount - _totalSupply) * weiRateMultiplier , 'Sent amount does not match outstanding');\r\n        require(msg.value <= msg.sender.balance, 'You have not enough funds to repay!'); //Not necessary but nice warning.\r\n        return true;\r\n     }\r\n     \r\n     function callBondAndRepay() public payable returns (bool success)\r\n     {\r\n         /*\r\n             This is called by administrator to repay full amount. To make sure\r\n             we accidentally don't send wrong funds we must send exactly outstanding amount.\r\n\r\n         */\r\n\r\n         // require(block.timestamp >= maturityDate, 'Cannot call before maturity.')\r\n         \r\n         require(msg.sender == administrator, 'Only administrator can call bond');\r\n         require(issuer.balance >= (issuedAmount - _totalSupply) * weiRateMultiplier , 'Contract has insufficient funds');\r\n         for(uint i=0 ; i<balances.size(); i++) {\r\n             // Transfer back the bonds to the contract\r\n             address holder = balances.getKeyAtIndex(i);\r\n           \r\n             if(holder != address(this))\r\n             {\r\n                uint amnt = balances.get(holder);\r\n                // Transfer back the bonds to the issuer\r\n                transferTokens(payable(holder), payable(issuer), amnt);\r\n                //Repay with interest\r\n                payable(holder).transfer(amnt * weiRateMultiplier);\r\n             }\r\n         }\r\n        return true;\r\n     }\r\n     \r\n     function deposit(uint depositAmnt) public payable returns(bool success)\r\n     {\r\n           require(msg.sender == administrator, 'Only administrator can deposit funds');\r\n           require(msg.value == depositAmnt * 1e15, 'Did you mean to send this amount? Argument is in Finney');\r\n           return true;\r\n     }\r\n     \r\n       function withdraw_all() public payable returns (bool success)\r\n       {\r\n       \r\n         if(address(this).balance > 0)\r\n         {\r\n            withdraw(address(this).balance);\r\n         }\r\n         return true;\r\n       }\r\n       \r\n       function withdraw(uint f) public payable returns (bool success)\r\n       {\r\n          require(msg.sender == administrator, 'Only administrator can withdraw funds');\r\n          payable(administrator).transfer(f);\r\n          return true;         \r\n       }\r\n     // ------------------------------------------------------------------------\r\n     // 1,000 FBond Tokens per 1 ETH\r\n     // ------------------------------------------------------------------------\r\n     fallback() external payable\r\n   {\r\n\r\n   }\r\n\r\n     receive() external payable\r\n     {\r\n         // This datecomparison is not quite right\r\n         //require(block.timestamp <= issueDate + 1 days, 'Funds not accepted. Passed issuedate.');\r\n         uint16 tokens = uint16(msg.value / weiMultiplier);\r\n         require(tokens <= _totalSupply, 'Not enough supply of bonds for order.');\r\n         transferTokens(payable(issuer), payable(msg.sender), tokens);\r\n         _totalSupply = uint16(safeSub(_totalSupply, tokens));\r\n         // Lend out the transfered ether to issuer\r\n         payable(administrator).transfer(msg.value);\r\n     }\r\n\r\n     // ------------------------------------------------------------------------\r\n     // Owner can transfer out any accidentally sent ERC20 tokens\r\n     // ------------------------------------------------------------------------\r\n     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success)\r\n     {\r\n         return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n     }\r\n}","ABI":"[]","ContractName":"IterableMapping","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ed7c716a1438fffc75f0671d7a3d0c81529b1846a46c5500f5fe8ae54066ae03"}]}