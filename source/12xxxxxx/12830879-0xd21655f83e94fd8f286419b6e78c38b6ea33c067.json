{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@solv/solv-vnft-core/contracts/interface/IVNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\ninterface IVNFT /* is IERC721 */{\\n    event PartialTransfer(address indexed from, address indexed to, uint256 indexed tokenId, uint256 targetTokenId,\\n        uint256 transferUnits);\\n    event Split(address indexed owner, uint256 indexed tokenId, uint256 newTokenId, uint256 splitUnits);\\n    event Merge(address indexed owner, uint256 indexed tokenId, uint256 indexed targetTokenId, uint256 mergeUnits);\\n    event ApprovalUnits(address indexed owner, address indexed approved, uint256 indexed tokenId, uint256 approvalUnits);\\n\\n    function slotOf(uint256 tokenId)  external view returns(uint256 slot);\\n\\n    function balanceOfSlot(uint256 slot) external view returns (uint256 balance);\\n    function tokenOfSlotByIndex(uint256 slot, uint256 index) external view returns (uint256 tokenId);\\n    function unitsInToken(uint256 tokenId) external view returns (uint256 units);\\n\\n    function approve(address to, uint256 tokenId, uint256 units) external;\\n    function allowance(uint256 tokenId, address spender) external view returns (uint256 allowed);\\n\\n    function split(uint256 tokenId, uint256[] calldata units) external returns (uint256[] memory newTokenIds);\\n    function merge(uint256[] calldata tokenIds, uint256 targetTokenId) external;\\n\\n    function transferFrom(address from, address to, uint256 tokenId,\\n        uint256 units) external returns (uint256 newTokenId);\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId,\\n        uint256 units, bytes calldata data) external returns (uint256 newTokenId);\\n\\n    function transferFrom(address from, address to, uint256 tokenId, uint256 targetTokenId,\\n        uint256 units) external;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, uint256 targetTokenId,\\n        uint256 units, bytes calldata data) external;\\n}\\n\\ninterface IVNFTReceiver {\\n    function onVNFTReceived(address operator, address from, uint256 tokenId,\\n        uint256 units, bytes calldata data) external returns (bytes4);\\n}\"\r\n    },\r\n    \"@solv/v2-helper/helpers/ERC20TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\nimport \\\"./EthAddressLib.sol\\\";\\n\\ninterface ERC20Interface {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary ERC20TransferHelper {\\n    function doTransferIn(\\n        address underlying,\\n        address from,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        if (underlying == EthAddressLib.ethAddress()) {\\n            // Sanity checks\\n            require(tx.origin == from || msg.sender == from, \\\"sender mismatch\\\");\\n            require(msg.value == amount, \\\"value mismatch\\\");\\n\\n            return amount;\\n        } else {\\n            require(msg.value == 0, \\\"don't support msg.value\\\");\\n            uint256 balanceBefore = ERC20Interface(underlying).balanceOf(\\n                address(this)\\n            );\\n            (bool success, bytes memory data) = underlying.call(\\n                abi.encodeWithSelector(\\n                    ERC20Interface.transferFrom.selector,\\n                    from,\\n                    address(this),\\n                    amount\\n                )\\n            );\\n            require(\\n                success && (data.length == 0 || abi.decode(data, (bool))),\\n                \\\"STF\\\"\\n            );\\n\\n            // Calculate the amount that was *actually* transferred\\n            uint256 balanceAfter = ERC20Interface(underlying).balanceOf(\\n                address(this)\\n            );\\n            require(\\n                balanceAfter >= balanceBefore,\\n                \\\"TOKEN_TRANSFER_IN_OVERFLOW\\\"\\n            );\\n            return balanceAfter - balanceBefore; // underflow already checked above, just subtract\\n        }\\n    }\\n\\n    function doTransferOut(\\n        address underlying,\\n        address payable to,\\n        uint256 amount\\n    ) internal {\\n        if (underlying == EthAddressLib.ethAddress()) {\\n            (bool success, ) = to.call{value: amount}(new bytes(0));\\n            require(success, \\\"STE\\\");\\n        } else {\\n            (bool success, bytes memory data) = underlying.call(\\n                abi.encodeWithSelector(\\n                    ERC20Interface.transfer.selector,\\n                    to,\\n                    amount\\n                )\\n            );\\n            require(\\n                success && (data.length == 0 || abi.decode(data, (bool))),\\n                \\\"ST\\\"\\n            );\\n        }\\n    }\\n\\n    function getCashPrior(address underlying_) internal view returns (uint256) {\\n        if (underlying_ == EthAddressLib.ethAddress()) {\\n            uint256 startingBalance = sub(address(this).balance, msg.value);\\n            return startingBalance;\\n        } else {\\n            ERC20Interface token = ERC20Interface(underlying_);\\n            return token.balanceOf(address(this));\\n        }\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solv/v2-helper/helpers/EthAddressLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nlibrary EthAddressLib {\\n\\n    /**\\n    * @dev returns the address used within the protocol to identify ETH\\n    * @return the address assigned to ETH\\n     */\\n    function ethAddress() internal pure returns(address) {\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    }\\n}\"\r\n    },\r\n    \"contracts/VestingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\nimport \\\"@solv/v2-helper/helpers/EthAddressLib.sol\\\";\\nimport \\\"@solv/v2-helper/helpers/ERC20TransferHelper.sol\\\";\\nimport \\\"./interface/IVestingPool.sol\\\";\\nimport \\\"./interface/IVNFTErc20Container.sol\\\";\\nimport \\\"./library/VestingLibrary.sol\\\";\\n\\ninterface IERC20Optional {\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n}\\n\\ncontract VestingPool is IVestingPool {\\n    using SafeMathUpgradeable for uint256;\\n    using SafeMathUpgradeable for uint64;\\n    using VestingLibrary for VestingLibrary.Vesting;\\n    using StringsUpgradeable for uint256;\\n    event NewManager(address oldManager, address newManager);\\n\\n    address internal _underlying;\\n    bool internal _initialized;\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    address public manager;\\n    uint256 internal _totalAmount;\\n\\n    // tokenId => Vault\\n    mapping(uint256 => VestingLibrary.Vesting) public vestingById;\\n\\n    // variables added in v2.1\\n    string internal _baseImageURI;\\n    string internal _baseExternalURI;\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        require(msg.sender == manager, \\\"only manager\\\");\\n        _;\\n    }\\n\\n    function initialize(address underlying_) public {\\n        require(_initialized == false, \\\"already initialized\\\");\\n        admin = msg.sender;\\n\\n        if (underlying_ != EthAddressLib.ethAddress()) {\\n            IERC20(underlying_).totalSupply();\\n        }\\n\\n        _underlying = underlying_;\\n        _initialized = true;\\n    }\\n\\n    function isVestingPool() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    function _setManager(address newManager_) public onlyAdmin {\\n        address oldManager = manager;\\n        manager = newManager_;\\n        emit NewManager(oldManager, newManager_);\\n    }\\n\\n    function _setBaseImageURI(string memory uri_) external onlyAdmin {\\n        _baseImageURI = uri_;\\n    }\\n\\n    function _setBaseExternalURI(string memory uri_) external onlyAdmin {\\n        _baseExternalURI = uri_;\\n    }\\n\\n    function mint(\\n        uint8 claimType_,\\n        address minter_,\\n        uint256 tokenId_,\\n        uint64 term_,\\n        uint256 amount_,\\n        uint64[] calldata maturities_,\\n        uint32[] calldata percentages_,\\n        string memory originalInvestor_\\n    ) external virtual override onlyManager returns (uint256) {\\n        return\\n            _mint(\\n                claimType_,\\n                minter_,\\n                tokenId_,\\n                term_,\\n                amount_,\\n                maturities_,\\n                percentages_,\\n                originalInvestor_\\n            );\\n    }\\n\\n    struct MintLocalVar {\\n        uint64 term;\\n        uint256 sumPercentages;\\n        uint256 mintPrincipal;\\n        uint256 mintUnits;\\n    }\\n\\n    function _mint(\\n        uint8 claimType_,\\n        address minter_,\\n        uint256 tokenId_,\\n        uint64 term_,\\n        uint256 amount_,\\n        uint64[] memory maturities_,\\n        uint32[] memory percentages_,\\n        string memory originalInvestor_\\n    ) internal virtual returns (uint256) {\\n        MintLocalVar memory vars;\\n        require(\\n            maturities_.length > 0 && maturities_.length == percentages_.length,\\n            \\\"invalid maturities/percentages\\\"\\n        );\\n\\n        if (claimType_ == VestingLibrary.CLAIM_TYPE_MULTI) {\\n            vars.term = _sub(\\n                maturities_[maturities_.length - 1],\\n                maturities_[0]\\n            );\\n            require(vars.term == term_, \\\"term mismatch\\\");\\n        }\\n\\n        for (uint256 i = 0; i < percentages_.length; i++) {\\n            vars.sumPercentages = vars.sumPercentages.add(percentages_[i]);\\n        }\\n        require(\\n            vars.sumPercentages == VestingLibrary.FULL_PERCENTAGE,\\n            \\\"invalid percentages\\\"\\n        );\\n\\n        ERC20TransferHelper.doTransferIn(_underlying, minter_, amount_);\\n        VestingLibrary.Vesting storage vesting = vestingById[tokenId_];\\n        (, vars.mintPrincipal) = vesting.mint(\\n            claimType_,\\n            term_,\\n            amount_,\\n            maturities_,\\n            percentages_,\\n            originalInvestor_\\n        );\\n\\n        vars.mintUnits = amount2units(vars.mintPrincipal);\\n\\n        emit MintVesting(\\n            claimType_,\\n            minter_,\\n            tokenId_,\\n            term_,\\n            maturities_,\\n            percentages_,\\n            amount_,\\n            amount_\\n        );\\n\\n        _totalAmount = _totalAmount.add(amount_);\\n\\n        return vars.mintUnits;\\n    }\\n\\n    function recharge(\\n        address recharger_,\\n        address owner_,\\n        uint256 tokenId_,\\n        uint256 amount_\\n    ) external virtual override onlyManager returns (uint256) {\\n        ERC20TransferHelper.doTransferIn(_underlying, recharger_, amount_);\\n        VestingLibrary.Vesting storage vesting = vestingById[tokenId_];\\n        vesting.recharge(amount_);\\n\\n        emit RechargeVesting(recharger_, owner_, tokenId_, amount_, amount_);\\n\\n        _totalAmount = _totalAmount.add(amount_);\\n        uint256 rechargeUnits = amount2units(amount_);\\n        return rechargeUnits;\\n    }\\n\\n    function claim(\\n        address payable payee,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) external virtual override onlyManager returns (uint256) {\\n        return _claim(payee, tokenId, amount);\\n    }\\n\\n    function claimableAmount(uint256 tokenId_)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        VestingLibrary.Vesting memory vesting = vestingById[tokenId_];\\n        if (!vesting.isValid) {\\n            return 0;\\n        }\\n\\n        if (\\n            vesting.claimType == VestingLibrary.CLAIM_TYPE_LINEAR ||\\n            vesting.claimType == VestingLibrary.CLAIM_TYPE_SINGLE\\n        ) {\\n            if (block.timestamp >= vesting.maturities[0]) {\\n                // 到期或过期\\n                return vesting.principal;\\n            }\\n            uint256 timeRemained = vesting.maturities[0] - block.timestamp;\\n            // 尚未开始解锁\\n            if (timeRemained >= vesting.term) {\\n                return 0;\\n            }\\n\\n            uint256 lockedAmount = vesting.vestingAmount.mul(timeRemained).div(\\n                vesting.term\\n            );\\n            if (lockedAmount > vesting.principal) {\\n                return 0;\\n            }\\n            return\\n                vesting.principal.sub(lockedAmount, \\\"claimable amount error\\\");\\n        } else if (vesting.claimType == VestingLibrary.CLAIM_TYPE_MULTI) {\\n            //尚未开始解锁\\n            if (block.timestamp < vesting.maturities[0]) {\\n                return 0;\\n            }\\n\\n            uint256 lockedPercentage;\\n            for (uint256 i = vesting.maturities.length - 1; i >= 0; i--) {\\n                if (vesting.maturities[i] <= block.timestamp) {\\n                    break;\\n                }\\n                lockedPercentage = lockedPercentage.add(vesting.percentages[i]);\\n            }\\n\\n            uint256 lockedAmount = vesting\\n            .vestingAmount\\n            .mul(lockedPercentage)\\n            .div(VestingLibrary.FULL_PERCENTAGE, \\\"locked amount error\\\");\\n            //避免先claim后再split，可能会因为精度导致locedAmount比principal多一点\\n            if (lockedAmount > vesting.principal) {\\n                return 0;\\n            }\\n            return\\n                vesting.principal.sub(lockedAmount, \\\"claimable amount error\\\");\\n        } else {\\n            revert(\\\"unsupported claimType\\\");\\n        }\\n    }\\n\\n    function _claim(\\n        address payable payee_,\\n        uint256 tokenId_,\\n        uint256 claimAmount_\\n    ) internal virtual returns (uint256) {\\n        require(claimAmount_ > 0, \\\"cannot claim 0\\\");\\n        require(claimAmount_ <= claimableAmount(tokenId_), \\\"over claim\\\");\\n\\n        VestingLibrary.Vesting storage v = vestingById[tokenId_];\\n\\n        require(claimAmount_ <= v.principal, \\\"insufficient principal\\\");\\n\\n        v.claim(claimAmount_);\\n\\n        ERC20TransferHelper.doTransferOut(_underlying, payee_, claimAmount_);\\n\\n        _totalAmount = _totalAmount.sub(claimAmount_);\\n\\n        emit ClaimVesting(payee_, tokenId_, claimAmount_);\\n        return amount2units(claimAmount_);\\n    }\\n\\n    function transferVesting(\\n        address from_,\\n        uint256 tokenId_,\\n        address to_,\\n        uint256 targetTokenId_,\\n        uint256 transferUnits_\\n    ) public virtual override onlyManager {\\n        uint256 transferAmount = units2amount(transferUnits_);\\n        (\\n            uint256 transferVestingAmount,\\n            uint256 transferPrincipal\\n        ) = vestingById[tokenId_].transfer(\\n            vestingById[targetTokenId_],\\n            transferAmount\\n        );\\n        emit TransferVesting(\\n            from_,\\n            tokenId_,\\n            to_,\\n            targetTokenId_,\\n            transferVestingAmount,\\n            transferPrincipal\\n        );\\n    }\\n\\n    function splitVesting(\\n        address owner_,\\n        uint256 tokenId_,\\n        uint256 newTokenId_,\\n        uint256 splitUnits_\\n    ) public virtual override onlyManager {\\n        uint256 splitAmount = units2amount(splitUnits_);\\n        (uint256 splitVestingAmount, uint256 splitPrincipal) = vestingById[\\n            tokenId_\\n        ]\\n        .split(vestingById[newTokenId_], splitAmount);\\n        emit SplitVesting(\\n            owner_,\\n            tokenId_,\\n            newTokenId_,\\n            splitVestingAmount,\\n            splitPrincipal\\n        );\\n    }\\n\\n    function mergeVesting(\\n        address owner_,\\n        uint256 tokenId_,\\n        uint256 targetTokenId_\\n    ) public virtual override onlyManager {\\n        (uint256 mergeVestingAmount, uint256 mergePrincipal) = vestingById[\\n            tokenId_\\n        ]\\n        .merge(vestingById[targetTokenId_]);\\n        delete vestingById[tokenId_];\\n        emit MergeVesting(\\n            owner_,\\n            tokenId_,\\n            targetTokenId_,\\n            mergeVestingAmount,\\n            mergePrincipal\\n        );\\n    }\\n\\n    function units2amount(uint256 units_)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return units_ * 1;\\n    }\\n\\n    function amount2units(uint256 amount_)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return amount_ / 1;\\n    }\\n\\n    function totalAmount() public view override returns (uint256) {\\n        return _totalAmount;\\n    }\\n\\n    struct VestingSnapShot {\\n        uint256 vestingAmount_;\\n        uint256 principal_;\\n        uint64[] maturities_;\\n        uint32[] percentages_;\\n        uint64 term_;\\n        uint8 claimType_;\\n        uint256 claimableAmount;\\n        bool isValid_;\\n        string originalInvestor_;\\n    }\\n\\n    function getVestingSnapshot(uint256 tokenId_)\\n        public\\n        view\\n        override\\n        returns (\\n            uint8,\\n            uint64,\\n            uint256,\\n            uint256,\\n            uint64[] memory,\\n            uint32[] memory,\\n            uint256,\\n            string memory,\\n            bool\\n        )\\n    {\\n        VestingSnapShot memory vars;\\n        vars.vestingAmount_ = vestingById[tokenId_].vestingAmount;\\n        vars.principal_ = vestingById[tokenId_].principal;\\n        vars.maturities_ = vestingById[tokenId_].maturities;\\n        vars.percentages_ = vestingById[tokenId_].percentages;\\n        vars.term_ = vestingById[tokenId_].term;\\n        vars.claimType_ = vestingById[tokenId_].claimType;\\n        vars.claimableAmount = claimableAmount(tokenId_);\\n        vars.isValid_ = vestingById[tokenId_].isValid;\\n        vars.originalInvestor_ = vestingById[tokenId_].originalInvestor;\\n        return (\\n            vars.claimType_,\\n            vars.term_,\\n            vars.vestingAmount_,\\n            vars.principal_,\\n            vars.maturities_,\\n            vars.percentages_,\\n            vars.claimableAmount,\\n            vars.originalInvestor_,\\n            vars.isValid_\\n        );\\n    }\\n\\n    function underlying() public view override returns (address) {\\n        return _underlying;\\n    }\\n\\n    function _setPendingAdmin(address newPendingAdmin) public {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    function _acceptAdmin() public {\\n        require(\\n            msg.sender == pendingAdmin && msg.sender != address(0),\\n            \\\"only pending admin\\\"\\n        );\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n\\n    function _add(uint64 a, uint64 b) internal pure returns (uint64) {\\n        uint64 c = a + b;\\n        require(c >= a, \\\"add-overflow\\\");\\n        return c;\\n    }\\n\\n    function _sub(uint64 a, uint64 b) internal pure returns (uint64) {\\n        require(b <= a, \\\"sub-overflow\\\");\\n        return a - b;\\n    }\\n\\n    struct UnderlyingInfo {\\n        address underlying;\\n        string symbol;\\n        uint8 decimals;\\n    }\\n\\n    function getInfo(uint256 tokenId, address owner, string memory tokenSymbol) \\n        external \\n        view \\n        override \\n        returns (string memory) \\n    {\\n        string memory underlyingSymbol;\\n        uint8 underlyingDecimals;\\n        if (_underlying == EthAddressLib.ethAddress()) {\\n            underlyingSymbol = \\\"ETH\\\";\\n            underlyingDecimals = 18;\\n        } else {\\n            underlyingSymbol = IERC20Optional(_underlying).symbol();\\n            underlyingDecimals = IERC20Optional(_underlying).decimals();\\n        }\\n\\n        UnderlyingInfo memory underlyingInfo = UnderlyingInfo(_underlying, underlyingSymbol, underlyingDecimals);\\n\\n        return string(\\n            abi.encodePacked(\\n                'data:application/json,',\\n                abi.encodePacked(\\n                    '{\\\"name\\\":\\\"', name(tokenId, underlyingSymbol, underlyingDecimals),\\n                    '\\\", \\\"description\\\":\\\"', description(tokenId, underlyingSymbol),\\n                    '\\\",\\\"image\\\": \\\"', _baseImageURI, tokenSymbol, '/', tokenId.toString(),\\n                    '.png\\\",\\\"external_url\\\":\\\"', _baseExternalURI, tokenSymbol, '/', tokenId.toString(),\\n                    '\\\", \\\"properties\\\": ', properties(tokenId, owner, underlyingInfo),\\n                    '}'\\n                )\\n            )\\n        );\\n    }\\n\\n    function name(uint256 tokenId, string memory underlyingSymbol, uint8 underlyingDecimals) \\n        internal \\n        view  \\n        returns (bytes memory) \\n    {\\n        uint8 claimType = vestingById[tokenId].claimType;\\n        uint256 principal = vestingById[tokenId].principal;\\n\\n        bytes memory typeName;\\n        if (claimType == 0) {\\n            typeName = 'Linear';\\n        } else if (claimType == 1) {\\n            typeName = 'OneTime';\\n        } else if (claimType == 2) {\\n            typeName = abi.encodePacked(vestingById[tokenId].maturities.length.toString(), ' Stages');\\n        } else {\\n            revert(\\\"unsupported claimType\\\");\\n        }\\n\\n        return \\n            abi.encodePacked(\\n                underlyingSymbol, ' Allocation Voucher #', tokenId.toString(), ' - ', \\n                trim(uint2decimal(principal, underlyingDecimals), underlyingDecimals - 2),\\n                ' - ', typeName\\n            );\\n    }\\n\\n    function description(uint256 tokenId, string memory underlyingSymbol) \\n        internal \\n        pure \\n        returns (bytes memory) \\n    {\\n        return \\n            abi.encodePacked(\\n                \\\"Voucher #\\\", tokenId.toString(), \\\" of \\\", underlyingSymbol, \\n                \\\" allocation. Voucher is used to represent the lock-up allocations of a certain project, which is currently being used to trade in the OTC Market. Now, everyone can trade \\\",\\n                underlyingSymbol, \\\"'s allocations on Opensea or Solv Vouchers by trading the Voucher onchain!\\\"\\n            );\\n    }\\n\\n    function properties(uint256 tokenId, address owner, UnderlyingInfo memory underlyingInfo) \\n        internal \\n        view \\n        returns (bytes memory) \\n    {\\n        bytes memory data = abi.encodePacked(\\n            '{\\\"owner\\\":\\\"', addressToString(owner),\\n            '\\\",\\\"underlying\\\":\\\"', addressToString(underlyingInfo.underlying),\\n            '\\\",\\\"underlyingSymbol\\\":\\\"', underlyingInfo.symbol,\\n            '\\\",\\\"vestingAmount\\\":\\\"', uint2decimal(vestingById[tokenId].vestingAmount, underlyingInfo.decimals),\\n            '\\\",\\\"principal\\\":\\\"', uint2decimal(vestingById[tokenId].principal, underlyingInfo.decimals),\\n            '\\\",\\\"claimType\\\":\\\"', uint2claimType(vestingById[tokenId].claimType),\\n            '\\\",\\\"claimableAmount\\\":\\\"', uint2decimal(claimableAmount(tokenId), underlyingInfo.decimals),\\n            '\\\",\\\"percentages\\\":', percentArray2str(vestingById[tokenId].percentages),\\n            ',\\\"maturities\\\":', uintArray2str(vestingById[tokenId].maturities)\\n        );\\n\\n        if (vestingById[tokenId].term > 0) {\\n            data = abi.encodePacked(data, ',\\\"term\\\":\\\"', second2day(vestingById[tokenId].term), ' days\\\"');\\n        }\\n\\n        bytes memory originalInvestor = bytes(vestingById[tokenId].originalInvestor);\\n        if (originalInvestor.length > 0) {\\n            data = abi.encodePacked(data, ',\\\"originalInvestor\\\":\\\"', originalInvestor, '\\\"');\\n        }\\n\\n        return abi.encodePacked(data, '}');\\n    }\\n\\n    function uintArray2str(uint64[] storage array) \\n        private \\n        view \\n        returns (bytes memory) \\n    {\\n        bytes memory pack = abi.encodePacked('[');\\n        for (uint256 i = 0; i < array.length; i++) {\\n            if (i == array.length - 1) {\\n                pack = abi.encodePacked(pack, uint256(array[i]).toString());\\n            } else {\\n                pack = abi.encodePacked(pack, uint256(array[i]).toString(), ',');\\n            }\\n        }\\n        return abi.encodePacked(pack, ']');\\n    }\\n\\n    function percentArray2str(uint32[] storage array) \\n        private \\n        view \\n        returns (string memory) \\n    {\\n        bytes memory pack = abi.encodePacked('[');\\n        for (uint256 i = 0; i < array.length; i++) {\\n            bytes memory percent = abi.encodePacked('\\\"', uint2decimal(array[i], 2), '%\\\"');\\n\\n            if (i == array.length - 1) {\\n                pack = abi.encodePacked(pack, percent);\\n            } else {\\n                pack = abi.encodePacked(pack, percent, ',');\\n            }\\n        }\\n        pack = abi.encodePacked(pack, ']');\\n        return string(pack);\\n    }\\n\\n    function uint2claimType(uint8 claimType) \\n        private\\n        pure \\n        returns (string memory) \\n    {\\n        return claimType == 0 ? 'Linear' : claimType == 1 ? 'OneTime' : claimType == 2 ? 'Staged' : 'unknown';\\n    }\\n\\n    function uint2decimal(uint256 number, uint8 decimals) \\n        private\\n        pure\\n        returns (bytes memory)\\n    {\\n        uint256 base = 10 ** decimals;\\n        string memory round = number.div(base).toString();\\n        string memory fraction = number.mod(base).toString();\\n        uint256 fractionLength = bytes(fraction).length;\\n\\n        bytes memory fullStr = abi.encodePacked(round, '.');\\n        if (fractionLength < decimals) {\\n            for (uint8 i = 0; i < decimals - fractionLength; i++) {\\n                fullStr = abi.encodePacked(fullStr, '0');\\n            }\\n        }\\n\\n        return abi.encodePacked(fullStr, fraction);\\n    }\\n\\n    function second2day(uint256 second)\\n        private\\n        pure\\n        returns (bytes memory)\\n    {\\n        return uint2decimal(second.div(864), 2);\\n    }\\n\\n    function trim(bytes memory oriString, uint256 cutLength) \\n        private \\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory newString = new bytes(oriString.length - cutLength);\\n        uint256 index = newString.length;\\n        while (index-- > 0) {\\n            newString[index] = oriString[index];\\n        }\\n        return newString;\\n    }\\n\\n    function addressToString(address _addr) \\n        private \\n        pure \\n        returns (string memory) \\n    {\\n        bytes32 value = bytes32(uint256(_addr));\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(42);\\n        str[0] = '0';\\n        str[1] = 'x';\\n        for (uint i = 0; i < 20; i++) {\\n            str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];\\n            str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n        }\\n        return string(str);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IUnderlyingContainer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\ninterface IUnderlyingContainer {\\n    function totalUnderlyingAmount() external view returns (uint256);\\n    function underlying() external view returns (address);\\n}\"\r\n    },\r\n    \"contracts/interface/IVNFTErc20Container.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@solv/solv-vnft-core/contracts/interface/IVNFT.sol\\\";\\nimport \\\"./IUnderlyingContainer.sol\\\";\\n\\ninterface IVNFTErc20Container is IVNFT, IUnderlyingContainer {\\n    function getUnderlyingAmount(uint256 units) external view returns (uint256 underlyingAmount);\\n    function getUnits(uint256 underlyingAmount) external view returns (uint256 units);\\n}\"\r\n    },\r\n    \"contracts/interface/IVestingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\ninterface IVestingPool {\\n   event NewAdmin(address oldAdmin, address newAdmin);\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n    event MintVesting(\\n        uint8 indexed claimType,\\n        address indexed minter,\\n        uint256 indexed tokenId,\\n        uint64 term,\\n        uint64[] maturities,\\n        uint32[] percentages,\\n        uint256 vestingAmount,\\n        uint256 principal\\n    );\\n    event ClaimVesting(\\n        address indexed payee,\\n        uint256 indexed tokenId,\\n        uint256 claimAmount\\n    );\\n    event RechargeVesting(\\n        address indexed recharger,\\n        address indexed owner,\\n        uint256 indexed tokenId,\\n        uint256 rechargeVestingAmount,\\n        uint256 rechargePrincipal\\n    );\\n    event TransferVesting(\\n        address indexed from,\\n        uint256 indexed tokenId,\\n        address indexed to,\\n        uint256 targetTokenId,\\n        uint256 transferVestingAmount,\\n        uint256 transferPrincipal\\n    );\\n    event SplitVesting(\\n        address indexed owner,\\n        uint256 indexed tokenId,\\n        uint256 newTokenId,\\n        uint256 splitVestingAmount,\\n        uint256 splitPricipal\\n    );\\n    event MergeVesting(\\n        address indexed owner,\\n        uint256 indexed tokenId,\\n        uint256 indexed targetTokenId,\\n        uint256 mergeVestingAmount,\\n        uint256 mergePrincipal\\n    );\\n\\n    function isVestingPool() external pure returns (bool);\\n\\n    function mint(\\n        uint8 claimType_,\\n        address minter_,\\n        uint256 tokenId_,\\n        uint64 term_,\\n        uint256 amount_,\\n        uint64[] calldata maturities_,\\n        uint32[] calldata percentages_,\\n        string memory originalInvestor_\\n    ) external returns (uint256 mintUnits);\\n\\n    function claim(address payable payee, uint256 tokenId,\\n        uint256 amount) external returns(uint256 claimUnit);\\n\\n    function claimableAmount(uint256 tokenId_)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function recharge(address recharger_, address owner_, uint256 tokenId_, uint256 amount_) \\n        external \\n        returns (uint256);\\n\\n    function transferVesting(\\n        address from_,\\n        uint256 tokenId_,\\n        address to_,\\n        uint256 targetTokenId_,\\n        uint256 transferUnits_\\n    ) external;\\n\\n    function splitVesting(address owner_, uint256 tokenId_, uint256 newTokenId_,\\n        uint256 splitUnits_) external;\\n\\n    function mergeVesting(address owner_, uint256 tokenId_,\\n        uint256 targetTokenId_) external;\\n\\n    function units2amount(uint256 units_) external view returns (uint256);\\n    function amount2units(uint256 units_) external view returns (uint256);\\n    function totalAmount() external view returns(uint256);\\n\\n    function getVestingSnapshot(uint256 tokenId_)\\n    external\\n    view\\n    returns (\\n        uint8 claimType_,\\n        uint64 term_,\\n        uint256 vestingAmount_,\\n        uint256 principal_,\\n        uint64[] memory maturities_,\\n        uint32[] memory percentages_,\\n        uint256 availableWithdrawAmount_,\\n        string memory originalInvestor_,\\n        bool isValid_\\n    );\\n\\n    function getInfo(uint256 tokenId, address owner, string memory tokenSymbol) external view returns (string memory);\\n\\n    function underlying() external view returns (address) ;\\n}\\n\"\r\n    },\r\n    \"contracts/library/VestingLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary VestingLibrary {\\n    using SafeMath for uint256;\\n\\n    uint32 constant internal FULL_PERCENTAGE = 10000;  // 释放比例基数，精确到小数点后两位\\n    uint8 constant internal CLAIM_TYPE_LINEAR = 0;\\n    uint8 constant internal CLAIM_TYPE_SINGLE = 1;\\n    uint8 constant internal CLAIM_TYPE_MULTI = 2;\\n\\n    struct Vesting {\\n        uint8 claimType; //0: 线性释放, 1: 单点释放, 2: 多点释放\\n        uint64 term; // 0 : Non-fixed term , 1 - N : fixed term in seconds\\n        uint64[] maturities; //到期时间（秒）\\n        uint32[] percentages;  //到期释放比例\\n        bool isValid; //是否有效\\n        uint256 vestingAmount;\\n        uint256 principal;\\n        string originalInvestor;\\n    }\\n\\n    function mint(\\n        Vesting storage self,\\n        uint8 claimType,\\n        uint64 term,\\n        uint256 amount,\\n        uint64[] memory maturities,\\n        uint32[] memory percentages,\\n        string memory originalInvestor\\n    ) internal returns (uint256, uint256) {\\n        require(! self.isValid, \\\"vesting already exists\\\");\\n        self.term = term;\\n        self.maturities = maturities;\\n        self.percentages = percentages;\\n        self.claimType = claimType;\\n        self.vestingAmount = amount;\\n        self.principal = amount;\\n        self.originalInvestor = originalInvestor;\\n        self.isValid = true;\\n        return (self.vestingAmount, self.principal);\\n    }\\n\\n    function claim(Vesting storage self, uint256 amount) internal {\\n        require(self.isValid, \\\"vesting not exists\\\");\\n        self.principal = self.principal.sub(amount, \\\"insufficient principal\\\");\\n    }\\n\\n    function recharge(Vesting storage self, uint256 amount) internal returns (uint256, uint256) {\\n        require(self.isValid, \\\"vesting not exists\\\");\\n        self.principal = self.principal.add(amount);\\n        self.vestingAmount = self.vestingAmount.add(amount);\\n        return (self.vestingAmount, self.principal);\\n    }\\n\\n    function merge(Vesting storage self, Vesting storage target) internal returns (uint256 mergeVestingAmount, uint256 mergePrincipal) {\\n        require(self.isValid && target.isValid, \\\"vesting not exists\\\");\\n        mergeVestingAmount = self.vestingAmount;\\n        mergePrincipal = self.principal;\\n        require(mergePrincipal <= mergeVestingAmount, \\\"balance error\\\");\\n        self.vestingAmount = 0;\\n        self.principal = 0;\\n        target.vestingAmount = target.vestingAmount.add(mergeVestingAmount);\\n        target.principal = target.principal.add(mergePrincipal);\\n        self.isValid = false;\\n        return (mergeVestingAmount, mergePrincipal);\\n    }\\n\\n    function split(Vesting storage source, Vesting storage create, uint256 amount) internal returns (uint256 splitVestingAmount, uint256 splitPrincipal){\\n        require(source.isValid, \\\"vesting not exists\\\");\\n        require(source.principal <= source.vestingAmount, \\\"balance error\\\");\\n        splitVestingAmount = source.vestingAmount.mul(amount).div(source.principal);\\n        source.vestingAmount = source.vestingAmount.sub(splitVestingAmount, \\\"split excess vestingAmount\\\");\\n        source.principal = source.principal.sub(amount, \\\"split excess principal\\\");\\n        mint(create, source.claimType, source.term, 0, source.maturities, source.percentages, source.originalInvestor);\\n        create.vestingAmount = splitVestingAmount;\\n        create.principal = amount;\\n        return (splitVestingAmount, amount);\\n    }\\n\\n    function transfer(Vesting storage source, Vesting storage target, uint256 amount ) internal returns (uint256 transferVestingAmount, uint256 transferPrincipal){\\n        require(source.isValid, \\\"vesting not exists\\\");\\n        transferPrincipal = amount;\\n        transferVestingAmount = source.vestingAmount.mul(transferPrincipal).div(source.principal);\\n        source.principal = source.principal.sub(transferPrincipal, \\\"transfer excess principal\\\");\\n        source.vestingAmount = source.vestingAmount.sub(transferVestingAmount, \\\"transfer excess vestingAmount\\\");\\n        if (! target.isValid) {\\n            mint(target, source.claimType, source.term, 0, source.maturities, source.percentages, \\\"\\\");\\n        }\\n        target.vestingAmount = target.vestingAmount.add(transferVestingAmount);\\n        target.principal = target.principal.add(transferPrincipal);\\n        return (transferVestingAmount, transferPrincipal);\\n    }\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mergeVestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mergePrincipal\",\"type\":\"uint256\"}],\"name\":\"MergeVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"claimType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"term\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"maturities\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"percentages\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"}],\"name\":\"MintVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"NewManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recharger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rechargeVestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rechargePrincipal\",\"type\":\"uint256\"}],\"name\":\"RechargeVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"splitVestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"splitPricipal\",\"type\":\"uint256\"}],\"name\":\"SplitVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferVestingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferPrincipal\",\"type\":\"uint256\"}],\"name\":\"TransferVesting\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"}],\"name\":\"_setBaseExternalURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"}],\"name\":\"_setBaseImageURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager_\",\"type\":\"address\"}],\"name\":\"_setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"amount2units\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"claimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"name\":\"getInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getVestingSnapshot\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"},{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVestingPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenId_\",\"type\":\"uint256\"}],\"name\":\"mergeVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"claimType_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"term_\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint64[]\",\"name\":\"maturities_\",\"type\":\"uint64[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentages_\",\"type\":\"uint32[]\"},{\"internalType\":\"string\",\"name\":\"originalInvestor_\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recharger_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"recharge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newTokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitUnits_\",\"type\":\"uint256\"}],\"name\":\"splitVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferUnits_\",\"type\":\"uint256\"}],\"name\":\"transferVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"units_\",\"type\":\"uint256\"}],\"name\":\"units2amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingById\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"claimType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"term\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"vestingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"originalInvestor\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VestingPool","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}