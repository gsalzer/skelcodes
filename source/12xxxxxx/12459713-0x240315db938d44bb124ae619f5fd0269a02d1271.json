{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.2;\r\n\r\n/*******************************************************\r\n *                     Ownable\r\n *******************************************************/\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\n\r\n/*******************************************************\r\n *                       Interfaces\r\n *******************************************************/\r\ninterface IV2Vault {\r\n    function token() external view returns (address);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function totalAssets() external view returns (uint256);\r\n\r\n    function apiVersion() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function emergencyShutdown() external view returns (bool);\r\n\r\n    function depositLimit() external view returns (uint256);\r\n}\r\n\r\ninterface IV2Registry {\r\n    function numTokens() external view returns (uint256);\r\n\r\n    function numVaults(address token) external view returns (uint256);\r\n\r\n    function tokens(uint256 tokenIdx) external view returns (address);\r\n\r\n    function latestVault(address token) external view returns (address);\r\n\r\n    function vaults(address token, uint256 tokenIdx)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\ninterface IAddressesGenerator {\r\n    function assetsAddresses() external view returns (address[] memory);\r\n\r\n    function assetsLength() external view returns (uint256);\r\n\r\n    function registry() external view returns (address);\r\n\r\n    function getPositionSpenderAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n}\r\n\r\ninterface IOracle {\r\n    function getNormalizedValueUsdc(address tokenAddress, uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getPriceUsdcRecommended(address tokenAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address spender, address owner)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IHelper {\r\n    // Strategies helper\r\n    function assetStrategiesDelegatedBalance(address)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    // Allowances helper\r\n    struct Allowance {\r\n        address owner;\r\n        address spender;\r\n        uint256 amount;\r\n        address token;\r\n    }\r\n\r\n    function allowances(\r\n        address ownerAddress,\r\n        address[] memory tokensAddresses,\r\n        address[] memory spenderAddresses\r\n    ) external view returns (Allowance[] memory);\r\n}\r\n\r\n/*******************************************************\r\n *                     Adapter Logic\r\n *******************************************************/\r\ncontract RegisteryAdapterV2Vaults is Ownable {\r\n    /*******************************************************\r\n     *           Common code shared by all adapters\r\n     *******************************************************/\r\n    address public oracleAddress; // The oracle is used to fetch USDC normalized pricing data\r\n    address public helperAddress; // A helper utility is used for batch allowance fetching and address array merging\r\n    address public addressesGeneratorAddress; // A utility for fetching assets addresses and length\r\n    address[] private _extensionsAddresses; // Optional contract extensions provide a way to add new features at a later date\r\n\r\n    /**\r\n     * High level static information about an asset\r\n     */\r\n    struct AssetStatic {\r\n        address id; // Asset address\r\n        string typeId; // Asset typeId (for example \"VAULT_V2\" or \"IRON_BANK_MARKET\")\r\n        address tokenId; // Underlying token address\r\n        string name; // Asset Name\r\n        string version; // Asset version\r\n        string symbol; // Asset symbol\r\n        uint8 decimals; // Asset decimals\r\n    }\r\n\r\n    /**\r\n     * High level dynamic information about an asset\r\n     */\r\n    struct AssetDynamic {\r\n        address id; // Asset address\r\n        string typeId; // Asset typeId (for example \"VAULT_V2\" or \"IRON_BANK_MARKET\")\r\n        address tokenId; // Underlying token address;\r\n        TokenAmount underlyingTokenBalance; // Underlying token balances\r\n        AssetMetadata metadata; // Metadata specific to the asset type of this adapter\r\n    }\r\n\r\n    /**\r\n     * Information about a user's position relative to an asset\r\n     */\r\n    struct Position {\r\n        address assetId; // Asset address\r\n        address tokenId; // Underlying asset token address\r\n        string typeId; // Position typeId (for example \"DEPOSIT,\" \"BORROW,\" \"LEND\")\r\n        uint256 balance; // asset.balanceOf(account)\r\n        TokenAmount underlyingTokenBalance; // Represents a user's asset position in underlying tokens\r\n        Allowance[] tokenAllowances; // Underlying token allowances\r\n        Allowance[] assetAllowances; // Asset allowances\r\n    }\r\n\r\n    /**\r\n     * Token amount representation\r\n     */\r\n    struct TokenAmount {\r\n        uint256 amount; // Amount in underlying token decimals\r\n        uint256 amountUsdc; // Amount in USDC (6 decimals)\r\n    }\r\n\r\n    /**\r\n     * Allowance information\r\n     */\r\n    struct Allowance {\r\n        address owner; // Allowance owner\r\n        address spender; // Allowance spender\r\n        uint256 amount; // Allowance amount (in underlying token)\r\n    }\r\n\r\n    /**\r\n     * Information about the adapter\r\n     */\r\n    struct AdapterInfo {\r\n        address id; // Adapter address\r\n        string typeId; // Adapter typeId (for example \"VAULT_V2\" or \"IRON_BANK_MARKET\")\r\n        string categoryId; // Adapter categoryId (for example \"VAULT\")\r\n    }\r\n\r\n    /**\r\n     * Fetch static information about an array of assets. This method can be used for off-chain pagination.\r\n     */\r\n    function assetsStatic(address[] memory _assetsAddresses)\r\n        public\r\n        view\r\n        returns (AssetStatic[] memory)\r\n    {\r\n        uint256 numberOfAssets = _assetsAddresses.length;\r\n        AssetStatic[] memory _assets = new AssetStatic[](numberOfAssets);\r\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\r\n            address assetAddress = _assetsAddresses[assetIdx];\r\n            AssetStatic memory _asset = assetStatic(assetAddress);\r\n            _assets[assetIdx] = _asset;\r\n        }\r\n        return _assets;\r\n    }\r\n\r\n    /**\r\n     * Fetch dynamic information about an array of assets. This method can be used for off-chain pagination.\r\n     */\r\n    function assetsDynamic(address[] memory _assetsAddresses)\r\n        public\r\n        view\r\n        returns (AssetDynamic[] memory)\r\n    {\r\n        uint256 numberOfAssets = _assetsAddresses.length;\r\n        AssetDynamic[] memory _assets = new AssetDynamic[](numberOfAssets);\r\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\r\n            address assetAddress = _assetsAddresses[assetIdx];\r\n            AssetDynamic memory _asset = assetDynamic(assetAddress);\r\n            _assets[assetIdx] = _asset;\r\n        }\r\n        return _assets;\r\n    }\r\n\r\n    /**\r\n     * Fetch static information for all assets\r\n     */\r\n    function assetsStatic() external view returns (AssetStatic[] memory) {\r\n        address[] memory _assetsAddresses = assetsAddresses();\r\n        return assetsStatic(_assetsAddresses);\r\n    }\r\n\r\n    /**\r\n     * Fetch dynamic information for all assets\r\n     */\r\n    function assetsDynamic() external view returns (AssetDynamic[] memory) {\r\n        address[] memory _assetsAddresses = assetsAddresses();\r\n        return assetsDynamic(_assetsAddresses);\r\n    }\r\n\r\n    /**\r\n     * Fetch underlying token allowances relative to an asset.\r\n     * This is useful for determining whether or not a user has token approvals\r\n     * to allow depositing into an asset\r\n     */\r\n    function tokenAllowances(address accountAddress, address assetAddress)\r\n        public\r\n        view\r\n        returns (Allowance[] memory)\r\n    {\r\n        address tokenAddress = assetUnderlyingTokenAddress(assetAddress);\r\n        address[] memory tokenAddresses = new address[](1);\r\n        address[] memory assetAddresses = new address[](1);\r\n        tokenAddresses[0] = tokenAddress;\r\n        assetAddresses[0] = assetAddress;\r\n        bytes memory allowances =\r\n            abi.encode(\r\n                IHelper(helperAddress).allowances(\r\n                    accountAddress,\r\n                    tokenAddresses,\r\n                    assetAddresses\r\n                )\r\n            );\r\n        return abi.decode(allowances, (Allowance[]));\r\n    }\r\n\r\n    /**\r\n     * Fetch asset allowances based on positionSpenderAddresses (configurable).\r\n     * This is useful to determine if a particular zap contract is approved for the asset (zap out use case)\r\n     */\r\n    function assetAllowances(address accountAddress, address assetAddress)\r\n        public\r\n        view\r\n        returns (Allowance[] memory)\r\n    {\r\n        address[] memory assetAddresses = new address[](1);\r\n        assetAddresses[0] = assetAddress;\r\n        bytes memory allowances =\r\n            abi.encode(\r\n                IHelper(helperAddress).allowances(\r\n                    accountAddress,\r\n                    assetAddresses,\r\n                    IAddressesGenerator(addressesGeneratorAddress)\r\n                        .getPositionSpenderAddresses()\r\n                )\r\n            );\r\n        return abi.decode(allowances, (Allowance[]));\r\n    }\r\n\r\n    /**\r\n     * Fetch the total number of assets for this adapter\r\n     */\r\n    function assetsLength() public view returns (uint256) {\r\n        return IAddressesGenerator(addressesGeneratorAddress).assetsLength();\r\n    }\r\n\r\n    /**\r\n     * Fetch all asset addresses for this adapter\r\n     */\r\n    function assetsAddresses() public view returns (address[] memory) {\r\n        return IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\r\n    }\r\n\r\n    /**\r\n     * Fetch registry address from addresses generator\r\n     */\r\n    function registryAddress() public view returns (address) {\r\n        return IAddressesGenerator(addressesGeneratorAddress).registry();\r\n    }\r\n\r\n    /**\r\n     * Allow storage slots to be manually updated\r\n     */\r\n    function updateSlot(bytes32 slot, bytes32 value) external onlyOwner {\r\n        assembly {\r\n            sstore(slot, value)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set optional fallback extension addresses\r\n     */\r\n    function setExtensionsAddresses(address[] memory _newExtensionsAddresses)\r\n        external\r\n        onlyOwner\r\n    {\r\n        _extensionsAddresses = _newExtensionsAddresses;\r\n    }\r\n\r\n    /**\r\n     * Fetch fallback extension addresses\r\n     */\r\n    function extensionsAddresses() external view returns (address[] memory) {\r\n        return (_extensionsAddresses);\r\n    }\r\n\r\n    /**\r\n     * Internal method for constructing a TokenAmount struct given a token balance and address\r\n     */\r\n    function tokenAmount(uint256 amount, address tokenAddress)\r\n        internal\r\n        view\r\n        returns (TokenAmount memory)\r\n    {\r\n        return\r\n            TokenAmount({\r\n                amount: amount,\r\n                amountUsdc: IOracle(oracleAddress).getNormalizedValueUsdc(\r\n                    tokenAddress,\r\n                    amount\r\n                )\r\n            });\r\n    }\r\n\r\n    /*******************************************************\r\n     * Common code shared by v1 vaults, v2 vaults and earn\r\n     *******************************************************/\r\n\r\n    /**\r\n     * Fetch asset positions of an account given an array of assets. This method can be used for off-chain pagination.\r\n     */\r\n    function assetsPositionsOf(\r\n        address accountAddress,\r\n        address[] memory _assetsAddresses\r\n    ) public view returns (Position[] memory) {\r\n        uint256 numberOfAssets = _assetsAddresses.length;\r\n        Position[] memory positions = new Position[](numberOfAssets);\r\n        uint256 currentPositionIdx;\r\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\r\n            address assetAddress = _assetsAddresses[assetIdx];\r\n            Position memory position =\r\n                assetPositionsOf(accountAddress, assetAddress)[0];\r\n            if (position.balance > 0) {\r\n                positions[currentPositionIdx] = position;\r\n                currentPositionIdx++;\r\n            }\r\n        }\r\n        bytes memory encodedData = abi.encode(positions);\r\n        assembly {\r\n            mstore(add(encodedData, 0x40), currentPositionIdx)\r\n        }\r\n        positions = abi.decode(encodedData, (Position[]));\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Fetch asset positions for an account for all assets\r\n     */\r\n    function assetsPositionsOf(address accountAddress)\r\n        public\r\n        view\r\n        returns (Position[] memory)\r\n    {\r\n        address[] memory _assetsAddresses = assetsAddresses();\r\n        return assetsPositionsOf(accountAddress, _assetsAddresses);\r\n    }\r\n\r\n    /*******************************************************\r\n     *                 V2 Adapter (unique logic)\r\n     *******************************************************/\r\n    /**\r\n     * Configure adapter\r\n     */\r\n    constructor(\r\n        address _oracleAddress,\r\n        address _helperAddress,\r\n        address _addressesGeneratorAddress\r\n    ) {\r\n        require(_oracleAddress != address(0), \"Missing oracle address\");\r\n        oracleAddress = _oracleAddress;\r\n        addressesGeneratorAddress = _addressesGeneratorAddress;\r\n        helperAddress = _helperAddress;\r\n    }\r\n\r\n    /**\r\n     * Return information about the adapter\r\n     */\r\n    function adapterInfo() public view returns (AdapterInfo memory) {\r\n        return\r\n            AdapterInfo({\r\n                id: address(this),\r\n                typeId: \"VAULT_V2\",\r\n                categoryId: \"VAULT\"\r\n            });\r\n    }\r\n\r\n    // Position types supported by this adapter\r\n    string positionDeposit = \"DEPOSIT\";\r\n    string[] public supportedPositions = [positionDeposit];\r\n\r\n    /**\r\n     * Metadata specific to this asset type\r\n     */\r\n    struct AssetMetadata {\r\n        uint256 pricePerShare; // Vault pricePerShare\r\n        bool migrationAvailable; // True if a migration is available for this vault\r\n        address latestVaultAddress; // Latest vault migration address\r\n        uint256 depositLimit; // Deposit limit of asset\r\n        bool emergencyShutdown; // Vault is in emergency shutdown mode\r\n    }\r\n\r\n    /**\r\n     * High level adapter metadata scoped to a user\r\n     */\r\n    struct AdapterPosition {\r\n        uint256 balanceUsdc;\r\n    }\r\n\r\n    /**\r\n     * Metadata specific to an asset type scoped to a user.\r\n     * Not used in this adapter.\r\n     */\r\n    struct AssetUserMetadata {\r\n        address depositBalance;\r\n    }\r\n\r\n    /**\r\n     * Fetch asset metadata scoped to a user\r\n     */\r\n    function assetUserMetadata(address assetAddress, address accountAddress)\r\n        public\r\n        view\r\n        returns (AssetUserMetadata memory)\r\n    {}\r\n\r\n    /**\r\n     * Fetch asset metadata scoped to a user\r\n     */\r\n    function assetsUserMetadata(address accountAddress)\r\n        public\r\n        view\r\n        returns (AssetUserMetadata[] memory)\r\n    {}\r\n\r\n    /**\r\n     * Fetch the underlying token address of an asset\r\n     */\r\n    function assetUnderlyingTokenAddress(address assetAddress)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        IV2Vault vault = IV2Vault(assetAddress);\r\n        address tokenAddress = vault.token();\r\n        return tokenAddress;\r\n    }\r\n\r\n    /**\r\n     * Fetch static information about an asset\r\n     */\r\n    function assetStatic(address assetAddress)\r\n        public\r\n        view\r\n        returns (AssetStatic memory)\r\n    {\r\n        IV2Vault vault = IV2Vault(assetAddress);\r\n        address tokenAddress = assetUnderlyingTokenAddress(assetAddress);\r\n        return\r\n            AssetStatic({\r\n                id: assetAddress,\r\n                typeId: adapterInfo().typeId,\r\n                tokenId: tokenAddress,\r\n                name: vault.name(),\r\n                version: vault.apiVersion(),\r\n                symbol: vault.symbol(),\r\n                decimals: vault.decimals()\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch dynamic information about an asset\r\n     */\r\n    function assetDynamic(address assetAddress)\r\n        public\r\n        view\r\n        returns (AssetDynamic memory)\r\n    {\r\n        IV2Vault vault = IV2Vault(assetAddress);\r\n        address tokenAddress = assetUnderlyingTokenAddress(assetAddress);\r\n        uint256 totalSupply = vault.totalSupply();\r\n        uint256 pricePerShare = 0;\r\n        bool vaultHasShares = totalSupply != 0;\r\n        if (vaultHasShares) {\r\n            pricePerShare = vault.pricePerShare();\r\n        }\r\n\r\n        address latestVaultAddress =\r\n            IV2Registry(registryAddress()).latestVault(tokenAddress);\r\n        bool migrationAvailable = latestVaultAddress != assetAddress;\r\n\r\n        AssetMetadata memory metadata =\r\n            AssetMetadata({\r\n                pricePerShare: pricePerShare,\r\n                migrationAvailable: migrationAvailable,\r\n                latestVaultAddress: latestVaultAddress,\r\n                depositLimit: vault.depositLimit(),\r\n                emergencyShutdown: vault.emergencyShutdown()\r\n            });\r\n\r\n        uint256 balance = assetBalance(assetAddress);\r\n        TokenAmount memory underlyingTokenBalance =\r\n            tokenAmount(balance, tokenAddress);\r\n\r\n        return\r\n            AssetDynamic({\r\n                id: assetAddress,\r\n                typeId: adapterInfo().typeId,\r\n                tokenId: tokenAddress,\r\n                underlyingTokenBalance: underlyingTokenBalance,\r\n                metadata: metadata\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch asset positions of an account given an asset address\r\n     */\r\n    function assetPositionsOf(address accountAddress, address assetAddress)\r\n        public\r\n        view\r\n        returns (Position[] memory)\r\n    {\r\n        IV2Vault _asset = IV2Vault(assetAddress);\r\n        uint8 assetDecimals = _asset.decimals();\r\n        address tokenAddress = assetUnderlyingTokenAddress(assetAddress);\r\n        uint256 balance = _asset.balanceOf(accountAddress);\r\n        uint256 _underlyingTokenBalance =\r\n            (balance * _asset.pricePerShare()) / 10**assetDecimals;\r\n        Position[] memory positions = new Position[](1);\r\n        positions[0] = Position({\r\n            assetId: assetAddress,\r\n            tokenId: tokenAddress,\r\n            typeId: positionDeposit,\r\n            balance: balance,\r\n            underlyingTokenBalance: tokenAmount(\r\n                _underlyingTokenBalance,\r\n                tokenAddress\r\n            ),\r\n            tokenAllowances: tokenAllowances(accountAddress, assetAddress),\r\n            assetAllowances: assetAllowances(accountAddress, assetAddress)\r\n        });\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Fetch asset balance in underlying tokens\r\n     */\r\n    function assetBalance(address assetAddress) public view returns (uint256) {\r\n        IV2Vault vault = IV2Vault(assetAddress);\r\n        return vault.totalAssets();\r\n    }\r\n\r\n    /**\r\n     * Fetch high level information about an account\r\n     */\r\n    function adapterPositionOf(address accountAddress)\r\n        external\r\n        view\r\n        returns (AdapterPosition memory)\r\n    {\r\n        Position[] memory positions = assetsPositionsOf(accountAddress);\r\n        uint256 balanceUsdc;\r\n        for (\r\n            uint256 positionIdx;\r\n            positionIdx < positions.length;\r\n            positionIdx++\r\n        ) {\r\n            Position memory position = positions[positionIdx];\r\n            balanceUsdc += position.underlyingTokenBalance.amountUsdc;\r\n        }\r\n        return AdapterPosition({balanceUsdc: balanceUsdc});\r\n    }\r\n\r\n    /**\r\n     * Returns unique list of tokens associated with this adapter\r\n     */\r\n    function assetsTokensAddresses() public view returns (address[] memory) {\r\n        IV2Registry _registry = IV2Registry(registryAddress());\r\n        uint256 numberOfTokens = _registry.numTokens();\r\n        address[] memory _tokensAddresses = new address[](numberOfTokens);\r\n        for (uint256 tokenIdx = 0; tokenIdx < numberOfTokens; tokenIdx++) {\r\n            address tokenAddress = _registry.tokens(tokenIdx);\r\n            _tokensAddresses[tokenIdx] = tokenAddress;\r\n        }\r\n        return _tokensAddresses;\r\n    }\r\n\r\n    /**\r\n     * Cascading fallback proxy provides the contract with the ability to add new features at a later time\r\n     */\r\n    fallback() external {\r\n        for (uint256 i = 0; i < _extensionsAddresses.length; i++) {\r\n            address extension = _extensionsAddresses[i];\r\n            assembly {\r\n                let _target := extension\r\n                calldatacopy(0, 0, calldatasize())\r\n                let success := staticcall(\r\n                    gas(),\r\n                    _target,\r\n                    0,\r\n                    calldatasize(),\r\n                    0,\r\n                    0\r\n                )\r\n                returndatacopy(0, 0, returndatasize())\r\n                if success {\r\n                    return(0, returndatasize())\r\n                }\r\n            }\r\n        }\r\n        revert(\"Extensions: Fallback proxy failed to return data\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_helperAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressesGeneratorAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"adapterInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"categoryId\",\"type\":\"string\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AdapterInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"adapterPositionOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balanceUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AdapterPosition\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressesGeneratorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetAllowances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Allowance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetDynamic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"migrationAvailable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"latestVaultAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"emergencyShutdown\",\"type\":\"bool\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetDynamic\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetPositionsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Allowance[]\",\"name\":\"tokenAllowances\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Allowance[]\",\"name\":\"assetAllowances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Position[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetStatic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetStatic\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"assetUnderlyingTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"assetUserMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"depositBalance\",\"type\":\"address\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetUserMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsDynamic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"migrationAvailable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"latestVaultAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"emergencyShutdown\",\"type\":\"bool\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetDynamic[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assetsAddresses\",\"type\":\"address[]\"}],\"name\":\"assetsDynamic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"migrationAvailable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"latestVaultAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"emergencyShutdown\",\"type\":\"bool\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetDynamic[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_assetsAddresses\",\"type\":\"address[]\"}],\"name\":\"assetsPositionsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Allowance[]\",\"name\":\"tokenAllowances\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Allowance[]\",\"name\":\"assetAllowances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Position[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"assetsPositionsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUsdc\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.TokenAmount\",\"name\":\"underlyingTokenBalance\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Allowance[]\",\"name\":\"tokenAllowances\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Allowance[]\",\"name\":\"assetAllowances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Position[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsStatic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetStatic[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assetsAddresses\",\"type\":\"address[]\"}],\"name\":\"assetsStatic\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"id\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"typeId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetStatic[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsTokensAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"assetsUserMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"depositBalance\",\"type\":\"address\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.AssetUserMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extensionsAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"helperAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newExtensionsAddresses\",\"type\":\"address[]\"}],\"name\":\"setExtensionsAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supportedPositions\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"tokenAllowances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RegisteryAdapterV2Vaults.Allowance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"updateSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RegisteryAdapterV2Vaults","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000083d95e0d5f402511db06817aff3f9ea88224b0300000000000000000000000005aacd0d03096039ac4381cd814637e9fb7c34a6f000000000000000000000000437758d475f70249e03eda6be23684ad1fc375f0","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://33c3e68900f74b3c04db510e6dbdc95dfb8b80584f0c54731c8f9605f99fc580"}]}