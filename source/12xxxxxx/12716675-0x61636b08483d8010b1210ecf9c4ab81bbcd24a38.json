{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.3;\r\n\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\nlibrary Clones {\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create2(0, ptr, 0x37, salt)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create2 failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\r\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\r\n            mstore(add(ptr, 0x4c), salt)\r\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\r\n            predicted := keccak256(add(ptr, 0x37), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\r\n        return predictDeterministicAddress(implementation, salt, address(this));\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\ncontract Governance is ReentrancyGuard {\r\n\r\n\tuint constant public governance_challenging_period = 10 days;\r\n\tuint constant public governance_freeze_period = 30 days;\r\n\r\n\taddress public votingTokenAddress;\r\n\taddress public governedContractAddress;\r\n\r\n\tmapping(address => uint) public balances;\r\n\r\n\tVotedValue[] public votedValues;\r\n\tmapping(string => VotedValue) public votedValuesMap;\r\n\r\n\r\n\tconstructor(address _governedContractAddress, address _votingTokenAddress){\r\n\t\tinit(_governedContractAddress, _votingTokenAddress);\r\n\t}\r\n\r\n\tfunction init(address _governedContractAddress, address _votingTokenAddress) public {\r\n\t\trequire(governedContractAddress == address(0), \"governance already initialized\");\r\n\t\tgovernedContractAddress = _governedContractAddress;\r\n\t\tvotingTokenAddress = _votingTokenAddress;\r\n\t}\r\n\r\n\tfunction addressBelongsToGovernance(address addr) public view returns (bool) {\r\n\t\tfor (uint i = 0; i < votedValues.length; i++)\r\n\t\t\tif (address(votedValues[i]) == addr)\r\n\t\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction isUntiedFromAllVotes(address addr) public view returns (bool) {\r\n\t\tfor (uint i = 0; i < votedValues.length; i++)\r\n\t\t\tif (votedValues[i].hasVote(addr))\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction addVotedValue(string memory name, VotedValue votedValue) external {\r\n\t\trequire(msg.sender == governedContractAddress, \"not authorized\");\r\n\t\tvotedValues.push(votedValue);\r\n\t\tvotedValuesMap[name] = votedValue;\r\n\t}\r\n\r\n\r\n\t// deposit\r\n\r\n\tfunction deposit(uint amount) payable external {\r\n\t\tdeposit(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction deposit(address from, uint amount) nonReentrant payable public {\r\n\t\trequire(from == msg.sender || addressBelongsToGovernance(msg.sender), \"not allowed\");\r\n\t\tif (votingTokenAddress == address(0))\r\n\t\t\trequire(msg.value == amount, \"wrong amount received\");\r\n\t\telse {\r\n\t\t\trequire(msg.value == 0, \"don't send ETH\");\r\n\t\t\trequire(IERC20(votingTokenAddress).transferFrom(from, address(this), amount), \"failed to pull gov deposit\");\r\n\t\t}\r\n\t\tbalances[from] += amount;\r\n\t}\r\n\r\n\r\n\t// withdrawal functions\r\n\r\n\tfunction withdraw() external {\r\n\t\twithdraw(balances[msg.sender]);\r\n\t}\r\n\r\n\tfunction withdraw(uint amount) nonReentrant public {\r\n\t\trequire(amount > 0, \"zero withdrawal requested\");\r\n\t\trequire(amount <= balances[msg.sender], \"not enough balance\");\r\n\t\trequire(isUntiedFromAllVotes(msg.sender), \"some votes not removed yet\");\r\n\t\tbalances[msg.sender] -= amount;\r\n\t\tif (votingTokenAddress == address(0))\r\n\t\t\tpayable(msg.sender).transfer(amount);\r\n\t\telse\r\n\t\t\trequire(IERC20(votingTokenAddress).transfer(msg.sender, amount), \"failed to withdraw gov deposit\");\r\n\t}\r\n}\r\n\r\n\r\nabstract contract VotedValue is ReentrancyGuard {\r\n\tGovernance public governance;\r\n\tuint public challenging_period_start_ts;\r\n\tmapping(address => bool) public hasVote;\r\n\r\n\tconstructor(Governance _governance){\r\n\t\tgovernance = _governance;\r\n\t}\r\n\r\n\tfunction checkVoteChangeLock() view public {\r\n\t\trequire(challenging_period_start_ts + governance.governance_challenging_period() + governance.governance_freeze_period() < block.timestamp, \"you cannot change your vote yet\");\r\n\t}\r\n\r\n\tfunction checkChallengingPeriodExpiry() view public {\r\n\t\trequire(block.timestamp > challenging_period_start_ts + governance.governance_challenging_period(), \"challenging period not expired yet\");\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract GovernanceFactory {\r\n\r\n\taddress public governanceMaster;\r\n\r\n\tconstructor(address _governanceMaster) {\r\n\t\tgovernanceMaster = _governanceMaster;\r\n\t}\r\n\r\n\tfunction createGovernance(address governedContractAddress, address votingTokenAddress) external returns (Governance) {\r\n\t\tGovernance governance = Governance(Clones.clone(governanceMaster));\r\n\t\tgovernance.init(governedContractAddress, votingTokenAddress);\r\n\t\treturn governance;\r\n\t}\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governanceMaster\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governedContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"votingTokenAddress\",\"type\":\"address\"}],\"name\":\"createGovernance\",\"outputs\":[{\"internalType\":\"contract Governance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GovernanceFactory","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dd603fc2312a0e7ab01de2da83e7776af406dceb","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://1c1a37db9ba0aad2757b59ad86713377475188f2e7e1fac62427ba298bbc1c12"}]}