{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/burnHelper/BurnGasHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./IBurnGasHelper.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/Utils.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/Withdrawable.sol\\\";\\n\\n\\ncontract BurnGasHelper is IBurnGasHelper, Utils, Withdrawable {\\n\\n\\n    address public gasTokenAddr;\\n\\n    constructor(\\n        address _admin,\\n        address _gasToken\\n    ) public Withdrawable(_admin) {\\n        gasTokenAddr = _gasToken;\\n    }\\n\\n    function updateGasToken(address _gasToken) external onlyAdmin {\\n        gasTokenAddr = _gasToken;\\n    }\\n\\n    function getAmountGasTokensToBurn(\\n        uint256 gasTotalConsumption\\n    ) external override view returns(uint numGas, address gasToken) {\\n\\n        gasToken = gasTokenAddr;\\n        uint256 gas = gasleft();\\n        uint256 safeNumTokens = 0;\\n        if (gas >= 27710) {\\n            safeNumTokens = (gas - 27710) / 7020; // (1148 + 5722 + 150);\\n        }\\n\\n        uint256 gasSpent = 21000 + 16 * gasTotalConsumption;\\n        numGas = (gasSpent + 14154) / 41947;\\n\\n        numGas = minOf(safeNumTokens, numGas);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/burnHelper/IBurnGasHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\ninterface IBurnGasHelper {\\n    function getAmountGasTokensToBurn(uint256 gasTotalConsumption)\\n        external\\n        view\\n        returns (uint256 numGas, address gasToken);\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/Utils.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./IERC20Ext.sol\\\";\\n\\n\\n/**\\n * @title Kyber utility file\\n * mostly shared constants and rate calculation helpers\\n * inherited by most of kyber contracts.\\n * previous utils implementations are for previous solidity versions.\\n */\\ncontract Utils {\\n    /// Declared constants below to be used in tandem with\\n    /// getDecimalsConstant(), for gas optimization purposes\\n    /// which return decimals from a constant list of popular\\n    /// tokens.\\n    IERC20Ext internal constant ETH_TOKEN_ADDRESS = IERC20Ext(\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\\n    );\\n    IERC20Ext internal constant USDT_TOKEN_ADDRESS = IERC20Ext(\\n        0xdAC17F958D2ee523a2206206994597C13D831ec7\\n    );\\n    IERC20Ext internal constant DAI_TOKEN_ADDRESS = IERC20Ext(\\n        0x6B175474E89094C44Da98b954EedeAC495271d0F\\n    );\\n    IERC20Ext internal constant USDC_TOKEN_ADDRESS = IERC20Ext(\\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\\n    );\\n    IERC20Ext internal constant WBTC_TOKEN_ADDRESS = IERC20Ext(\\n        0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\\n    );\\n    IERC20Ext internal constant KNC_TOKEN_ADDRESS = IERC20Ext(\\n        0xdd974D5C2e2928deA5F71b9825b8b646686BD200\\n    );\\n    uint256 public constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\\n    uint256 internal constant PRECISION = (10**18);\\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\\n    uint256 internal constant MAX_DECIMALS = 18;\\n    uint256 internal constant ETH_DECIMALS = 18;\\n    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\\n\\n    mapping(IERC20Ext => uint256) internal decimals;\\n\\n    /// @dev Sets the decimals of a token to storage if not already set, and returns\\n    ///      the decimals value of the token. Prefer using this function over\\n    ///      getDecimals(), to avoid forgetting to set decimals in local storage.\\n    /// @param token The token type\\n    /// @return tokenDecimals The decimals of the token\\n    function getSetDecimals(IERC20Ext token) internal returns (uint256 tokenDecimals) {\\n        tokenDecimals = getDecimalsConstant(token);\\n        if (tokenDecimals > 0) return tokenDecimals;\\n\\n        tokenDecimals = decimals[token];\\n        if (tokenDecimals == 0) {\\n            tokenDecimals = token.decimals();\\n            decimals[token] = tokenDecimals;\\n        }\\n    }\\n\\n    /// @dev Get the balance of a user\\n    /// @param token The token type\\n    /// @param user The user's address\\n    /// @return The balance\\n    function getBalance(IERC20Ext token, address user) internal view returns (uint256) {\\n        if (token == ETH_TOKEN_ADDRESS) {\\n            return user.balance;\\n        } else {\\n            return token.balanceOf(user);\\n        }\\n    }\\n\\n    /// @dev Get the decimals of a token, read from the constant list, storage,\\n    ///      or from token.decimals(). Prefer using getSetDecimals when possible.\\n    /// @param token The token type\\n    /// @return tokenDecimals The decimals of the token\\n    function getDecimals(IERC20Ext token) internal view returns (uint256 tokenDecimals) {\\n        // return token decimals if has constant value\\n        tokenDecimals = getDecimalsConstant(token);\\n        if (tokenDecimals > 0) return tokenDecimals;\\n\\n        // handle case where token decimals is not a declared decimal constant\\n        tokenDecimals = decimals[token];\\n        // moreover, very possible that old tokens have decimals 0\\n        // these tokens will just have higher gas fees.\\n        return (tokenDecimals > 0) ? tokenDecimals : token.decimals();\\n    }\\n\\n    function calcDestAmount(\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 rate\\n    ) internal view returns (uint256) {\\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\\n    }\\n\\n    function calcSrcAmount(\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 destAmount,\\n        uint256 rate\\n    ) internal view returns (uint256) {\\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\\n    }\\n\\n    function calcDstQty(\\n        uint256 srcQty,\\n        uint256 srcDecimals,\\n        uint256 dstDecimals,\\n        uint256 rate\\n    ) internal pure returns (uint256) {\\n        require(srcQty <= MAX_QTY, \\\"srcQty > MAX_QTY\\\");\\n        require(rate <= MAX_RATE, \\\"rate > MAX_RATE\\\");\\n\\n        if (dstDecimals >= srcDecimals) {\\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \\\"dst - src > MAX_DECIMALS\\\");\\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\\n        } else {\\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \\\"src - dst > MAX_DECIMALS\\\");\\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\\n        }\\n    }\\n\\n    function calcSrcQty(\\n        uint256 dstQty,\\n        uint256 srcDecimals,\\n        uint256 dstDecimals,\\n        uint256 rate\\n    ) internal pure returns (uint256) {\\n        require(dstQty <= MAX_QTY, \\\"dstQty > MAX_QTY\\\");\\n        require(rate <= MAX_RATE, \\\"rate > MAX_RATE\\\");\\n\\n        //source quantity is rounded up. to avoid dest quantity being too low.\\n        uint256 numerator;\\n        uint256 denominator;\\n        if (srcDecimals >= dstDecimals) {\\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \\\"src - dst > MAX_DECIMALS\\\");\\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\\n            denominator = rate;\\n        } else {\\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \\\"dst - src > MAX_DECIMALS\\\");\\n            numerator = (PRECISION * dstQty);\\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\\n        }\\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\\n    }\\n\\n    function calcRateFromQty(\\n        uint256 srcAmount,\\n        uint256 destAmount,\\n        uint256 srcDecimals,\\n        uint256 dstDecimals\\n    ) internal pure returns (uint256) {\\n        require(srcAmount <= MAX_QTY, \\\"srcAmount > MAX_QTY\\\");\\n        require(destAmount <= MAX_QTY, \\\"destAmount > MAX_QTY\\\");\\n\\n        if (dstDecimals >= srcDecimals) {\\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \\\"dst - src > MAX_DECIMALS\\\");\\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\\n        } else {\\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \\\"src - dst > MAX_DECIMALS\\\");\\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\\n        }\\n    }\\n\\n    /// @dev save storage access by declaring token decimal constants\\n    /// @param token The token type\\n    /// @return token decimals\\n    function getDecimalsConstant(IERC20Ext token) internal pure returns (uint256) {\\n        if (token == ETH_TOKEN_ADDRESS) {\\n            return ETH_DECIMALS;\\n        } else if (token == USDT_TOKEN_ADDRESS) {\\n            return 6;\\n        } else if (token == DAI_TOKEN_ADDRESS) {\\n            return 18;\\n        } else if (token == USDC_TOKEN_ADDRESS) {\\n            return 6;\\n        } else if (token == WBTC_TOKEN_ADDRESS) {\\n            return 8;\\n        } else if (token == KNC_TOKEN_ADDRESS) {\\n            return 18;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? y : x;\\n    }\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/Withdrawable.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./IERC20Ext.sol\\\";\\nimport \\\"./PermissionGroups.sol\\\";\\n\\ncontract Withdrawable is PermissionGroups {\\n    using SafeERC20 for IERC20Ext;\\n\\n    event TokenWithdraw(IERC20Ext token, uint256 amount, address sendTo);\\n    event EtherWithdraw(uint256 amount, address sendTo);\\n\\n    constructor(address _admin) public PermissionGroups(_admin) {}\\n\\n    /**\\n     * @dev Withdraw all IERC20Ext compatible tokens\\n     * @param token IERC20Ext The address of the token contract\\n     */\\n    function withdrawToken(\\n        IERC20Ext token,\\n        uint256 amount,\\n        address sendTo\\n    ) external onlyAdmin {\\n        token.safeTransfer(sendTo, amount);\\n        emit TokenWithdraw(token, amount, sendTo);\\n    }\\n\\n    /**\\n     * @dev Withdraw Ethers\\n     */\\n    function withdrawEther(uint256 amount, address payable sendTo) external onlyAdmin {\\n        (bool success, ) = sendTo.call{value: amount}(\\\"\\\");\\n        require(success, \\\"withdraw failed\\\");\\n        emit EtherWithdraw(amount, sendTo);\\n    }\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/IERC20Ext.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n\\n/**\\n * @dev Interface extending ERC20 standard to include decimals() as\\n *      it is optional in the OpenZeppelin IERC20 interface.\\n */\\ninterface IERC20Ext is IERC20 {\\n    /**\\n     * @dev This function is required as Kyber requires to interact\\n     *      with token.decimals() with many of its operations.\\n     */\\n    function decimals() external view returns (uint8 digits);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/PermissionGroups.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ncontract PermissionGroups {\\n    uint256 internal constant MAX_GROUP_SIZE = 50;\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    mapping(address => bool) internal operators;\\n    mapping(address => bool) internal alerters;\\n    address[] internal operatorsGroup;\\n    address[] internal alertersGroup;\\n\\n    event AdminClaimed(address newAdmin, address previousAdmin);\\n\\n    event TransferAdminPending(address pendingAdmin);\\n\\n    event OperatorAdded(address newOperator, bool isAdd);\\n\\n    event AlerterAdded(address newAlerter, bool isAdd);\\n\\n    constructor(address _admin) public {\\n        require(_admin != address(0), \\\"admin 0\\\");\\n        admin = _admin;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(operators[msg.sender], \\\"only operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyAlerter() {\\n        require(alerters[msg.sender], \\\"only alerter\\\");\\n        _;\\n    }\\n\\n    function getOperators() external view returns (address[] memory) {\\n        return operatorsGroup;\\n    }\\n\\n    function getAlerters() external view returns (address[] memory) {\\n        return alertersGroup;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the pendingAdmin address.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdmin(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0), \\\"new admin 0\\\");\\n        emit TransferAdminPending(newAdmin);\\n        pendingAdmin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0), \\\"admin 0\\\");\\n        emit TransferAdminPending(newAdmin);\\n        emit AdminClaimed(newAdmin, admin);\\n        admin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\\n     */\\n    function claimAdmin() public {\\n        require(pendingAdmin == msg.sender, \\\"not pending\\\");\\n        emit AdminClaimed(pendingAdmin, admin);\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n\\n    function addAlerter(address newAlerter) public onlyAdmin {\\n        require(!alerters[newAlerter], \\\"alerter exists\\\"); // prevent duplicates.\\n        require(alertersGroup.length < MAX_GROUP_SIZE, \\\"max alerters\\\");\\n\\n        emit AlerterAdded(newAlerter, true);\\n        alerters[newAlerter] = true;\\n        alertersGroup.push(newAlerter);\\n    }\\n\\n    function removeAlerter(address alerter) public onlyAdmin {\\n        require(alerters[alerter], \\\"not alerter\\\");\\n        alerters[alerter] = false;\\n\\n        for (uint256 i = 0; i < alertersGroup.length; ++i) {\\n            if (alertersGroup[i] == alerter) {\\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\\n                alertersGroup.pop();\\n                emit AlerterAdded(alerter, false);\\n                break;\\n            }\\n        }\\n    }\\n\\n    function addOperator(address newOperator) public onlyAdmin {\\n        require(!operators[newOperator], \\\"operator exists\\\"); // prevent duplicates.\\n        require(operatorsGroup.length < MAX_GROUP_SIZE, \\\"max operators\\\");\\n\\n        emit OperatorAdded(newOperator, true);\\n        operators[newOperator] = true;\\n        operatorsGroup.push(newOperator);\\n    }\\n\\n    function removeOperator(address operator) public onlyAdmin {\\n        require(operators[operator], \\\"not operator\\\");\\n        operators[operator] = false;\\n\\n        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\\n            if (operatorsGroup[i] == operator) {\\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\\n                operatorsGroup.pop();\\n                emit OperatorAdded(operator, false);\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wrappers/AAVE/FetchAaveDataWrapper.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ILendingPoolV1.sol\\\";\\nimport \\\"./ILendingPoolV2.sol\\\";\\nimport \\\"./IFetchAaveDataWrapper.sol\\\";\\nimport \\\"./ILendingPoolCore.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/Withdrawable.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/IERC20Ext.sol\\\";\\n\\n\\n/// Fetch data for multiple users or reserves from AAVE\\n/// Checkout list deployed AAVE's contracts here\\n/// https://docs.aave.com/developers/deployed-contracts/deployed-contract-instances\\ncontract FetchAaveDataWrapper is Withdrawable, IFetchAaveDataWrapper {\\n    uint256 internal constant PRECISION = 10**18;\\n    uint256 internal constant RATE_PRECISION = 10**27;\\n\\n    constructor(address _admin) public Withdrawable(_admin) {}\\n\\n    function getReserves(address pool, bool isV1)\\n        external\\n        view\\n        override\\n        returns (address[] memory reserves)\\n    {\\n        if (isV1) {\\n            return ILendingPoolV1(pool).getReserves();\\n        }\\n        return ILendingPoolV2(pool).getReservesList();\\n    }\\n\\n    function getReservesConfigurationData(\\n        address pool,\\n        bool isV1,\\n        address[] calldata _reserves\\n    ) external view override returns (ReserveConfigData[] memory configsData) {\\n        configsData = new ReserveConfigData[](_reserves.length);\\n        for (uint256 i = 0; i < _reserves.length; i++) {\\n            if (isV1) {\\n                (\\n                    configsData[i].ltv,\\n                    configsData[i].liquidationThreshold,\\n                    configsData[i].liquidationBonus, // rate strategy address\\n                    ,\\n                    configsData[i].usageAsCollateralEnabled,\\n                    configsData[i].borrowingEnabled,\\n                    configsData[i].stableBorrowRateEnabled,\\n                    configsData[i].isActive\\n                ) = ILendingPoolV1(pool).getReserveConfigurationData(_reserves[i]);\\n                configsData[i].aTokenAddress = ILendingPoolCore(ILendingPoolV1(pool).core())\\n                    .getReserveATokenAddress(_reserves[i]);\\n            } else {\\n                IProtocolDataProvider provider = IProtocolDataProvider(pool);\\n                (\\n                    ,\\n                    // decimals\\n                    configsData[i].ltv,\\n                    configsData[i].liquidationThreshold,\\n                    configsData[i].liquidationBonus, // reserve factor\\n                    ,\\n                    configsData[i].usageAsCollateralEnabled,\\n                    configsData[i].borrowingEnabled,\\n                    configsData[i].stableBorrowRateEnabled,\\n                    configsData[i].isActive,\\n\\n                ) = provider.getReserveConfigurationData(_reserves[i]);\\n                (configsData[i].aTokenAddress, , ) = provider.getReserveTokensAddresses(\\n                    _reserves[i]\\n                );\\n            }\\n        }\\n    }\\n\\n    function getReservesData(\\n        address pool,\\n        bool isV1,\\n        address[] calldata _reserves\\n    ) external view override returns (ReserveData[] memory reservesData) {\\n        reservesData = new ReserveData[](_reserves.length);\\n        if (isV1) {\\n            ILendingPoolCore core = ILendingPoolCore(ILendingPoolV1(pool).core());\\n            for (uint256 i = 0; i < _reserves.length; i++) {\\n                reservesData[i].totalLiquidity = core.getReserveTotalLiquidity(_reserves[i]);\\n                reservesData[i].availableLiquidity = core.getReserveAvailableLiquidity(\\n                    _reserves[i]\\n                );\\n                reservesData[i].utilizationRate = core.getReserveUtilizationRate(_reserves[i]);\\n                reservesData[i].liquidityRate = core.getReserveCurrentLiquidityRate(_reserves[i]);\\n\\n                reservesData[i].totalBorrowsStable = core.getReserveTotalBorrowsStable(\\n                    _reserves[i]\\n                );\\n                reservesData[i].totalBorrowsVariable = core.getReserveTotalBorrowsVariable(\\n                    _reserves[i]\\n                );\\n\\n                reservesData[i].variableBorrowRate = core.getReserveCurrentVariableBorrowRate(\\n                    _reserves[i]\\n                );\\n                reservesData[i].stableBorrowRate = core.getReserveCurrentStableBorrowRate(\\n                    _reserves[i]\\n                );\\n                reservesData[i].averageStableBorrowRate = core\\n                    .getReserveCurrentAverageStableBorrowRate(_reserves[i]);\\n            }\\n        } else {\\n            IProtocolDataProvider provider = IProtocolDataProvider(pool);\\n            for (uint256 i = 0; i < _reserves.length; i++) {\\n                (\\n                    reservesData[i].availableLiquidity,\\n                    reservesData[i].totalBorrowsStable,\\n                    reservesData[i].totalBorrowsVariable,\\n                    reservesData[i].liquidityRate,\\n                    reservesData[i].variableBorrowRate,\\n                    reservesData[i].stableBorrowRate,\\n                    reservesData[i].averageStableBorrowRate,\\n                    ,\\n                    ,\\n\\n                ) = provider.getReserveData(_reserves[i]);\\n                (address aTokenAddress, , ) = provider.getReserveTokensAddresses(_reserves[i]);\\n                reservesData[i].availableLiquidity = IERC20Ext(_reserves[i]).balanceOf(\\n                    aTokenAddress\\n                );\\n\\n                reservesData[i].totalLiquidity =\\n                    reservesData[i].availableLiquidity +\\n                    reservesData[i].totalBorrowsStable +\\n                    reservesData[i].totalBorrowsVariable;\\n                if (reservesData[i].totalLiquidity > 0) {\\n                    reservesData[i].utilizationRate =\\n                        RATE_PRECISION -\\n                        (reservesData[i].availableLiquidity * RATE_PRECISION) /\\n                        reservesData[i].totalLiquidity;\\n                }\\n            }\\n        }\\n    }\\n\\n    function getUserAccountsData(\\n        address pool,\\n        bool isV1,\\n        address[] calldata _users\\n    ) external view override returns (UserAccountData[] memory accountsData) {\\n        accountsData = new UserAccountData[](_users.length);\\n\\n        for (uint256 i = 0; i < _users.length; i++) {\\n            accountsData[i] = getSingleUserAccountData(pool, isV1, _users[i]);\\n        }\\n    }\\n\\n    function getUserReservesData(\\n        address pool,\\n        bool isV1,\\n        address[] calldata _reserves,\\n        address _user\\n    ) external view override returns (UserReserveData[] memory userReservesData) {\\n        userReservesData = new UserReserveData[](_reserves.length);\\n        for (uint256 i = 0; i < _reserves.length; i++) {\\n            if (isV1) {\\n                userReservesData[i] = getSingleUserReserveDataV1(\\n                    ILendingPoolV1(pool),\\n                    _reserves[i],\\n                    _user\\n                );\\n            } else {\\n                userReservesData[i] = getSingleUserReserveDataV2(\\n                    IProtocolDataProvider(pool),\\n                    _reserves[i],\\n                    _user\\n                );\\n            }\\n        }\\n    }\\n\\n    function getUsersReserveData(\\n        address pool,\\n        bool isV1,\\n        address _reserve,\\n        address[] calldata _users\\n    ) external view override returns (UserReserveData[] memory userReservesData) {\\n        userReservesData = new UserReserveData[](_users.length);\\n        for (uint256 i = 0; i < _users.length; i++) {\\n            if (isV1) {\\n                userReservesData[i] = getSingleUserReserveDataV1(\\n                    ILendingPoolV1(pool),\\n                    _reserve,\\n                    _users[i]\\n                );\\n            } else {\\n                userReservesData[i] = getSingleUserReserveDataV2(\\n                    IProtocolDataProvider(pool),\\n                    _reserve,\\n                    _users[i]\\n                );\\n            }\\n        }\\n    }\\n\\n    function getSingleUserReserveDataV1(\\n        ILendingPoolV1 pool,\\n        address _reserve,\\n        address _user\\n    ) public view returns (UserReserveData memory data) {\\n        (\\n            data.currentATokenBalance,\\n            data.currentBorrowBalance,\\n            data.principalBorrowBalance,\\n            data.borrowRateMode,\\n            data.borrowRate,\\n            data.liquidityRate,\\n            data.originationFee,\\n            ,\\n            ,\\n            data.usageAsCollateralEnabled\\n        ) = pool.getUserReserveData(_reserve, _user);\\n        IERC20Ext aToken =\\n            IERC20Ext(ILendingPoolCore(pool.core()).getReserveATokenAddress(_reserve));\\n        uint256 totalSupply = aToken.totalSupply();\\n        if (totalSupply > 0) {\\n            data.poolShareInPrecision = aToken.balanceOf(_user) * RATE_PRECISION / totalSupply;\\n        }\\n    }\\n\\n    function getSingleUserReserveDataV2(\\n        IProtocolDataProvider provider,\\n        address _reserve,\\n        address _user\\n    ) public view returns (UserReserveData memory data) {\\n        {\\n            (\\n                data.currentATokenBalance,\\n                data.currentStableDebt,\\n                data.currentVariableDebt,\\n                data.principalStableDebt,\\n                data.scaledVariableDebt,\\n                data.stableBorrowRate,\\n                data.liquidityRate,\\n                ,\\n                data.usageAsCollateralEnabled\\n            ) = provider.getUserReserveData(_reserve, _user);\\n        }\\n        {\\n            (address aTokenAddress, , ) = provider.getReserveTokensAddresses(_reserve);\\n            uint256 totalSupply = IERC20Ext(aTokenAddress).totalSupply();\\n            if (totalSupply > 0) {\\n                data.poolShareInPrecision =\\n                    IERC20Ext(aTokenAddress).balanceOf(_user) * RATE_PRECISION /\\n                    totalSupply;\\n            }\\n        }\\n    }\\n\\n    function getSingleUserAccountData(\\n        address pool,\\n        bool isV1,\\n        address _user\\n    ) public view returns (UserAccountData memory data) {\\n        if (isV1) {\\n            (\\n                data.totalLiquidityETH,\\n                data.totalCollateralETH,\\n                data.totalBorrowsETH,\\n                data.totalFeesETH,\\n                data.availableBorrowsETH,\\n                data.currentLiquidationThreshold,\\n                data.ltv,\\n                data.healthFactor\\n            ) = ILendingPoolV1(pool).getUserAccountData(_user);\\n            return data;\\n        }\\n        (\\n            data.totalCollateralETH,\\n            data.totalBorrowsETH,\\n            data.availableBorrowsETH,\\n            data.currentLiquidationThreshold,\\n            data.ltv,\\n            data.healthFactor\\n        ) = ILendingPoolV2(pool).getUserAccountData(_user);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wrappers/AAVE/ILendingPoolV1.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\ninterface ILendingPoolV1{\\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external payable;\\n    function core() external view returns (address);\\n    function getReserves() external view returns (address[] memory);\\n    function getReserveConfigurationData(address _reserve)\\n        external\\n        view\\n        returns (\\n            uint256 ltv,\\n            uint256 liquidationThreshold,\\n            uint256 liquidationBonus,\\n            address rateStrategyAddress,\\n            bool usageAsCollateralEnabled,\\n            bool borrowingEnabled,\\n            bool stableBorrowRateEnabled,\\n            bool isActive\\n        );\\n    function getUserAccountData(address _user)\\n        external\\n        view\\n        returns (\\n            uint256 totalLiquidityETH,\\n            uint256 totalCollateralETH,\\n            uint256 totalBorrowsETH,\\n            uint256 totalFeesETH,\\n            uint256 availableBorrowsETH,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        );\\n\\n    function getUserReserveData(address _reserve, address _user)\\n        external\\n        view\\n        returns (\\n            uint256 currentATokenBalance,\\n            uint256 currentBorrowBalance,\\n            uint256 principalBorrowBalance,\\n            uint256 borrowRateMode,\\n            uint256 borrowRate,\\n            uint256 liquidityRate,\\n            uint256 originationFee,\\n            uint256 variableBorrowIndex,\\n            uint256 lastUpdateTimestamp,\\n            bool usageAsCollateralEnabled\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/wrappers/AAVE/ILendingPoolV2.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./DataTypes.sol\\\";\\nimport \\\"./IProtocolDataProvider.sol\\\";\\n\\ninterface ILendingPoolV2 {\\n  /**\\n   * @dev Returns the configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The configuration of the reserve\\n   **/\\n  function getConfiguration(address asset)\\n    external\\n    view\\n    returns (DataTypes.ReserveConfigurationMap memory);\\n\\n  /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset)\\n    external\\n    view\\n    returns (DataTypes.ReserveData memory);\\n\\n  /**\\n   * @dev Returns the user account data across all the reserves\\n   * @param user The address of the user\\n   * @return totalCollateralETH the total collateral in ETH of the user\\n   * @return totalDebtETH the total debt in ETH of the user\\n   * @return availableBorrowsETH the borrowing power left of the user\\n   * @return currentLiquidationThreshold the liquidation threshold of the user\\n   * @return ltv the loan to value of the user\\n   * @return healthFactor the current health factor of the user\\n   **/\\n  function getUserAccountData(address user)\\n    external\\n    view\\n    returns (\\n      uint256 totalCollateralETH,\\n      uint256 totalDebtETH,\\n      uint256 availableBorrowsETH,\\n      uint256 currentLiquidationThreshold,\\n      uint256 ltv,\\n      uint256 healthFactor\\n    );\\n\\n  /**\\n   * @dev Returns the configuration of the user across all the reserves\\n   * @param user The user address\\n   * @return The configuration of the user\\n   **/\\n  function getUserConfiguration(address user)\\n    external\\n    view\\n    returns (DataTypes.UserConfigurationMap memory);\\n\\n  function getReservesList() external view returns (address[] memory);\\n  function getAddressesProvider() external view returns (IProtocolDataProvider);\\n}\\n\"\r\n    },\r\n    \"contracts/wrappers/AAVE/IFetchAaveDataWrapper.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface IFetchAaveDataWrapper {\\n    struct ReserveConfigData {\\n        uint256 ltv;\\n        uint256 liquidationThreshold;\\n        uint256 liquidationBonus;\\n        bool usageAsCollateralEnabled;\\n        bool borrowingEnabled;\\n        bool stableBorrowRateEnabled;\\n        bool isActive;\\n        address aTokenAddress;\\n    }\\n\\n    struct ReserveData {\\n        uint256 availableLiquidity;\\n        uint256 totalBorrowsStable;\\n        uint256 totalBorrowsVariable;\\n        uint256 liquidityRate;\\n        uint256 variableBorrowRate;\\n        uint256 stableBorrowRate;\\n        uint256 averageStableBorrowRate;\\n        uint256 totalLiquidity;\\n        uint256 utilizationRate;\\n    }\\n\\n    struct UserAccountData {\\n        uint256 totalLiquidityETH; // only v1\\n        uint256 totalCollateralETH;\\n        uint256 totalBorrowsETH;\\n        uint256 totalFeesETH; // only v1\\n        uint256 availableBorrowsETH;\\n        uint256 currentLiquidationThreshold;\\n        uint256 ltv;\\n        uint256 healthFactor;\\n    }\\n\\n    struct UserReserveData {\\n        uint256 currentATokenBalance;\\n        uint256 liquidityRate;\\n        uint256 poolShareInPrecision;\\n        bool usageAsCollateralEnabled;\\n        // v1 data\\n        uint256 currentBorrowBalance;\\n        uint256 principalBorrowBalance;\\n        uint256 borrowRateMode;\\n        uint256 borrowRate;\\n        uint256 originationFee;\\n        // v2 data\\n        uint256 currentStableDebt;\\n        uint256 currentVariableDebt;\\n        uint256 principalStableDebt;\\n        uint256 scaledVariableDebt;\\n        uint256 stableBorrowRate;\\n    }\\n\\n    function getReserves(address pool, bool isV1) external view returns (address[] memory);\\n    function getReservesConfigurationData(address pool, bool isV1, address[] calldata _reserves)\\n        external\\n        view\\n        returns (\\n            ReserveConfigData[] memory configsData\\n        );\\n\\n    function getReservesData(address pool, bool isV1, address[] calldata _reserves)\\n        external\\n        view\\n        returns (\\n            ReserveData[] memory reservesData\\n        );\\n\\n    function getUserAccountsData(address pool, bool isV1, address[] calldata _users)\\n        external\\n        view\\n        returns (\\n            UserAccountData[] memory accountsData\\n        );\\n\\n    function getUserReservesData(address pool, bool isV1, address[] calldata _reserves, address _user)\\n        external\\n        view\\n        returns (\\n            UserReserveData[] memory userReservesData\\n        );\\n\\n    function getUsersReserveData(address pool, bool isV1, address _reserve, address[] calldata _users)\\n        external\\n        view\\n        returns (\\n            UserReserveData[] memory userReservesData\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/wrappers/AAVE/ILendingPoolCore.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\ninterface ILendingPoolCore {\\n    function getReserveATokenAddress(address _reserve) external view returns (address);\\n    function getReserveTotalLiquidity(address _reserve) external view returns (uint256);\\n    function getReserveAvailableLiquidity(address _reserve) external view returns (uint256);\\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256);\\n    function getReserveUtilizationRate(address _reserve) external view returns (uint256);\\n\\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256);\\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256);\\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256);\\n    function getReserveCurrentStableBorrowRate(address _reserve) external view returns (uint256);\\n    function getReserveCurrentAverageStableBorrowRate(address _reserve) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/wrappers/AAVE/DataTypes.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nlibrary DataTypes {\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    uint256 data;\\n  }\\n\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\n}\\n\"\r\n    },\r\n    \"contracts/wrappers/AAVE/IProtocolDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface IProtocolDataProvider {\\n  struct TokenData {\\n    string symbol;\\n    address tokenAddress;\\n  }\\n\\n  function getAllReservesTokens() external view returns (TokenData[] memory);\\n  function getAllATokens() external view returns (TokenData[] memory);\\n  function getReserveConfigurationData(address asset)\\n    external view returns(\\n        uint256 decimals,\\n        uint256 ltv,\\n        uint256 liquidationThreshold,\\n        uint256 liquidationBonus,\\n        uint256 reserveFactor,\\n        bool usageAsCollateralEnabled,\\n        bool borrowingEnabled,\\n        bool stableBorrowRateEnabled,\\n        bool isActive,\\n        bool isFrozen\\n    );\\n  function getReserveData(address asset)\\n    external view returns (\\n        uint256 availableLiquidity,\\n        uint256 totalStableDebt,\\n        uint256 totalVariableDebt,\\n        uint256 liquidityRate,\\n        uint256 variableBorrowRate,\\n        uint256 stableBorrowRate,\\n        uint256 averageStableBorrowRate,\\n        uint256 liquidityIndex,\\n        uint256 variableBorrowIndex,\\n        uint40 lastUpdateTimestamp\\n    );\\n  function getUserReserveData(address asset, address user)\\n    external view returns (\\n        uint256 currentATokenBalance,\\n        uint256 currentStableDebt,\\n        uint256 currentVariableDebt,\\n        uint256 principalStableDebt,\\n        uint256 scaledVariableDebt,\\n        uint256 stableBorrowRate,\\n        uint256 liquidityRate,\\n        uint40 stableRateLastUpdated,\\n        bool usageAsCollateralEnabled\\n    );\\n  function getReserveTokensAddresses(address asset)\\n    external view returns (\\n        address aTokenAddress,\\n        address stableDebtTokenAddress,\\n        address variableDebtTokenAddress\\n    );\\n  function calculateUserGlobalData(address _user)\\n    external\\n    view\\n    returns (\\n        uint256 totalLiquidityBalanceETH,\\n        uint256 totalCollateralBalanceETH,\\n        uint256 totalBorrowBalanceETH,\\n        uint256 totalFeesETH,\\n        uint256 currentLtv,\\n        uint256 currentLiquidationThreshold,\\n        uint256 healthFactor,\\n        bool healthFactorBelowThreshold\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKyberProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@kyber.network/utils-sc/contracts/IERC20Ext.sol\\\";\\n\\n\\ninterface IKyberProxy {\\n\\n    function tradeWithHintAndFee(\\n        IERC20 src,\\n        uint256 srcAmount,\\n        IERC20 dest,\\n        address payable destAddress,\\n        uint256 maxDestAmount,\\n        uint256 minConversionRate,\\n        address payable platformWallet,\\n        uint256 platformFeeBps,\\n        bytes calldata hint\\n    ) external payable returns (uint256 destAmount);\\n\\n    function getExpectedRateAfterFee(\\n        IERC20 src,\\n        IERC20 dest,\\n        uint256 srcQty,\\n        uint256 platformFeeBps,\\n        bytes calldata hint\\n    ) external view returns (uint256 expectedRate);\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/SmartWalletSwapStorage.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../burnHelper/IBurnGasHelper.sol\\\";\\nimport \\\"../interfaces/IKyberProxy.sol\\\";\\nimport \\\"../interfaces/IGasToken.sol\\\";\\nimport \\\"../lending/ISmartWalletLending.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/IERC20Ext.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/Utils.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/Withdrawable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\n\\n\\ncontract SmartWalletSwapStorage is Utils, Withdrawable, ReentrancyGuard {\\n\\n    uint256 constant internal MAX_AMOUNT = uint256(-1);\\n\\n    mapping (address => mapping(IERC20Ext => uint256)) public platformWalletFees;\\n    // Proxy and routers will be set only once in constructor\\n    IKyberProxy public kyberProxy;\\n    // check if a router (Uniswap or its clones) is supported\\n    mapping(IUniswapV2Router02 => bool) public isRouterSupported;\\n\\n    IBurnGasHelper public burnGasHelper;\\n    mapping (address => bool) public supportedPlatformWallets;\\n\\n    struct TradeInput {\\n        uint256 srcAmount;\\n        uint256 minData; // min rate if Kyber, min return if Uni-pools\\n        address payable recipient;\\n        uint256 platformFeeBps;\\n        address payable platformWallet;\\n        bytes hint;\\n    }\\n\\n    ISmartWalletLending public lendingImpl;\\n\\n    // bytes32(uint256(keccak256(\\\"SmartWalletSwapImplementation\\\")) - 1)\\n    bytes32 internal constant IMPLEMENTATION = 0x6a7efb0627ddb0e69b773958c7c9c3c9c3dc049819cdf56a8ee84c3074b2a5d7;\\n\\n    constructor(address _admin) public Withdrawable(_admin) {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGasToken.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\ninterface IGasToken {\\n    function mint(uint256 value) external;\\n    function freeUpTo(uint256 value) external returns (uint256 freed);\\n\\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool success);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool success);\\n    function approve(address spender, uint256 value) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"contracts/lending/ISmartWalletLending.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@kyber.network/utils-sc/contracts/IERC20Ext.sol\\\";\\nimport \\\"../interfaces/IAaveLendingPoolV2.sol\\\";\\nimport \\\"../interfaces/IAaveLendingPoolV1.sol\\\";\\nimport \\\"../interfaces/IWeth.sol\\\";\\nimport \\\"../interfaces/ICompErc20.sol\\\";\\n\\n\\ninterface ISmartWalletLending {\\n\\n    event ClaimedComp(\\n        address[] holders,\\n        ICompErc20[] cTokens,\\n        bool borrowers,\\n        bool suppliers\\n    );\\n\\n    enum LendingPlatform { AAVE_V1, AAVE_V2, COMPOUND }\\n\\n    struct UserReserveData {\\n        uint256 currentATokenBalance;\\n        uint256 liquidityRate;\\n        uint256 poolShareInPrecision;\\n        bool usageAsCollateralEnabled;\\n        // Aave v1 data\\n        uint256 currentBorrowBalance;\\n        uint256 principalBorrowBalance;\\n        uint256 borrowRateMode;\\n        uint256 borrowRate;\\n        uint256 originationFee;\\n        // Aave v2 data\\n        uint256 currentStableDebt;\\n        uint256 currentVariableDebt;\\n        uint256 principalStableDebt;\\n        uint256 scaledVariableDebt;\\n        uint256 stableBorrowRate;\\n    }\\n\\n    function updateAaveLendingPoolData(\\n        IAaveLendingPoolV2 poolV2,\\n        IProtocolDataProvider provider,\\n        IAaveLendingPoolV1 poolV1,\\n        address lendingPoolCoreV1,\\n        uint16 referalCode,\\n        IWeth weth,\\n        IERC20Ext[] calldata tokens\\n    ) external;\\n\\n    function updateCompoundData(\\n        address _comptroller,\\n        address _cEth,\\n        address[] calldata _cTokens\\n    ) external;\\n\\n    function depositTo(\\n        LendingPlatform platform,\\n        address payable onBehalfOf,\\n        IERC20Ext token,\\n        uint256 amount\\n    ) external;\\n\\n    function borrowFrom(\\n        LendingPlatform platform,\\n        address payable onBehalfOf,\\n        IERC20Ext token,\\n        uint256 borrowAmount,\\n        uint256 interestRateMode\\n    ) external;\\n\\n    function withdrawFrom(\\n        LendingPlatform platform,\\n        address payable onBehalfOf,\\n        IERC20Ext token,\\n        uint256 amount,\\n        uint256 minReturn\\n    ) external returns (uint256 returnedAmount);\\n\\n    function repayBorrowTo(\\n        LendingPlatform platform,\\n        address payable onBehalfOf,\\n        IERC20Ext token,\\n        uint256 amount,\\n        uint256 payAmount,\\n        uint256 rateMode // only for aave v2\\n    ) external;\\n    \\n    function claimComp(\\n        address[] calldata holders,\\n        ICompErc20[] calldata cTokens,\\n        bool borrowers,\\n        bool suppliers\\n    ) external;\\n\\n    function storeAndRetrieveUserDebtCurrent(\\n        LendingPlatform platform,\\n        address _reserve,\\n        address _user\\n    ) external returns (uint256 debt);\\n\\n    function getLendingToken(LendingPlatform platform, IERC20Ext token) external view returns(address);\\n\\n    function getUserDebtStored(LendingPlatform platform, address reserve, address user)\\n        external\\n        view\\n        returns (uint256 debt);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveLendingPoolV2.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../wrappers/AAVE/DataTypes.sol\\\";\\nimport \\\"../wrappers/AAVE/IProtocolDataProvider.sol\\\";\\n\\n\\ninterface IAaveLendingPoolV2 {\\n    /**\\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n     * @param asset The address of the underlying asset to deposit\\n     * @param amount The amount to be deposited\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     **/\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n     * @param asset The address of the underlying asset to withdraw\\n     * @param amount The underlying amount to be withdrawn\\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n     * @param to Address that will receive the underlying, same as msg.sender if the user\\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n     *   different wallet\\n     * @return The final amount withdrawn\\n     **/\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n     * @param asset The address of the underlying asset to borrow\\n     * @param amount The amount to be borrowed\\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n     * if he has been given credit delegation allowance\\n     **/\\n    function borrow(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        uint16 referralCode,\\n        address onBehalfOf\\n    ) external;\\n\\n    /**\\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\n     * @param amount The amount to repay\\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n     * other borrower whose debt should be removed\\n     * @return The final amount repaid\\n     **/\\n    function repay(\\n        address asset,\\n        uint256 amount,\\n        uint256 rateMode,\\n        address onBehalfOf\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\n     * @param asset The address of the underlying asset deposited\\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\\n     **/\\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\n\\n    /**\\n     * @dev Returns the state and configuration of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The state of the reserve\\n     **/\\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveLendingPoolV1.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\ninterface IAaveLendingPoolV1 {\\n    function deposit(\\n        address _reserve,\\n        uint256 _amount,\\n        uint16 _referralCode\\n    ) external payable;\\n\\n    function borrow(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _interestRateMode,\\n        uint16 _referralCode\\n    ) external;\\n\\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external;\\n\\n    function repay(\\n        address _reserve,\\n        uint256 _amount,\\n        address payable _onBehalfOf\\n    ) external payable;\\n\\n    function core() external view returns (address);\\n\\n    function getUserReserveData(address _reserve, address _user)\\n        external\\n        view\\n        returns (\\n            uint256 currentATokenBalance,\\n            uint256 currentBorrowBalance,\\n            uint256 principalBorrowBalance,\\n            uint256 borrowRateMode,\\n            uint256 borrowRate,\\n            uint256 liquidityRate,\\n            uint256 originationFee,\\n            uint256 variableBorrowIndex,\\n            uint256 lastUpdateTimestamp,\\n            bool usageAsCollateralEnabled\\n        );\\n}\\n\\ninterface IAToken {\\n    function redeem(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWeth.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@kyber.network/utils-sc/contracts/IERC20Ext.sol\\\";\\n\\n\\ninterface IWeth is IERC20Ext {\\n    function deposit() external payable;\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICompErc20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\n\\ninterface ICompErc20 {\\n    function mint(uint mintAmount) external returns (uint);\\n    function redeem(uint redeemTokens) external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\n    function borrow(uint borrowAmount) external returns (uint);\\n    function repayBorrow(uint repayAmount) external returns (uint);\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\\n\\n    function transfer(address dst, uint amount) external returns (bool);\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\n    function approve(address spender, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function balanceOfUnderlying(address owner) external returns (uint);\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\n    function totalBorrowsCurrent() external returns (uint);\\n    function borrowBalanceCurrent(address account) external returns (uint);\\n    function borrowBalanceStored(address account) external view returns (uint);\\n    function exchangeRateCurrent() external returns (uint);\\n    function exchangeRateStored() external view returns (uint);\\n    function underlying() external view returns (address);\\n}\\n\\ninterface ICompEth {\\n    function mint() external payable;\\n    function repayBorrowBehalf(address borrower) external payable;\\n    function repayBorrow() external payable;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/SmartWalletSwapProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./SmartWalletSwapStorage.sol\\\";\\n\\n\\ncontract SmartWalletSwapProxy is SmartWalletSwapStorage {\\n    using Address for address;\\n\\n    event ImplementationUpdated(address indexed implementation);\\n\\n    constructor(\\n        address _admin,\\n        address _implementation,\\n        IKyberProxy _proxy,\\n        IUniswapV2Router02[] memory _routers\\n    ) public SmartWalletSwapStorage(_admin) {\\n        _setImplementation(_implementation);\\n        kyberProxy = _proxy;\\n        for (uint256 i = 0; i < _routers.length; i++) {\\n            isRouterSupported[_routers[i]] = true;\\n        }\\n    }\\n\\n    function updateNewImplementation(address _implementation) external onlyAdmin {\\n        _setImplementation(_implementation);\\n        emit ImplementationUpdated(_implementation);\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n     * @dev Delegates execution to an implementation contract.\\n     * It returns to the external caller whatever the implementation returns\\n     * or forwards reverts.\\n     */\\n    fallback() external payable {\\n        (bool success, ) = implementation().delegatecall(msg.data);\\n\\n        assembly {\\n            let free_mem_ptr := mload(0x40)\\n            returndatacopy(free_mem_ptr, 0, returndatasize())\\n            switch success\\n                case 0 {\\n                    revert(free_mem_ptr, returndatasize())\\n                }\\n                default {\\n                    return(free_mem_ptr, returndatasize())\\n                }\\n        }\\n    }\\n\\n    function implementation() public view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    function _setImplementation(address _implementation) internal {\\n        require(_implementation.isContract(), \\\"non-contract address\\\");\\n\\n        bytes32 slot = IMPLEMENTATION;\\n        assembly {\\n            sstore(slot, _implementation)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lending/SmartWalletLending.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../wrappers/AAVE/ILendingPoolCore.sol\\\";\\nimport \\\"../interfaces/IComptroller.sol\\\";\\nimport \\\"./ISmartWalletLending.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/Utils.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/Withdrawable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\n\\ncontract SmartWalletLending is ISmartWalletLending, Utils, Withdrawable {\\n    using SafeERC20 for IERC20Ext;\\n    using SafeMath for uint256;\\n\\n    struct AaveLendingPoolData {\\n        IAaveLendingPoolV2 lendingPoolV2;\\n        IProtocolDataProvider provider;\\n        mapping(IERC20Ext => address) aTokensV2;\\n        IWeth weth;\\n        IAaveLendingPoolV1 lendingPoolV1;\\n        mapping(IERC20Ext => address) aTokensV1;\\n        address lendingPoolCoreV1;\\n        uint16 referalCode;\\n    }\\n\\n    AaveLendingPoolData public aaveLendingPool;\\n\\n    struct CompoundData {\\n        address comptroller;\\n        mapping(IERC20Ext => address) cTokens;\\n    }\\n\\n    CompoundData public compoundData;\\n\\n    address public swapImplementation;\\n\\n    event UpdatedSwapImplementation(address indexed _oldSwapImpl, address indexed _newSwapImpl);\\n    event UpdatedAaveLendingPool(\\n        IAaveLendingPoolV2 poolV2,\\n        IProtocolDataProvider provider,\\n        IAaveLendingPoolV1 poolV1,\\n        address lendingPoolCoreV1,\\n        uint16 referalCode,\\n        IWeth weth,\\n        IERC20Ext[] tokens,\\n        address[] aTokensV1,\\n        address[] aTokensV2\\n    );\\n    event UpdatedCompoudData(\\n        address comptroller,\\n        address cEth,\\n        address[] cTokens,\\n        IERC20Ext[] underlyingTokens\\n    );\\n\\n    modifier onlySwapImpl() {\\n        require(msg.sender == swapImplementation, \\\"only swap impl\\\");\\n        _;\\n    }\\n\\n    constructor(address _admin) public Withdrawable(_admin) {}\\n\\n    receive() external payable {}\\n\\n    function updateSwapImplementation(address _swapImpl) external onlyAdmin {\\n        require(_swapImpl != address(0), \\\"invalid swap impl\\\");\\n        emit UpdatedSwapImplementation(swapImplementation, _swapImpl);\\n        swapImplementation = _swapImpl;\\n    }\\n\\n    function updateAaveLendingPoolData(\\n        IAaveLendingPoolV2 poolV2,\\n        IProtocolDataProvider provider,\\n        IAaveLendingPoolV1 poolV1,\\n        address lendingPoolCoreV1,\\n        uint16 referalCode,\\n        IWeth weth,\\n        IERC20Ext[] calldata tokens\\n    ) external override onlyAdmin {\\n        require(weth != IWeth(0), \\\"invalid weth\\\");\\n        aaveLendingPool.lendingPoolV2 = poolV2;\\n        aaveLendingPool.provider = provider;\\n        aaveLendingPool.lendingPoolV1 = poolV1;\\n        aaveLendingPool.lendingPoolCoreV1 = lendingPoolCoreV1;\\n        aaveLendingPool.referalCode = referalCode;\\n        aaveLendingPool.weth = weth;\\n\\n        address[] memory aTokensV1 = new address[](tokens.length);\\n        address[] memory aTokensV2 = new address[](tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            if (poolV1 != IAaveLendingPoolV1(0)) {\\n                // update data for pool v1\\n                try\\n                    ILendingPoolCore(poolV1.core()).getReserveATokenAddress(address(tokens[i]))\\n                returns (address aToken) {\\n                    aTokensV1[i] = aToken;\\n                } catch {}\\n                aaveLendingPool.aTokensV1[tokens[i]] = aTokensV1[i];\\n            }\\n            if (poolV2 != IAaveLendingPoolV2(0)) {\\n                address token =\\n                    tokens[i] == ETH_TOKEN_ADDRESS ? address(weth) : address(tokens[i]);\\n                // update data for pool v2\\n                try poolV2.getReserveData(token) returns (DataTypes.ReserveData memory data) {\\n                    aTokensV2[i] = data.aTokenAddress;\\n                } catch {}\\n                aaveLendingPool.aTokensV2[tokens[i]] = aTokensV2[i];\\n            }\\n        }\\n\\n        // do token approvals\\n        if (lendingPoolCoreV1 != address(0)) {\\n            for (uint256 j = 0; j < aTokensV1.length; j++) {\\n                safeApproveAllowance(lendingPoolCoreV1, tokens[j]);\\n            }\\n        }\\n        if (poolV2 != IAaveLendingPoolV2(0)) {\\n            for (uint256 j = 0; j < aTokensV1.length; j++) {\\n                safeApproveAllowance(address(poolV2), tokens[j]);\\n            }\\n        }\\n\\n        emit UpdatedAaveLendingPool(\\n            poolV2,\\n            provider,\\n            poolV1,\\n            lendingPoolCoreV1,\\n            referalCode,\\n            weth,\\n            tokens,\\n            aTokensV1,\\n            aTokensV2\\n        );\\n    }\\n\\n    function updateCompoundData(\\n        address _comptroller,\\n        address _cEth,\\n        address[] calldata _cTokens\\n    ) external override onlyAdmin {\\n        require(_comptroller != address(0), \\\"invalid _comptroller\\\");\\n        require(_cEth != address(0), \\\"invalid cEth\\\");\\n\\n        compoundData.comptroller = _comptroller;\\n        compoundData.cTokens[ETH_TOKEN_ADDRESS] = _cEth;\\n\\n        IERC20Ext[] memory tokens;\\n        if (_cTokens.length > 0) {\\n            // add specific markets\\n            tokens = new IERC20Ext[](_cTokens.length);\\n            for (uint256 i = 0; i < _cTokens.length; i++) {\\n                require(_cTokens[i] != address(0), \\\"invalid cToken\\\");\\n                tokens[i] = IERC20Ext(ICompErc20(_cTokens[i]).underlying());\\n                require(tokens[i] != IERC20Ext(0), \\\"invalid underlying token\\\");\\n                compoundData.cTokens[tokens[i]] = _cTokens[i];\\n\\n                // do token approvals\\n                safeApproveAllowance(_cTokens[i], tokens[i]);\\n            }\\n            emit UpdatedCompoudData(_comptroller, _cEth, _cTokens, tokens);\\n        } else {\\n            // add all markets\\n            ICompErc20[] memory markets = IComptroller(_comptroller).getAllMarkets();\\n            tokens = new IERC20Ext[](markets.length);\\n            address[] memory cTokens = new address[](markets.length);\\n            for (uint256 i = 0; i < markets.length; i++) {\\n                if (address(markets[i]) == _cEth) {\\n                    tokens[i] = ETH_TOKEN_ADDRESS;\\n                    cTokens[i] = _cEth;\\n                    continue;\\n                }\\n                require(markets[i] != ICompErc20(0), \\\"invalid cToken\\\");\\n                tokens[i] = IERC20Ext(markets[i].underlying());\\n                require(tokens[i] != IERC20Ext(0), \\\"invalid underlying token\\\");\\n                cTokens[i] = address(markets[i]);\\n                compoundData.cTokens[tokens[i]] = cTokens[i];\\n\\n                // do token approvals\\n                safeApproveAllowance(_cTokens[i], tokens[i]);\\n            }\\n            emit UpdatedCompoudData(_comptroller, _cEth, cTokens, tokens);\\n        }\\n    }\\n\\n    /// @dev deposit to lending platforms like AAVE, COMPOUND\\n    ///     expect amount of token should already be in the contract\\n    function depositTo(\\n        LendingPlatform platform,\\n        address payable onBehalfOf,\\n        IERC20Ext token,\\n        uint256 amount\\n    ) external override onlySwapImpl {\\n        require(getBalance(token, address(this)) >= amount, \\\"low balance\\\");\\n        if (platform == LendingPlatform.AAVE_V1) {\\n            IAaveLendingPoolV1 poolV1 = aaveLendingPool.lendingPoolV1;\\n            IERC20Ext aToken = IERC20Ext(aaveLendingPool.aTokensV1[token]);\\n            require(aToken != IERC20Ext(0), \\\"aToken not found\\\");\\n\\n            // deposit and compute received aToken amount\\n            uint256 aTokenBalanceBefore = aToken.balanceOf(address(this));\\n            poolV1.deposit{value: token == ETH_TOKEN_ADDRESS ? amount : 0}(\\n                address(token),\\n                amount,\\n                aaveLendingPool.referalCode\\n            );\\n            uint256 aTokenBalanceAfter = aToken.balanceOf(address(this));\\n            // transfer all received aToken back to the sender\\n            aToken.safeTransfer(onBehalfOf, aTokenBalanceAfter.sub(aTokenBalanceBefore));\\n        } else if (platform == LendingPlatform.AAVE_V2) {\\n            if (token == ETH_TOKEN_ADDRESS) {\\n                // wrap eth -> weth, then deposit\\n                IWeth weth = aaveLendingPool.weth;\\n                IAaveLendingPoolV2 pool = aaveLendingPool.lendingPoolV2;\\n                weth.deposit{value: amount}();\\n                pool.deposit(address(weth), amount, onBehalfOf, aaveLendingPool.referalCode);\\n            } else {\\n                IAaveLendingPoolV2 pool = aaveLendingPool.lendingPoolV2;\\n                pool.deposit(address(token), amount, onBehalfOf, aaveLendingPool.referalCode);\\n            }\\n        } else {\\n            // Compound\\n            address cToken = compoundData.cTokens[token];\\n            require(cToken != address(0), \\\"token is not supported by Compound\\\");\\n            uint256 cTokenBalanceBefore = IERC20Ext(cToken).balanceOf(address(this));\\n            if (token == ETH_TOKEN_ADDRESS) {\\n                ICompEth(cToken).mint{value: amount}();\\n            } else {\\n                require(ICompErc20(cToken).mint(amount) == 0, \\\"can not mint cToken\\\");\\n            }\\n            uint256 cTokenBalanceAfter = IERC20Ext(cToken).balanceOf(address(this));\\n            IERC20Ext(cToken).safeTransfer(\\n                onBehalfOf,\\n                cTokenBalanceAfter.sub(cTokenBalanceBefore)\\n            );\\n        }\\n    }\\n\\n    /// @dev borrow from lending platforms like AAVE v2, COMPOUND\\n    function borrowFrom(\\n        LendingPlatform platform,\\n        address payable onBehalfOf,\\n        IERC20Ext token,\\n        uint256 borrowAmount,\\n        uint256 interestRateMode\\n    ) external override onlySwapImpl {\\n        require(platform != LendingPlatform.AAVE_V1, \\\"Aave V1 not supported\\\");\\n\\n        if (platform == LendingPlatform.AAVE_V2) {\\n            IAaveLendingPoolV2 poolV2 = aaveLendingPool.lendingPoolV2;\\n            poolV2.borrow(\\n                address(token),\\n                borrowAmount,\\n                interestRateMode,\\n                aaveLendingPool.referalCode,\\n                onBehalfOf\\n            );\\n        }\\n    }\\n\\n    /// @dev withdraw from lending platforms like AAVE, COMPOUND\\n    ///     expect amount of aToken or cToken should already be in the contract\\n    function withdrawFrom(\\n        LendingPlatform platform,\\n        address payable onBehalfOf,\\n        IERC20Ext token,\\n        uint256 amount,\\n        uint256 minReturn\\n    ) external override onlySwapImpl returns (uint256 returnedAmount) {\\n        address lendingToken = getLendingToken(platform, token);\\n\\n        uint256 tokenBalanceBefore;\\n        uint256 tokenBalanceAfter;\\n        if (platform == LendingPlatform.AAVE_V1) {\\n            // burn aToken to withdraw underlying token\\n            tokenBalanceBefore = getBalance(token, address(this));\\n            IAToken(lendingToken).redeem(amount);\\n            tokenBalanceAfter = getBalance(token, address(this));\\n            returnedAmount = tokenBalanceAfter.sub(tokenBalanceBefore);\\n            require(returnedAmount >= minReturn, \\\"low returned amount\\\");\\n            // transfer token to user\\n            transferToken(onBehalfOf, token, returnedAmount);\\n        } else if (platform == LendingPlatform.AAVE_V2) {\\n            if (token == ETH_TOKEN_ADDRESS) {\\n                // withdraw weth, then convert to eth for user\\n                address weth = address(aaveLendingPool.weth);\\n                // withdraw underlying token from pool\\n                tokenBalanceBefore = IERC20Ext(weth).balanceOf(address(this));\\n                returnedAmount = aaveLendingPool.lendingPoolV2.withdraw(\\n                    weth,\\n                    amount,\\n                    address(this)\\n                );\\n                tokenBalanceAfter = IERC20Ext(weth).balanceOf(address(this));\\n                require(\\n                    tokenBalanceAfter.sub(tokenBalanceBefore) >= returnedAmount,\\n                    \\\"invalid return\\\"\\n                );\\n                require(returnedAmount >= minReturn, \\\"low returned amount\\\");\\n                // convert weth to eth and transfer to sender\\n                IWeth(weth).withdraw(returnedAmount);\\n                (bool success, ) = onBehalfOf.call{value: returnedAmount}(\\\"\\\");\\n                require(success, \\\"transfer eth to sender failed\\\");\\n            } else {\\n                // withdraw token directly to user's wallet\\n                tokenBalanceBefore = getBalance(token, onBehalfOf);\\n                returnedAmount = aaveLendingPool.lendingPoolV2.withdraw(\\n                    address(token),\\n                    amount,\\n                    onBehalfOf\\n                );\\n                tokenBalanceAfter = getBalance(token, onBehalfOf);\\n                // valid received amount in user's wallet\\n                require(\\n                    tokenBalanceAfter.sub(tokenBalanceBefore) >= returnedAmount,\\n                    \\\"invalid return\\\"\\n                );\\n                require(returnedAmount >= minReturn, \\\"low returned amount\\\");\\n            }\\n        } else {\\n            // COMPOUND\\n            // burn cToken to withdraw underlying token\\n            tokenBalanceBefore = getBalance(token, address(this));\\n            require(ICompErc20(lendingToken).redeem(amount) == 0, \\\"unable to redeem\\\");\\n            tokenBalanceAfter = getBalance(token, address(this));\\n            returnedAmount = tokenBalanceAfter.sub(tokenBalanceBefore);\\n            require(returnedAmount >= minReturn, \\\"low returned amount\\\");\\n            // transfer underlying token to user\\n            transferToken(onBehalfOf, token, returnedAmount);\\n        }\\n    }\\n\\n    /// @dev repay borrows to lending platforms like AAVE, COMPOUND\\n    ///     expect amount of token should already be in the contract\\n    ///     if amount > payAmount, (amount - payAmount) will be sent back to user\\n    function repayBorrowTo(\\n        LendingPlatform platform,\\n        address payable onBehalfOf,\\n        IERC20Ext token,\\n        uint256 amount,\\n        uint256 payAmount,\\n        uint256 rateMode // only for aave v2\\n    ) external override onlySwapImpl {\\n        require(amount >= payAmount, \\\"invalid pay amount\\\");\\n        require(getBalance(token, address(this)) >= amount, \\\"bad token balance\\\");\\n\\n        if (amount > payAmount) {\\n            // transfer back token\\n            transferToken(payable(onBehalfOf), token, amount - payAmount);\\n        }\\n        if (platform == LendingPlatform.AAVE_V1) {\\n            IAaveLendingPoolV1 poolV1 = aaveLendingPool.lendingPoolV1;\\n\\n            poolV1.repay{value: token == ETH_TOKEN_ADDRESS ? payAmount : 0}(\\n                address(token),\\n                payAmount,\\n                onBehalfOf\\n            );\\n        } else if (platform == LendingPlatform.AAVE_V2) {\\n            IAaveLendingPoolV2 poolV2 = aaveLendingPool.lendingPoolV2;\\n            if (token == ETH_TOKEN_ADDRESS) {\\n                IWeth weth = aaveLendingPool.weth;\\n                weth.deposit{value: payAmount}();\\n                require(\\n                    poolV2.repay(address(weth), payAmount, rateMode, onBehalfOf) == payAmount,\\n                    \\\"wrong paid amount\\\"\\n                );\\n            } else {\\n                require(\\n                    poolV2.repay(address(token), payAmount, rateMode, onBehalfOf) == payAmount,\\n                    \\\"wrong paid amount\\\"\\n                );\\n            }\\n        } else {\\n            // compound\\n            address cToken = compoundData.cTokens[token];\\n            require(cToken != address(0), \\\"token is not supported by Compound\\\");\\n            if (token == ETH_TOKEN_ADDRESS) {\\n                ICompEth(cToken).repayBorrowBehalf{value: payAmount}(onBehalfOf);\\n            } else {\\n                require(\\n                    ICompErc20(cToken).repayBorrowBehalf(onBehalfOf, payAmount) == 0,\\n                    \\\"compound repay error\\\"\\n                );\\n            }\\n        }\\n    }\\n\\n    function claimComp(\\n        address[] calldata holders,\\n        ICompErc20[] calldata cTokens,\\n        bool borrowers,\\n        bool suppliers\\n    ) external override onlySwapImpl {\\n        require(holders.length > 0, \\\"no holders\\\");\\n        IComptroller comptroller = IComptroller(compoundData.comptroller);\\n        if (cTokens.length == 0) {\\n            // claim for all markets\\n            ICompErc20[] memory markets = comptroller.getAllMarkets();\\n            comptroller.claimComp(holders, markets, borrowers, suppliers);\\n        } else {\\n            comptroller.claimComp(holders, cTokens, borrowers, suppliers);\\n        }\\n        emit ClaimedComp(holders, cTokens, borrowers, suppliers);\\n    }\\n\\n    function getLendingToken(LendingPlatform platform, IERC20Ext token)\\n        public\\n        view\\n        override\\n        returns (address)\\n    {\\n        if (platform == LendingPlatform.AAVE_V1) {\\n            return aaveLendingPool.aTokensV1[token];\\n        } else if (platform == LendingPlatform.AAVE_V2) {\\n            return aaveLendingPool.aTokensV2[token];\\n        }\\n        return compoundData.cTokens[token];\\n    }\\n\\n    /** @dev Calculate the current user debt and return\\n    */\\n    function storeAndRetrieveUserDebtCurrent(\\n        LendingPlatform platform,\\n        address _reserve,\\n        address _user\\n    ) external override returns (uint256 debt) {\\n        if (platform == LendingPlatform.AAVE_V1 || platform == LendingPlatform.AAVE_V2) {\\n            debt = getUserDebtStored(platform, _reserve, _user);\\n            return debt;\\n        }\\n        ICompErc20 cToken = ICompErc20(compoundData.cTokens[IERC20Ext(_reserve)]);\\n        debt = cToken.borrowBalanceCurrent(_user);\\n    }\\n\\n    /** @dev Return the stored user debt from given platform\\n    *   to get the latest data of user's debt for repaying, should call\\n    *   storeAndRetrieveUserDebtCurrent function, esp for Compound platform\\n    */\\n    function getUserDebtStored(\\n        LendingPlatform platform,\\n        address _reserve,\\n        address _user\\n    ) public view override returns (uint256 debt) {\\n        if (platform == LendingPlatform.AAVE_V1) {\\n            uint256 originationFee;\\n            IAaveLendingPoolV1 pool = aaveLendingPool.lendingPoolV1;\\n            (, debt, , , , , originationFee, , , ) = pool.getUserReserveData(_reserve, _user);\\n            debt = debt.add(originationFee);\\n        } else if (platform == LendingPlatform.AAVE_V2) {\\n            IProtocolDataProvider provider = aaveLendingPool.provider;\\n            (, uint256 stableDebt, uint256 variableDebt, , , , , , ) =\\n                provider.getUserReserveData(_reserve, _user);\\n            debt = stableDebt > 0 ? stableDebt : variableDebt;\\n        } else {\\n            ICompErc20 cToken = ICompErc20(compoundData.cTokens[IERC20Ext(_reserve)]);\\n            debt = cToken.borrowBalanceStored(_user);\\n        }\\n    }\\n\\n    function safeApproveAllowance(address spender, IERC20Ext token) internal {\\n        if (token != ETH_TOKEN_ADDRESS && token.allowance(address(this), spender) == 0) {\\n            token.safeApprove(spender, MAX_ALLOWANCE);\\n        }\\n    }\\n\\n    function transferToken(\\n        address payable recipient,\\n        IERC20Ext token,\\n        uint256 amount\\n    ) internal {\\n        if (token == ETH_TOKEN_ADDRESS) {\\n            (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n            require(success, \\\"failed to transfer eth\\\");\\n        } else {\\n            token.safeTransfer(recipient, amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IComptroller.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./ICompErc20.sol\\\";\\n\\n\\ninterface IComptroller {\\n    function getAllMarkets() external view returns (ICompErc20[] memory);\\n    function getCompAddress() external view returns (address);\\n    function claimComp(\\n        address[] calldata holders,\\n        ICompErc20[] calldata cTokens,\\n        bool borrowers,\\n        bool suppliers\\n    ) external;\\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISmartWalletSwapImplementation.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../lending/ISmartWalletLending.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/IERC20Ext.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\n\\n\\ninterface ISmartWalletSwapImplementation {\\n    event KyberTrade(\\n        address indexed trader,\\n        IERC20Ext indexed src,\\n        IERC20Ext indexed dest,\\n        uint256 srcAmount,\\n        uint256 destAmount,\\n        address recipient,\\n        uint256 platformFeeBps,\\n        address platformWallet,\\n        bytes hint,\\n        bool useGasToken,\\n        uint numGasBurns\\n    );\\n\\n    event UniswapTrade(\\n        address indexed trader,\\n        address indexed router,\\n        address[] tradePath,\\n        uint256 srcAmount,\\n        uint256 destAmount,\\n        address recipient,\\n        uint256 platformFeeBps,\\n        address platformWallet,\\n        bool feeInSrc,\\n        bool useGasToken,\\n        uint256 numGasBurns\\n    );\\n\\n    event KyberTradeAndDeposit(\\n        address indexed trader,\\n        ISmartWalletLending.LendingPlatform indexed platform,\\n        IERC20Ext src,\\n        IERC20Ext indexed dest,\\n        uint256 srcAmount,\\n        uint256 destAmount,\\n        uint256 platformFeeBps,\\n        address platformWallet,\\n        bytes hint,\\n        bool useGasToken,\\n        uint numGasBurns\\n    );\\n\\n    event UniswapTradeAndDeposit(\\n        address indexed trader,\\n        ISmartWalletLending.LendingPlatform indexed platform,\\n        IUniswapV2Router02 indexed router,\\n        address[] tradePath,\\n        uint256 srcAmount,\\n        uint256 destAmount,\\n        uint256 platformFeeBps,\\n        address platformWallet,\\n        bool useGasToken,\\n        uint256 numGasBurns\\n    );\\n\\n    event BorrowFromLending(\\n        ISmartWalletLending.LendingPlatform indexed platform,\\n        IERC20Ext token,\\n        uint256 amountBorrowed,\\n        uint256 interestRateMode,\\n        bool useGasToken,\\n        uint256 numGasBurns\\n    );\\n\\n    event WithdrawFromLending(\\n        ISmartWalletLending.LendingPlatform indexed platform,\\n        IERC20Ext token,\\n        uint256 amount,\\n        uint256 minReturn,\\n        uint256 actualReturnAmount,\\n        bool useGasToken,\\n        uint256 numGasBurns\\n    );\\n\\n    event KyberTradeAndRepay(\\n        address indexed trader,\\n        ISmartWalletLending.LendingPlatform indexed platform,\\n        IERC20Ext src,\\n        IERC20Ext indexed dest,\\n        uint256 srcAmount,\\n        uint256 destAmount,\\n        uint256 payAmount,\\n        uint256 feeAndRateMode,\\n        address platformWallet,\\n        bytes hint,\\n        bool useGasToken,\\n        uint numGasBurns\\n    );\\n\\n    event UniswapTradeAndRepay(\\n        address indexed trader,\\n        ISmartWalletLending.LendingPlatform indexed platform,\\n        IUniswapV2Router02 indexed router,\\n        address[] tradePath,\\n        uint256 srcAmount,\\n        uint256 destAmount,\\n        uint256 payAmount,\\n        uint256 feeAndRateMode,\\n        address platformWallet,\\n        bool useGasToken,\\n        uint256 numGasBurns\\n    );\\n\\n    function getExpectedReturnKyber(\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 platformFeeBps,\\n        bytes calldata hint\\n    ) external view returns (\\n        uint256 destAmount,\\n        uint256 expectedRate\\n    );\\n\\n    function getExpectedReturnUniswap(\\n        IUniswapV2Router02 router,\\n        uint256 srcAmount,\\n        address[] calldata tradePath,\\n        uint256 platformFeeBps\\n    ) external view returns (\\n        uint256 destAmount,\\n        uint256 expectedRate\\n    );\\n\\n    function swapKyber(\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 minConversionRate,\\n        address payable recipient,\\n        uint256 platformFeeBps,\\n        address payable platformWallet,\\n        bytes calldata hint,\\n        bool useGasToken\\n    ) external payable returns (uint256 destAmount);\\n\\n    function swapUniswap(\\n        IUniswapV2Router02 router,\\n        uint256 srcAmount,\\n        uint256 minDestAmount,\\n        address[] calldata tradePath,\\n        address payable recipient,\\n        uint256 platformFeeBps,\\n        address payable platformWallet,\\n        bool feeInSrc,\\n        bool useGasToken\\n    ) external payable returns (uint256 destAmount);\\n\\n    function swapKyberAndDeposit(\\n        ISmartWalletLending.LendingPlatform platform,\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 minConversionRate,\\n        uint256 platformFeeBps,\\n        address payable platformWallet,\\n        bytes calldata hint,\\n        bool useGasToken\\n    ) external payable returns (uint256 destAmount);\\n\\n    function swapUniswapAndDeposit(\\n        ISmartWalletLending.LendingPlatform platform,\\n        IUniswapV2Router02 router,\\n        uint256 srcAmount,\\n        uint256 minDestAmount,\\n        address[] calldata tradePath,\\n        uint256 platformFeeBps,\\n        address payable platformWallet,\\n        bool useGasToken\\n    ) external payable returns (uint256 destAmount);\\n\\n    function withdrawFromLendingPlatform(\\n        ISmartWalletLending.LendingPlatform platform,\\n        IERC20Ext token,\\n        uint256 amount,\\n        uint256 minReturn,\\n        bool useGasToken\\n    ) external returns (uint256 returnedAmount);\\n\\n    function swapKyberAndRepay(\\n        ISmartWalletLending.LendingPlatform platform,\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 payAmount,\\n        uint256 feeAndRateMode, // in case aave v2, fee: feeAndRateMode % BPS, rateMode: feeAndRateMode / BPS\\n        address payable platformWallet,\\n        bytes calldata hint,\\n        bool useGasToken\\n    ) external payable returns (uint256 destAmount);\\n\\n    function swapUniswapAndRepay(\\n        ISmartWalletLending.LendingPlatform platform,\\n        IUniswapV2Router02 router,\\n        uint256 srcAmount,\\n        uint256 payAmount,\\n        address[] calldata tradePath,\\n        uint256 feeAndRateMode, // in case aave v2, fee: feeAndRateMode % BPS, rateMode: feeAndRateMode / BPS\\n        address payable platformWallet,\\n        bool useGasToken\\n    ) external payable returns (uint256 destAmount);\\n\\n    function claimComp(\\n        address[] calldata holders,\\n        ICompErc20[] calldata cTokens,\\n        bool borrowers,\\n        bool suppliers,\\n        bool useGasToken\\n    ) external;\\n\\n    function claimPlatformFees(\\n        address[] calldata platformWallets,\\n        IERC20Ext[] calldata tokens\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/SmartWalletSwapImplementation.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"../interfaces/ISmartWalletSwapImplementation.sol\\\";\\nimport \\\"./SmartWalletSwapStorage.sol\\\";\\nimport \\\"@kyber.network/utils-sc/contracts/IERC20Ext.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\n\\ncontract SmartWalletSwapImplementation is SmartWalletSwapStorage, ISmartWalletSwapImplementation {\\n    using SafeERC20 for IERC20Ext;\\n    using SafeMath for uint256;\\n\\n    event UpdatedSupportedPlatformWallets(address[] wallets, bool isSupported);\\n    event UpdatedBurnGasHelper(IBurnGasHelper indexed gasHelper);\\n    event UpdatedLendingImplementation(ISmartWalletLending impl);\\n    event ApprovedAllowances(IERC20Ext[] tokens, address[] spenders, bool isReset);\\n    event ClaimedPlatformFees(address[] wallets, IERC20Ext[] tokens, address claimer);\\n\\n    constructor(address _admin) public SmartWalletSwapStorage(_admin) {}\\n\\n    receive() external payable {}\\n\\n    function updateBurnGasHelper(IBurnGasHelper _burnGasHelper) external onlyAdmin {\\n        if (burnGasHelper != _burnGasHelper) {\\n            burnGasHelper = _burnGasHelper;\\n            emit UpdatedBurnGasHelper(_burnGasHelper);\\n        }\\n    }\\n\\n    function updateLendingImplementation(ISmartWalletLending newImpl) external onlyAdmin {\\n        require(newImpl != ISmartWalletLending(0), \\\"invalid lending impl\\\");\\n        lendingImpl = newImpl;\\n        emit UpdatedLendingImplementation(newImpl);\\n    }\\n\\n    /// @dev to prevent other integrations to call trade from this contract\\n    function updateSupportedPlatformWallets(address[] calldata wallets, bool isSupported)\\n        external\\n        onlyAdmin\\n    {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            supportedPlatformWallets[wallets[i]] = isSupported;\\n        }\\n        emit UpdatedSupportedPlatformWallets(wallets, isSupported);\\n    }\\n\\n    function claimPlatformFees(address[] calldata platformWallets, IERC20Ext[] calldata tokens)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        for (uint256 i = 0; i < platformWallets.length; i++) {\\n            for (uint256 j = 0; j < tokens.length; j++) {\\n                uint256 fee = platformWalletFees[platformWallets[i]][tokens[j]];\\n                if (fee > 1) {\\n                    platformWalletFees[platformWallets[i]][tokens[j]] = 1;\\n                    transferToken(payable(platformWallets[i]), tokens[j], fee - 1);\\n                }\\n            }\\n        }\\n        emit ClaimedPlatformFees(platformWallets, tokens, msg.sender);\\n    }\\n\\n    function approveAllowances(\\n        IERC20Ext[] calldata tokens,\\n        address[] calldata spenders,\\n        bool isReset\\n    ) external onlyAdmin {\\n        uint256 allowance = isReset ? 0 : MAX_ALLOWANCE;\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            for (uint256 j = 0; j < spenders.length; j++) {\\n                tokens[i].safeApprove(spenders[j], allowance);\\n            }\\n            getSetDecimals(tokens[i]);\\n        }\\n\\n        emit ApprovedAllowances(tokens, spenders, isReset);\\n    }\\n\\n    /// ========== SWAP ========== ///\\n\\n    /// @dev swap token via Kyber\\n    /// @notice for some tokens that are paying fee, for example: DGX\\n    /// contract will trade with received src token amount (after minus fee)\\n    /// for Kyber, fee will be taken in ETH as part of their feature\\n    function swapKyber(\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 minConversionRate,\\n        address payable recipient,\\n        uint256 platformFeeBps,\\n        address payable platformWallet,\\n        bytes calldata hint,\\n        bool useGasToken\\n    ) external payable override nonReentrant returns (uint256 destAmount) {\\n        uint256 gasBefore = useGasToken ? gasleft() : 0;\\n        destAmount = doKyberTrade(\\n            src,\\n            dest,\\n            srcAmount,\\n            minConversionRate,\\n            recipient,\\n            platformFeeBps,\\n            platformWallet,\\n            hint\\n        );\\n        uint256 numGasBurns = 0;\\n        // burn gas token if needed\\n        if (useGasToken) {\\n            numGasBurns = burnGasTokensAfter(gasBefore);\\n        }\\n        emit KyberTrade(\\n            msg.sender,\\n            src,\\n            dest,\\n            srcAmount,\\n            destAmount,\\n            recipient,\\n            platformFeeBps,\\n            platformWallet,\\n            hint,\\n            useGasToken,\\n            numGasBurns\\n        );\\n    }\\n\\n    /// @dev swap token via a supported Uniswap router\\n    /// @notice for some tokens that are paying fee, for example: DGX\\n    /// contract will trade with received src token amount (after minus fee)\\n    /// for Uniswap, fee will be taken in src token\\n    function swapUniswap(\\n        IUniswapV2Router02 router,\\n        uint256 srcAmount,\\n        uint256 minDestAmount,\\n        address[] calldata tradePath,\\n        address payable recipient,\\n        uint256 platformFeeBps,\\n        address payable platformWallet,\\n        bool feeInSrc,\\n        bool useGasToken\\n    ) external payable override nonReentrant returns (uint256 destAmount) {\\n        uint256 numGasBurns;\\n        {\\n            // prevent stack too deep\\n            uint256 gasBefore = useGasToken ? gasleft() : 0;\\n            destAmount = swapUniswapInternal(\\n                router,\\n                srcAmount,\\n                minDestAmount,\\n                tradePath,\\n                recipient,\\n                platformFeeBps,\\n                platformWallet,\\n                feeInSrc\\n            );\\n            if (useGasToken) {\\n                numGasBurns = burnGasTokensAfter(gasBefore);\\n            }\\n        }\\n\\n        emit UniswapTrade(\\n            msg.sender,\\n            address(router),\\n            tradePath,\\n            srcAmount,\\n            destAmount,\\n            recipient,\\n            platformFeeBps,\\n            platformWallet,\\n            feeInSrc,\\n            useGasToken,\\n            numGasBurns\\n        );\\n    }\\n\\n    /// ========== SWAP & DEPOSIT ========== ///\\n\\n    function swapKyberAndDeposit(\\n        ISmartWalletLending.LendingPlatform platform,\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 minConversionRate,\\n        uint256 platformFeeBps,\\n        address payable platformWallet,\\n        bytes calldata hint,\\n        bool useGasToken\\n    ) external payable override nonReentrant returns (uint256 destAmount) {\\n        require(lendingImpl != ISmartWalletLending(0));\\n        uint256 gasBefore = useGasToken ? gasleft() : 0;\\n        if (src == dest) {\\n            // just collect src token, no need to swap\\n            destAmount = safeForwardTokenAndCollectFee(\\n                src,\\n                msg.sender,\\n                payable(address(lendingImpl)),\\n                srcAmount,\\n                platformFeeBps,\\n                platformWallet\\n            );\\n        } else {\\n            destAmount = doKyberTrade(\\n                src,\\n                dest,\\n                srcAmount,\\n                minConversionRate,\\n                payable(address(lendingImpl)),\\n                platformFeeBps,\\n                platformWallet,\\n                hint\\n            );\\n        }\\n\\n        // eth or token alr transferred to the address\\n        lendingImpl.depositTo(platform, msg.sender, dest, destAmount);\\n\\n        uint256 numGasBurns = 0;\\n        if (useGasToken) {\\n            numGasBurns = burnGasTokensAfter(gasBefore);\\n        }\\n\\n        emit KyberTradeAndDeposit(\\n            msg.sender,\\n            platform,\\n            src,\\n            dest,\\n            srcAmount,\\n            destAmount,\\n            platformFeeBps,\\n            platformWallet,\\n            hint,\\n            useGasToken,\\n            numGasBurns\\n        );\\n    }\\n\\n    /// @dev swap Uniswap then deposit to platform\\n    ///     if tradePath has only 1 token, don't need to do swap\\n    /// @param platform platform to deposit\\n    /// @param router which Uni-clone to use for swapping\\n    /// @param srcAmount amount of src token\\n    /// @param minDestAmount minimal accepted dest amount\\n    /// @param tradePath path of the trade on Uniswap\\n    /// @param platformFeeBps fee if swapping\\n    /// @param platformWallet wallet to receive fee\\n    /// @param useGasToken whether to use gas token or not\\n    function swapUniswapAndDeposit(\\n        ISmartWalletLending.LendingPlatform platform,\\n        IUniswapV2Router02 router,\\n        uint256 srcAmount,\\n        uint256 minDestAmount,\\n        address[] calldata tradePath,\\n        uint256 platformFeeBps,\\n        address payable platformWallet,\\n        bool useGasToken\\n    ) external payable override nonReentrant returns (uint256 destAmount) {\\n        require(lendingImpl != ISmartWalletLending(0));\\n        uint256 gasBefore = useGasToken ? gasleft() : 0;\\n        {\\n            IERC20Ext dest = IERC20Ext(tradePath[tradePath.length - 1]);\\n            if (tradePath.length == 1) {\\n                // just collect src token, no need to swap\\n                destAmount = safeForwardTokenAndCollectFee(\\n                    dest,\\n                    msg.sender,\\n                    payable(address(lendingImpl)),\\n                    srcAmount,\\n                    platformFeeBps,\\n                    platformWallet\\n                );\\n            } else {\\n                destAmount = swapUniswapInternal(\\n                    router,\\n                    srcAmount,\\n                    minDestAmount,\\n                    tradePath,\\n                    payable(address(lendingImpl)),\\n                    platformFeeBps,\\n                    platformWallet,\\n                    false\\n                );\\n            }\\n\\n            // eth or token alr transferred to the address\\n            lendingImpl.depositTo(platform, msg.sender, dest, destAmount);\\n        }\\n\\n        uint256 numGasBurns = 0;\\n        if (useGasToken) {\\n            numGasBurns = burnGasTokensAfter(gasBefore);\\n        }\\n\\n        emit UniswapTradeAndDeposit(\\n            msg.sender,\\n            platform,\\n            router,\\n            tradePath,\\n            srcAmount,\\n            destAmount,\\n            platformFeeBps,\\n            platformWallet,\\n            useGasToken,\\n            numGasBurns\\n        );\\n    }\\n\\n    /// @dev withdraw token from Lending platforms (AAVE, COMPOUND)\\n    /// @param platform platform to withdraw token\\n    /// @param token underlying token to withdraw, e.g ETH, USDT, DAI\\n    /// @param amount amount of cToken (COMPOUND) or aToken (AAVE) to withdraw\\n    /// @param minReturn minimum amount of USDT tokens to return\\n    /// @param useGasToken whether to use gas token or not\\n    /// @return returnedAmount returns the amount withdrawn to the user\\n    function withdrawFromLendingPlatform(\\n        ISmartWalletLending.LendingPlatform platform,\\n        IERC20Ext token,\\n        uint256 amount,\\n        uint256 minReturn,\\n        bool useGasToken\\n    ) external override nonReentrant returns (uint256 returnedAmount) {\\n        require(lendingImpl != ISmartWalletLending(0));\\n        uint256 gasBefore = useGasToken ? gasleft() : 0;\\n        IERC20Ext lendingToken = IERC20Ext(lendingImpl.getLendingToken(platform, token));\\n        require(lendingToken != IERC20Ext(0), \\\"unsupported token\\\");\\n        // AAVE aToken's transfer logic could have rounding errors\\n        uint256 tokenBalanceBefore = lendingToken.balanceOf(address(lendingImpl));\\n        lendingToken.safeTransferFrom(msg.sender, address(lendingImpl), amount);\\n        uint256 tokenBalanceAfter = lendingToken.balanceOf(address(lendingImpl));\\n\\n        returnedAmount = lendingImpl.withdrawFrom(\\n            platform,\\n            msg.sender,\\n            token,\\n            tokenBalanceAfter.sub(tokenBalanceBefore),\\n            minReturn\\n        );\\n\\n        uint256 numGasBurns;\\n        if (useGasToken) {\\n            numGasBurns = burnGasTokensAfter(gasBefore);\\n        }\\n        emit WithdrawFromLending(\\n            platform,\\n            token,\\n            amount,\\n            minReturn,\\n            returnedAmount,\\n            useGasToken,\\n            numGasBurns\\n        );\\n    }\\n\\n    /// @dev swap on Kyber and repay borrow for sender\\n    /// if src == dest, no need to swap, use src token to repay directly\\n    /// @param payAmount: amount that user wants to pay, if the dest amount (after swap) is higher,\\n    ///     the remain amount will be sent back to user's wallet\\n    /// @param feeAndRateMode: in case of aave v2, user needs to specify the rateMode to repay\\n    ///     to prevent stack too deep, combine fee and rateMode into a single value\\n    ///     platformFee: feeAndRateMode % BPS, rateMode: feeAndRateMode / BPS\\n    /// Other params are params for trade on Kyber\\n    function swapKyberAndRepay(\\n        ISmartWalletLending.LendingPlatform platform,\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 payAmount,\\n        uint256 feeAndRateMode,\\n        address payable platformWallet,\\n        bytes calldata hint,\\n        bool useGasToken\\n    ) external payable override nonReentrant returns (uint256 destAmount) {\\n        uint256 numGasBurns;\\n        {\\n            require(lendingImpl != ISmartWalletLending(0));\\n            uint256 gasBefore = useGasToken ? gasleft() : 0;\\n\\n            {\\n                // use user debt value if debt is <= payAmount,\\n                // user can pay all debt by putting really high payAmount as param\\n                payAmount = checkUserDebt(platform, address(dest), payAmount);\\n                if (src == dest) {\\n                    if (src == ETH_TOKEN_ADDRESS) {\\n                        require(msg.value == srcAmount, \\\"invalid msg value\\\");\\n                        transferToken(payable(address(lendingImpl)), src, srcAmount);\\n                    } else {\\n                        destAmount = srcAmount > payAmount ? payAmount : srcAmount;\\n                        src.safeTransferFrom(msg.sender, address(lendingImpl), destAmount);\\n                    }\\n                } else {\\n                    // use user debt value if debt is <= payAmount\\n                    payAmount = checkUserDebt(platform, address(dest), payAmount);\\n\\n                    // use min rate so it can return earlier if failed to swap\\n                    uint256 minRate =\\n                        calcRateFromQty(srcAmount, payAmount, src.decimals(), dest.decimals());\\n\\n                    destAmount = doKyberTrade(\\n                        src,\\n                        dest,\\n                        srcAmount,\\n                        minRate,\\n                        payable(address(lendingImpl)),\\n                        feeAndRateMode % BPS,\\n                        platformWallet,\\n                        hint\\n                    );\\n                }\\n            }\\n\\n            lendingImpl.repayBorrowTo(\\n                platform,\\n                msg.sender,\\n                dest,\\n                destAmount,\\n                payAmount,\\n                feeAndRateMode / BPS\\n            );\\n\\n            if (useGasToken) {\\n                numGasBurns = burnGasTokensAfter(gasBefore);\\n            }\\n        }\\n\\n        emit KyberTradeAndRepay(\\n            msg.sender,\\n            platform,\\n            src,\\n            dest,\\n            srcAmount,\\n            destAmount,\\n            payAmount,\\n            feeAndRateMode,\\n            platformWallet,\\n            hint,\\n            useGasToken,\\n            numGasBurns\\n        );\\n    }\\n\\n    /// @dev swap on Uni-clone and repay borrow for sender\\n    /// if tradePath.length == 1, no need to swap, use tradePath[0] token to repay directly\\n    /// @param payAmount: amount that user wants to pay, if the dest amount (after swap) is higher,\\n    ///     the remain amount will be sent back to user's wallet\\n    /// @param feeAndRateMode: in case of aave v2, user needs to specify the rateMode to repay\\n    ///     to prevent stack too deep, combine fee and rateMode into a single value\\n    ///     platformFee: feeAndRateMode % BPS, rateMode: feeAndRateMode / BPS\\n    /// Other params are params for trade on Uni-clone\\n    function swapUniswapAndRepay(\\n        ISmartWalletLending.LendingPlatform platform,\\n        IUniswapV2Router02 router,\\n        uint256 srcAmount,\\n        uint256 payAmount,\\n        address[] calldata tradePath,\\n        uint256 feeAndRateMode,\\n        address payable platformWallet,\\n        bool useGasToken\\n    ) external payable override nonReentrant returns (uint256 destAmount) {\\n        uint256 numGasBurns;\\n        {\\n            // scope to prevent stack too deep\\n            require(lendingImpl != ISmartWalletLending(0));\\n            uint256 gasBefore = useGasToken ? gasleft() : 0;\\n            IERC20Ext dest = IERC20Ext(tradePath[tradePath.length - 1]);\\n\\n            // use user debt value if debt is <= payAmount\\n            // user can pay all debt by putting really high payAmount as param\\n            payAmount = checkUserDebt(platform, address(dest), payAmount);\\n            if (tradePath.length == 1) {\\n                if (dest == ETH_TOKEN_ADDRESS) {\\n                    require(msg.value == srcAmount, \\\"invalid msg value\\\");\\n                    transferToken(payable(address(lendingImpl)), dest, srcAmount);\\n                } else {\\n                    destAmount = srcAmount > payAmount ? payAmount : srcAmount;\\n                    dest.safeTransferFrom(msg.sender, address(lendingImpl), destAmount);\\n                }\\n            } else {\\n                destAmount = swapUniswapInternal(\\n                    router,\\n                    srcAmount,\\n                    payAmount,\\n                    tradePath,\\n                    payable(address(lendingImpl)),\\n                    feeAndRateMode % BPS,\\n                    platformWallet,\\n                    false\\n                );\\n            }\\n\\n            lendingImpl.repayBorrowTo(\\n                platform,\\n                msg.sender,\\n                dest,\\n                destAmount,\\n                payAmount,\\n                feeAndRateMode / BPS\\n            );\\n\\n            if (useGasToken) {\\n                numGasBurns = burnGasTokensAfter(gasBefore);\\n            }\\n        }\\n\\n        emit UniswapTradeAndRepay(\\n            msg.sender,\\n            platform,\\n            router,\\n            tradePath,\\n            srcAmount,\\n            destAmount,\\n            payAmount,\\n            feeAndRateMode,\\n            platformWallet,\\n            useGasToken,\\n            numGasBurns\\n        );\\n    }\\n\\n    function claimComp(\\n        address[] calldata holders,\\n        ICompErc20[] calldata cTokens,\\n        bool borrowers,\\n        bool suppliers,\\n        bool useGasToken\\n    ) external override nonReentrant {\\n        uint256 gasBefore = useGasToken ? gasleft() : 0;\\n        lendingImpl.claimComp(holders, cTokens, borrowers, suppliers);\\n        if (useGasToken) {\\n            burnGasTokensAfter(gasBefore);\\n        }\\n    }\\n\\n    /// @dev get expected return and conversion rate if using Kyber\\n    function getExpectedReturnKyber(\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 platformFee,\\n        bytes calldata hint\\n    ) external view override returns (uint256 destAmount, uint256 expectedRate) {\\n        try kyberProxy.getExpectedRateAfterFee(src, dest, srcAmount, platformFee, hint) returns (\\n            uint256 rate\\n        ) {\\n            expectedRate = rate;\\n        } catch {\\n            expectedRate = 0;\\n        }\\n        destAmount = calcDestAmount(src, dest, srcAmount, expectedRate);\\n    }\\n\\n    /// @dev get expected return and conversion rate if using a Uniswap router\\n    function getExpectedReturnUniswap(\\n        IUniswapV2Router02 router,\\n        uint256 srcAmount,\\n        address[] calldata tradePath,\\n        uint256 platformFee\\n    ) external view override returns (uint256 destAmount, uint256 expectedRate) {\\n        if (platformFee >= BPS) return (0, 0); // platform fee is too high\\n        if (!isRouterSupported[router]) return (0, 0); // router is not supported\\n        uint256 srcAmountAfterFee = (srcAmount * (BPS - platformFee)) / BPS;\\n        if (srcAmountAfterFee == 0) return (0, 0);\\n        // in case pair is not supported\\n        try router.getAmountsOut(srcAmountAfterFee, tradePath) returns (uint256[] memory amounts) {\\n            destAmount = amounts[tradePath.length - 1];\\n        } catch {\\n            destAmount = 0;\\n        }\\n        expectedRate = calcRateFromQty(\\n            srcAmountAfterFee,\\n            destAmount,\\n            getDecimals(IERC20Ext(tradePath[0])),\\n            getDecimals(IERC20Ext(tradePath[tradePath.length - 1]))\\n        );\\n    }\\n\\n    function checkUserDebt(\\n        ISmartWalletLending.LendingPlatform platform,\\n        address token,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        uint256 debt = lendingImpl.storeAndRetrieveUserDebtCurrent(platform, token, msg.sender);\\n\\n        if (debt >= amount) {\\n            return amount;\\n        }\\n\\n        return debt;\\n    }\\n\\n    function doKyberTrade(\\n        IERC20Ext src,\\n        IERC20Ext dest,\\n        uint256 srcAmount,\\n        uint256 minConversionRate,\\n        address payable recipient,\\n        uint256 platformFeeBps,\\n        address payable platformWallet,\\n        bytes memory hint\\n    ) internal virtual returns (uint256 destAmount) {\\n        uint256 actualSrcAmount =\\n            validateAndPrepareSourceAmount(address(kyberProxy), src, srcAmount, platformWallet);\\n        uint256 callValue = src == ETH_TOKEN_ADDRESS ? actualSrcAmount : 0;\\n        destAmount = kyberProxy.tradeWithHintAndFee{value: callValue}(\\n            src,\\n            actualSrcAmount,\\n            dest,\\n            recipient,\\n            MAX_AMOUNT,\\n            minConversionRate,\\n            platformWallet,\\n            platformFeeBps,\\n            hint\\n        );\\n    }\\n\\n    function swapUniswapInternal(\\n        IUniswapV2Router02 router,\\n        uint256 srcAmount,\\n        uint256 minDestAmount,\\n        address[] memory tradePath,\\n        address payable recipient,\\n        uint256 platformFeeBps,\\n        address payable platformWallet,\\n        bool feeInSrc\\n    ) internal returns (uint256 destAmount) {\\n        TradeInput memory input =\\n            TradeInput({\\n                srcAmount: srcAmount,\\n                minData: minDestAmount,\\n                recipient: recipient,\\n                platformFeeBps: platformFeeBps,\\n                platformWallet: platformWallet,\\n                hint: \\\"\\\"\\n            });\\n\\n        // extra validation when swapping on Uniswap\\n        require(isRouterSupported[router], \\\"unsupported router\\\");\\n        require(platformFeeBps < BPS, \\\"high platform fee\\\");\\n\\n        IERC20Ext src = IERC20Ext(tradePath[0]);\\n\\n        input.srcAmount = validateAndPrepareSourceAmount(\\n            address(router),\\n            src,\\n            srcAmount,\\n            platformWallet\\n        );\\n\\n        destAmount = doUniswapTrade(router, src, tradePath, input, feeInSrc);\\n    }\\n\\n    function doUniswapTrade(\\n        IUniswapV2Router02 router,\\n        IERC20Ext src,\\n        address[] memory tradePath,\\n        TradeInput memory input,\\n        bool feeInSrc\\n    ) internal virtual returns (uint256 destAmount) {\\n        uint256 tradeLen = tradePath.length;\\n        IERC20Ext actualDest = IERC20Ext(tradePath[tradeLen - 1]);\\n        {\\n            // convert eth -> weth address to trade on Uniswap\\n            if (tradePath[0] == address(ETH_TOKEN_ADDRESS)) {\\n                tradePath[0] = router.WETH();\\n            }\\n            if (tradePath[tradeLen - 1] == address(ETH_TOKEN_ADDRESS)) {\\n                tradePath[tradeLen - 1] = router.WETH();\\n            }\\n        }\\n\\n        uint256 srcAmountFee;\\n        uint256 srcAmountAfterFee;\\n        uint256 destBalanceBefore;\\n        address recipient;\\n\\n        if (feeInSrc) {\\n            srcAmountFee = input.srcAmount.mul(input.platformFeeBps).div(BPS);\\n            srcAmountAfterFee = input.srcAmount.sub(srcAmountFee);\\n            recipient = input.recipient;\\n        } else {\\n            srcAmountAfterFee = input.srcAmount;\\n            destBalanceBefore = getBalance(actualDest, address(this));\\n            recipient = address(this);\\n        }\\n\\n        uint256[] memory amounts;\\n        if (src == ETH_TOKEN_ADDRESS) {\\n            // swap eth -> token\\n            amounts = router.swapExactETHForTokens{value: srcAmountAfterFee}(\\n                input.minData,\\n                tradePath,\\n                recipient,\\n                MAX_AMOUNT\\n            );\\n        } else {\\n            if (actualDest == ETH_TOKEN_ADDRESS) {\\n                // swap token -> eth\\n                amounts = router.swapExactTokensForETH(\\n                    srcAmountAfterFee,\\n                    input.minData,\\n                    tradePath,\\n                    recipient,\\n                    MAX_AMOUNT\\n                );\\n            } else {\\n                // swap token -> token\\n                amounts = router.swapExactTokensForTokens(\\n                    srcAmountAfterFee,\\n                    input.minData,\\n                    tradePath,\\n                    recipient,\\n                    MAX_AMOUNT\\n                );\\n            }\\n        }\\n\\n        if (!feeInSrc) {\\n            // fee in dest token, calculated received dest amount\\n            uint256 destBalanceAfter = getBalance(actualDest, address(this));\\n            destAmount = destBalanceAfter.sub(destBalanceBefore);\\n            uint256 destAmountFee = destAmount.mul(input.platformFeeBps).div(BPS);\\n            // charge fee in dest token\\n            addFeeToPlatform(input.platformWallet, actualDest, destAmountFee);\\n            // transfer back dest token to recipient\\n            destAmount = destAmount.sub(destAmountFee);\\n            transferToken(input.recipient, actualDest, destAmount);\\n        } else {\\n            // fee in src amount\\n            destAmount = amounts[amounts.length - 1];\\n            addFeeToPlatform(input.platformWallet, src, srcAmountFee);\\n        }\\n    }\\n\\n    function validateAndPrepareSourceAmount(\\n        address protocol,\\n        IERC20Ext src,\\n        uint256 srcAmount,\\n        address platformWallet\\n    ) internal virtual returns (uint256 actualSrcAmount) {\\n        require(supportedPlatformWallets[platformWallet], \\\"unsupported platform wallet\\\");\\n        if (src == ETH_TOKEN_ADDRESS) {\\n            require(msg.value == srcAmount, \\\"wrong msg value\\\");\\n            actualSrcAmount = srcAmount;\\n        } else {\\n            require(msg.value == 0, \\\"bad msg value\\\");\\n            uint256 balanceBefore = src.balanceOf(address(this));\\n            src.safeTransferFrom(msg.sender, address(this), srcAmount);\\n            uint256 balanceAfter = src.balanceOf(address(this));\\n            actualSrcAmount = balanceAfter.sub(balanceBefore);\\n            require(actualSrcAmount > 0, \\\"invalid src amount\\\");\\n\\n            safeApproveAllowance(protocol, src);\\n        }\\n    }\\n\\n    function burnGasTokensAfter(uint256 gasBefore) internal virtual returns (uint256 numGasBurns) {\\n        if (burnGasHelper == IBurnGasHelper(0)) return 0;\\n        IGasToken gasToken;\\n        uint256 gasAfter = gasleft();\\n\\n        try\\n            burnGasHelper.getAmountGasTokensToBurn(gasBefore.sub(gasAfter).add(msg.data.length))\\n        returns (uint256 _gasBurns, address _gasToken) {\\n            numGasBurns = _gasBurns;\\n            gasToken = IGasToken(_gasToken);\\n        } catch {\\n            numGasBurns = 0;\\n        }\\n\\n        if (numGasBurns > 0 && gasToken != IGasToken(0)) {\\n            numGasBurns = gasToken.freeFromUpTo(msg.sender, numGasBurns);\\n        }\\n    }\\n\\n    function safeForwardTokenAndCollectFee(\\n        IERC20Ext token,\\n        address from,\\n        address payable to,\\n        uint256 amount,\\n        uint256 platformFeeBps,\\n        address payable platformWallet\\n    ) internal returns (uint256 destAmount) {\\n        require(platformFeeBps < BPS, \\\"high platform fee\\\");\\n        require(supportedPlatformWallets[platformWallet], \\\"unsupported platform wallet\\\");\\n        uint256 feeAmount = (amount * platformFeeBps) / BPS;\\n        destAmount = amount - feeAmount;\\n        if (token == ETH_TOKEN_ADDRESS) {\\n            require(msg.value >= amount);\\n            (bool success, ) = to.call{value: destAmount}(\\\"\\\");\\n            require(success, \\\"transfer eth failed\\\");\\n        } else {\\n            uint256 balanceBefore = token.balanceOf(to);\\n            token.safeTransferFrom(from, to, amount);\\n            uint256 balanceAfter = token.balanceOf(to);\\n            destAmount = balanceAfter.sub(balanceBefore);\\n        }\\n        addFeeToPlatform(platformWallet, token, feeAmount);\\n    }\\n\\n    function addFeeToPlatform(\\n        address wallet,\\n        IERC20Ext token,\\n        uint256 amount\\n    ) internal {\\n        if (amount > 0) {\\n            platformWalletFees[wallet][token] = platformWalletFees[wallet][token].add(amount);\\n        }\\n    }\\n\\n    function transferToken(\\n        address payable recipient,\\n        IERC20Ext token,\\n        uint256 amount\\n    ) internal {\\n        if (amount == 0) return;\\n        if (token == ETH_TOKEN_ADDRESS) {\\n            (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n            require(success, \\\"failed to transfer eth\\\");\\n        } else {\\n            token.safeTransfer(recipient, amount);\\n        }\\n    }\\n\\n    function safeApproveAllowance(address spender, IERC20Ext token) internal {\\n        if (token.allowance(address(this), spender) == 0) {\\n            getSetDecimals(token);\\n            token.safeApprove(spender, MAX_ALLOWANCE);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 780\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20Ext\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isV1\",\"type\":\"bool\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"reserves\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isV1\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"_reserves\",\"type\":\"address[]\"}],\"name\":\"getReservesConfigurationData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationBonus\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"usageAsCollateralEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"borrowingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"stableBorrowRateEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"aTokenAddress\",\"type\":\"address\"}],\"internalType\":\"struct IFetchAaveDataWrapper.ReserveConfigData[]\",\"name\":\"configsData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isV1\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"_reserves\",\"type\":\"address[]\"}],\"name\":\"getReservesData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowsStable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowsVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"averageStableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationRate\",\"type\":\"uint256\"}],\"internalType\":\"struct IFetchAaveDataWrapper.ReserveData[]\",\"name\":\"reservesData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isV1\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getSingleUserAccountData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalLiquidityETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowsETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFeesETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableBorrowsETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLiquidationThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"healthFactor\",\"type\":\"uint256\"}],\"internalType\":\"struct IFetchAaveDataWrapper.UserAccountData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILendingPoolV1\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getSingleUserReserveDataV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"currentATokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolShareInPrecision\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"usageAsCollateralEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"currentBorrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalBorrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateMode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentStableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentVariableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalStableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scaledVariableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableBorrowRate\",\"type\":\"uint256\"}],\"internalType\":\"struct IFetchAaveDataWrapper.UserReserveData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocolDataProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getSingleUserReserveDataV2\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"currentATokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolShareInPrecision\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"usageAsCollateralEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"currentBorrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalBorrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateMode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentStableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentVariableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalStableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scaledVariableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableBorrowRate\",\"type\":\"uint256\"}],\"internalType\":\"struct IFetchAaveDataWrapper.UserReserveData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isV1\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"getUserAccountsData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalLiquidityETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowsETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFeesETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableBorrowsETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLiquidationThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"healthFactor\",\"type\":\"uint256\"}],\"internalType\":\"struct IFetchAaveDataWrapper.UserAccountData[]\",\"name\":\"accountsData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isV1\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"_reserves\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserReservesData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"currentATokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolShareInPrecision\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"usageAsCollateralEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"currentBorrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalBorrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateMode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentStableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentVariableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalStableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scaledVariableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableBorrowRate\",\"type\":\"uint256\"}],\"internalType\":\"struct IFetchAaveDataWrapper.UserReserveData[]\",\"name\":\"userReservesData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isV1\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"getUsersReserveData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"currentATokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolShareInPrecision\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"usageAsCollateralEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"currentBorrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalBorrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateMode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentStableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentVariableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalStableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scaledVariableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableBorrowRate\",\"type\":\"uint256\"}],\"internalType\":\"struct IFetchAaveDataWrapper.UserReserveData[]\",\"name\":\"userReservesData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Ext\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FetchAaveDataWrapper","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"780","ConstructorArguments":"000000000000000000000000189ea49c4d5717ab6f7566deaf0690b9504087bd","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}