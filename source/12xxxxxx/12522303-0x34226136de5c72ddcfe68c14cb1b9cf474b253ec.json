{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/LockingLayers.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n//SPDX-License-Identifier: MIT\\r\\n\\r\\n\\n\\r\\nimport \\\"./ILockingLayers.sol\\\";\\r\\nimport \\\"./VRFConsumerBase.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev LockingLayers is an ERC721 contract that contains the logic and source of ownership\\r\\n * for Whole Picture. The core mechanics breakdown as follows:\\r\\n *   - Each artwork consists of 4 layers. \\r\\n *   - A Layer contain a canvasId.\\r\\n *   - Each layer shifts its canvasId after X blocks, unless the layer is locked.\\r\\n *   - Layers are revealed over time, and the entire process ends after all layers are revelaed and\\r\\n *     all layer shifts have finished.\\r\\n *   \\r\\n * Schema is:\\r\\n *   - artworkId => owned by address\\r\\n *     - canvasIds[NUM_LAYERS] => owned by artwork => NUM_LAYERS = 4 so each artwork ownes 4 canvasIds\\r\\n *\\r\\n * Layer Mappings:\\r\\n *   - Mappings from canvasId => canvas are stored offchain in IPFS. Mapping json file can be viewed\\r\\n *   - at ipfs://QmZ7Lpf5T4NhawAKsWAmomG5sxkSN6USfRVRW5nMzjrHdD\\r\\n * \\r\\n * IMPORTANT NOTES:\\r\\n *  - canvasIds and actionIds are 1 indexed, not 0 indexed. This is because a 0 index signifies that\\r\\n *  a layer is not locked, and an actionId of 0 signifies that the action has not happened yet.\\r\\n */\\r\\ncontract LockingLayers is ILockingLayers, ERC721, VRFConsumerBase, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n\\r\\n    // Total number of artworks to create\\r\\n    uint16 constant TOTAL_ARTWORK_SUPPLY = 1200;\\r\\n\\r\\n\\r\\n    // The layerIds owned by each artwork\\r\\n    uint8 constant NUM_LAYERS = 4;\\r\\n\\r\\n\\r\\n    // Actions are shifts per each layer\\r\\n    // NOTE: all actions are 1 indexed, not 0 indexed. This is because an action idx of\\r\\n    // 0 means that layer does nto exist yet\\r\\n    uint8 constant ACTIONS_PER_LAYER = 5;\\r\\n\\r\\n\\r\\n    // Defines number blocks required to trigger an action\\r\\n    uint16 constant BLOCKS_PER_ACTION = 4444;\\r\\n\\r\\n\\r\\n    // Total number of actions for the project\\r\\n    uint16 constant MAX_ACTIONS = ACTIONS_PER_LAYER * NUM_LAYERS;\\r\\n\\r\\n\\r\\n    // There will be the same number of layerIds because each artwork is guaranteed to have 4 layers\\r\\n    uint16 constant NUM_CANVAS_IDS = TOTAL_ARTWORK_SUPPLY;\\r\\n\\r\\n\\r\\n    // Number of artworks in each tier\\r\\n    uint16[3] totalArtworksInTier = [200, 800, 200];\\r\\n\\r\\n\\r\\n    // remaining artworks in each tier that can be purchased\\r\\n    uint16[3] artworksRemainingInTier = [200, 800, 200];\\r\\n\\r\\n\\r\\n    // CID of the mappings from canvasId to canvas! View on ipfs.\\r\\n    string constant provinanceRecord = \\\"QmZ7Lpf5T4NhawAKsWAmomG5sxkSN6USfRVRW5nMzjrHdD\\\";\\r\\n\\r\\n\\r\\n    // First artwork will be id of 0\\r\\n    uint16 nextArtworkId = 0;\\r\\n\\r\\n\\r\\n    // Records the official \\r\\n    uint256 private _startBlock = 0;\\r\\n\\r\\n   \\r\\n    // True once artwork has begun (once VRF has been received)\\r\\n    bool private isArtworkStarted = false; \\r\\n\\r\\n\\r\\n    // Block that stores first time of first purchase\\r\\n    uint256 public firstPurchaseBlock = 0;\\r\\n\\r\\n\\r\\n    // If not all artworks are sold, will trigger start this many blocks after first artwork purchased\\r\\n    uint256 public constant AUTOMATIC_START_BLOCK_DELAY = 184000;\\r\\n\\r\\n\\r\\n    // Mapping to the artwork tier for each token\\r\\n    // artworkId => tier\\r\\n    mapping(uint256 => ArtworkTier) public artworkTier;\\r\\n\\r\\n    \\r\\n    // The constant number of locks for each purchase tier.\\r\\n    uint8[4] locksPerTier = [1, 2, 4];\\r\\n\\r\\n\\r\\n    // Remaining locks per artwork -- each lock will decrement value\\r\\n    // artworkId => _locksRemaining\\r\\n    mapping(uint256 => uint8) _locksRemaining;\\r\\n\\r\\n\\r\\n    // A record of locked layers for each token:\\r\\n    // artworkId => lockedCanvasId[NUM_LAYERS]\\r\\n    // NOTE: a value of 0 signifies that a layer is NOT locked\\r\\n    //   - Example: \\r\\n    //     - lockedLayersForToken[100][1] = 10\\r\\n    //       - can be read as artworkId 100 has layer 1 (0 indexed) locked with canvasId 10.\\r\\n    //     - lockedLayerForToken[100][0] = 0\\r\\n    //       - can be read as artworkId 100's layer 0 is NOT locked\\r\\n    mapping(uint256 => uint16[NUM_LAYERS]) lockedLayersForToken;\\r\\n\\r\\n\\r\\n    // A record of if an artwork is locked and at which action it was locked.\\r\\n    // canvasId => actionId[NUM_LAYERS] -> ~7 actions per layer so uint8 is good for actionId\\r\\n    // canvasIds are reused for each layer to save on storage costs.\\r\\n    //   - Example:\\r\\n    //     - lockedLayerHistory[10][1] = 2\\r\\n    //       - can be read as canvasId 10 for second layer (0 indexed) was locked on action 2\\r\\n    //     - lockedLayerHistory[10][2] = 0\\r\\n    //       - can be read as canvasId 10 has NOT BEEN LOCKED for third layer\\r\\n    mapping(uint16 => uint8[NUM_LAYERS]) lockedLayerHistory;\\r\\n\\r\\n\\r\\n    // Offsets for layerIds for each layer, used when finding base id for next layer\\r\\n    // The [0] index is set by Chainlink VRF (https://docs.chain.link/docs/chainlink-vrf-api-reference)\\r\\n    // Later indexes are only influenced by participants locking layers, so the artwork is\\r\\n    // more connected with the behaviour of the participants.\\r\\n    // INVARIANT: Can only change for future UNLOCKED layer, can never be altered for \\r\\n    // past layers. Needs to be deterministic for past/current layers. \\r\\n    //   - Example:\\r\\n    //     - layerIdStartOffset[1] = 19413\\r\\n    //     - can be read as the starting canvasId will be offset by 19413\\r\\n    uint256[NUM_LAYERS] public canvasIdStartOffsets;\\r\\n\\r\\n    // CHAINLINK VRF properties -- want to keep locally to test gas spend\\r\\n    bytes32 constant keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\\r\\n    uint256 constant vrfFee = 2000000000000000000;\\r\\n\\r\\n    // Store the current URI -- URI may change if domain is updated\\r\\n    string baseURI = \\\"https://su3p5zea28.execute-api.us-west-1.amazonaws.com/prod/metadata/\\\";\\r\\n\\r\\n    constructor() \\r\\n        ERC721(\\\"Whole Picture\\\", \\\"WP\\\") \\r\\n        VRFConsumerBase(\\r\\n            0xf0d54349aDdcf704F77AE15b96510dEA15cb7952,\\r\\n            0x514910771AF9Ca656af840dff83E8264EcF986CA\\r\\n        )    \\r\\n    public {\\r\\n\\r\\n    }\\r\\n\\r\\n    /** \\r\\n      * @dev Metadata base uri    \\r\\n     */\\r\\n    function _baseURI() internal view override returns (string memory) {\\r\\n        return baseURI;\\r\\n    }\\r\\n\\r\\n   \\r\\n\\r\\n    /**\\r\\n     * @dev Returns the currnet price in wei for an artwork in a given tier.\\r\\n     * Pricing is a bonding curve, using 4 quadratic easing sections:\\r\\n     *   - Enthusiast tier is an ease out curve\\r\\n     *   - Collector tier is ease in segment until midway point, then ease out\\r\\n     *   - Strata tier is ease in.\\r\\n     */\\r\\n    function currentPrice(ArtworkTier tier) public override view returns (uint256) {\\r\\n        if(artworksRemainingInTier[uint256(tier)] == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 min;\\r\\n        uint256 max;\\r\\n        uint256 numerator;\\r\\n        uint256 denominator;\\r\\n        \\r\\n        if(tier == ArtworkTier.ENTHUSIAST) {\\r\\n            min = 1 * 1 ether / 10;\\r\\n            max = 5 * 1 ether / 10;\\r\\n            numerator = totalArtworksInTier[0] - artworksRemainingInTier[0];\\r\\n            denominator = totalArtworksInTier[0];\\r\\n\\r\\n        }\\r\\n        else if(tier == ArtworkTier.COLLECTOR) {\\r\\n            uint256 collectorMin =  5 * 1 ether / 10;\\r\\n            uint256 collectorMax = 25 * 1 ether / 10;\\r\\n            uint256 midwayPrice = collectorMin + (collectorMax - collectorMin) / 2;\\r\\n            uint256 midwayArtworks = totalArtworksInTier[1] / 2;\\r\\n            if(artworksRemainingInTier[1] > midwayArtworks){\\r\\n                // invert so switch min and max\\r\\n                min = midwayPrice;\\r\\n                max = collectorMin;\\r\\n                numerator = midwayArtworks - (totalArtworksInTier[1] - artworksRemainingInTier[1]);\\r\\n                denominator = midwayArtworks;\\r\\n            } else {\\r\\n                min = midwayPrice;\\r\\n                max = collectorMax;\\r\\n                numerator = midwayArtworks - artworksRemainingInTier[1];\\r\\n                denominator = midwayArtworks;\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            // Strata tier so return STRATA_TIER price\\r\\n            // inverted so switch max and min\\r\\n            max = 25 * 1 ether / 10;\\r\\n            min = 4 * 1 ether / 1;\\r\\n            numerator = artworksRemainingInTier[2] - 1; // inverted so use remaining for numerator\\r\\n            denominator = totalArtworksInTier[2] - 1; // minus one so ends on 4\\r\\n        }\\r\\n        \\r\\n        return easeInQuad(min, max, numerator, denominator);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Get the price and available artworks for a given tier\\r\\n     *   - Returns:\\r\\n     *      - uint256 => PRICE in wei\\r\\n     *      - uint256 => available artworks\\r\\n     */\\r\\n    function getTierPurchaseData(ArtworkTier tier) public override view returns (uint256, uint16) {\\r\\n        return (currentPrice(tier), artworksRemainingInTier[uint256(tier)]);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of artworks issued.\\r\\n     */\\r\\n    function totalArtworks() public override pure returns (uint16) {\\r\\n        return TOTAL_ARTWORK_SUPPLY;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total artworks remaining across all tiers.\\r\\n     */\\r\\n    function availableArtworks() public override view returns (uint16) {\\r\\n        return artworksRemainingInTier[0] + artworksRemainingInTier[1] + artworksRemainingInTier[2];\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev The number of blocks remaining until next layer is revealed.\\r\\n     */\\r\\n    function blocksUntilNextLayerRevealed() public override view returns (uint256) {\\r\\n        if(!hasStarted()) {\\r\\n            return 0;\\r\\n        }\\r\\n        return ((getAction()) * BLOCKS_PER_ACTION + startBlock()) - block.number;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if an artwork can lock the current layer.\\r\\n     *   - if no locks remaining or if layer is already locked, cannot lock\\r\\n     */\\r\\n    function canLock(uint256 artworkId) public override view returns (bool) {\\r\\n        // check locks\\r\\n        return (_locksRemaining[artworkId] > 0);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if an artwork can lock the current layer.\\r\\n     *   - if no locks remaining or if layer is already locked, cannot lock\\r\\n     */\\r\\n    function locksRemaining(uint256 artworkId) public view returns (uint8) {\\r\\n        // check locks\\r\\n        return _locksRemaining[artworkId];\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Get canvasIds for each layer for artwork.\\r\\n     */\\r\\n    function getCanvasIds(uint256 artworkId) public override view returns (uint16, uint16, uint16, uint16) {\\r\\n        // ensure no ids sent if hasn't started or artwork doesn't exist\\r\\n        if(!hasStarted() || !_exists(artworkId)) {\\r\\n            return (0, 0, 0, 0);\\r\\n        }\\r\\n\\r\\n        (uint8 currentLayer, uint8 currentAction) = getCurrentLayerAndAction();\\r\\n\\r\\n        // initialize array, all values start at 0\\r\\n        uint16[NUM_LAYERS] memory canvasIds;\\r\\n\\r\\n        // now need to loop through all layers\\r\\n        for(uint8 i = 0; i <= currentLayer; i++) {\\r\\n            uint8 layerAction;\\r\\n\\r\\n            // check if we are on the current (topmost) layer, in which case we use the current action\\r\\n            if(i == currentLayer) {\\r\\n                layerAction = currentAction;\\r\\n            } else {\\r\\n                // otherwise we use the final action for previous layer\\r\\n                layerAction = ACTIONS_PER_LAYER;\\r\\n            }\\r\\n\\r\\n            // now get the canvasId for action for target layer\\r\\n            canvasIds[i] = getCanvasIdForAction(artworkId, i, layerAction);\\r\\n        }\\r\\n        return (canvasIds[0], canvasIds[1], canvasIds[2], canvasIds[3]);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the startBlock for the artwork.\\r\\n     * There are two conditions for the artwork to start -- either all artworks are sold,\\r\\n     * or the automatic trigger started after the first artwork has sold has been reached.\\r\\n     */\\r\\n    function startBlock() public view returns (uint256) {    \\r\\n        return _startBlock;      \\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Check whether the artwork has started.\\r\\n     */\\r\\n    function hasStarted() public view returns (bool) {\\r\\n        return startBlock() != 0;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the overall action since the start of the process.\\r\\n     * NOTE: Actions are 1 indexed! 0 means no actions because has not begun.\\r\\n     */\\r\\n    function getAction() public view returns (uint8) {\\r\\n        if(!hasStarted()) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 elapsedBlocks = block.number.sub(startBlock());\\r\\n        // actions are 1 indexed so need to add 1\\r\\n        uint256 actionsElapsed = elapsedBlocks.div(BLOCKS_PER_ACTION) + 1;\\r\\n        uint256 clampedActions = Math.min(actionsElapsed, MAX_ACTIONS);\\r\\n        // console.log(\\\"ElapsedBlocks: %s\\\", elapsedBlocks);\\r\\n        return uint8(clampedActions);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current layer as well as the current action.\\r\\n     *   - Returns:\\r\\n     *     - (layer, actionInLayer)\\r\\n     *   - If action == 0, then layer is not revealed\\r\\n     */\\r\\n    function getCurrentLayerAndAction() public view returns (uint8, uint8) {\\r\\n        \\r\\n        uint8 totalActions = getAction();\\r\\n        \\r\\n        // ensure we return \\r\\n        if(totalActions == 0) {\\r\\n            return (0, 0);\\r\\n        }\\r\\n\\r\\n        // need to subtract 1 because actions start at 1\\r\\n        uint8 actionZeroIndexed = totalActions - 1;\\r\\n\\r\\n        uint8 currentLayer = (actionZeroIndexed) / ACTIONS_PER_LAYER;\\r\\n         \\r\\n        uint8 currentActionZeroIndexed = actionZeroIndexed - (currentLayer * ACTIONS_PER_LAYER);\\r\\n        \\r\\n        // re-add 1 to restore 1 index\\r\\n        uint8 currentAction = currentActionZeroIndexed + 1;\\r\\n\\r\\n        return (currentLayer, currentAction);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Purchases an artwork.\\r\\n     *   - Returns the artworkID of purchased work.\\r\\n     *   - Reverts if insuffiscient funds or no artworks left.\\r\\n     */\\r\\n    function purchase(ArtworkTier tier) public override payable returns (uint256) {\\r\\n        require(artworksRemainingInTier[uint256(tier)] > 0, \\\"No artworks remaining in tier!\\\");\\r\\n\\r\\n        // Validate payment amount\\r\\n        uint256 weiRequired = currentPrice(tier);\\r\\n        require(msg.value >= weiRequired, \\\"Not enough payment sent!\\\");\\r\\n        \\r\\n        uint256 newArtworkId = nextArtworkId;\\r\\n\\r\\n        // check if first sale, and if so set first sale block\\r\\n        if(newArtworkId == 0) {\\r\\n            firstPurchaseBlock = block.number;\\r\\n        }\\r\\n\\r\\n        // mint new artwork!\\r\\n        _safeMint(_msgSender(), newArtworkId);\\r\\n\\r\\n        // record tier and the number of locks\\r\\n        artworkTier[newArtworkId] = tier;\\r\\n        _locksRemaining[newArtworkId] = locksPerTier[uint256(tier)];\\r\\n\\r\\n        // decrement artworks available in tier\\r\\n        artworksRemainingInTier[uint256(tier)] -= 1;\\r\\n\\r\\n        // incriment artwork to the next artworkId\\r\\n        nextArtworkId++;\\r\\n\\r\\n        // check if all artworks sold, then trigger startBlock if not already started\\r\\n        if(nextArtworkId == TOTAL_ARTWORK_SUPPLY) {\\r\\n            if(!hasStarted()) {\\r\\n\\n                requestStartArtwork();\\r\\n            } \\r\\n        }\\r\\n\\r\\n\\n\\r\\n        emit ArtworkPurchased(newArtworkId, uint8(tier));\\r\\n\\r\\n        return newArtworkId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Request to start the artwork!\\r\\n     *   - Acheived by requesting a random number from Chainlink VRF.\\r\\n     *   - Will automatically be requested after the last sale -- or can be requested\\r\\n     *     manually once sale period has ended.\\r\\n     * Requirements:\\r\\n     *   Can only occur after:\\r\\n     *     - All works have been sold\\r\\n     *     - Sale period ended (X blocks past the block of the first purchase)\\r\\n     *     - Has not already been started\\r\\n     *     - Enough LINK on contract\\r\\n     */\\r\\n    function requestStartArtwork() public returns (bytes32) {\\r\\n        require(!hasStarted(), \\\"Artwork has already been started!\\\");\\r\\n        \\r\\n        // Require all artworks sold or after sale period has ended\\r\\n        require(\\r\\n            availableArtworks() == 0 || \\r\\n            firstPurchaseBlock > 0 && block.number > firstPurchaseBlock + AUTOMATIC_START_BLOCK_DELAY,\\r\\n            \\\"Cannot start the artwork before all works are sold out or until after sale period\\\"\\r\\n        );\\r\\n\\r\\n\\n\\r\\n\\n        // Request randomness from VRF\\r\\n        return requestRandomness(keyHash, vrfFee, block.number);\\r\\n\\n    }\\r\\n\\r\\n\\r\\n    /** \\r\\n     * @dev Respond to Chainlink VRF\\r\\n     *   - This will start artwork if not already started\\r\\n     */\\r\\n    function fulfillRandomness(bytes32 /*requestId*/, uint256 randomness) internal override {\\r\\n        startArtwork(randomness);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Start the artwork! This sets the start seed and start block.\\r\\n     *   - Can only be called once\\r\\n     */\\r\\n    function startArtwork(uint256 randomSeed) internal {\\r\\n        // Ensure start block not already set (in case random number requested twice before being fulfilled)\\r\\n        require(!hasStarted(), \\\"Artwork has already started, seed cannot be set twice!\\\");\\r\\n\\r\\n\\n\\r\\n        // Set start block and the start seed, which kicks off the artwork experience!!!!!\\r\\n        _startBlock = block.number;\\r\\n\\r\\n        // The first canvas start is the random Seed!\\r\\n        canvasIdStartOffsets[0] = randomSeed % TOTAL_ARTWORK_SUPPLY;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Lock artwork layer.\\r\\n     *   - Reverts if cannot lock.\\r\\n     *   - Emits LayerLocked event\\r\\n     */\\r\\n    function lockLayer(uint256 artworkId) public override {\\r\\n\\r\\n        require(hasStarted(), \\\"Art event has not begun!\\\");\\r\\n\\r\\n        require(_exists(artworkId), \\\"Artwork does not exist!\\\");\\r\\n\\r\\n        // require locking party to be owner\\r\\n        require(_msgSender() == ownerOf(artworkId), \\\"Must be artwork owner!\\\");\\r\\n\\r\\n        // require locks remaining\\r\\n        require(canLock(artworkId), \\\"No locks remaining!\\\");\\r\\n\\r\\n        // first determine active layer and current action\\r\\n        (uint8 currentLayer, uint8 currentAction) = getCurrentLayerAndAction();\\r\\n        \\r\\n        // Ensure we are not on action 0, which means cannot lock\\r\\n        require(currentAction > 0, \\\"Canvas is not yet revealed!\\\");\\r\\n\\r\\n        // recreate history to determine current canvas\\r\\n        uint16 currentCanvasId = getCanvasIdForAction(artworkId, currentLayer, currentAction);\\r\\n        \\r\\n        // ensure not already locked so user does not waste lock\\r\\n        uint8 currLockedValue = lockedLayerHistory[currentCanvasId][currentLayer];\\r\\n        require(currLockedValue == 0, \\\"Layer must not be already locked!\\\");\\r\\n        require(currentCanvasId > 0, \\\"Invalid canvas id of 0!\\\"); // is this needed???\\r\\n\\r\\n        // update locked layer by idx mapping\\r\\n        lockedLayersForToken[artworkId][currentLayer] = currentCanvasId;\\r\\n\\r\\n        // update canvasId locked layer mapping\\r\\n        lockedLayerHistory[currentCanvasId][currentLayer] = currentAction;\\r\\n\\r\\n        // Update start canvasId offset for next layer\\r\\n        if(currentLayer < NUM_LAYERS - 1) {\\r\\n\\n            canvasIdStartOffsets[currentLayer + 1] = (block.number + canvasIdStartOffsets[currentLayer]) % TOTAL_ARTWORK_SUPPLY;\\r\\n        }\\r\\n\\r\\n\\n\\r\\n        _locksRemaining[artworkId] -= 1;\\r\\n        emit LayerLocked(artworkId, currentLayer, currentCanvasId);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Valid canvasIds are always 1 indexed! An index of 0 means canvas is not yet revealed.\\r\\n     */\\r\\n    function incrimentCanvasId(uint16 canvasId) internal pure returns (uint16) {\\r\\n        return (canvasId % NUM_CANVAS_IDS) + 1;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the corresponding canvasId for an artwork and layer at a given action.\\r\\n     *   This function calculates the current canvas by starting at first canvas of the current\\r\\n     *   layer and recreating past actions, which leads to the current valid layer.\\r\\n     *     - Each artworkID should ALWAYS return a unique canvas ID for the same action state.\\r\\n     *     - CanvasIds are 1 indexed, so a revealed canvas should NEVER return 0!\\r\\n     */\\r\\n    function getCanvasIdForAction(uint256 artworkId, uint8 layer, uint8 action) internal view returns (uint16) {        \\r\\n\\r\\n        // If we are on 0 action, layer is not revealed no valid canvasId\\r\\n        if(action == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // If artwork does not exist, return 0\\r\\n        if(!_exists(artworkId)) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // If canvas is locked, return the locked canvasId\\r\\n        uint16 lockedCanvasId = lockedLayersForToken[artworkId][layer];\\r\\n        if(lockedCanvasId != 0) {\\r\\n\\n            return lockedCanvasId;\\r\\n        }\\r\\n\\r\\n        // first canvasId is 1 INDEXED => the offset + the artwork id + 1\\r\\n        uint16 currCanvasId = uint16(((canvasIdStartOffsets[layer] + artworkId) % (NUM_CANVAS_IDS)) + 1);\\r\\n\\r\\n        // We begin at action 1, and then find corresponding canvasId. Then we incriment for each\\r\\n        // action while also checking if canvasId has been locked in the past. This will be expensive\\r\\n        // when many layers are locked.\\r\\n\\r\\n        \\r\\n        // this will start on second action, and then work way up to latest final action\\r\\n        for(uint8 i = 1; i < action; i++) {\\r\\n\\r\\n            // incriment the currentCanvasId\\r\\n            currCanvasId = incrimentCanvasId(currCanvasId);\\r\\n\\r\\n            // check if this canvas was locked on a previous action\\r\\n            uint8 canvasLockedOnAction = lockedLayerHistory[currCanvasId][layer];\\r\\n            \\r\\n            // TODO: Prevent infinite loop just in case??\\r\\n\\r\\n            // while canvasId was locked on a previous action, incriment the current canvasId\\r\\n            while( canvasLockedOnAction != 0 && canvasLockedOnAction <= i) {\\r\\n\\n                // advance canvas step\\r\\n                currCanvasId = incrimentCanvasId(currCanvasId);\\r\\n                canvasLockedOnAction = lockedLayerHistory[currCanvasId][layer];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return currCanvasId;\\r\\n    }\\r\\n\\r\\n    \\r\\n    /**\\r\\n     * @dev Ease in quadratic lerp function -- x * x, invert for ease out\\r\\n     */\\r\\n    function easeInQuad(uint256 min, uint256 max, uint256 numerator, uint256 denominator) \\r\\n        internal pure returns (uint256) \\r\\n    {\\r\\n        if(min <= max) {\\r\\n            // min + (max - min) * x^2\\r\\n            return (max.sub(min)).mul(numerator).mul(numerator).div(denominator).div(denominator).add(min);\\r\\n        }\\r\\n        // inverted -> max - (max - min) * x^2\\r\\n        return min.sub((min.sub(max)).mul(numerator).mul(numerator).div(denominator).div(denominator));\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Updates the URI in case of domain change or switch to IPFS in the future;\\r\\n     */\\r\\n    function setBaseURI(string calldata newURI) public onlyOwner {\\r\\n        baseURI = newURI;\\r\\n    }\\r\\n    \\r\\n\\r\\n    /**\\r\\n     * @dev Withdrawl funds to owner\\r\\n     *   - This saves gas vs if each payment was sent to owner\\r\\n     */\\r\\n    function withdrawlFunds() public {\\r\\n        (bool success, ) = address(0x1Df3260ea86d338404aC49F3D33cec477a46A827).call{value: address(this).balance}(\\\"\\\");\\r\\n        require(success, \\\"Transfer failed.\\\");\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"cache/solpp-generated-contracts/ILockingLayers.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Interface for locking layer artwork project. Implemented interface will allow for functional website.\\r\\n */\\r\\ninterface ILockingLayers {\\r\\n\\r\\n    /** Artwork tier, used for pricing, # layers locked, and gallery benefits */\\r\\n    enum ArtworkTier {\\r\\n        ENTHUSIAST,\\r\\n        COLLECTOR,\\r\\n        STRATA\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when layer successfully locked.\\r\\n     */\\r\\n    event LayerLocked(uint256 artworkId, uint8 layer, uint256 canvasId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emit on purchase to know which artwork tier and original owner\\r\\n     */\\r\\n    event ArtworkPurchased(uint256 artworkId, uint8 tier);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current price to buy an artwork in wei.\\r\\n     */\\r\\n    function currentPrice(ArtworkTier tier) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of artworks issued.\\r\\n     */\\r\\n    function totalArtworks() external view returns (uint16);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total artworks remaining across all tiers.\\r\\n     */\\r\\n    function availableArtworks() external view returns (uint16);\\r\\n\\r\\n    /**\\r\\n     * @dev Get the price and available artworks for a given tier\\r\\n     *   - Returns:\\r\\n     *      - uint256 => PRICE in wei\\r\\n     *      - uint256 => available artworks\\r\\n     */\\r\\n    function getTierPurchaseData(ArtworkTier tier) external view returns (uint256, uint16); \\r\\n\\r\\n    /**\\r\\n     * @dev Get canvasIds for each layer for artwork.\\r\\n     */\\r\\n    function getCanvasIds(uint256 artworkId) external view returns (uint16, uint16, uint16, uint16);\\r\\n\\r\\n    /**\\r\\n     * @dev The number of blocks remaining until next layer is revealed.\\r\\n     */\\r\\n    function blocksUntilNextLayerRevealed() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if an artwork can lock the current layer.\\r\\n     */\\r\\n    function canLock(uint256 artworkId) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Purchases an artwork.\\r\\n     *   - Returns the artworkID of purchased work.\\r\\n     *   - Reverts if insuffiscient funds or no artworks left.\\r\\n     */\\r\\n    function purchase(ArtworkTier tier) external payable returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Lock artwork layer.\\r\\n     *   - Reverts if cannot lock.\\r\\n     */\\r\\n    function lockLayer(uint256 artworkId) external; \\r\\n\\r\\n\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/VRFConsumerBase.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\r\\n/* EDITED FOR COMPATABILITY WITH 0.8.0 COMPILER */\\r\\n/* Edited on 22/04/2021 by Jasper Degens */\\r\\n\\r\\n\\r\\n\\r\\n// Trimmed down interface for just VRF functions\\r\\nimport \\\"./LinkTokenInterfaceSimplified.sol\\\";\\r\\n\\r\\nimport \\\"./VRFRequestIDBase.sol\\\";\\r\\n\\r\\n/** ****************************************************************************\\r\\n * @notice Interface for contracts using VRF randomness\\r\\n * *****************************************************************************\\r\\n * @dev PURPOSE\\r\\n *\\r\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\r\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\r\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\r\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\r\\n * @dev Reggie, he gives back a value which is computed completely\\r\\n * @dev deterministically from the seed and the secret key.\\r\\n *\\r\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\r\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\r\\n * @dev the output is indistinguishable to her from a uniform random sample\\r\\n * @dev from the output space.\\r\\n *\\r\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\r\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\r\\n * @dev simple access to a verifiable source of randomness.\\r\\n * *****************************************************************************\\r\\n * @dev USAGE\\r\\n *\\r\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\r\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\r\\n * @dev shown:\\r\\n *\\r\\n * @dev   contract VRFConsumer {\\r\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\r\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\r\\n * @dev         <initialization with other arguments goes here>\\r\\n * @dev       }\\r\\n * @dev   }\\r\\n *\\r\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\r\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\r\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\r\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\r\\n * @dev want to generate randomness from.\\r\\n *\\r\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\r\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\r\\n *\\r\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\r\\n * @dev generated from your seed.\\r\\n *\\r\\n * @dev The requestId argument is generated from the keyHash and the seed by\\r\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\r\\n * @dev requests open, you can use the requestId to track which seed is\\r\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\r\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\r\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\r\\n *\\r\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\r\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\r\\n * @dev next section.)\\r\\n *\\r\\n * *****************************************************************************\\r\\n * @dev SECURITY CONSIDERATIONS\\r\\n *\\r\\n * @dev A method with the ability to call your fulfillRandomness method directly\\r\\n * @dev could spoof a VRF response with any random value, so it's critical that\\r\\n * @dev it cannot be directly called by anything other than this base contract\\r\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\r\\n *\\r\\n * @dev For your users to trust that your contract's random behavior is free\\r\\n * @dev from malicious interference, it's best if you can write it so that all\\r\\n * @dev behaviors implied by a VRF response are executed *during* your\\r\\n * @dev fulfillRandomness method. If your contract must store the response (or\\r\\n * @dev anything derived from it) and use it later, you must ensure that any\\r\\n * @dev user-significant behavior which depends on that stored value cannot be\\r\\n * @dev manipulated by a subsequent VRF request.\\r\\n *\\r\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\r\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\r\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\r\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\r\\n * @dev be used to manipulate your contract's user-significant behavior.\\r\\n *\\r\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\r\\n * @dev block in which the request is made, user-provided seeds have no impact\\r\\n * @dev on its economic security properties. They are only included for API\\r\\n * @dev compatability with previous versions of this contract.\\r\\n *\\r\\n * @dev Since the block hash of the block which contains the requestRandomness\\r\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\r\\n * @dev miner could, in principle, fork the blockchain to evict the block\\r\\n * @dev containing the request, forcing the request to be included in a\\r\\n * @dev different block with a different hash, and therefore a different input\\r\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\r\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\r\\n * @dev until it calls responds to a request.\\r\\n */\\r\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\r\\n\\r\\n  /**\\r\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\r\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\r\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\r\\n   * @notice method.\\r\\n   *\\r\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\r\\n   * @dev signature, and will call it once it has verified the proof\\r\\n   * @dev associated with the randomness. (It is triggered via a call to\\r\\n   * @dev rawFulfillRandomness, below.)\\r\\n   *\\r\\n   * @param requestId The Id initially returned by requestRandomness\\r\\n   * @param randomness the VRF output\\r\\n   */\\r\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\\r\\n    internal virtual;\\r\\n\\r\\n  /**\\r\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\r\\n   *\\r\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\r\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\r\\n   *\\r\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\r\\n   * @dev the _fee must exceed the fee specified during registration of the\\r\\n   * @dev _keyHash.\\r\\n   *\\r\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\r\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\r\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\r\\n   * @dev oracle will mix the hash of the block containing your request into the\\r\\n   * @dev VRF seed it ultimately uses.\\r\\n   *\\r\\n   * @param _keyHash ID of public key against which randomness is generated\\r\\n   * @param _fee The amount of LINK to send with the request\\r\\n   * @param _seed seed mixed into the input of the VRF.\\r\\n   *\\r\\n   * @return requestId unique ID for this request\\r\\n   *\\r\\n   * @dev The returned requestId can be used to distinguish responses to\\r\\n   * @dev concurrent requests. It is passed as the first argument to\\r\\n   * @dev fulfillRandomness.\\r\\n   */\\r\\n  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\\r\\n    internal returns (bytes32 requestId)\\r\\n  {\\r\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\\r\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\r\\n    // the hash of the block containing this request to obtain the seed/input\\r\\n    // which is finally passed to the VRF cryptographic machinery.\\r\\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\\r\\n    // nonces[_keyHash] must stay in sync with\\r\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\r\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\r\\n    // This provides protection against the user repeating their input seed,\\r\\n    // which would result in a predictable/duplicate output, if multiple such\\r\\n    // requests appeared in the same block.\\r\\n    nonces[_keyHash] = nonces[_keyHash] + 1;\\r\\n    return makeRequestId(_keyHash, vRFSeed);\\r\\n  }\\r\\n\\r\\n  LinkTokenInterfaceSimplified immutable internal LINK;\\r\\n  address immutable private vrfCoordinator;\\r\\n\\r\\n  // Nonces for each VRF key from which randomness has been requested.\\r\\n  //\\r\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\r\\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\\r\\n\\r\\n  /**\\r\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\r\\n   * @param _link address of LINK token contract\\r\\n   *\\r\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\r\\n   */\\r\\n  constructor(address _vrfCoordinator, address _link) {\\r\\n    vrfCoordinator = _vrfCoordinator;\\r\\n    LINK = LinkTokenInterfaceSimplified(_link);\\r\\n  }\\r\\n\\r\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\r\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\r\\n  // the origin of the call\\r\\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\r\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\r\\n    fulfillRandomness(requestId, randomness);\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"./extensions/IERC721Enumerable.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping (uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping (address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC721).interfaceId\\n            || interfaceId == type(IERC721Metadata).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0\\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\\n            : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\\n     * in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/LinkTokenInterfaceSimplified.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\n\\r\\ninterface LinkTokenInterfaceSimplified {\\r\\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\\r\\n  function balanceOf(address owner) external view returns (uint256 balance);\\r\\n}\"\r\n    },\r\n    \"cache/solpp-generated-contracts/VRFRequestIDBase.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\n\\r\\ncontract VRFRequestIDBase {\\r\\n\\r\\n  /**\\r\\n   * @notice returns the seed which is actually input to the VRF coordinator\\r\\n   *\\r\\n   * @dev To prevent repetition of VRF output due to repetition of the\\r\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\r\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\r\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\r\\n   * @dev the final seed, but the nonce does protect against repetition in\\r\\n   * @dev requests which are included in a single block.\\r\\n   *\\r\\n   * @param _userSeed VRF seed input provided by user\\r\\n   * @param _requester Address of the requesting contract\\r\\n   * @param _nonce User-specific nonce at the time of the request\\r\\n   */\\r\\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\\r\\n    address _requester, uint256 _nonce)\\r\\n    internal pure returns (uint256)\\r\\n  {\\r\\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the id for this request\\r\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\r\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\r\\n   * @return The id for this request\\r\\n   *\\r\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\r\\n   * @dev contract, but the one generated by makeVRFInputSeed\\r\\n   */\\r\\n  function makeRequestId(\\r\\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\r\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"artworkId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"tier\",\"type\":\"uint8\"}],\"name\":\"ArtworkPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"artworkId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"layer\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"canvasId\",\"type\":\"uint256\"}],\"name\":\"LayerLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AUTOMATIC_START_BLOCK_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"artworkTier\",\"outputs\":[{\"internalType\":\"enum ILockingLayers.ArtworkTier\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableArtworks\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksUntilNextLayerRevealed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"artworkId\",\"type\":\"uint256\"}],\"name\":\"canLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"canvasIdStartOffsets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ILockingLayers.ArtworkTier\",\"name\":\"tier\",\"type\":\"uint8\"}],\"name\":\"currentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstPurchaseBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAction\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"artworkId\",\"type\":\"uint256\"}],\"name\":\"getCanvasIds\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentLayerAndAction\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ILockingLayers.ArtworkTier\",\"name\":\"tier\",\"type\":\"uint8\"}],\"name\":\"getTierPurchaseData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"artworkId\",\"type\":\"uint256\"}],\"name\":\"lockLayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"artworkId\",\"type\":\"uint256\"}],\"name\":\"locksRemaining\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ILockingLayers.ArtworkTier\",\"name\":\"tier\",\"type\":\"uint8\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestStartArtwork\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalArtworks\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawlFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LockingLayers","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}