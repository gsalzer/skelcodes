{"status":"1","message":"OK","result":[{"SourceCode":"/// SPDX-License-Identifier: MIT\r\n/*\r\n▄▄█    ▄   ██   █▄▄▄▄ ▄█ \r\n██     █  █ █  █  ▄▀ ██ \r\n██ ██   █ █▄▄█ █▀▀▌  ██ \r\n▐█ █ █  █ █  █ █  █  ▐█ \r\n ▐ █  █ █    █   █    ▐ \r\n   █   ██   █   ▀   \r\n           ▀          */\r\n/// Special thanks to Keno and Boring for reviewing early bridge patterns.\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0\r\n/// License-Identifier: MIT\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n\r\n    function to64(uint256 a) internal pure returns (uint64 c) {\r\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\r\n        c = uint64(a);\r\n    }\r\n\r\n    function to32(uint256 a) internal pure returns (uint32 c) {\r\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\r\n        c = uint32(a);\r\n    }\r\n}\r\n\r\n/// @notice Interface for SushiSwap.\r\ninterface ISushiSwap {\r\n    function deposit() external payable; // wETH deposit\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0\r\n/// License-Identifier: MIT\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0\r\n/// License-Identifier: MIT\r\n\r\nlibrary BoringERC20 {\r\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\r\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\r\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\r\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\r\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\r\n\r\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param from Transfer tokens from.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\r\n    }\r\n}\r\n\r\n/// @notice Contract that batches SUSHI staking and DeFi strategies.\r\ncontract Inari {\r\n    using BoringMath for uint256;\r\n    using BoringERC20 for IERC20;\r\n    \r\n    address constant wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address constant sushiSwapFactory = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac; // SushiSwap factory contract\r\n    ISushiSwap constant sushiSwapSushiWethPair = ISushiSwap(0x795065dCc9f64b5614C407a6EFDC400DA6221FB0); // \r\n    \r\n    function swap1() external payable {\r\n        (uint256 reserve0, uint256 reserve1, ) = sushiSwapSushiWethPair.getReserves();\r\n        uint256 amountInWithFee = msg.value.mul(997);\r\n        uint256 amountOut =\r\n            amountInWithFee.mul(reserve1) /\r\n            reserve0.mul(1000).add(amountInWithFee);\r\n        ISushiSwap(wETH).deposit{value: msg.value}();\r\n        IERC20(wETH).approve(address(sushiSwapSushiWethPair), msg.value);\r\n        IERC20(wETH).safeTransfer(address(sushiSwapSushiWethPair), msg.value);\r\n        sushiSwapSushiWethPair.swap(0, amountOut, msg.sender, \"\");\r\n    }\r\n    \r\n    function swap2() external payable {\r\n        (uint256 reserve0, uint256 reserve1, ) = sushiSwapSushiWethPair.getReserves();\r\n        uint256 amountInWithFee = msg.value.mul(997);\r\n        uint256 amountOut =\r\n            amountInWithFee.mul(reserve0) /\r\n            reserve1.mul(1000).add(amountInWithFee);\r\n        ISushiSwap(wETH).deposit{value: msg.value}();\r\n        IERC20(wETH).approve(address(sushiSwapSushiWethPair), msg.value);\r\n        IERC20(wETH).safeTransfer(address(sushiSwapSushiWethPair), msg.value);\r\n        sushiSwapSushiWethPair.swap(amountOut, 0, msg.sender, \"\");\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"swap1\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap2\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"Inari","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://471dfe62536f794935f52f7df4bd2a6de25c67e7180d27c25c096460daa8dbf6"}]}