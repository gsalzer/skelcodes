{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n\r\n    function name() external view returns (string memory);\r\n\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n \r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata, Ownable{\r\n    mapping (address => uint256) internal _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 internal _decimals;\r\n\r\n\r\n    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n    }\r\n\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\ncontract ExclusiveNetwork is ERC20(\"Exclusive Network\", \"Exc\", 18) {\r\n    \r\n    // Declaring fund receiver\r\n    address private  fund_receiver = payable(0x2B489D6470501a81C9dD309B7f731E337bA9C337);\r\n    /*\r\n    * **** above are the address for the fund receiver wallet for the presale.\r\n    * ________________________________________________________________________________________________________________________________\r\n    */\r\n    \r\n    \r\n    uint256 public tokenRate = 500000*(10**18);\r\n     \r\n    // Declaring the roles and lock time for the wallets.\r\n    struct RolesLocked {\r\n       address[] address_;\r\n       uint8 percentLocked;\r\n       uint256 timeLocked;\r\n    }\r\n    \r\n    mapping (string => RolesLocked) private roles;\r\n    mapping (address => uint256) private presale_total_per_user;\r\n    uint256 public per_person_cap = 5070000000000000000;\r\n    \r\n    \r\n    \r\n    // unlocked declaration\r\n    struct RolesUnlocked {\r\n        address address_;\r\n        uint8 percent;\r\n    }\r\n    // \r\n    \r\n    /*\r\n    * **** below are the address for the unlocked wallet.\r\n    * __________________________________________________________________________________________________________________________________\r\n    */\r\n    \r\n    RolesUnlocked public public_sale_unlocked = RolesUnlocked(0x7642B7ecBEc2a37f1ab9fdbf19Eb2Fede28E2301, 40); // public sale address will mint with 25 % of totalSupply\r\n    RolesUnlocked public exchanges_and_liquidity_unlocked = RolesUnlocked(0x441db5A35c4241060703737C4786f6A87d55034F, 5); // exchanges_and_liquidity address will mint with 5 % of totalSupply\r\n    RolesUnlocked public marketing_unlocked = RolesUnlocked(0xAD7fD36B13bdA52048616B9A02E59b60CB3f78B2, 10); // marking address will mint with 10 % of totalSupply\r\n    RolesUnlocked public presale_unlocked = RolesUnlocked(0x7423C1831C50AeA3868780e7b4f8d5F090242a8F, 10); // presale address will mint with 20 % of totalSupply\r\n\r\n    /*\r\n    * **** above are the address for the unlocked wallet.\r\n    * __________________________________________________________________________________________________________________________________\r\n    */\r\n    \r\n    // fund collect for the presale.\r\n    uint256 public presale_fund;\r\n    \r\n    // declaration of requirements for the presale.\r\n    bool public isPresaleStarted = false;\r\n\r\n    \r\n    constructor(){\r\n        // filling the roles address and locked timeline.\r\n        \r\n        /*\r\n        * **** below are the address for the locked wallets.\r\n        * ____________________________________________________________________________________________________________________________________\r\n        */\r\n        address[] memory partnership = new address[](3); // address Array with a length of 1 So you can add only one address here. Please change the length in case to add any address.\r\n        partnership[0] = 0x1827A11990001d5f9F6Ca21d5D752A84f4265835; // adding address to the first index of the partnership address array.\r\n        partnership[1] = 0x03653cFB415ba73b9cB9D178cc339f5eC0fc6351; // In case of mulitple accounts.\r\n        partnership[2] = 0x166E5d714be7a73351E28A2835CCb77D8Dc119CF; // In case of mulitple accounts.\r\n        roles[\"partnership_locked_address\"] = RolesLocked(partnership, 15,   block.timestamp + 63072000); // blocktime + 2 years of time. with 15%\r\n        \r\n        \r\n        /*\r\n        * In team there are two members. so the team array have the lenght initialize to 2.\r\n        * after that first address will go to the index 0 and second will go to the index 1 as shown below.\r\n        * This process can be follow for the multiple addresses in each locked array.\r\n        * Minting will distribute the token equally to all the address and lock them. \r\n        *__________________________________________________________________________________________________++++++++++++++++++++++++++++++++\r\n        */\r\n        address[] memory team = new address[](2);\r\n        team[0] = 0x2d6362839a58235698123f520237Dd3052A56AAb;\r\n        team[1] = 0xE05F5F34B23E55eaac3D4f6DceBb402b1ec6760E;\r\n        roles[\"team_locked_address\"] = RolesLocked(team, 10,   block.timestamp + 63072000 ); // blocktime + 2 year of time. with 10%\r\n        \r\n        address[] memory advisors = new address[](1);\r\n        advisors[0] = 0x2a7D8a9298b753B9E74575dB8C5f9bCFfbA1e7Bb;\r\n        roles[\"advisors_locked_address\"] = RolesLocked(advisors, 5,   block.timestamp + 31536000); // blocktime + 1 year with 5 %. \r\n        \r\n        address[] memory reserve = new address[](1);\r\n        reserve[0] = 0x04b1a69d7d943217a1C95efAdFA8d653c5E8FC3e;\r\n        roles[\"Reserve_locked_address\"] = RolesLocked(reserve, 5, block.timestamp + 31536000); // blocktime + 1 year with 5 %.\r\n        \r\n        /*\r\n        * **** above are the address for the locked wallets.\r\n        * _____________________________________________________________________________________________________________________________________\r\n        */\r\n        \r\n        // minting the tokens to as per the tokenomics.\r\n        uint256 supply = 2 * (10**9) * (10**18);\r\n        \r\n        for(uint i=0; i < roles['partnership_locked_address'].address_.length; i++){\r\n            _mint(roles['partnership_locked_address'].address_[i], (roles['partnership_locked_address'].percentLocked*supply)/(100*roles['partnership_locked_address'].address_.length)); // Minting to the partnership_locked_address.\r\n        }\r\n        \r\n        for(uint i=0; i < roles['team_locked_address'].address_.length; i++){\r\n            _mint(roles['team_locked_address'].address_[i], (roles['team_locked_address'].percentLocked*supply)/(100*roles['team_locked_address'].address_.length)); // Minting to the Team_locked_address.\r\n        }\r\n        \r\n        for(uint i=0; i < roles['advisors_locked_address'].address_.length; i++){\r\n            _mint(roles['advisors_locked_address'].address_[i], (roles['advisors_locked_address'].percentLocked*supply)/(100*roles['advisors_locked_address'].address_.length)); // Minting to the advisors_locked_address.\r\n        }\r\n        \r\n        for(uint i=0; i < roles[\"Reserve_locked_address\"].address_.length; i++){\r\n            _mint(roles['Reserve_locked_address'].address_[0], (roles['Reserve_locked_address'].percentLocked*supply)/(100*roles['Reserve_locked_address'].address_.length)); // Minting to the Reserve_locked_address.\r\n        }\r\n        \r\n        /*\r\n        * ****** Minting process for the locked token address.\r\n        *__________________________________________________________________________________________\r\n        */\r\n        \r\n        // minting to the unlocked address.\r\n        _mint(public_sale_unlocked.address_, (public_sale_unlocked.percent*supply)/100); // Minting to the public_sale_unlocked.\r\n        _mint(exchanges_and_liquidity_unlocked.address_, (exchanges_and_liquidity_unlocked.percent*supply)/100); // Minting to the exchanges_and_liquidity_unlocked.\r\n        _mint(marketing_unlocked.address_, (marketing_unlocked.percent*supply)/100); // Minting to the marketing_unlocked.\r\n        \r\n        // setting the fund for the presale. 25% will be locked for the presale.\r\n        _mint(presale_unlocked.address_, (presale_unlocked.percent*supply)/100); // Minting to the presale_unlocked.\r\n        presale_fund = (20*((presale_unlocked.percent*supply)/100)/100);\r\n        _approve(presale_unlocked.address_, address(this), (presale_unlocked.percent*supply)/100);\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) override internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        \r\n        /*\r\n        * Checking for the locked address. It will reject the transaction if the locked address have not meet the deadline.\r\n        * __________________________________________________________________________________________\r\n        */\r\n        \r\n        for(uint i=0; i < roles['partnership_locked_address'].address_.length; i++){\r\n            if (sender==roles['partnership_locked_address'].address_[i]){\r\n                require(roles['partnership_locked_address'].timeLocked < block.timestamp, \"ERC20: TimeClock not reached for partnership_locked_address.\");\r\n            } \r\n        }\r\n        \r\n        for(uint i=0; i < roles['team_locked_address'].address_.length; i++){\r\n            if (sender==roles['team_locked_address'].address_[0]){ \r\n                require(roles['team_locked_address'].timeLocked < block.timestamp, \"ERC20: TimeClock not reached for team_locked_address.\");\r\n            }\r\n        }\r\n        \r\n        for(uint i=0; i < roles['advisors_locked_address'].address_.length; i++){\r\n            if (sender==roles['advisors_locked_address'].address_[0]) { \r\n                require(roles['advisors_locked_address'].timeLocked < block.timestamp, \"ERC20: TimeClock not reached for advisors_locked_address.\");\r\n            }    \r\n        }\r\n        \r\n        for(uint i=0; i < roles['Reserve_locked_address'].address_.length; i++){\r\n            if (sender==roles['Reserve_locked_address'].address_[0]) {\r\n                require(roles['Reserve_locked_address'].timeLocked < block.timestamp, \"ERC20: TimeClock not reached for Reserve_locked_address.\");\r\n            } \r\n        }\r\n         \r\n        \r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n    \r\n    \r\n    function startPresale() public onlyOwner {\r\n        isPresaleStarted = true;        \r\n    }\r\n    \r\n    function endPresale() public onlyOwner {\r\n        isPresaleStarted = false;\r\n    }\r\n    \r\n    function changePerPersonCap(uint256 _newCap) public onlyOwner {\r\n        per_person_cap = _newCap;\r\n    }\r\n    \r\n    function buyToken() public payable {\r\n        require(msg.sender!=address(0), \"ERC20: zero address cannot buy tokens\");\r\n        require(msg.value> 0, \"ERC20: value is Zero\");\r\n        require(isPresaleStarted == true,\"ERC20: Sale Not Started!\");\r\n        require(msg.value <= per_person_cap - presale_total_per_user[msg.sender], \"ERC20: Requested amount exceed the per user Limit.\");\r\n        \r\n        uint256 transferAmount = (msg.value*tokenRate)/(10**18);\r\n        \r\n        require(presale_fund >= transferAmount, \"ERC20: Presale fund remaining not meeting the requirements.\");\r\n        \r\n        _transfer(presale_unlocked.address_, msg.sender, (20*transferAmount/100));\r\n        presale_fund -= (20*transferAmount/100);\r\n        \r\n        payable(fund_receiver).transfer(msg.value);\r\n        presale_total_per_user[msg.sender] += msg.value;\r\n        \r\n    }\r\n    \r\n    function setTokenRate(uint256 _no_of_token_per_eth_withDecimals) public onlyOwner {\r\n        //  Note: Rate = number of tokens per eth * token decimals. \r\n        tokenRate = _no_of_token_per_eth_withDecimals;\r\n    }\r\n    \r\n    function Airdrop(address[] memory _airdropReceivers, uint256[] memory _amountWithDecimals) public  {\r\n        // Please check the allowance from the funded wallet before calling the function.\r\n        \r\n        // second argument is the array of the address of the airdrop receivers.\r\n        for(uint i=0; i<_airdropReceivers.length; i++){\r\n            transfer(_airdropReceivers[i], _amountWithDecimals[i]);\r\n        }\r\n    }\r\n    \r\n    function get_partnership_locked_details() view public returns(RolesLocked memory){\r\n        return roles[\"partnership_locked_address\"];\r\n    }\r\n    \r\n    function get_team_locked_details() view public returns(RolesLocked memory){\r\n        return roles[\"team_locked_address\"];\r\n    }\r\n    \r\n    function get_advisor_locked_details() view public returns(RolesLocked memory){\r\n        return roles[\"advisors_locked_address\"];\r\n    }\r\n    \r\n    function get_reserved_locked_details() view public returns(RolesLocked memory){\r\n        return roles[\"Reserve_locked_address\"];\r\n    }\r\n    \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_airdropReceivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amountWithDecimals\",\"type\":\"uint256[]\"}],\"name\":\"Airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newCap\",\"type\":\"uint256\"}],\"name\":\"changePerPersonCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchanges_and_liquidity_unlocked\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_advisor_locked_details\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"address_\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"percentLocked\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timeLocked\",\"type\":\"uint256\"}],\"internalType\":\"struct ExclusiveNetwork.RolesLocked\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_partnership_locked_details\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"address_\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"percentLocked\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timeLocked\",\"type\":\"uint256\"}],\"internalType\":\"struct ExclusiveNetwork.RolesLocked\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_reserved_locked_details\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"address_\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"percentLocked\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timeLocked\",\"type\":\"uint256\"}],\"internalType\":\"struct ExclusiveNetwork.RolesLocked\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_team_locked_details\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"address_\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"percentLocked\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timeLocked\",\"type\":\"uint256\"}],\"internalType\":\"struct ExclusiveNetwork.RolesLocked\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPresaleStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketing_unlocked\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"per_person_cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presale_fund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presale_unlocked\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"public_sale_unlocked\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_no_of_token_per_eth_withDecimals\",\"type\":\"uint256\"}],\"name\":\"setTokenRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ExclusiveNetwork","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7b28b02f040a655449e2594c03c552f18dd910c86a7c2a3044b8ceb3e2aefa8c"}]}