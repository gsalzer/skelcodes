{"status":"1","message":"OK","result":[{"SourceCode":"/// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n/// @dev brief interface for moloch dao v2 erc20 token txs\r\ninterface IERC20 { \r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n/// @dev brief interface for moloch dao v2 \r\ninterface IMOLOCH { \r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        string calldata details\r\n    ) external returns (uint256);\r\n    \r\n    function getProposalFlags(uint256 proposalId) external view returns (bool[6] memory);\r\n    \r\n    function withdrawBalance(address token, uint256 amount) external;\r\n}\r\n\r\n/// @dev brief interface for sushi bar (`xSUSHI`) entry\r\ninterface ISushiBar { \r\n   function enter(uint256 _amount) external;\r\n}\r\n\r\n/// @dev helper for address type\r\nlibrary Address { \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/// @dev helper for non-standard token\r\nlibrary SafeERC20 { \r\n    using Address for address;\r\n    \r\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\r\n    }\r\n    \r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\r\n    }\r\n    \r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returnData) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returnData.length > 0) { // return data is optional\r\n            require(abi.decode(returnData, (bool)), \"SafeERC20: erc20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/// @dev helper for under/overflow check\r\nlibrary SafeMath { \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n}\r\n\r\n/// @dev call wrapper for reentrancy check\r\ncontract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/// @dev low-level caller, ETH holder, separate bank for moloch dao v2 - based on raid guild `Minion`\r\ncontract SushiMinion is ReentrancyGuard {\r\n    address immutable sushiToken; // internal sushi token contract reference\r\n    IMOLOCH public moloch; // parent moloch contract reference \r\n\r\n    mapping(uint256 => Action) public actions; // proposalId => Action\r\n\r\n    struct Action {\r\n        uint256 value;\r\n        address to;\r\n        address proposer;\r\n        bool executed;\r\n        bytes data;\r\n    }\r\n\r\n    event ProposeAction(uint256 proposalId, address proposer);\r\n    event ExecuteAction(uint256 proposalId, address executor);\r\n\r\n    constructor(address _moloch, address _sushiToken, address _xSushiToken, address _aave) public {\r\n        moloch = IMOLOCH(_moloch);\r\n        sushiToken = _sushiToken;\r\n        IERC20(_sushiToken).approve(_xSushiToken, uint256(-1)); // max approve sushi bar for sushi token staking into xSushi\r\n        IERC20(_xSushiToken).approve(_aave, uint256(-1)); // max approve aave for deposit into aToken from underlying xSushi\r\n    }\r\n\r\n    function doWithdraw(address token, uint256 amount) external nonReentrant {\r\n        moloch.withdrawBalance(token, amount); // withdraw funds from parent moloch into minion\r\n    }\r\n\r\n    function proposeAction(\r\n        address actionTo,\r\n        uint256 actionValue,\r\n        bytes calldata actionData,\r\n        string calldata details\r\n    ) external nonReentrant returns (uint256) {\r\n        // No calls to zero address allows us to check that proxy submitted\r\n        // the proposal without getting the proposal struct from parent moloch\r\n        require(actionTo != address(0), \"invalid actionTo\");\r\n\r\n        uint256 proposalId = moloch.submitProposal(\r\n            address(this),\r\n            0,\r\n            0,\r\n            0,\r\n            sushiToken,\r\n            0,\r\n            sushiToken,\r\n            details\r\n        );\r\n\r\n        Action memory action = Action({\r\n            value: actionValue,\r\n            to: actionTo,\r\n            proposer: msg.sender,\r\n            executed: false,\r\n            data: actionData\r\n        });\r\n\r\n        actions[proposalId] = action;\r\n\r\n        emit ProposeAction(proposalId, msg.sender);\r\n        return proposalId;\r\n    }\r\n\r\n    function executeAction(uint256 proposalId) external nonReentrant returns (bytes memory) {\r\n        Action memory action = actions[proposalId];\r\n        bool[6] memory flags = moloch.getProposalFlags(proposalId);\r\n\r\n        require(action.to != address(0), \"invalid proposalId\");\r\n        require(!action.executed, \"action executed\");\r\n        require(address(this).balance >= action.value, \"insufficient ETH\");\r\n        require(flags[2], \"proposal not passed\");\r\n\r\n        // execute call\r\n        actions[proposalId].executed = true;\r\n        (bool success, bytes memory retData) = action.to.call{value: action.value}(action.data);\r\n        require(success, \"call failure\");\r\n        emit ExecuteAction(proposalId, msg.sender);\r\n        return retData;\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n\r\n/*=====================================\r\nWELCOME TO THE POOL PARTY (飲み会)\r\n_Developed by Peeps Democracy & LexDAO\r\n__USE AT YOUR OWN RISK\r\n=====================================*/\r\n/// SushiNomikai is the coolest party in town. You come in with some Sushi and stake (xSushi) to vote on party matters, like what food gets served. You can leave anytime with your fair share of party food. \r\ncontract SushiNomikai is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /***************\r\n    GLOBAL CONSTANTS\r\n    ***************/\r\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\r\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\r\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\r\n    uint256 public proposalDeposit; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\r\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\r\n    uint256 public processingReward; // default = 0.1 - amount of ETH to give to whoever processes a proposal\r\n    uint256 immutable summoningTime; // needed to determine the current period\r\n    \r\n    address payable public immutable sushiMinion; // sushi minion contract reference\r\n    address immutable depositToken; // deposit token contract reference; default = SUSHI\r\n    address immutable sushiToken; // sushi token contract reference\r\n    address immutable xSushiToken; // \"sushi bar\" xSushi token contract reference\r\n\r\n    // HARD-CODED LIMITS\r\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\r\n    // with periods or shares, yet big enough to not limit reasonable use cases.\r\n    uint256 constant MAX_VOTING_PERIOD_LENGTH = 10**18; // maximum length of voting period\r\n    uint256 constant MAX_GRACE_PERIOD_LENGTH = 10**18; // maximum length of grace period\r\n    uint256 constant MAX_DILUTION_BOUND = 10**18; // maximum dilution bound\r\n    uint256 constant MAX_NUMBER_OF_SHARES_AND_LOOT = uint256(-1); // maximum number of shares that can be minted\r\n    uint256 constant MAX_TOKEN_WHITELIST_COUNT = 400; // maximum number of whitelisted tokens\r\n    uint256 constant MAX_TOKEN_GUILDBANK_COUNT = 200; // maximum number of tokens with non-zero balance in guildbank\r\n\r\n    // ***************\r\n    // EVENTS\r\n    // ***************\r\n    event SummonComplete(address indexed summoner, address[] tokens, uint256 summoningTime, uint256 periodDuration, uint256 votingPeriodLength, uint256 gracePeriodLength, uint256 proposalDeposit, uint256 dilutionBound, uint256 processingReward);\r\n    event MakeDeposit(address indexed memberAddress, uint256 tributeOffered, uint256 shares);\r\n    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, string details, bool[6] flags, uint256 proposalId, address indexed delegateKey, address indexed memberAddress);\r\n    event SponsorProposal(address indexed delegateKey, address indexed memberAddress, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);\r\n    event SubmitVote(uint256 proposalId, uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\r\n    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessWhitelistProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessGuildKickProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);\r\n    event TokensCollected(address indexed token, uint256 amountToCollect);\r\n    event CancelProposal(uint256 indexed proposalId, address applicantAddress);\r\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\r\n    event Withdraw(address indexed memberAddress, address token, uint256 amount);\r\n    event InternalTransfer(address indexed from, address indexed to, address token, uint256 amount);\r\n\r\n    // *******************\r\n    // INTERNAL ACCOUNTING\r\n    // *******************\r\n    uint256 public proposalCount = 0; // total proposals submitted\r\n    uint256 public totalShares = 0; // total shares across all members\r\n    uint256 public totalLoot = 0; // total loot across all members\r\n\r\n    uint256 public totalGuildBankTokens = 0; // total tokens with non-zero balance in guild bank\r\n\r\n    address public constant GUILD = address(0xdead);\r\n    address public constant ESCROW = address(0xbeef);\r\n    address public constant TOTAL = address(0xbabe);\r\n    mapping(address => mapping(address => uint256)) public userTokenBalances; // userTokenBalances[userAddress][tokenAddress]\r\n\r\n    enum Vote {\r\n        Null, // default value, counted as abstention\r\n        Yes,\r\n        No\r\n    }\r\n\r\n    struct Member {\r\n        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated\r\n        uint256 shares; // the # of voting shares assigned to this member\r\n        uint256 loot; // the loot amount available to this member (combined with shares on ragequit)\r\n        bool exists; // always true once a member has been created\r\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\r\n        uint256 jailed; // set to proposalIndex of a passing guild kick proposal for this member, prevents voting on and sponsoring proposals\r\n    }\r\n\r\n    struct Proposal {\r\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as guild kick target for gkick proposals)\r\n        address proposer; // the account that submitted the proposal (can be non-member)\r\n        address sponsor; // the member that sponsored the proposal (moving it into the queue)\r\n        uint256 sharesRequested; // the # of shares the applicant is requesting\r\n        uint256 lootRequested; // the amount of loot the applicant is requesting\r\n        uint256 tributeOffered; // amount of tokens offered as tribute\r\n        address tributeToken; // tribute token contract reference\r\n        uint256 paymentRequested; // amount of tokens requested as payment\r\n        address paymentToken; // payment token contract reference\r\n        uint256 startingPeriod; // the period in which voting can start for this proposal\r\n        uint256 yesVotes; // the total number of YES votes for this proposal\r\n        uint256 noVotes; // the total number of NO votes for this proposal\r\n        bool[6] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n        string details; // proposal details - could be IPFS hash, plaintext, or JSON\r\n        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\r\n        mapping(address => Vote) votesByMember; // the votes on this proposal by each member\r\n    }\r\n\r\n    mapping(address => bool) public tokenWhitelist;\r\n    address[] public approvedTokens;\r\n\r\n    mapping(address => bool) public proposedToWhitelist;\r\n    mapping(address => bool) public proposedToKick;\r\n\r\n    mapping(address => Member) public members;\r\n    mapping(address => address) public memberAddressByDelegateKey;\r\n\r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    uint256[] public proposalQueue;\r\n\r\n    modifier onlyMember {\r\n        require(members[msg.sender].shares > 0 || members[msg.sender].loot > 0, \"not a member\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyShareholder {\r\n        require(members[msg.sender].shares > 0, \"not a shareholder\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDelegate {\r\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"not a delegate\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _summoner,\r\n        address[] memory _approvedTokens,\r\n        address _sushiToken,\r\n        address _xSushiToken,\r\n        address _aave,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _proposalDeposit,\r\n        uint256 _dilutionBound,\r\n        uint256 _processingReward\r\n    ) public {\r\n        require(_summoner != address(0), \"summoner cannot be 0\");\r\n        require(_periodDuration > 0, \"_periodDuration cannot be 0\");\r\n        require(_votingPeriodLength > 0, \"_votingPeriodLength cannot be 0\");\r\n        require(_votingPeriodLength <= MAX_VOTING_PERIOD_LENGTH, \"_votingPeriodLength exceeds limit\");\r\n        require(_gracePeriodLength <= MAX_GRACE_PERIOD_LENGTH, \"_gracePeriodLength exceeds limit\");\r\n        require(_dilutionBound > 0, \"_dilutionBound cannot be 0\");\r\n        require(_dilutionBound <= MAX_DILUTION_BOUND, \"_dilutionBound exceeds limit\");\r\n        require(_approvedTokens.length > 0, \"need at least one approved token\");\r\n        require(_approvedTokens.length <= MAX_TOKEN_WHITELIST_COUNT, \"too many tokens\");\r\n        require(_proposalDeposit >= _processingReward, \"_proposalDeposit cannot be smaller than _processingReward\");\r\n        \r\n        tokenWhitelist[_sushiToken] = true;\r\n        approvedTokens.push(_sushiToken);\r\n        \r\n        tokenWhitelist[_xSushiToken] = true;\r\n        approvedTokens.push(_xSushiToken);\r\n        \r\n        // NOTE: move event up here, avoid stack too deep if too many approved tokens\r\n        emit SummonComplete(_summoner, _approvedTokens, now, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDeposit, _dilutionBound, _processingReward);\r\n\r\n        for (uint256 i = 0; i < _approvedTokens.length; i++) {\r\n            require(_approvedTokens[i] != address(0), \"_approvedToken cannot be 0\");\r\n            require(!tokenWhitelist[_approvedTokens[i]], \"duplicate approved token\");\r\n            tokenWhitelist[_approvedTokens[i]] = true;\r\n            approvedTokens.push(_approvedTokens[i]);\r\n        }\r\n        \r\n        IERC20(_sushiToken).approve(_xSushiToken, uint256(-1)); // max approve sushi bar for sushi token staking into xSushi\r\n        \r\n        SushiMinion minion = new SushiMinion(address(this), _sushiToken, _xSushiToken, _aave); // summon sushi minion contract \r\n        sushiMinion = address(minion); // record minion reference\r\n        \r\n        depositToken = _sushiToken;\r\n        sushiToken = _sushiToken;\r\n        xSushiToken = _xSushiToken;\r\n        \r\n        periodDuration = _periodDuration;\r\n        votingPeriodLength = _votingPeriodLength;\r\n        gracePeriodLength = _gracePeriodLength;\r\n        proposalDeposit = _proposalDeposit;\r\n        dilutionBound = _dilutionBound;\r\n        processingReward = _processingReward;\r\n\r\n        summoningTime = now;\r\n\r\n        members[_summoner] = Member(_summoner, 0, 0, true, 0, 0);\r\n        memberAddressByDelegateKey[_summoner] = _summoner;\r\n    }\r\n    \r\n    /********************\r\n    SUSHI 飲み会 DEPOSITS\r\n    ********************/\r\n    function makeSushiDeposit(uint256 tributeOffered) external nonReentrant {\r\n        require(IERC20(sushiToken).transferFrom(msg.sender, address(this), tributeOffered), \"sushi tribute failed\");\r\n        \r\n        uint256 startBalance = IERC20(xSushiToken).balanceOf(address(this));\r\n        ISushiBar(xSushiToken).enter(tributeOffered);\r\n        uint256 shares = IERC20(xSushiToken).balanceOf(address(this)) - startBalance;\r\n        \r\n        if (!members[msg.sender].exists) {\r\n            members[msg.sender] = Member(msg.sender, shares, 0, true, 0, 0);\r\n            memberAddressByDelegateKey[msg.sender] = msg.sender;\r\n        } else {\r\n            members[msg.sender].shares += shares;\r\n        }\r\n        \r\n        require(totalShares + shares <= MAX_NUMBER_OF_SHARES_AND_LOOT, \"too many shares requested\");\r\n        totalShares += shares;\r\n        \r\n        unsafeAddToBalance(GUILD, xSushiToken, shares);\r\n        \r\n        emit MakeDeposit(msg.sender, tributeOffered, shares);\r\n    }\r\n    \r\n    function makeXSushiDeposit(uint256 tributeOffered) external nonReentrant {\r\n        require(IERC20(xSushiToken).transferFrom(msg.sender, address(this), tributeOffered), \"xSushi tribute failed\");\r\n        \r\n        if (!members[msg.sender].exists) {\r\n            members[msg.sender] = Member(msg.sender, tributeOffered, 0, true, 0, 0);\r\n            memberAddressByDelegateKey[msg.sender] = msg.sender;\r\n        } else {\r\n            members[msg.sender].shares += tributeOffered;\r\n        }\r\n        \r\n        require(totalShares + tributeOffered <= MAX_NUMBER_OF_SHARES_AND_LOOT, \"too many shares requested\");\r\n        totalShares += tributeOffered;\r\n        \r\n        unsafeAddToBalance(GUILD, xSushiToken, tributeOffered);\r\n        \r\n        emit MakeDeposit(msg.sender, tributeOffered, tributeOffered);\r\n    }\r\n\r\n    /*****************\r\n    PROPOSAL FUNCTIONS\r\n    *****************/\r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        string memory details\r\n    ) external nonReentrant returns (uint256 proposalId) {\r\n        require(sharesRequested.add(lootRequested) <= MAX_NUMBER_OF_SHARES_AND_LOOT, \"too many shares requested\");\r\n        require(tokenWhitelist[tributeToken], \"tributeToken is not whitelisted\");\r\n        require(tokenWhitelist[paymentToken], \"payment is not whitelisted\");\r\n        require(applicant != address(0), \"applicant cannot be 0\");\r\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant address cannot be reserved\");\r\n        require(members[applicant].jailed == 0, \"proposal applicant must not be jailed\");\r\n\r\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, 'cannot submit more tribute proposals for new tokens - guildbank is full');\r\n        }\r\n\r\n        // collect tribute from proposer and store it in the Moloch until the proposal is processed\r\n        IERC20(tributeToken).safeTransferFrom(msg.sender, address(this), tributeOffered);\r\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\r\n\r\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n\r\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\r\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\r\n    }\r\n\r\n    function submitWhitelistProposal(address tokenToWhitelist, string memory details) external nonReentrant returns (uint256 proposalId) {\r\n        require(tokenToWhitelist != address(0), \"must provide token address\");\r\n        require(!tokenWhitelist[tokenToWhitelist], \"cannot already have whitelisted the token\");\r\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"cannot submit more whitelist proposals\");\r\n\r\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n        flags[4] = true; // whitelist\r\n\r\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags);\r\n        return proposalCount - 1;\r\n    }\r\n\r\n    function submitGuildKickProposal(address memberToKick, string memory details) external nonReentrant returns (uint256 proposalId) {\r\n        Member memory member = members[memberToKick];\r\n\r\n        require(member.shares > 0 || member.loot > 0, \"member must have at least one share or one loot\");\r\n        require(members[memberToKick].jailed == 0, \"member must not already be jailed\");\r\n\r\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\r\n        flags[5] = true; // guild kick\r\n\r\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags);\r\n        return proposalCount - 1;\r\n    }\r\n\r\n    function _submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        string memory details,\r\n        bool[6] memory flags\r\n    ) private {\r\n        Proposal memory proposal = Proposal({\r\n            applicant : applicant,\r\n            proposer : msg.sender,\r\n            sponsor : address(0),\r\n            sharesRequested : sharesRequested,\r\n            lootRequested : lootRequested,\r\n            tributeOffered : tributeOffered,\r\n            tributeToken : tributeToken,\r\n            paymentRequested : paymentRequested,\r\n            paymentToken : paymentToken,\r\n            startingPeriod : 0,\r\n            yesVotes : 0,\r\n            noVotes : 0,\r\n            flags : flags,\r\n            details : details,\r\n            maxTotalSharesAndLootAtYesVote : 0\r\n        });\r\n\r\n        proposals[proposalCount] = proposal;\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        // NOTE: argument order matters, avoid stack too deep\r\n        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, proposalCount, msg.sender, memberAddress);\r\n        proposalCount += 1;\r\n    }\r\n\r\n    function sponsorProposal(uint256 proposalId) external nonReentrant onlyDelegate {\r\n        // collect proposal deposit from sponsor and store it in the Moloch until the proposal is processed\r\n        require(IERC20(depositToken).transferFrom(msg.sender, address(this), proposalDeposit), \"proposal deposit token transfer failed\");\r\n        unsafeAddToBalance(ESCROW, depositToken, proposalDeposit);\r\n\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.proposer != address(0), 'proposal must have been proposed');\r\n        require(!proposal.flags[0], \"proposal has already been sponsored\");\r\n        require(!proposal.flags[3], \"proposal has been cancelled\");\r\n        require(members[proposal.applicant].jailed == 0, \"proposal applicant must not be jailed\");\r\n\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {\r\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, 'cannot sponsor more tribute proposals for new tokens - guildbank is full');\r\n        }\r\n\r\n        // whitelist proposal\r\n        if (proposal.flags[4]) {\r\n            require(!tokenWhitelist[address(proposal.tributeToken)], \"cannot already have whitelisted the token\");\r\n            require(!proposedToWhitelist[address(proposal.tributeToken)], 'already proposed to whitelist');\r\n            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"cannot sponsor more whitelist proposals\");\r\n            proposedToWhitelist[address(proposal.tributeToken)] = true;\r\n\r\n        // guild kick proposal\r\n        } else if (proposal.flags[5]) {\r\n            require(!proposedToKick[proposal.applicant], 'already proposed to kick');\r\n            proposedToKick[proposal.applicant] = true;\r\n        }\r\n\r\n        // compute startingPeriod for proposal\r\n        uint256 startingPeriod = max(\r\n            getCurrentPeriod(),\r\n            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length.sub(1)]].startingPeriod\r\n        ).add(1);\r\n\r\n        proposal.startingPeriod = startingPeriod;\r\n\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        proposal.sponsor = memberAddress;\r\n\r\n        proposal.flags[0] = true; // sponsored\r\n\r\n        // append proposal to the queue\r\n        proposalQueue.push(proposalId);\r\n        \r\n        emit SponsorProposal(msg.sender, memberAddress, proposalId, proposalQueue.length.sub(1), startingPeriod);\r\n    }\r\n\r\n    // NOTE: In MolochV2 proposalIndex != proposalId\r\n    function submitVote(uint256 proposalIndex, uint8 uintVote) external nonReentrant onlyDelegate {\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\r\n        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(uintVote < 3, \"must be less than 3\");\r\n        Vote vote = Vote(uintVote);\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"voting period has not started\");\r\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"proposal voting period has expired\");\r\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"member has already voted\");\r\n        require(vote == Vote.Yes || vote == Vote.No, \"vote must be either Yes or No\");\r\n\r\n        proposal.votesByMember[memberAddress] = vote;\r\n\r\n        if (vote == Vote.Yes) {\r\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\r\n\r\n            // set highest index (latest) yes vote - must be processed for member to ragequit\r\n            if (proposalIndex > member.highestIndexYesVote) {\r\n                member.highestIndexYesVote = proposalIndex;\r\n            }\r\n\r\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\r\n            if (totalShares.add(totalLoot) > proposal.maxTotalSharesAndLootAtYesVote) {\r\n                proposal.maxTotalSharesAndLootAtYesVote = totalShares.add(totalLoot);\r\n            }\r\n\r\n        } else if (vote == Vote.No) {\r\n            proposal.noVotes = proposal.noVotes.add(member.shares);\r\n        }\r\n     \r\n        // NOTE: subgraph indexes by proposalId not proposalIndex since proposalIndex isn't set untill it's been sponsored but proposal is created on submission\r\n        emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, memberAddress, uintVote);\r\n    }\r\n\r\n    function processProposal(uint256 proposalIndex) external nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(!proposal.flags[4] && !proposal.flags[5], \"must be a standard proposal\");\r\n\r\n        proposal.flags[1] = true; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        // Make the proposal fail if the new total number of shares and loot exceeds the limit\r\n        if (totalShares.add(totalLoot).add(proposal.sharesRequested).add(proposal.lootRequested) > MAX_NUMBER_OF_SHARES_AND_LOOT) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance\r\n        if (proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it would result in too many tokens with non-zero balance in guild bank\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0 && totalGuildBankTokens >= MAX_TOKEN_GUILDBANK_COUNT) {\r\n           didPass = false;\r\n        }\r\n\r\n        // PROPOSAL PASSED\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n\r\n            // if the applicant is already a member, add to their existing shares & loot\r\n            if (members[proposal.applicant].exists) {\r\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\r\n                members[proposal.applicant].loot = members[proposal.applicant].loot.add(proposal.lootRequested);\r\n\r\n            // the applicant is a new member, create a new record for them\r\n            } else {\r\n                // if the applicant address is already taken by a member's delegateKey, reset it to their member address\r\n                if (members[memberAddressByDelegateKey[proposal.applicant]].exists) {\r\n                    address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\r\n                    memberAddressByDelegateKey[memberToOverride] = memberToOverride;\r\n                    members[memberToOverride].delegateKey = memberToOverride;\r\n                }\r\n\r\n                // use applicant address as delegateKey by default\r\n                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, proposal.lootRequested, true, 0, 0);\r\n                memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\r\n            }\r\n\r\n            // mint new shares & loot\r\n            totalShares = totalShares.add(proposal.sharesRequested);\r\n            totalLoot = totalLoot.add(proposal.lootRequested);\r\n\r\n            // if the proposal tribute is the first tokens of its kind to make it into the guild bank, increment total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.tributeToken] == 0 && proposal.tributeOffered > 0) {\r\n                totalGuildBankTokens += 1;\r\n            }\r\n\r\n            unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);\r\n            unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposal.paymentRequested);\r\n\r\n            // if the proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\r\n            if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {\r\n                totalGuildBankTokens -= 1;\r\n            }\r\n\r\n        // PROPOSAL FAILED\r\n        } else {\r\n            // return all tokens to the proposer (not the applicant, because funds come from proposer)\r\n            unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        }\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n\r\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processWhitelistProposal(uint256 proposalIndex) external nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[4], \"must be a whitelist proposal\");\r\n\r\n        proposal.flags[1] = true; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (approvedTokens.length >= MAX_TOKEN_WHITELIST_COUNT) {\r\n            didPass = false;\r\n        }\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n\r\n            tokenWhitelist[address(proposal.tributeToken)] = true;\r\n            approvedTokens.push(proposal.tributeToken);\r\n        }\r\n\r\n        proposedToWhitelist[address(proposal.tributeToken)] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n\r\n        emit ProcessWhitelistProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function processGuildKickProposal(uint256 proposalIndex) external nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[5], \"must be a guild kick proposal\");\r\n\r\n        proposal.flags[1] = true; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n            Member storage member = members[proposal.applicant];\r\n            member.jailed = proposalIndex;\r\n\r\n            // transfer shares to loot\r\n            member.loot = member.loot.add(member.shares);\r\n            totalShares = totalShares.sub(member.shares);\r\n            totalLoot = totalLoot.add(member.shares);\r\n            member.shares = 0; // revoke all shares\r\n        }\r\n\r\n        proposedToKick[proposal.applicant] = false;\r\n\r\n        _returnDeposit(proposal.sponsor);\r\n\r\n        emit ProcessGuildKickProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n    function _didPass(uint256 proposalIndex) private view returns (bool didPass) {\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        didPass = proposal.yesVotes > proposal.noVotes;\r\n\r\n        // Make the proposal fail if the dilutionBound is exceeded\r\n        if ((totalShares.add(totalLoot)).mul(dilutionBound) < proposal.maxTotalSharesAndLootAtYesVote) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if the applicant is jailed\r\n        // - for standard proposals, we don't want the applicant to get any shares/loot/payment\r\n        // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter\r\n        if (members[proposal.applicant].jailed != 0) {\r\n            didPass = false;\r\n        }\r\n\r\n        return didPass;\r\n    }\r\n\r\n    function _validateProposalForProcessing(uint256 proposalIndex) private view {\r\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"proposal is not ready to be processed\");\r\n        require(proposal.flags[1] == false, \"proposal has already been processed\");\r\n        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex.sub(1)]].flags[1], \"previous proposal must be processed\");\r\n    }\r\n\r\n    function _returnDeposit(address sponsor) private {\r\n        unsafeInternalTransfer(ESCROW, msg.sender, depositToken, processingReward);\r\n        unsafeInternalTransfer(ESCROW, sponsor, depositToken, proposalDeposit.sub(processingReward));\r\n    }\r\n\r\n    function ragequit(uint256 sharesToBurn, uint256 lootToBurn) external nonReentrant onlyMember {\r\n        _ragequit(msg.sender, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function _ragequit(address memberAddress, uint256 sharesToBurn, uint256 lootToBurn) private {\r\n        uint256 initialTotalSharesAndLoot = totalShares.add(totalLoot);\r\n\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(member.shares >= sharesToBurn, \"insufficient shares\");\r\n        require(member.loot >= lootToBurn, \"insufficient loot\");\r\n\r\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\r\n\r\n        uint256 sharesAndLootToBurn = sharesToBurn.add(lootToBurn);\r\n\r\n        // burn shares and loot\r\n        member.shares = member.shares.sub(sharesToBurn);\r\n        member.loot = member.loot.sub(lootToBurn);\r\n        totalShares = totalShares.sub(sharesToBurn);\r\n        totalLoot = totalLoot.sub(lootToBurn);\r\n\r\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\r\n            uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][approvedTokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\r\n            if (amountToRagequit > 0) { // gas optimization to allow a higher maximum token limit\r\n                // deliberately not using safemath here to keep overflows from preventing the function execution (which would break ragekicks)\r\n                // if a token overflows, it is because the supply was artificially inflated to oblivion, so we probably don't care about it anyways\r\n                userTokenBalances[GUILD][approvedTokens[i]] -= amountToRagequit;\r\n                userTokenBalances[memberAddress][approvedTokens[i]] += amountToRagequit;\r\n            }\r\n        }\r\n\r\n        emit Ragequit(msg.sender, sharesToBurn, lootToBurn);\r\n    }\r\n\r\n    function ragekick(address memberToKick) external nonReentrant {\r\n        Member storage member = members[memberToKick];\r\n\r\n        require(member.jailed != 0, \"member must be in jail\");\r\n        require(member.loot > 0, \"member must have some loot\"); // note - should be impossible for jailed member to have shares\r\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\r\n\r\n        _ragequit(memberToKick, 0, member.loot);\r\n    }\r\n\r\n    function withdrawBalance(address token, uint256 amount) external nonReentrant {\r\n        _withdrawBalance(token, amount);\r\n    }\r\n\r\n    function withdrawBalances(address[] memory tokens, uint256[] memory amounts, bool max) external nonReentrant {\r\n        require(tokens.length == amounts.length, \"tokens and amounts arrays must be matching lengths\");\r\n\r\n        for (uint256 i=0; i < tokens.length; i++) {\r\n            uint256 withdrawAmount = amounts[i];\r\n            if (max) { // withdraw the maximum balance\r\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\r\n            }\r\n\r\n            _withdrawBalance(tokens[i], withdrawAmount);\r\n        }\r\n    }\r\n    \r\n    function _withdrawBalance(address token, uint256 amount) private {\r\n        require(userTokenBalances[msg.sender][token] >= amount, \"insufficient balance\");\r\n        unsafeSubtractFromBalance(msg.sender, token, amount);\r\n        IERC20(token).safeTransfer(msg.sender, amount);\r\n        emit Withdraw(msg.sender, token, amount);\r\n    }\r\n    \r\n    // allows guild bank users to make internal token transfers among accounts\r\n    function internalTransfer(address to, address token, uint256 amount) external {\r\n        require(userTokenBalances[msg.sender][token] >= amount, \"insufficient amount\");\r\n        unsafeInternalTransfer(msg.sender, to, token, amount);\r\n        emit InternalTransfer(msg.sender, to, token, amount);\r\n    }\r\n\r\n    function collectTokens(address token) external onlyDelegate nonReentrant {\r\n        uint256 amountToCollect = IERC20(token).balanceOf(address(this)).sub(userTokenBalances[TOTAL][token]);\r\n        // only collect if 1) there are tokens to collect 2) token is whitelisted 3) token has non-zero balance\r\n        require(amountToCollect > 0, 'no tokens to collect');\r\n        require(tokenWhitelist[token], 'token to collect must be whitelisted');\r\n        require(userTokenBalances[GUILD][token] > 0, 'token to collect must have non-zero guild bank balance');\r\n        \r\n        unsafeAddToBalance(GUILD, token, amountToCollect);\r\n        emit TokensCollected(token, amountToCollect);\r\n    }\r\n\r\n    // NOTE: requires that delegate key which sent the original proposal cancels, msg.sender == proposal.proposer\r\n    function cancelProposal(uint256 proposalId) external nonReentrant {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(!proposal.flags[0], \"proposal has already been sponsored\");\r\n        require(!proposal.flags[3], \"proposal has already been cancelled\");\r\n        require(msg.sender == proposal.proposer, \"solely the proposer can cancel\");\r\n\r\n        proposal.flags[3] = true; // cancelled\r\n        \r\n        unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        emit CancelProposal(proposalId, msg.sender);\r\n    }\r\n\r\n    function updateDelegateKey(address newDelegateKey) external nonReentrant onlyShareholder {\r\n        require(newDelegateKey != address(0), \"newDelegateKey cannot be 0\");\r\n\r\n        // skip checks if member is setting the delegate key to their member address\r\n        if (newDelegateKey != msg.sender) {\r\n            require(!members[newDelegateKey].exists, \"cannot overwrite existing members\");\r\n            require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"cannot overwrite existing delegate keys\");\r\n        }\r\n\r\n        Member storage member = members[msg.sender];\r\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\r\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\r\n        member.delegateKey = newDelegateKey;\r\n\r\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\r\n    }\r\n\r\n    // can only ragequit if the latest proposal you voted YES on has been processed\r\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\r\n        require(highestIndexYesVote < proposalQueue.length, \"proposal does not exist\");\r\n        return proposals[proposalQueue[highestIndexYesVote]].flags[1];\r\n    }\r\n\r\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\r\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\r\n    }\r\n    \r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n    function max(uint256 x, uint256 y) private pure returns (uint256) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return now.sub(summoningTime).div(periodDuration);\r\n    }\r\n\r\n    function getProposalQueueLength() public view returns (uint256) {\r\n        return proposalQueue.length;\r\n    }\r\n\r\n    function getProposalFlags(uint256 proposalId) public view returns (bool[6] memory) {\r\n        return proposals[proposalId].flags;\r\n    }\r\n\r\n    function getUserTokenBalance(address user, address token) public view returns (uint256) {\r\n        return userTokenBalances[user][token];\r\n    }\r\n\r\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) {\r\n        require(members[memberAddress].exists, \"member does not exist\");\r\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\r\n        return proposals[proposalQueue[proposalIndex]].votesByMember[memberAddress];\r\n    }\r\n\r\n    function getTokenCount() public view returns (uint256) {\r\n        return approvedTokens.length;\r\n    }\r\n\r\n    /***************\r\n    HELPER FUNCTIONS\r\n    ***************/\r\n    function unsafeAddToBalance(address user, address token, uint256 amount) private {\r\n        userTokenBalances[user][token] += amount;\r\n        userTokenBalances[TOTAL][token] += amount;\r\n    }\r\n\r\n    function unsafeSubtractFromBalance(address user, address token, uint256 amount) private {\r\n        userTokenBalances[user][token] -= amount;\r\n        userTokenBalances[TOTAL][token] -= amount;\r\n    }\r\n\r\n    function unsafeInternalTransfer(address from, address to, address token, uint256 amount) private {\r\n        unsafeSubtractFromBalance(from, token, amount);\r\n        unsafeAddToBalance(to, token, amount);\r\n    }\r\n\r\n    function fairShare(uint256 balance, uint256 shares, uint256 totalSharesAndLoot) private pure returns (uint256) {\r\n        require(totalSharesAndLoot != 0);\r\n\r\n        if (balance == 0) { return 0; }\r\n\r\n        uint256 prod = balance * shares;\r\n\r\n        if (prod / balance == shares) { // no overflow in multiplication above?\r\n            return prod / totalSharesAndLoot;\r\n        }\r\n\r\n        return (balance / totalSharesAndLoot) * shares;\r\n    } \r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_summoner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_approvedTokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_sushiToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xSushiToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_aave\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_periodDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_votingPeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gracePeriodLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_proposalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dilutionBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_processingReward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"applicantAddress\",\"type\":\"address\"}],\"name\":\"CancelProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InternalTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"MakeDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessGuildKickProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didPass\",\"type\":\"bool\"}],\"name\":\"ProcessWhitelistProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootToBurn\",\"type\":\"uint256\"}],\"name\":\"Ragequit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"}],\"name\":\"SponsorProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool[6]\",\"name\":\"flags\",\"type\":\"bool[6]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"SubmitProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"uintVote\",\"type\":\"uint8\"}],\"name\":\"SubmitVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"summoner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"summoningTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votingPeriodLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gracePeriodLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dilutionBound\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"processingReward\",\"type\":\"uint256\"}],\"name\":\"SummonComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToCollect\",\"type\":\"uint256\"}],\"name\":\"TokensCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDelegateKey\",\"type\":\"address\"}],\"name\":\"UpdateDelegateKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ESCROW\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GUILD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"highestIndexYesVote\",\"type\":\"uint256\"}],\"name\":\"canRagequit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancelProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"collectTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dilutionBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"getMemberProposalVote\",\"outputs\":[{\"internalType\":\"enum SushiNomikai.Vote\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalFlags\",\"outputs\":[{\"internalType\":\"bool[6]\",\"name\":\"\",\"type\":\"bool[6]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposalQueueLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUserTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gracePeriodLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"}],\"name\":\"hasVotingPeriodExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"internalTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"}],\"name\":\"makeSushiDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"}],\"name\":\"makeXSushiDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberAddressByDelegateKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"members\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"delegateKey\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loot\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"highestIndexYesVote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jailed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processGuildKickProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"}],\"name\":\"processWhitelistProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yesVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noVotes\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalSharesAndLootAtYesVote\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposedToKick\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposedToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberToKick\",\"type\":\"address\"}],\"name\":\"ragekick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootToBurn\",\"type\":\"uint256\"}],\"name\":\"ragequit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"sponsorProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memberToKick\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"submitGuildKickProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"applicant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tributeOffered\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tributeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentRequested\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"submitProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"uintVote\",\"type\":\"uint8\"}],\"name\":\"submitVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenToWhitelist\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"submitWhitelistProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiMinion\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGuildBankTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDelegateKey\",\"type\":\"address\"}],\"name\":\"updateDelegateKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTokenBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingPeriodLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"max\",\"type\":\"bool\"}],\"name\":\"withdrawBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SushiNomikai","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001c0aa8ccd568d90d61659f060d1bfb1e6f855a2000000000000000000000000000000000000000000000000000000000000001600000000000000000000000006b3595068778dd592e39a122f4f5a5cf09c90fe20000000000000000000000008798249c2e607446efb7ad49ec89dd1865ff42720000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a90000000000000000000000000000000000000000000000000000000000004380000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000f4bb2e28688e89fcce3c0580d37d36a7672e8a9f0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca0000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e0000000000000000000000007fc66500c84a76ad7e9c93437bfc5ac33e2ddae9000000000000000000000000dbdb4d16eda451d0503b854cf79d55697f90c8df000000000000000000000000c011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f0000000000000000000000001f9840a85d5af5bf1d1762f925bdaddc4201f9840000000000000000000000003472a5a71965499acd81997a54bba8d852c6e53d","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://614a819aae6767a3efa655007b16fa30d3a7506c86aab3c218a7857840dfc3d1"}]}