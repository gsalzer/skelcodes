{"status":"1","message":"OK","result":[{"SourceCode":"{\"Declaration.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport \\\"./Global.sol\\\";\\r\\n\\r\\nabstract contract Declaration is Global {\\r\\n\\r\\n    uint256 constant _decimals = 18;\\r\\n    uint256 constant REI_PER_GRISE = 10 ** _decimals; // 1 GRISE = 1E18 REI\\r\\n    \\r\\n    uint64 constant PRECISION_RATE = 1E18;\\r\\n    uint32 constant REWARD_PRECISION_RATE = 1E4;\\r\\n\\r\\n    uint16 constant GRISE_WEEK = 7;\\r\\n    uint16 constant GRISE_MONTH = GRISE_WEEK * 4;\\r\\n    uint16 constant GRISE_YEAR = GRISE_MONTH * 12;\\r\\n\\r\\n    // Inflation Reward\\r\\n    uint32 constant INFLATION_RATE = 57658685; // per day Inflation Amount\\r\\n    uint16 constant MED_TERM_INFLATION_REWARD = 3000; // 30% of Inflation Amount with 1E4 Precision\\r\\n    uint16 constant LONG_TERM_INFLATION_REWARD = 7000; // 70% of Inflation Amount with 1E4 Precision\\r\\n\\r\\n    uint16 constant ST_STAKER_COMPENSATION = 200; // 2.00% multiple 1E4 Precision\\r\\n    uint16 constant MLT_STAKER_COMPENSATION = 347; // 3.47% multiple 1E4 Precision\\r\\n\\r\\n    // End-Stake Panalty Reward\\r\\n    uint16 constant PENALTY_RATE = 1700; // pre-mature end-stake penalty\\r\\n    uint16 constant RESERVOIR_PENALTY_REWARD = 3427;\\r\\n    uint16 constant SHORT_STAKER_PENALTY_REWARD = 1311;\\r\\n    uint16 constant MED_LONG_STAKER_PENALTY_REWARD = 2562;\\r\\n    uint16 constant TEAM_PENALTY_REWARD = 1350;\\r\\n    uint16 constant DEVELOPER_PENALTY_REWARD = 150;\\r\\n    uint16 constant BURN_PENALTY_REWARD = 1200;\\r\\n\\r\\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\\r\\n\\r\\n    address constant TEAM_ADDRESS = 0xa377433831E83C7a4Fa10fB75C33217cD7CABec2;\\r\\n    address constant DEVELOPER_ADDRESS = 0xcD8DcbA8e4791B19719934886A8bA77EA3fad447;\\r\\n\\r\\n    IUniswapRouterV2 public constant UNISWAP_ROUTER = IUniswapRouterV2(\\r\\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D // mainnet\\r\\n    );\\r\\n\\r\\n    IGriseToken public GRISE_CONTRACT;\\r\\n    address public contractDeployer;\\r\\n\\r\\n    constructor(address _immutableAddress) \\r\\n    {\\r\\n        contractDeployer = msg.sender;\\r\\n\\r\\n        GRISE_CONTRACT = IGriseToken(_immutableAddress);\\r\\n\\r\\n        // Min-Max Staking Day limit\\r\\n        stakeDayLimit[StakeType.SHORT_TERM].minStakeDay = 1 * GRISE_WEEK;   // Min 1 Week\\r\\n        stakeDayLimit[StakeType.SHORT_TERM].maxStakeDay = 12 * GRISE_WEEK;  // Max 12 Week\\r\\n        stakeDayLimit[StakeType.MEDIUM_TERM].minStakeDay = 3 * GRISE_MONTH; // Min 3 Month\\r\\n        stakeDayLimit[StakeType.MEDIUM_TERM].maxStakeDay = 9 * GRISE_MONTH; // Max 9 Month\\r\\n        stakeDayLimit[StakeType.LONG_TERM].minStakeDay =  1 * GRISE_YEAR;  // Min 1 Year\\r\\n        stakeDayLimit[StakeType.LONG_TERM].maxStakeDay = 10 * GRISE_YEAR;  // Max 10 Year\\r\\n\\r\\n        //Min Staking Amount limit\\r\\n        stakeCaps[StakeType.SHORT_TERM][0].minStakingAmount = 50 * REI_PER_GRISE;   // 50 GRISE TOKEN\\r\\n        stakeCaps[StakeType.MEDIUM_TERM][0].minStakingAmount = 225 * REI_PER_GRISE; // 225 GIRSE TOKEN\\r\\n        stakeCaps[StakeType.MEDIUM_TERM][1].minStakingAmount = 100 * REI_PER_GRISE; // 100 GIRSE TOKEN\\r\\n        stakeCaps[StakeType.MEDIUM_TERM][2].minStakingAmount = 150 * REI_PER_GRISE; // 150 GIRSE TOKEN\\r\\n        stakeCaps[StakeType.LONG_TERM][0].minStakingAmount = 100 * REI_PER_GRISE;  // 100 GIRSE TOKEN\\r\\n\\r\\n        //Max Staking Slot Limit\\r\\n        stakeCaps[StakeType.SHORT_TERM][0].maxStakingSlot = 1250;   // Max 1250 Slot Available\\r\\n        stakeCaps[StakeType.MEDIUM_TERM][0].maxStakingSlot = 250;   // Max 250 Slot Available\\r\\n        stakeCaps[StakeType.MEDIUM_TERM][1].maxStakingSlot = 500;   // Max 500 Slot Available\\r\\n        stakeCaps[StakeType.MEDIUM_TERM][2].maxStakingSlot = 300;   // Max 300 Slot Available\\r\\n        stakeCaps[StakeType.LONG_TERM][0].maxStakingSlot = 300;    // Max 300 Slot Available\\r\\n    }\\r\\n\\r\\n    struct Stake {\\r\\n        uint256 stakesShares;\\r\\n        uint256 stakedAmount;\\r\\n        uint256 rewardAmount;\\r\\n        StakeType stakeType;\\r\\n        uint256 totalOccupiedSlot;\\r\\n        uint256 startDay;\\r\\n        uint256 lockDays;\\r\\n        uint256 finalDay;\\r\\n        uint256 closeDay;\\r\\n        uint256 scrapeDay;\\r\\n        bool isActive;\\r\\n    }\\r\\n\\r\\n    enum StakeType {\\r\\n        SHORT_TERM,\\r\\n        MEDIUM_TERM,\\r\\n        LONG_TERM\\r\\n    }\\r\\n\\r\\n    struct StakeCapping {\\r\\n        uint256 minStakingAmount;\\r\\n        uint256 stakingSlotCount;\\r\\n        uint256 maxStakingSlot;\\r\\n        uint256 totalStakeCount;\\r\\n    }\\r\\n\\r\\n    struct StakeMinMaxDay{\\r\\n        uint256 minStakeDay;\\r\\n        uint256 maxStakeDay;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e uint256) public stakeCount;\\r\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e uint256)) public scrapes;\\r\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e Stake)) public stakes;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) public scheduledToEnd;\\r\\n    mapping(uint256 =\\u003e uint256) public totalPenalties;\\r\\n    mapping(uint256 =\\u003e uint256) public MLTPenaltiesRewardPerShares; // Medium/Long Term Penatly Reward\\r\\n    mapping(uint256 =\\u003e uint256) public STPenaltiesRewardPerShares;  // Short Term Penatly Reward\\r\\n    mapping(uint256 =\\u003e uint256) public ReservoirPenaltiesRewardPerShares;  // Short Term Penatly Reward\\r\\n\\r\\n    mapping(StakeType =\\u003e StakeMinMaxDay) public stakeDayLimit;\\r\\n    mapping(StakeType =\\u003e mapping(uint8 =\\u003e StakeCapping)) public stakeCaps;\\r\\n}\\r\\n\"},\"Events.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\ncontract Events {\\r\\n    \\r\\n    event StakeStart(\\r\\n        bytes16 indexed stakeID,\\r\\n        address indexed stakerAddress,\\r\\n        uint256 stakeType,\\r\\n        uint256 stakedAmount,\\r\\n        uint256 stakesShares,\\r\\n        uint256 startDay,\\r\\n        uint256 lockDays\\r\\n    );\\r\\n\\r\\n    event StakeEnd(\\r\\n        bytes16 indexed stakeID,\\r\\n        address indexed stakerAddress,\\r\\n        uint256 stakeType,\\r\\n        uint256 stakedAmount,\\r\\n        uint256 stakesShares,\\r\\n        uint256 rewardAmount,\\r\\n        uint256 closeDay,\\r\\n        uint256 penaltyAmount\\r\\n    );\\r\\n\\r\\n    event InterestScraped(\\r\\n        bytes16 indexed stakeID,\\r\\n        address indexed stakerAddress,\\r\\n        uint256 scrapeAmount,\\r\\n        uint256 scrapeDay,\\r\\n        uint256 currentGriseDay\\r\\n    );\\r\\n\\r\\n    event NewGlobals(\\r\\n        uint256 indexed currentGriseDay,\\r\\n        uint256 totalShares,\\r\\n        uint256 totalStaked,\\r\\n        uint256 shortTermshare,\\r\\n        uint256 MediumTermshare,\\r\\n        uint256 shareRate\\r\\n    );\\r\\n}\"},\"Global.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./Events.sol\\\";\\r\\n\\r\\nabstract contract Global is Events {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    struct Globals {\\r\\n        uint256 totalStaked;\\r\\n        uint256 totalShares;\\r\\n        uint256 STShares; // Short Term shares counter\\r\\n        uint256 MLTShares; // Medium Term and Large Term Shares counter\\r\\n        uint256 sharePrice;\\r\\n        uint256 currentGriseDay;\\r\\n    }\\r\\n\\r\\n    Globals public globals;\\r\\n\\r\\n    constructor() {\\r\\n        globals.sharePrice = 100E15;\\r\\n    }\\r\\n\\r\\n    function _increaseGlobals(\\r\\n        uint8 _stakeType, \\r\\n        uint256 _staked,\\r\\n        uint256 _shares\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        globals.totalStaked =\\r\\n        globals.totalStaked.add(_staked);\\r\\n\\r\\n        globals.totalShares =\\r\\n        globals.totalShares.add(_shares);\\r\\n\\r\\n        if (_stakeType \\u003e 0) {\\r\\n            globals.MLTShares = \\r\\n                globals.MLTShares.add(_shares);\\r\\n        }else {\\r\\n            globals.STShares = \\r\\n                globals.STShares.add(_shares);\\r\\n        }\\r\\n\\r\\n        _logGlobals();\\r\\n    }\\r\\n\\r\\n    function _decreaseGlobals(\\r\\n        uint8 _stakeType,\\r\\n        uint256 _staked,\\r\\n        uint256 _shares\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        globals.totalStaked =\\r\\n        globals.totalStaked \\u003e _staked ?\\r\\n        globals.totalStaked - _staked : 0;\\r\\n\\r\\n        globals.totalShares =\\r\\n        globals.totalShares \\u003e _shares ?\\r\\n        globals.totalShares - _shares : 0;\\r\\n\\r\\n        if (_stakeType \\u003e 0) {\\r\\n            globals.MLTShares = \\r\\n                globals.MLTShares \\u003e _shares ?\\r\\n                globals.MLTShares - _shares : 0;\\r\\n        }else {            \\r\\n            globals.STShares = \\r\\n                globals.STShares \\u003e _shares ?\\r\\n                globals.STShares - _shares : 0;\\r\\n\\r\\n        }\\r\\n        \\r\\n        _logGlobals();\\r\\n    }\\r\\n\\r\\n    function _logGlobals()\\r\\n        private\\r\\n    {\\r\\n        emit NewGlobals(\\r\\n            globals.currentGriseDay,\\r\\n            globals.totalShares,\\r\\n            globals.totalStaked,\\r\\n            globals.STShares,\\r\\n            globals.MLTShares,\\r\\n            globals.sharePrice\\r\\n        );\\r\\n    }\\r\\n}\"},\"Helper.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport \\\"./Declaration.sol\\\";\\r\\n\\r\\nabstract contract Helper is Declaration {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    function notContract(address _addr) internal view returns (bool) {\\r\\n        uint32 size;\\r\\n        assembly {\\r\\n            size := extcodesize(_addr)\\r\\n        }\\r\\n        return (size == 0);\\r\\n    }\\r\\n\\r\\n    function toBytes16(uint256 x) internal pure returns (bytes16 b) {\\r\\n       return bytes16(bytes32(x));\\r\\n    }\\r\\n\\r\\n    function generateID(address x, uint256 y, bytes1 z) public pure returns (bytes16 b) {\\r\\n        b = toBytes16(\\r\\n            uint256(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(x, y, z)\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function generateStakeID(address _staker) internal view returns (bytes16 stakeID) {\\r\\n        return generateID(_staker, stakeCount[_staker], 0x01);\\r\\n    }\\r\\n\\r\\n    function currentGriseDay() internal view returns (uint256) {\\r\\n        return GRISE_CONTRACT.currentGriseDay();\\r\\n    }\\r\\n\\r\\n    function latestStakeID(address _staker) external view returns (bytes16) {\\r\\n        return stakeCount[_staker] == 0 ? bytes16(0) : generateID(_staker, stakeCount[_staker].sub(1), 0x01);\\r\\n    }\\r\\n\\r\\n    function _increaseStakeCount(address _staker) internal {\\r\\n        stakeCount[_staker] = stakeCount[_staker] + 1;\\r\\n    }\\r\\n\\r\\n    function _isMatureStake(Stake memory _stake) internal view returns (bool) {\\r\\n        return _stake.closeDay \\u003e 0\\r\\n            ? _stake.finalDay \\u003c= _stake.closeDay\\r\\n            : _stake.finalDay \\u003c= currentGriseDay();\\r\\n    }\\r\\n\\r\\n    function _stakeNotStarted(Stake memory _stake) internal view returns (bool) {\\r\\n        return _stake.closeDay \\u003e 0\\r\\n            ? _stake.startDay \\u003e _stake.closeDay\\r\\n            : _stake.startDay \\u003e currentGriseDay();\\r\\n    }\\r\\n\\r\\n    function _stakeEligibleForWeeklyReward(Stake memory _stake) internal view returns (bool) {\\r\\n        uint256 curGriseDay = currentGriseDay();\\r\\n        \\r\\n        return ( _stake.isActive \\u0026\\u0026 \\r\\n                !_stakeNotStarted(_stake) \\u0026\\u0026\\r\\n                (_startingDay(_stake) \\u003c curGriseDay.sub(curGriseDay.mod(GRISE_WEEK)) ||\\r\\n                   curGriseDay \\u003e= _stake.finalDay));\\r\\n    }\\r\\n\\r\\n    function _stakeEligibleForMonthlyReward(Stake memory _stake) internal view returns (bool) {\\r\\n        uint256 curGriseDay = currentGriseDay();\\r\\n\\r\\n        return ( _stake.isActive \\u0026\\u0026 \\r\\n                !_stakeNotStarted(_stake) \\u0026\\u0026\\r\\n                (_startingDay(_stake) \\u003c curGriseDay.sub(curGriseDay.mod(GRISE_MONTH)) ||\\r\\n                   curGriseDay \\u003e= _stake.finalDay));\\r\\n    }\\r\\n\\r\\n    function _stakeEnded(Stake memory _stake) internal view returns (bool) {\\r\\n        return _stake.isActive == false || _isMatureStake(_stake);\\r\\n    }\\r\\n\\r\\n    function _daysLeft(Stake memory _stake) internal view returns (uint256) {\\r\\n        return _stake.isActive == false\\r\\n            ? _daysDiff(_stake.closeDay, _stake.finalDay)\\r\\n            : _daysDiff(currentGriseDay(), _stake.finalDay);\\r\\n    }\\r\\n\\r\\n    function _daysDiff(uint256 _startDate, uint256 _endDate) internal pure returns (uint256) {\\r\\n        return _startDate \\u003e _endDate ? 0 : _endDate.sub(_startDate);\\r\\n    }\\r\\n\\r\\n    function _calculationDay(Stake memory _stake) internal view returns (uint256) {\\r\\n        return _stake.finalDay \\u003e globals.currentGriseDay ? globals.currentGriseDay : _stake.finalDay;\\r\\n    }\\r\\n\\r\\n    function _startingDay(Stake memory _stake) internal pure returns (uint256) {\\r\\n        return _stake.scrapeDay == 0 ? _stake.startDay : _stake.scrapeDay;\\r\\n    }\\r\\n\\r\\n    function _notFuture(uint256 _day) internal view returns (bool) {\\r\\n        return _day \\u003c= currentGriseDay();\\r\\n    }\\r\\n\\r\\n    function _notPast(uint256 _day) internal view returns (bool) {\\r\\n        return _day \\u003e= currentGriseDay();\\r\\n    }\\r\\n\\r\\n    function _nonZeroAddress(address _address) internal pure returns (bool) {\\r\\n        return _address != address(0x0);\\r\\n    }\\r\\n\\r\\n    function _getLockDays(Stake memory _stake) internal pure returns (uint256) {\\r\\n        return\\r\\n            _stake.lockDays \\u003e 1 ?\\r\\n            _stake.lockDays - 1 : 1;\\r\\n    }\\r\\n\\r\\n    function stakesPagination(\\r\\n        address _staker,\\r\\n        uint256 _offset,\\r\\n        uint256 _length\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (bytes16[] memory _stakes)\\r\\n    {\\r\\n        uint256 start = _offset \\u003e 0 \\u0026\\u0026\\r\\n            stakeCount[_staker] \\u003e _offset ?\\r\\n            stakeCount[_staker] - _offset : stakeCount[_staker];\\r\\n\\r\\n        uint256 finish = _length \\u003e 0 \\u0026\\u0026\\r\\n            start \\u003e _length ?\\r\\n            start - _length : 0;\\r\\n\\r\\n        uint256 i;\\r\\n\\r\\n        _stakes = new bytes16[](start - finish);\\r\\n\\r\\n        for (uint256 _stakeIndex = start; _stakeIndex \\u003e finish; _stakeIndex--) {\\r\\n            bytes16 _stakeID = generateID(_staker, _stakeIndex - 1, 0x01);\\r\\n            if (stakes[_staker][_stakeID].stakedAmount \\u003e 0) {\\r\\n                _stakes[i] = _stakeID; i++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n}\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\ninterface IUniswapRouterV2 {\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (\\r\\n        uint[] memory amounts\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IGriseToken {\\r\\n\\r\\n    function currentGriseDay()\\r\\n        external view\\r\\n        returns (uint64);\\r\\n\\r\\n    function balanceOfStaker(\\r\\n        address account\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function approve(\\r\\n        address _spender,\\r\\n        uint256 _value\\r\\n    ) external returns (bool success);\\r\\n\\r\\n    function totalSupply() \\r\\n        external view \\r\\n        returns (uint256);\\r\\n\\r\\n    function mintSupply(\\r\\n        address _investorAddress,\\r\\n        uint256 _amount\\r\\n    ) external;\\r\\n\\r\\n    function burnSupply(\\r\\n        address _investorAddress,\\r\\n        uint256 _amount\\r\\n    ) external;\\r\\n\\r\\n    function setStaker(\\r\\n        address _staker\\r\\n    ) external;\\r\\n\\r\\n    function resetStaker(\\r\\n        address _staker\\r\\n    ) external;\\r\\n\\r\\n    function updateStakedToken(\\r\\n        uint256 _stakedToken\\r\\n    ) external;\\r\\n\\r\\n    function updateMedTermShares(\\r\\n        uint256 _shares\\r\\n    ) external;\\r\\n\\r\\n    function getTransFeeReward(\\r\\n        uint256 _fromDay,\\r\\n        uint256 _toDay\\r\\n    )external view returns (uint256 rewardAmount);\\r\\n    \\r\\n    function getReservoirReward(\\r\\n        uint256 _fromDay,\\r\\n        uint256 _toDay\\r\\n    )external view returns (uint256 rewardAmount);\\r\\n\\r\\n    function getTokenHolderReward(\\r\\n        uint256 _fromDay,\\r\\n        uint256 _toDay\\r\\n    )external view returns (uint256 rewardAmount);\\r\\n}\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity ^0.7.6;\\r\\n\\r\\ncontract Migrations {\\r\\n    address public owner;\\r\\n    uint public last_completed_migration;\\r\\n\\r\\n    constructor() {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier restricted() {\\r\\n        if (msg.sender == owner)\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setCompleted(uint completed) public restricted {\\r\\n        last_completed_migration = completed;\\r\\n    }\\r\\n\\r\\n    function upgrade(address new_address) public restricted {\\r\\n        Migrations upgraded = Migrations(new_address);\\r\\n        upgraded.setCompleted(last_completed_migration);\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\r\\n        if (a == 0 || b == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        \\r\\n        if(b == 0){\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"Snapshot.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport \\\"./Helper.sol\\\";\\r\\n\\r\\nabstract contract Snapshot is Helper {\\r\\n\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    // regular shares\\r\\n    struct SnapShot {\\r\\n        uint256 totalShares;\\r\\n        uint256 inflationAmount;\\r\\n        uint256 scheduledToEnd;\\r\\n    }\\r\\n\\r\\n    mapping(uint256 =\\u003e SnapShot) public snapshots;\\r\\n    \\r\\n    modifier snapshotTrigger() {\\r\\n        _dailySnapshotPoint(currentGriseDay());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    \\r\\n    /**\\r\\n     * @notice allows volunteer to offload snapshots\\r\\n     * to save on gas during next start/end stake\\r\\n     */\\r\\n    function manualDailySnapshot()\\r\\n        external\\r\\n    {\\r\\n        _dailySnapshotPoint(currentGriseDay());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice allows volunteer to offload snapshots\\r\\n     * to save on gas during next start/end stake\\r\\n     * in case manualDailySnapshot reach block limit\\r\\n     */\\r\\n    function manualDailySnapshotPoint(\\r\\n        uint256 _updateDay\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        require(\\r\\n            _updateDay \\u003e 0 \\u0026\\u0026\\r\\n            _updateDay \\u003c currentGriseDay(),\\r\\n            \\u0027GRISE: snapshot day does not exist yet\\u0027\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            _updateDay \\u003e globals.currentGriseDay,\\r\\n            \\u0027GRISE: snapshot already taken for that day\\u0027\\r\\n        );\\r\\n\\r\\n        _dailySnapshotPoint(_updateDay);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice internal function that offloads\\r\\n     * global values to daily snapshots\\r\\n     * updates globals.currentGriseDay\\r\\n     */\\r\\n    function _dailySnapshotPoint(\\r\\n        uint256 _updateDay\\r\\n    )\\r\\n        private\\r\\n    {\\r\\n    \\r\\n        uint256 scheduledToEndToday;\\r\\n        uint256 totalStakedToday = globals.totalStaked;\\r\\n\\r\\n        for (uint256 _day = globals.currentGriseDay; _day \\u003c _updateDay; _day++) {\\r\\n\\r\\n            // ------------------------------------\\r\\n            // prepare snapshot for regular shares\\r\\n            // reusing scheduledToEndToday variable\\r\\n\\r\\n            scheduledToEndToday = scheduledToEnd[_day] + snapshots[_day - 1].scheduledToEnd;\\r\\n\\r\\n            SnapShot memory snapshot = snapshots[_day];\\r\\n            snapshot.scheduledToEnd = scheduledToEndToday;\\r\\n\\r\\n            snapshot.totalShares =\\r\\n                globals.totalShares \\u003e scheduledToEndToday ?\\r\\n                globals.totalShares - scheduledToEndToday : 0;\\r\\n\\r\\n            snapshot.inflationAmount =  snapshot.totalShares\\r\\n                .mul(PRECISION_RATE)\\r\\n                .div(\\r\\n                    _inflationAmount(\\r\\n                        totalStakedToday,\\r\\n                        GRISE_CONTRACT.totalSupply(),\\r\\n                        INFLATION_RATE\\r\\n                    )\\r\\n                );\\r\\n\\r\\n            // store regular snapshot\\r\\n            snapshots[_day] = snapshot;\\r\\n            globals.currentGriseDay++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _inflationAmount(uint256 _totalStaked, uint256 _totalSupply, uint256 _INFLATION_RATE) private pure returns (uint256) {\\r\\n        return (_totalStaked + _totalSupply) * 10000 / _INFLATION_RATE;\\r\\n    }\\r\\n}\"},\"StakingToken.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport \\\"./Snapshot.sol\\\";\\r\\n\\r\\ncontract StakingToken is Snapshot {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    receive() payable external {}\\r\\n\\r\\n    constructor(address _immutableAddress) Declaration(_immutableAddress) {}\\r\\n\\r\\n   /**\\r\\n     * @notice allows to create stake directly with ETH\\r\\n     * if you don\\u0027t have GRISE tokens method will convert\\r\\n     * and use amount returned from UNISWAP to open a stake\\r\\n     * @param _lockDays amount of days it is locked for.\\r\\n     */\\r\\n    function createStakeWithETH(\\r\\n        uint256 _stakedAmount,\\r\\n        StakeType _stakeType,\\r\\n        uint64 _lockDays\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (bytes16, uint256)\\r\\n    {\\r\\n        address[] memory path = new address[](2);\\r\\n            path[0] = WETH;\\r\\n            path[1] = address(GRISE_CONTRACT);\\r\\n\\r\\n        uint256[] memory amounts =\\r\\n        UNISWAP_ROUTER.swapETHForExactTokens{value: msg.value}(\\r\\n            _stakedAmount.add(_stakedAmount.mul(400).div(10000)),\\r\\n            path,\\r\\n            msg.sender,\\r\\n            block.timestamp + 2 hours\\r\\n        );\\r\\n\\r\\n        if (msg.value \\u003e amounts[0])\\r\\n        {\\r\\n            (bool success, ) = msg.sender.call{value: msg.value.sub(amounts[0])}(\\\"Pending Ether\\\");\\r\\n            require(success, \\u0027Grise: Pending ETH transfer failed\\u0027);\\r\\n        }\\r\\n\\r\\n        return createStake(\\r\\n            _stakedAmount,\\r\\n            _stakeType,\\r\\n            _lockDays\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice A method for a staker to create a stake\\r\\n     * @param _stakedAmount amount of GRISE staked.\\r\\n     * @param _stakeType Small/Medium/Large.\\r\\n     * @param _lockDays amount of days it is locked for.\\r\\n     */\\r\\n    function createStake(\\r\\n        uint256 _stakedAmount,\\r\\n        StakeType _stakeType,\\r\\n        uint64 _lockDays\\r\\n    )\\r\\n        snapshotTrigger\\r\\n        public\\r\\n        returns (bytes16, uint256)\\r\\n    {\\r\\n        // stakingSlot will be 0 for short/long term staking and\\r\\n        // stakingSlot will be 0,1,2 for 3,6,9 month medium term staking respectively.\\r\\n        uint8 stakingSlot; \\r\\n\\r\\n        if (_stakeType == StakeType.MEDIUM_TERM){\\r\\n            if (_lockDays == 168){ // 6 Month\\r\\n                stakingSlot = 1;\\r\\n            } else if (_lockDays == 252){ // 9 Month\\r\\n                stakingSlot = 2;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            _lockDays % GRISE_WEEK == 0 \\u0026\\u0026\\r\\n            _lockDays \\u003e= stakeDayLimit[_stakeType].minStakeDay \\u0026\\u0026\\r\\n            _lockDays \\u003c= stakeDayLimit[_stakeType].maxStakeDay,\\r\\n            \\u0027GRISE: stake is not in range\\u0027\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            _stakedAmount \\u003e= stakeCaps[_stakeType][stakingSlot].minStakingAmount \\u0026\\u0026 \\r\\n            _stakedAmount.mod(stakeCaps[_stakeType][stakingSlot].minStakingAmount) == 0,\\r\\n            \\u0027GRISE: stake is not large enough or StakingAmount is not Valid\\u0027\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            stakeCaps[_stakeType][stakingSlot].stakingSlotCount \\u003c= \\r\\n                    stakeCaps[_stakeType][stakingSlot].maxStakingSlot ,\\r\\n            \\u0027GRISE: All staking slot is occupied not extra slot is available\\u0027\\r\\n        );\\r\\n\\r\\n        uint256 newOccupiedSlotCount = _stakedAmount\\r\\n                                      .mod(stakeCaps[_stakeType][stakingSlot].minStakingAmount) != 0?\\r\\n                                      _stakedAmount\\r\\n                                      .div(stakeCaps[_stakeType][stakingSlot].minStakingAmount) + 1 :\\r\\n                                      _stakedAmount\\r\\n                                      .div(stakeCaps[_stakeType][stakingSlot].minStakingAmount);\\r\\n\\r\\n        require(\\r\\n            (stakeCaps[_stakeType][stakingSlot].stakingSlotCount + newOccupiedSlotCount \\u003c= \\r\\n                    stakeCaps[_stakeType][stakingSlot].maxStakingSlot),\\r\\n            \\u0027GRISE: All staking slot is occupied not extra slot is available\\u0027\\r\\n        );\\r\\n\\r\\n        stakeCaps[_stakeType][stakingSlot].stakingSlotCount = \\r\\n        stakeCaps[_stakeType][stakingSlot].stakingSlotCount.add(newOccupiedSlotCount);\\r\\n\\r\\n        (\\r\\n            Stake memory newStake,\\r\\n            bytes16 stakeID,\\r\\n            uint256 _startDay\\r\\n        ) =\\r\\n\\r\\n        _createStake(msg.sender, _stakedAmount, _lockDays, _stakeType, newOccupiedSlotCount);\\r\\n\\r\\n        stakes[msg.sender][stakeID] = newStake;\\r\\n\\r\\n        _increaseStakeCount(\\r\\n            msg.sender\\r\\n        );\\r\\n\\r\\n        _increaseGlobals(\\r\\n            uint8(newStake.stakeType),\\r\\n            newStake.stakedAmount,\\r\\n            newStake.stakesShares\\r\\n        );\\r\\n        \\r\\n        _addScheduledShares(\\r\\n            newStake.finalDay,\\r\\n            newStake.stakesShares\\r\\n        );\\r\\n\\r\\n        GRISE_CONTRACT.setStaker(msg.sender);\\r\\n        GRISE_CONTRACT.updateStakedToken(globals.totalStaked);\\r\\n\\r\\n        if (newStake.stakeType != StakeType.SHORT_TERM) {\\r\\n            GRISE_CONTRACT.updateMedTermShares(globals.MLTShares);\\r\\n        }\\r\\n\\r\\n        stakeCaps[_stakeType][stakingSlot].totalStakeCount++;\\r\\n\\r\\n        emit StakeStart(\\r\\n            stakeID,\\r\\n            msg.sender,\\r\\n            uint256(newStake.stakeType),\\r\\n            newStake.stakedAmount,\\r\\n            newStake.stakesShares,\\r\\n            newStake.startDay,\\r\\n            newStake.lockDays\\r\\n        );\\r\\n\\r\\n        return (stakeID, _startDay);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice A method for a staker to start a stake\\r\\n    * @param _staker ...\\r\\n    * @param _stakedAmount ...\\r\\n    * @param _lockDays ...\\r\\n    * @param _stakeType ...\\r\\n    * @param _totalOccupiedSlot ...\\r\\n    */\\r\\n    function _createStake(\\r\\n        address _staker,\\r\\n        uint256 _stakedAmount,\\r\\n        uint64 _lockDays,\\r\\n        StakeType  _stakeType,\\r\\n        uint256 _totalOccupiedSlot\\r\\n    )\\r\\n        private\\r\\n        returns (\\r\\n            Stake memory _newStake,\\r\\n            bytes16 _stakeID,\\r\\n            uint256 _startDay\\r\\n        )\\r\\n    {\\r\\n        require(\\r\\n            GRISE_CONTRACT.balanceOfStaker(_staker) \\u003e= _stakedAmount,\\r\\n            \\\"GRISE: Staker doesn\\u0027t have enough balance\\\"\\r\\n        );\\r\\n\\r\\n        GRISE_CONTRACT.burnSupply(\\r\\n            _staker,\\r\\n            _stakedAmount\\r\\n        );\\r\\n\\r\\n        _startDay = currentGriseDay() + 1;\\r\\n        _stakeID = generateStakeID(_staker);\\r\\n\\r\\n        _newStake.stakeType = _stakeType;\\r\\n        _newStake.totalOccupiedSlot = _totalOccupiedSlot;\\r\\n        _newStake.lockDays = _lockDays;\\r\\n        _newStake.startDay = _startDay;\\r\\n        _newStake.finalDay = _startDay + _lockDays;\\r\\n        _newStake.isActive = true;\\r\\n\\r\\n        _newStake.stakedAmount = _stakedAmount;\\r\\n        _newStake.stakesShares = _stakesShares(\\r\\n            _stakedAmount,\\r\\n            globals.sharePrice\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice A method for a staker to remove a stake\\r\\n    * belonging to his address by providing ID of a stake.\\r\\n    * @param _stakeID unique bytes sequence reference to the stake\\r\\n    */\\r\\n    function endStake(\\r\\n        bytes16 _stakeID\\r\\n    )\\r\\n        snapshotTrigger\\r\\n        external\\r\\n        returns (uint256)\\r\\n    {\\r\\n        (\\r\\n            Stake memory endedStake,\\r\\n            uint256 penaltyAmount\\r\\n        ) =\\r\\n\\r\\n        _endStake(\\r\\n            msg.sender,\\r\\n            _stakeID\\r\\n        );\\r\\n\\r\\n        _decreaseGlobals(\\r\\n            uint8(endedStake.stakeType),\\r\\n            endedStake.stakedAmount,\\r\\n            endedStake.stakesShares\\r\\n        );\\r\\n\\r\\n        _removeScheduledShares(\\r\\n            endedStake.finalDay,\\r\\n            endedStake.stakesShares\\r\\n        );\\r\\n\\r\\n        _storePenalty(\\r\\n            endedStake.closeDay,\\r\\n            penaltyAmount\\r\\n        );\\r\\n\\r\\n        uint8 stakingSlot; \\r\\n        if (endedStake.stakeType == StakeType.MEDIUM_TERM){\\r\\n            if (endedStake.lockDays == 168) { // 6 Month\\r\\n                stakingSlot = 1;\\r\\n            } else if (endedStake.lockDays == 252) { // 9 Month\\r\\n                stakingSlot = 2;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        stakeCaps[endedStake.stakeType][stakingSlot].stakingSlotCount = \\r\\n        stakeCaps[endedStake.stakeType][stakingSlot].stakingSlotCount.sub(endedStake.totalOccupiedSlot);\\r\\n        \\r\\n        GRISE_CONTRACT.resetStaker(msg.sender);\\r\\n        GRISE_CONTRACT.updateStakedToken(globals.totalStaked);\\r\\n\\r\\n        if (endedStake.stakeType != StakeType.SHORT_TERM) {\\r\\n            GRISE_CONTRACT.updateMedTermShares(globals.MLTShares);\\r\\n        }\\r\\n        \\r\\n        stakeCaps[endedStake.stakeType][stakingSlot].totalStakeCount--;\\r\\n\\r\\n        emit StakeEnd(\\r\\n            _stakeID,\\r\\n            msg.sender,\\r\\n            uint256(endedStake.stakeType),\\r\\n            endedStake.stakedAmount,\\r\\n            endedStake.stakesShares,\\r\\n            endedStake.rewardAmount,\\r\\n            endedStake.closeDay,\\r\\n            penaltyAmount\\r\\n        );\\r\\n\\r\\n        return endedStake.rewardAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice A method for a staker to end a stake\\r\\n    * @param _staker ...\\r\\n    * @param _stakeID ...\\r\\n    */\\r\\n    function _endStake(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    )\\r\\n        private\\r\\n        returns (\\r\\n            Stake storage _stake,\\r\\n            uint256 _penalty\\r\\n        )\\r\\n    {\\r\\n        require(\\r\\n            stakes[_staker][_stakeID].isActive,\\r\\n            \\u0027GRISE: Not an active stake\\u0027\\r\\n        );\\r\\n\\r\\n        uint256 transFeeCompensation;\\r\\n        _stake = stakes[_staker][_stakeID];\\r\\n        _stake.closeDay = currentGriseDay();\\r\\n        _stake.rewardAmount = _calculateRewardAmount(_stake);\\r\\n        _penalty = _calculatePenaltyAmount(_stake);\\r\\n\\r\\n        if (_stake.stakeType == StakeType.SHORT_TERM)\\r\\n        {\\r\\n            transFeeCompensation = (_stake.stakedAmount\\r\\n                                    .add(_stake.rewardAmount)\\r\\n                                    .sub(_penalty))\\r\\n                                    .mul(ST_STAKER_COMPENSATION)\\r\\n                                    .div(REWARD_PRECISION_RATE);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            transFeeCompensation = (_stake.stakedAmount\\r\\n                                    .add(_stake.rewardAmount)\\r\\n                                    .sub(_penalty))\\r\\n                                    .mul(MLT_STAKER_COMPENSATION)\\r\\n                                    .div(REWARD_PRECISION_RATE);\\r\\n        }\\r\\n        _stake.isActive = false;\\r\\n\\r\\n        GRISE_CONTRACT.mintSupply(\\r\\n            _staker,\\r\\n            _stake.stakedAmount \\u003e _penalty ?\\r\\n            _stake.stakedAmount - _penalty : 0\\r\\n        );\\r\\n\\r\\n        GRISE_CONTRACT.mintSupply(\\r\\n            _staker,\\r\\n            _stake.rewardAmount\\r\\n        );\\r\\n\\r\\n        GRISE_CONTRACT.mintSupply(\\r\\n            _staker,\\r\\n            transFeeCompensation\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice alloes to scrape Reward from active stake\\r\\n    * @param _stakeID unique bytes sequence reference to the stake\\r\\n    */\\r\\n    function scrapeReward(\\r\\n        bytes16 _stakeID\\r\\n    )\\r\\n        external\\r\\n        snapshotTrigger\\r\\n        returns (\\r\\n            uint256 scrapeDay,\\r\\n            uint256 scrapeAmount\\r\\n        )\\r\\n    {\\r\\n        require(\\r\\n            stakes[msg.sender][_stakeID].isActive,\\r\\n            \\u0027GRISE: Not an active stake\\u0027\\r\\n        );\\r\\n\\r\\n        Stake memory stake = stakes[msg.sender][_stakeID];\\r\\n\\r\\n        require(\\r\\n            globals.currentGriseDay \\u003e= stake.finalDay || \\r\\n                _startingDay(stake) \\u003c currentGriseDay().sub(currentGriseDay().mod(GRISE_WEEK)),\\r\\n            \\u0027GRISE: Stake is not yet mature to claim Reward\\u0027\\r\\n        );\\r\\n\\r\\n        scrapeDay = _calculationDay(stake);\\r\\n\\r\\n        scrapeDay = scrapeDay \\u003c stake.finalDay\\r\\n            ? scrapeDay.sub(scrapeDay.mod(GRISE_WEEK))\\r\\n            : scrapeDay;\\r\\n\\r\\n        scrapeAmount = getTranscRewardAmount(msg.sender, _stakeID);\\r\\n\\r\\n        scrapeAmount += getPenaltyRewardAmount(msg.sender, _stakeID);\\r\\n\\r\\n        scrapeAmount += getReservoirRewardAmount(msg.sender, _stakeID);\\r\\n\\r\\n        scrapes[msg.sender][_stakeID] =\\r\\n        scrapes[msg.sender][_stakeID].add(scrapeAmount);\\r\\n        \\r\\n        stake.scrapeDay = scrapeDay;\\r\\n        stakes[msg.sender][_stakeID] = stake;\\r\\n\\r\\n        GRISE_CONTRACT.mintSupply(\\r\\n            msg.sender,\\r\\n            scrapeAmount\\r\\n        );\\r\\n\\r\\n        emit InterestScraped(\\r\\n            _stakeID,\\r\\n            msg.sender,\\r\\n            scrapeAmount,\\r\\n            scrapeDay,\\r\\n            currentGriseDay()\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _addScheduledShares(\\r\\n        uint256 _finalDay,\\r\\n        uint256 _shares\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        scheduledToEnd[_finalDay] =\\r\\n        scheduledToEnd[_finalDay].add(_shares);\\r\\n    }\\r\\n\\r\\n    function _removeScheduledShares(\\r\\n        uint256 _finalDay,\\r\\n        uint256 _shares\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        if (_notPast(_finalDay)) {\\r\\n\\r\\n            scheduledToEnd[_finalDay] =\\r\\n            scheduledToEnd[_finalDay] \\u003e _shares ?\\r\\n            scheduledToEnd[_finalDay] - _shares : 0;\\r\\n\\r\\n        } else {\\r\\n\\r\\n            uint256 _day = currentGriseDay() - 1;\\r\\n            snapshots[_day].scheduledToEnd =\\r\\n            snapshots[_day].scheduledToEnd \\u003e _shares ?\\r\\n            snapshots[_day].scheduledToEnd - _shares : 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function checkMatureStake(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (bool isMature)\\r\\n    {\\r\\n        Stake memory stake = stakes[_staker][_stakeID];\\r\\n        isMature = _isMatureStake(stake);\\r\\n    }\\r\\n\\r\\n    function checkStakeByID(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns \\r\\n    (\\r\\n        uint256 startDay,\\r\\n        uint256 lockDays,\\r\\n        uint256 finalDay,\\r\\n        uint256 closeDay,\\r\\n        uint256 scrapeDay,\\r\\n        StakeType stakeType,\\r\\n        uint256 slotOccupied,\\r\\n        uint256 stakedAmount,\\r\\n        uint256 penaltyAmount,\\r\\n        bool isActive,\\r\\n        bool isMature\\r\\n    )\\r\\n    {\\r\\n        Stake memory stake = stakes[_staker][_stakeID];\\r\\n        startDay = stake.startDay;\\r\\n        lockDays = stake.lockDays;\\r\\n        finalDay = stake.finalDay;\\r\\n        closeDay = stake.closeDay;\\r\\n        scrapeDay = stake.scrapeDay;\\r\\n        stakeType = stake.stakeType;\\r\\n        slotOccupied = stake.totalOccupiedSlot;\\r\\n        stakedAmount = stake.stakedAmount;\\r\\n        penaltyAmount = _calculatePenaltyAmount(stake);\\r\\n        isActive = stake.isActive;\\r\\n        isMature = _isMatureStake(stake);\\r\\n    }\\r\\n\\r\\n    function checkStakeRewards(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns \\r\\n    (\\r\\n        uint256 transcRewardAmount,\\r\\n        uint256 penaltyRewardAmount,\\r\\n        uint256 reservoirRewardAmount,\\r\\n        uint256 inflationRewardAmount\\r\\n    )\\r\\n    {\\r\\n        transcRewardAmount = getTranscRewardAmount(_staker, _stakeID);\\r\\n        penaltyRewardAmount = getPenaltyRewardAmount(_staker, _stakeID);\\r\\n        reservoirRewardAmount = getReservoirRewardAmount(_staker, _stakeID);\\r\\n        inflationRewardAmount = getInflationRewardAmount(_staker, _stakeID);\\r\\n    }\\r\\n\\r\\n    function updateStakingSlotLimit(\\r\\n        uint256 STSlotLimit,\\r\\n        uint256 MT3MonthSlotLimit,\\r\\n        uint256 MT6MonthSlotLimit,\\r\\n        uint256 MT9MonthSlotLimit,\\r\\n        uint256 LTSlotLimit\\r\\n    )\\r\\n    external\\r\\n    {\\r\\n        require(\\r\\n            msg.sender == contractDeployer,\\r\\n            \\u0027Operation Denied\\u0027\\r\\n        );\\r\\n\\r\\n        stakeCaps[StakeType.SHORT_TERM][0].maxStakingSlot = STSlotLimit;\\r\\n        stakeCaps[StakeType.MEDIUM_TERM][0].maxStakingSlot = MT3MonthSlotLimit;\\r\\n        stakeCaps[StakeType.MEDIUM_TERM][1].maxStakingSlot = MT6MonthSlotLimit;\\r\\n        stakeCaps[StakeType.MEDIUM_TERM][2].maxStakingSlot = MT9MonthSlotLimit;\\r\\n        stakeCaps[StakeType.LONG_TERM][0].maxStakingSlot = LTSlotLimit;\\r\\n    }\\r\\n\\r\\n    function getTranscRewardAmount(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    ) \\r\\n        private\\r\\n        view\\r\\n        returns (uint256 rewardAmount)\\r\\n    {\\r\\n        Stake memory _stake = stakes[_staker][_stakeID];\\r\\n\\r\\n        if ( _stakeEligibleForWeeklyReward(_stake))\\r\\n        {\\r\\n            uint256 _endDay = currentGriseDay() \\u003e= _stake.finalDay ? \\r\\n                                _stake.finalDay : \\r\\n                                currentGriseDay().sub(currentGriseDay().mod(GRISE_WEEK));\\r\\n\\r\\n            rewardAmount = _loopTranscRewardAmount(\\r\\n                _stake.stakesShares,\\r\\n                _startingDay(_stake),\\r\\n                _endDay,\\r\\n                _stake.stakeType);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPenaltyRewardAmount(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    ) \\r\\n        private \\r\\n        view \\r\\n        returns (uint256 rewardAmount) \\r\\n    {\\r\\n        Stake memory _stake = stakes[_staker][_stakeID];\\r\\n\\r\\n        if ( _stakeEligibleForWeeklyReward(_stake))\\r\\n        {\\r\\n            uint256 _endDay = currentGriseDay() \\u003e= _stake.finalDay ? \\r\\n                                _stake.finalDay : \\r\\n                                currentGriseDay().sub(currentGriseDay().mod(GRISE_WEEK));\\r\\n\\r\\n            rewardAmount = _loopPenaltyRewardAmount(\\r\\n                _stake.stakesShares,\\r\\n                _startingDay(_stake),\\r\\n                _endDay,\\r\\n                _stake.stakeType);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getReservoirRewardAmount(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    ) \\r\\n        private \\r\\n        view \\r\\n        returns (uint256 rewardAmount) \\r\\n    {\\r\\n        Stake memory _stake = stakes[_staker][_stakeID];\\r\\n\\r\\n        if ( _stakeEligibleForMonthlyReward(_stake))\\r\\n        {\\r\\n            uint256 _endDay = currentGriseDay() \\u003e= _stake.finalDay ? \\r\\n                                _stake.finalDay : \\r\\n                                currentGriseDay().sub(currentGriseDay().mod(GRISE_MONTH));\\r\\n\\r\\n            rewardAmount = _loopReservoirRewardAmount(\\r\\n                _stake.stakesShares,\\r\\n                _startingDay(_stake),\\r\\n                _endDay,\\r\\n                _stake.stakeType\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getInflationRewardAmount(\\r\\n        address _staker,\\r\\n        bytes16 _stakeID\\r\\n    ) \\r\\n        private \\r\\n        view \\r\\n        returns (uint256 rewardAmount) \\r\\n    {    \\r\\n        Stake memory _stake = stakes[_staker][_stakeID];\\r\\n\\r\\n        if ( _stake.isActive \\u0026\\u0026 !_stakeNotStarted(_stake))\\r\\n        {\\r\\n            rewardAmount = _loopInflationRewardAmount(\\r\\n            _stake.stakesShares,\\r\\n            _stake.startDay,\\r\\n            _calculationDay(_stake),\\r\\n            _stake.stakeType);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _stakesShares(\\r\\n        uint256 _stakedAmount,\\r\\n        uint256 _sharePrice\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _stakedAmount\\r\\n                .div(_sharePrice);\\r\\n    }\\r\\n\\r\\n    function _storePenalty(\\r\\n        uint256 _storeDay,\\r\\n        uint256 _penalty\\r\\n    )\\r\\n        private\\r\\n    {\\r\\n        if (_penalty \\u003e 0) {\\r\\n            totalPenalties[_storeDay] =\\r\\n            totalPenalties[_storeDay].add(_penalty);\\r\\n\\r\\n            MLTPenaltiesRewardPerShares[_storeDay] += \\r\\n                _penalty.mul(MED_LONG_STAKER_PENALTY_REWARD)\\r\\n                        .div(REWARD_PRECISION_RATE)\\r\\n                        .div(globals.MLTShares);\\r\\n\\r\\n            STPenaltiesRewardPerShares[_storeDay] +=\\r\\n                _penalty.mul(SHORT_STAKER_PENALTY_REWARD)\\r\\n                        .div(REWARD_PRECISION_RATE)\\r\\n                        .div(globals.STShares);\\r\\n\\r\\n            ReservoirPenaltiesRewardPerShares[_storeDay] +=\\r\\n                _penalty.mul(RESERVOIR_PENALTY_REWARD)\\r\\n                        .div(REWARD_PRECISION_RATE)\\r\\n                        .div(globals.MLTShares);\\r\\n\\r\\n            GRISE_CONTRACT.mintSupply(\\r\\n                TEAM_ADDRESS,\\r\\n                _penalty.mul(TEAM_PENALTY_REWARD)\\r\\n                        .div(REWARD_PRECISION_RATE)\\r\\n            );\\r\\n\\r\\n            GRISE_CONTRACT.mintSupply(\\r\\n                DEVELOPER_ADDRESS,\\r\\n                _penalty.mul(DEVELOPER_PENALTY_REWARD)\\r\\n                        .div(REWARD_PRECISION_RATE)\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _calculatePenaltyAmount(\\r\\n        Stake memory _stake\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _stakeNotStarted(_stake) || _isMatureStake(_stake) ? 0 : _getPenalties(_stake);\\r\\n    }\\r\\n\\r\\n    function _getPenalties(\\r\\n        Stake memory _stake\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _stake.stakedAmount * ((PENALTY_RATE * (_daysLeft(_stake) - 1) / (_getLockDays(_stake)))) / 10000;\\r\\n    }\\r\\n\\r\\n    function _calculateRewardAmount(\\r\\n        Stake memory _stake\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 _rewardAmount)\\r\\n    {\\r\\n        _rewardAmount = _loopPenaltyRewardAmount(\\r\\n            _stake.stakesShares,\\r\\n            _startingDay(_stake),\\r\\n            _calculationDay(_stake),\\r\\n            _stake.stakeType\\r\\n        );\\r\\n\\r\\n        _rewardAmount += _loopTranscRewardAmount(\\r\\n            _stake.stakesShares,\\r\\n            _startingDay(_stake),\\r\\n            _calculationDay(_stake),\\r\\n            _stake.stakeType\\r\\n        );\\r\\n\\r\\n        _rewardAmount += _loopReservoirRewardAmount(\\r\\n            _stake.stakesShares,\\r\\n            _startingDay(_stake),\\r\\n            _calculationDay(_stake),\\r\\n             _stake.stakeType\\r\\n        );\\r\\n        \\r\\n        _rewardAmount += _loopInflationRewardAmount(\\r\\n            _stake.stakesShares,\\r\\n            _stake.startDay,\\r\\n            _calculationDay(_stake),\\r\\n            _stake.stakeType\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _loopInflationRewardAmount(\\r\\n        uint256 _stakeShares,\\r\\n        uint256 _startDay,\\r\\n        uint256 _finalDay,\\r\\n        StakeType _stakeType\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 _rewardAmount)\\r\\n    {\\r\\n        uint256 inflationAmount;\\r\\n        if (_stakeType == StakeType.SHORT_TERM)\\r\\n        {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        for (uint256 _day = _startDay; _day \\u003c _finalDay; _day++) {\\r\\n\\r\\n            inflationAmount = (_stakeType == StakeType.MEDIUM_TERM) ? \\r\\n                                snapshots[_day].inflationAmount\\r\\n                                .mul(MED_TERM_INFLATION_REWARD)\\r\\n                                .div(REWARD_PRECISION_RATE) :\\r\\n                                snapshots[_day].inflationAmount\\r\\n                                .mul(LONG_TERM_INFLATION_REWARD)\\r\\n                                .div(REWARD_PRECISION_RATE);\\r\\n\\r\\n            _rewardAmount = _rewardAmount\\r\\n                            .add(_stakeShares\\r\\n                                    .mul(PRECISION_RATE)\\r\\n                                    .div(inflationAmount));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _loopPenaltyRewardAmount(\\r\\n        uint256 _stakeShares,\\r\\n        uint256 _startDay,\\r\\n        uint256 _finalDay,\\r\\n        StakeType _stakeType\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 _rewardAmount)\\r\\n    {\\r\\n        for (uint256 day = _startDay; day \\u003c _finalDay; day++) \\r\\n        {\\r\\n            if (_stakeType == StakeType.SHORT_TERM)\\r\\n            {\\r\\n                _rewardAmount += STPenaltiesRewardPerShares[day]\\r\\n                                    .mul(_stakeShares);\\r\\n            } else {\\r\\n                _rewardAmount += MLTPenaltiesRewardPerShares[day]\\r\\n                                    .mul(_stakeShares);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _loopReservoirRewardAmount(\\r\\n        uint256 _stakeShares,\\r\\n        uint256 _startDay,\\r\\n        uint256 _finalDay,\\r\\n        StakeType _stakeType\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 _rewardAmount)\\r\\n    {\\r\\n        if (_stakeType == StakeType.SHORT_TERM)\\r\\n        {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        for (uint256 day = _startDay; day \\u003c _finalDay; day++) \\r\\n        {\\r\\n            _rewardAmount = \\r\\n            _rewardAmount.add(ReservoirPenaltiesRewardPerShares[day]);\\r\\n        }\\r\\n\\r\\n        _rewardAmount = \\r\\n        _rewardAmount.add(GRISE_CONTRACT.getReservoirReward(_startDay, _finalDay));\\r\\n\\r\\n        _rewardAmount = \\r\\n        _rewardAmount.mul(_stakeShares);\\r\\n    }\\r\\n\\r\\n    function _loopTranscRewardAmount(\\r\\n        uint256 _stakeShares,\\r\\n        uint256 _startDay,\\r\\n        uint256 _finalDay,\\r\\n        StakeType _stakeType\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 _rewardAmount)\\r\\n    {\\r\\n        uint256 stakedAmount = _stakeShares.mul(globals.sharePrice);\\r\\n        \\r\\n        if (_stakeType != StakeType.SHORT_TERM)\\r\\n        {\\r\\n            _rewardAmount =\\r\\n            _rewardAmount.add(GRISE_CONTRACT.getTransFeeReward(_startDay, _finalDay)\\r\\n                                .mul(_stakeShares)); \\r\\n        }\\r\\n\\r\\n        _rewardAmount =\\r\\n        _rewardAmount.add(GRISE_CONTRACT.getTokenHolderReward(_startDay, _finalDay)\\r\\n                            .mul(stakedAmount)\\r\\n                            .div(PRECISION_RATE));\\r\\n    }\\r\\n\\r\\n    function getSlotLeft() \\r\\n        external \\r\\n        view \\r\\n        returns \\r\\n    (\\r\\n        uint256 STSlotLeft, \\r\\n        uint256 MT3MonthSlotLeft,\\r\\n        uint256 MT6MonthSlotLeft, \\r\\n        uint256 MT9MonthSlotLeft, \\r\\n        uint256 LTSlotLeft\\r\\n    ) \\r\\n    {\\r\\n\\r\\n        STSlotLeft = stakeCaps[StakeType.SHORT_TERM][0].maxStakingSlot\\r\\n                            .sub(stakeCaps[StakeType.SHORT_TERM][0].stakingSlotCount);\\r\\n\\r\\n        MT3MonthSlotLeft = stakeCaps[StakeType.MEDIUM_TERM][0].maxStakingSlot\\r\\n                            .sub(stakeCaps[StakeType.MEDIUM_TERM][0].stakingSlotCount);\\r\\n                            \\r\\n        MT6MonthSlotLeft = stakeCaps[StakeType.MEDIUM_TERM][1].maxStakingSlot\\r\\n                            .sub(stakeCaps[StakeType.MEDIUM_TERM][1].stakingSlotCount);\\r\\n\\r\\n        MT9MonthSlotLeft = stakeCaps[StakeType.MEDIUM_TERM][2].maxStakingSlot\\r\\n                            .sub(stakeCaps[StakeType.MEDIUM_TERM][2].stakingSlotCount);\\r\\n        \\r\\n        LTSlotLeft = stakeCaps[StakeType.LONG_TERM][0].maxStakingSlot\\r\\n                            .sub(stakeCaps[StakeType.LONG_TERM][0].stakingSlotCount);\\r\\n    }\\r\\n\\r\\n    function getStakeCount() \\r\\n        external \\r\\n        view \\r\\n        returns \\r\\n    (\\r\\n        uint256 STStakeCount, \\r\\n        uint256 MT3MonthStakeCount,\\r\\n        uint256 MT6MonthStakeCount,\\r\\n        uint256 MT9MonthStakeCount,\\r\\n        uint256 LTStakeCount\\r\\n    )\\r\\n    {\\r\\n        STStakeCount = stakeCaps[StakeType.SHORT_TERM][0].totalStakeCount;\\r\\n        MT3MonthStakeCount = stakeCaps[StakeType.MEDIUM_TERM][0].totalStakeCount;\\r\\n        MT6MonthStakeCount = stakeCaps[StakeType.MEDIUM_TERM][1].totalStakeCount;\\r\\n        MT9MonthStakeCount = stakeCaps[StakeType.MEDIUM_TERM][2].totalStakeCount;\\r\\n        LTStakeCount = stakeCaps[StakeType.LONG_TERM][0].totalStakeCount;\\r\\n    }\\r\\n\\r\\n    function getTotalStakedToken()\\r\\n        external\\r\\n        view \\r\\n        returns (uint256) \\r\\n    {\\r\\n        return globals.totalStaked;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_immutableAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentGriseDay\",\"type\":\"uint256\"}],\"name\":\"InterestScraped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentGriseDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shortTermshare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"MediumTermshare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareRate\",\"type\":\"uint256\"}],\"name\":\"NewGlobals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closeDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"}],\"name\":\"StakeEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"}],\"name\":\"StakeStart\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GRISE_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IGriseToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MLTPenaltiesRewardPerShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ReservoirPenaltiesRewardPerShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"STPenaltiesRewardPerShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapRouterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"checkMatureStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMature\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"checkStakeByID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"enum Declaration.StakeType\",\"name\":\"stakeType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"slotOccupied\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMature\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"checkStakeRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"transcRewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyRewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservoirRewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationRewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum Declaration.StakeType\",\"name\":\"_stakeType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"}],\"name\":\"createStake\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum Declaration.StakeType\",\"name\":\"_stakeType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"_lockDays\",\"type\":\"uint64\"}],\"name\":\"createStakeWithETH\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"endStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"x\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"z\",\"type\":\"bytes1\"}],\"name\":\"generateID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"b\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSlotLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"STSlotLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MT3MonthSlotLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MT6MonthSlotLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MT9MonthSlotLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LTSlotLeft\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"STStakeCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MT3MonthStakeCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MT6MonthStakeCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MT9MonthStakeCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LTStakeCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"STShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MLTShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentGriseDay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"latestStakeID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDailySnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_updateDay\",\"type\":\"uint256\"}],\"name\":\"manualDailySnapshotPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"scheduledToEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"scrapeReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scrapeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"scrapes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"snapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheduledToEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Declaration.StakeType\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"stakeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minStakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingSlotCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakingSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakeCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Declaration.StakeType\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"stakeDayLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minStakeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeDay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum Declaration.StakeType\",\"name\":\"stakeType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalOccupiedSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scrapeDay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"stakesPagination\",\"outputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_stakes\",\"type\":\"bytes16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalPenalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"STSlotLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MT3MonthSlotLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MT6MonthSlotLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MT9MonthSlotLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LTSlotLimit\",\"type\":\"uint256\"}],\"name\":\"updateStakingSlotLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"StakingToken","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000eff9c1b11bcde99cdfb6305d25bea1db52fa6032","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e99ae803e8414c5d3d5a30ee65b8f467f78f366a9292ebc29168100270b8e57d"}]}