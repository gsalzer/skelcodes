{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BinaryOptionMarketMastercopy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// Inheritance\\nimport \\\"./BinaryOptionMarket.sol\\\";\\n\\ncontract BinaryOptionMarketMastercopy is BinaryOptionMarket {\\n    constructor() public MinimalProxyFactory() OwnedWithInit() {\\n        // Freeze mastercopy on deployment so it can never be initialized with real arguments\\n        initialized = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BinaryOptionMarket.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// Inheritance\\nimport \\\"synthetix-2.43.1/contracts/MinimalProxyFactory.sol\\\";\\nimport \\\"./OwnedWithInit.sol\\\";\\nimport \\\"./interfaces/IBinaryOptionMarket.sol\\\";\\n\\n// Libraries\\nimport \\\"synthetix-2.43.1/contracts/SafeDecimalMath.sol\\\";\\n\\n// Internal references\\nimport \\\"./BinaryOptionMarketManager.sol\\\";\\nimport \\\"./BinaryOption.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/interfaces/IExchangeRates.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/interfaces/IAddressResolver.sol\\\";\\n\\ncontract BinaryOptionMarket is MinimalProxyFactory, OwnedWithInit, IBinaryOptionMarket {\\n    /* ========== LIBRARIES ========== */\\n\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    /* ========== TYPES ========== */\\n\\n    struct Options {\\n        BinaryOption long;\\n        BinaryOption short;\\n    }\\n\\n    struct Times {\\n        uint maturity;\\n        uint expiry;\\n    }\\n\\n    struct OracleDetails {\\n        bytes32 key;\\n        uint strikePrice;\\n        uint finalPrice;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    Options public options;\\n    Times public times;\\n    OracleDetails public oracleDetails;\\n    BinaryOptionMarketManager.Fees public fees;\\n    IAddressResolver public resolver;\\n\\n    // `deposited` tracks the sum of all deposits minus the withheld fees.\\n    // This must explicitly be kept, in case tokens are transferred to the contract directly.\\n    uint public deposited;\\n    uint public accumulatedFees;\\n    uint public initialMint;\\n    address public creator;\\n    bool public resolved;\\n\\n    uint internal _feeMultiplier;\\n\\n    /* ---------- Address Resolver Configuration ---------- */\\n\\n    bytes32 internal constant CONTRACT_EXRATES = \\\"ExchangeRates\\\";\\n    bytes32 internal constant CONTRACT_SYNTHSUSD = \\\"SynthsUSD\\\";\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    bool public initialized = false;\\n\\n    function initialize(\\n        address _owner,\\n        address _binaryOptionMastercopy,\\n        IAddressResolver _resolver,\\n        address _creator,\\n        bytes32 _oracleKey,\\n        uint _strikePrice,\\n        uint[2] calldata _times, // [maturity, expiry]\\n        uint _deposit, // sUSD deposit\\n        uint[2] calldata _fees // [poolFee, creatorFee]\\n    ) external {\\n        require(!initialized, \\\"Binary Option Market already initialized\\\");\\n        initialized = true;\\n        initOwner(_owner);\\n        resolver = _resolver;\\n        creator = _creator;\\n\\n        oracleDetails = OracleDetails(_oracleKey, _strikePrice, 0);\\n        times = Times(_times[0], _times[1]);\\n\\n        deposited = _deposit;\\n        initialMint = _deposit;\\n\\n        (uint poolFee, uint creatorFee) = (_fees[0], _fees[1]);\\n        fees = BinaryOptionMarketManager.Fees(poolFee, creatorFee);\\n        _feeMultiplier = SafeDecimalMath.unit().sub(poolFee.add(creatorFee));\\n\\n        // Instantiate the options themselves\\n        options.long = BinaryOption(_cloneAsMinimalProxy(_binaryOptionMastercopy, \\\"Could not create a Binary Option\\\"));\\n        options.short = BinaryOption(_cloneAsMinimalProxy(_binaryOptionMastercopy, \\\"Could not create a Binary Option\\\"));\\n        // abi.encodePacked(\\\"sLONG: \\\", _oracleKey)\\n        // consider naming the option: sLongBTC>50@2021.12.31\\n        options.long.initialize(\\\"Binary Option Long\\\", \\\"sLONG\\\");\\n        options.short.initialize(\\\"Binary Option Short\\\", \\\"sSHORT\\\");\\n        _mint(creator, initialMint);\\n\\n        // Note: the ERC20 base contract does not have a constructor, so we do not have to worry\\n        // about initializing its state separately\\n    }\\n\\n    /* ---------- External Contracts ---------- */\\n\\n    function _exchangeRates() internal view returns (IExchangeRates) {\\n        return IExchangeRates(resolver.requireAndGetAddress(CONTRACT_EXRATES, \\\"ExchangeRates contract not found\\\"));\\n    }\\n\\n    function _sUSD() internal view returns (IERC20) {\\n        return IERC20(resolver.requireAndGetAddress(CONTRACT_SYNTHSUSD, \\\"SynthsUSD contract not found\\\"));\\n    }\\n\\n    function _manager() internal view returns (BinaryOptionMarketManager) {\\n        return BinaryOptionMarketManager(owner);\\n    }\\n\\n    /* ---------- Phases ---------- */\\n\\n    function _matured() internal view returns (bool) {\\n        return times.maturity < block.timestamp;\\n    }\\n\\n    function _expired() internal view returns (bool) {\\n        return resolved && (times.expiry < block.timestamp || deposited == 0);\\n    }\\n\\n    function phase() external view returns (Phase) {\\n        if (!_matured()) {\\n            return Phase.Trading;\\n        }\\n        if (!_expired()) {\\n            return Phase.Maturity;\\n        }\\n        return Phase.Expiry;\\n    }\\n\\n    /* ---------- Market Resolution ---------- */\\n\\n    function _oraclePriceAndTimestamp() internal view returns (uint price, uint updatedAt) {\\n        return _exchangeRates().rateAndUpdatedTime(oracleDetails.key);\\n    }\\n\\n    function oraclePriceAndTimestamp() external view returns (uint price, uint updatedAt) {\\n        return _oraclePriceAndTimestamp();\\n    }\\n\\n    function _isFreshPriceUpdateTime(uint timestamp) internal view returns (bool) {\\n        (uint maxOraclePriceAge, , ) = _manager().durations();\\n        return (times.maturity.sub(maxOraclePriceAge)) <= timestamp;\\n    }\\n\\n    function canResolve() external view returns (bool) {\\n        (, uint updatedAt) = _oraclePriceAndTimestamp();\\n        return !resolved && _matured() && _isFreshPriceUpdateTime(updatedAt);\\n    }\\n\\n    function _result() internal view returns (Side) {\\n        uint price;\\n        if (resolved) {\\n            price = oracleDetails.finalPrice;\\n        } else {\\n            (price, ) = _oraclePriceAndTimestamp();\\n        }\\n\\n        return oracleDetails.strikePrice <= price ? Side.Long : Side.Short;\\n    }\\n\\n    function result() external view returns (Side) {\\n        return _result();\\n    }\\n\\n    /* ---------- Option Balances and Mints ---------- */\\n\\n    function _balancesOf(address account) internal view returns (uint long, uint short) {\\n        return (options.long.balanceOf(account), options.short.balanceOf(account));\\n    }\\n\\n    function balancesOf(address account) external view returns (uint long, uint short) {\\n        return _balancesOf(account);\\n    }\\n\\n    function totalSupplies() external view returns (uint long, uint short) {\\n        return (options.long.totalSupply(), options.short.totalSupply());\\n    }\\n\\n    /* ---------- Utilities ---------- */\\n\\n    function _incrementDeposited(uint value) internal returns (uint _deposited) {\\n        _deposited = deposited.add(value);\\n        deposited = _deposited;\\n        _manager().incrementTotalDeposited(value);\\n    }\\n\\n    function _decrementDeposited(uint value) internal returns (uint _deposited) {\\n        _deposited = deposited.sub(value);\\n        deposited = _deposited;\\n        _manager().decrementTotalDeposited(value);\\n    }\\n\\n    function _requireManagerNotPaused() internal view {\\n        require(!_manager().paused(), \\\"This action cannot be performed while the contract is paused\\\");\\n    }\\n\\n    function requireUnpaused() external view {\\n        _requireManagerNotPaused();\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /* ---------- Minting ---------- */\\n\\n    function mint(uint value) external duringMinting {\\n        if (value == 0) {\\n            return;\\n        }\\n\\n        uint valueAfterFees = value.multiplyDecimalRound(_feeMultiplier);\\n        uint deductedFees = value.sub(valueAfterFees);\\n        accumulatedFees = accumulatedFees.add(deductedFees);\\n\\n        _mint(msg.sender, valueAfterFees);\\n\\n        _incrementDeposited(value);\\n        _manager().transferSusdTo(msg.sender, address(this), value);\\n    }\\n\\n    function _mint(address minter, uint amount) internal {\\n        options.long.mint(minter, amount);\\n        options.short.mint(minter, amount);\\n\\n        emit Mint(Side.Long, minter, amount);\\n        emit Mint(Side.Short, minter, amount);\\n    }\\n\\n    /* ---------- Market Resolution ---------- */\\n\\n    function resolve() external onlyOwner afterMaturity managerNotPaused {\\n        require(!resolved, \\\"Market already resolved\\\");\\n\\n        // We don't need to perform stale price checks, so long as the price was\\n        // last updated recently enough before the maturity date.\\n        (uint price, uint updatedAt) = _oraclePriceAndTimestamp();\\n        require(_isFreshPriceUpdateTime(updatedAt), \\\"Price is stale\\\");\\n\\n        oracleDetails.finalPrice = price;\\n        resolved = true;\\n\\n        // Now remit any collected fees.\\n        // Since the constructor enforces that creatorFee + poolFee < 1, the balance\\n        // in the contract will be sufficient to cover these transfers.\\n        IERC20 sUSD = _sUSD();\\n\\n        uint totalFeesRatio = fees.poolFee.add(fees.creatorFee);\\n        uint poolFeesRatio = fees.poolFee.divideDecimalRound(totalFeesRatio);\\n        uint creatorFeesRatio = fees.creatorFee.divideDecimalRound(totalFeesRatio);\\n        uint poolFees = poolFeesRatio.multiplyDecimalRound(accumulatedFees);\\n        uint creatorFees = accumulatedFees.sub(poolFees);\\n        _decrementDeposited(creatorFees.add(poolFees));\\n        sUSD.transfer(_manager().feeAddress(), poolFees);\\n        sUSD.transfer(creator, creatorFees);\\n\\n        emit MarketResolved(_result(), price, updatedAt, deposited, poolFees, creatorFees);\\n    }\\n\\n    /* ---------- Claiming and Exercising Options ---------- */\\n\\n    function exerciseOptions() external afterMaturity returns (uint) {\\n        // The market must be resolved if it has not been.\\n        // the first one to exercise pays the gas fees. Might be worth splitting it up.\\n        if (!resolved) {\\n            _manager().resolveMarket(address(this));\\n        }\\n\\n        // If the account holds no options, revert.\\n        (uint longBalance, uint shortBalance) = _balancesOf(msg.sender);\\n        require(longBalance != 0 || shortBalance != 0, \\\"Nothing to exercise\\\");\\n\\n        // Each option only needs to be exercised if the account holds any of it.\\n        if (longBalance != 0) {\\n            options.long.exercise(msg.sender);\\n        }\\n        if (shortBalance != 0) {\\n            options.short.exercise(msg.sender);\\n        }\\n\\n        // Only pay out the side that won.\\n        uint payout = (_result() == Side.Long) ? longBalance : shortBalance;\\n        emit OptionsExercised(msg.sender, payout);\\n        if (payout != 0) {\\n            _decrementDeposited(payout);\\n            _sUSD().transfer(msg.sender, payout);\\n        }\\n        return payout;\\n    }\\n\\n    /* ---------- Market Expiry ---------- */\\n\\n    function _selfDestruct(address payable beneficiary) internal {\\n        uint _deposited = deposited;\\n        if (_deposited != 0) {\\n            _decrementDeposited(_deposited);\\n        }\\n\\n        // Transfer the balance rather than the deposit value in case there are any synths left over\\n        // from direct transfers.\\n        IERC20 sUSD = _sUSD();\\n        uint balance = sUSD.balanceOf(address(this));\\n        if (balance != 0) {\\n            sUSD.transfer(beneficiary, balance);\\n        }\\n\\n        // Destroy the option tokens before destroying the market itself.\\n        options.long.expire(beneficiary);\\n        options.short.expire(beneficiary);\\n        selfdestruct(beneficiary);\\n    }\\n\\n    function expire(address payable beneficiary) external onlyOwner {\\n        require(_expired(), \\\"Unexpired options remaining\\\");\\n        _selfDestruct(beneficiary);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier duringMinting() {\\n        require(!_matured(), \\\"Minting inactive\\\");\\n        _;\\n    }\\n\\n    modifier afterMaturity() {\\n        require(_matured(), \\\"Not yet mature\\\");\\n        _;\\n    }\\n\\n    modifier managerNotPaused() {\\n        _requireManagerNotPaused();\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Mint(Side side, address indexed account, uint value);\\n    event MarketResolved(\\n        Side result,\\n        uint oraclePrice,\\n        uint oracleTimestamp,\\n        uint deposited,\\n        uint poolFees,\\n        uint creatorFees\\n    );\\n    event OptionsExercised(address indexed account, uint value);\\n}\\n\"\r\n    },\r\n    \"synthetix-2.43.1/contracts/MinimalProxyFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// https://docs.synthetix.io/contracts/source/contracts/minimalproxyfactory\\ncontract MinimalProxyFactory {\\n    function _cloneAsMinimalProxy(address _base, string memory _revertMsg) internal returns (address clone) {\\n        bytes memory createData = _generateMinimalProxyCreateData(_base);\\n\\n        assembly {\\n            clone := create(\\n                0, // no value\\n                add(createData, 0x20), // data\\n                55 // data is always 55 bytes (10 constructor + 45 code)\\n            )\\n        }\\n\\n        // If CREATE fails for some reason, address(0) is returned\\n        require(clone != address(0), _revertMsg);\\n    }\\n\\n    function _generateMinimalProxyCreateData(address _base) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                //---- constructor -----\\n                bytes10(0x3d602d80600a3d3981f3),\\n                //---- proxy code -----\\n                bytes10(0x363d3d373d3d3d363d73),\\n                _base,\\n                bytes15(0x5af43d82803e903d91602b57fd5bf3)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OwnedWithInit.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ncontract OwnedWithInit {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor() public {}\\n\\n    function initOwner(address _owner) internal {\\n        require(owner == address(0), \\\"Init can only be called when owner is 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBinaryOptionMarket.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\nimport \\\"../interfaces/IBinaryOptionMarketManager.sol\\\";\\nimport \\\"../interfaces/IBinaryOption.sol\\\";\\n\\ninterface IBinaryOptionMarket {\\n    /* ========== TYPES ========== */\\n\\n    enum Phase {Trading, Maturity, Expiry}\\n    enum Side {Long, Short}\\n\\n    /* ========== VIEWS / VARIABLES ========== */\\n\\n    function options() external view returns (IBinaryOption long, IBinaryOption short);\\n\\n    function times()\\n        external\\n        view\\n        returns (\\n            uint maturity,\\n            uint destructino\\n        );\\n\\n    function oracleDetails()\\n        external\\n        view\\n        returns (\\n            bytes32 key,\\n            uint strikePrice,\\n            uint finalPrice\\n        );\\n\\n    function fees()\\n        external\\n        view\\n        returns (\\n            uint poolFee,\\n            uint creatorFee\\n        );\\n\\n    function deposited() external view returns (uint);\\n\\n    function accumulatedFees() external view returns (uint);\\n\\n    function creator() external view returns (address);\\n\\n    function resolved() external view returns (bool);\\n\\n    function phase() external view returns (Phase);\\n\\n    function oraclePriceAndTimestamp() external view returns (uint price, uint updatedAt);\\n\\n    function canResolve() external view returns (bool);\\n\\n    function result() external view returns (Side);\\n\\n    function balancesOf(address account) external view returns (uint long, uint short);\\n\\n    function totalSupplies() external view returns (uint long, uint short);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function mint(uint value) external;\\n\\n    function exerciseOptions() external returns (uint);\\n}\\n\"\r\n    },\r\n    \"synthetix-2.43.1/contracts/SafeDecimalMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// Libraries\\nimport \\\"openzeppelin-solidity-2.3.0/contracts/math/SafeMath.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\\nlibrary SafeDecimalMath {\\n    using SafeMath for uint;\\n\\n    /* Number of decimal places in the representations. */\\n    uint8 public constant decimals = 18;\\n    uint8 public constant highPrecisionDecimals = 27;\\n\\n    /* The number representing 1.0. */\\n    uint public constant UNIT = 10**uint(decimals);\\n\\n    /* The number representing 1.0 for higher fidelity numbers. */\\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\\n\\n    /**\\n     * @return Provides an interface to UNIT.\\n     */\\n    function unit() external pure returns (uint) {\\n        return UNIT;\\n    }\\n\\n    /**\\n     * @return Provides an interface to PRECISE_UNIT.\\n     */\\n    function preciseUnit() external pure returns (uint) {\\n        return PRECISE_UNIT;\\n    }\\n\\n    /**\\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n     * decimals.\\n     *\\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\\n     * so that product must be less than 2**256. As this is an integer division,\\n     * the internal division always rounds down. This helps save on gas. Rounding\\n     * is more expensive on gas.\\n     */\\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return x.mul(y) / UNIT;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of the specified precision unit.\\n     *\\n     * @dev The operands should be in the form of a the specified unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function _multiplyDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a precise unit.\\n     *\\n     * @dev The operands should be in the precise unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a standard unit.\\n     *\\n     * @dev The operands should be in the standard unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is a high\\n     * precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n     * this is an integer division, the result is always rounded down.\\n     * This helps save on gas. Rounding is more expensive on gas.\\n     */\\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Reintroduce the UNIT factor that will be divided out by y. */\\n        return x.mul(UNIT).div(y);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * decimal in the precision unit specified in the parameter.\\n     *\\n     * @dev y is divided after the product of x and the specified precision unit\\n     * is evaluated, so the product of x and the specified precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function _divideDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\\n\\n        if (resultTimesTen % 10 >= 5) {\\n            resultTimesTen += 10;\\n        }\\n\\n        return resultTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * standard precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and the standard precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * high precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the high precision unit\\n     * is evaluated, so the product of x and the high precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @dev Convert a standard decimal representation to a high precision one.\\n     */\\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n    }\\n\\n    /**\\n     * @dev Convert a high precision decimal to a standard decimal representation.\\n     */\\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BinaryOptionMarketManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// Inheritance\\nimport \\\"./interfaces/IBinaryOptionMarketManager.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/Owned.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/Pausable.sol\\\";\\n\\n// Libraries\\nimport \\\"synthetix-2.43.1/contracts/AddressSetLib.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/SafeDecimalMath.sol\\\";\\n\\n// Internal references\\nimport \\\"./BinaryOptionMarketFactory.sol\\\";\\nimport \\\"./BinaryOptionMarket.sol\\\";\\nimport \\\"./BinaryOption.sol\\\";\\nimport \\\"./interfaces/IBinaryOptionMarket.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/interfaces/IExchangeRates.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/interfaces/IAddressResolver.sol\\\";\\n\\ncontract BinaryOptionMarketManager is Owned, Pausable, IBinaryOptionMarketManager {\\n    /* ========== LIBRARIES ========== */\\n\\n    using SafeMath for uint;\\n    using AddressSetLib for AddressSetLib.AddressSet;\\n\\n    /* ========== TYPES ========== */\\n\\n    struct Fees {\\n        uint poolFee;\\n        uint creatorFee;\\n    }\\n\\n    struct Durations {\\n        uint maxOraclePriceAge;\\n        uint expiryDuration;\\n        uint maxTimeToMaturity;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    address public feeAddress;\\n\\n    Fees public fees;\\n    Durations public durations;\\n    uint public capitalRequirement;\\n\\n    bool public marketCreationEnabled = true;\\n    uint public totalDeposited;\\n\\n    AddressSetLib.AddressSet internal _activeMarkets;\\n    AddressSetLib.AddressSet internal _maturedMarkets;\\n\\n    BinaryOptionMarketManager internal _migratingManager;\\n\\n    IAddressResolver public resolver;\\n\\n    address public binaryOptionMarketFactory;\\n\\n    /* ---------- Address Resolver Configuration ---------- */\\n\\n    bytes32 internal constant CONTRACT_SYNTHSUSD = \\\"SynthsUSD\\\";\\n    bytes32 internal constant CONTRACT_EXRATES = \\\"ExchangeRates\\\";\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        address _owner,\\n        IAddressResolver _resolver,\\n        uint _maxOraclePriceAge,\\n        uint _expiryDuration,\\n        uint _maxTimeToMaturity,\\n        uint _creatorCapitalRequirement,\\n        uint _poolFee,\\n        uint _creatorFee,\\n        address _feeAddress\\n    ) public Owned(_owner) Pausable() {\\n        resolver = _resolver;\\n\\n        // Temporarily change the owner so that the setters don't revert.\\n        owner = msg.sender;\\n\\n        setFeeAddress(_feeAddress);\\n        setExpiryDuration(_expiryDuration);\\n        setMaxOraclePriceAge(_maxOraclePriceAge);\\n        setMaxTimeToMaturity(_maxTimeToMaturity);\\n        setCreatorCapitalRequirement(_creatorCapitalRequirement);\\n        setPoolFee(_poolFee);\\n        setCreatorFee(_creatorFee);\\n        owner = _owner;\\n    }\\n\\n    /* ========== SETTERS ========== */\\n    function setBinaryOptionsMarketFactory(address _binaryOptionMarketFactory) external onlyOwner {\\n        binaryOptionMarketFactory = _binaryOptionMarketFactory;\\n    }\\n\\n    function setFeeAddress(address _feeAddress) public onlyOwner {\\n        feeAddress = _feeAddress;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    /* ---------- Related Contracts ---------- */\\n\\n    function _sUSD() internal view returns (IERC20) {\\n        return IERC20(resolver.requireAndGetAddress(CONTRACT_SYNTHSUSD, \\\"Synth sUSD contract not found\\\"));\\n    }\\n\\n    function _exchangeRates() internal view returns (IExchangeRates) {\\n        return IExchangeRates(resolver.requireAndGetAddress(CONTRACT_EXRATES, \\\"ExchangeRates contract not found\\\"));\\n    }\\n\\n    /* ---------- Market Information ---------- */\\n\\n    function _isKnownMarket(address candidate) internal view returns (bool) {\\n        return _activeMarkets.contains(candidate) || _maturedMarkets.contains(candidate);\\n    }\\n\\n    function numActiveMarkets() external view returns (uint) {\\n        return _activeMarkets.elements.length;\\n    }\\n\\n    function activeMarkets(uint index, uint pageSize) external view returns (address[] memory) {\\n        return _activeMarkets.getPage(index, pageSize);\\n    }\\n\\n    function numMaturedMarkets() external view returns (uint) {\\n        return _maturedMarkets.elements.length;\\n    }\\n\\n    function maturedMarkets(uint index, uint pageSize) external view returns (address[] memory) {\\n        return _maturedMarkets.getPage(index, pageSize);\\n    }\\n\\n    function _isValidKey(bytes32 oracleKey) internal view returns (bool) {\\n        IExchangeRates exchangeRates = _exchangeRates();\\n\\n        // If it has a rate, then it's possibly a valid key\\n        if (exchangeRates.rateForCurrency(oracleKey) != 0) {\\n            // But not sUSD\\n            if (oracleKey == \\\"sUSD\\\") {\\n                return false;\\n            }\\n\\n            // and not inverse rates\\n            (uint entryPoint, , , , ) = exchangeRates.inversePricing(oracleKey);\\n            if (entryPoint != 0) {\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /* ---------- Setters ---------- */\\n\\n    function setMaxOraclePriceAge(uint _maxOraclePriceAge) public onlyOwner {\\n        durations.maxOraclePriceAge = _maxOraclePriceAge;\\n        emit MaxOraclePriceAgeUpdated(_maxOraclePriceAge);\\n    }\\n\\n    function setExpiryDuration(uint _expiryDuration) public onlyOwner {\\n        durations.expiryDuration = _expiryDuration;\\n        emit ExpiryDurationUpdated(_expiryDuration);\\n    }\\n\\n    function setMaxTimeToMaturity(uint _maxTimeToMaturity) public onlyOwner {\\n        durations.maxTimeToMaturity = _maxTimeToMaturity;\\n        emit MaxTimeToMaturityUpdated(_maxTimeToMaturity);\\n    }\\n\\n    function setPoolFee(uint _poolFee) public onlyOwner {\\n        uint totalFee = _poolFee + fees.creatorFee;\\n        require(totalFee < SafeDecimalMath.unit(), \\\"Total fee must be less than 100%.\\\");\\n        require(0 < totalFee, \\\"Total fee must be nonzero.\\\");\\n        fees.poolFee = _poolFee;\\n        emit PoolFeeUpdated(_poolFee);\\n    }\\n\\n    function setCreatorFee(uint _creatorFee) public onlyOwner {\\n        uint totalFee = _creatorFee + fees.poolFee;\\n        require(totalFee < SafeDecimalMath.unit(), \\\"Total fee must be less than 100%.\\\");\\n        require(0 < totalFee, \\\"Total fee must be nonzero.\\\");\\n        fees.creatorFee = _creatorFee;\\n        emit CreatorFeeUpdated(_creatorFee);\\n    }\\n\\n    function setCreatorCapitalRequirement(uint _creatorCapitalRequirement) public onlyOwner {\\n        capitalRequirement = _creatorCapitalRequirement;\\n        emit CreatorCapitalRequirementUpdated(_creatorCapitalRequirement);\\n    }\\n\\n    /* ---------- Deposit Management ---------- */\\n\\n    function incrementTotalDeposited(uint delta) external onlyActiveMarkets notPaused {\\n        totalDeposited = totalDeposited.add(delta);\\n    }\\n\\n    function decrementTotalDeposited(uint delta) external onlyKnownMarkets notPaused {\\n        // NOTE: As individual market debt is not tracked here, the underlying markets\\n        //       need to be careful never to subtract more debt than they added.\\n        //       This can't be enforced without additional state/communication overhead.\\n        totalDeposited = totalDeposited.sub(delta);\\n    }\\n\\n    /* ---------- Market Lifecycle ---------- */\\n\\n    function createMarket(\\n        bytes32 oracleKey,\\n        uint strikePrice,\\n        uint maturity,\\n        uint initialMint // initial sUSD to mint options for\\n    )\\n        external\\n        notPaused\\n        returns (\\n            IBinaryOptionMarket // no support for returning BinaryOptionMarket polymorphically given the interface\\n        )\\n    {\\n        require(marketCreationEnabled, \\\"Market creation is disabled\\\");\\n        require(_isValidKey(oracleKey), \\\"Invalid key\\\");\\n\\n        require(maturity <= block.timestamp + durations.maxTimeToMaturity, \\\"Maturity too far in the future\\\");\\n        uint expiry = maturity.add(durations.expiryDuration);\\n\\n        require(block.timestamp < maturity, \\\"Maturity has to be in the future\\\");\\n        // We also require maturity < expiry. But there is no need to check this.\\n        // Fees being in range are checked in the setters.\\n        // The market itself validates the capital and skew requirements.\\n\\n        require(capitalRequirement <= initialMint, \\\"Insufficient capital\\\");\\n\\n        BinaryOptionMarket market =\\n            BinaryOptionMarketFactory(binaryOptionMarketFactory).createMarket(\\n                msg.sender,\\n                resolver,\\n                oracleKey,\\n                strikePrice,\\n                [maturity, expiry],\\n                initialMint,\\n                [fees.poolFee, fees.creatorFee]\\n            );\\n        _activeMarkets.add(address(market));\\n\\n        // The debt can't be incremented in the new market's constructor because until construction is complete,\\n        // the manager doesn't know its address in order to grant it permission.\\n        totalDeposited = totalDeposited.add(initialMint);\\n        _sUSD().transferFrom(msg.sender, address(market), initialMint);\\n\\n        (BinaryOption long, BinaryOption short) = market.options();\\n\\n        emit MarketCreated(\\n            address(market),\\n            msg.sender,\\n            oracleKey,\\n            strikePrice,\\n            maturity,\\n            expiry,\\n            address(long),\\n            address(short)\\n        );\\n        return market;\\n    }\\n\\n    function transferSusdTo(\\n        address sender,\\n        address receiver,\\n        uint amount\\n    ) external {\\n        //only to be called by markets themselves\\n        require(_isKnownMarket(address(msg.sender)), \\\"Market unknown.\\\");\\n        _sUSD().transferFrom(sender, receiver, amount);\\n    }\\n\\n    function resolveMarket(address market) external {\\n        require(_activeMarkets.contains(market), \\\"Not an active market\\\");\\n        BinaryOptionMarket(market).resolve();\\n        _activeMarkets.remove(market);\\n        _maturedMarkets.add(market);\\n    }\\n\\n    function expireMarkets(address[] calldata markets) external notPaused onlyOwner {\\n        for (uint i = 0; i < markets.length; i++) {\\n            address market = markets[i];\\n\\n            require(_isKnownMarket(address(market)), \\\"Market unknown.\\\");\\n\\n            // The market itself handles decrementing the total deposits.\\n            BinaryOptionMarket(market).expire(msg.sender);\\n\\n            // Note that we required that the market is known, which guarantees\\n            // its index is defined and that the list of markets is not empty.\\n            _maturedMarkets.remove(market);\\n\\n            emit MarketExpired(market);\\n        }\\n    }\\n\\n    function setMarketCreationEnabled(bool enabled) public onlyOwner {\\n        if (enabled != marketCreationEnabled) {\\n            marketCreationEnabled = enabled;\\n            emit MarketCreationEnabledUpdated(enabled);\\n        }\\n    }\\n\\n    function setMigratingManager(BinaryOptionMarketManager manager) public onlyOwner {\\n        _migratingManager = manager;\\n    }\\n\\n    function migrateMarkets(\\n        BinaryOptionMarketManager receivingManager,\\n        bool active,\\n        BinaryOptionMarket[] calldata marketsToMigrate\\n    ) external onlyOwner {\\n        require(address(receivingManager) != address(this), \\\"Can't migrate to self\\\");\\n\\n        uint _numMarkets = marketsToMigrate.length;\\n        if (_numMarkets == 0) {\\n            return;\\n        }\\n        AddressSetLib.AddressSet storage markets = active ? _activeMarkets : _maturedMarkets;\\n\\n        uint runningDepositTotal;\\n        for (uint i; i < _numMarkets; i++) {\\n            BinaryOptionMarket market = marketsToMigrate[i];\\n            require(_isKnownMarket(address(market)), \\\"Market unknown.\\\");\\n\\n            // Remove it from our list and deposit total.\\n            markets.remove(address(market));\\n            runningDepositTotal = runningDepositTotal.add(market.deposited());\\n\\n            // Prepare to transfer ownership to the new manager.\\n            market.nominateNewOwner(address(receivingManager));\\n        }\\n        // Deduct the total deposits of the migrated markets.\\n        totalDeposited = totalDeposited.sub(runningDepositTotal);\\n        emit MarketsMigrated(receivingManager, marketsToMigrate);\\n\\n        // Now actually transfer the markets over to the new manager.\\n        receivingManager.receiveMarkets(active, marketsToMigrate);\\n    }\\n\\n    function receiveMarkets(bool active, BinaryOptionMarket[] calldata marketsToReceive) external {\\n        require(msg.sender == address(_migratingManager), \\\"Only permitted for migrating manager.\\\");\\n\\n        uint _numMarkets = marketsToReceive.length;\\n        if (_numMarkets == 0) {\\n            return;\\n        }\\n        AddressSetLib.AddressSet storage markets = active ? _activeMarkets : _maturedMarkets;\\n\\n        uint runningDepositTotal;\\n        for (uint i; i < _numMarkets; i++) {\\n            BinaryOptionMarket market = marketsToReceive[i];\\n            require(!_isKnownMarket(address(market)), \\\"Market already known.\\\");\\n\\n            market.acceptOwnership();\\n            markets.add(address(market));\\n            // Update the market with the new manager address,\\n            runningDepositTotal = runningDepositTotal.add(market.deposited());\\n        }\\n        totalDeposited = totalDeposited.add(runningDepositTotal);\\n        emit MarketsReceived(_migratingManager, marketsToReceive);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyActiveMarkets() {\\n        require(_activeMarkets.contains(msg.sender), \\\"Permitted only for active markets.\\\");\\n        _;\\n    }\\n\\n    modifier onlyKnownMarkets() {\\n        require(_isKnownMarket(msg.sender), \\\"Permitted only for known markets.\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event MarketCreated(\\n        address market,\\n        address indexed creator,\\n        bytes32 indexed oracleKey,\\n        uint strikePrice,\\n        uint maturityDate,\\n        uint expiryDate,\\n        address long,\\n        address short\\n    );\\n    event MarketExpired(address market);\\n    event MarketsMigrated(BinaryOptionMarketManager receivingManager, BinaryOptionMarket[] markets);\\n    event MarketsReceived(BinaryOptionMarketManager migratingManager, BinaryOptionMarket[] markets);\\n    event MarketCreationEnabledUpdated(bool enabled);\\n    event MaxOraclePriceAgeUpdated(uint duration);\\n    event ExpiryDurationUpdated(uint duration);\\n    event MaxTimeToMaturityUpdated(uint duration);\\n    event CreatorCapitalRequirementUpdated(uint value);\\n    event PoolFeeUpdated(uint fee);\\n    event CreatorFeeUpdated(uint fee);\\n}\\n\"\r\n    },\r\n    \"contracts/BinaryOption.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// Inheritance\\nimport \\\"synthetix-2.43.1/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IBinaryOption.sol\\\";\\n\\n// Libraries\\nimport \\\"synthetix-2.43.1/contracts/SafeDecimalMath.sol\\\";\\n\\n// Internal references\\nimport \\\"./BinaryOptionMarket.sol\\\";\\n\\ncontract BinaryOption is IERC20, IBinaryOption {\\n    /* ========== LIBRARIES ========== */\\n\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public constant decimals = 18;\\n\\n    BinaryOptionMarket public market;\\n\\n    mapping(address => uint) public balanceOf;\\n    uint public totalSupply;\\n\\n    // The argument order is allowance[owner][spender]\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    // Enforce a 1 cent minimum amount\\n    uint internal constant _MINIMUM_AMOUNT = 1e16;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    bool public initialized = false;\\n\\n    function initialize(\\n        string calldata _name,\\n        string calldata _symbol\\n    ) external {\\n        require(!initialized, \\\"Binary Option Market already initialized\\\");\\n        initialized = true;\\n        name = _name;\\n        symbol = _symbol;\\n        market = BinaryOptionMarket(msg.sender);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function _requireMinimumAmount(uint amount) internal pure returns (uint) {\\n        require(amount >= _MINIMUM_AMOUNT || amount == 0, \\\"Balance < $0.01\\\");\\n        return amount;\\n    }\\n\\n    function mint(address minter, uint amount) external onlyMarket {\\n        _requireMinimumAmount(amount);\\n        totalSupply = totalSupply.add(amount);\\n        balanceOf[minter] = balanceOf[minter].add(amount); // Increment rather than assigning since a transfer may have occurred.\\n\\n        emit Transfer(address(0), minter, amount);\\n        emit Issued(minter, amount);\\n    }\\n\\n    // This must only be invoked after maturity.\\n    function exercise(address claimant) external onlyMarket {\\n        uint balance = balanceOf[claimant];\\n\\n        if (balance == 0) {\\n            return;\\n        }\\n\\n        balanceOf[claimant] = 0;\\n        totalSupply = totalSupply.sub(balance);\\n\\n        emit Transfer(claimant, address(0), balance);\\n        emit Burned(claimant, balance);\\n    }\\n\\n    // This must only be invoked after the exercise window is complete.\\n    // Note that any options which have not been exercised will linger.\\n    function expire(address payable beneficiary) external onlyMarket {\\n        selfdestruct(beneficiary);\\n    }\\n\\n    /* ---------- ERC20 Functions ---------- */\\n\\n    function _transfer(\\n        address _from,\\n        address _to,\\n        uint _value\\n    ) internal returns (bool success) {\\n        market.requireUnpaused();\\n        require(_to != address(0) && _to != address(this), \\\"Invalid address\\\");\\n\\n        uint fromBalance = balanceOf[_from];\\n        require(_value <= fromBalance, \\\"Insufficient balance\\\");\\n\\n        balanceOf[_from] = fromBalance.sub(_value);\\n        balanceOf[_to] = balanceOf[_to].add(_value);\\n\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    function transfer(address _to, uint _value) external returns (bool success) {\\n        return _transfer(msg.sender, _to, _value);\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint _value\\n    ) external returns (bool success) {\\n        uint fromAllowance = allowance[_from][msg.sender];\\n        require(_value <= fromAllowance, \\\"Insufficient allowance\\\");\\n\\n        allowance[_from][msg.sender] = fromAllowance.sub(_value);\\n        return _transfer(_from, _to, _value);\\n    }\\n\\n    function approve(address _spender, uint _value) external returns (bool success) {\\n        require(_spender != address(0));\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyMarket() {\\n        require(msg.sender == address(market), \\\"Only market allowed\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Issued(address indexed account, uint value);\\n    event Burned(address indexed account, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\"\r\n    },\r\n    \"synthetix-2.43.1/contracts/interfaces/IExchangeRates.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\\ninterface IExchangeRates {\\n    // Structs\\n    struct RateAndUpdatedTime {\\n        uint216 rate;\\n        uint40 time;\\n    }\\n\\n    struct InversePricing {\\n        uint entryPoint;\\n        uint upperLimit;\\n        uint lowerLimit;\\n        bool frozenAtUpperLimit;\\n        bool frozenAtLowerLimit;\\n    }\\n\\n    // Views\\n    function aggregators(bytes32 currencyKey) external view returns (address);\\n\\n    function aggregatorWarningFlags() external view returns (address);\\n\\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\\n\\n    function canFreezeRate(bytes32 currencyKey) external view returns (bool);\\n\\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\\n\\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\\n\\n    function effectiveValue(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external view returns (uint value);\\n\\n    function effectiveValueAndRates(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    )\\n        external\\n        view\\n        returns (\\n            uint value,\\n            uint sourceRate,\\n            uint destinationRate\\n        );\\n\\n    function effectiveValueAtRound(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        uint roundIdForSrc,\\n        uint roundIdForDest\\n    ) external view returns (uint value);\\n\\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\\n\\n    function getLastRoundIdBeforeElapsedSecs(\\n        bytes32 currencyKey,\\n        uint startingRoundId,\\n        uint startingTimestamp,\\n        uint timediff\\n    ) external view returns (uint);\\n\\n    function inversePricing(bytes32 currencyKey)\\n        external\\n        view\\n        returns (\\n            uint entryPoint,\\n            uint upperLimit,\\n            uint lowerLimit,\\n            bool frozenAtUpperLimit,\\n            bool frozenAtLowerLimit\\n        );\\n\\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\\n\\n    function oracle() external view returns (address);\\n\\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\\n\\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\\n\\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\\n\\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\\n\\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\\n\\n    function rateStalePeriod() external view returns (uint);\\n\\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\\n        external\\n        view\\n        returns (uint[] memory rates, uint[] memory times);\\n\\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\\n        external\\n        view\\n        returns (uint[] memory rates, bool anyRateInvalid);\\n\\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\\n\\n    // Mutative functions\\n    function freezeRate(bytes32 currencyKey) external;\\n}\\n\"\r\n    },\r\n    \"synthetix-2.43.1/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\\ninterface IERC20 {\\n    // ERC20 Optional Views\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    // Views\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    // Mutative functions\\n    function transfer(address to, uint value) external returns (bool);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    // Events\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\"\r\n    },\r\n    \"synthetix-2.43.1/contracts/interfaces/IAddressResolver.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\\ninterface IAddressResolver {\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getSynth(bytes32 key) external view returns (address);\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBinaryOptionMarketManager.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\nimport \\\"../interfaces/IBinaryOptionMarket.sol\\\";\\n\\ninterface IBinaryOptionMarketManager {\\n    /* ========== VIEWS / VARIABLES ========== */\\n\\n    function fees() external view returns (uint poolFee, uint creatorFee);\\n\\n    function durations()\\n        external\\n        view\\n        returns (\\n            uint maxOraclePriceAge,\\n            uint expiryDuration,\\n            uint maxTimeToMaturity\\n        );\\n\\n    function capitalRequirement() external view returns (uint);\\n\\n    function marketCreationEnabled() external view returns (bool);\\n\\n    function totalDeposited() external view returns (uint);\\n\\n    function numActiveMarkets() external view returns (uint);\\n\\n    function activeMarkets(uint index, uint pageSize) external view returns (address[] memory);\\n\\n    function numMaturedMarkets() external view returns (uint);\\n\\n    function maturedMarkets(uint index, uint pageSize) external view returns (address[] memory);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function createMarket(\\n        bytes32 oracleKey,\\n        uint strikePrice,\\n        uint maturity,\\n        uint initialMint // initial sUSD to mint options for\\n    ) external returns (IBinaryOptionMarket);\\n\\n    function resolveMarket(address market) external;\\n\\n    function expireMarkets(address[] calldata market) external;\\n\\n    function transferSusdTo(address sender, address receiver, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBinaryOption.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24;\\n\\nimport \\\"../interfaces/IBinaryOptionMarket.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/interfaces/IERC20.sol\\\";\\n\\ninterface IBinaryOption {\\n    /* ========== VIEWS / VARIABLES ========== */\\n\\n    function market() external view returns (IBinaryOptionMarket);\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function totalSupply() external view returns (uint);\\n\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity-2.3.0/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"synthetix-2.43.1/contracts/Owned.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// https://docs.synthetix.io/contracts/source/contracts/owned\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor(address _owner) public {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\"\r\n    },\r\n    \"synthetix-2.43.1/contracts/Pausable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// Inheritance\\nimport \\\"./Owned.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/source/contracts/pausable\\ncontract Pausable is Owned {\\n    uint public lastPauseTime;\\n    bool public paused;\\n\\n    constructor() internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\\n    }\\n\\n    /**\\n     * @notice Change the paused state of the contract\\n     * @dev Only the contract owner may call this.\\n     */\\n    function setPaused(bool _paused) external onlyOwner {\\n        // Ensure we're actually changing the state before we do anything\\n        if (_paused == paused) {\\n            return;\\n        }\\n\\n        // Set our paused state.\\n        paused = _paused;\\n\\n        // If applicable, set the last pause time.\\n        if (paused) {\\n            lastPauseTime = now;\\n        }\\n\\n        // Let everyone know that our pause state has changed.\\n        emit PauseChanged(paused);\\n    }\\n\\n    event PauseChanged(bool isPaused);\\n\\n    modifier notPaused {\\n        require(!paused, \\\"This action cannot be performed while the contract is paused\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"synthetix-2.43.1/contracts/AddressSetLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// https://docs.synthetix.io/contracts/source/libraries/addresssetlib/\\nlibrary AddressSetLib {\\n    struct AddressSet {\\n        address[] elements;\\n        mapping(address => uint) indices;\\n    }\\n\\n    function contains(AddressSet storage set, address candidate) internal view returns (bool) {\\n        if (set.elements.length == 0) {\\n            return false;\\n        }\\n        uint index = set.indices[candidate];\\n        return index != 0 || set.elements[0] == candidate;\\n    }\\n\\n    function getPage(\\n        AddressSet storage set,\\n        uint index,\\n        uint pageSize\\n    ) internal view returns (address[] memory) {\\n        // NOTE: This implementation should be converted to slice operators if the compiler is updated to v0.6.0+\\n        uint endIndex = index + pageSize; // The check below that endIndex <= index handles overflow.\\n\\n        // If the page extends past the end of the list, truncate it.\\n        if (endIndex > set.elements.length) {\\n            endIndex = set.elements.length;\\n        }\\n        if (endIndex <= index) {\\n            return new address[](0);\\n        }\\n\\n        uint n = endIndex - index; // We already checked for negative overflow.\\n        address[] memory page = new address[](n);\\n        for (uint i; i < n; i++) {\\n            page[i] = set.elements[i + index];\\n        }\\n        return page;\\n    }\\n\\n    function add(AddressSet storage set, address element) internal {\\n        // Adding to a set is an idempotent operation.\\n        if (!contains(set, element)) {\\n            set.indices[element] = set.elements.length;\\n            set.elements.push(element);\\n        }\\n    }\\n\\n    function remove(AddressSet storage set, address element) internal {\\n        require(contains(set, element), \\\"Element not in set.\\\");\\n        // Replace the removed element with the last element of the list.\\n        uint index = set.indices[element];\\n        uint lastIndex = set.elements.length - 1; // We required that element is in the list, so it is not empty.\\n        if (index != lastIndex) {\\n            // No need to shift the last element if it is the one we want to delete.\\n            address shiftedElement = set.elements[lastIndex];\\n            set.elements[index] = shiftedElement;\\n            set.indices[shiftedElement] = index;\\n        }\\n        set.elements.pop();\\n        delete set.indices[element];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BinaryOptionMarketFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// Inheritance\\nimport \\\"synthetix-2.43.1/contracts/MinimalProxyFactory.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/Owned.sol\\\";\\n\\n// Internal references\\nimport \\\"./BinaryOptionMarket.sol\\\";\\nimport \\\"synthetix-2.43.1/contracts/interfaces/IAddressResolver.sol\\\";\\n\\ncontract BinaryOptionMarketFactory is MinimalProxyFactory, Owned {\\n    /* ========== STATE VARIABLES ========== */\\n    address public binaryOptionMarketManager;\\n    address public binaryOptionMarketMastercopy;\\n    address public binaryOptionMastercopy;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(address _owner) public MinimalProxyFactory() Owned(_owner) {}\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function createMarket(\\n        address creator,\\n        IAddressResolver _resolver,\\n        bytes32 oracleKey,\\n        uint strikePrice,\\n        uint[2] calldata times, // [maturity, expiry]\\n        uint initialMint,\\n        uint[2] calldata fees // [poolFee, creatorFee]\\n    ) external returns (BinaryOptionMarket) {\\n        require(binaryOptionMarketManager == msg.sender, \\\"Only permitted by the manager.\\\");\\n\\n        BinaryOptionMarket bom =\\n            BinaryOptionMarket(\\n                _cloneAsMinimalProxy(binaryOptionMarketMastercopy, \\\"Could not create a Binary Option Market\\\")\\n            );\\n        bom.initialize(\\n            binaryOptionMarketManager,\\n            binaryOptionMastercopy,\\n            _resolver,\\n            creator,\\n            oracleKey,\\n            strikePrice,\\n            times,\\n            initialMint,\\n            fees\\n        );\\n        return bom;\\n    }\\n\\n    /* ========== SETTERS ========== */\\n    function setBinaryOptionMarketManager(address _binaryOptionMarketManager) external onlyOwner {\\n        binaryOptionMarketManager = _binaryOptionMarketManager;\\n        emit BinaryOptionMarketManagerChanged(_binaryOptionMarketManager);\\n    }\\n\\n    function setBinaryOptionMarketMastercopy(address _binaryOptionMarketMastercopy) external onlyOwner {\\n        binaryOptionMarketMastercopy = _binaryOptionMarketMastercopy;\\n        emit BinaryOptionMarketMastercopyChanged(_binaryOptionMarketMastercopy);\\n    }\\n\\n    function setBinaryOptionMastercopy(address _binaryOptionMastercopy) external onlyOwner {\\n        binaryOptionMastercopy = _binaryOptionMastercopy;\\n        emit BinaryOptionMastercopyChanged(_binaryOptionMastercopy);\\n    }\\n\\n    event BinaryOptionMarketManagerChanged(address _binaryOptionMarketManager);\\n    event BinaryOptionMarketMastercopyChanged(address _binaryOptionMarketMastercopy);\\n    event BinaryOptionMastercopyChanged(address _binaryOptionMastercopy);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"synthetix-2.43.1/contracts/SafeDecimalMath.sol\": {\r\n        \"SafeDecimalMath\": \"0x84d626b2bb4d0f064067e4bf80fce7055d8f3e7b\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum IBinaryOptionMarket.Side\",\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oracleTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorFees\",\"type\":\"uint256\"}],\"name\":\"MarketResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum IBinaryOptionMarket.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OptionsExercised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accumulatedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balancesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"long\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"short\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canResolve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exerciseOptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"expire\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creatorFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_binaryOptionMastercopy\",\"type\":\"address\"},{\"internalType\":\"contract IAddressResolver\",\"name\":\"_resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_oracleKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"_times\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"_deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"_fees\",\"type\":\"uint256[2]\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"options\",\"outputs\":[{\"internalType\":\"contract BinaryOption\",\"name\":\"long\",\"type\":\"address\"},{\"internalType\":\"contract BinaryOption\",\"name\":\"short\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracleDetails\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclePriceAndTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"internalType\":\"enum IBinaryOptionMarket.Phase\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requireUnpaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resolve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract IAddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"result\",\"outputs\":[{\"internalType\":\"enum IBinaryOptionMarket.Side\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"times\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"long\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"short\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BinaryOptionMarketMastercopy","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}