{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/collateralSplits/x5Split.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./CollateralSplitParent.sol\\\";\\n\\ncontract x5Split is CollateralSplitParent {\\n    function symbol() external pure override returns (string memory) {\\n        return \\\"x5\\\";\\n    }\\n\\n    function splitNominalValue(int256 _normalizedValue)\\n        public\\n        pure\\n        override\\n        returns (int256)\\n    {\\n        if (_normalizedValue <= -(FRACTION_MULTIPLIER / 5)) {\\n            return 0;\\n        } else if (\\n            _normalizedValue > -(FRACTION_MULTIPLIER / 5) &&\\n            _normalizedValue < FRACTION_MULTIPLIER / 5\\n        ) {\\n            return (FRACTION_MULTIPLIER + _normalizedValue * 5) / 2;\\n        } else {\\n            return FRACTION_MULTIPLIER;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/collateralSplits/CollateralSplitParent.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"./ICollateralSplit.sol\\\";\\nimport \\\"../oracleIterators/IOracleIterator.sol\\\";\\n\\nabstract contract CollateralSplitParent is ICollateralSplit {\\n    using SignedSafeMath for int256;\\n\\n    int256 public constant FRACTION_MULTIPLIER = 10**12;\\n    int256 public constant NEGATIVE_INFINITY = type(int256).min;\\n\\n    function isCollateralSplit() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    function split(\\n        address[] calldata _oracles,\\n        address[] calldata _oracleIterators,\\n        int256[] calldata _underlyingStarts,\\n        uint256 _settleTime,\\n        uint256[] calldata _underlyingEndRoundHints\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (uint256 _split, int256[] memory _underlyingEnds)\\n    {\\n        require(_oracles.length == 1, \\\"More than one oracle\\\");\\n        require(_oracles[0] != address(0), \\\"Oracle is empty\\\");\\n        require(_oracleIterators[0] != address(0), \\\"Oracle iterator is empty\\\");\\n\\n        _underlyingEnds = new int256[](1);\\n\\n        IOracleIterator iterator = IOracleIterator(_oracleIterators[0]);\\n        require(iterator.isOracleIterator(), \\\"Not oracle iterator\\\");\\n\\n        _underlyingEnds[0] = iterator.getUnderlyingValue(\\n            _oracles[0],\\n            _settleTime,\\n            _underlyingEndRoundHints\\n        );\\n\\n        _split = range(\\n            splitNominalValue(\\n                normalize(_underlyingStarts[0], _underlyingEnds[0])\\n            )\\n        );\\n    }\\n\\n    function splitNominalValue(int256 _normalizedValue)\\n        public\\n        pure\\n        virtual\\n        returns (int256);\\n\\n    function normalize(int256 _u_0, int256 _u_T)\\n        public\\n        pure\\n        virtual\\n        returns (int256)\\n    {\\n        require(_u_0 != NEGATIVE_INFINITY, \\\"u_0 is absent\\\");\\n        require(_u_T != NEGATIVE_INFINITY, \\\"u_T is absent\\\");\\n        require(_u_0 > 0, \\\"u_0 is less or equal zero\\\");\\n\\n        if (_u_T < 0) {\\n            _u_T = 0;\\n        }\\n\\n        return _u_T.sub(_u_0).mul(FRACTION_MULTIPLIER).div(_u_0);\\n    }\\n\\n    function range(int256 _split) public pure returns (uint256) {\\n        if (_split >= FRACTION_MULTIPLIER) {\\n            return uint256(FRACTION_MULTIPLIER);\\n        }\\n        if (_split <= 0) {\\n            return 0;\\n        }\\n        return uint256(_split);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/collateralSplits/ICollateralSplit.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\n/// @title Collateral Split interface\\n/// @notice Contains mathematical functions used to calculate relative claim\\n/// on collateral of primary and complement assets after settlement.\\n/// @dev Created independently from specification and published to the CollateralSplitRegistry\\ninterface ICollateralSplit {\\n    /// @notice Proof of collateral split contract\\n    /// @dev Verifies that contract is a collateral split contract\\n    /// @return true if contract is a collateral split contract\\n    function isCollateralSplit() external pure returns (bool);\\n\\n    /// @notice Symbol of the collateral split\\n    /// @dev Should be resolved through CollateralSplitRegistry contract\\n    /// @return collateral split specification symbol\\n    function symbol() external pure returns (string memory);\\n\\n    /// @notice Calcs primary asset class' share of collateral at settlement.\\n    /// @dev Returns ranged value between 0 and 1 multiplied by 10 ^ 12\\n    /// @param _underlyingStarts underlying values in the start of Live period\\n    /// @param _underlyingEndRoundHints specify for each oracle round of the end of Live period\\n    /// @return _split primary asset class' share of collateral at settlement\\n    /// @return _underlyingEnds underlying values in the end of Live period\\n    function split(\\n        address[] calldata _oracles,\\n        address[] calldata _oracleIterators,\\n        int256[] calldata _underlyingStarts,\\n        uint256 _settleTime,\\n        uint256[] calldata _underlyingEndRoundHints\\n    ) external view returns (uint256 _split, int256[] memory _underlyingEnds);\\n}\\n\"\r\n    },\r\n    \"contracts/oracleIterators/IOracleIterator.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IOracleIterator {\\n    /// @notice Proof of oracle iterator contract\\n    /// @dev Verifies that contract is a oracle iterator contract\\n    /// @return true if contract is a oracle iterator contract\\n    function isOracleIterator() external pure returns (bool);\\n\\n    /// @notice Symbol of the oracle iterator\\n    /// @dev Should be resolved through OracleIteratorRegistry contract\\n    /// @return oracle iterator symbol\\n    function symbol() external pure returns (string memory);\\n\\n    /// @notice Algorithm that, for the type of oracle used by the derivative,\\n    //  finds the value closest to a given timestamp\\n    /// @param _oracle iteratable oracle through\\n    /// @param _timestamp a given timestamp\\n    /// @param _roundHints specified rounds for a given timestamp\\n    /// @return the value closest to a given timestamp\\n    function getUnderlyingValue(\\n        address _oracle,\\n        uint256 _timestamp,\\n        uint256[] calldata _roundHints\\n    ) external view returns (int256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"FRACTION_MULTIPLIER\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NEGATIVE_INFINITY\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCollateralSplit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_u_0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_u_T\",\"type\":\"int256\"}],\"name\":\"normalize\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_split\",\"type\":\"int256\"}],\"name\":\"range\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_oracles\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_oracleIterators\",\"type\":\"address[]\"},{\"internalType\":\"int256[]\",\"name\":\"_underlyingStarts\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"_settleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_underlyingEndRoundHints\",\"type\":\"uint256[]\"}],\"name\":\"split\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_split\",\"type\":\"uint256\"},{\"internalType\":\"int256[]\",\"name\":\"_underlyingEnds\",\"type\":\"int256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_normalizedValue\",\"type\":\"int256\"}],\"name\":\"splitNominalValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"x5Split","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}