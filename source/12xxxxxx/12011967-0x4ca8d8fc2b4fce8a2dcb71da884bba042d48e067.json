{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lp-oracle-contracts/aggregators/BalancerSharedPoolPriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/BPool.sol\\\";\\nimport \\\"../interfaces/IExtendedAggregator.sol\\\";\\nimport \\\"../interfaces/IPriceOracle.sol\\\";\\nimport \\\"../misc/BNum.sol\\\";\\n\\n/** @title BalancerSharedPoolPriceProvider\\n * @notice Price provider for a balancer pool token\\n * It calculates the price using Chainlink as an external price source and the pool's tokens balances using the weighted arithmetic mean formula.\\n * If there is a price deviation, instead of the balances, it uses a weighted geometric mean with the token's weights and constant value function V.\\n */\\n\\ncontract BalancerSharedPoolPriceProvider is BNum, IExtendedAggregator {\\n    BPool public pool;\\n    address[] public tokens;\\n    uint256[] public weights;\\n    bool[] public isPeggedToEth;\\n    uint8[] public decimals;\\n    IPriceOracle public priceOracle;\\n    uint256 public immutable maxPriceDeviation;\\n    uint256 internal immutable K;\\n    uint256 internal immutable powerPrecision;\\n    uint256[][] internal approximationMatrix;\\n\\n    /**\\n     * BalancerSharedPoolPriceProvider constructor.\\n     * @param _pool Balancer pool address.\\n     * @param _isPeggedToEth For each token, true if it is pegged to ETH (token order determined by pool.getFinalTokens()).\\n     * @param _decimals Number of decimals for each token (token order determined by pool.getFinalTokens()).\\n     * @param _priceOracle Aave price oracle.\\n     * @param _maxPriceDeviation Threshold of spot prices deviation: 10ˆ16 represents a 1% deviation.\\n     * @param _K //Constant K = 1 / (w1ˆw1 * .. * wn^wn)\\n     * @param _powerPrecision //Precision for power math function.\\n     * @param _approximationMatrix //Approximation matrix for gas optimization.\\n     */\\n    constructor(\\n        BPool _pool,\\n        bool[] memory _isPeggedToEth,\\n        uint8[] memory _decimals,\\n        IPriceOracle _priceOracle,\\n        uint256 _maxPriceDeviation,\\n        uint256 _K,\\n        uint256 _powerPrecision,\\n        uint256[][] memory _approximationMatrix\\n    ) public {\\n        pool = _pool;\\n        //Get token list\\n        tokens = pool.getFinalTokens(); //This already checks for pool finalized\\n        uint256 length = tokens.length;\\n        //Validate contructor params\\n        require(length >= 2 && length <= 3, \\\"ERR_INVALID_POOL_TOKENS_NUMBER\\\");\\n        require(_isPeggedToEth.length == length, \\\"ERR_INVALID_PEGGED_LENGTH\\\");\\n        require(_decimals.length == length, \\\"ERR_INVALID_DECIMALS_LENGTH\\\");\\n        for (uint8 i = 0; i < length; i++) {\\n            require(_decimals[i] <= 18, \\\"ERR_INVALID_DECIMALS\\\");\\n        }\\n        require(\\n            _approximationMatrix.length == 0 ||\\n                _approximationMatrix[0].length == length + 1,\\n            \\\"ERR_INVALID_APPROX_MATRIX\\\"\\n        );\\n        require(_maxPriceDeviation < BONE, \\\"ERR_INVALID_PRICE_DEVIATION\\\");\\n        require(\\n            _powerPrecision >= 1 && _powerPrecision <= BONE,\\n            \\\"ERR_INVALID_POWER_PRECISION\\\"\\n        );\\n        require(\\n            address(_priceOracle) != address(0),\\n            \\\"ERR_INVALID_PRICE_PROVIDER\\\"\\n        );\\n        //Get token normalized weights\\n        for (uint8 i = 0; i < length; i++) {\\n            weights.push(pool.getNormalizedWeight(tokens[i]));\\n        }\\n        isPeggedToEth = _isPeggedToEth;\\n        decimals = _decimals;\\n        priceOracle = _priceOracle;\\n        maxPriceDeviation = _maxPriceDeviation;\\n        K = _K;\\n        powerPrecision = _powerPrecision;\\n        approximationMatrix = _approximationMatrix;\\n    }\\n\\n    /**\\n     * Returns the token balance in ethers by multiplying its balance with its price in ethers.\\n     * @param index Token index.\\n     */\\n    function getEthBalanceByToken(uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 pi =\\n            isPeggedToEth[index]\\n                ? BONE\\n                : uint256(priceOracle.getAssetPrice(tokens[index]));\\n        require(pi > 0, \\\"ERR_NO_ORACLE_PRICE\\\");\\n        uint256 missingDecimals = 18 - decimals[index];\\n        uint256 bi =\\n            bmul(pool.getBalance(tokens[index]), BONE * 10**(missingDecimals));\\n        return bmul(bi, pi);\\n    }\\n\\n    /**\\n     * Using the matrix approximation, returns a near base and exponentiation result, for num ^ weights[index]\\n     * @param index Token index.\\n     * @param num Base to approximate.\\n     */\\n    function getClosestBaseAndExponetation(uint256 index, uint256 num)\\n        internal\\n        view\\n        returns (uint256, uint256)\\n    {\\n        uint256 length = approximationMatrix.length;\\n        uint256 k = index + 1;\\n        for (uint8 i = 0; i < length; i++) {\\n            if (approximationMatrix[i][0] >= num) {\\n                return (approximationMatrix[i][0], approximationMatrix[i][k]);\\n            }\\n        }\\n        return (0, 0);\\n    }\\n\\n    /**\\n     * Returns true if there is a price deviation.\\n     * @param ethTotals Balance of each token in ethers.\\n     */\\n    function hasDeviation(uint256[] memory ethTotals)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        //Check for a price deviation\\n        uint256 length = tokens.length;\\n        for (uint8 i = 0; i < length; i++) {\\n            for (uint8 o = 0; o < length; o++) {\\n                if (i != o) {\\n                    uint256 price_deviation =\\n                        bdiv(\\n                            bdiv(ethTotals[i], weights[i]),\\n                            bdiv(ethTotals[o], weights[o])\\n                        );\\n                    if (\\n                        price_deviation > (BONE + maxPriceDeviation) ||\\n                        price_deviation < (BONE - maxPriceDeviation)\\n                    ) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Calculates the price of the pool token using the formula of weighted arithmetic mean.\\n     * @param ethTotals Balance of each token in ethers.\\n     */\\n    function getArithmeticMean(uint256[] memory ethTotals)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 totalEth = 0;\\n        uint256 length = tokens.length;\\n        for (uint8 i = 0; i < length; i++) {\\n            totalEth = badd(totalEth, ethTotals[i]);\\n        }\\n        return bdiv(totalEth, pool.totalSupply());\\n    }\\n\\n    /**\\n     * Returns the weighted token balance in ethers by calculating the balance in ether of the token to the power of its weight.\\n     * @param index Token index.\\n     */\\n    function getWeightedEthBalanceByToken(uint256 index, uint256 ethTotal)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 weight = weights[index];\\n        (uint256 base, uint256 result) =\\n            getClosestBaseAndExponetation(index, ethTotal);\\n        if (base == 0 || ethTotal < MAX_BPOW_BASE) {\\n            if (ethTotal < MAX_BPOW_BASE) {\\n                return bpowApprox(ethTotal, weight, powerPrecision);\\n            } else {\\n                return\\n                    bmul(\\n                        ethTotal,\\n                        bpowApprox(\\n                            bdiv(BONE, ethTotal),\\n                            (BONE - weight),\\n                            powerPrecision\\n                        )\\n                    );\\n            }\\n        } else {\\n            return\\n                bmul(\\n                    result,\\n                    bpowApprox(bdiv(ethTotal, base), weight, powerPrecision)\\n                );\\n        }\\n    }\\n\\n    /**\\n     * Calculates the price of the pool token using the formula of weighted geometric mean.\\n     * @param ethTotals Balance of each token in ethers.\\n     */\\n    function getWeightedGeometricMean(uint256[] memory ethTotals)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 mult = BONE;\\n        uint256 length = tokens.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            mult = bmul(mult, getWeightedEthBalanceByToken(i, ethTotals[i]));\\n        }\\n        return bdiv(bmul(mult, K), pool.totalSupply());\\n    }\\n\\n    /**\\n     * Returns Balancer pool address.\\n     */\\n    function getPool() external view returns (BPool) {\\n        return pool;\\n    }\\n\\n    /**\\n     * Returns all tokens's weights.\\n     */\\n    function getWeights() external view returns (uint256[] memory) {\\n        return weights;\\n    }\\n\\n    /**\\n     * @dev Returns token type for categorization\\n     * @return uint256 1 = Simple (Native or plain ERC20 tokens like DAI), 2 = Complex (LP Tokens, Staked tokens)\\n     */\\n    function getTokenType()\\n        external\\n        pure\\n        override\\n        returns (IExtendedAggregator.TokenType)\\n    {\\n        return IExtendedAggregator.TokenType.Complex;\\n    }\\n\\n    /**\\n     * @dev Returns the number of tokens that composes the LP shares\\n     * @return address[] memory of token addresses\\n     */\\n    function getSubTokens() external view override returns (address[] memory) {\\n        return tokens;\\n    }\\n\\n    /**\\n     * @dev Returns the LP shares token\\n     * @return address of the LP shares token\\n     */\\n    function getToken() external view override returns (address) {\\n        return address(pool);\\n    }\\n\\n    /**\\n     * @dev Returns the platform id to categorize the price aggregator\\n     * @return uint256 1 = Uniswap, 2 = Balancer\\n     */\\n    function getPlatformId()\\n        external\\n        pure\\n        override\\n        returns (IExtendedAggregator.PlatformId)\\n    {\\n        return IExtendedAggregator.PlatformId.Balancer;\\n    }\\n\\n    /**\\n     * @dev Returns the pool's token price.\\n     *   It calculates the price using Chainlink as an external price source and the pool's tokens balances using the weighted arithmetic mean formula.\\n     *   If there is a price deviation, instead of the balances, it uses a weighted geometric mean with the token's weights and constant value function V.\\n     * @return int256 price\\n     */\\n    function latestAnswer() external view override returns (int256) {\\n        //Get token balances in ethers\\n        uint256[] memory ethTotals = new uint256[](tokens.length);\\n        uint256 length = tokens.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            ethTotals[i] = getEthBalanceByToken(i);\\n        }\\n\\n        if (hasDeviation(ethTotals)) {\\n            //Calculate the weighted geometric mean\\n            return int256(getWeightedGeometricMean(ethTotals));\\n        } else {\\n            //Calculate the weighted arithmetic mean\\n            return int256(getArithmeticMean(ethTotals));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/interfaces/BPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\ninterface BPool {\\n  function getFinalTokens() external view returns (address[] memory tokens);\\n\\n  function getNormalizedWeight(address token) external view returns (uint256);\\n\\n  function getBalance(address token) external view returns (uint256);\\n\\n  function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/interfaces/IExtendedAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity ^0.6.12;\\n\\ninterface IExtendedAggregator {\\n    enum TokenType {Invalid, Simple, Complex}\\n\\n    enum PlatformId {Invalid, Simple, Uniswap, Balancer}\\n\\n    /**\\n     * @dev Returns the LP shares token\\n     * @return address of the LP shares token\\n     */\\n    function getToken() external view returns (address);\\n\\n    /**\\n     * @dev Returns token type for categorization\\n     * @return uint256 1 = Simple (Native or plain ERC20 tokens like DAI), 2 = Complex (LP Tokens, Staked tokens)\\n     */\\n    function getTokenType() external pure returns (TokenType);\\n\\n    /**\\n     * @dev Returns the number of tokens that composes the LP shares\\n     * @return address[] memory of token addresses\\n     */\\n    function getSubTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Returns the platform id to categorize the price aggregator\\n     * @return uint256 1 = Uniswap, 2 = Balancer\\n     */\\n    function getPlatformId() external pure returns (PlatformId);\\n\\n    /**\\n     * @dev Returns the latest price\\n     * @return int256 price\\n     */\\n    function latestAnswer() external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/************\\n@title IPriceOracle interface\\n@notice Interface for the Aave price oracle.*/\\ninterface IPriceOracle {\\n  /***********\\n    @dev returns the asset price in ETH\\n     */\\n  function getAssetPrice(address _asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/misc/BNum.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// From https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.6.12;\\n\\nimport './BConst.sol';\\n\\ncontract BNum is BConst {\\n  function btoi(uint256 a) internal pure returns (uint256) {\\n    return a / BONE;\\n  }\\n\\n  function bfloor(uint256 a) internal pure returns (uint256) {\\n    return btoi(a) * BONE;\\n  }\\n\\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'ERR_ADD_OVERFLOW');\\n    return c;\\n  }\\n\\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    (uint256 c, bool flag) = bsubSign(a, b);\\n    require(!flag, 'ERR_SUB_UNDERFLOW');\\n    return c;\\n  }\\n\\n  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\\n    if (a >= b) {\\n      return (a - b, false);\\n    } else {\\n      return (b - a, true);\\n    }\\n  }\\n\\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c0 = a * b;\\n    require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\\n    uint256 c1 = c0 + (BONE / 2);\\n    require(c1 >= c0, 'ERR_MUL_OVERFLOW');\\n    uint256 c2 = c1 / BONE;\\n    return c2;\\n  }\\n\\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'ERR_DIV_ZERO');\\n    uint256 c0 = a * BONE;\\n    require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\\n    uint256 c1 = c0 + (b / 2);\\n    require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\\n    uint256 c2 = c1 / b;\\n    return c2;\\n  }\\n\\n  // DSMath.wpow\\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\\n    uint256 z = n % 2 != 0 ? a : BONE;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n      a = bmul(a, a);\\n\\n      if (n % 2 != 0) {\\n        z = bmul(z, a);\\n      }\\n    }\\n    return z;\\n  }\\n\\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n  // of approximation of b^0.w\\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\\n    require(base >= MIN_BPOW_BASE, 'ERR_BPOW_BASE_TOO_LOW');\\n    require(base <= MAX_BPOW_BASE, 'ERR_BPOW_BASE_TOO_HIGH');\\n\\n    uint256 whole = bfloor(exp);\\n    uint256 remain = bsub(exp, whole);\\n\\n    uint256 wholePow = bpowi(base, btoi(whole));\\n\\n    if (remain == 0) {\\n      return wholePow;\\n    }\\n\\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n    return bmul(wholePow, partialResult);\\n  }\\n\\n  function bpowApprox(\\n    uint256 base,\\n    uint256 exp,\\n    uint256 precision\\n  ) internal pure returns (uint256) {\\n    // term 0:\\n    uint256 a = exp;\\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\\n    uint256 term = BONE;\\n    uint256 sum = term;\\n    bool negative = false;\\n\\n    // term(k) = numer / denom\\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\\n    // continue until term is less than precision\\n    for (uint256 i = 1; term >= precision; i++) {\\n      uint256 bigK = i * BONE;\\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n      term = bmul(term, bmul(c, x));\\n      term = bdiv(term, bigK);\\n      if (term == 0) break;\\n\\n      if (xneg) negative = !negative;\\n      if (cneg) negative = !negative;\\n      if (negative) {\\n        sum = bsub(sum, term);\\n      } else {\\n        sum = badd(sum, term);\\n      }\\n    }\\n\\n    return sum;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lp-oracle-contracts/misc/BConst.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// From // From https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\ncontract BConst {\\n  uint256 public constant BONE = 10**18;\\n\\n  uint256 public constant MIN_BOUND_TOKENS = 2;\\n  uint256 public constant MAX_BOUND_TOKENS = 8;\\n\\n  uint256 public constant MIN_FEE = BONE / 10**6;\\n  uint256 public constant MAX_FEE = BONE / 10;\\n  uint256 public constant EXIT_FEE = 0;\\n\\n  uint256 public constant MIN_WEIGHT = BONE;\\n  uint256 public constant MAX_WEIGHT = BONE * 50;\\n  uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\\n  uint256 public constant MIN_BALANCE = BONE / 10**12;\\n\\n  uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\\n\\n  uint256 public constant MIN_BPOW_BASE = 1 wei;\\n  uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\\n  uint256 public constant BPOW_PRECISION = BONE / 10**10;\\n\\n  uint256 public constant MAX_IN_RATIO = BONE / 2;\\n  uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract BPool\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"_isPeggedToEth\",\"type\":\"bool[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_decimals\",\"type\":\"uint8[]\"},{\"internalType\":\"contract IPriceOracle\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxPriceDeviation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_powerPrecision\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"_approximationMatrix\",\"type\":\"uint256[][]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformId\",\"outputs\":[{\"internalType\":\"enum IExtendedAggregator.PlatformId\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"contract BPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSubTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenType\",\"outputs\":[{\"internalType\":\"enum IExtendedAggregator.TokenType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeights\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isPeggedToEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPriceDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract BPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"contract IPriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"weights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BalancerSharedPoolPriceProvider","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001eff8af5d577060ba4ac8a29a13525bb0ee2a3d500000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000160000000000000000000000000a50ba011c48153de246e5192c8f9258a2ba79ca900000000000000000000000000000000000000000000000000b1a2bc2ec500000000000000000000000000000000000000000000000000001bc16d674ec800000000000000000000000000000000000000000000000000000000000005f5e10000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000048000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000580000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000006800000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000078000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000880000000000000000000000000000000000000000000000000000000000000090000000000000000000000000000000000000000000000000000000000000009800000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a800000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000b800000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000002be2aac7077d5bc40000000000000000000000000000000000000000000000002be2aac7077d5bc400000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000008ac7230489e80000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000003635c9adc5dea00000000000000000000000000000000000000000000000000001b6daabc64ae595a8000000000000000000000000000000000000000000000001b6daabc64ae595a8000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000021e19e0c9bab24000000000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000056bc75e2d63100000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000152d02c7e14af6800000000000000000000000000000000000000000000000000011248ab5beecf7d890000000000000000000000000000000000000000000000011248ab5beecf7d890000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000084595161401484a0000000000000000000000000000000000000000000000000000ab6d6b197541ae75a00000000000000000000000000000000000000000000000ab6d6b197541ae75a0000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000052b7d2dcc80cd2e400000000000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000033b2e3c9fd0803ce80000000000000000000000000000000000000000000000000006b2462efe9490d098400000000000000000000000000000000000000000000006b2462efe9490d0984000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000204fce5e3e2502611000000000000000000000000000000000000000000000000000152d02c7e14af680000000000000000000000000000000000000000000000000152d02c7e14af680000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000001431e0fae6d7217caa00000000000000000000000000000000000000000000000000042f6bdd5f1cda825f2800000000000000000000000000000000000000000000042f6bdd5f1cda825f2800000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000c9f2c9cd04674edea4000000000000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000000000000000000000000d3c21bcecceda10000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000007e37be2022c0914b2680000000000000000000000000000000000000000000000000029da36a5b7208917b7900000000000000000000000000000000000000000000029da36a5b7208917b7900000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000004ee2d6d415b85acef8100000000000000000000000000000000000000000000000000084595161401484a000000000000000000000000000000000000000000000000084595161401484a0000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000314dc6448d9338c15b0a000000000000000000000000000000000000000000000000001a286227927455aed2ba000000000000000000000000000000000000000000001a286227927455aed2ba000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000001ed09bead87c0378d8e640000000000000000000000000000000000000000000000000052b7d2dcc80cd2e400000000000000000000000000000000000000000000000052b7d2dcc80cd2e40000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000013426172c74d822b878fe8000000000000000000000000000000000000000000000000010593d58bb88b58d43b44000000000000000000000000000000000000000000010593d58bb88b58d43b440000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000c097ce7bc90715b34b9f10000000000000000000000000000000000000000000000000033b2e3c9fd0803ce80000000000000000000000000000000000000000000000033b2e3c9fd0803ce80000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000785ee10d5da46d900f436a00000000000000000000000000000000000000000000000000a37c657753571784a50a80000000000000000000000000000000000000000000a37c657753571784a50a8000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000004b3b4ca85a86c47a098a2240000000000000000000000000000000000000000000000000204fce5e3e250261100000000000000000000000000000000000000000000000204fce5e3e25026110000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}