{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.6;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"Dino.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Roles.sol\\\";\\nimport \\\"./ProjectToken_interface.sol\\\";\\nimport \\\"./TetherToken_interface.sol\\\";\\n\\n\\ncontract AdminRole is Context, Ownable {\\n    using Roles for Roles.Role;\\n    using SafeMath for uint256;\\n\\n    event AdminAdded(address indexed account);\\n    event AdminRemoved(address indexed account);\\n\\n    uint256 private _qty_admins = 0;\\n    Roles.Role private _admins;\\n    address[] private _signatures;\\n\\n    modifier onlyAdmin() {\\n        require(isAdmin(_msgSender()), \\\"AdminRole: caller does not have the Admin role\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwnerOrAdmin() {\\n      require(isAdminOrOwner(_msgSender()), \\\"Can call only owner or admin\\\");\\n      _;\\n    }\\n\\n    function isAdminOrOwner(address account) public view returns (bool) {\\n        return isAdmin(account) || isOwner();\\n    }\\n\\n    function isAdmin(address account) public view returns (bool) {\\n        return _admins.has(account);\\n    }\\n\\n    function _addAdmin(address account) internal {\\n\\n        require(!isAdmin(account) \\u0026\\u0026 account != owner(), \\\"already exist\\\");\\n\\n        _admins.add(account);\\n        _qty_admins = _qty_admins.add(1);\\n        emit AdminAdded(account);\\n    }\\n\\n    function addSignature4NextOperation() public onlyOwnerOrAdmin {\\n      bool exist = false;\\n      for(uint256 i=0; i\\u003c_signatures.length; i++){\\n        if(_signatures[i] == _msgSender()){\\n          exist = true;\\n          break;\\n        }\\n      }\\n      require(!exist, \\\"already exist\\\");\\n      _signatures.push(_msgSender());\\n    }\\n\\n    function cancelSignature4NextOperation() public onlyOwnerOrAdmin {\\n      for(uint256 i=0; i\\u003c_signatures.length; i++){\\n        if(_signatures[i] == _msgSender()){\\n          _remove_signatures(i);\\n          return;\\n        }\\n      }\\n      require(false, \\\"not found\\\");\\n\\n    }\\n\\n    function checkValidMultiSignatures() public view returns(bool){\\n      uint256 all_signatures = _qty_admins.add(1); // 1 for owner\\n      if(all_signatures \\u003c= 2){\\n        return all_signatures == _signatures.length;\\n      }\\n      uint256 approved_signatures = all_signatures.mul(2).div(3);\\n      return _signatures.length \\u003e= approved_signatures;\\n    }\\n\\n    function cancelAllMultiSignatures() public onlyOwnerOrAdmin{\\n      uint256 l = _signatures.length;\\n      for(uint256 i=0; i\\u003cl; i++){\\n        _signatures.pop();\\n      }\\n    }\\n\\n    function checkExistSignature(address account) public view returns(bool){\\n      bool exist = false;\\n      for(uint256 i=0; i\\u003c_signatures.length; i++){\\n        if(_signatures[i] == account){\\n          exist = true;\\n          break;\\n        }\\n      }\\n      return exist;\\n    }\\n\\n    function m_signaturesTransferOwnership(address newOwner) public onlyOwnerOrAdmin {\\n      require(isOwner() || checkValidMultiSignatures(), \\\"There is no required number of signatures\\\");\\n      transferOwnership(newOwner);\\n      cancelAllMultiSignatures();\\n    }\\n\\n    function _remove_signatures(uint index) private {\\n      if (index \\u003e= _signatures.length) return;\\n      for (uint i = index; i\\u003c_signatures.length-1; i++){\\n        _signatures[i] = _signatures[i+1];\\n      }\\n      _signatures.pop();\\n    }\\n\\n}\\n\\n// https://solidity-by-example.org/signature/\\n\\ncontract VerifySignature{\\n\\n    function getMessageHash(address holder, uint _maxvalue) public pure returns (bytes32){\\n        return keccak256(abi.encodePacked(holder, _maxvalue));\\n    }\\n\\n    function getSignedMessageHash(bytes32 _messageHash) public pure returns (bytes32) {\\n        /*\\n        Signature is produced by signing a keccak256 hash with the following format:\\n        \\\"\\\\x19Ethereum Signed Message\\\\n\\\" + len(msg) + msg\\n        */\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _messageHash));\\n    }\\n\\n    function verify(address _signer, address holder, uint _maxvalue, bytes memory signature) public pure returns (bool) {\\n        bytes32 messageHash = getMessageHash(holder, _maxvalue);\\n        bytes32 signedMessageHash = getSignedMessageHash(messageHash);\\n        return recoverSigner(signedMessageHash, signature) == _signer;\\n    }\\n\\n    function recoverSigner(bytes32 _signedMessageHash, bytes memory _signature) public pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n        return ecrecover(_signedMessageHash, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory sig) public pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\n        assembly {\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n    }\\n}\\n\\n\\ncontract ProjectName is AdminRole, VerifySignature{\\n  using SafeMath for uint256;\\n\\n  event TokensaleInfo(address indexed signer, uint256 coinsvalue, uint256 tokensvalue, uint256 holder_max_project_tokens, uint256 allowed_coinsvalue, uint256 allowed_tokensvalue);\\n\\n  // sales status id\\n  uint8 private _tokensale_status;\\n\\n  address public currency_token_address;\\n  TetherToken_interface private _currency_token;\\n\\n  address public project_token_address;\\n  ProjectToken_interface private _project_token;\\n\\n  uint256 private _token_price;\\n\\n  address private _signer_address;\\n\\n  mapping(address =\\u003e uint256) private _sold_amounts;\\n  uint256 private _totalsold = 0;\\n  address[] private _participants;\\n\\n  constructor () public {\\n\\n    // set the sales status id as: \\\"disabled\\n    _tokensale_status = 2;\\n\\n    //set the sale price for 1 token\\n    _token_price = 1000000000000000000; //1 USDT * (10**18) = 1000000000000000000 wei, where 18 is decimal of USDT\\n\\n    // set the address that stores Tokens and signs data from the white list\\n    _signer_address = address(0xEe3EA17E0Ed56a794e9bAE6F7A6c6b43b93333F5);\\n\\n    // set the address of a currency smart contract\\n    // e.g. Token Tether (USDT) address is 0xdAC17F958D2ee523a2206206994597C13D831ec7\\n    currency_token_address = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\\n    _currency_token = TetherToken_interface(currency_token_address);\\n\\n    // set the address of the smart contract of the project token\\n    project_token_address = address(0x7426d1A249672749945b6F217086D9F18E0df481);\\n    _project_token = ProjectToken_interface(project_token_address);\\n\\n    // set administrators\\n    _addAdmin(address(0x92C3b65677700eD595DA15A402f5d7C9A10a4e49));\\n    _addAdmin(address(0x1489a398BeB2171D48C458CfbA9Cf1Bd739C0438));\\n    _addAdmin(address(0xd0cF831E3a2E171220094C066Ec4263d24c0C715));\\n\\n    // transfer ownership from a deployer to 0x0000000000000000000000000000000000000000\\n    transferOwnership(address(0));\\n  }\\n\\n  // returns the current sales status\\n  function saleStatus() public view returns(string memory){\\n    if(_tokensale_status == 0){\\n      return \\\"Closed\\\";\\n    }else if(_tokensale_status == 1){\\n      return \\\"Active\\\";\\n    }else if(_tokensale_status == 2){\\n      return \\\"Disabled\\\";\\n    }\\n    return \\\"Unknown\\\"; //impossible\\n  }\\n\\n  // blocking the reception of a standard coin of network\\n  receive() external payable {\\n    require(false, \\\"The contract does not accept the base coin of network.\\\");\\n  }\\n\\n  // this method allows admin of the smart contract to withdraw tokens\\n  // from smart contract. This can be done before or after stopTokensale()\\n  function tokenWithdrawal(address token_address, address recipient, uint256 value) public onlyOwnerOrAdmin {\\n    require(checkValidMultiSignatures(), \\\"There is no required number of signatures\\\");\\n\\n    TetherToken_interface ct = TetherToken_interface(token_address);\\n\\n    /////\\n    ///// Tether Token does not return bool when calling transfer\\n    /////\\n    // // withdraw USDT from the customer\\n    // require(ct.transfer(recipient, value), \\\"USDT withdrawal error\\\");\\n    /////\\n    ///// without call require\\n    /////\\n    ct.transfer(recipient, value);\\n\\n    cancelAllMultiSignatures();\\n  }\\n\\n  // this method allows admin of the smart contract to withdraw USDT\\n  // from smart contract. This can be done before or after stopTokensale()\\n  function USDTWithdrawal(address recipient, uint256 value) public onlyOwnerOrAdmin {\\n    tokenWithdrawal(currency_token_address, recipient, value);\\n  }\\n\\n  // get price of 1 token in USDT\\n  function getTokenPrice() public view returns(uint256){\\n    return _token_price;\\n  }\\n\\n  // Total tokens sold to specified address.\\n  function totalTokensSoldByAddress(address holder) public view returns(uint256){\\n    return _sold_amounts[holder];\\n  }\\n\\n  // The amount of tokens sold so far.\\n  function totalTokensSold() public view returns (uint256) {\\n      return _totalsold;\\n  }\\n\\n  // get the participant address by her index starting from 0.\\n  function getParticipantAddressByIndex(uint256 index) public view returns(address){\\n    return _participants[index];\\n  }\\n\\n  // Get the number of participants that have purchased more than 0 tokens.\\n  function getNumberOfParticipants() public view returns(uint256){\\n    return _participants.length;\\n  }\\n\\n\\n  function setWhitelistAuthorityAddress(address signer) public onlyOwnerOrAdmin {\\n      // Set a different address of whitelist authority. This address will be used to sign \\\"Purchase Certificates\\\".\\n      // Purchase certificates are items of the white list indicatoing that the client has the right\\n      // to buy stated amount of tokens.\\n    require(checkValidMultiSignatures(), \\\"There is no required number of signatures\\\");\\n\\n    require(_tokensale_status \\u003e 0, \\\"Sales closed\\\");\\n\\n    _signer_address = signer;\\n\\n    cancelAllMultiSignatures();\\n  }\\n\\n\\n  //function get_holder_available_token_value(address _holder, uint256 _maxProjectTokens, bytes memory _signedData) public view returns (uint256) {\\n  function getRemainingBalance(address holder, uint256 holder_max_project_tokens, bytes memory signature) public view returns (uint256) {\\n    // The remaining amount of tokens msg.sender has the right to purchase. This takes into account the\\n    // previously purchased tokens.\\n    require(verify(_signer_address, holder, holder_max_project_tokens, signature), \\\"Incoming data have incorrectly signed\\\");\\n    uint256 c = totalTokensSoldByAddress(holder);\\n    return holder_max_project_tokens.sub(c);\\n  }\\n\\n  // function is_holder_available_token_value(address _holder, uint256 _needed_project_token_value, uint256 _maxProjectTokens, bytes memory _signedData) public view returns (bool){\\n  function checkEligibility(address holder, uint256 require_token_value, uint256 holder_max_project_tokens, bytes memory signature) public view returns (bool){\\n    // Check if msg.sender is eligible to buy the stated amount of tokens.\\n    uint256 v = getRemainingBalance(holder, holder_max_project_tokens, signature);\\n    if(v == 0 || require_token_value == 0){ return false; }\\n    return v \\u003e= require_token_value;\\n  }\\n\\n  // function burn_allowanced_value(uint256 _projectTokens, uint256 _maxProjectTokens, bytes memory _signedData) public{\\n  // the main method of the smart contract that allows to purchase the project tokens\\n  // for USDT.\\n  function tokenPurchase(uint256 require_token_value, uint256 holder_max_project_tokens, bytes memory signature) public{\\n\\n    // check that sales are open\\n    require(_tokensale_status==1, \\\"Sales are not allowed\\\");\\n    require(require_token_value \\u003e 0, \\\"The requested amount of tokens for purchase must be greater than 0 (zero)\\\");\\n\\n    address sender = _msgSender();\\n\\n    // check the permitted limits for purchase tokens for the customer\\n    require(checkEligibility(sender, require_token_value, holder_max_project_tokens, signature), \\\"Customer limited by max value\\\");\\n\\n    // calculate the price for the specified purchase tokens value\\n    uint256 topay_value = require_token_value.mul(_token_price).div(10**_currency_token.decimals());\\n\\n    // check customer USDT balance\\n    uint256 c_value = _currency_token.balanceOf(sender);\\n    require(c_value \\u003e= topay_value, \\\"The customer does not have enough USDT balance\\\");\\n\\n    // check allowed USDT value for transfer from the customer\\n    c_value = _currency_token.allowance(sender, address(this));\\n    require(c_value \\u003e= topay_value, \\\"Smart contact is not entitled to such an USDT amount\\\");\\n\\n    // check the balance of project tokens for sale\\n    uint256 p_value = _project_token.balanceOf(_signer_address);\\n    require(p_value \\u003e= require_token_value, \\\"The holder does not have enough project token balance\\\");\\n\\n    // check allowed project tokens value for transfer to the customer\\n    p_value = _project_token.allowance(_signer_address, address(this));\\n    require(p_value \\u003e= require_token_value, \\\"Smart contact is not entitled to such a project token amount\\\");\\n\\n    // write information about purchase to events\\n    emit TokensaleInfo(_signer_address, topay_value, require_token_value, holder_max_project_tokens, c_value, p_value);\\n\\n    /*\\n    //\\n    // Warning:\\n       USDT transferFrom has not return the result bool value\\n       and has not perform the necessary checks.\\n       !!! Do not remove all of the above checks, as this may damage the smart contract.!!!\\n    //\\n    */\\n\\n    /////\\n    ///// Tether Token does not return bool when calling transferFrom\\n    /////\\n    // // withdraw USDT from the customer\\n    // require(_currency_token.transferFrom(sender, address(this), topay_value), \\\"USDT withdrawal error\\\");\\n    // // transfer project tokens to the customer\\n    // require(_project_token.transferFrom(_signer_address, sender, require_token_value), \\\"Project Token transfer error\\\");\\n    /////\\n    ///// without call require\\n    /////\\n    // withdraw USDT from the customer\\n    _currency_token.transferFrom(sender, address(this), topay_value);\\n    // transfer project tokens to the customer\\n    _project_token.transferFrom(_signer_address, sender, require_token_value);\\n    /////\\n    /////\\n\\n    // add the customer\\u0027s address to the list of participants\\n    if(_sold_amounts[sender] == 0){\\n      _participants.push(sender);\\n    }\\n\\n    // calculate the total amount of purchased tokens by the customer\\n    _sold_amounts[sender] = _sold_amounts[sender].add(require_token_value);\\n    // calculate the total amount of purchased tokens by smart contact\\n    _totalsold = _totalsold.add(require_token_value);\\n  }\\n\\n  // Stops the sales. After this method is called, no further purchases may take place.\\n  // This can be reverted. If there are unsold tokens, they can to sell later.\\n  function stopSales() public onlyOwnerOrAdmin{\\n\\n    require(checkValidMultiSignatures(), \\\"There is no required number of signatures\\\");\\n\\n    require(_tokensale_status \\u003e 0, \\\"Sales is close\\\");\\n\\n    _tokensale_status = 2;\\n\\n    cancelAllMultiSignatures();\\n  }\\n\\n  // Start the sales. After this method is called, smart contract will opened selles.\\n  // This can be reverted.\\n  function startSales() public onlyOwnerOrAdmin{\\n\\n    require(checkValidMultiSignatures(), \\\"There is no required number of signatures\\\");\\n\\n    require(_tokensale_status \\u003e 0, \\\"Sales is close\\\");\\n\\n    _tokensale_status = 1;\\n\\n    cancelAllMultiSignatures();\\n  }\\n\\n\\n  // Close the sales. After this method is called, no further purchases may take place.\\n  // This can not be reverted. If there are unsold tokens they will remain with the\\n  // original holder of the tokens that issued allowence for this contract to\\n  // sell them.\\n  function stopTokensale() public onlyOwnerOrAdmin{\\n    require(checkValidMultiSignatures(), \\\"There is no required number of signatures\\\");\\n\\n    // reset the address of the signature and the holder of the tokens for sale\\n    _signer_address = address(0);\\n\\n    // set the sales status index to \\\"Closed\\\"\\n    _tokensale_status = 0;\\n\\n    cancelAllMultiSignatures();\\n  }\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.6;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        // require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"ProjectToken_interface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\nabstract contract ProjectToken_interface {\\n    function name() public view virtual returns (string memory);\\n    function symbol() public view virtual returns (string memory);\\n    function decimals() public view virtual returns (uint8);\\n\\n    function owner() public view virtual returns (address);\\n    function balanceOf(address who) public view virtual returns (uint256);\\n    \\n    function transfer(address _to, uint256 _value) public virtual returns (bool);\\n    function allowance(address _owner, address _spender) public virtual returns (uint);\\n    function transferFrom(address _from, address _to, uint _value) public virtual returns (bool);\\n    \\n    // Tether format\\n    // function transfer(address _to, uint256 _value) public virtual;\\n    // function transferFrom(address _from, address _to, uint _value) public virtual;\\n}\\n\"},\"Roles.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address =\\u003e bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account\\u0027s access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"TetherToken_interface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.6;\\n\\nabstract contract TetherToken_interface {\\n    function name() public view virtual returns (string memory);\\n    function symbol() public view virtual returns (string memory);\\n    function decimals() public view virtual returns (uint8);\\n\\n    function owner() public view virtual returns (address);\\n    function balanceOf(address who) public view virtual returns (uint256);\\n    \\n    // function transfer(address _to, uint256 _value) public virtual returns (bool);\\n    function allowance(address _owner, address _spender) public virtual returns (uint);\\n    // function transferFrom(address _from, address _to, uint _value) public virtual returns (bool);\\n    \\n    // Tether format\\n    function transfer(address _to, uint256 _value) public virtual;\\n    function transferFrom(address _from, address _to, uint _value) public virtual;\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coinsvalue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensvalue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"holder_max_project_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allowed_coinsvalue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allowed_tokensvalue\",\"type\":\"uint256\"}],\"name\":\"TokensaleInfo\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"USDTWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addSignature4NextOperation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelAllMultiSignatures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelSignature4NextOperation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"require_token_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"holder_max_project_tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"checkEligibility\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"checkExistSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkValidMultiSignatures\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currency_token_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxvalue\",\"type\":\"uint256\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfParticipants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getParticipantAddressByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"holder_max_project_tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"getRemainingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"}],\"name\":\"getSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAdminOrOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"m_signaturesTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"project_token_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_signedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"setWhitelistAuthorityAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSales\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopSales\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopTokensale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"require_token_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"holder_max_project_tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"tokenPurchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"tokenWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"totalTokensSoldByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxvalue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ProjectName","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6dbfa8e525812b33cfa405744be2cc82c50335412c73525fc90fffc13bdab55e"}]}