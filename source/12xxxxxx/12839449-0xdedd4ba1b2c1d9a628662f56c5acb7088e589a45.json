{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/options/lib/HeaderRLP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n// This library extracts data from Block header encoded in RLP format.\\n// It is not a complete implementation, but optimized for specific cases - thus many hardcoded values.\\n// Here's the current RLP structure and the values we're looking for:\\n//\\n// idx  Element                 element length with 1 byte storing its length\\n// ==========================================================================\\n// Static elements (always same size):\\n//\\n// 0    RLP length              1+2\\n// 1    parentHash              1+32\\n// 2    ommersHash              1+32\\n// 3    beneficiary             1+20\\n// 4    stateRoot               1+32\\n// 5    TransactionRoot         1+32\\n// 6    receiptsRoot            1+32\\n//      logsBloom length        1+2\\n// 7    logsBloom               256\\n//                              =========\\n//  Total static elements size: 448 bytes\\n//\\n// Dynamic elements (need to read length) start at position 448\\n// and each one is preceeded with 1 byte length (if element is >= 128)\\n// or if element is < 128 - then length byte is skipped and it is just the 1-byte element:\\n//\\n// 8\\tdifficulty  - starts at pos 448\\n// 9\\tnumber      - blockNumber\\n// 10\\tgasLimit\\n// 11\\tgasUsed\\n// 12\\ttimestamp\\n// 13\\textraData\\n// 14\\tmixHash\\n// 15\\tnonce\\n\\n// SAFEMATH DISCLAIMER:\\n// We and don't use SafeMath here intentionally, because input values are bytes in a byte-array, thus limited to 255\\nlibrary HeaderRLP {\\n    function checkBlockHash(bytes calldata rlp) external view returns (uint256) {\\n        uint256 rlpBlockNumber = getBlockNumber(rlp);\\n\\n        require(\\n            blockhash(rlpBlockNumber) == keccak256(rlp), // blockhash() costs 20 now but it may cost 5000 in the future\\n            \\\"HeaderRLP.checkBlockHash: Block hashes don't match\\\"\\n        );\\n        return rlpBlockNumber;\\n    }\\n\\n    function nextElementJump(uint8 prefix) public pure returns (uint8) {\\n        // RLP has much more options for element lenghts\\n        // But we are safe between 56 bytes and 2MB\\n        if (prefix <= 128) {\\n            return 1;\\n        } else if (prefix <= 183) {\\n            return prefix - 128 + 1;\\n        }\\n        revert(\\\"HeaderRLP.nextElementJump: Given element length not implemented\\\");\\n    }\\n\\n    // no loop saves ~300 gas\\n    function getBlockNumberPositionNoLoop(bytes memory rlp) public pure returns (uint256) {\\n        uint256 pos;\\n        //jumpting straight to the 1st dynamic element at pos 448 - difficulty\\n        pos = 448;\\n        //2nd element - block number\\n        pos += nextElementJump(uint8(rlp[pos]));\\n\\n        return pos;\\n    }\\n\\n    // no loop saves ~300 gas\\n    function getGasLimitPositionNoLoop(bytes memory rlp) public pure returns (uint256) {\\n        uint256 pos;\\n        //jumpting straight to the 1st dynamic element at pos 448 - difficulty\\n        pos = 448;\\n        //2nd element - block number\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        //3rd element - gas limit\\n        pos += nextElementJump(uint8(rlp[pos]));\\n\\n        return pos;\\n    }\\n\\n    // no loop saves ~300 gas\\n    function getTimestampPositionNoLoop(bytes memory rlp) public pure returns (uint256) {\\n        uint256 pos;\\n        //jumpting straight to the 1st dynamic element at pos 448 - difficulty\\n        pos = 448;\\n        //2nd element - block number\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        //3rd element - gas limit\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        //4th element - gas used\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        //timestamp - jackpot!\\n        pos += nextElementJump(uint8(rlp[pos]));\\n\\n        return pos;\\n    }\\n\\n    function getBaseFeePositionNoLoop(bytes memory rlp) public pure returns (uint256) {\\n        //jumping straight to the 1st dynamic element at pos 448 - difficulty\\n        uint256 pos = 448;\\n\\n        // 2nd element - block number\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        // 3rd element - gas limit\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        // 4th element - gas used\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        // timestamp\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        // extradata\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        // mixhash\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        // nonce\\n        pos += nextElementJump(uint8(rlp[pos]));\\n        // nonce\\n        pos += nextElementJump(uint8(rlp[pos]));\\n\\n        return pos;\\n    }\\n\\n    function extractFromRLP(bytes calldata rlp, uint256 elementPosition) public pure returns (uint256 element) {\\n        // RLP hint: If the byte is less than 128 - than this byte IS the value needed - just return it.\\n        if (uint8(rlp[elementPosition]) < 128) {\\n            return uint256(uint8(rlp[elementPosition]));\\n        }\\n\\n        // RLP hint: Otherwise - this byte stores the length of the element needed (in bytes).\\n        uint8 elementSize = uint8(rlp[elementPosition]) - 128;\\n\\n        // ABI Encoding hint for dynamic bytes element:\\n        //  0x00-0x04 (4 bytes): Function signature\\n        //  0x05-0x23 (32 bytes uint): Offset to raw data of RLP[]\\n        //  0x24-0x43 (32 bytes uint): Length of RLP's raw data (in bytes)\\n        //  0x44-.... The RLP raw data starts here\\n        //  0x44 + elementPosition: 1 byte stores a length of our element\\n        //  0x44 + elementPosition + 1: Raw data of the element\\n\\n        // Copies the element from calldata to uint256 stored in memory\\n        assembly {\\n            calldatacopy(\\n                add(mload(0x40), sub(32, elementSize)), // Copy to: Memory 0x40 (free memory pointer) + 32bytes (uint256 size) - length of our element (in bytes)\\n                add(0x44, add(elementPosition, 1)), // Copy from: Calldata 0x44 (RLP raw data offset) + elementPosition + 1 byte for the size of element\\n                elementSize\\n            )\\n            element := mload(mload(0x40)) // Load the 32 bytes (uint256) stored at memory 0x40 pointer - into return value\\n        }\\n        return element;\\n    }\\n\\n    function getBlockNumber(bytes calldata rlp) public pure returns (uint256 bn) {\\n        return extractFromRLP(rlp, getBlockNumberPositionNoLoop(rlp));\\n    }\\n\\n    function getTimestamp(bytes calldata rlp) external pure returns (uint256 ts) {\\n        return extractFromRLP(rlp, getTimestampPositionNoLoop(rlp));\\n    }\\n\\n    function getDifficulty(bytes calldata rlp) external pure returns (uint256 diff) {\\n        return extractFromRLP(rlp, 448);\\n    }\\n\\n    function getGasLimit(bytes calldata rlp) external pure returns (uint256 gasLimit) {\\n        return extractFromRLP(rlp, getGasLimitPositionNoLoop(rlp));\\n    }\\n\\n    function getBaseFee(bytes calldata rlp) external pure returns (uint256 baseFee) {\\n        return extractFromRLP(rlp, getBaseFeePositionNoLoop(rlp));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"}],\"name\":\"checkBlockHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"elementPosition\",\"type\":\"uint256\"}],\"name\":\"extractFromRLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"element\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"}],\"name\":\"getBaseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"}],\"name\":\"getBaseFeePositionNoLoop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"}],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"}],\"name\":\"getBlockNumberPositionNoLoop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"}],\"name\":\"getDifficulty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"diff\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"}],\"name\":\"getGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"}],\"name\":\"getGasLimitPositionNoLoop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rlp\",\"type\":\"bytes\"}],\"name\":\"getTimestampPositionNoLoop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"prefix\",\"type\":\"uint8\"}],\"name\":\"nextElementJump\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"HeaderRLP","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}