{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/contracts/core/Manager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {ISynthereumFinder} from './interfaces/IFinder.sol';\\nimport {ISynthereumManager} from './interfaces/IManager.sol';\\nimport {IDerivative} from '../derivative/common/interfaces/IDerivative.sol';\\nimport {IRole} from '../base/interfaces/IRole.sol';\\nimport {SynthereumInterfaces} from './Constants.sol';\\nimport {\\n  AccessControl\\n} from '../../@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract SynthereumManager is ISynthereumManager, AccessControl {\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  //Describe role structure\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n  }\\n\\n  //----------------------------------------\\n  // State variables\\n  //----------------------------------------\\n\\n  ISynthereumFinder public synthereumFinder;\\n\\n  //----------------------------------------\\n  // Modifiers\\n  //----------------------------------------\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyMaintainerOrDeployer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender) ||\\n        synthereumFinder.getImplementationAddress(\\n          SynthereumInterfaces.Deployer\\n        ) ==\\n        msg.sender,\\n      'Sender must be the maintainer or the deployer'\\n    );\\n    _;\\n  }\\n\\n  //----------------------------------------\\n  // Constructor\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Constructs the SynthereumManager contract\\n   * @param _synthereumFinder Synthereum finder contract\\n   * @param _roles Admin and Mainteiner roles\\n   */\\n  constructor(ISynthereumFinder _synthereumFinder, Roles memory _roles) public {\\n    synthereumFinder = _synthereumFinder;\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, _roles.admin);\\n    _setupRole(MAINTAINER_ROLE, _roles.maintainer);\\n  }\\n\\n  //----------------------------------------\\n  // External functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Allow to add roles in derivatives and synthetic tokens contracts\\n   * @param contracts Derivatives or Synthetic role contracts\\n   * @param roles Roles id\\n   * @param accounts Addresses to which give the grant\\n   */\\n  function grantSynthereumRole(\\n    address[] calldata contracts,\\n    bytes32[] calldata roles,\\n    address[] calldata accounts\\n  ) external override onlyMaintainerOrDeployer {\\n    uint256 rolesCount = roles.length;\\n    require(rolesCount > 0, 'No roles paased');\\n    require(\\n      rolesCount == accounts.length,\\n      'Number of roles and accounts must be the same'\\n    );\\n    require(\\n      rolesCount == contracts.length,\\n      'Number of roles and contracts must be the same'\\n    );\\n    for (uint256 i; i < rolesCount; i++) {\\n      IRole(contracts[i]).grantRole(roles[i], accounts[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allow to revoke roles in derivatives and synthetic tokens contracts\\n   * @param contracts Derivatives or Synthetic role contracts\\n   * @param roles Roles id\\n   * @param accounts Addresses to which revoke the grant\\n   */\\n  function revokeSynthereumRole(\\n    address[] calldata contracts,\\n    bytes32[] calldata roles,\\n    address[] calldata accounts\\n  ) external override onlyMaintainerOrDeployer {\\n    uint256 rolesCount = roles.length;\\n    require(rolesCount > 0, 'No roles paased');\\n    require(\\n      rolesCount == accounts.length,\\n      'Number of roles and accounts must be the same'\\n    );\\n    require(\\n      rolesCount == contracts.length,\\n      'Number of roles and contracts must be the same'\\n    );\\n    for (uint256 i; i < rolesCount; i++) {\\n      IRole(contracts[i]).revokeRole(roles[i], accounts[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allow to renounce roles in derivatives and synthetic tokens contracts\\n   * @param contracts Derivatives or Synthetic role contracts\\n   * @param roles Roles id\\n   */\\n  function renounceSynthereumRole(\\n    address[] calldata contracts,\\n    bytes32[] calldata roles\\n  ) external override onlyMaintainerOrDeployer {\\n    uint256 rolesCount = roles.length;\\n    require(rolesCount > 0, 'No roles paased');\\n    require(\\n      rolesCount == contracts.length,\\n      'Number of roles and contracts must be the same'\\n    );\\n    for (uint256 i; i < rolesCount; i++) {\\n      IRole(contracts[i]).renounceRole(roles[i], address(this));\\n    }\\n  }\\n\\n  /**\\n   * @notice Allow to call emergency shutdown in derivative contracts\\n   * @param derivatives Derivate contracts to shutdown\\n   */\\n  function emergencyShutdown(IDerivative[] calldata derivatives)\\n    external\\n    override\\n    onlyMaintainer\\n  {\\n    require(derivatives.length > 0, 'No Derivative passed');\\n    for (uint256 i; i < derivatives.length; i++) {\\n      derivatives[i].emergencyShutdown();\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/core/interfaces/IFinder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\ninterface ISynthereumFinder {\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/core/interfaces/IManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {IDerivative} from '../../derivative/common/interfaces/IDerivative.sol';\\n\\ninterface ISynthereumManager {\\n  /**\\n   * @notice Allow to add roles in derivatives and synthetic tokens contracts\\n   * @param contracts Derivatives or Synthetic role contracts\\n   * @param roles Roles id\\n   * @param accounts Addresses to which give the grant\\n   */\\n  function grantSynthereumRole(\\n    address[] calldata contracts,\\n    bytes32[] calldata roles,\\n    address[] calldata accounts\\n  ) external;\\n\\n  /**\\n   * @notice Allow to revoke roles in derivatives and synthetic tokens contracts\\n   * @param contracts Derivatives or Synthetic role contracts\\n   * @param roles Roles id\\n   * @param accounts Addresses to which revoke the grant\\n   */\\n  function revokeSynthereumRole(\\n    address[] calldata contracts,\\n    bytes32[] calldata roles,\\n    address[] calldata accounts\\n  ) external;\\n\\n  /**\\n   * @notice Allow to renounce roles in derivatives and synthetic tokens contracts\\n   * @param contracts Derivatives or Synthetic role contracts\\n   * @param roles Roles id\\n   */\\n  function renounceSynthereumRole(\\n    address[] calldata contracts,\\n    bytes32[] calldata roles\\n  ) external;\\n\\n  /**\\n   * @notice Allow to call emergency shutdown in derivative contracts\\n   * @param derivatives Derivate contracts to shutdown\\n   */\\n  function emergencyShutdown(IDerivative[] calldata derivatives) external;\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/derivative/common/interfaces/IDerivative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IDerivativeDeployment} from './IDerivativeDeployment.sol';\\nimport {\\n  FinderInterface\\n} from '../../../../@jarvis-network/uma-core/contracts/oracle/interfaces/FinderInterface.sol';\\nimport {\\n  FixedPoint\\n} from '../../../../@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol';\\n\\ninterface IDerivative is IDerivativeDeployment {\\n  struct FeePayerData {\\n    IERC20 collateralCurrency;\\n    FinderInterface finder;\\n    uint256 lastPaymentTime;\\n    FixedPoint.Unsigned cumulativeFeeMultiplier;\\n  }\\n\\n  struct PositionManagerData {\\n    IERC20 tokenCurrency;\\n    bytes32 priceIdentifier;\\n    uint256 withdrawalLiveness;\\n    FixedPoint.Unsigned minSponsorTokens;\\n    FixedPoint.Unsigned emergencyShutdownPrice;\\n    uint256 emergencyShutdownTimestamp;\\n    address excessTokenBeneficiary;\\n  }\\n\\n  struct GlobalPositionData {\\n    FixedPoint.Unsigned totalTokensOutstanding;\\n    FixedPoint.Unsigned rawTotalPositionCollateral;\\n  }\\n\\n  function feePayerData() external view returns (FeePayerData memory data);\\n\\n  function positionManagerData()\\n    external\\n    view\\n    returns (PositionManagerData memory data);\\n\\n  function globalPositionData()\\n    external\\n    view\\n    returns (GlobalPositionData memory data);\\n\\n  function depositTo(\\n    address sponsor,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) external;\\n\\n  function deposit(FixedPoint.Unsigned memory collateralAmount) external;\\n\\n  function withdraw(FixedPoint.Unsigned memory collateralAmount)\\n    external\\n    returns (FixedPoint.Unsigned memory amountWithdrawn);\\n\\n  function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\\n    external;\\n\\n  function withdrawPassedRequest()\\n    external\\n    returns (FixedPoint.Unsigned memory amountWithdrawn);\\n\\n  function cancelWithdrawal() external;\\n\\n  function create(\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) external;\\n\\n  function redeem(FixedPoint.Unsigned memory numTokens)\\n    external\\n    returns (FixedPoint.Unsigned memory amountWithdrawn);\\n\\n  function repay(FixedPoint.Unsigned memory numTokens) external;\\n\\n  function settleEmergencyShutdown()\\n    external\\n    returns (FixedPoint.Unsigned memory amountWithdrawn);\\n\\n  function emergencyShutdown() external;\\n\\n  function remargin() external;\\n\\n  function trimExcess(IERC20 token)\\n    external\\n    returns (FixedPoint.Unsigned memory amount);\\n\\n  function addPool(address pool) external;\\n\\n  function addAdmin(address admin) external;\\n\\n  function renouncePool() external;\\n\\n  function renounceAdminAndPool() external;\\n\\n  function addSyntheticTokenMinter(address derivative) external;\\n\\n  function addSyntheticTokenBurner(address derivative) external;\\n\\n  function addSyntheticTokenAdmin(address derivative) external;\\n\\n  function addSyntheticTokenAdminAndMinterAndBurner(address derivative)\\n    external;\\n\\n  function renounceSyntheticTokenMinter() external;\\n\\n  function renounceSyntheticTokenBurner() external;\\n\\n  function renounceSyntheticTokenAdmin() external;\\n\\n  function renounceSyntheticTokenAdminAndMinterAndBurner() external;\\n\\n  function getCollateral(address sponsor)\\n    external\\n    view\\n    returns (FixedPoint.Unsigned memory collateralAmount);\\n\\n  function totalPositionCollateral()\\n    external\\n    view\\n    returns (FixedPoint.Unsigned memory totalCollateral);\\n\\n  function emergencyShutdownPrice()\\n    external\\n    view\\n    returns (FixedPoint.Unsigned memory emergencyPrice);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/base/interfaces/IRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\n/**\\n * @title Access role interface\\n */\\ninterface IRole {\\n  /**\\n   * @dev Returns `true` if `account` has been granted `role`.\\n   */\\n  function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n  /**\\n   * @dev Returns the number of accounts that have `role`. Can be used\\n   * together with {getRoleMember} to enumerate all bearers of a role.\\n   */\\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns one of the accounts that have `role`. `index` must be a\\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\\n   *\\n   */\\n  function getRoleMember(bytes32 role, uint256 index)\\n    external\\n    view\\n    returns (address);\\n\\n  /**\\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\\n   * {revokeRole}.\\n   */\\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function grantRole(bytes32 role, address account) external;\\n\\n  /**\\n   * @dev Revokes `role` from `account`.\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function revokeRole(bytes32 role, address account) external;\\n\\n  /**\\n   * @dev Revokes `role` from the calling account.\\n   *\\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n   * purpose is to provide a mechanism for accounts to lose their privileges\\n   * if they are compromised (such as when a trusted device is misplaced).\\n   *\\n   * - the caller must be `account`.\\n   */\\n  function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/core/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nlibrary SynthereumInterfaces {\\n  bytes32 public constant Deployer = 'Deployer';\\n  bytes32 public constant FactoryVersioning = 'FactoryVersioning';\\n  bytes32 public constant PoolRegistry = 'PoolRegistry';\\n  bytes32 public constant PriceFeed = 'PriceFeed';\\n  bytes32 public constant Manager = 'Manager';\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport '../utils/EnumerableSet.sol';\\nimport '../utils/Address.sol';\\nimport '../GSN/Context.sol';\\n\\nabstract contract AccessControl is Context {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using Address for address;\\n\\n  struct RoleData {\\n    EnumerableSet.AddressSet members;\\n    bytes32 adminRole;\\n  }\\n\\n  mapping(bytes32 => RoleData) private _roles;\\n\\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  event RoleGranted(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  event RoleRevoked(\\n    bytes32 indexed role,\\n    address indexed account,\\n    address indexed sender\\n  );\\n\\n  function hasRole(bytes32 role, address account) public view returns (bool) {\\n    return _roles[role].members.contains(account);\\n  }\\n\\n  function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n    return _roles[role].members.length();\\n  }\\n\\n  function getRoleMember(bytes32 role, uint256 index)\\n    public\\n    view\\n    returns (address)\\n  {\\n    return _roles[role].members.at(index);\\n  }\\n\\n  function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n    return _roles[role].adminRole;\\n  }\\n\\n  function grantRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to grant'\\n    );\\n\\n    _grantRole(role, account);\\n  }\\n\\n  function revokeRole(bytes32 role, address account) public virtual {\\n    require(\\n      hasRole(_roles[role].adminRole, _msgSender()),\\n      'AccessControl: sender must be an admin to revoke'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function renounceRole(bytes32 role, address account) public virtual {\\n    require(\\n      account == _msgSender(),\\n      'AccessControl: can only renounce roles for self'\\n    );\\n\\n    _revokeRole(role, account);\\n  }\\n\\n  function _setupRole(bytes32 role, address account) internal virtual {\\n    _grantRole(role, account);\\n  }\\n\\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n    emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n    _roles[role].adminRole = adminRole;\\n  }\\n\\n  function _grantRole(bytes32 role, address account) private {\\n    if (_roles[role].members.add(account)) {\\n      emit RoleGranted(role, account, _msgSender());\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) private {\\n    if (_roles[role].members.remove(account)) {\\n      emit RoleRevoked(role, account, _msgSender());\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/contracts/derivative/common/interfaces/IDerivativeDeployment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.12;\\n\\nimport {\\n  IERC20\\n} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IDerivativeDeployment {\\n  function addAdminAndPool(address adminAndPool) external;\\n\\n  function renounceAdmin() external;\\n\\n  function collateralCurrency() external view returns (IERC20 collateral);\\n\\n  function tokenCurrency() external view returns (IERC20 syntheticCurrency);\\n\\n  function getAdminMembers() external view returns (address[] memory);\\n\\n  function getPoolMembers() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/oracle/interfaces/FinderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\ninterface FinderInterface {\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/@jarvis-network/uma-core/contracts/common/implementation/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.6.0;\\n\\nimport '../../../../../@openzeppelin/contracts/math/SafeMath.sol';\\nimport '../../../../../@openzeppelin/contracts/math/SignedSafeMath.sol';\\n\\nlibrary FixedPoint {\\n  using SafeMath for uint256;\\n  using SignedSafeMath for int256;\\n\\n  uint256 private constant FP_SCALING_FACTOR = 10**18;\\n\\n  struct Unsigned {\\n    uint256 rawValue;\\n  }\\n\\n  function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.mul(FP_SCALING_FACTOR));\\n  }\\n\\n  function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  function isGreaterThan(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThan(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isGreaterThan(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue >= b.rawValue;\\n  }\\n\\n  function isLessThan(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  function isLessThan(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isLessThan(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue < b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  function isLessThanOrEqual(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledUint(a).rawValue <= b.rawValue;\\n  }\\n\\n  function min(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  function max(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  function add(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.add(b.rawValue));\\n  }\\n\\n  function add(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return add(a, fromUnscaledUint(b));\\n  }\\n\\n  function sub(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  function sub(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return sub(a, fromUnscaledUint(b));\\n  }\\n\\n  function sub(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return sub(fromUnscaledUint(a), b);\\n  }\\n\\n  function mul(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\n  }\\n\\n  function mul(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  function mulCeil(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    uint256 mulRaw = a.rawValue.mul(b.rawValue);\\n    uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\n    uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\n    if (mod != 0) {\\n      return Unsigned(mulFloor.add(1));\\n    } else {\\n      return Unsigned(mulFloor);\\n    }\\n  }\\n\\n  function mulCeil(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  function div(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  function div(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return Unsigned(a.rawValue.div(b));\\n  }\\n\\n  function div(uint256 a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return div(fromUnscaledUint(a), b);\\n  }\\n\\n  function divCeil(Unsigned memory a, Unsigned memory b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\n    uint256 divFloor = aScaled.div(b.rawValue);\\n    uint256 mod = aScaled.mod(b.rawValue);\\n    if (mod != 0) {\\n      return Unsigned(divFloor.add(1));\\n    } else {\\n      return Unsigned(divFloor);\\n    }\\n  }\\n\\n  function divCeil(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory)\\n  {\\n    return divCeil(a, fromUnscaledUint(b));\\n  }\\n\\n  function pow(Unsigned memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Unsigned memory output)\\n  {\\n    output = fromUnscaledUint(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n\\n  int256 private constant SFP_SCALING_FACTOR = 10**18;\\n\\n  struct Signed {\\n    int256 rawValue;\\n  }\\n\\n  function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\n    require(a.rawValue >= 0, 'Negative value provided');\\n    return Unsigned(uint256(a.rawValue));\\n  }\\n\\n  function fromUnsigned(Unsigned memory a)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    require(a.rawValue <= uint256(type(int256).max), 'Unsigned too large');\\n    return Signed(int256(a.rawValue));\\n  }\\n\\n  function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\n    return Signed(a.mul(SFP_SCALING_FACTOR));\\n  }\\n\\n  function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  function isGreaterThan(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThan(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue > fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isGreaterThan(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue > b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue >= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isGreaterThanOrEqual(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue >= b.rawValue;\\n  }\\n\\n  function isLessThan(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue < fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue < b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  function isLessThanOrEqual(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return a.rawValue <= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  function isLessThanOrEqual(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return fromUnscaledInt(a).rawValue <= b.rawValue;\\n  }\\n\\n  function min(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  function max(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  function add(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.add(b.rawValue));\\n  }\\n\\n  function add(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return add(a, fromUnscaledInt(b));\\n  }\\n\\n  function sub(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  function sub(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return sub(a, fromUnscaledInt(b));\\n  }\\n\\n  function sub(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return sub(fromUnscaledInt(a), b);\\n  }\\n\\n  function mul(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\n  }\\n\\n  function mul(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  function mulAwayFromZero(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    int256 mulRaw = a.rawValue.mul(b.rawValue);\\n    int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\n\\n    int256 mod = mulRaw % SFP_SCALING_FACTOR;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(mulTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(mulTowardsZero);\\n    }\\n  }\\n\\n  function mulAwayFromZero(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  function div(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  function div(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return Signed(a.rawValue.div(b));\\n  }\\n\\n  function div(int256 a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return div(fromUnscaledInt(a), b);\\n  }\\n\\n  function divAwayFromZero(Signed memory a, Signed memory b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\n    int256 divTowardsZero = aScaled.div(b.rawValue);\\n\\n    int256 mod = aScaled % b.rawValue;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(divTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(divTowardsZero);\\n    }\\n  }\\n\\n  function divAwayFromZero(Signed memory a, int256 b)\\n    internal\\n    pure\\n    returns (Signed memory)\\n  {\\n    return divAwayFromZero(a, fromUnscaledInt(b));\\n  }\\n\\n  function pow(Signed memory a, uint256 b)\\n    internal\\n    pure\\n    returns (Signed memory output)\\n  {\\n    output = fromUnscaledInt(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary SignedSafeMath {\\n  int256 private constant _INT256_MIN = -2**255;\\n\\n  function mul(int256 a, int256 b) internal pure returns (int256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    require(\\n      !(a == -1 && b == _INT256_MIN),\\n      'SignedSafeMath: multiplication overflow'\\n    );\\n\\n    int256 c = a * b;\\n    require(c / a == b, 'SignedSafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(int256 a, int256 b) internal pure returns (int256) {\\n    require(b != 0, 'SignedSafeMath: division by zero');\\n    require(\\n      !(b == -1 && a == _INT256_MIN),\\n      'SignedSafeMath: division overflow'\\n    );\\n\\n    int256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  function sub(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a - b;\\n    require(\\n      (b >= 0 && c <= a) || (b < 0 && c > a),\\n      'SignedSafeMath: subtraction overflow'\\n    );\\n\\n    return c;\\n  }\\n\\n  function add(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a + b;\\n    require(\\n      (b >= 0 && c >= a) || (b < 0 && c < a),\\n      'SignedSafeMath: addition overflow'\\n    );\\n\\n    return c;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nlibrary EnumerableSet {\\n  struct Set {\\n    bytes32[] _values;\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      bytes32 lastvalue = set._values[lastIndex];\\n\\n      set._values[toDeleteIndex] = lastvalue;\\n\\n      set._indexes[lastvalue] = toDeleteIndex + 1;\\n\\n      set._values.pop();\\n\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function _contains(Set storage set, bytes32 value)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    require(set._values.length > index, 'EnumerableSet: index out of bounds');\\n    return set._values[index];\\n  }\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  function remove(Bytes32Set storage set, bytes32 value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, value);\\n  }\\n\\n  function contains(Bytes32Set storage set, bytes32 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, value);\\n  }\\n\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(Bytes32Set storage set, uint256 index)\\n    internal\\n    view\\n    returns (bytes32)\\n  {\\n    return _at(set._inner, index);\\n  }\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function remove(AddressSet storage set, address value)\\n    internal\\n    returns (bool)\\n  {\\n    return _remove(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function contains(AddressSet storage set, address value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(uint256(value)));\\n  }\\n\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(AddressSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return address(uint256(_at(set._inner, index)));\\n  }\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  function contains(UintSet storage set, uint256 value)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  function at(UintSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return uint256(_at(set._inner, index));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.8.0;\\n\\nlibrary Address {\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(\\n      success,\\n      'Address: unable to send value, recipient may have reverted'\\n    );\\n  }\\n\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return functionCall(target, data, 'Address: low-level call failed');\\n  }\\n\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        'Address: low-level call with value failed'\\n      );\\n  }\\n\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance >= value,\\n      'Address: insufficient balance for call'\\n    );\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(target, data, 'Address: low-level static call failed');\\n  }\\n\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), 'Address: static call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      if (returndata.length > 0) {\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this;\\n    return msg.data;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"_synthereumFinder\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maintainer\",\"type\":\"address\"}],\"internalType\":\"struct SynthereumManager.Roles\",\"name\":\"_roles\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAINTAINER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDerivative[]\",\"name\":\"derivatives\",\"type\":\"address[]\"}],\"name\":\"emergencyShutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"roles\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"grantSynthereumRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"roles\",\"type\":\"bytes32[]\"}],\"name\":\"renounceSynthereumRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"roles\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"revokeSynthereumRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synthereumFinder\",\"outputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SynthereumManager","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d451de78e297b496ee8a4f06dcf991c17580b452000000000000000000000000eb04e2b446cde583f900daff3dd9917fcf6f0586000000000000000000000000cdddd005cf81dc8c4182e27f3079d22fa7c7d35a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}