{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;    \r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function decimals() external view returns (uint256 digits);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}    \r\n\r\n\r\n\r\n\r\n\r\nabstract contract IWETH {\r\n    function allowance(address, address) public virtual view returns (uint256);\r\n\r\n    function balanceOf(address) public virtual view returns (uint256);\r\n\r\n    function approve(address, uint256) public virtual;\r\n\r\n    function transfer(address, uint256) public virtual returns (bool);\r\n\r\n    function transferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) public virtual returns (bool);\r\n\r\n    function deposit() public payable virtual;\r\n\r\n    function withdraw(uint256) public virtual;\r\n}    \r\n\r\n\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}    \r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /// @dev Edited so it always first approves 0 and then the value, because of non standard tokens\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            \"SafeERC20: decreased allowance below zero\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}    \r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary TokenUtils {\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    function approveToken(\r\n        address _tokenAddr,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal {\r\n        if (_tokenAddr == ETH_ADDR) return;\r\n\r\n        if (IERC20(_tokenAddr).allowance(address(this), _to) < _amount) {\r\n            IERC20(_tokenAddr).safeApprove(_to, _amount);\r\n        }\r\n    }\r\n\r\n    function pullTokensIfNeeded(\r\n        address _token,\r\n        address _from,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        // handle max uint amount\r\n        if (_amount == type(uint256).max) {\r\n            _amount = getBalance(_token, _from);\r\n        }\r\n\r\n        if (_from != address(0) && _from != address(this) && _token != ETH_ADDR && _amount != 0) {\r\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\r\n        }\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function withdrawTokens(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        if (_amount == type(uint256).max) {\r\n            _amount = getBalance(_token, address(this));\r\n        }\r\n\r\n        if (_to != address(0) && _to != address(this) && _amount != 0) {\r\n            if (_token != ETH_ADDR) {\r\n                IERC20(_token).safeTransfer(_to, _amount);\r\n            } else {\r\n                payable(_to).transfer(_amount);\r\n            }\r\n        }\r\n\r\n        return _amount;\r\n    }\r\n\r\n    function depositWeth(uint256 _amount) internal {\r\n        IWETH(WETH_ADDR).deposit{value: _amount}();\r\n    }\r\n\r\n    function withdrawWeth(uint256 _amount) internal {\r\n        IWETH(WETH_ADDR).withdraw(_amount);\r\n    }\r\n\r\n    function getBalance(address _tokenAddr, address _acc) internal view returns (uint256) {\r\n        if (_tokenAddr == ETH_ADDR) {\r\n            return _acc.balance;\r\n        } else {\r\n            return IERC20(_tokenAddr).balanceOf(_acc);\r\n        }\r\n    }\r\n\r\n    function getTokenDecimals(address _token) internal view returns (uint256) {\r\n        if (_token == ETH_ADDR) return 18;\r\n\r\n        return IERC20(_token).decimals();\r\n    }\r\n}    \r\n\r\n\r\n\r\n\r\n// Common interface for the Trove Manager.\r\ninterface ITroveManager {\r\n    \r\n    // --- Events ---\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event LQTYTokenAddressChanged(address _lqtyTokenAddress);\r\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\r\n\r\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\r\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\r\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\r\n    event BaseRateUpdated(uint _baseRate);\r\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\r\n    event TotalStakesUpdated(uint _newTotalStakes);\r\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\r\n    event LTermsUpdated(uint _L_ETH, uint _L_LUSDDebt);\r\n    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_LUSDDebt);\r\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\r\n\r\n    function getTroveOwnersCount() external view returns (uint);\r\n\r\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\r\n\r\n    function getNominalICR(address _borrower) external view returns (uint);\r\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\r\n\r\n    function liquidate(address _borrower) external;\r\n\r\n    function liquidateTroves(uint _n) external;\r\n\r\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\r\n\r\n    function redeemCollateral(\r\n        uint _LUSDAmount,\r\n        address _firstRedemptionHint,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR,\r\n        uint _maxIterations,\r\n        uint _maxFee\r\n    ) external; \r\n\r\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\r\n\r\n    function updateTroveRewardSnapshots(address _borrower) external;\r\n\r\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\r\n\r\n    function applyPendingRewards(address _borrower) external;\r\n\r\n    function getPendingETHReward(address _borrower) external view returns (uint);\r\n\r\n    function getPendingLUSDDebtReward(address _borrower) external view returns (uint);\r\n\r\n     function hasPendingRewards(address _borrower) external view returns (bool);\r\n\r\n    function getEntireDebtAndColl(address _borrower) external view returns (\r\n        uint debt, \r\n        uint coll, \r\n        uint pendingLUSDDebtReward, \r\n        uint pendingETHReward\r\n    );\r\n\r\n    function closeTrove(address _borrower) external;\r\n\r\n    function removeStake(address _borrower) external;\r\n\r\n    function getRedemptionRate() external view returns (uint);\r\n    function getRedemptionRateWithDecay() external view returns (uint);\r\n\r\n    function getRedemptionFeeWithDecay(uint _ETHDrawn) external view returns (uint);\r\n\r\n    function getBorrowingRate() external view returns (uint);\r\n    function getBorrowingRateWithDecay() external view returns (uint);\r\n\r\n    function getBorrowingFee(uint LUSDDebt) external view returns (uint);\r\n    function getBorrowingFeeWithDecay(uint _LUSDDebt) external view returns (uint);\r\n\r\n    function decayBaseRateFromBorrowing() external;\r\n\r\n    function getTroveStatus(address _borrower) external view returns (uint);\r\n    \r\n    function getTroveStake(address _borrower) external view returns (uint);\r\n\r\n    function getTroveDebt(address _borrower) external view returns (uint);\r\n\r\n    function getTroveColl(address _borrower) external view returns (uint);\r\n\r\n    function setTroveStatus(address _borrower, uint num) external;\r\n\r\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\r\n\r\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \r\n\r\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function getTCR(uint _price) external view returns (uint);\r\n\r\n    function checkRecoveryMode(uint _price) external view returns (bool);\r\n}    \r\n\r\n\r\n\r\n// Common interface for the Trove Manager.\r\ninterface IBorrowerOperations {\r\n\r\n    // --- Events ---\r\n\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\r\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\r\n\r\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\r\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\r\n\r\n    // --- Functions ---\r\n\r\n    function openTrove(uint _maxFee, uint _LUSDAmount, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function addColl(address _upperHint, address _lowerHint) external payable;\r\n\r\n    function moveETHGainToTrove(address _user, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function withdrawColl(uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function withdrawLUSD(uint _maxFee, uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function repayLUSD(uint _amount, address _upperHint, address _lowerHint) external;\r\n\r\n    function closeTrove() external;\r\n\r\n    function adjustTrove(uint _maxFee, uint _collWithdrawal, uint _debtChange, bool isDebtIncrease, address _upperHint, address _lowerHint) external payable;\r\n\r\n    function claimCollateral() external;\r\n\r\n    function getCompositeDebt(uint _debt) external pure returns (uint);\r\n}    \r\n\r\n\r\n\r\ninterface IPriceFeed {\r\n    function lastGoodPrice() external pure returns (uint256);\r\n}    \r\n\r\n\r\n\r\ninterface IHintHelpers {\r\n\r\n    function getRedemptionHints(\r\n        uint _LUSDamount, \r\n        uint _price,\r\n        uint _maxIterations\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address firstRedemptionHint,\r\n            uint partialRedemptionHintNICR,\r\n            uint truncatedLUSDamount\r\n        );\r\n\r\n    function getApproxHint(uint _CR, uint _numTrials, uint _inputRandomSeed)\r\n        external\r\n        view\r\n        returns (address hintAddress, uint diff, uint latestRandomSeed);\r\n\r\n    function computeNominalCR(uint _coll, uint _debt) external pure returns (uint);\r\n\r\n    function computeCR(uint _coll, uint _debt, uint _price) external pure returns (uint);\r\n}    \r\n\r\n\r\n\r\n// Common interface for the SortedTroves Doubly Linked List.\r\ninterface ISortedTroves {\r\n\r\n    // --- Events ---\r\n    \r\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\r\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\r\n    event NodeAdded(address _id, uint _NICR);\r\n    event NodeRemoved(address _id);\r\n\r\n    // --- Functions ---\r\n    \r\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\r\n\r\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\r\n\r\n    function remove(address _id) external;\r\n\r\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\r\n\r\n    function contains(address _id) external view returns (bool);\r\n\r\n    function isFull() external view returns (bool);\r\n\r\n    function isEmpty() external view returns (bool);\r\n\r\n    function getSize() external view returns (uint256);\r\n\r\n    function getMaxSize() external view returns (uint256);\r\n\r\n    function getFirst() external view returns (address);\r\n\r\n    function getLast() external view returns (address);\r\n\r\n    function getNext(address _id) external view returns (address);\r\n\r\n    function getPrev(address _id) external view returns (address);\r\n\r\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\r\n\r\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\r\n}    \r\n\r\n\r\ninterface ICollSurplusPool {\r\n\r\n    // --- Events ---\r\n    \r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n\r\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Contract setters ---\r\n\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress\r\n    ) external;\r\n\r\n    function getETH() external view returns (uint);\r\n\r\n    function getCollateral(address _account) external view returns (uint);\r\n\r\n    function accountSurplus(address _account, uint _amount) external;\r\n\r\n    function claimColl(address _account) external;\r\n}    \r\n\r\n\r\ninterface IStabilityPool {\r\n\r\n    // --- Events ---\r\n    \r\n    event StabilityPoolETHBalanceUpdated(uint _newBalance);\r\n    event StabilityPoolLUSDBalanceUpdated(uint _newBalance);\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\r\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\r\n\r\n    event P_Updated(uint _P);\r\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\r\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\r\n    event EpochUpdated(uint128 _currentEpoch);\r\n    event ScaleUpdated(uint128 _currentScale);\r\n\r\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\r\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\r\n\r\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\r\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\r\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\r\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\r\n\r\n    event ETHGainWithdrawn(address indexed _depositor, uint _ETH, uint _LUSDLoss);\r\n    event LQTYPaidToDepositor(address indexed _depositor, uint _LQTY);\r\n    event LQTYPaidToFrontEnd(address indexed _frontEnd, uint _LQTY);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    /*\r\n     * Called only once on init, to set addresses of other Liquity contracts\r\n     * Callable only by owner, renounces ownership at the end\r\n     */\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress,\r\n        address _lusdTokenAddress,\r\n        address _sortedTrovesAddress,\r\n        address _priceFeedAddress,\r\n        address _communityIssuanceAddress\r\n    ) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend is registered or zero address\r\n     * - Sender is not a registered frontend\r\n     * - _amount is not zero\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\r\n     * - Sends depositor's accumulated gains (LQTY, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\r\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     */\r\n    function provideToSP(uint _amount, address _frontEndTag) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - _amount is zero or there are no under collateralized troves left in the system\r\n     * - User has a non zero deposit\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Removes the deposit's front end tag if it is a full withdrawal\r\n     * - Sends all depositor's accumulated gains (LQTY, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\r\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     *\r\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\r\n     */\r\n    function withdrawFromSP(uint _amount) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - User has a non zero deposit\r\n     * - User has an open trove\r\n     * - User has some ETH gain\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Sends all depositor's LQTY gain to  depositor\r\n     * - Sends all tagged front end's LQTY gain to the tagged front end\r\n     * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\r\n     * - Leaves their compounded deposit in the Stability Pool\r\n     * - Updates snapshots for deposit and tagged front end stake\r\n     */\r\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend (sender) not already registered\r\n     * - User (sender) has no deposit\r\n     * - _kickbackRate is in the range [0, 100%]\r\n     * ---\r\n     * Front end makes a one-time selection of kickback rate upon registering\r\n     */\r\n    function registerFrontEnd(uint _kickbackRate) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Caller is TroveManager\r\n     * ---\r\n     * Cancels out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\r\n     * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\r\n     * Only called by liquidation functions in the TroveManager.\r\n     */\r\n    function offset(uint _debt, uint _coll) external;\r\n\r\n    /*\r\n     * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,\r\n     * to exclude edge cases like ETH received from a self-destruct.\r\n     */\r\n    function getETH() external view returns (uint);\r\n\r\n    /*\r\n     * Returns LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\r\n     */\r\n    function getTotalLUSDDeposits() external view returns (uint);\r\n\r\n    /*\r\n     * Calculates the ETH gain earned by the deposit since its last snapshots were taken.\r\n     */\r\n    function getDepositorETHGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\r\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\r\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\r\n     * which they made their deposit.\r\n     */\r\n    function getDepositorLQTYGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the LQTY gain earned by the front end.\r\n     */\r\n    function getFrontEndLQTYGain(address _frontEnd) external view returns (uint);\r\n\r\n    /*\r\n     * Return the user's compounded deposit.\r\n     */\r\n    function getCompoundedLUSDDeposit(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the front end's compounded stake.\r\n     *\r\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\r\n     */\r\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\r\n}    \r\n\r\n\r\n\r\ninterface ILQTYStaking {\r\n\r\n    // --- Events --\r\n    \r\n    event LQTYTokenAddressSet(address _lqtyTokenAddress);\r\n    event LUSDTokenAddressSet(address _lusdTokenAddress);\r\n    event TroveManagerAddressSet(address _troveManager);\r\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\r\n    event ActivePoolAddressSet(address _activePoolAddress);\r\n\r\n    event StakeChanged(address indexed staker, uint newStake);\r\n    event StakingGainsWithdrawn(address indexed staker, uint LUSDGain, uint ETHGain);\r\n    event F_ETHUpdated(uint _F_ETH);\r\n    event F_LUSDUpdated(uint _F_LUSD);\r\n    event TotalLQTYStakedUpdated(uint _totalLQTYStaked);\r\n    event EtherSent(address _account, uint _amount);\r\n    event StakerSnapshotsUpdated(address _staker, uint _F_ETH, uint _F_LUSD);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses\r\n    (\r\n        address _lqtyTokenAddress,\r\n        address _lusdTokenAddress,\r\n        address _troveManagerAddress, \r\n        address _borrowerOperationsAddress,\r\n        address _activePoolAddress\r\n    )  external;\r\n\r\n    function stake(uint _LQTYamount) external;\r\n\r\n    function unstake(uint _LQTYamount) external;\r\n\r\n    function increaseF_ETH(uint _ETHFee) external; \r\n\r\n    function increaseF_LUSD(uint _LQTYFee) external;  \r\n\r\n    function getPendingETHGain(address _user) external view returns (uint);\r\n\r\n    function getPendingLUSDGain(address _user) external view returns (uint);\r\n\r\n    function stakes(address) external view returns (uint256);\r\n}    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LiquityHelper {\r\n    using TokenUtils for address;\r\n\r\n    uint constant public LUSD_GAS_COMPENSATION = 200e18;\r\n    address constant public LUSDTokenAddr = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;\r\n    address constant public LQTYTokenAddr = 0x6DEA81C8171D0bA574754EF6F8b412F2Ed88c54D;\r\n    address constant public PriceFeedAddr = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De;\r\n    address constant public BorrowerOperationsAddr = 0x24179CD81c9e782A4096035f7eC97fB8B783e007;\r\n    address constant public TroveManagerAddr = 0xA39739EF8b0231DbFA0DcdA07d7e29faAbCf4bb2;\r\n    address constant public SortedTrovesAddr = 0x8FdD3fbFEb32b28fb73555518f8b361bCeA741A6;\r\n    address constant public HintHelpersAddr = 0xE84251b93D9524E0d2e621Ba7dc7cb3579F997C0;\r\n    address constant public CollSurplusPoolAddr = 0x3D32e8b97Ed5881324241Cf03b2DA5E2EBcE5521;\r\n    address constant public StabilityPoolAddr = 0x66017D22b0f8556afDd19FC67041899Eb65a21bb;\r\n    address constant public LQTYStakingAddr = 0x4f9Fbb3f1E99B56e0Fe2892e623Ed36A76Fc605d;\r\n\r\n    IPriceFeed constant public PriceFeed = IPriceFeed(PriceFeedAddr);\r\n    IBorrowerOperations constant public BorrowerOperations = IBorrowerOperations(BorrowerOperationsAddr);\r\n    ITroveManager constant public TroveManager = ITroveManager(TroveManagerAddr);\r\n    ISortedTroves constant public SortedTroves = ISortedTroves(SortedTrovesAddr);\r\n    IHintHelpers constant public HintHelpers = IHintHelpers(HintHelpersAddr);\r\n    ICollSurplusPool constant public CollSurplusPool = ICollSurplusPool(CollSurplusPoolAddr);\r\n    IStabilityPool constant public StabilityPool = IStabilityPool(StabilityPoolAddr);\r\n    ILQTYStaking constant public LQTYStaking = ILQTYStaking(LQTYStakingAddr);\r\n\r\n    function withdrawStaking(uint256 _ethGain, uint256 _lusdGain, address _wethTo, address _lusdTo) internal {\r\n        if (_ethGain > 0) {\r\n            TokenUtils.depositWeth(_ethGain);\r\n            TokenUtils.WETH_ADDR.withdrawTokens(_wethTo, _ethGain);\r\n        }\r\n        if (_lusdGain > 0) {\r\n            LUSDTokenAddr.withdrawTokens(_lusdTo, _lusdGain);\r\n        }\r\n    }\r\n    \r\n    function withdrawStabilityGains(uint256 _ethGain, uint256 _lqtyGain, address _wethTo, address _lqtyTo) internal {\r\n        if (_ethGain > 0) {\r\n            TokenUtils.depositWeth(_ethGain);\r\n            TokenUtils.WETH_ADDR.withdrawTokens(_wethTo, _ethGain);\r\n        }      \r\n        if (_lqtyGain > 0) {\r\n            LQTYTokenAddr.withdrawTokens(_lqtyTo, _lqtyGain);\r\n        }\r\n    }\r\n}    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LiquityView is LiquityHelper {\r\n    using TokenUtils for address;\r\n    using SafeMath for uint256;\r\n\r\n    enum LiquityActionId {Open, Borrow, Payback, Supply, Withdraw}\r\n\r\n    function isRecoveryMode() public view returns (bool) {\r\n        uint256 price = PriceFeed.lastGoodPrice();\r\n        return TroveManager.checkRecoveryMode(price);\r\n    }\r\n\r\n    function computeNICR(uint256 _coll, uint256 _debt) public pure returns (uint256) {\r\n        if (_debt > 0) {\r\n            return _coll.mul(1e20).div(_debt);\r\n        }\r\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\r\n        else {\r\n            // if (_debt == 0)\r\n            return 2**256 - 1;\r\n        }\r\n    }\r\n\r\n    /// @notice Predict the resulting nominal collateral ratio after a trove modifying action\r\n    /// @param _troveOwner Address of the trove owner, if the action specified is LiquityOpen this argument is ignored\r\n    /// @param _action LiquityActionIds\r\n    function predictNICR(\r\n        address _troveOwner,\r\n        LiquityActionId _action,\r\n        address _from,\r\n        uint256 _collAmount,\r\n        uint256 _lusdAmount\r\n    ) external view returns (uint256 NICR) {\r\n        //  LiquityOpen\r\n        if (_action == LiquityActionId.Open) {\r\n            if (!isRecoveryMode())\r\n                _lusdAmount = _lusdAmount.add(TroveManager.getBorrowingFeeWithDecay(_lusdAmount));\r\n            _lusdAmount = BorrowerOperations.getCompositeDebt(_lusdAmount);\r\n\r\n            if (_collAmount == type(uint256).max)\r\n                _collAmount = TokenUtils.WETH_ADDR.getBalance(_from);\r\n\r\n            return computeNICR(_collAmount, _lusdAmount);\r\n        }\r\n\r\n        (uint256 debt, uint256 coll, , ) = TroveManager.getEntireDebtAndColl(_troveOwner);\r\n\r\n        //  LiquityBorrow\r\n        if (_action == LiquityActionId.Borrow) {\r\n            if (!isRecoveryMode())\r\n                _lusdAmount = _lusdAmount.add(TroveManager.getBorrowingFeeWithDecay(_lusdAmount));\r\n            return computeNICR(coll, debt.add(_lusdAmount));\r\n        }\r\n\r\n        //  LiquityPayback\r\n        if (_action == LiquityActionId.Payback) {\r\n            return computeNICR(coll, debt.sub(_lusdAmount));\r\n        }\r\n\r\n        //  LiquitySupply\r\n        if (_action == LiquityActionId.Supply) {\r\n            if (_collAmount == type(uint256).max)\r\n                _collAmount = TokenUtils.WETH_ADDR.getBalance(_from);\r\n\r\n            return computeNICR(coll.add(_collAmount), debt);\r\n        }\r\n\r\n        //  LiquityWithdraw\r\n        if (_action == LiquityActionId.Withdraw) {\r\n            return computeNICR(coll.sub(_collAmount), debt);\r\n        }\r\n    }\r\n\r\n    function getApproxHint(\r\n        uint256 _CR,\r\n        uint256 _numTrials,\r\n        uint256 _inputRandomSeed\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address hintAddress,\r\n            uint256 diff,\r\n            uint256 latestRandomSeed\r\n        )\r\n    {\r\n        return HintHelpers.getApproxHint(_CR, _numTrials, _inputRandomSeed);\r\n    }\r\n\r\n    function findInsertPosition(\r\n        uint256 _ICR,\r\n        address _prevId,\r\n        address _nextId\r\n    ) external view returns (address upperHint, address lowerHint) {\r\n        return SortedTroves.findInsertPosition(_ICR, _prevId, _nextId);\r\n    }\r\n\r\n    function getTroveInfo(address _troveOwner)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 troveStatus,\r\n            uint256 collAmount,\r\n            uint256 debtAmount,\r\n            uint256 collPrice,\r\n            uint256 TCRatio,\r\n            bool recoveryMode\r\n        )\r\n    {\r\n        troveStatus = TroveManager.getTroveStatus(_troveOwner);\r\n        collAmount = TroveManager.getTroveColl(_troveOwner);\r\n        debtAmount = TroveManager.getTroveDebt(_troveOwner);\r\n        collPrice = PriceFeed.lastGoodPrice();\r\n        TCRatio = TroveManager.getTCR(collPrice);\r\n        recoveryMode = TroveManager.checkRecoveryMode(collPrice);\r\n    }\r\n\r\n    function getInsertPosition(\r\n        uint256 _collAmount,\r\n        uint256 _debtAmount,\r\n        uint256 _numTrials,\r\n        uint256 _inputRandomSeed\r\n    ) external view returns (address upperHint, address lowerHint) {\r\n        uint256 NICR = _collAmount.mul(1e20).div(_debtAmount);\r\n        (address hintAddress, , ) = HintHelpers.getApproxHint(NICR, _numTrials, _inputRandomSeed);\r\n        (upperHint, lowerHint) = SortedTroves.findInsertPosition(NICR, hintAddress, hintAddress);\r\n    }\r\n\r\n    function getRedemptionHints(\r\n        uint _LUSDamount, \r\n        uint _price,\r\n        uint _maxIterations\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n        address firstRedemptionHint,\r\n        uint partialRedemptionHintNICR,\r\n        uint truncatedLUSDamount\r\n    ) {\r\n        return HintHelpers.getRedemptionHints(_LUSDamount, _price, _maxIterations);\r\n    }\r\n    \r\n    function getStakeInfo(address _user) external view returns (uint256 stake, uint256 ethGain, uint256 lusdGain) {\r\n        stake = LQTYStaking.stakes(_user);\r\n        ethGain = LQTYStaking.getPendingETHGain(_user);\r\n        lusdGain = LQTYStaking.getPendingLUSDGain(_user);\r\n    }\r\n    \r\n    function getDepositorInfo(address _depositor) external view returns(uint256 compoundedLUSD, uint256 ethGain, uint256 lqtyGain) {\r\n        compoundedLUSD = StabilityPool.getCompoundedLUSDDeposit(_depositor);\r\n        ethGain = StabilityPool.getDepositorETHGain(_depositor);\r\n        lqtyGain = StabilityPool.getDepositorLQTYGain(_depositor);\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"name\":\"BorrowerOperations\",\"outputs\":[{\"internalType\":\"contract IBorrowerOperations\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BorrowerOperationsAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CollSurplusPool\",\"outputs\":[{\"internalType\":\"contract ICollSurplusPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CollSurplusPoolAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HintHelpers\",\"outputs\":[{\"internalType\":\"contract IHintHelpers\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HintHelpersAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LQTYStaking\",\"outputs\":[{\"internalType\":\"contract ILQTYStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LQTYStakingAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LQTYTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LUSDTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LUSD_GAS_COMPENSATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PriceFeed\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PriceFeedAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SortedTrovesAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StabilityPool\",\"outputs\":[{\"internalType\":\"contract IStabilityPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StabilityPoolAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TroveManager\",\"outputs\":[{\"internalType\":\"contract ITroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TroveManagerAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"}],\"name\":\"computeNICR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ICR\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_prevId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nextId\",\"type\":\"address\"}],\"name\":\"findInsertPosition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upperHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lowerHint\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_CR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numTrials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputRandomSeed\",\"type\":\"uint256\"}],\"name\":\"getApproxHint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"hintAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"diff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestRandomSeed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"getDepositorInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"compoundedLUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethGain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lqtyGain\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numTrials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputRandomSeed\",\"type\":\"uint256\"}],\"name\":\"getInsertPosition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upperHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lowerHint\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_LUSDamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxIterations\",\"type\":\"uint256\"}],\"name\":\"getRedemptionHints\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"firstRedemptionHint\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"partialRedemptionHintNICR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"truncatedLUSDamount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStakeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethGain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lusdGain\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_troveOwner\",\"type\":\"address\"}],\"name\":\"getTroveInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"troveStatus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TCRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"recoveryMode\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRecoveryMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_troveOwner\",\"type\":\"address\"},{\"internalType\":\"enum LiquityView.LiquityActionId\",\"name\":\"_action\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lusdAmount\",\"type\":\"uint256\"}],\"name\":\"predictNICR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"NICR\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LiquityView","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b86ac3859325a03d046c3a16494afd9437d7945ccf9f6acb5a2663d1b8f904ef"}]}