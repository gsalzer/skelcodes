{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/mac/Desktop/Invest/Blockchain/demo/contracts/wealthWalletFactoryFlat.sol\": {\r\n      \"content\": \"// File: contracts/interfaces/IUniswapV2Router.sol\\n\\ninterface IUniswapV2Router {\\n    function swapExactTokensForTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);       \\n    function WETH() external pure returns (address);\\n}\\n\\n// File: contracts/interfaces/IUniswapV2Pair.sol\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\\n// File: contracts/interfaces/IWETH.sol\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function approve(address spender, uint amount) external;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n    function allowance(address owner, address spender) external view returns(uint);\\n    function balanceOf(address owner) external view returns(uint);\\n}\\n\\n// File: contracts/portfolio.sol\\n\\npragma solidity ^0.7.6;\\n\\n\\n\\n\\ncontract Portfolio {\\n    //info\\n    address public owner;\\n    string public name;\\n    uint public totalAssets;\\n    mapping(uint => Asset) public assets;\\n    Config config;\\n\\n    //states\\n    bool configured;\\n    bool rulesSet;\\n    bool started;\\n    bool running;\\n    bool rebalancing;\\n\\n    //interfaces\\n    IUniswapV2Router iUniswapRouter;\\n    IWETH iWeth;\\n\\n    //asset structure\\n    struct Asset {\\n        string name;\\n        string symbol;\\n        address tokenAddress;\\n        uint ratio;\\n        uint amount;\\n    }\\n\\n    //configuration structure\\n    struct Config {\\n        uint slippage; // basis points out of 10,000 \\n        uint swapTimeLimit; // time limit until swap expires in seconds\\n        address uniswapRouterAddress;\\n        address wethAddress;\\n    }\\n    \\n    constructor(address _owner, string memory _name) public {\\n        //set main info\\n        owner = _owner;\\n        name = _name;\\n        totalAssets = 0;\\n\\n        //set states\\n        configured = false;\\n        rulesSet = false;\\n        started= false;\\n        running = false;\\n        rebalancing = false;\\n\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Only owner can call this function.\\\");\\n        _;\\n    }\\n\\n    function addAsset(string memory _name, string memory _symbol, address _address, uint _ratio) onlyOwner public {\\n        //create Asset\\n        Asset memory asset = Asset(_name, _symbol, _address, _ratio, 0);\\n\\n        //map asset\\n        assets[totalAssets] = asset;\\n        totalAssets++;\\n    }\\n    \\n    function changeAssetRatio(uint _assetIndex, uint _assetRatio) onlyOwner public {\\n        assets[_assetIndex].ratio = _assetRatio;\\n    }\\n\\n    function spreadToAssets() internal {\\n        //spread contract balance to assets\\n        uint totalAmount = address(this).balance;\\n        uint currentAmount = totalAmount;\\n\\n        //for every asset\\n        for (uint i=0; i<totalAssets; i++) {\\n            //if current amount is empty\\n            if (currentAmount == 0) {\\n                break;\\n            }\\n\\n            //get asset and ratio\\n            Asset memory asset = assets[i];\\n            uint assetRatio = asset.ratio;\\n\\n            if (assetRatio == 0) {\\n                break;\\n            }\\n            \\n            //calculate amountPerAsset\\n            uint amountPerAsset = totalAmount * assetRatio / 10000;\\n            \\n            //if current amount is more than amount to asset\\n            if (amountPerAsset <= currentAmount) {\\n                //buy asset for amount\\n                buyAsset(i, amountPerAsset);\\n\\n                //adjust current amount\\n                if (amountPerAsset == currentAmount) {\\n                    currentAmount = 0;\\n                }\\n                else {\\n                    currentAmount -= amountPerAsset;\\n                }\\n            }\\n            else {\\n                //buy remaining current amount and set to 0\\n                buyAsset(i, currentAmount);\\n                currentAmount = 0;\\n            }\\n        }\\n        \\n    }\\n\\n    function buyAsset(uint currentIndex, uint amountIn) internal {\\n        //set asset data\\n        Asset memory asset = assets[currentIndex];\\n        address buyingAddress = asset.tokenAddress;\\n        address wethAddress = config.wethAddress;\\n\\n        require(amountIn <= address(this).balance, \\\"Can't send more than current balance\\\");\\n\\n        if (buyingAddress == wethAddress) {\\n            //deposit to Wrapped WETH\\n            iWeth.deposit{value: amountIn}();\\n        }\\n        else {\\n            //get swap config\\n            uint slippage = config.slippage;\\n            uint swapTimeLimit = config.swapTimeLimit;\\n\\n            //set path\\n            address[] memory path = new address[](2);\\n            path[0] = wethAddress;\\n            path[1] = buyingAddress;\\n\\n            //get amounts out\\n            uint[] memory amountsOut = iUniswapRouter.getAmountsOut(amountIn, path);\\n            uint tokenOutput = amountsOut[1];\\n\\n            //calculate slippage\\n            uint amountOutMin =  tokenOutput * (10000 - slippage) / 10000;\\n            \\n            //set deadline\\n            uint deadline = block.timestamp + swapTimeLimit;\\n\\n            //swap Eth for tokens and set return amounts\\n            uint[] memory amounts = iUniswapRouter.swapExactETHForTokens{value: amountIn}(amountOutMin, path, address(this), deadline);\\n        }\\n\\n        //update balance\\n        updateAssetBalance(currentIndex);\\n    }\\n\\n    function updateAssetBalance(uint currentIndex) internal {\\n        Asset memory asset = assets[currentIndex];\\n\\n        //set balance\\n        uint balance;\\n\\n        //set Weth address\\n        address wethAddress = config.wethAddress;\\n\\n        if (asset.tokenAddress == wethAddress) {\\n            //get balance\\n            balance = iWeth.balanceOf(address(this));\\n        }\\n        else {\\n            //create pair instance\\n            IUniswapV2Pair pair = IUniswapV2Pair(asset.tokenAddress);\\n\\n            //get balance\\n            balance = pair.balanceOf(address(this));\\n        }\\n\\n        //update balance\\n        assets[currentIndex].amount = balance;\\n    }\\n\\n    function rebalance() onlyOwner public {\\n        //set rebalancing true \\n        rebalancing = true;\\n\\n        //empty assets\\n        emptyAssets();\\n\\n        //spread to assets\\n        spreadToAssets();    \\n\\n        //set rebalancing back to false\\n        rebalancing = false;  \\n    }\\n\\n    function emptyAssets() onlyOwner internal {\\n        //for every asset\\n        for (uint i=0; i<totalAssets; i++) {\\n            //get asset and ratio\\n            Asset memory asset = assets[i];\\n\\n            //if asset balance not empty\\n            if (asset.amount > 0) {\\n                //empty asset\\n                emptyAsset(i);\\n            }   \\n        }\\n    }\\n\\n    function emptyAsset(uint currentIndex) internal {\\n        //set asset data\\n        Asset memory asset = assets[currentIndex];\\n        address sellingAddress = asset.tokenAddress;\\n        address wethAddress = config.wethAddress;\\n\\n        //get swap config\\n        uint slippage = config.slippage;\\n        uint swapTimeLimit = config.swapTimeLimit;\\n\\n        require(asset.amount > 0, \\\"Asset is already empty\\\");\\n\\n        if (sellingAddress == wethAddress) {\\n            //deposit to Wrapped WETH\\n            iWeth.withdraw(asset.amount);\\n        }\\n        else {\\n            //set path\\n            address[] memory path = new address[](2);\\n            path[0] = sellingAddress;\\n            path[1] = wethAddress;\\n\\n            //get amounts out\\n            uint[] memory amountsOut = iUniswapRouter.getAmountsOut(asset.amount, path);\\n            uint tokenOutput = amountsOut[1];\\n\\n            //calculate slippage\\n            uint amountOutMin =  tokenOutput * (10000 - slippage) / 10000;\\n            \\n            //set deadline\\n            uint deadline = block.timestamp + swapTimeLimit;\\n\\n            IUniswapV2Pair pair = IUniswapV2Pair(sellingAddress);\\n            pair.approve(address(iUniswapRouter), asset.amount);\\n\\n            //swap Eth for tokens and set return amounts\\n            iUniswapRouter.swapExactTokensForETH(asset.amount, amountOutMin, path, address(this), deadline);\\n        }\\n\\n        //update asset balance\\n        updateAssetBalance(currentIndex);\\n    }\\n\\n    function configure(uint _slippage, uint _swapTimeLimit, address _uniswapRouterAddress, address _wethAddress) onlyOwner public {\\n        config = Config({\\n            slippage: _slippage,\\n            swapTimeLimit: _swapTimeLimit,\\n            uniswapRouterAddress: _uniswapRouterAddress,\\n            wethAddress:_wethAddress\\n        });\\n\\n        //set interface instances\\n        iUniswapRouter = IUniswapV2Router(config.uniswapRouterAddress);\\n        iWeth = IWETH(config.wethAddress);\\n\\n        //set configured to true\\n        configured = true;\\n    }\\n\\n    function rename(string memory newName) onlyOwner public {\\n        name = newName;\\n    }\\n\\n    function deposit() public payable {\\n        require(configured, \\\"Configure portfolio\\\");\\n\\n        if (!rebalancing) {\\n            spreadToAssets();\\n        }\\n    }\\n\\n    function withdraw(uint amount) onlyOwner public {\\n        //set state\\n        rebalancing = true;\\n\\n        emptyAssets();\\n\\n        //transfer to owner\\n        owner.call{value: amount}(\\\"\\\");\\n\\n        spreadToAssets();\\n\\n        rebalancing = false;\\n    }\\n\\n    function withdrawAll() onlyOwner public {\\n        //set state\\n        rebalancing = true;\\n\\n        emptyAssets();\\n\\n        //transfer to owner\\n        owner.call{value: address(this).balance}(\\\"\\\");\\n\\n        spreadToAssets();\\n\\n        rebalancing = false;\\n    }\\n\\n    function getTotalAssets() public view returns (uint) {\\n        return totalAssets;\\n    }\\n\\n    function getAssetDetails(uint i) public view returns (string memory, string memory, address, uint, uint) {\\n        return (assets[i].name, assets[i].symbol, assets[i].tokenAddress, assets[i].ratio, assets[i].amount);\\n    }\\n    \\n\\n    receive() external payable {\\n        deposit();\\n    }\\n}\\n\\n// File: contracts/wealthWallet.sol\\n\\npragma solidity ^0.7.6;\\n\\n\\ncontract WealthWallet {\\n    address public owner;\\n    uint public totalPortfolios;\\n    mapping(uint => Portfolio) public portfolios;\\n    bool public defaultSet;\\n    uint public defaultPortfolio;\\n    \\n    constructor(address _owner) public {\\n        owner = _owner;\\n        defaultSet = false;\\n        totalPortfolios = 0;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Only owner can call this function.\\\");\\n        _;\\n    }\\n\\n    function createPortfolio(string memory _name) onlyOwner public {\\n        Portfolio portfolio = new Portfolio(owner, _name);\\n\\n        portfolios[totalPortfolios] = portfolio;\\n\\n        //if there is no default portfolio\\n        if (!defaultSet) {\\n            //set default to this\\n            defaultPortfolio = totalPortfolios;\\n            defaultSet = true;\\n        }\\n\\n        //update total portfolios\\n        totalPortfolios+=1;\\n    }\\n\\n    function addFunds() public payable {\\n        require(defaultSet, \\\"Create a portfolio\\\");\\n        \\n        fundPortfolio(defaultPortfolio);\\n    }\\n\\n    function fundPortfolio(uint portfolioIndex) public payable {\\n        //get portfolio\\n        Portfolio portfolio = portfolios[portfolioIndex];\\n\\n        //fund portfolio with msg value\\n        address(portfolio).call{value: msg.value}(\\\"\\\");\\n    }\\n\\n    function setDefault(uint portfolioIndex) onlyOwner public {\\n        require(portfolioIndex < totalPortfolios, \\\"Portfolio doesn't exist\\\");\\n\\n        //sets new default portfolio\\n        defaultPortfolio = portfolioIndex;\\n    }\\n\\n    function getOwner() public view returns (address) {\\n        return owner;\\n    }\\n    function getTotalPortfolios() public view returns (uint) {\\n        return totalPortfolios;\\n    }\\n    function getPortfolio(uint portfolioIndex) public view returns (address) {\\n        return address(portfolios[portfolioIndex]);\\n    }\\n\\n    receive() external payable {\\n        addFunds();\\n    }\\n}\\n\\n// File: contracts/wealthWalletFactory.sol\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\n\\ncontract WealthWalletFactory {\\n    mapping(address => WealthWallet) public wealthWallets;\\n\\n    function createWealthWallet() external {\\n        require(address(wealthWallets[msg.sender]) == address(0), \\\"Wealthwallet already exists\\\");\\n\\n        //create wealth wallet\\n        WealthWallet wealthWallet = new WealthWallet(msg.sender);\\n\\n        //map wealth wallet to sender\\n        wealthWallets[msg.sender] = wealthWallet;\\n    }\\n\\n    function getWealthWallet() external view returns (address) {\\n        return address(wealthWallets[msg.sender]);\\n    }\\n    \\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"createWealthWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWealthWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wealthWallets\",\"outputs\":[{\"internalType\":\"contract WealthWallet\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WealthWalletFactory","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}