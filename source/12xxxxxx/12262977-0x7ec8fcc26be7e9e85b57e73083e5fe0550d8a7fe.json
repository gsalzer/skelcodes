{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/governance/KyberGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\\nimport {PermissionAdmin} from '@kyber.network/utils-sc/contracts/PermissionAdmin.sol';\\nimport {IKyberGovernance} from '../interfaces/governance/IKyberGovernance.sol';\\nimport {IExecutorWithTimelock} from '../interfaces/governance/IExecutorWithTimelock.sol';\\nimport {IVotingPowerStrategy} from '../interfaces/governance/IVotingPowerStrategy.sol';\\nimport {IProposalValidator} from '../interfaces/governance/IProposalValidator.sol';\\nimport {getChainId} from '../misc/Helpers.sol';\\n\\n/**\\n * @title Kyber Governance contract for Kyber 3.0\\n * - Create a Proposal\\n * - Cancel a Proposal\\n * - Queue a Proposal\\n * - Execute a Proposal\\n * - Submit Vote to a Proposal\\n * Proposal States : Pending => Active => Succeeded(/Failed/Finalized)\\n *                   => Queued => Executed(/Expired)\\n *                   The transition to \\\"Canceled\\\" can appear in multiple states\\n **/\\ncontract KyberGovernance is IKyberGovernance, PermissionAdmin {\\n  using SafeMath for uint256;\\n\\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\\n  );\\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256(\\n    'VoteEmitted(uint256 id,uint256 optionBitMask)'\\n  );\\n  string public constant NAME = 'Kyber Governance';\\n\\n  address private _daoOperator;\\n  uint256 private _proposalsCount;\\n  mapping(uint256 => Proposal) private _proposals;\\n  mapping(address => bool) private _authorizedExecutors;\\n  mapping(address => bool) private _authorizedVotingPowerStrategies;\\n\\n  constructor(\\n    address admin,\\n    address daoOperator,\\n    address[] memory executors,\\n    address[] memory votingPowerStrategies\\n  ) PermissionAdmin(admin) {\\n    require(daoOperator != address(0), 'invalid dao operator');\\n    _daoOperator = daoOperator;\\n\\n    _authorizeExecutors(executors);\\n    _authorizeVotingPowerStrategies(votingPowerStrategies);\\n  }\\n\\n  /**\\n   * @dev Creates a Binary Proposal (needs to be validated by the Proposal Validator)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy voting power strategy of the proposal\\n   * @param executionParams data for execution, includes\\n   *   targets list of contracts called by proposal's associated transactions\\n   *   weiValues list of value in wei for each proposal's associated transaction\\n   *   signatures list of function signatures (can be empty) to be used when created the callData\\n   *   calldatas list of calldatas: if associated signature empty,\\n   *        calldata ready, else calldata is arguments\\n   *   withDelegatecalls boolean, true = transaction delegatecalls the taget,\\n   *         else calls the target\\n   * @param startTime start timestamp to allow vote\\n   * @param endTime end timestamp of the proposal\\n   * @param link link to the proposal description\\n   **/\\n  function createBinaryProposal(\\n    IExecutorWithTimelock executor,\\n    IVotingPowerStrategy strategy,\\n    BinaryProposalParams memory executionParams,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string memory link\\n  ) external override returns (uint256 proposalId) {\\n    require(executionParams.targets.length != 0, 'create binary invalid empty targets');\\n    require(\\n      executionParams.targets.length == executionParams.weiValues.length &&\\n        executionParams.targets.length == executionParams.signatures.length &&\\n        executionParams.targets.length == executionParams.calldatas.length &&\\n        executionParams.targets.length == executionParams.withDelegatecalls.length,\\n      'create binary inconsistent params length'\\n    );\\n\\n    require(isExecutorAuthorized(address(executor)), 'create binary executor not authorized');\\n    require(\\n      isVotingPowerStrategyAuthorized(address(strategy)),\\n      'create binary strategy not authorized'\\n    );\\n\\n    proposalId = _proposalsCount;\\n    require(\\n      IProposalValidator(address(executor)).validateBinaryProposalCreation(\\n        strategy,\\n        msg.sender,\\n        startTime,\\n        endTime,\\n        _daoOperator\\n      ),\\n      'validate proposal creation invalid'\\n    );\\n\\n    ProposalWithoutVote storage newProposalData = _proposals[proposalId].proposalData;\\n    newProposalData.id = proposalId;\\n    newProposalData.proposalType = ProposalType.Binary;\\n    newProposalData.creator = msg.sender;\\n    newProposalData.executor = executor;\\n    newProposalData.targets = executionParams.targets;\\n    newProposalData.weiValues = executionParams.weiValues;\\n    newProposalData.signatures = executionParams.signatures;\\n    newProposalData.calldatas = executionParams.calldatas;\\n    newProposalData.withDelegatecalls = executionParams.withDelegatecalls;\\n    newProposalData.startTime = startTime;\\n    newProposalData.endTime = endTime;\\n    newProposalData.strategy = strategy;\\n    newProposalData.link = link;\\n\\n    // only 2 options, YES and NO\\n    newProposalData.options.push('YES');\\n    newProposalData.options.push('NO');\\n    newProposalData.voteCounts.push(0);\\n    newProposalData.voteCounts.push(0);\\n    // use max voting power to finalise the proposal\\n    newProposalData.maxVotingPower = strategy.getMaxVotingPower();\\n\\n    _proposalsCount++;\\n    // call strategy to record data if needed\\n    strategy.handleProposalCreation(proposalId, startTime, endTime);\\n\\n    emit BinaryProposalCreated(\\n      proposalId,\\n      msg.sender,\\n      executor,\\n      strategy,\\n      executionParams.targets,\\n      executionParams.weiValues,\\n      executionParams.signatures,\\n      executionParams.calldatas,\\n      executionParams.withDelegatecalls,\\n      startTime,\\n      endTime,\\n      link,\\n      newProposalData.maxVotingPower\\n    );\\n  }\\n\\n  /**\\n   * @dev Creates a Generic Proposal (needs to be validated by the Proposal Validator)\\n   *    It only gets the winning option without any executions\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy voting power strategy of the proposal\\n   * @param options list of options to vote for\\n   * @param startTime start timestamp to allow vote\\n   * @param endTime end timestamp of the proposal\\n   * @param link link to the proposal description\\n   **/\\n  function createGenericProposal(\\n    IExecutorWithTimelock executor,\\n    IVotingPowerStrategy strategy,\\n    string[] memory options,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string memory link\\n  )\\n    external override returns (uint256 proposalId)\\n  {\\n    require(\\n      isExecutorAuthorized(address(executor)),\\n      'create generic executor not authorized'\\n    );\\n    require(\\n      isVotingPowerStrategyAuthorized(address(strategy)),\\n      'create generic strategy not authorized'\\n    );\\n    proposalId = _proposalsCount;\\n    require(\\n      IProposalValidator(address(executor)).validateGenericProposalCreation(\\n        strategy,\\n        msg.sender,\\n        startTime,\\n        endTime,\\n        options,\\n        _daoOperator\\n      ),\\n      'validate proposal creation invalid'\\n    );\\n    Proposal storage newProposal = _proposals[proposalId];\\n    ProposalWithoutVote storage newProposalData = newProposal.proposalData;\\n    newProposalData.id = proposalId;\\n    newProposalData.proposalType = ProposalType.Generic;\\n    newProposalData.creator = msg.sender;\\n    newProposalData.executor = executor;\\n    newProposalData.startTime = startTime;\\n    newProposalData.endTime = endTime;\\n    newProposalData.strategy = strategy;\\n    newProposalData.link = link;\\n    newProposalData.options = options;\\n    newProposalData.voteCounts = new uint256[](options.length);\\n    // use max voting power to finalise the proposal\\n    newProposalData.maxVotingPower = strategy.getMaxVotingPower();\\n\\n    _proposalsCount++;\\n    // call strategy to record data if needed\\n    strategy.handleProposalCreation(proposalId, startTime, endTime);\\n\\n    emit GenericProposalCreated(\\n      proposalId,\\n      msg.sender,\\n      executor,\\n      strategy,\\n      options,\\n      startTime,\\n      endTime,\\n      link,\\n      newProposalData.maxVotingPower\\n    );\\n  }\\n\\n  /**\\n   * @dev Cancels a Proposal.\\n   * - Callable by the _daoOperator with relaxed conditions,\\n   *   or by anybody if the conditions of cancellation on the executor are fulfilled\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external override {\\n    require(proposalId < _proposalsCount, 'invalid proposal id');\\n    ProposalState state = getProposalState(proposalId);\\n    require(\\n      state != ProposalState.Executed &&\\n        state != ProposalState.Canceled &&\\n        state != ProposalState.Expired &&\\n        state != ProposalState.Finalized,\\n      'invalid state to cancel'\\n    );\\n\\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\\n    require(\\n      msg.sender == _daoOperator ||\\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\\n          IKyberGovernance(this),\\n          proposalId,\\n          proposal.creator\\n        ),\\n      'validate proposal cancellation failed'\\n    );\\n    proposal.canceled = true;\\n    if (proposal.proposalType == ProposalType.Binary) {\\n      for (uint256 i = 0; i < proposal.targets.length; i++) {\\n        proposal.executor.cancelTransaction(\\n          proposal.targets[i],\\n          proposal.weiValues[i],\\n          proposal.signatures[i],\\n          proposal.calldatas[i],\\n          proposal.executionTime,\\n          proposal.withDelegatecalls[i]\\n        );\\n      }\\n    }\\n    // notify voting power strategy about the cancellation\\n    proposal.strategy.handleProposalCancellation(proposalId);\\n\\n    emit ProposalCanceled(proposalId);\\n  }\\n\\n  /**\\n   * @dev Queue the proposal (If Proposal Succeeded), only for Binary proposals\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external override {\\n    require(proposalId < _proposalsCount, 'invalid proposal id');\\n    require(\\n      getProposalState(proposalId) == ProposalState.Succeeded,\\n      'invalid state to queue'\\n    );\\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\\n    // generic proposal does not have Succeeded state\\n    assert(proposal.proposalType == ProposalType.Binary);\\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      _queueOrRevert(\\n        proposal.executor,\\n        proposal.targets[i],\\n        proposal.weiValues[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n    proposal.executionTime = executionTime;\\n\\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Execute the proposal (If Proposal Queued), only for Binary proposals\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external override payable {\\n    require(proposalId < _proposalsCount, 'invalid proposal id');\\n    require(getProposalState(proposalId) == ProposalState.Queued, 'only queued proposals');\\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\\n    // generic proposal does not have Queued state\\n    assert(proposal.proposalType == ProposalType.Binary);\\n    proposal.executed = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      proposal.executor.executeTransaction{value: proposal.weiValues[i]}(\\n        proposal.targets[i],\\n        proposal.weiValues[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.executionTime,\\n        proposal.withDelegatecalls[i]\\n      );\\n    }\\n    emit ProposalExecuted(proposalId, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param optionBitMask bitmask optionBitMask of voter\\n   *  for Binary Proposal, optionBitMask should be either 1 or 2 (Accept/Reject)\\n   *  for Generic Proposal, optionBitMask is the bitmask of voted options\\n   **/\\n  function submitVote(uint256 proposalId, uint256 optionBitMask) external override {\\n    return _submitVote(msg.sender, proposalId, optionBitMask);\\n  }\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param optionBitMask the bit mask of voted options\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    uint256 optionBitMask,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external override {\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\n        '\\\\x19\\\\x01',\\n        keccak256(\\n          abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))\\n        ),\\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, optionBitMask))\\n      )\\n    );\\n    address signer = ecrecover(digest, v, r, s);\\n    require(signer != address(0), 'invalid signature');\\n    return _submitVote(signer, proposalId, optionBitMask);\\n  }\\n\\n  /**\\n   * @dev Function to handle voting power changed for a voter\\n   *  caller must be the voting power strategy of the proposal\\n   * @param voter address that has changed the voting power\\n   * @param newVotingPower new voting power of that address,\\n   *   old voting power can be taken from records\\n   * @param proposalIds list proposal ids that belongs to this voting power strategy\\n   *   should update the voteCound of the active proposals in the list\\n   **/\\n  function handleVotingPowerChanged(\\n    address voter,\\n    uint256 newVotingPower,\\n    uint256[] calldata proposalIds\\n  ) external override {\\n    uint224 safeNewVotingPower = _safeUint224(newVotingPower);\\n    for (uint256 i = 0; i < proposalIds.length; i++) {\\n      // only update for active proposals\\n      if (getProposalState(proposalIds[i]) != ProposalState.Active) continue;\\n      ProposalWithoutVote storage proposal = _proposals[proposalIds[i]].proposalData;\\n      require(address(proposal.strategy) == msg.sender, 'invalid voting power strategy');\\n      Vote memory vote = _proposals[proposalIds[i]].votes[voter];\\n      if (vote.optionBitMask == 0) continue; // not voted yet\\n      uint256 oldVotingPower = uint256(vote.votingPower);\\n      // update totalVotes of the proposal\\n      proposal.totalVotes = proposal.totalVotes.add(newVotingPower).sub(oldVotingPower);\\n      for (uint256 j = 0; j < proposal.options.length; j++) {\\n        if (vote.optionBitMask & (2**j) == 2**j) {\\n          // update voteCounts for each voted option\\n          proposal.voteCounts[j] = proposal.voteCounts[j].add(newVotingPower).sub(oldVotingPower);\\n        }\\n      }\\n      // update voting power of the voter\\n      _proposals[proposalIds[i]].votes[voter].votingPower = safeNewVotingPower;\\n      emit VotingPowerChanged(\\n        proposalIds[i],\\n        voter,\\n        vote.optionBitMask,\\n        vote.votingPower,\\n        safeNewVotingPower\\n      );\\n    }\\n  }\\n\\n  /**\\n  * @dev Transfer dao operator\\n  * @param newDaoOperator new dao operator\\n  **/\\n  function transferDaoOperator(address newDaoOperator) external {\\n    require(msg.sender == _daoOperator, 'only dao operator');\\n    require(newDaoOperator != address(0), 'invalid dao operator');\\n    _daoOperator = newDaoOperator;\\n    emit DaoOperatorTransferred(newDaoOperator);\\n  }\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] memory executors)\\n    public override onlyAdmin\\n  {\\n    _authorizeExecutors(executors);\\n  }\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] memory executors)\\n    public override onlyAdmin\\n  {\\n    _unauthorizeExecutors(executors);\\n  }\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized strategies\\n   * @param strategies list of new addresses to be authorized strategies\\n   **/\\n  function authorizeVotingPowerStrategies(address[] memory strategies)\\n    public override onlyAdmin\\n  {\\n    _authorizeVotingPowerStrategies(strategies);\\n  }\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized strategies\\n   * @param strategies list of addresses to be removed as authorized strategies\\n   **/\\n  function unauthorizeVotingPowerStrategies(address[] memory strategies)\\n    public\\n    override\\n    onlyAdmin\\n  {\\n    _unauthorizedVotingPowerStrategies(strategies);\\n  }\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) public override view returns (bool) {\\n    return _authorizedExecutors[executor];\\n  }\\n\\n  /**\\n   * @dev Returns whether an address is an authorized strategy\\n   * @param strategy address to evaluate as authorized strategy\\n   * @return true if authorized\\n   **/\\n  function isVotingPowerStrategyAuthorized(address strategy) public override view returns (bool) {\\n    return _authorizedVotingPowerStrategies[strategy];\\n  }\\n\\n  /**\\n   * @dev Getter the address of the daoOperator, that can mainly cancel proposals\\n   * @return The address of the daoOperator\\n   **/\\n  function getDaoOperator() external override view returns (address) {\\n    return _daoOperator;\\n  }\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external override view returns (uint256) {\\n    return _proposalsCount;\\n  }\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVote memory object\\n   **/\\n  function getProposalById(uint256 proposalId)\\n    external\\n    override\\n    view\\n    returns (ProposalWithoutVote memory)\\n  {\\n    return _proposals[proposalId].proposalData;\\n  }\\n\\n  /**\\n   * @dev Getter of the vote data of a proposal by id\\n   * including totalVotes, voteCounts and options\\n   * @param proposalId id of the proposal\\n   * @return (totalVotes, voteCounts, options)\\n   **/\\n  function getProposalVoteDataById(uint256 proposalId)\\n    external\\n    override\\n    view\\n    returns (\\n      uint256,\\n      uint256[] memory,\\n      string[] memory\\n    )\\n  {\\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\\n    return (proposal.totalVotes, proposal.voteCounts, proposal.options);\\n  }\\n\\n  /**\\n   * @dev Getter of the Vote of a voter about a proposal\\n   * Note: Vote is a struct: ({uint32 bitOptionMask, uint224 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote memory object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter)\\n    external\\n    override\\n    view\\n    returns (Vote memory)\\n  {\\n    return _proposals[proposalId].votes[voter];\\n  }\\n\\n  /**\\n   * @dev Get the current state of a proposal\\n   * @param proposalId id of the proposal\\n   * @return The current state if the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) public override view returns (ProposalState) {\\n    require(proposalId < _proposalsCount, 'invalid proposal id');\\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\\n    if (proposal.canceled) {\\n      return ProposalState.Canceled;\\n    } else if (block.timestamp < proposal.startTime) {\\n      return ProposalState.Pending;\\n    } else if (block.timestamp <= proposal.endTime) {\\n      return ProposalState.Active;\\n    } else if (proposal.proposalType == ProposalType.Generic) {\\n      return ProposalState.Finalized;\\n    } else if (\\n      !IProposalValidator(address(proposal.executor)).isBinaryProposalPassed(\\n        IKyberGovernance(this),\\n        proposalId\\n      )\\n    ) {\\n      return ProposalState.Failed;\\n    } else if (proposal.executionTime == 0) {\\n      return ProposalState.Succeeded;\\n    } else if (proposal.executed) {\\n      return ProposalState.Executed;\\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\\n      return ProposalState.Expired;\\n    } else {\\n      return ProposalState.Queued;\\n    }\\n  }\\n\\n  function _queueOrRevert(\\n    IExecutorWithTimelock executor,\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory callData,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) internal {\\n    require(\\n      !executor.isActionQueued(\\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\\n      ),\\n      'duplicated action'\\n    );\\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\\n  }\\n\\n  function _submitVote(\\n    address voter,\\n    uint256 proposalId,\\n    uint256 optionBitMask\\n  ) internal {\\n    require(proposalId < _proposalsCount, 'invalid proposal id');\\n    require(getProposalState(proposalId) == ProposalState.Active, 'voting closed');\\n    ProposalWithoutVote storage proposal = _proposals[proposalId].proposalData;\\n    uint256 numOptions = proposal.options.length;\\n    if (proposal.proposalType == ProposalType.Binary) {\\n      // either Yes (1) or No (2)\\n      require(optionBitMask == 1 || optionBitMask == 2, 'wrong vote for binary proposal');\\n    } else {\\n      require(\\n        optionBitMask > 0 && optionBitMask < 2**numOptions,\\n        'invalid options for generic proposal'\\n      );\\n    }\\n\\n    Vote memory vote = _proposals[proposalId].votes[voter];\\n    uint256 votingPower = proposal.strategy.handleVote(voter, proposalId, optionBitMask);\\n    if (vote.optionBitMask == 0) {\\n      // first time vote, increase the totalVotes of the proposal\\n      proposal.totalVotes = proposal.totalVotes.add(votingPower);\\n    }\\n    for (uint256 i = 0; i < proposal.options.length; i++) {\\n      bool hasVoted = (vote.optionBitMask & (2**i)) == 2**i;\\n      bool isVoting = (optionBitMask & (2**i)) == 2**i;\\n      if (hasVoted && !isVoting) {\\n        proposal.voteCounts[i] = proposal.voteCounts[i].sub(votingPower);\\n      } else if (!hasVoted && isVoting) {\\n        proposal.voteCounts[i] = proposal.voteCounts[i].add(votingPower);\\n      }\\n    }\\n\\n    _proposals[proposalId].votes[voter] = Vote({\\n      optionBitMask: _safeUint32(optionBitMask),\\n      votingPower: _safeUint224(votingPower)\\n    });\\n    emit VoteEmitted(proposalId, voter, _safeUint32(optionBitMask), _safeUint224(votingPower));\\n  }\\n\\n  function _authorizeExecutors(address[] memory executors) internal {\\n    for(uint256 i = 0; i < executors.length; i++) {\\n      _authorizedExecutors[executors[i]] = true;\\n      emit ExecutorAuthorized(executors[i]);\\n    }\\n  }\\n\\n  function _unauthorizeExecutors(address[] memory executors) internal {\\n    for(uint256 i = 0; i < executors.length; i++) {\\n      _authorizedExecutors[executors[i]] = false;\\n      emit ExecutorUnauthorized(executors[i]);\\n    }\\n  }\\n\\n  function _authorizeVotingPowerStrategies(address[] memory strategies) internal {\\n    for(uint256 i = 0; i < strategies.length; i++) {\\n      _authorizedVotingPowerStrategies[strategies[i]] = true;\\n      emit VotingPowerStrategyAuthorized(strategies[i]);\\n    }\\n  }\\n\\n  function _unauthorizedVotingPowerStrategies(address[] memory strategies) internal {\\n    for(uint256 i = 0; i < strategies.length; i++) {\\n      _authorizedVotingPowerStrategies[strategies[i]] = false;\\n      emit VotingPowerStrategyUnauthorized(strategies[i]);\\n    }\\n  }\\n\\n  function _safeUint224(uint256 value) internal pure returns (uint224) {\\n    require(value < 2**224 - 1, 'value is too big (uint224)');\\n    return uint224(value);\\n  }\\n\\n  function _safeUint32(uint256 value) internal pure returns (uint32) {\\n    require(value < 2**32 - 1, 'value is too big (uint32)');\\n    return uint32(value);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@kyber.network/utils-sc/contracts/PermissionAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n\\nabstract contract PermissionAdmin {\\n    address public admin;\\n    address public pendingAdmin;\\n\\n    event AdminClaimed(address newAdmin, address previousAdmin);\\n\\n    event TransferAdminPending(address pendingAdmin);\\n\\n    constructor(address _admin) {\\n        require(_admin != address(0), \\\"admin 0\\\");\\n        admin = _admin;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the pendingAdmin address.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdmin(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0), \\\"new admin 0\\\");\\n        emit TransferAdminPending(newAdmin);\\n        pendingAdmin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0), \\\"admin 0\\\");\\n        emit TransferAdminPending(newAdmin);\\n        emit AdminClaimed(newAdmin, admin);\\n        admin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\\n     */\\n    function claimAdmin() public {\\n        require(pendingAdmin == msg.sender, \\\"not pending\\\");\\n        emit AdminClaimed(pendingAdmin, admin);\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IKyberGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IExecutorWithTimelock} from './IExecutorWithTimelock.sol';\\nimport {IVotingPowerStrategy} from './IVotingPowerStrategy.sol';\\n\\ninterface IKyberGovernance {\\n  enum ProposalState {\\n    Pending,\\n    Canceled,\\n    Active,\\n    Failed,\\n    Succeeded,\\n    Queued,\\n    Expired,\\n    Executed,\\n    Finalized\\n  }\\n  enum ProposalType {Generic, Binary}\\n\\n  /// For Binary proposal, optionBitMask is 0/1/2\\n  /// For Generic proposal, optionBitMask is bitmask of voted options\\n  struct Vote {\\n    uint32 optionBitMask;\\n    uint224 votingPower;\\n  }\\n\\n  struct ProposalWithoutVote {\\n    uint256 id;\\n    ProposalType proposalType;\\n    address creator;\\n    IExecutorWithTimelock executor;\\n    IVotingPowerStrategy strategy;\\n    address[] targets;\\n    uint256[] weiValues;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    string[] options;\\n    uint256[] voteCounts;\\n    uint256 totalVotes;\\n    uint256 maxVotingPower;\\n    uint256 startTime;\\n    uint256 endTime;\\n    uint256 executionTime;\\n    string link;\\n    bool executed;\\n    bool canceled;\\n  }\\n\\n  struct Proposal {\\n    ProposalWithoutVote proposalData;\\n    mapping(address => Vote) votes;\\n  }\\n\\n  struct BinaryProposalParams {\\n    address[] targets;\\n    uint256[] weiValues;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n  }\\n\\n  /**\\n   * @dev emitted when a new binary proposal is created\\n   * @param proposalId id of the binary proposal\\n   * @param creator address of the creator\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param targets list of contracts called by proposal's associated transactions\\n   * @param weiValues list of value in wei for each propoposal's associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used\\n   *     when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty,\\n   *     calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget,\\n   *    else calls the target\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   * @param maxVotingPower max voting power for this proposal\\n   **/\\n  event BinaryProposalCreated(\\n    uint256 proposalId,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    IVotingPowerStrategy indexed strategy,\\n    address[] targets,\\n    uint256[] weiValues,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    bool[] withDelegatecalls,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string link,\\n    uint256 maxVotingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a new generic proposal is created\\n   * @param proposalId id of the generic proposal\\n   * @param creator address of the creator\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param options list of proposal vote options\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   * @param maxVotingPower max voting power for this proposal\\n   **/\\n  event GenericProposalCreated(\\n    uint256 proposalId,\\n    address indexed creator,\\n    IExecutorWithTimelock indexed executor,\\n    IVotingPowerStrategy indexed strategy,\\n    string[] options,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string link,\\n    uint256 maxVotingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a proposal is canceled\\n   * @param proposalId id of the proposal\\n   **/\\n  event ProposalCanceled(uint256 proposalId);\\n\\n  /**\\n   * @dev emitted when a proposal is queued\\n   * @param proposalId id of the proposal\\n   * @param executionTime time when proposal underlying transactions can be executed\\n   * @param initiatorQueueing address of the initiator of the queuing transaction\\n   **/\\n  event ProposalQueued(\\n    uint256 indexed proposalId,\\n    uint256 executionTime,\\n    address indexed initiatorQueueing\\n  );\\n  /**\\n   * @dev emitted when a proposal is executed\\n   * @param proposalId id of the proposal\\n   * @param initiatorExecution address of the initiator of the execution transaction\\n   **/\\n  event ProposalExecuted(uint256 proposalId, address indexed initiatorExecution);\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @param voteOptions vote options selected by voter\\n   * @param votingPower Power of the voter/vote\\n   **/\\n  event VoteEmitted(\\n    uint256 indexed proposalId,\\n    address indexed voter,\\n    uint32 indexed voteOptions,\\n    uint224 votingPower\\n  );\\n\\n  /**\\n   * @dev emitted when a vote is registered\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @param voteOptions vote options selected by voter\\n   * @param oldVotingPower Old power of the voter/vote\\n   * @param newVotingPower New power of the voter/vote\\n   **/\\n  event VotingPowerChanged(\\n    uint256 indexed proposalId,\\n    address indexed voter,\\n    uint32 indexed voteOptions,\\n    uint224 oldVotingPower,\\n    uint224 newVotingPower\\n  );\\n\\n  event DaoOperatorTransferred(address indexed newDaoOperator);\\n\\n  event ExecutorAuthorized(address indexed executor);\\n\\n  event ExecutorUnauthorized(address indexed executor);\\n\\n  event VotingPowerStrategyAuthorized(address indexed strategy);\\n\\n  event VotingPowerStrategyUnauthorized(address indexed strategy);\\n\\n  /**\\n   * @dev Function is triggered when users withdraw from staking and change voting power\\n   */\\n  function handleVotingPowerChanged(\\n    address staker,\\n    uint256 newVotingPower,\\n    uint256[] calldata proposalIds\\n  ) external;\\n\\n  /**\\n   * @dev Creates a Binary Proposal (needs to be validated by the Proposal Validator)\\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy voting power strategy of the proposal\\n   * @param executionParams data for execution, includes\\n   *   targets list of contracts called by proposal's associated transactions\\n   *   weiValues list of value in wei for each proposal's associated transaction\\n   *   signatures list of function signatures (can be empty)\\n   *        to be used when created the callData\\n   *   calldatas list of calldatas: if associated signature empty,\\n   *        calldata ready, else calldata is arguments\\n   *   withDelegatecalls boolean, true = transaction delegatecalls the taget,\\n   *        else calls the target\\n   * @param startTime start timestamp to allow vote\\n   * @param endTime end timestamp of the proposal\\n   * @param link link to the proposal description\\n   **/\\n  function createBinaryProposal(\\n    IExecutorWithTimelock executor,\\n    IVotingPowerStrategy strategy,\\n    BinaryProposalParams memory executionParams,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string memory link\\n  ) external returns (uint256 proposalId);\\n\\n  /**\\n   * @dev Creates a Generic Proposal\\n   * @param executor ExecutorWithTimelock contract that will execute the proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param options list of proposal vote options\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param link URL link of the proposal\\n   **/\\n  function createGenericProposal(\\n    IExecutorWithTimelock executor,\\n    IVotingPowerStrategy strategy,\\n    string[] memory options,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string memory link\\n  ) external returns (uint256 proposalId);\\n\\n  /**\\n   * @dev Cancels a Proposal,\\n   * either at anytime by guardian\\n   * or when proposal is Pending/Active and threshold no longer reached\\n   * @param proposalId id of the proposal\\n   **/\\n  function cancel(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Queue the proposal (If Proposal Succeeded)\\n   * @param proposalId id of the proposal to queue\\n   **/\\n  function queue(uint256 proposalId) external;\\n\\n  /**\\n   * @dev Execute the proposal (If Proposal Queued)\\n   * @param proposalId id of the proposal to execute\\n   **/\\n  function execute(uint256 proposalId) external payable;\\n\\n  /**\\n   * @dev Function allowing msg.sender to vote for/against a proposal\\n   * @param proposalId id of the proposal\\n   * @param optionBitMask vote option(s) selected\\n   **/\\n  function submitVote(uint256 proposalId, uint256 optionBitMask) external;\\n\\n  /**\\n   * @dev Function to register the vote of user that has voted offchain via signature\\n   * @param proposalId id of the proposal\\n   * @param choice the bit mask of voted options\\n   * @param v v part of the voter signature\\n   * @param r r part of the voter signature\\n   * @param s s part of the voter signature\\n   **/\\n  function submitVoteBySignature(\\n    uint256 proposalId,\\n    uint256 choice,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized executors\\n   * @param executors list of new addresses to be authorized executors\\n   **/\\n  function authorizeExecutors(address[] calldata executors) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized executors\\n   * @param executors list of addresses to be removed as authorized executors\\n   **/\\n  function unauthorizeExecutors(address[] calldata executors) external;\\n\\n  /**\\n   * @dev Add new addresses to the list of authorized strategies\\n   * @param strategies list of new addresses to be authorized strategies\\n   **/\\n  function authorizeVotingPowerStrategies(address[] calldata strategies) external;\\n\\n  /**\\n   * @dev Remove addresses to the list of authorized strategies\\n   * @param strategies list of addresses to be removed as authorized strategies\\n   **/\\n  function unauthorizeVotingPowerStrategies(address[] calldata strategies) external;\\n\\n  /**\\n   * @dev Returns whether an address is an authorized executor\\n   * @param executor address to evaluate as authorized executor\\n   * @return true if authorized\\n   **/\\n  function isExecutorAuthorized(address executor) external view returns (bool);\\n\\n  /**\\n   * @dev Returns whether an address is an authorized strategy\\n   * @param strategy address to evaluate as authorized strategy\\n   * @return true if authorized\\n   **/\\n  function isVotingPowerStrategyAuthorized(address strategy) external view returns (bool);\\n\\n  /**\\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\\n   * @return The address of the guardian\\n   **/\\n  function getDaoOperator() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the proposal count (the current number of proposals ever created)\\n   * @return the proposal count\\n   **/\\n  function getProposalsCount() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of a proposal by id\\n   * @param proposalId id of the proposal to get\\n   * @return the proposal as ProposalWithoutVote memory object\\n   **/\\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVote memory);\\n\\n  /**\\n   * @dev Getter of the vote data of a proposal by id\\n   * including totalVotes, voteCounts and options\\n   * @param proposalId id of the proposal\\n   * @return (totalVotes, voteCounts, options)\\n   **/\\n  function getProposalVoteDataById(uint256 proposalId)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256[] memory,\\n      string[] memory\\n    );\\n\\n  /**\\n   * @dev Getter of the Vote of a voter about a proposal\\n   * Note: Vote is a struct: ({uint32 bitOptionMask, uint224 votingPower})\\n   * @param proposalId id of the proposal\\n   * @param voter address of the voter\\n   * @return The associated Vote memory object\\n   **/\\n  function getVoteOnProposal(uint256 proposalId, address voter)\\n    external\\n    view\\n    returns (Vote memory);\\n\\n  /**\\n   * @dev Get the current state of a proposal\\n   * @param proposalId id of the proposal\\n   * @return The current state if the proposal\\n   **/\\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IKyberGovernance} from './IKyberGovernance.sol';\\n\\ninterface IExecutorWithTimelock {\\n  /**\\n   * @dev emitted when a new pending admin is set\\n   * @param newPendingAdmin address of the new pending admin\\n   **/\\n  event NewPendingAdmin(address newPendingAdmin);\\n\\n  /**\\n   * @dev emitted when a new admin is set\\n   * @param newAdmin address of the new admin\\n   **/\\n  event NewAdmin(address newAdmin);\\n\\n  /**\\n   * @dev emitted when a new delay (between queueing and execution) is set\\n   * @param delay new delay\\n   **/\\n  event NewDelay(uint256 delay);\\n\\n  /**\\n   * @dev emitted when a new (trans)action is Queued.\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event QueuedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  event CancelledAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  );\\n\\n  /**\\n   * @dev emitted when an action is Cancelled\\n   * @param actionHash hash of the action\\n   * @param target address of the targeted contract\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   * @param resultData the actual callData used on the target\\n   **/\\n  event ExecutedAction(\\n    bytes32 actionHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 executionTime,\\n    bool withDelegatecall,\\n    bytes resultData\\n  );\\n\\n  /**\\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external payable returns (bytes memory);\\n\\n  /**\\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n   * @param target smart contract target\\n   * @param value wei value of the transaction\\n   * @param signature function signature of the transaction\\n   * @param data function arguments of the transaction or callData if signature empty\\n   * @param executionTime time at which to execute the transaction\\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n   **/\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) external returns (bytes32);\\n\\n  /**\\n   * @dev Getter of the current admin address (should be governance)\\n   * @return The address of the current admin\\n   **/\\n  function getAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the current pending admin address\\n   * @return The address of the pending admin\\n   **/\\n  function getPendingAdmin() external view returns (address);\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\\n\\n  /**\\n   * @dev Checks whether a proposal is over its grace period\\n   * @param governance Governance contract\\n   * @param proposalId Id of the proposal against which to test\\n   * @return true of proposal is over grace period\\n   **/\\n  function isProposalOverGracePeriod(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Getter of grace period constant\\n   * @return grace period in seconds\\n   **/\\n  function GRACE_PERIOD() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of minimum delay constant\\n   * @return minimum delay in seconds\\n   **/\\n  function MINIMUM_DELAY() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of maximum delay constant\\n   * @return maximum delay in seconds\\n   **/\\n  function MAXIMUM_DELAY() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IVotingPowerStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IWithdrawHandler} from '../staking/IWithdrawHandler.sol';\\n\\ninterface IVotingPowerStrategy is IWithdrawHandler {\\n  /**\\n   * @dev call by governance when create a proposal\\n   */\\n  function handleProposalCreation(\\n    uint256 proposalId,\\n    uint256 startTime,\\n    uint256 endTime\\n  ) external;\\n\\n  /**\\n   * @dev call by governance when cancel a proposal\\n   */\\n  function handleProposalCancellation(uint256 proposalId) external;\\n\\n  /**\\n   * @dev call by governance when submitting a vote\\n   * @param choice: unused param for future usage\\n   * @return votingPower of voter\\n   */\\n  function handleVote(\\n    address voter,\\n    uint256 proposalId,\\n    uint256 choice\\n  ) external returns (uint256 votingPower);\\n\\n  /**\\n   * @dev get voter's voting power given timestamp\\n   * @dev for reading purposes and validating voting power for creating/canceling proposal in the furture\\n   * @dev when submitVote, should call 'handleVote' instead\\n   */\\n  function getVotingPower(address voter, uint256 timestamp)\\n    external\\n    view\\n    returns (uint256 votingPower);\\n\\n  /**\\n   * @dev validate that startTime and endTime are suitable for calculating voting power\\n   * @dev with current version, startTime and endTime must be in the sameEpcoh\\n   */\\n  function validateProposalCreation(uint256 startTime, uint256 endTime)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev getMaxVotingPower at current time\\n   * @dev call by governance when creating a proposal\\n   */\\n  function getMaxVotingPower() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/governance/IProposalValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {IKyberGovernance} from './IKyberGovernance.sol';\\nimport {IVotingPowerStrategy} from './IVotingPowerStrategy.sol';\\n\\ninterface IProposalValidator {\\n  /**\\n   * @dev Called to validate a binary proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param creator address of the creator\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param daoOperator address of daoOperator\\n   * @return boolean, true if can be created\\n   **/\\n  function validateBinaryProposalCreation(\\n    IVotingPowerStrategy strategy,\\n    address creator,\\n    uint256 startTime,\\n    uint256 endTime,\\n    address daoOperator\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Called to validate a generic proposal\\n   * @param strategy votingPowerStrategy contract to calculate voting power\\n   * @param creator address of the creator\\n   * @param startTime timestamp when vote starts\\n   * @param endTime timestamp when vote ends\\n   * @param options list of proposal vote options\\n   * @param daoOperator address of daoOperator\\n   * @return boolean, true if can be created\\n   **/\\n  function validateGenericProposalCreation(\\n    IVotingPowerStrategy strategy,\\n    address creator,\\n    uint256 startTime,\\n    uint256 endTime,\\n    string[] calldata options,\\n    address daoOperator\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Called to validate the cancellation of a proposal\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the generic proposal\\n   * @param user entity initiating the cancellation\\n   * @return boolean, true if can be cancelled\\n   **/\\n  function validateProposalCancellation(\\n    IKyberGovernance governance,\\n    uint256 proposalId,\\n    address user\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Returns whether a binary proposal passed or not\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the proposal to set\\n   * @return true if proposal passed\\n   **/\\n  function isBinaryProposalPassed(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has reached quorum\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the proposal to verify\\n   * @return voting power needed for a proposal to pass\\n   **/\\n  function isQuorumValid(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\\n   * @param governance governance contract to fetch proposals from\\n   * @param proposalId Id of the proposal to verify\\n   * @return true if enough For-Votes\\n   **/\\n  function isVoteDifferentialValid(IKyberGovernance governance, uint256 proposalId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Get maximum vote options for a generic proposal\\n   * @return the maximum no. of vote options possible for a generic proposal\\n   **/\\n  function MAX_VOTING_OPTIONS() external view returns (uint256);\\n\\n  /**\\n   * @dev Get minimum voting duration constant value\\n   * @return the minimum voting duration value in seconds\\n   **/\\n  function MIN_VOTING_DURATION() external view returns (uint256);\\n\\n  /**\\n   * @dev Get the vote differential threshold constant value\\n   * to compare with % of for votes/total supply - % of against votes/total supply\\n   * @return the vote differential threshold value (100 <=> 1%)\\n   **/\\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\\n\\n  /**\\n   * @dev Get quorum threshold constant value\\n   * to compare with % of for votes/total supply\\n   * @return the quorum threshold value (100 <=> 1%)\\n   **/\\n  function MINIMUM_QUORUM() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/misc/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nfunction getChainId() pure returns (uint256) {\\n  uint256 chainId;\\n  assembly {\\n    chainId := chainid()\\n  }\\n  return chainId;\\n}\\n\\nfunction isContract(address account) view returns (bool) {\\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n  // for accounts without code, i.e. `keccak256('')`\\n  bytes32 codehash;\\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n  // solhint-disable-next-line no-inline-assembly\\n  assembly {\\n    codehash := extcodehash(account)\\n  }\\n  return (codehash != accountHash && codehash != 0x0);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/IWithdrawHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n/**\\n * @title Interface for callbacks hooks when user withdraws from staking contract\\n */\\ninterface IWithdrawHandler {\\n  function handleWithdrawal(address staker, uint256 reduceAmount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"daoOperator\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"executors\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"votingPowerStrategies\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IExecutorWithTimelock\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IVotingPowerStrategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"weiValues\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"withDelegatecalls\",\"type\":\"bool[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxVotingPower\",\"type\":\"uint256\"}],\"name\":\"BinaryProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDaoOperator\",\"type\":\"address\"}],\"name\":\"DaoOperatorTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"ExecutorAuthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"ExecutorUnauthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IExecutorWithTimelock\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IVotingPowerStrategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"options\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxVotingPower\",\"type\":\"uint256\"}],\"name\":\"GenericProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"ProposalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiatorExecution\",\"type\":\"address\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiatorQueueing\",\"type\":\"address\"}],\"name\":\"ProposalQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"voteOptions\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint224\",\"name\":\"votingPower\",\"type\":\"uint224\"}],\"name\":\"VoteEmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"voteOptions\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint224\",\"name\":\"oldVotingPower\",\"type\":\"uint224\"},{\"indexed\":false,\"internalType\":\"uint224\",\"name\":\"newVotingPower\",\"type\":\"uint224\"}],\"name\":\"VotingPowerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"VotingPowerStrategyAuthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"VotingPowerStrategyUnauthorized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTE_EMITTED_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"executors\",\"type\":\"address[]\"}],\"name\":\"authorizeExecutors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"}],\"name\":\"authorizeVotingPowerStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IExecutorWithTimelock\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"contract IVotingPowerStrategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weiValues\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"bool[]\",\"name\":\"withDelegatecalls\",\"type\":\"bool[]\"}],\"internalType\":\"struct IKyberGovernance.BinaryProposalParams\",\"name\":\"executionParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"}],\"name\":\"createBinaryProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IExecutorWithTimelock\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"contract IVotingPowerStrategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"options\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"}],\"name\":\"createGenericProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDaoOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalById\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum IKyberGovernance.ProposalType\",\"name\":\"proposalType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"contract IExecutorWithTimelock\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"contract IVotingPowerStrategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weiValues\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"bool[]\",\"name\":\"withDelegatecalls\",\"type\":\"bool[]\"},{\"internalType\":\"string[]\",\"name\":\"options\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"voteCounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVotingPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"}],\"internalType\":\"struct IKyberGovernance.ProposalWithoutVote\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalState\",\"outputs\":[{\"internalType\":\"enum IKyberGovernance.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalVoteDataById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposalsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getVoteOnProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"optionBitMask\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"votingPower\",\"type\":\"uint224\"}],\"internalType\":\"struct IKyberGovernance.Vote\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newVotingPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"proposalIds\",\"type\":\"uint256[]\"}],\"name\":\"handleVotingPowerChanged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"isExecutorAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"isVotingPowerStrategyAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionBitMask\",\"type\":\"uint256\"}],\"name\":\"submitVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionBitMask\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"submitVoteBySignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDaoOperator\",\"type\":\"address\"}],\"name\":\"transferDaoOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"executors\",\"type\":\"address[]\"}],\"name\":\"unauthorizeExecutors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"}],\"name\":\"unauthorizeVotingPowerStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KyberGovernance","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000560fb65513a3e9f22df97501393360bf0db448ad000000000000000000000000e6a7338cba0a1070adfb22c07115299605454713000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}