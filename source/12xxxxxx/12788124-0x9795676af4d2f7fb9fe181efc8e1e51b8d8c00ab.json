{"status":"1","message":"OK","result":[{"SourceCode":"{\"context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n\\tfunction _msgSender() internal view virtual returns (address) {\\r\\n\\t\\treturn msg.sender;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _msgData() internal view virtual returns (bytes calldata) {\\r\\n\\t\\treturn msg.data;\\r\\n\\t}\\r\\n}\\r\\n\"},\"main.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport \\\"./ownable.sol\\\";\\r\\n\\r\\ninterface IERC20 {\\r\\n\\t/**\\r\\n\\t* @dev Returns the amount of tokens in existence.\\r\\n\\t*/\\r\\n\\tfunction totalSupply() external view returns (uint256);\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the amount of tokens owned by `account`.\\r\\n\\t*/\\r\\n\\tfunction balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n\\t*\\r\\n\\t* Returns a boolean value indicating whether the operation succeeded.\\r\\n\\t*\\r\\n\\t* Emits a {Transfer} event.\\r\\n\\t*/\\r\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the remaining number of tokens that `spender` will be\\r\\n\\t* allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n\\t* zero by default.\\r\\n\\t*\\r\\n\\t* This value changes when {approve} or {transferFrom} are called.\\r\\n\\t*/\\r\\n\\tfunction allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n\\t*\\r\\n\\t* Returns a boolean value indicating whether the operation succeeded.\\r\\n\\t*\\r\\n\\t* IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n\\t* that someone may use both the old and the new allowance by unfortunate\\r\\n\\t* transaction ordering. One possible solution to mitigate this race\\r\\n\\t* condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n\\t* desired value afterwards:\\r\\n\\t* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n\\t*\\r\\n\\t* Emits an {Approval} event.\\r\\n\\t*/\\r\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n\\t* allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n\\t* allowance.\\r\\n\\t*\\r\\n\\t* Returns a boolean value indicating whether the operation succeeded.\\r\\n\\t*\\r\\n\\t* Emits a {Transfer} event.\\r\\n\\t*/\\r\\n\\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n\\t* another (`to`).\\r\\n\\t*\\r\\n\\t* Note that `value` may be zero.\\r\\n\\t*/\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n\\t* a call to {approve}. `value` is the new allowance.\\r\\n\\t*/\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\t/**\\r\\n\\t* @dev Returns the addition of two unsigned integers, reverting on\\r\\n\\t* overflow.\\r\\n\\t*\\r\\n\\t* Counterpart to Solidity\\u0027s `+` operator.\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - Addition cannot overflow.\\r\\n\\t*/\\r\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\t\\tuint256 c = a + b;\\r\\n\\t\\trequire(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n\\t\\treturn c;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n\\t* overflow (when the result is negative).\\r\\n\\t*\\r\\n\\t* Counterpart to Solidity\\u0027s `-` operator.\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - Subtraction cannot overflow.\\r\\n\\t*/\\r\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\t\\treturn sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n\\t* overflow (when the result is negative).\\r\\n\\t*\\r\\n\\t* Counterpart to Solidity\\u0027s `-` operator.\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - Subtraction cannot overflow.\\r\\n\\t*/\\r\\n\\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n\\t\\trequire(b \\u003c= a, errorMessage);\\r\\n\\t\\tuint256 c = a - b;\\r\\n\\r\\n\\t\\treturn c;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n\\t* overflow.\\r\\n\\t*\\r\\n\\t* Counterpart to Solidity\\u0027s `*` operator.\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - Multiplication cannot overflow.\\r\\n\\t*/\\r\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\t\\t// Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n\\t\\t// benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n\\t\\tif (a == 0) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuint256 c = a * b;\\r\\n\\t\\trequire(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n\\t\\treturn c;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n\\t* division by zero. The result is rounded towards zero.\\r\\n\\t*\\r\\n\\t* Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n\\t* `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n\\t* uses an invalid opcode to revert (consuming all remaining gas).\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - The divisor cannot be zero.\\r\\n\\t*/\\r\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\t\\treturn div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n\\t* division by zero. The result is rounded towards zero.\\r\\n\\t*\\r\\n\\t* Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n\\t* `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n\\t* uses an invalid opcode to revert (consuming all remaining gas).\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - The divisor cannot be zero.\\r\\n\\t*/\\r\\n\\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n\\t\\trequire(b \\u003e 0, errorMessage);\\r\\n\\t\\tuint256 c = a / b;\\r\\n\\t\\t// assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n\\t\\treturn c;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n\\t* Reverts when dividing by zero.\\r\\n\\t*\\r\\n\\t* Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n\\t* opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n\\t* invalid opcode to revert (consuming all remaining gas).\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - The divisor cannot be zero.\\r\\n\\t*/\\r\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\t\\treturn mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n\\t* Reverts with custom message when dividing by zero.\\r\\n\\t*\\r\\n\\t* Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n\\t* opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n\\t* invalid opcode to revert (consuming all remaining gas).\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - The divisor cannot be zero.\\r\\n\\t*/\\r\\n\\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n\\t\\trequire(b != 0, errorMessage);\\r\\n\\t\\treturn a % b;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n\\t/**\\r\\n\\t* @dev Returns true if `account` is a contract.\\r\\n\\t*\\r\\n\\t* [IMPORTANT]\\r\\n\\t* ====\\r\\n\\t* It is unsafe to assume that an address for which this function returns\\r\\n\\t* false is an externally-owned account (EOA) and not a contract.\\r\\n\\t*\\r\\n\\t* Among others, `isContract` will return false for the following\\r\\n\\t* types of addresses:\\r\\n\\t*\\r\\n\\t*  - an externally-owned account\\r\\n\\t*  - a contract in construction\\r\\n\\t*  - an address where a contract will be created\\r\\n\\t*  - an address where a contract lived, but was destroyed\\r\\n\\t* ====\\r\\n\\t*/\\r\\n\\tfunction isContract(address account) internal view returns (bool) {\\r\\n\\t\\tbytes32 codehash;\\r\\n\\t\\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\r\\n\\t\\tassembly { codehash := extcodehash(account) }\\r\\n\\t\\treturn (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n\\t* `recipient`, forwarding all available gas and reverting on errors.\\r\\n\\t*\\r\\n\\t* https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n\\t* of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n\\t* imposed by `transfer`, making them unable to receive funds via\\r\\n\\t* `transfer`. {sendValue} removes this limitation.\\r\\n\\t*\\r\\n\\t* https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n\\t*\\r\\n\\t* IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n\\t* taken to not create reentrancy vulnerabilities. Consider using\\r\\n\\t* {ReentrancyGuard} or the\\r\\n\\t* https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n\\t*/\\r\\n\\tfunction sendValue(address payable recipient, uint256 amount) internal {\\r\\n\\t\\trequire(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n\\t\\t(bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n\\t\\trequire(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Performs a Solidity function call using a low level `call`. A\\r\\n\\t* plain`call` is an unsafe replacement for a function call: use this\\r\\n\\t* function instead.\\r\\n\\t*\\r\\n\\t* If `target` reverts with a revert reason, it is bubbled up by this\\r\\n\\t* function (like regular Solidity function calls).\\r\\n\\t*\\r\\n\\t* Returns the raw returned data. To convert to the expected return value,\\r\\n\\t* use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - `target` must be a contract.\\r\\n\\t* - calling `target` with `data` must not revert.\\r\\n\\t*\\r\\n\\t* _Available since v3.1._\\r\\n\\t*/\\r\\n\\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n\\treturn functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n\\t* `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n\\t*\\r\\n\\t* _Available since v3.1._\\r\\n\\t*/\\r\\n\\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n\\t\\treturn _functionCallWithValue(target, data, 0, errorMessage);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n\\t* but also transferring `value` wei to `target`.\\r\\n\\t*\\r\\n\\t* Requirements:\\r\\n\\t*\\r\\n\\t* - the calling contract must have an ETH balance of at least `value`.\\r\\n\\t* - the called Solidity function must be `payable`.\\r\\n\\t*\\r\\n\\t* _Available since v3.1._\\r\\n\\t*/\\r\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n\\t\\treturn functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t* @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n\\t* with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n\\t*\\r\\n\\t* _Available since v3.1._\\r\\n\\t*/\\r\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n\\t\\trequire(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n\\t\\treturn _functionCallWithValue(target, data, value, errorMessage);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\r\\n\\t\\trequire(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls\\r\\n\\t\\t(bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\r\\n\\t\\tif (success) {\\r\\n\\t\\t\\treturn returndata;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t// Look for revert reason and bubble it up if present\\r\\n\\t\\t\\tif (returndata.length \\u003e 0) {\\r\\n\\t\\t\\t\\t// The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n\\t\\t\\t\\t// solhint-disable-next-line no-inline-assembly\\r\\n\\t\\t\\t\\tassembly {\\r\\n\\t\\t\\t\\t\\tlet returndata_size := mload(returndata)\\r\\n\\t\\t\\t\\t\\trevert(add(32, returndata), returndata_size)\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\trevert(errorMessage);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n\\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n\\tfunction feeTo() external view returns (address);\\r\\n\\tfunction feeToSetter() external view returns (address);\\r\\n\\r\\n\\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n\\tfunction allPairs(uint) external view returns (address pair);\\r\\n\\tfunction allPairsLength() external view returns (uint);\\r\\n\\r\\n\\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n\\tfunction setFeeTo(address) external;\\r\\n\\tfunction setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n\\tfunction name() external pure returns (string memory);\\r\\n\\tfunction symbol() external pure returns (string memory);\\r\\n\\tfunction decimals() external pure returns (uint8);\\r\\n\\tfunction totalSupply() external view returns (uint);\\r\\n\\tfunction balanceOf(address owner) external view returns (uint);\\r\\n\\tfunction allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n\\tfunction approve(address spender, uint value) external returns (bool);\\r\\n\\tfunction transfer(address to, uint value) external returns (bool);\\r\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\tfunction nonces(address owner) external view returns (uint);\\r\\n\\r\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n\\tevent Mint(address indexed sender, uint amount0, uint amount1);\\r\\n\\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n\\tevent Swap(\\r\\n\\t\\taddress indexed sender,\\r\\n\\t\\tuint amount0In,\\r\\n\\t\\tuint amount1In,\\r\\n\\t\\tuint amount0Out,\\r\\n\\t\\tuint amount1Out,\\r\\n\\t\\taddress indexed to\\r\\n\\t);\\r\\n\\tevent Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n\\tfunction factory() external view returns (address);\\r\\n\\tfunction token0() external view returns (address);\\r\\n\\tfunction token1() external view returns (address);\\r\\n\\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n\\tfunction price0CumulativeLast() external view returns (uint);\\r\\n\\tfunction price1CumulativeLast() external view returns (uint);\\r\\n\\tfunction kLast() external view returns (uint);\\r\\n\\r\\n\\tfunction mint(address to) external returns (uint liquidity);\\r\\n\\tfunction burn(address to) external returns (uint amount0, uint amount1);\\r\\n\\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n\\tfunction skim(address to) external;\\r\\n\\tfunction sync() external;\\r\\n\\r\\n\\tfunction initialize(address, address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n\\tfunction factory() external pure returns (address);\\r\\n\\tfunction WETH() external pure returns (address);\\r\\n\\r\\n\\tfunction addLiquidity(\\r\\n\\t\\taddress tokenA,\\r\\n\\t\\taddress tokenB,\\r\\n\\t\\tuint amountADesired,\\r\\n\\t\\tuint amountBDesired,\\r\\n\\t\\tuint amountAMin,\\r\\n\\t\\tuint amountBMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\tfunction addLiquidityETH(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint amountTokenDesired,\\r\\n\\t\\tuint amountTokenMin,\\r\\n\\t\\tuint amountETHMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\tfunction removeLiquidity(\\r\\n\\t\\taddress tokenA,\\r\\n\\t\\taddress tokenB,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountAMin,\\r\\n\\t\\tuint amountBMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint amountA, uint amountB);\\r\\n\\tfunction removeLiquidityETH(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountTokenMin,\\r\\n\\t\\tuint amountETHMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint amountToken, uint amountETH);\\r\\n\\tfunction removeLiquidityWithPermit(\\r\\n\\t\\taddress tokenA,\\r\\n\\t\\taddress tokenB,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountAMin,\\r\\n\\t\\tuint amountBMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline,\\r\\n\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n\\t) external returns (uint amountA, uint amountB);\\r\\n\\tfunction removeLiquidityETHWithPermit(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountTokenMin,\\r\\n\\t\\tuint amountETHMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline,\\r\\n\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n\\t) external returns (uint amountToken, uint amountETH);\\r\\n\\tfunction swapExactTokensForTokens(\\r\\n\\t\\tuint amountIn,\\r\\n\\t\\tuint amountOutMin,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint[] memory amounts);\\r\\n\\tfunction swapTokensForExactTokens(\\r\\n\\t\\tuint amountOut,\\r\\n\\t\\tuint amountInMax,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint[] memory amounts);\\r\\n\\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n\\t\\texternal\\r\\n\\t\\tpayable\\r\\n\\t\\treturns (uint[] memory amounts);\\r\\n\\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n\\t\\texternal\\r\\n\\t\\treturns (uint[] memory amounts);\\r\\n\\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n\\t\\texternal\\r\\n\\t\\treturns (uint[] memory amounts);\\r\\n\\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n\\t\\texternal\\r\\n\\t\\tpayable\\r\\n\\t\\treturns (uint[] memory amounts);\\r\\n\\r\\n\\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n\\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n\\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n\\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n\\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n\\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountTokenMin,\\r\\n\\t\\tuint amountETHMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external returns (uint amountETH);\\r\\n\\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint liquidity,\\r\\n\\t\\tuint amountTokenMin,\\r\\n\\t\\tuint amountETHMin,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline,\\r\\n\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n\\t) external returns (uint amountETH);\\r\\n\\r\\n\\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n\\t\\tuint amountIn,\\r\\n\\t\\tuint amountOutMin,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external;\\r\\n\\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n\\t\\tuint amountOutMin,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external payable;\\r\\n\\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n\\t\\tuint amountIn,\\r\\n\\t\\tuint amountOutMin,\\r\\n\\t\\taddress[] calldata path,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint deadline\\r\\n\\t) external;\\r\\n}\\r\\n\\r\\ncontract Leafty is Context, IERC20, Ownable {\\r\\n\\tusing SafeMath for uint256;\\r\\n\\tusing Address for address;\\r\\n\\r\\n\\tmapping (address =\\u003e uint256) private _rOwned;\\r\\n\\tmapping (address =\\u003e uint256) private _tOwned;\\r\\n\\tmapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n\\tmapping (address =\\u003e bool) private _isExcludedFromFee;\\r\\n\\r\\n\\tmapping (address =\\u003e bool) private _isExcluded;\\r\\n\\taddress[] private _excluded;\\r\\n\\r\\n\\tuint256 private constant MAX = ~uint256(0);\\r\\n\\tuint256 private _tTotal = 100000000000 * 10**9;\\r\\n\\tuint256 private _rTotal = (MAX - (MAX % _tTotal));\\r\\n\\tuint256 private _tFeeTotal;\\r\\n\\r\\n\\tstring private _name = \\u0027Leafty\\u0027;\\r\\n\\tstring private _symbol = \\u0027LEAFTY\\u0027;\\r\\n\\tuint8 private _decimals = 9;\\r\\n\\r\\n\\t// Tax and charity fees will start at 0 so we don\\u0027t have a big impact when deploying to Uniswap\\r\\n\\t// Charity wallet address is null but the method to set the address is exposed\\r\\n\\tuint256 private _taxFee = 1;\\r\\n\\tuint256 private _charityFee = 7;\\r\\n\\tuint256 private _previousTaxFee = _taxFee;\\r\\n\\tuint256 private _previousCharityFee = _charityFee;\\r\\n\\r\\n\\taddress payable public _charityWalletAddress;\\r\\n\\r\\n\\tIUniswapV2Router02 public immutable uniswapV2Router;\\r\\n\\taddress public immutable uniswapV2Pair;\\r\\n\\r\\n\\tbool inSwap = false;\\r\\n\\tbool public swapEnabled = true;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\r\\n\\tuint256 private _maxTxAmount = 10000000000000 * 10**9;\\r\\n\\t// We will set a minimum amount of tokens to be swaped =\\u003e 500k\\r\\n\\tuint256 private _numOfTokensToExchangeForCharity = 5 * 10**3 * 10**9;\\r\\n\\r\\n\\tevent MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\\r\\n\\tevent SwapEnabledUpdated(bool enabled);\\r\\n\\r\\n\\tmodifier lockTheSwap {\\r\\n\\t\\tinSwap = true;\\r\\n\\t\\t_;\\r\\n\\t\\tinSwap = false;\\r\\n\\t}\\r\\n\\r\\n\\tconstructor (address payable charityWalletAddress) {\\r\\n\\t\\t_charityWalletAddress = charityWalletAddress;\\r\\n\\t\\t_rOwned[_msgSender()] = _rTotal;\\r\\n\\r\\n\\t\\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // UniswapV2 for Ethereum network\\r\\n\\t\\t// Create a uniswap pair for this new token\\r\\n\\t\\tuniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\r\\n\\t\\t\\t.createPair(address(this), _uniswapV2Router.WETH());\\r\\n\\r\\n\\t\\t// set the rest of the contract variables\\r\\n\\t\\tuniswapV2Router = _uniswapV2Router;\\r\\n\\r\\n\\t\\t// Exclude owner and this contract from fee\\r\\n\\t\\t_isExcludedFromFee[owner()] = true;\\r\\n\\t\\t_isExcludedFromFee[address(this)] = true;\\r\\n\\r\\n\\t\\temit Transfer(address(0), _msgSender(), _tTotal);\\r\\n\\t}\\r\\n\\r\\n\\tfunction name() public view returns (string memory) {\\r\\n\\t\\treturn _name;\\r\\n\\t}\\r\\n\\r\\n\\tfunction symbol() public view returns (string memory) {\\r\\n\\t\\treturn _symbol;\\r\\n\\t}\\r\\n\\r\\n\\tfunction decimals() public view returns (uint8) {\\r\\n\\t\\treturn _decimals;\\r\\n\\t}\\r\\n\\r\\n\\tfunction totalSupply() public view override returns (uint256) {\\r\\n\\t\\treturn _tTotal;\\r\\n\\t}\\r\\n\\r\\n\\tfunction balanceOf(address account) public view override returns (uint256) {\\r\\n\\t\\tif (_isExcluded[account]) return _tOwned[account];\\r\\n\\t\\treturn tokenFromReflection(_rOwned[account]);\\r\\n\\t}\\r\\n\\r\\n\\tfunction transfer(address recipient, uint256 amount) public override returns (bool) {\\r\\n\\t\\t_transfer(_msgSender(), recipient, amount);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\tfunction allowance(address owner, address spender) public view override returns (uint256) {\\r\\n\\t\\treturn _allowances[owner][spender];\\r\\n\\t}\\r\\n\\r\\n\\tfunction approve(address spender, uint256 amount) public override returns (bool) {\\r\\n\\t\\t_approve(_msgSender(), spender, amount);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\tfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\r\\n\\t\\t_transfer(sender, recipient, amount);\\r\\n\\t\\t_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n\\t\\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n\\t\\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\tfunction isExcluded(address account) public view returns (bool) {\\r\\n\\t\\treturn _isExcluded[account];\\r\\n\\t}\\r\\n\\r\\n\\tfunction setExcludeFromFee(address account, bool excluded) external onlyOwner() {\\r\\n\\t\\t_isExcludedFromFee[account] = excluded;\\r\\n\\t}\\r\\n\\r\\n\\tfunction totalFees() public view returns (uint256) {\\r\\n\\t\\treturn _tFeeTotal;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction charityMin() public view returns (uint256) {\\r\\n\\t\\treturn _numOfTokensToExchangeForCharity;\\r\\n\\t}\\r\\n\\r\\n\\tfunction deliver(uint256 tAmount) public {\\r\\n\\t\\taddress sender = _msgSender();\\r\\n\\t\\trequire(!_isExcluded[sender], \\\"Excluded addresses cannot call this function\\\");\\r\\n\\t\\t(uint256 rAmount,,,,,) = _getValues(tAmount);\\r\\n\\t\\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\\r\\n\\t\\t_rTotal = _rTotal.sub(rAmount);\\r\\n\\t\\t_tFeeTotal = _tFeeTotal.add(tAmount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\\r\\n\\t\\trequire(tAmount \\u003c= _tTotal, \\\"Amount must be less than supply\\\");\\r\\n\\t\\tif (!deductTransferFee) {\\r\\n\\t\\t\\t(uint256 rAmount,,,,,) = _getValues(tAmount);\\r\\n\\t\\t\\treturn rAmount;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t(,uint256 rTransferAmount,,,,) = _getValues(tAmount);\\r\\n\\t\\t\\treturn rTransferAmount;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\r\\n\\t\\trequire(rAmount \\u003c= _rTotal, \\\"Amount must be less than total reflections\\\");\\r\\n\\t\\tuint256 currentRate =  _getRate();\\r\\n\\t\\treturn rAmount.div(currentRate);\\r\\n\\t}\\r\\n\\r\\n\\tfunction excludeAccount(address account) external onlyOwner() {\\r\\n\\t\\trequire(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, \\u0027We can not exclude Uniswap router.\\u0027);\\r\\n\\t\\trequire(!_isExcluded[account], \\\"Account is already excluded\\\");\\r\\n\\t\\tif(_rOwned[account] \\u003e 0) {\\r\\n\\t\\t\\t_tOwned[account] = tokenFromReflection(_rOwned[account]);\\r\\n\\t\\t}\\r\\n\\t\\t_isExcluded[account] = true;\\r\\n\\t\\t_excluded.push(account);\\r\\n\\t}\\r\\n\\r\\n\\tfunction includeAccount(address account) external onlyOwner() {\\r\\n\\t\\trequire(_isExcluded[account], \\\"Account is already excluded\\\");\\r\\n\\t\\tfor (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n\\t\\t\\tif (_excluded[i] == account) {\\r\\n\\t\\t\\t\\t_excluded[i] = _excluded[_excluded.length - 1];\\r\\n\\t\\t\\t\\t_tOwned[account] = 0;\\r\\n\\t\\t\\t\\t_isExcluded[account] = false;\\r\\n\\t\\t\\t\\t_excluded.pop();\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction removeAllFee() private {\\r\\n\\t\\tif(_taxFee == 0 \\u0026\\u0026 _charityFee == 0) return;\\r\\n\\r\\n\\t\\t_previousTaxFee = _taxFee;\\r\\n\\t\\t_previousCharityFee = _charityFee;\\r\\n\\r\\n\\t\\t_taxFee = 0;\\r\\n\\t\\t_charityFee = 0;\\r\\n\\t}\\r\\n\\r\\n\\tfunction restoreAllFee() private {\\r\\n\\t\\t_taxFee = _previousTaxFee;\\r\\n\\t\\t_charityFee = _previousCharityFee;\\r\\n\\t}\\r\\n\\r\\n\\tfunction isExcludedFromFee(address account) public view returns(bool) {\\r\\n\\t\\treturn _isExcludedFromFee[account];\\r\\n\\t}\\r\\n\\r\\n\\tfunction _approve(address owner, address spender, uint256 amount) private {\\r\\n\\t\\trequire(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n\\t\\trequire(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n\\t\\t_allowances[owner][spender] = amount;\\r\\n\\t\\temit Approval(owner, spender, amount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _transfer(address sender, address recipient, uint256 amount) private {\\r\\n\\t\\trequire(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n\\t\\trequire(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\t\\trequire(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n\\r\\n\\t\\tif(sender != owner() \\u0026\\u0026 recipient != owner())\\r\\n\\t\\t\\trequire(amount \\u003c= _maxTxAmount, \\\"Transfer amount exceeds the maxTxAmount.\\\");\\r\\n\\r\\n\\t\\t// is the token balance of this contract address over the min number of\\r\\n\\t\\t// tokens that we need to initiate a swap?\\r\\n\\t\\t// also, don\\u0027t get caught in a circular charity event.\\r\\n\\t\\t// also, don\\u0027t swap if sender is uniswap pair.\\r\\n\\t\\tuint256 contractTokenBalance = balanceOf(address(this));\\r\\n\\r\\n\\t\\tif(contractTokenBalance \\u003e= _maxTxAmount)\\r\\n\\t\\t{\\r\\n\\t\\t\\tcontractTokenBalance = _maxTxAmount;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tbool overMinTokenBalance = contractTokenBalance \\u003e= _numOfTokensToExchangeForCharity;\\r\\n\\t\\tif (!inSwap \\u0026\\u0026 swapEnabled \\u0026\\u0026 overMinTokenBalance \\u0026\\u0026 sender != uniswapV2Pair) {\\r\\n\\t\\t\\t// We need to swap the current tokens to ETH and send to the charity wallet\\r\\n\\t\\t\\tswapTokensForEth(contractTokenBalance);\\r\\n\\r\\n\\t\\t\\tuint256 contractETHBalance = address(this).balance;\\r\\n\\t\\t\\tif(contractETHBalance \\u003e 0) {\\r\\n\\t\\t\\t\\tsendETHToCharity(address(this).balance);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//indicates if fee should be deducted from transfer\\r\\n\\t\\tbool takeFee = true;\\r\\n\\r\\n\\t\\t//if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n\\t\\tif(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){\\r\\n\\t\\t\\ttakeFee = false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//transfer amount, it will take tax and charity fee\\r\\n\\t\\t_tokenTransfer(sender,recipient,amount,takeFee);\\r\\n\\t}\\r\\n\\r\\n\\tfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap{\\r\\n\\t\\t// generate the uniswap pair path of token -\\u003e weth\\r\\n\\t\\taddress[] memory path = new address[](2);\\r\\n\\t\\tpath[0] = address(this);\\r\\n\\t\\tpath[1] = uniswapV2Router.WETH();\\r\\n\\r\\n\\t\\t_approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n\\t\\t// make the swap\\r\\n\\t\\tuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n\\t\\t\\ttokenAmount,\\r\\n\\t\\t\\t0, // accept any amount of ETH\\r\\n\\t\\t\\tpath,\\r\\n\\t\\t\\taddress(this),\\r\\n\\t\\t\\tblock.timestamp\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\tfunction sendETHToCharity(uint256 amount) private {\\r\\n\\t\\t_charityWalletAddress.transfer(amount);\\r\\n\\t}\\r\\n\\r\\n\\t// We are exposing these functions to be able to manual swap and send\\r\\n\\t// in case the token is highly valued and 500k becomes too much\\r\\n\\tfunction manualSwap() external onlyOwner() {\\r\\n\\t\\tuint256 contractBalance = balanceOf(address(this));\\r\\n\\t\\tswapTokensForEth(contractBalance);\\r\\n\\t}\\r\\n\\r\\n\\tfunction manualSend() external onlyOwner() {\\r\\n\\t\\tuint256 contractETHBalance = address(this).balance;\\r\\n\\t\\tsendETHToCharity(contractETHBalance);\\r\\n\\t}\\r\\n\\r\\n\\tfunction setSwapEnabled(bool enabled) external onlyOwner() {\\r\\n\\t\\tswapEnabled = enabled;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\\r\\n\\t\\tif(!takeFee)\\r\\n\\t\\t\\tremoveAllFee();\\r\\n\\r\\n\\t\\tif (_isExcluded[sender] \\u0026\\u0026 !_isExcluded[recipient]) {\\r\\n\\t\\t\\t_transferFromExcluded(sender, recipient, amount);\\r\\n\\t\\t} else if (!_isExcluded[sender] \\u0026\\u0026 _isExcluded[recipient]) {\\r\\n\\t\\t\\t_transferToExcluded(sender, recipient, amount);\\r\\n\\t\\t} else if (!_isExcluded[sender] \\u0026\\u0026 !_isExcluded[recipient]) {\\r\\n\\t\\t\\t_transferStandard(sender, recipient, amount);\\r\\n\\t\\t} else if (_isExcluded[sender] \\u0026\\u0026 _isExcluded[recipient]) {\\r\\n\\t\\t\\t_transferBothExcluded(sender, recipient, amount);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t_transferStandard(sender, recipient, amount);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif(!takeFee)\\r\\n\\t\\t\\trestoreAllFee();\\r\\n\\t}\\r\\n\\r\\n\\tfunction _transferStandard(address sender, address recipient, uint256 tAmount) private {\\r\\n\\t\\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\\r\\n\\t\\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\\r\\n\\t\\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\r\\n\\t\\t_takeCharity(tCharity);\\r\\n\\t\\t_reflectFee(rFee, tFee);\\r\\n\\t\\temit Transfer(sender, recipient, tTransferAmount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\\r\\n\\t\\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\\r\\n\\t\\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\\r\\n\\t\\t_tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\\r\\n\\t\\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\r\\n\\t\\t_takeCharity(tCharity);\\r\\n\\t\\t_reflectFee(rFee, tFee);\\r\\n\\t\\temit Transfer(sender, recipient, tTransferAmount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\\r\\n\\t\\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\\r\\n\\t\\t_tOwned[sender] = _tOwned[sender].sub(tAmount);\\r\\n\\t\\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\\r\\n\\t\\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\r\\n\\t\\t_takeCharity(tCharity);\\r\\n\\t\\t_reflectFee(rFee, tFee);\\r\\n\\t\\temit Transfer(sender, recipient, tTransferAmount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\\r\\n\\t\\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\\r\\n\\t\\t_tOwned[sender] = _tOwned[sender].sub(tAmount);\\r\\n\\t\\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\\r\\n\\t\\t_tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\\r\\n\\t\\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\r\\n\\t\\t_takeCharity(tCharity);\\r\\n\\t\\t_reflectFee(rFee, tFee);\\r\\n\\t\\temit Transfer(sender, recipient, tTransferAmount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _takeCharity(uint256 tCharity) private {\\r\\n\\t\\tuint256 currentRate =  _getRate();\\r\\n\\t\\tuint256 rCharity = tCharity.mul(currentRate);\\r\\n\\t\\t_rOwned[address(this)] = _rOwned[address(this)].add(rCharity);\\r\\n\\t\\tif(_isExcluded[address(this)])\\r\\n\\t\\t\\t_tOwned[address(this)] = _tOwned[address(this)].add(tCharity);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _reflectFee(uint256 rFee, uint256 tFee) private {\\r\\n\\t\\t_rTotal = _rTotal.sub(rFee);\\r\\n\\t\\t_tFeeTotal = _tFeeTotal.add(tFee);\\r\\n\\t}\\r\\n\\r\\n\\t\\t//to recieve ETH from uniswapV2Router when swaping\\r\\n\\treceive() external payable {}\\r\\n\\r\\n\\tfunction _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\\r\\n\\t\\t(uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getTValues(tAmount, _taxFee, _charityFee);\\r\\n\\t\\tuint256 currentRate =  _getRate();\\r\\n\\t\\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\\r\\n\\t\\treturn (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tCharity);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getTValues(uint256 tAmount, uint256 taxFee, uint256 charityFee) private pure returns (uint256, uint256, uint256) {\\r\\n\\t\\tuint256 tFee = tAmount.mul(taxFee).div(100);\\r\\n\\t\\tuint256 tCharity = tAmount.mul(charityFee).div(100);\\r\\n\\t\\tuint256 tTransferAmount = tAmount.sub(tFee).sub(tCharity);\\r\\n\\t\\treturn (tTransferAmount, tFee, tCharity);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\\r\\n\\t\\tuint256 rAmount = tAmount.mul(currentRate);\\r\\n\\t\\tuint256 rFee = tFee.mul(currentRate);\\r\\n\\t\\tuint256 rTransferAmount = rAmount.sub(rFee);\\r\\n\\t\\treturn (rAmount, rTransferAmount, rFee);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getRate() private view returns(uint256) {\\r\\n\\t\\t(uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\r\\n\\t\\treturn rSupply.div(tSupply);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getCurrentSupply() private view returns(uint256, uint256) {\\r\\n\\t\\tuint256 rSupply = _rTotal;\\r\\n\\t\\tuint256 tSupply = _tTotal;\\r\\n\\t\\tfor (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n\\t\\t\\tif (_rOwned[_excluded[i]] \\u003e rSupply || _tOwned[_excluded[i]] \\u003e tSupply) return (_rTotal, _tTotal);\\r\\n\\t\\t\\trSupply = rSupply.sub(_rOwned[_excluded[i]]);\\r\\n\\t\\t\\ttSupply = tSupply.sub(_tOwned[_excluded[i]]);\\r\\n\\t\\t}\\r\\n\\t\\tif (rSupply \\u003c _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\\r\\n\\t\\treturn (rSupply, tSupply);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getTaxFee() private view returns(uint256) {\\r\\n\\t\\treturn _taxFee;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getMaxTxAmount() private view returns(uint256) {\\r\\n\\t\\treturn _maxTxAmount;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getETHBalance() public view returns(uint256 balance) {\\r\\n\\t\\treturn address(this).balance;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setTaxFee(uint256 taxFee) external onlyOwner() {\\r\\n\\t\\trequire(taxFee \\u003e= 1 \\u0026\\u0026 taxFee \\u003c= 10, \\u0027taxFee should be in 1 - 10\\u0027);\\r\\n\\t\\t_taxFee = taxFee;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setCharityFee(uint256 charityFee) external onlyOwner() {\\r\\n\\t\\trequire(charityFee \\u003e= 1 \\u0026\\u0026 charityFee \\u003c= 99, \\u0027charityFee should be in 1 - 99\\u0027);\\r\\n\\t\\t_charityFee = charityFee;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction _setCharityMin(uint256 scharityMin) external onlyOwner() {\\r\\n\\t\\t_numOfTokensToExchangeForCharity = scharityMin;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setCharityWallet(address payable charityWalletAddress) external onlyOwner() {\\r\\n\\t\\t_charityWalletAddress = charityWalletAddress;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setMaxTxAmount(uint256 maxTxAmount) external onlyOwner() {\\r\\n\\t\\trequire(maxTxAmount \\u003e= 10000000000000e9 , \\u0027maxTxAmount should be greater than 10000000000000e9\\u0027);\\r\\n\\t\\t_maxTxAmount = maxTxAmount;\\r\\n\\t}\\r\\n}\"},\"ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n\\taddress private _owner;\\r\\n\\r\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\t/**\\r\\n\\t\\t* @dev Initializes the contract setting the deployer as the initial owner.\\r\\n\\t\\t*/\\r\\n\\tconstructor() {\\r\\n\\t\\t_setOwner(_msgSender());\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\t* @dev Returns the address of the current owner.\\r\\n\\t\\t*/\\r\\n\\tfunction owner() public view virtual returns (address) {\\r\\n\\t\\treturn _owner;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\t* @dev Throws if called by any account other than the owner.\\r\\n\\t\\t*/\\r\\n\\tmodifier onlyOwner() {\\r\\n\\t\\trequire(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\t* @dev Leaves the contract without owner. It will not be possible to call\\r\\n\\t\\t* `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n\\t\\t*\\r\\n\\t\\t* NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n\\t\\t* thereby removing any functionality that is only available to the owner.\\r\\n\\t\\t*/\\r\\n\\tfunction renounceOwnership() public virtual onlyOwner {\\r\\n\\t\\t_setOwner(address(0));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\t* @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n\\t\\t* Can only be called by the current owner.\\r\\n\\t\\t*/\\r\\n\\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n\\t\\trequire(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n\\t\\t_setOwner(newOwner);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setOwner(address newOwner) private {\\r\\n\\t\\taddress oldOwner = _owner;\\r\\n\\t\\t_owner = newOwner;\\r\\n\\t\\temit OwnershipTransferred(oldOwner, newOwner);\\r\\n\\t}\\r\\n}\\r\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"charityWalletAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minTokensBeforeSwap\",\"type\":\"uint256\"}],\"name\":\"MinTokensBeforeSwapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_charityWalletAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getETHBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"charityFee\",\"type\":\"uint256\"}],\"name\":\"_setCharityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"scharityMin\",\"type\":\"uint256\"}],\"name\":\"_setCharityMin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"charityWalletAddress\",\"type\":\"address\"}],\"name\":\"_setCharityWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"_setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"taxFee\",\"type\":\"uint256\"}],\"name\":\"_setTaxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"setExcludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Leafty","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000004017ab7dd3894ac70d45d63c31e41c32cc476d8","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://39d977cccf01c373688d656fb00b433ec87818d1695994dda5b4023e26833a01"}]}