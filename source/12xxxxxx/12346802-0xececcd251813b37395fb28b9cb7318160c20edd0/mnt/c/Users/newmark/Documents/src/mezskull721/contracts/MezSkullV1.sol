pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/utils/Context.sol";

/**
 * @dev Mezskull Collection V1 {ERC721} token, 
 * contract developed by mangrovia.solutions
 * 
 * 
 *                           E953?77*3*77??30SE
 *                      #S37:-----?E8EK9!------:*30E
 *                   E27---....-::7L89S?*::-...-----!3S
 *                 0??05?::!:::-..........--:::!::302?:!S
 *              #99U!--**!:137-.............-?3*:!*!--79UL8
 *             E0399***......-***!!.....!****!.....-*!?SU359
 *            SL05*7!........3000003...?U00009.......-*77U55S#
 *           S331:!-.........-*9000U3-30000U?:.........:!!??L0#
 *          #E9L5UL:..........-S033UU00UL00U*..........!0U55SE8#
 *         #E93L399..........--S0?.1U0U*7009-..........:SU333SKS
 *         353953?..........-SU000$.L0:3000U53..........-330U323#
 *        E?7!:-............-?3?333.--.3?33337.............-:!7?K
 *        9?*!--............!-...............::............-:!7?K
 *        U?*!--.-:.!L:-53.10!-??........-?7.?0:.23.7L-.!-.-:!7?#
 *        9?*:?3:70?!03:0?*03-35!.........10?-05:L2-50-30:!37!73
 *        8?03*3U135?L0L0230L00:...........*0550300L033L?3U?7L55
 *         52L9SE####EEK8S99U00?1.--...---?3UU99SS8EE###  #K$2LE
 *         ES8#                ##82?!:!30E                   8S
 *          S#                    00L3L09                    ##
 *          ##                   8L05L003#                   #
 *                              #000L$200E                   #
 *           ##                 S050E S55S                  K#
 *          K9U#           ####S003E   SL0K###             S09E
 *          E77?S ###E8S9U09SS02538     S300SS9U9S8EE### E33*7E
 *           #?*0029050300UULL0??8      #S7303$95052U0SS102!*8
 *             #EU8#EKEL00!30:7059#     #952!*0?70?3U?5931$S#
 *                       9!.L3.-50#     #0?--03.?9S#
 *                       L*--...-U #3-9 #3....--1#
 *                      2:-:--::-.-......--::---!S
 *                      137--...--.-?57..--!!7!2!#
 *                      UL-3!977--!!:U3::*3?.5.93
 *                       #9L.S7-0L-?U:.3S.:5.8E
 *                          SE--#-.! -.-E??#
 *                             ##5L$ S20
 * 
 * 
 *  including:
 *
 *  the collection of 211 skulls curated by the author and the developers on April 2021
 *  + 1 "Gypsy Soul" Skull. See transfer comments for an explanation of the 'gypsy' behaviour.
 *  
 *  211 is a refernce to the 2 November, the Day of the Dead in Mexico, Italy and most of catholic countries.
 *
 *  The unique SVG skulls are generated by an algorithm created in 2018 by LL for Mangrovia Blockchain Solutions.
 *  The generator has been tested on the app available at https://mezskull.com
 *  
 *  SVG skulls and Json metadata are stored on IPFS for perpetual storage at these addresses:
 *  Skulls Json Metadata        : "https://ipfs.io/ipfs/QmQA2i2NXLUsn6EHjiHq33KDdJQSSySAehydcnLmD4QGn2/*.json";
 *  Skulls SVG Images           : "https://ipfs.io/ipfs/Qmdx7ehc7KaYhqXzS2qUgSWfUbjFuuWMr6fFduDyjaomQV/*.svg";
 *  Collection Description Json : "https://ipfs.io//ipfs/QmSBbCWKWCeesuTNFJSDwQXXmiUaL7Kia28VzStYmWn5KV";
 *  
 *  Functions to change the URIs are implemented to permit to easier show the collection on deployment.
 *  Each Json includes the sha256 field that represent the hash of the image/svg, immutable and perpetual.
 *
 *  A Skull is Forever!
 *
 */

 // SPDX-License-Identifier:Apache-2.0" 
contract MezSkullV1 is Context, ERC721Enumerable {
   
    address private owner;

    string private _baseTokenURI;
    string private _baseImageURI;
    string private _baseContractURI;
  
    // TotalSkulls mintable in this release is 211 + 1 gypsy Skull
    uint totalSkullz = 212;

    string _name = "MEZSKULL V1";
    string _symbol = "MV1";
    
    event ChangeBaseURI(address from, string oldURI, string newURI);
    event ChangeImageURI(address from, string oldURI, string newURI);
    event ChangeContractURI(address from, string oldURI, string newURI);

    /**
     * @dev Grants `owner` role  to the
     * account that deploys the contract.
     * The ownership can't be trasfered, and the wallet will be 'lost' once the skulls are all sold
     * so nobody will be able to change the json and image link in the future
     * stored forever on IPFS
     * 
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * Same for the ImageURI
     * See {ERC721-tokenURI}.
     */
    constructor() ERC721("MEZSKULL V1", "MV1") {

        //_baseTokenURI = "https://ipfs.io/ipfs/QmQA2i2NXLUsn6EHjiHq33KDdJQSSySAehydcnLmD4QGn2";
        //_baseImageURI = "https://ipfs.io/ipfs/Qmdx7ehc7KaYhqXzS2qUgSWfUbjFuuWMr6fFduDyjaomQV/";
        //_baseContractURI = "https://ipfs.io//ipfs/QmSBbCWKWCeesuTNFJSDwQXXmiUaL7Kia28VzStYmWn5KV";

        _baseTokenURI = "https://mezskull.com/data/json/";
        _baseImageURI = "https://mezskull.com/data/svg/";
        _baseContractURI = "https://mezskull.com/data/ContractURI.json";

        owner = _msgSender();
        
    }
    
    /**
    * This function is required to cast a uint to a string for URI composer
    */
    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return "0";
        }
        uint j = _i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k-1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        return string(abi.encodePacked(_baseTokenURI, uint2str(tokenId), ".json"));
    }

    function imageURI(uint tokenId) public view virtual returns (string memory) {
        return string(abi.encodePacked(_baseImageURI, uint2str(tokenId), ".svg"));
    }

    function contractURI() public view virtual returns (string memory) {
        return string(_baseContractURI);
    }

   
    /**
     * @dev Creates a bunch of new token for `to`. Its token ID is taken from the start
     * and loop for much amount of token (and available on the emitted {IERC721-Transfer} event), 
     * 
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must be the contract `owner`.
     * - it can mint max totalSkullz amount of token
     * - it fail when it mint an already minted token
     *
     */
        function mint(address to, uint8 start, uint8 much) public virtual {
            require(_msgSender() == owner, "MezSkull: must have minter role to mint");
            require( (start+much) <= totalSkullz, "Mezskull: we can mint only 211 skulls + the gypsy");
            //require(tocreate,  "Mezskull cannnot be minted futher, each Series has its own contract");

            for(uint8 i=start; i< (start+much); i++){
            _mint(to, i);
            }
        }

    /**
    * transferFrom implementation to manage the Gypsy token
    * the Gypsy Skull #0 cannot be transferred and will move by itself
    * if block.timestamp+block.number is a multiple of 2/11 (the Day of the Dead)
    * the Gypsy Skull is transferred from the previous owner to the _to of the transfer
    * 
    * there is no way to overlook if the Gypsy will move
    * the _to will gain the token trasferred + the Gypsy
    * 
    * nobody know how long the Gypsy Skull will be owned by them
    *
    * this move has no high randomness but this is not a requirement as Gypsy Skull has no reall value
    * and will move anyway soon or later
    */
    function transferFrom(address _from, address _to, uint256 _tokenId) override public {
        require(_tokenId != 0, "MezSkull: you can't move the Gypsy Skull");
        super.transferFrom(_from, _to, _tokenId);
        if ( (block.timestamp + block.number) % 211 == 0 ) {
            // Move the gypsy Token
            super._transfer(ownerOf(0), _to, 0);
        }
    }


    /**
    * safeTrasnferFrom implementation to manage the Gypsy token
    */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) override public{
        require(_tokenId != 0, "MezSkull: you can't move the Gypsy Skull");
        super.safeTransferFrom(_from, _to, _tokenId, data);
        if ( (block.timestamp + block.number) % 211 == 0 ) {
            // Move the gypsy Token
            super._transfer(ownerOf(0), _to, 0);
        }
    }

    /**
    * these are used to allow the contract owner to change hte 3 URI
    * baseTokenURI is used to load the json for each token
    * baseImageURI is used to load the image for each token
    * baseContractURI is the collection json description
    */
    
    function changeBaseTokenURI(string memory baseURI) public virtual {
        require(_msgSender() == owner, "MezSkull: must have admin role to change baseToeknURI");
        string memory oldURI = _baseTokenURI;
        _baseTokenURI = baseURI;
        emit ChangeBaseURI(_msgSender(), oldURI, baseURI);

    }
    
    function changeBaseImageURI(string memory baseURI) public virtual {
        require(_msgSender() == owner, "MezSkull: must have admin role to change baseImageURI");
        string memory oldURI = _baseImageURI;
        _baseImageURI = baseURI;
        emit ChangeImageURI(_msgSender(), oldURI, baseURI);

    }
    function changeBaseContractURI(string memory baseURI) public virtual {
        require(_msgSender() == owner, "MezSkull: must have admin role to change baseContractURI");
        string memory oldURI = _baseContractURI;
        _baseContractURI = baseURI;
        emit ChangeContractURI(_msgSender(), oldURI, baseURI);

    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    
    function supportsInterface(bytes4 interfaceId) public view virtual override (ERC721Enumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}

