{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/disputes/DisputeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"../governance/Managed.sol\\\";\\nimport \\\"../upgrades/GraphUpgradeable.sol\\\";\\nimport \\\"../utils/TokenUtils.sol\\\";\\n\\nimport \\\"./DisputeManagerStorage.sol\\\";\\nimport \\\"./IDisputeManager.sol\\\";\\n\\n/*\\n * @title DisputeManager\\n * @notice Provides a way to align the incentives of participants by having slashing as deterrent\\n * for incorrect behaviour.\\n *\\n * There are two types of disputes that can be created: Query disputes and Indexing disputes.\\n *\\n * Query Disputes:\\n * Graph nodes receive queries and return responses with signed receipts called attestations.\\n * An attestation can be disputed if the consumer thinks the query response was invalid.\\n * Indexers use the derived private key for an allocation to sign attestations.\\n *\\n * Indexing Disputes:\\n * Indexers present a Proof of Indexing (POI) when they close allocations to prove\\n * they were indexing a subgraph. The Staking contract emits that proof with the format\\n * keccak256(indexer.address, POI).\\n * Any challenger can dispute the validity of a POI by submitting a dispute to this contract\\n * along with a deposit.\\n *\\n * Arbitration:\\n * Disputes can only be accepted, rejected or drawn by the arbitrator role that can be delegated\\n * to a EOA or DAO.\\n */\\ncontract DisputeManager is DisputeManagerV1Storage, GraphUpgradeable, IDisputeManager {\\n    using SafeMath for uint256;\\n\\n    // -- EIP-712  --\\n\\n    bytes32 private constant DOMAIN_TYPE_HASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\\\"\\n        );\\n    bytes32 private constant DOMAIN_NAME_HASH = keccak256(\\\"Graph Protocol\\\");\\n    bytes32 private constant DOMAIN_VERSION_HASH = keccak256(\\\"0\\\");\\n    bytes32 private constant DOMAIN_SALT =\\n        0xa070ffb1cd7409649bf77822cce74495468e06dbfaef09556838bf188679b9c2;\\n    bytes32 private constant RECEIPT_TYPE_HASH =\\n        keccak256(\\\"Receipt(bytes32 requestCID,bytes32 responseCID,bytes32 subgraphDeploymentID)\\\");\\n\\n    // -- Constants --\\n\\n    // Attestation size is the sum of the receipt (96) + signature (65)\\n    uint256 private constant ATTESTATION_SIZE_BYTES = RECEIPT_SIZE_BYTES + SIG_SIZE_BYTES;\\n    uint256 private constant RECEIPT_SIZE_BYTES = 96;\\n\\n    uint256 private constant SIG_R_LENGTH = 32;\\n    uint256 private constant SIG_S_LENGTH = 32;\\n    uint256 private constant SIG_V_LENGTH = 1;\\n    uint256 private constant SIG_R_OFFSET = RECEIPT_SIZE_BYTES;\\n    uint256 private constant SIG_S_OFFSET = RECEIPT_SIZE_BYTES + SIG_R_LENGTH;\\n    uint256 private constant SIG_V_OFFSET = RECEIPT_SIZE_BYTES + SIG_R_LENGTH + SIG_S_LENGTH;\\n    uint256 private constant SIG_SIZE_BYTES = SIG_R_LENGTH + SIG_S_LENGTH + SIG_V_LENGTH;\\n\\n    uint256 private constant UINT8_BYTE_LENGTH = 1;\\n    uint256 private constant BYTES32_BYTE_LENGTH = 32;\\n\\n    uint256 private constant MAX_PPM = 1000000; // 100% in parts per million\\n\\n    // -- Events --\\n\\n    /**\\n     * @dev Emitted when a query dispute is created for `subgraphDeploymentID` and `indexer`\\n     * by `fisherman`.\\n     * The event emits the amount of `tokens` deposited by the fisherman and `attestation` submitted.\\n     */\\n    event QueryDisputeCreated(\\n        bytes32 indexed disputeID,\\n        address indexed indexer,\\n        address indexed fisherman,\\n        uint256 tokens,\\n        bytes32 subgraphDeploymentID,\\n        bytes attestation\\n    );\\n\\n    /**\\n     * @dev Emitted when an indexing dispute is created for `allocationID` and `indexer`\\n     * by `fisherman`.\\n     * The event emits the amount of `tokens` deposited by the fisherman.\\n     */\\n    event IndexingDisputeCreated(\\n        bytes32 indexed disputeID,\\n        address indexed indexer,\\n        address indexed fisherman,\\n        uint256 tokens,\\n        address allocationID\\n    );\\n\\n    /**\\n     * @dev Emitted when arbitrator accepts a `disputeID` to `indexer` created by `fisherman`.\\n     * The event emits the amount `tokens` transferred to the fisherman, the deposit plus reward.\\n     */\\n    event DisputeAccepted(\\n        bytes32 indexed disputeID,\\n        address indexed indexer,\\n        address indexed fisherman,\\n        uint256 tokens\\n    );\\n\\n    /**\\n     * @dev Emitted when arbitrator rejects a `disputeID` for `indexer` created by `fisherman`.\\n     * The event emits the amount `tokens` burned from the fisherman deposit.\\n     */\\n    event DisputeRejected(\\n        bytes32 indexed disputeID,\\n        address indexed indexer,\\n        address indexed fisherman,\\n        uint256 tokens\\n    );\\n\\n    /**\\n     * @dev Emitted when arbitrator draw a `disputeID` for `indexer` created by `fisherman`.\\n     * The event emits the amount `tokens` used as deposit and returned to the fisherman.\\n     */\\n    event DisputeDrawn(\\n        bytes32 indexed disputeID,\\n        address indexed indexer,\\n        address indexed fisherman,\\n        uint256 tokens\\n    );\\n\\n    /**\\n     * @dev Emitted when two disputes are in conflict to link them.\\n     * This event will be emitted after each DisputeCreated event is emitted\\n     * for each of the individual disputes.\\n     */\\n    event DisputeLinked(bytes32 indexed disputeID1, bytes32 indexed disputeID2);\\n\\n    // -- Modifiers --\\n\\n    function _onlyArbitrator() internal view {\\n        require(msg.sender == arbitrator, \\\"Caller is not the Arbitrator\\\");\\n    }\\n\\n    /**\\n     * @dev Check if the caller is the arbitrator.\\n     */\\n    modifier onlyArbitrator {\\n        _onlyArbitrator();\\n        _;\\n    }\\n\\n    // -- Functions --\\n\\n    /**\\n     * @dev Initialize this contract.\\n     * @param _arbitrator Arbitrator role\\n     * @param _minimumDeposit Minimum deposit required to create a Dispute\\n     * @param _fishermanRewardPercentage Percent of slashed funds for fisherman (ppm)\\n     * @param _qrySlashingPercentage Percentage of indexer stake slashed for query disputes (ppm)\\n     * @param _idxSlashingPercentage Percentage of indexer stake slashed for indexing disputes (ppm)\\n     */\\n    function initialize(\\n        address _controller,\\n        address _arbitrator,\\n        uint256 _minimumDeposit,\\n        uint32 _fishermanRewardPercentage,\\n        uint32 _qrySlashingPercentage,\\n        uint32 _idxSlashingPercentage\\n    ) external onlyImpl {\\n        Managed._initialize(_controller);\\n\\n        // Settings\\n        _setArbitrator(_arbitrator);\\n        _setMinimumDeposit(_minimumDeposit);\\n        _setFishermanRewardPercentage(_fishermanRewardPercentage);\\n        _setSlashingPercentage(_qrySlashingPercentage, _idxSlashingPercentage);\\n\\n        // EIP-712 domain separator\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPE_HASH,\\n                DOMAIN_NAME_HASH,\\n                DOMAIN_VERSION_HASH,\\n                _getChainID(),\\n                address(this),\\n                DOMAIN_SALT\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Set the arbitrator address.\\n     * @notice Update the arbitrator to `_arbitrator`\\n     * @param _arbitrator The address of the arbitration contract or party\\n     */\\n    function setArbitrator(address _arbitrator) external override onlyGovernor {\\n        _setArbitrator(_arbitrator);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the arbitrator address.\\n     * @notice Update the arbitrator to `_arbitrator`\\n     * @param _arbitrator The address of the arbitration contract or party\\n     */\\n    function _setArbitrator(address _arbitrator) private {\\n        require(_arbitrator != address(0), \\\"Arbitrator must be set\\\");\\n        arbitrator = _arbitrator;\\n        emit ParameterUpdated(\\\"arbitrator\\\");\\n    }\\n\\n    /**\\n     * @dev Set the minimum deposit required to create a dispute.\\n     * @notice Update the minimum deposit to `_minimumDeposit` Graph Tokens\\n     * @param _minimumDeposit The minimum deposit in Graph Tokens\\n     */\\n    function setMinimumDeposit(uint256 _minimumDeposit) external override onlyGovernor {\\n        _setMinimumDeposit(_minimumDeposit);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the minimum deposit required to create a dispute.\\n     * @notice Update the minimum deposit to `_minimumDeposit` Graph Tokens\\n     * @param _minimumDeposit The minimum deposit in Graph Tokens\\n     */\\n    function _setMinimumDeposit(uint256 _minimumDeposit) private {\\n        require(_minimumDeposit > 0, \\\"Minimum deposit must be set\\\");\\n        minimumDeposit = _minimumDeposit;\\n        emit ParameterUpdated(\\\"minimumDeposit\\\");\\n    }\\n\\n    /**\\n     * @dev Set the percent reward that the fisherman gets when slashing occurs.\\n     * @notice Update the reward percentage to `_percentage`\\n     * @param _percentage Reward as a percentage of indexer stake\\n     */\\n    function setFishermanRewardPercentage(uint32 _percentage) external override onlyGovernor {\\n        _setFishermanRewardPercentage(_percentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the percent reward that the fisherman gets when slashing occurs.\\n     * @notice Update the reward percentage to `_percentage`\\n     * @param _percentage Reward as a percentage of indexer stake\\n     */\\n    function _setFishermanRewardPercentage(uint32 _percentage) private {\\n        // Must be within 0% to 100% (inclusive)\\n        require(_percentage <= MAX_PPM, \\\"Reward percentage must be below or equal to MAX_PPM\\\");\\n        fishermanRewardPercentage = _percentage;\\n        emit ParameterUpdated(\\\"fishermanRewardPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Set the percentage used for slashing indexers.\\n     * @param _qryPercentage Percentage slashing for query disputes\\n     * @param _idxPercentage Percentage slashing for indexing disputes\\n     */\\n    function setSlashingPercentage(uint32 _qryPercentage, uint32 _idxPercentage)\\n        external\\n        override\\n        onlyGovernor\\n    {\\n        _setSlashingPercentage(_qryPercentage, _idxPercentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the percentage used for slashing indexers.\\n     * @param _qryPercentage Percentage slashing for query disputes\\n     * @param _idxPercentage Percentage slashing for indexing disputes\\n     */\\n    function _setSlashingPercentage(uint32 _qryPercentage, uint32 _idxPercentage) private {\\n        // Must be within 0% to 100% (inclusive)\\n        require(\\n            _qryPercentage <= MAX_PPM && _idxPercentage <= MAX_PPM,\\n            \\\"Slashing percentage must be below or equal to MAX_PPM\\\"\\n        );\\n        qrySlashingPercentage = _qryPercentage;\\n        idxSlashingPercentage = _idxPercentage;\\n        emit ParameterUpdated(\\\"qrySlashingPercentage\\\");\\n        emit ParameterUpdated(\\\"idxSlashingPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Return whether a dispute exists or not.\\n     * @notice Return if dispute with ID `_disputeID` exists\\n     * @param _disputeID True if dispute already exists\\n     */\\n    function isDisputeCreated(bytes32 _disputeID) public view override returns (bool) {\\n        return disputes[_disputeID].fisherman != address(0);\\n    }\\n\\n    /**\\n     * @dev Get the message hash that an indexer used to sign the receipt.\\n     * Encodes a receipt using a domain separator, as described on\\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification.\\n     * @notice Return the message hash used to sign the receipt\\n     * @param _receipt Receipt returned by indexer and submitted by fisherman\\n     * @return Message hash used to sign the receipt\\n     */\\n    function encodeHashReceipt(Receipt memory _receipt) public view override returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\", // EIP-191 encoding pad, EIP-712 version 1\\n                    DOMAIN_SEPARATOR,\\n                    keccak256(\\n                        abi.encode(\\n                            RECEIPT_TYPE_HASH,\\n                            _receipt.requestCID,\\n                            _receipt.responseCID,\\n                            _receipt.subgraphDeploymentID\\n                        ) // EIP 712-encoded message hash\\n                    )\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns if two attestations are conflicting.\\n     * Everything must match except for the responseID.\\n     * @param _attestation1 Attestation\\n     * @param _attestation2 Attestation\\n     * @return True if the two attestations are conflicting\\n     */\\n    function areConflictingAttestations(\\n        Attestation memory _attestation1,\\n        Attestation memory _attestation2\\n    ) public pure override returns (bool) {\\n        return (_attestation1.requestCID == _attestation2.requestCID &&\\n            _attestation1.subgraphDeploymentID == _attestation2.subgraphDeploymentID &&\\n            _attestation1.responseCID != _attestation2.responseCID);\\n    }\\n\\n    /**\\n     * @dev Returns the indexer that signed an attestation.\\n     * @param _attestation Attestation\\n     * @return Indexer address\\n     */\\n    function getAttestationIndexer(Attestation memory _attestation)\\n        public\\n        view\\n        override\\n        returns (address)\\n    {\\n        // Get attestation signer. Indexers signs with the allocationID\\n        address allocationID = _recoverAttestationSigner(_attestation);\\n\\n        IStaking.Allocation memory alloc = staking().getAllocation(allocationID);\\n        require(alloc.indexer != address(0), \\\"Indexer cannot be found for the attestation\\\");\\n        require(\\n            alloc.subgraphDeploymentID == _attestation.subgraphDeploymentID,\\n            \\\"Allocation and attestation subgraphDeploymentID must match\\\"\\n        );\\n        return alloc.indexer;\\n    }\\n\\n    /**\\n     * @dev Create a query dispute for the arbitrator to resolve.\\n     * This function is called by a fisherman that will need to `_deposit` at\\n     * least `minimumDeposit` GRT tokens.\\n     * @param _attestationData Attestation bytes submitted by the fisherman\\n     * @param _deposit Amount of tokens staked as deposit\\n     */\\n    function createQueryDispute(bytes calldata _attestationData, uint256 _deposit)\\n        external\\n        override\\n        returns (bytes32)\\n    {\\n        // Get funds from submitter\\n        _pullSubmitterDeposit(_deposit);\\n\\n        // Create a dispute\\n        return\\n            _createQueryDisputeWithAttestation(\\n                msg.sender,\\n                _deposit,\\n                _parseAttestation(_attestationData),\\n                _attestationData\\n            );\\n    }\\n\\n    /**\\n     * @dev Create query disputes for two conflicting attestations.\\n     * A conflicting attestation is a proof presented by two different indexers\\n     * where for the same request on a subgraph the response is different.\\n     * For this type of dispute the submitter is not required to present a deposit\\n     * as one of the attestation is considered to be right.\\n     * Two linked disputes will be created and if the arbitrator resolve one, the other\\n     * one will be automatically resolved.\\n     * @param _attestationData1 First attestation data submitted\\n     * @param _attestationData2 Second attestation data submitted\\n     * @return DisputeID1, DisputeID2\\n     */\\n    function createQueryDisputeConflict(\\n        bytes calldata _attestationData1,\\n        bytes calldata _attestationData2\\n    ) external override returns (bytes32, bytes32) {\\n        address fisherman = msg.sender;\\n\\n        // Parse each attestation\\n        Attestation memory attestation1 = _parseAttestation(_attestationData1);\\n        Attestation memory attestation2 = _parseAttestation(_attestationData2);\\n\\n        // Test that attestations are conflicting\\n        require(\\n            areConflictingAttestations(attestation1, attestation2),\\n            \\\"Attestations must be in conflict\\\"\\n        );\\n\\n        // Create the disputes\\n        // The deposit is zero for conflicting attestations\\n        bytes32 dID1 =\\n            _createQueryDisputeWithAttestation(fisherman, 0, attestation1, _attestationData1);\\n        bytes32 dID2 =\\n            _createQueryDisputeWithAttestation(fisherman, 0, attestation2, _attestationData2);\\n\\n        // Store the linked disputes to be resolved\\n        disputes[dID1].relatedDisputeID = dID2;\\n        disputes[dID2].relatedDisputeID = dID1;\\n\\n        // Emit event that links the two created disputes\\n        emit DisputeLinked(dID1, dID2);\\n\\n        return (dID1, dID2);\\n    }\\n\\n    /**\\n     * @dev Create a query dispute passing the parsed attestation.\\n     * To be used in createQueryDispute() and createQueryDisputeConflict()\\n     * to avoid calling parseAttestation() multiple times\\n     * `_attestationData` is only passed to be emitted\\n     * @param _fisherman Creator of dispute\\n     * @param _deposit Amount of tokens staked as deposit\\n     * @param _attestation Attestation struct parsed from bytes\\n     * @param _attestationData Attestation bytes submitted by the fisherman\\n     * @return DisputeID\\n     */\\n    function _createQueryDisputeWithAttestation(\\n        address _fisherman,\\n        uint256 _deposit,\\n        Attestation memory _attestation,\\n        bytes memory _attestationData\\n    ) private returns (bytes32) {\\n        // Get the indexer that signed the attestation\\n        address indexer = getAttestationIndexer(_attestation);\\n\\n        // The indexer is disputable\\n        require(staking().getIndexerStakedTokens(indexer) > 0, \\\"Dispute indexer has no stake\\\");\\n\\n        // Create a disputeID\\n        bytes32 disputeID =\\n            keccak256(\\n                abi.encodePacked(\\n                    _attestation.requestCID,\\n                    _attestation.responseCID,\\n                    _attestation.subgraphDeploymentID,\\n                    indexer,\\n                    _fisherman\\n                )\\n            );\\n\\n        // Only one dispute for a (indexer, subgraphDeploymentID) at a time\\n        require(!isDisputeCreated(disputeID), \\\"Dispute already created\\\");\\n\\n        // Store dispute\\n        disputes[disputeID] = Dispute(\\n            indexer,\\n            _fisherman,\\n            _deposit,\\n            0, // no related dispute,\\n            DisputeType.QueryDispute\\n        );\\n\\n        emit QueryDisputeCreated(\\n            disputeID,\\n            indexer,\\n            _fisherman,\\n            _deposit,\\n            _attestation.subgraphDeploymentID,\\n            _attestationData\\n        );\\n\\n        return disputeID;\\n    }\\n\\n    /**\\n     * @dev Create an indexing dispute for the arbitrator to resolve.\\n     * The disputes are created in reference to an allocationID\\n     * This function is called by a challenger that will need to `_deposit` at\\n     * least `minimumDeposit` GRT tokens.\\n     * @param _allocationID The allocation to dispute\\n     * @param _deposit Amount of tokens staked as deposit\\n     */\\n    function createIndexingDispute(address _allocationID, uint256 _deposit)\\n        external\\n        override\\n        returns (bytes32)\\n    {\\n        // Get funds from submitter\\n        _pullSubmitterDeposit(_deposit);\\n\\n        // Create a dispute\\n        return _createIndexingDisputeWithAllocation(msg.sender, _deposit, _allocationID);\\n    }\\n\\n    /**\\n     * @dev Create indexing dispute internal function.\\n     * @param _fisherman The challenger creating the dispute\\n     * @param _deposit Amount of tokens staked as deposit\\n     * @param _allocationID Allocation disputed\\n     */\\n\\n    function _createIndexingDisputeWithAllocation(\\n        address _fisherman,\\n        uint256 _deposit,\\n        address _allocationID\\n    ) private returns (bytes32) {\\n        // Create a disputeID\\n        bytes32 disputeID = keccak256(abi.encodePacked(_allocationID));\\n\\n        // Only one dispute for an allocationID at a time\\n        require(!isDisputeCreated(disputeID), \\\"Dispute already created\\\");\\n\\n        // Allocation must exist\\n        IStaking staking = staking();\\n        IStaking.Allocation memory alloc = staking.getAllocation(_allocationID);\\n        require(alloc.indexer != address(0), \\\"Dispute allocation must exist\\\");\\n\\n        // The indexer must be disputable\\n        require(staking.getIndexerStakedTokens(alloc.indexer) > 0, \\\"Dispute indexer has no stake\\\");\\n\\n        // Store dispute\\n        disputes[disputeID] = Dispute(\\n            alloc.indexer,\\n            _fisherman,\\n            _deposit,\\n            0,\\n            DisputeType.IndexingDispute\\n        );\\n\\n        emit IndexingDisputeCreated(disputeID, alloc.indexer, _fisherman, _deposit, _allocationID);\\n\\n        return disputeID;\\n    }\\n\\n    /**\\n     * @dev The arbitrator accepts a dispute as being valid.\\n     * This function will revert if the indexer is not slashable, whether because it does not have\\n     * any stake available or the slashing percentage is configured to be zero. In those cases\\n     * a dispute must be resolved using drawDispute or rejectDispute.\\n     * @notice Accept a dispute with ID `_disputeID`\\n     * @param _disputeID ID of the dispute to be accepted\\n     */\\n    function acceptDispute(bytes32 _disputeID) external override onlyArbitrator {\\n        Dispute memory dispute = _resolveDispute(_disputeID);\\n\\n        // Slash\\n        (, uint256 tokensToReward) =\\n            _slashIndexer(dispute.indexer, dispute.fisherman, dispute.disputeType);\\n\\n        // Give the fisherman their deposit back\\n        TokenUtils.pushTokens(graphToken(), dispute.fisherman, dispute.deposit);\\n\\n        // Resolve the conflicting dispute if any\\n        _resolveDisputeInConflict(dispute);\\n\\n        emit DisputeAccepted(\\n            _disputeID,\\n            dispute.indexer,\\n            dispute.fisherman,\\n            dispute.deposit.add(tokensToReward)\\n        );\\n    }\\n\\n    /**\\n     * @dev The arbitrator rejects a dispute as being invalid.\\n     * @notice Reject a dispute with ID `_disputeID`\\n     * @param _disputeID ID of the dispute to be rejected\\n     */\\n    function rejectDispute(bytes32 _disputeID) external override onlyArbitrator {\\n        Dispute memory dispute = _resolveDispute(_disputeID);\\n\\n        // Handle conflicting dispute if any\\n        require(\\n            !_isDisputeInConflict(dispute),\\n            \\\"Dispute for conflicting attestation, must accept the related ID to reject\\\"\\n        );\\n\\n        // Burn the fisherman's deposit\\n        TokenUtils.burnTokens(graphToken(), dispute.deposit);\\n\\n        emit DisputeRejected(_disputeID, dispute.indexer, dispute.fisherman, dispute.deposit);\\n    }\\n\\n    /**\\n     * @dev The arbitrator draws dispute.\\n     * @notice Ignore a dispute with ID `_disputeID`\\n     * @param _disputeID ID of the dispute to be disregarded\\n     */\\n    function drawDispute(bytes32 _disputeID) external override onlyArbitrator {\\n        Dispute memory dispute = _resolveDispute(_disputeID);\\n\\n        // Return deposit to the fisherman\\n        TokenUtils.pushTokens(graphToken(), dispute.fisherman, dispute.deposit);\\n\\n        // Resolve the conflicting dispute if any\\n        _resolveDisputeInConflict(dispute);\\n\\n        emit DisputeDrawn(_disputeID, dispute.indexer, dispute.fisherman, dispute.deposit);\\n    }\\n\\n    /**\\n     * @dev Resolve a dispute by removing it from storage and returning a memory copy.\\n     * @param _disputeID ID of the dispute to resolve\\n     * @return Dispute\\n     */\\n    function _resolveDispute(bytes32 _disputeID) private returns (Dispute memory) {\\n        require(isDisputeCreated(_disputeID), \\\"Dispute does not exist\\\");\\n\\n        Dispute memory dispute = disputes[_disputeID];\\n\\n        // Resolve dispute\\n        delete disputes[_disputeID]; // Re-entrancy\\n\\n        return dispute;\\n    }\\n\\n    /**\\n     * @dev Returns whether the dispute is for a conflicting attestation or not.\\n     * @param _dispute Dispute\\n     * @return True conflicting attestation dispute\\n     */\\n    function _isDisputeInConflict(Dispute memory _dispute) private pure returns (bool) {\\n        return _dispute.relatedDisputeID != 0;\\n    }\\n\\n    /**\\n     * @dev Resolve the conflicting dispute if there is any for the one passed to this function.\\n     * @param _dispute Dispute\\n     * @return True if resolved\\n     */\\n    function _resolveDisputeInConflict(Dispute memory _dispute) private returns (bool) {\\n        if (_isDisputeInConflict(_dispute)) {\\n            bytes32 relatedDisputeID = _dispute.relatedDisputeID;\\n            delete disputes[relatedDisputeID];\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Pull deposit from submitter account.\\n     * @param _deposit Amount of tokens to deposit\\n     */\\n    function _pullSubmitterDeposit(uint256 _deposit) private {\\n        // Ensure that fisherman has staked at least the minimum amount\\n        require(_deposit >= minimumDeposit, \\\"Dispute deposit is under minimum required\\\");\\n\\n        // Transfer tokens to deposit from fisherman to this contract\\n        TokenUtils.pullTokens(graphToken(), msg.sender, _deposit);\\n    }\\n\\n    /**\\n     * @dev Make the staking contract slash the indexer and reward the challenger.\\n     * Give the challenger a reward equal to the fishermanRewardPercentage of slashed amount\\n     * @param _indexer Address of the indexer\\n     * @param _challenger Address of the challenger\\n     * @param _disputeType Type of dispute\\n     * @return slashAmount Dispute slash amount\\n     * @return rewardsAmount Dispute rewards amount\\n     */\\n    function _slashIndexer(\\n        address _indexer,\\n        address _challenger,\\n        DisputeType _disputeType\\n    ) private returns (uint256 slashAmount, uint256 rewardsAmount) {\\n        IStaking staking = staking();\\n\\n        // Get slashable amount for indexer\\n        uint256 slashableAmount = staking.getIndexerStakedTokens(_indexer); // slashable tokens\\n\\n        // Get slash amount\\n        slashAmount = _getSlashingPercentageForDisputeType(_disputeType).mul(slashableAmount).div(\\n            MAX_PPM\\n        );\\n        require(slashAmount > 0, \\\"Dispute has zero tokens to slash\\\");\\n\\n        // Get rewards amount\\n        rewardsAmount = uint256(fishermanRewardPercentage).mul(slashAmount).div(MAX_PPM);\\n\\n        // Have staking contract slash the indexer and reward the fisherman\\n        // Give the fisherman a reward equal to the fishermanRewardPercentage of slashed amount\\n        staking.slash(_indexer, slashAmount, rewardsAmount, _challenger);\\n    }\\n\\n    /**\\n     * @dev Recover the signer address of the `_attestation`.\\n     * @param _disputeType Dispute type\\n     * @return Slashing percentage to use for the dispute type\\n     */\\n    function _getSlashingPercentageForDisputeType(DisputeType _disputeType)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        if (_disputeType == DisputeType.QueryDispute) return uint256(qrySlashingPercentage);\\n        if (_disputeType == DisputeType.IndexingDispute) return uint256(idxSlashingPercentage);\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Recover the signer address of the `_attestation`.\\n     * @param _attestation The attestation struct\\n     * @return Signer address\\n     */\\n    function _recoverAttestationSigner(Attestation memory _attestation)\\n        private\\n        view\\n        returns (address)\\n    {\\n        // Obtain the hash of the fully-encoded message, per EIP-712 encoding\\n        Receipt memory receipt =\\n            Receipt(\\n                _attestation.requestCID,\\n                _attestation.responseCID,\\n                _attestation.subgraphDeploymentID\\n            );\\n        bytes32 messageHash = encodeHashReceipt(receipt);\\n\\n        // Obtain the signer of the fully-encoded EIP-712 message hash\\n        // NOTE: The signer of the attestation is the indexer that served the request\\n        return\\n            ECDSA.recover(\\n                messageHash,\\n                abi.encodePacked(_attestation.r, _attestation.s, _attestation.v)\\n            );\\n    }\\n\\n    /**\\n     * @dev Get the running network chain ID\\n     * @return The chain ID\\n     */\\n    function _getChainID() private pure returns (uint256) {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n\\n    /**\\n     * @dev Parse the bytes attestation into a struct from `_data`.\\n     * @return Attestation struct\\n     */\\n    function _parseAttestation(bytes memory _data) private pure returns (Attestation memory) {\\n        // Check attestation data length\\n        require(_data.length == ATTESTATION_SIZE_BYTES, \\\"Attestation must be 161 bytes long\\\");\\n\\n        // Decode receipt\\n        (bytes32 requestCID, bytes32 responseCID, bytes32 subgraphDeploymentID) =\\n            abi.decode(_data, (bytes32, bytes32, bytes32));\\n\\n        // Decode signature\\n        // Signature is expected to be in the order defined in the Attestation struct\\n        bytes32 r = _toBytes32(_data, SIG_R_OFFSET);\\n        bytes32 s = _toBytes32(_data, SIG_S_OFFSET);\\n        uint8 v = _toUint8(_data, SIG_V_OFFSET);\\n\\n        return Attestation(requestCID, responseCID, subgraphDeploymentID, r, s, v);\\n    }\\n\\n    /**\\n     * @dev Parse a uint8 from `_bytes` starting at offset `_start`.\\n     * @return uint8 value\\n     */\\n    function _toUint8(bytes memory _bytes, uint256 _start) private pure returns (uint8) {\\n        require(_bytes.length >= (_start + UINT8_BYTE_LENGTH), \\\"Bytes: out of bounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    /**\\n     * @dev Parse a bytes32 from `_bytes` starting at offset `_start`.\\n     * @return bytes32 value\\n     */\\n    function _toBytes32(bytes memory _bytes, uint256 _start) private pure returns (bytes32) {\\n        require(_bytes.length >= (_start + BYTES32_BYTE_LENGTH), \\\"Bytes: out of bounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Managed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IController.sol\\\";\\n\\nimport \\\"../curation/ICuration.sol\\\";\\nimport \\\"../epochs/IEpochManager.sol\\\";\\nimport \\\"../rewards/IRewardsManager.sol\\\";\\nimport \\\"../staking/IStaking.sol\\\";\\nimport \\\"../token/IGraphToken.sol\\\";\\n\\n/**\\n * @title Graph Managed contract\\n * @dev The Managed contract provides an interface to interact with the Controller.\\n * It also provides local caching for contract addresses. This mechanism relies on calling the\\n * public `syncAllContracts()` function whenever a contract changes in the controller.\\n *\\n * Inspired by Livepeer:\\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\\n */\\ncontract Managed {\\n    // -- State --\\n\\n    // Controller that contract is registered with\\n    IController public controller;\\n    mapping(bytes32 => address) private addressCache;\\n    uint256[10] private __gap;\\n\\n    // -- Events --\\n\\n    event ParameterUpdated(string param);\\n    event SetController(address controller);\\n\\n    /**\\n     * @dev Emitted when contract with `nameHash` is synced to `contractAddress`.\\n     */\\n    event ContractSynced(bytes32 indexed nameHash, address contractAddress);\\n\\n    // -- Modifiers --\\n\\n    function _notPartialPaused() internal view {\\n        require(!controller.paused(), \\\"Paused\\\");\\n        require(!controller.partialPaused(), \\\"Partial-paused\\\");\\n    }\\n\\n    function _notPaused() internal view {\\n        require(!controller.paused(), \\\"Paused\\\");\\n    }\\n\\n    function _onlyGovernor() internal view {\\n        require(msg.sender == controller.getGovernor(), \\\"Caller must be Controller governor\\\");\\n    }\\n\\n    function _onlyController() internal view {\\n        require(msg.sender == address(controller), \\\"Caller must be Controller\\\");\\n    }\\n\\n    modifier notPartialPaused {\\n        _notPartialPaused();\\n        _;\\n    }\\n\\n    modifier notPaused {\\n        _notPaused();\\n        _;\\n    }\\n\\n    // Check if sender is controller.\\n    modifier onlyController() {\\n        _onlyController();\\n        _;\\n    }\\n\\n    // Check if sender is the governor.\\n    modifier onlyGovernor() {\\n        _onlyGovernor();\\n        _;\\n    }\\n\\n    // -- Functions --\\n\\n    /**\\n     * @dev Initialize the controller.\\n     */\\n    function _initialize(address _controller) internal {\\n        _setController(_controller);\\n    }\\n\\n    /**\\n     * @notice Set Controller. Only callable by current controller.\\n     * @param _controller Controller contract address\\n     */\\n    function setController(address _controller) external onlyController {\\n        _setController(_controller);\\n    }\\n\\n    /**\\n     * @dev Set controller.\\n     * @param _controller Controller contract address\\n     */\\n    function _setController(address _controller) internal {\\n        require(_controller != address(0), \\\"Controller must be set\\\");\\n        controller = IController(_controller);\\n        emit SetController(_controller);\\n    }\\n\\n    /**\\n     * @dev Return Curation interface.\\n     * @return Curation contract registered with Controller\\n     */\\n    function curation() internal view returns (ICuration) {\\n        return ICuration(_resolveContract(keccak256(\\\"Curation\\\")));\\n    }\\n\\n    /**\\n     * @dev Return EpochManager interface.\\n     * @return Epoch manager contract registered with Controller\\n     */\\n    function epochManager() internal view returns (IEpochManager) {\\n        return IEpochManager(_resolveContract(keccak256(\\\"EpochManager\\\")));\\n    }\\n\\n    /**\\n     * @dev Return RewardsManager interface.\\n     * @return Rewards manager contract registered with Controller\\n     */\\n    function rewardsManager() internal view returns (IRewardsManager) {\\n        return IRewardsManager(_resolveContract(keccak256(\\\"RewardsManager\\\")));\\n    }\\n\\n    /**\\n     * @dev Return Staking interface.\\n     * @return Staking contract registered with Controller\\n     */\\n    function staking() internal view returns (IStaking) {\\n        return IStaking(_resolveContract(keccak256(\\\"Staking\\\")));\\n    }\\n\\n    /**\\n     * @dev Return GraphToken interface.\\n     * @return Graph token contract registered with Controller\\n     */\\n    function graphToken() internal view returns (IGraphToken) {\\n        return IGraphToken(_resolveContract(keccak256(\\\"GraphToken\\\")));\\n    }\\n\\n    /**\\n     * @dev Resolve a contract address from the cache or the Controller if not found.\\n     * @return Address of the contract\\n     */\\n    function _resolveContract(bytes32 _nameHash) internal view returns (address) {\\n        address contractAddress = addressCache[_nameHash];\\n        if (contractAddress == address(0)) {\\n            contractAddress = controller.getContractProxy(_nameHash);\\n        }\\n        return contractAddress;\\n    }\\n\\n    /**\\n     * @dev Cache a contract address from the Controller registry.\\n     * @param _name Name of the contract to sync into the cache\\n     */\\n    function _syncContract(string memory _name) internal {\\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\\n        address contractAddress = controller.getContractProxy(nameHash);\\n        if (addressCache[nameHash] != contractAddress) {\\n            addressCache[nameHash] = contractAddress;\\n            emit ContractSynced(nameHash, contractAddress);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sync protocol contract addresses from the Controller registry.\\n     * This function will cache all the contracts using the latest addresses\\n     * Anyone can call the function whenever a Proxy contract change in the\\n     * controller to ensure the protocol is using the latest version\\n     */\\n    function syncAllContracts() external {\\n        _syncContract(\\\"Curation\\\");\\n        _syncContract(\\\"EpochManager\\\");\\n        _syncContract(\\\"RewardsManager\\\");\\n        _syncContract(\\\"Staking\\\");\\n        _syncContract(\\\"GraphToken\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/GraphUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IGraphProxy.sol\\\";\\n\\n/**\\n * @title Graph Upgradeable\\n * @dev This contract is intended to be inherited from upgradeable contracts.\\n */\\ncontract GraphUpgradeable {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32\\n        internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Check if the caller is the proxy admin.\\n     */\\n    modifier onlyProxyAdmin(IGraphProxy _proxy) {\\n        require(msg.sender == _proxy.admin(), \\\"Caller must be the proxy admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check if the caller is the implementation.\\n     */\\n    modifier onlyImpl {\\n        require(msg.sender == _implementation(), \\\"Caller must be the implementation\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     * @return impl Address of the current implementation\\n     */\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Accept to be an implementation of proxy.\\n     */\\n    function acceptProxy(IGraphProxy _proxy) external onlyProxyAdmin(_proxy) {\\n        _proxy.acceptUpgrade();\\n    }\\n\\n    /**\\n     * @dev Accept to be an implementation of proxy and then call a function from the new\\n     * implementation as specified by `_data`, which should be an encoded function call. This is\\n     * useful to initialize new storage variables in the proxied contract.\\n     */\\n    function acceptProxyAndCall(IGraphProxy _proxy, bytes calldata _data)\\n        external\\n        onlyProxyAdmin(_proxy)\\n    {\\n        _proxy.acceptUpgradeAndCall(_data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/TokenUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../token/IGraphToken.sol\\\";\\n\\nlibrary TokenUtils {\\n    /**\\n     * @dev Pull tokens from an address to this contract.\\n     * @param _graphToken Token to transfer\\n     * @param _from Address sending the tokens\\n     * @param _amount Amount of tokens to transfer\\n     */\\n    function pullTokens(\\n        IGraphToken _graphToken,\\n        address _from,\\n        uint256 _amount\\n    ) internal {\\n        if (_amount > 0) {\\n            require(_graphToken.transferFrom(_from, address(this), _amount), \\\"!transfer\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Push tokens from this contract to a receiving address.\\n     * @param _graphToken Token to transfer\\n     * @param _to Address receiving the tokens\\n     * @param _amount Amount of tokens to transfer\\n     */\\n    function pushTokens(\\n        IGraphToken _graphToken,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        if (_amount > 0) {\\n            require(_graphToken.transfer(_to, _amount), \\\"!transfer\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Burn tokens held by this contract.\\n     * @param _graphToken Token to burn\\n     * @param _amount Amount of tokens to burn\\n     */\\n    function burnTokens(IGraphToken _graphToken, uint256 _amount) internal {\\n        if (_amount > 0) {\\n            _graphToken.burn(_amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/disputes/DisputeManagerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../governance/Managed.sol\\\";\\n\\nimport \\\"./IDisputeManager.sol\\\";\\n\\ncontract DisputeManagerV1Storage is Managed {\\n    // -- State --\\n\\n    bytes32 internal DOMAIN_SEPARATOR;\\n\\n    // The arbitrator is solely in control of arbitrating disputes\\n    address public arbitrator;\\n\\n    // Minimum deposit required to create a Dispute\\n    uint256 public minimumDeposit;\\n\\n    // -- Slot 0xf\\n    // Percentage of indexer slashed funds to assign as a reward to fisherman in successful dispute\\n    // Parts per million. (Allows for 4 decimal points, 999,999 = 99.9999%)\\n    uint32 public fishermanRewardPercentage;\\n\\n    // Percentage of indexer stake to slash on disputes\\n    // Parts per million. (Allows for 4 decimal points, 999,999 = 99.9999%)\\n    uint32 public qrySlashingPercentage;\\n    uint32 public idxSlashingPercentage;\\n\\n    // -- Slot 0x10\\n    // Disputes created : disputeID => Dispute\\n    // disputeID - check creation functions to see how disputeID is built\\n    mapping(bytes32 => IDisputeManager.Dispute) public disputes;\\n}\\n\"\r\n    },\r\n    \"contracts/disputes/IDisputeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\ninterface IDisputeManager {\\n    // -- Dispute --\\n\\n    enum DisputeType { Null, IndexingDispute, QueryDispute }\\n\\n    // Disputes contain info necessary for the Arbitrator to verify and resolve\\n    struct Dispute {\\n        address indexer;\\n        address fisherman;\\n        uint256 deposit;\\n        bytes32 relatedDisputeID;\\n        DisputeType disputeType;\\n    }\\n\\n    // -- Attestation --\\n\\n    // Receipt content sent from indexer in response to request\\n    struct Receipt {\\n        bytes32 requestCID;\\n        bytes32 responseCID;\\n        bytes32 subgraphDeploymentID;\\n    }\\n\\n    // Attestation sent from indexer in response to a request\\n    struct Attestation {\\n        bytes32 requestCID;\\n        bytes32 responseCID;\\n        bytes32 subgraphDeploymentID;\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n    }\\n\\n    // -- Configuration --\\n\\n    function setArbitrator(address _arbitrator) external;\\n\\n    function setMinimumDeposit(uint256 _minimumDeposit) external;\\n\\n    function setFishermanRewardPercentage(uint32 _percentage) external;\\n\\n    function setSlashingPercentage(uint32 _qryPercentage, uint32 _idxPercentage) external;\\n\\n    // -- Getters --\\n\\n    function isDisputeCreated(bytes32 _disputeID) external view returns (bool);\\n\\n    function encodeHashReceipt(Receipt memory _receipt) external view returns (bytes32);\\n\\n    function areConflictingAttestations(\\n        Attestation memory _attestation1,\\n        Attestation memory _attestation2\\n    ) external pure returns (bool);\\n\\n    function getAttestationIndexer(Attestation memory _attestation) external view returns (address);\\n\\n    // -- Dispute --\\n\\n    function createQueryDispute(bytes calldata _attestationData, uint256 _deposit)\\n        external\\n        returns (bytes32);\\n\\n    function createQueryDisputeConflict(\\n        bytes calldata _attestationData1,\\n        bytes calldata _attestationData2\\n    ) external returns (bytes32, bytes32);\\n\\n    function createIndexingDispute(address _allocationID, uint256 _deposit)\\n        external\\n        returns (bytes32);\\n\\n    function acceptDispute(bytes32 _disputeID) external;\\n\\n    function rejectDispute(bytes32 _disputeID) external;\\n\\n    function drawDispute(bytes32 _disputeID) external;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12 <0.8.0;\\n\\ninterface IController {\\n    function getGovernor() external view returns (address);\\n\\n    // -- Registry --\\n\\n    function setContractProxy(bytes32 _id, address _contractAddress) external;\\n\\n    function unsetContractProxy(bytes32 _id) external;\\n\\n    function updateController(bytes32 _id, address _controller) external;\\n\\n    function getContractProxy(bytes32 _id) external view returns (address);\\n\\n    // -- Pausing --\\n\\n    function setPartialPaused(bool _partialPaused) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function setPauseGuardian(address _newPauseGuardian) external;\\n\\n    function paused() external view returns (bool);\\n\\n    function partialPaused() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/curation/ICuration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IGraphCurationToken.sol\\\";\\n\\ninterface ICuration {\\n    // -- Pool --\\n\\n    struct CurationPool {\\n        uint256 tokens; // GRT Tokens stored as reserves for the subgraph deployment\\n        uint32 reserveRatio; // Ratio for the bonding curve\\n        IGraphCurationToken gcs; // Curation token contract for this curation pool\\n    }\\n\\n    // -- Configuration --\\n\\n    function setDefaultReserveRatio(uint32 _defaultReserveRatio) external;\\n\\n    function setMinimumCurationDeposit(uint256 _minimumCurationDeposit) external;\\n\\n    function setCurationTaxPercentage(uint32 _percentage) external;\\n\\n    // -- Curation --\\n\\n    function mint(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokensIn,\\n        uint256 _signalOutMin\\n    ) external returns (uint256, uint256);\\n\\n    function burn(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _signalIn,\\n        uint256 _tokensOutMin\\n    ) external returns (uint256);\\n\\n    function collect(bytes32 _subgraphDeploymentID, uint256 _tokens) external;\\n\\n    // -- Getters --\\n\\n    function isCurated(bytes32 _subgraphDeploymentID) external view returns (bool);\\n\\n    function getCuratorSignal(address _curator, bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCurationPoolSignal(bytes32 _subgraphDeploymentID) external view returns (uint256);\\n\\n    function getCurationPoolTokens(bytes32 _subgraphDeploymentID) external view returns (uint256);\\n\\n    function tokensToSignal(bytes32 _subgraphDeploymentID, uint256 _tokensIn)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function signalToTokens(bytes32 _subgraphDeploymentID, uint256 _signalIn)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function curationTaxPercentage() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/epochs/IEpochManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ninterface IEpochManager {\\n    // -- Configuration --\\n\\n    function setEpochLength(uint256 _epochLength) external;\\n\\n    // -- Epochs\\n\\n    function runEpoch() external;\\n\\n    // -- Getters --\\n\\n    function isCurrentEpochRun() external view returns (bool);\\n\\n    function blockNum() external view returns (uint256);\\n\\n    function blockHash(uint256 _block) external view returns (bytes32);\\n\\n    function currentEpoch() external view returns (uint256);\\n\\n    function currentEpochBlock() external view returns (uint256);\\n\\n    function currentEpochBlockSinceStart() external view returns (uint256);\\n\\n    function epochsSince(uint256 _epoch) external view returns (uint256);\\n\\n    function epochsSinceUpdate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/IRewardsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ninterface IRewardsManager {\\n    /**\\n     * @dev Stores accumulated rewards and snapshots related to a particular SubgraphDeployment.\\n     */\\n    struct Subgraph {\\n        uint256 accRewardsForSubgraph;\\n        uint256 accRewardsForSubgraphSnapshot;\\n        uint256 accRewardsPerSignalSnapshot;\\n        uint256 accRewardsPerAllocatedToken;\\n    }\\n\\n    // -- Params --\\n\\n    function setIssuanceRate(uint256 _issuanceRate) external;\\n\\n    // -- Denylist --\\n\\n    function setSubgraphAvailabilityOracle(address _subgraphAvailabilityOracle) external;\\n\\n    function setDenied(bytes32 _subgraphDeploymentID, bool _deny) external;\\n\\n    function setDeniedMany(bytes32[] calldata _subgraphDeploymentID, bool[] calldata _deny)\\n        external;\\n\\n    function isDenied(bytes32 _subgraphDeploymentID) external view returns (bool);\\n\\n    // -- Getters --\\n\\n    function getNewRewardsPerSignal() external view returns (uint256);\\n\\n    function getAccRewardsPerSignal() external view returns (uint256);\\n\\n    function getAccRewardsForSubgraph(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getAccRewardsPerAllocatedToken(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function getRewards(address _allocationID) external view returns (uint256);\\n\\n    // -- Updates --\\n\\n    function updateAccRewardsPerSignal() external returns (uint256);\\n\\n    function takeRewards(address _allocationID) external returns (uint256);\\n\\n    // -- Hooks --\\n\\n    function onSubgraphSignalUpdate(bytes32 _subgraphDeploymentID) external returns (uint256);\\n\\n    function onSubgraphAllocationUpdate(bytes32 _subgraphDeploymentID) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IStakingData.sol\\\";\\n\\ninterface IStaking is IStakingData {\\n    // -- Allocation Data --\\n\\n    /**\\n     * @dev Possible states an allocation can be\\n     * States:\\n     * - Null = indexer == address(0)\\n     * - Active = not Null && tokens > 0\\n     * - Closed = Active && closedAtEpoch != 0\\n     * - Finalized = Closed && closedAtEpoch + channelDisputeEpochs > now()\\n     * - Claimed = not Null && tokens == 0\\n     */\\n    enum AllocationState { Null, Active, Closed, Finalized, Claimed }\\n\\n    // -- Configuration --\\n\\n    function setMinimumIndexerStake(uint256 _minimumIndexerStake) external;\\n\\n    function setThawingPeriod(uint32 _thawingPeriod) external;\\n\\n    function setCurationPercentage(uint32 _percentage) external;\\n\\n    function setProtocolPercentage(uint32 _percentage) external;\\n\\n    function setChannelDisputeEpochs(uint32 _channelDisputeEpochs) external;\\n\\n    function setMaxAllocationEpochs(uint32 _maxAllocationEpochs) external;\\n\\n    function setRebateRatio(uint32 _alphaNumerator, uint32 _alphaDenominator) external;\\n\\n    function setDelegationRatio(uint32 _delegationRatio) external;\\n\\n    function setDelegationParameters(\\n        uint32 _indexingRewardCut,\\n        uint32 _queryFeeCut,\\n        uint32 _cooldownBlocks\\n    ) external;\\n\\n    function setDelegationParametersCooldown(uint32 _blocks) external;\\n\\n    function setDelegationUnbondingPeriod(uint32 _delegationUnbondingPeriod) external;\\n\\n    function setDelegationTaxPercentage(uint32 _percentage) external;\\n\\n    function setSlasher(address _slasher, bool _allowed) external;\\n\\n    function setAssetHolder(address _assetHolder, bool _allowed) external;\\n\\n    // -- Operation --\\n\\n    function setOperator(address _operator, bool _allowed) external;\\n\\n    function isOperator(address _operator, address _indexer) external view returns (bool);\\n\\n    // -- Staking --\\n\\n    function stake(uint256 _tokens) external;\\n\\n    function stakeTo(address _indexer, uint256 _tokens) external;\\n\\n    function unstake(uint256 _tokens) external;\\n\\n    function slash(\\n        address _indexer,\\n        uint256 _tokens,\\n        uint256 _reward,\\n        address _beneficiary\\n    ) external;\\n\\n    function withdraw() external;\\n\\n    function setRewardsDestination(address _destination) external;\\n\\n    // -- Delegation --\\n\\n    function delegate(address _indexer, uint256 _tokens) external returns (uint256);\\n\\n    function undelegate(address _indexer, uint256 _shares) external returns (uint256);\\n\\n    function withdrawDelegated(address _indexer, address _newIndexer) external returns (uint256);\\n\\n    // -- Channel management and allocations --\\n\\n    function allocate(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function allocateFrom(\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function closeAllocation(address _allocationID, bytes32 _poi) external;\\n\\n    function closeAllocationMany(CloseAllocationRequest[] calldata _requests) external;\\n\\n    function closeAndAllocate(\\n        address _oldAllocationID,\\n        bytes32 _poi,\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function collect(uint256 _tokens, address _allocationID) external;\\n\\n    function claim(address _allocationID, bool _restake) external;\\n\\n    function claimMany(address[] calldata _allocationID, bool _restake) external;\\n\\n    // -- Getters and calculations --\\n\\n    function hasStake(address _indexer) external view returns (bool);\\n\\n    function getIndexerStakedTokens(address _indexer) external view returns (uint256);\\n\\n    function getIndexerCapacity(address _indexer) external view returns (uint256);\\n\\n    function getAllocation(address _allocationID) external view returns (Allocation memory);\\n\\n    function getAllocationState(address _allocationID) external view returns (AllocationState);\\n\\n    function isAllocation(address _allocationID) external view returns (bool);\\n\\n    function getSubgraphAllocatedTokens(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getDelegation(address _indexer, address _delegator)\\n        external\\n        view\\n        returns (Delegation memory);\\n\\n    function isDelegator(address _indexer, address _delegator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/token/IGraphToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IGraphToken is IERC20 {\\n    // -- Mint and Burn --\\n\\n    function burn(uint256 amount) external;\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    // -- Mint Admin --\\n\\n    function addMinter(address _account) external;\\n\\n    function removeMinter(address _account) external;\\n\\n    function renounceMinter() external;\\n\\n    function isMinter(address _account) external view returns (bool);\\n\\n    // -- Permit --\\n\\n    function permit(\\n        address _owner,\\n        address _spender,\\n        uint256 _value,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/curation/IGraphCurationToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IGraphCurationToken is IERC20 {\\n    function burnFrom(address _account, uint256 _amount) external;\\n\\n    function mint(address _to, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IStakingData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12 <0.8.0;\\n\\ninterface IStakingData {\\n    /**\\n     * @dev Allocate GRT tokens for the purpose of serving queries of a subgraph deployment\\n     * An allocation is created in the allocate() function and consumed in claim()\\n     */\\n    struct Allocation {\\n        address indexer;\\n        bytes32 subgraphDeploymentID;\\n        uint256 tokens; // Tokens allocated to a SubgraphDeployment\\n        uint256 createdAtEpoch; // Epoch when it was created\\n        uint256 closedAtEpoch; // Epoch when it was closed\\n        uint256 collectedFees; // Collected fees for the allocation\\n        uint256 effectiveAllocation; // Effective allocation when closed\\n        uint256 accRewardsPerAllocatedToken; // Snapshot used for reward calc\\n    }\\n\\n    /**\\n     * @dev Represents a request to close an allocation with a specific proof of indexing.\\n     * This is passed when calling closeAllocationMany to define the closing parameters for\\n     * each allocation.\\n     */\\n    struct CloseAllocationRequest {\\n        address allocationID;\\n        bytes32 poi;\\n    }\\n\\n    // -- Delegation Data --\\n\\n    /**\\n     * @dev Delegation pool information. One per indexer.\\n     */\\n    struct DelegationPool {\\n        uint32 cooldownBlocks; // Blocks to wait before updating parameters\\n        uint32 indexingRewardCut; // in PPM\\n        uint32 queryFeeCut; // in PPM\\n        uint256 updatedAtBlock; // Block when the pool was last updated\\n        uint256 tokens; // Total tokens as pool reserves\\n        uint256 shares; // Total shares minted in the pool\\n        mapping(address => Delegation) delegators; // Mapping of delegator => Delegation\\n    }\\n\\n    /**\\n     * @dev Individual delegation data of a delegator in a pool.\\n     */\\n    struct Delegation {\\n        uint256 shares; // Shares owned by a delegator in the pool\\n        uint256 tokensLocked; // Tokens locked for undelegation\\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/IGraphProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.3;\\n\\ninterface IGraphProxy {\\n    function admin() external returns (address);\\n\\n    function setAdmin(address _newAdmin) external;\\n\\n    function implementation() external returns (address);\\n\\n    function pendingImplementation() external returns (address);\\n\\n    function upgradeTo(address _newImplementation) external;\\n\\n    function acceptUpgrade() external;\\n\\n    function acceptUpgradeAndCall(bytes calldata data) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ContractSynced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"disputeID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"indexer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fisherman\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"DisputeAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"disputeID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"indexer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fisherman\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"DisputeDrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"disputeID1\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"disputeID2\",\"type\":\"bytes32\"}],\"name\":\"DisputeLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"disputeID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"indexer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fisherman\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"DisputeRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"disputeID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"indexer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fisherman\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allocationID\",\"type\":\"address\"}],\"name\":\"IndexingDisputeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"param\",\"type\":\"string\"}],\"name\":\"ParameterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"disputeID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"indexer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fisherman\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"attestation\",\"type\":\"bytes\"}],\"name\":\"QueryDisputeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"SetController\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_disputeID\",\"type\":\"bytes32\"}],\"name\":\"acceptDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"acceptProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"acceptProxyAndCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arbitrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"requestCID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"responseCID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct IDisputeManager.Attestation\",\"name\":\"_attestation1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"requestCID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"responseCID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct IDisputeManager.Attestation\",\"name\":\"_attestation2\",\"type\":\"tuple\"}],\"name\":\"areConflictingAttestations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_allocationID\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deposit\",\"type\":\"uint256\"}],\"name\":\"createIndexingDispute\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_attestationData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_deposit\",\"type\":\"uint256\"}],\"name\":\"createQueryDispute\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_attestationData1\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_attestationData2\",\"type\":\"bytes\"}],\"name\":\"createQueryDisputeConflict\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"disputes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"indexer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fisherman\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"relatedDisputeID\",\"type\":\"bytes32\"},{\"internalType\":\"enum IDisputeManager.DisputeType\",\"name\":\"disputeType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_disputeID\",\"type\":\"bytes32\"}],\"name\":\"drawDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"requestCID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"responseCID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"}],\"internalType\":\"struct IDisputeManager.Receipt\",\"name\":\"_receipt\",\"type\":\"tuple\"}],\"name\":\"encodeHashReceipt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fishermanRewardPercentage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"requestCID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"responseCID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct IDisputeManager.Attestation\",\"name\":\"_attestation\",\"type\":\"tuple\"}],\"name\":\"getAttestationIndexer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idxSlashingPercentage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_fishermanRewardPercentage\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_qrySlashingPercentage\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_idxSlashingPercentage\",\"type\":\"uint32\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_disputeID\",\"type\":\"bytes32\"}],\"name\":\"isDisputeCreated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"qrySlashingPercentage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_disputeID\",\"type\":\"bytes32\"}],\"name\":\"rejectDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arbitrator\",\"type\":\"address\"}],\"name\":\"setArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_percentage\",\"type\":\"uint32\"}],\"name\":\"setFishermanRewardPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumDeposit\",\"type\":\"uint256\"}],\"name\":\"setMinimumDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_qryPercentage\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_idxPercentage\",\"type\":\"uint32\"}],\"name\":\"setSlashingPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syncAllContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DisputeManager","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}