{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Randomize.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// small library to randomize using (min, max, seed, offsetBit etc...)\\nlibrary Randomize {\\n    struct Random {\\n        uint256 seed;\\n        uint256 offsetBit;\\n    }\\n\\n    /// @notice get an random number between (min and max) using seed and offseting bits\\n    ///         this function assumes that max is never bigger than 0xffffff (hex color with opacity included)\\n    /// @dev this function is simply used to get random number using a seed.\\n    ///      if does bitshifting operations to try to reuse the same seed as much as possible.\\n    ///      should be enough for anyth\\n    /// @param random the randomizer\\n    /// @param min the minimum\\n    /// @param max the maximum\\n    /// @return result the resulting pseudo random number\\n    function next(\\n        Random memory random,\\n        uint256 min,\\n        uint256 max\\n    ) internal pure returns (uint256 result) {\\n        uint256 newSeed = random.seed;\\n        uint256 newOffset = random.offsetBit + 3;\\n\\n        uint256 maxOffset = 4;\\n        uint256 mask = 0xf;\\n        if (max > 0xfffff) {\\n            mask = 0xffffff;\\n            maxOffset = 24;\\n        } else if (max > 0xffff) {\\n            mask = 0xfffff;\\n            maxOffset = 20;\\n        } else if (max > 0xfff) {\\n            mask = 0xffff;\\n            maxOffset = 16;\\n        } else if (max > 0xff) {\\n            mask = 0xfff;\\n            maxOffset = 12;\\n        } else if (max > 0xf) {\\n            mask = 0xff;\\n            maxOffset = 8;\\n        }\\n\\n        // if offsetBit is too high to get the max number\\n        // just get new seed and restart offset to 0\\n        if (newOffset > (256 - maxOffset)) {\\n            newOffset = 0;\\n            newSeed = uint256(keccak256(abi.encode(newSeed)));\\n        }\\n\\n        uint256 offseted = (newSeed >> newOffset);\\n        uint256 part = offseted & mask;\\n        result = min + (part % (max - min));\\n\\n        random.seed = newSeed;\\n        random.offsetBit = newOffset;\\n    }\\n\\n    function nextInt(\\n        Random memory random,\\n        uint256 min,\\n        uint256 max\\n    ) internal pure returns (int256 result) {\\n        result = int256(Randomize.next(random, min, max));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Variety/Varieties/Renderer/512PrintRenderer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport '../../../Randomize.sol';\\n\\n/// @title TheBoard\\n/// @author Simon Fremaux (@dievardump)\\ncontract _512PrintRenderer {\\n    using Strings for uint256;\\n    using Strings for uint16;\\n    using Strings for uint8;\\n\\n    using Randomize for Randomize.Random;\\n\\n    struct Configuration {\\n        int256 spacing;\\n        string background1;\\n        string background2;\\n        string stroke1;\\n        string stroke2;\\n        string background;\\n        string stroke;\\n        bool degen;\\n        bool animated;\\n        bool backgroundGradient;\\n        bool strokeGradient;\\n        bool rotated;\\n        bool rounded;\\n        bool missing;\\n        bytes left;\\n        bytes right;\\n    }\\n\\n    constructor() {}\\n\\n    function start(bytes32 seed)\\n        public\\n        pure\\n        returns (Randomize.Random memory, Configuration memory)\\n    {\\n        Randomize.Random memory random = Randomize.Random({\\n            seed: uint256(seed),\\n            offsetBit: 0\\n        });\\n\\n        Configuration memory config = _getConfiguration(random);\\n\\n        return (random, config);\\n    }\\n\\n    /// @dev Rendering function; should be overrode by the actual seedling contract\\n    /// @param tokenId the tokenId\\n    /// @param seed the seed\\n    /// @return the json\\n    function render(\\n        string memory name,\\n        uint256 tokenId,\\n        bytes32 seed\\n    ) external pure returns (string memory) {\\n        (Randomize.Random memory random, Configuration memory config) = start(\\n            seed\\n        );\\n\\n        string memory id = uint256(seed).toString();\\n\\n        bytes memory svg = abi.encodePacked(\\n            'data:application/json;utf8,{\\\"name\\\":\\\"',\\n            name,\\n            '\\\",\\\"image\\\":\\\"data:image/svg+xml;utf8,',\\n            \\\"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 1200 1200' width='1200' height='1200'>\\\"\\n            \\\"<defs><clipPath id='print-clip-\\\",\\n            id,\\n            \\\"'><rect x='40' y='40' width='1120' height='1120' /></clipPath>\\\"\\n        );\\n\\n        svg = abi.encodePacked(\\n            svg,\\n            config.backgroundGradient\\n                ? string(_renderBackgroundGradient(id, config, random))\\n                : '',\\n            config.strokeGradient\\n                ? string(_renderStrokeGradient(id, config, random))\\n                : '',\\n            '</defs>',\\n            \\\"<rect width='100%' height='100%' fill='\\\",\\n            config.backgroundGradient\\n                ? string(abi.encodePacked('url(#print-background-', id, ')'))\\n                : config.background1,\\n            \\\"'/><g x='40' y='40' stroke-linecap='round' stroke-width='\\\",\\n            random.next(1, config.rounded ? 8 : 4).toString(),\\n            \\\"' stroke='\\\",\\n            config.strokeGradient\\n                ? string(abi.encodePacked('url(#print-stroke-', id, ')'))\\n                : config.stroke1,\\n            \\\"' fill='\\\",\\n            config.backgroundGradient\\n                ? string(abi.encodePacked('url(#print-background-', id, ')'))\\n                : config.background1,\\n            \\\"' style='clip-path: url(#print-clip-\\\",\\n            id,\\n            \\\")'>\\\"\\n        );\\n\\n        _fill(random, config);\\n\\n        svg = abi.encodePacked(svg, config.left, config.right);\\n\\n        svg = abi.encodePacked(\\n            svg,\\n            \\\"</g><text text-anchor='end' x='1160' y='1180' fill='\\\",\\n            config.strokeGradient\\n                ? string(abi.encodePacked('url(#print-stroke-', id, ')'))\\n                : config.stroke1,\\n            \\\"'>#\\\",\\n            tokenId.toString(),\\n            '</text></svg>\\\"'\\n        );\\n\\n        svg = abi.encodePacked(\\n            svg,\\n            ',\\\"license\\\":\\\"Full ownership with unlimited commercial rights.\\\",\\\"creator\\\":\\\"@dievardump\\\"'\\n            ',\\\"description\\\":\\\"Left or Right? Repeat. Add some fun.\\\\\\\\n\\\\\\\\n512Print Seedling is my take on the Solidity version of the renowned 10Print algorithm and the second of the [sol]Seedlings, an experiment of art and collectible NFTs 100% generated with Solidity.\\\\\\\\nby @dievardump\\\\\\\\n\\\\\\\\nLicense: Full ownership with unlimited commercial rights.\\\\\\\\n\\\\\\\\nMore info at https://solSeedlings.art\\\"'\\n            ',\\\"properties\\\":{\\\"Background\\\":\\\"',\\n            config.backgroundGradient ? 'Gradient' : 'Unicolor',\\n            '\\\",\\\"Stroke\\\":\\\"',\\n            config.strokeGradient ? 'Gradient' : 'Unicolor',\\n            '\\\"'\\n        );\\n\\n        svg = abi.encodePacked(\\n            svg,\\n            config.degen ? ',\\\"Particularity\\\":\\\"Degen\\\"' : '',\\n            config.rotated ? ',\\\"Angle\\\":\\\"45deg\\\"' : '',\\n            config.rounded ? ',\\\"Variante\\\":\\\"Rounded\\\"' : '',\\n            config.animated ? ',\\\"Rendering\\\":\\\"Animated\\\"' : '',\\n            '}}'\\n        );\\n\\n        return string(svg);\\n    }\\n\\n    function _fill(Randomize.Random memory random, Configuration memory config)\\n        internal\\n        pure\\n    {\\n        if (config.rounded) {\\n            _renderRounded(random, config);\\n        } else {\\n            _renderClassic(random, config);\\n        }\\n    }\\n\\n    function _renderClassic(\\n        Randomize.Random memory random,\\n        Configuration memory config\\n    ) internal pure {\\n        bytes memory result;\\n        int256 offset;\\n        int256 half = config.spacing / 2;\\n        for (int256 y; y < 1160; y += config.spacing) {\\n            for (int256 x; x < 1160; x += config.spacing) {\\n                if (config.missing && random.next(0, 100) < 15) continue;\\n                if (random.next(0, 2) == 0) {\\n                    if (!config.degen || random.next(0, 100) >= 10) {\\n                        result = _getLine(\\n                            x,\\n                            config.rotated ? y + half : y,\\n                            x + config.spacing,\\n                            config.rotated ? y + half : y + config.spacing,\\n                            0\\n                        );\\n                    } else {\\n                        offset = (random.nextInt(10, 20) * config.spacing) / 2;\\n                        result = _getLine(\\n                            x - offset,\\n                            config.rotated ? y + half : y - offset,\\n                            x + offset,\\n                            config.rotated ? y + half : y + offset,\\n                            random.next(10, 28)\\n                        );\\n                    }\\n\\n                    config.left = abi.encodePacked(config.left, result);\\n                } else {\\n                    if (!config.degen || random.next(0, 100) >= 10) {\\n                        result = _getLine(\\n                            config.rotated ? x + half : x,\\n                            y + config.spacing,\\n                            config.rotated ? x + half : x + config.spacing,\\n                            y,\\n                            0\\n                        );\\n                    } else {\\n                        offset = (random.nextInt(10, 20) * config.spacing) / 2;\\n                        result = _getLine(\\n                            config.rotated ? x + half : x - offset,\\n                            y + offset,\\n                            config.rotated ? x + half : x + offset,\\n                            y - offset,\\n                            random.next(10, 28)\\n                        );\\n                    }\\n\\n                    config.right = abi.encodePacked(config.right, result);\\n                }\\n            }\\n        }\\n    }\\n\\n    function _renderRounded(\\n        Randomize.Random memory random,\\n        Configuration memory config\\n    ) internal pure {\\n        uint256 spacing = uint256(config.spacing);\\n        string memory half = (spacing / 2).toString();\\n\\n        bytes memory element;\\n\\n        // 50% change being round\\n        string memory strSpacing = spacing.toString();\\n        bytes memory roundedBase = _getRoundedBase(half, strSpacing);\\n        bytes memory cross = _getCross(half, strSpacing);\\n        bytes memory rotate = abi.encodePacked(\\n            ' rotate(90, ',\\n            half,\\n            ', ',\\n            half,\\n            ')'\\n        );\\n\\n        int256 temp;\\n        bool doRotate;\\n        for (int256 y; y < 1160; y += config.spacing) {\\n            for (int256 x; x < 1160; x += config.spacing) {\\n                temp = random.nextInt(0, 100);\\n                if (temp < 50) {\\n                    element = roundedBase;\\n                } else {\\n                    element = cross;\\n                    if (temp > 83) {\\n                        element = abi.encodePacked(\\n                            element,\\n                            _getRoundedCircle(half, config.spacing / 4)\\n                        );\\n                    } else if (temp > 66) {\\n                        temp = config.animated\\n                            ? random.nextInt(20, 50)\\n                            : int256(0);\\n                        element = abi.encodePacked(\\n                            element,\\n                            _getSquare(\\n                                uint256(config.spacing / 4).toString(),\\n                                half,\\n                                uint256(temp)\\n                            )\\n                        );\\n                    }\\n                }\\n\\n                doRotate = (random.next(0, 2) == 0);\\n                temp = random.nextInt(5, 10);\\n                config.left = abi.encodePacked(\\n                    config.left,\\n                    \\\"<g transform='translate(\\\",\\n                    uint256(x).toString(),\\n                    ',',\\n                    uint256(y).toString(),\\n                    ')',\\n                    doRotate ? rotate : bytes(''),\\n                    \\\"' \\\",\\n                    config.degen\\n                        ? abi.encodePacked(\\n                            \\\" stroke-width='\\\",\\n                            uint256(temp).toString(),\\n                            \\\"' \\\"\\n                        )\\n                        : bytes(''),\\n                    '>',\\n                    element,\\n                    '</g>'\\n                );\\n            }\\n        }\\n    }\\n\\n    function _getCross(string memory half, string memory spacing)\\n        internal\\n        pure\\n        returns (bytes memory svg)\\n    {\\n        svg = abi.encodePacked(\\n            \\\"<line x1='\\\",\\n            half,\\n            \\\"' y1='0' x2='\\\",\\n            half,\\n            \\\"' y2='\\\",\\n            spacing,\\n            \\\"' />\\\",\\n            \\\"<line x1='0' y1='\\\",\\n            half,\\n            \\\"' x2='\\\",\\n            spacing,\\n            \\\"' y2='\\\",\\n            half,\\n            \\\"' />\\\"\\n        );\\n    }\\n\\n    function _getSquare(\\n        string memory position,\\n        string memory size,\\n        uint256 animation\\n    ) internal pure returns (bytes memory svg) {\\n        svg = abi.encodePacked(\\n            \\\"<rect x='\\\",\\n            position,\\n            \\\"' y='\\\",\\n            position,\\n            \\\"' width='\\\",\\n            size,\\n            \\\"' height='\\\",\\n            size,\\n            \\\"' rx='6'>\\\"\\n        );\\n\\n        if (animation > 0) {\\n            svg = abi.encodePacked(\\n                svg,\\n                \\\"<animateTransform attributeName='transform' attributeType='XML' type='rotate' dur='\\\",\\n                animation.toString(),\\n                \\\"s' from='0 \\\",\\n                size,\\n                ' ',\\n                size,\\n                \\\"' to='360 \\\",\\n                size,\\n                ' ',\\n                size,\\n                \\\"' repeatCount='indefinite' />\\\"\\n            );\\n        }\\n\\n        svg = abi.encodePacked(svg, '</rect>');\\n    }\\n\\n    function _getRoundedCircle(string memory half, int256 size)\\n        internal\\n        pure\\n        returns (bytes memory svg)\\n    {\\n        svg = abi.encodePacked(\\n            \\\"<circle cx='\\\",\\n            half,\\n            \\\"' cy='\\\",\\n            half,\\n            \\\"' r='\\\",\\n            uint256(size).toString(),\\n            \\\"' />\\\"\\n        );\\n    }\\n\\n    function _getRoundedBase(string memory half, string memory spacing)\\n        internal\\n        pure\\n        returns (bytes memory svg)\\n    {\\n        svg = abi.encodePacked(\\n            \\\"<path d='M \\\",\\n            half,\\n            ' 0',\\n            'a ',\\n            half,\\n            ' ',\\n            half,\\n            ' 0 0 1 -',\\n            half,\\n            ' ',\\n            half,\\n            '',\\n            'm '\\n        );\\n\\n        svg = abi.encodePacked(\\n            svg,\\n            spacing,\\n            ' 0',\\n            'a ',\\n            half,\\n            ' ',\\n            half,\\n            ' 0 0 0 -',\\n            half,\\n            ' ',\\n            half,\\n            \\\"' fill='none'/>\\\"\\n        );\\n    }\\n\\n    function _getLine(\\n        int256 x0,\\n        int256 y0,\\n        int256 x1,\\n        int256 y1,\\n        uint256 strokeWidth\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                \\\"<path fill='none' \\\",\\n                strokeWidth != 0\\n                    ? string(\\n                        abi.encodePacked(\\n                            \\\"stroke-width='\\\",\\n                            strokeWidth.toString(),\\n                            \\\"'\\\"\\n                        )\\n                    )\\n                    : '',\\n                \\\" d='M\\\",\\n                x0 < 0\\n                    ? string(abi.encodePacked('-', uint256(x0 * -1).toString()))\\n                    : uint256(x0).toString(),\\n                ',',\\n                y0 < 0\\n                    ? string(abi.encodePacked('-', uint256(y0 * -1).toString()))\\n                    : uint256(y0).toString(),\\n                'L',\\n                x1 < 0\\n                    ? string(abi.encodePacked('-', uint256(x1 * -1).toString()))\\n                    : uint256(x1).toString(),\\n                ',',\\n                y1 < 0\\n                    ? string(abi.encodePacked('-', uint256(y1 * -1).toString()))\\n                    : uint256(y1).toString(),\\n                \\\"'/>\\\"\\n            );\\n    }\\n\\n    function _renderBackgroundGradient(\\n        string memory id,\\n        Configuration memory config,\\n        Randomize.Random memory random\\n    ) internal pure returns (bytes memory result) {\\n        uint256 animation = random.next(10000, 20000);\\n        result = abi.encodePacked(\\n            \\\"<linearGradient id='print-background-\\\",\\n            id,\\n            \\\"' gradientTransform='rotate(\\\",\\n            random.next(0, 360).toString(),\\n            \\\", 600, 600)' gradientUnits='userSpaceOnUse'><stop offset='0%' stop-color='\\\",\\n            config.background1,\\n            \\\"'>\\\"\\n        );\\n\\n        if (config.animated) {\\n            result = abi.encodePacked(\\n                result,\\n                \\\"<animate attributeName='stop-color' dur='\\\",\\n                animation.toString(),\\n                \\\"ms' values='\\\",\\n                config.background1,\\n                ';',\\n                config.background2,\\n                ';',\\n                config.background1,\\n                \\\"' repeatCount='indefinite' />\\\"\\n            );\\n        }\\n\\n        result = abi.encodePacked(\\n            result,\\n            \\\"</stop><stop offset='100%' stop-color='\\\",\\n            config.background2,\\n            \\\"'>\\\"\\n        );\\n\\n        if (config.animated) {\\n            result = abi.encodePacked(\\n                result,\\n                \\\"<animate attributeName='stop-color' dur='\\\",\\n                animation.toString(),\\n                \\\"ms' values='\\\",\\n                config.background2,\\n                ';',\\n                config.background1,\\n                ';',\\n                config.background2,\\n                \\\"' repeatCount='indefinite' />\\\"\\n            );\\n        }\\n\\n        return abi.encodePacked(result, '</stop></linearGradient>');\\n    }\\n\\n    function _renderStrokeGradient(\\n        string memory id,\\n        Configuration memory config,\\n        Randomize.Random memory random\\n    ) internal pure returns (bytes memory result) {\\n        uint256 animation = random.next(10000, 20000);\\n        result = abi.encodePacked(\\n            \\\"<linearGradient id='print-stroke-\\\",\\n            id,\\n            \\\"' gradientTransform='rotate(\\\",\\n            random.next(0, 360).toString(),\\n            \\\", 600, 600)' gradientUnits='userSpaceOnUse'><stop offset='0%' stop-color='\\\",\\n            config.stroke1,\\n            \\\"'>\\\"\\n        );\\n\\n        if (config.animated) {\\n            result = abi.encodePacked(\\n                result,\\n                \\\"<animate attributeName='stop-color' dur='\\\",\\n                animation.toString(),\\n                \\\"ms' values='\\\",\\n                config.stroke1,\\n                ';',\\n                config.stroke2,\\n                ';',\\n                config.stroke1,\\n                \\\"' repeatCount='indefinite' />\\\"\\n            );\\n        }\\n\\n        result = abi.encodePacked(\\n            result,\\n            \\\"</stop><stop offset='100%' stop-color='\\\",\\n            config.stroke2,\\n            \\\"'>\\\"\\n        );\\n\\n        if (config.animated) {\\n            result = abi.encodePacked(\\n                result,\\n                \\\"<animate attributeName='stop-color' dur='\\\",\\n                animation.toString(),\\n                \\\"ms' values='\\\",\\n                config.stroke2,\\n                ';',\\n                config.stroke1,\\n                ';',\\n                config.stroke2,\\n                \\\"' repeatCount='indefinite' />\\\"\\n            );\\n        }\\n\\n        result = abi.encodePacked(result, '</stop></linearGradient>');\\n    }\\n\\n    function _getConfiguration(Randomize.Random memory random)\\n        internal\\n        pure\\n        returns (Configuration memory config)\\n    {\\n        string[16] memory darker = [\\n            '#000000',\\n            '#1A1A2E',\\n            '#2C061F',\\n            '#352F44',\\n            '#1D2D50',\\n            '#2A363B',\\n            '#61105E',\\n            '#84142D',\\n            '#173F5F',\\n            '#29435C',\\n            '#A7226E',\\n            '#C70D3A',\\n            '#355C7D',\\n            '#20639B',\\n            '#6C5B7B',\\n            '#2D6E7E'\\n        ];\\n\\n        string[20] memory lighter = [\\n            '#FFFFFF',\\n            '#E4FBFF',\\n            '#F7D9D9',\\n            '#B5EAEA',\\n            '#00FFF5',\\n            '#B6C9F0',\\n            '#FECEAB',\\n            '#FFF591',\\n            '#F8B195',\\n            '#F7DB4F',\\n            '#FF847C',\\n            '#3CAEA3',\\n            '#DA7F8F',\\n            '#F67280',\\n            '#2F9599',\\n            '#F26B38',\\n            '#C06C84',\\n            '#ED553B',\\n            '#E84A5F',\\n            '#EC2049'\\n        ];\\n\\n        bool rounded = (random.next(0, 100) < 33);\\n\\n        // if not rounded, 5% rotated\\n        bool rotated = !rounded && (random.next(0, 100) < 5);\\n\\n        // if rotated; then degen, else 20%\\n        bool degen = (rotated || (random.next(0, 100) < 20));\\n\\n        uint256 temp = random.next(0, 100);\\n        int256 spacing = random.nextInt(rounded ? 120 : 90, 160);\\n        if (spacing % 2 != 0) {\\n            spacing++;\\n        }\\n\\n        config = Configuration({\\n            spacing: spacing,\\n            background1: '#000',\\n            background2: '#000',\\n            stroke1: '#fff',\\n            stroke2: '#fff',\\n            background: 'Black',\\n            stroke: 'White',\\n            degen: degen,\\n            animated: false,\\n            backgroundGradient: false,\\n            strokeGradient: false,\\n            rotated: rotated,\\n            missing: !rounded && (random.next(0, 100) < 5),\\n            left: '',\\n            right: '',\\n            rounded: rounded\\n        });\\n\\n        if (temp >= 4 && temp < 8) {\\n            // black on white\\n            config.background1 = '#fff';\\n            config.background2 = '#fff';\\n            config.stroke1 = '#000';\\n            config.stroke2 = '#000';\\n            config.background = 'White';\\n            config.stroke = 'Black';\\n        } else if (temp < 26) {\\n            // black on lighter background\\n            config.background1 = config.background2 = lighter[\\n                random.next(0, lighter.length)\\n            ];\\n            config.stroke1 = '#000';\\n            config.stroke2 = '#000';\\n\\n            config.background = 'Lighter';\\n            config.stroke = 'Black';\\n        } else if (temp < 44) {\\n            // white on darker background\\n            config.background1 = config.background2 = darker[\\n                random.next(0, darker.length)\\n            ];\\n            config.stroke1 = '#fff';\\n            config.stroke2 = '#fff';\\n\\n            config.background = 'Darker';\\n            config.stroke = 'White';\\n        } else if (temp < 62) {\\n            // light gradient on black\\n            config.background1 = '#000';\\n            config.background2 = '#000';\\n            temp = random.next(0, lighter.length);\\n            config.stroke1 = lighter[temp];\\n            config.stroke2 = lighter[\\n                (temp + random.next(lighter.length / 2, lighter.length)) %\\n                    lighter.length\\n            ];\\n\\n            config.background = 'Black';\\n            config.stroke = 'Light gradient';\\n        } else if (temp < 80) {\\n            // dark gradient on white\\n            config.background1 = '#fff';\\n            config.background2 = '#fff';\\n\\n            temp = random.next(0, darker.length);\\n            config.stroke1 = darker[temp];\\n            config.stroke2 = darker[\\n                (temp + random.next(darker.length / 2, darker.length)) %\\n                    darker.length\\n            ];\\n\\n            config.background = 'White';\\n            config.stroke = 'Darker gradient';\\n        } else if (temp < 90) {\\n            // dark gradient on light gradient\\n            temp = random.next(0, lighter.length);\\n            config.background1 = lighter[temp];\\n            config.background2 = lighter[\\n                (temp + random.next(lighter.length / 2, lighter.length)) %\\n                    lighter.length\\n            ];\\n            temp = random.next(0, darker.length);\\n            config.stroke1 = darker[temp];\\n            config.stroke2 = darker[\\n                (temp + random.next(darker.length / 2, darker.length)) %\\n                    darker.length\\n            ];\\n\\n            config.background = 'Lighter gradient';\\n            config.stroke = 'Darker gradient';\\n        } else {\\n            // light gradient on dark gradient\\n            temp = random.next(0, darker.length);\\n            config.background1 = darker[temp];\\n            config.background2 = darker[\\n                (temp + random.next(darker.length / 2, darker.length)) %\\n                    darker.length\\n            ];\\n\\n            temp = random.next(0, lighter.length);\\n            config.stroke1 = lighter[temp];\\n            config.stroke2 = lighter[\\n                (temp + random.next(lighter.length / 2, lighter.length)) %\\n                    lighter.length\\n            ];\\n\\n            config.background = 'Darker gradient';\\n            config.stroke = 'Lighter gradient';\\n        }\\n\\n        config.backgroundGradient =\\n            keccak256(abi.encodePacked((config.background1))) !=\\n            keccak256(abi.encodePacked((config.background2)));\\n        config.strokeGradient =\\n            keccak256(abi.encodePacked((config.stroke1))) !=\\n            keccak256(abi.encodePacked((config.stroke2)));\\n\\n        // if rounded or gradient, it can be animated\\n        config.animated =\\n            (rounded || (config.backgroundGradient || config.strokeGradient)) &&\\n            (random.next(0, 100) < 10);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"render\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"start\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offsetBit\",\"type\":\"uint256\"}],\"internalType\":\"struct Randomize.Random\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"spacing\",\"type\":\"int256\"},{\"internalType\":\"string\",\"name\":\"background1\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"background2\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"stroke1\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"stroke2\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"background\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"stroke\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"degen\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"animated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"backgroundGradient\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"strokeGradient\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rotated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rounded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"missing\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"left\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"right\",\"type\":\"bytes\"}],\"internalType\":\"struct _512PrintRenderer.Configuration\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"_512PrintRenderer","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}