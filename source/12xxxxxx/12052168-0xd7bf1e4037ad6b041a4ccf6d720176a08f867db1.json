{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/WOWSCryptofolio.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2020-2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nimport './interfaces/IERC1155BurnMintable.sol';\\nimport './interfaces/IWOWSCryptofolio.sol';\\nimport './interfaces/IWOWSERC1155.sol';\\n\\ncontract WOWSCryptofolio is IWOWSCryptofolio {\\n  // Our NFT token parent\\n  IWOWSERC1155 private _deployer;\\n  // The owner of the NFT token parent\\n  address private _owner;\\n  // Mapping of cryptofolio items owned by this\\n  mapping(address => uint256[]) private _cryptofolios;\\n  // List of all known tradefloors\\n  address[] public _tradefloors;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Events\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Triggered if sft receives new tokens from operator\\n   */\\n  event CryptoFolioAdded(\\n    address indexed sft,\\n    address indexed operator,\\n    uint256[] tokenIds,\\n    uint256[] amounts\\n  );\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Initialization\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev See {IWOWSCryptofolio-initialize}.\\n   */\\n  function initialize() external override {\\n    require(address(_deployer) == address(0), 'CF: Already initialized');\\n    _deployer = IWOWSERC1155(msg.sender);\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Implementation of {IWOWSCryptofolio}\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev See {IWOWSCryptofolio-getCryptofolio}.\\n   */\\n  function getCryptofolio(address tradefloor)\\n    external\\n    view\\n    override\\n    returns (uint256[] memory tokenIds, uint256 idsLength)\\n  {\\n    uint256[] storage opIds = _cryptofolios[tradefloor];\\n    uint256[] memory result = new uint256[](opIds.length);\\n    uint256 newLength = 0;\\n\\n    if (opIds.length > 0) {\\n      address[] memory accounts = new address[](opIds.length);\\n      for (uint256 i = 0; i < opIds.length; ++i) accounts[i] = address(this);\\n      uint256[] memory balances =\\n        IERC1155(tradefloor).balanceOfBatch(accounts, opIds);\\n\\n      for (uint256 i = 0; i < opIds.length; ++i)\\n        if (balances[i] > 0) result[newLength++] = opIds[i];\\n    }\\n    return (result, newLength);\\n  }\\n\\n  /**\\n   * @dev See {IWOWSCryptofolio-setOwner}.\\n   */\\n  function setOwner(address newOwner) external override {\\n    require(msg.sender == address(_deployer), 'CF: Only deployer');\\n    for (uint256 i = 0; i < _tradefloors.length; ++i) {\\n      if (_owner != address(0))\\n        IERC1155(_tradefloors[i]).setApprovalForAll(_owner, false);\\n      if (newOwner != address(0))\\n        IERC1155(_tradefloors[i]).setApprovalForAll(newOwner, true);\\n    }\\n    _owner = newOwner;\\n  }\\n\\n  /**\\n   * @dev See {IWOWSCryptofolio-setApprovalForAll}.\\n   */\\n  function setApprovalForAll(address operator, bool allow) external override {\\n    require(msg.sender == _owner, 'CF: Only owner');\\n    for (uint256 i = 0; i < _tradefloors.length; ++i) {\\n      IERC1155(_tradefloors[i]).setApprovalForAll(operator, allow);\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IWOWSCryptofolio-burn}.\\n   */\\n  function burn() external override {\\n    require(msg.sender == address(_deployer), 'CF: Only deployer');\\n    for (uint256 i = 0; i < _tradefloors.length; ++i) {\\n      IERC1155BurnMintable tradefloor = IERC1155BurnMintable(_tradefloors[i]);\\n      uint256[] storage opIds = _cryptofolios[address(tradefloor)];\\n      if (opIds.length > 0) {\\n        address[] memory accounts = new address[](opIds.length);\\n        for (uint256 j = 0; j < opIds.length; ++j) accounts[j] = address(this);\\n        uint256[] memory balances = tradefloor.balanceOfBatch(accounts, opIds);\\n        tradefloor.burnBatch(address(this), opIds, balances);\\n      }\\n      delete _cryptofolios[address(tradefloor)];\\n    }\\n    delete _tradefloors;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Hooks\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  function onERC1155Received(\\n    address,\\n    address,\\n    uint256 tokenId,\\n    uint256 amount,\\n    bytes memory\\n  ) external returns (bytes4) {\\n    uint256[] memory tokenIds = new uint256[](1);\\n    tokenIds[0] = tokenId;\\n    uint256[] memory amounts = new uint256[](1);\\n    amounts[0] = amount;\\n    _onTokensReceived(tokenIds, amounts);\\n    return this.onERC1155Received.selector;\\n  }\\n\\n  function onERC1155BatchReceived(\\n    address,\\n    address,\\n    uint256[] memory tokenIds,\\n    uint256[] memory amounts,\\n    bytes memory\\n  ) external returns (bytes4) {\\n    _onTokensReceived(tokenIds, amounts);\\n    return this.onERC1155BatchReceived.selector;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Internal functionality\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Update our collection of tradeable cryptofolio items\\n   *\\n   * This function is only allowed to be called from one of our pseudo\\n   * TokenReceiver contracts.\\n   */\\n  function _onTokensReceived(\\n    uint256[] memory tokenIds,\\n    uint256[] memory amounts\\n  ) internal {\\n    address tradefloor = msg.sender;\\n    require(_deployer.isTradeFloor(tradefloor), 'CF: Only tradefloor');\\n    require(tokenIds.length == amounts.length, 'CF: Input lengths differ');\\n\\n    uint256[] storage currentIds = _cryptofolios[tradefloor];\\n    if (currentIds.length == 0) {\\n      IERC1155(tradefloor).setApprovalForAll(_owner, true);\\n      _tradefloors.push(tradefloor);\\n    }\\n\\n    for (uint256 iIds = 0; iIds < tokenIds.length; ++iIds) {\\n      if (amounts[iIds] > 0) {\\n        uint256 tokenId = tokenIds[iIds];\\n        // Search tokenId\\n        uint256 i = 0;\\n        for (; i < currentIds.length && currentIds[i] != tokenId; ++i) i;\\n        // If token was not found, insert it\\n        if (i == currentIds.length) currentIds.push(tokenId);\\n      }\\n    }\\n    emit CryptoFolioAdded(address(this), tradefloor, tokenIds, amounts);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IERC1155BurnMintable.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\\n\\ninterface IERC1155BurnMintable is IERC1155 {\\n  /**\\n   * @dev Mint amount new tokens at ID `tokenId` (MINTER_ROLE required)\\n   */\\n  function mint(\\n    address to,\\n    uint256 tokenId,\\n    uint256 amount,\\n    bytes memory data\\n  ) external;\\n\\n  /**\\n   * @dev Mint new token amounts at IDs `tokenIds` (MINTER_ROLE required)\\n   */\\n  function mintBatch(\\n    address to,\\n    uint256[] memory tokenIds,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) external;\\n\\n  /**\\n   * @dev Burn value amount of tokens with ID `tokenId`.\\n   *\\n   * Caller must be approvedForAll.\\n   */\\n  function burn(\\n    address account,\\n    uint256 tokenId,\\n    uint256 value\\n  ) external;\\n\\n  /**\\n   * @dev Burn `values` amounts of tokens with IDs `tokenIds`.\\n   *\\n   * Caller must be approvedForAll.\\n   */\\n  function burnBatch(\\n    address account,\\n    uint256[] memory tokenIds,\\n    uint256[] memory values\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSCryptofolio.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Cryptofolio interface\\n *\\n * TODO: Describe cryptofolios\\n */\\ninterface IWOWSCryptofolio {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Initialization\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Initialize the deployed contract after creation\\n   *\\n   * This is a one time call which sets _deployer to msg.sender.\\n   * Subsequent calls reverts.\\n   */\\n  function initialize() external;\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getters\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Return array of cryptofolio token IDs\\n   *\\n   * The token IDs belong to the contract tradefloor.\\n   *\\n   * @param tradefloor The tradefloor items belong to\\n   *\\n   * @return tokenIds The token IDs in scope of operator\\n   * @return idsLength The number of valid token IDs\\n   */\\n  function getCryptofolio(address tradefloor)\\n    external\\n    view\\n    returns (uint256[] memory tokenIds, uint256 idsLength);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Set the owner of the underlying NFT\\n   *\\n   * This function is called if ownership of the parent NFT has changed.\\n   *\\n   * The new owner gets allowance to transfer cryptofolio items. The new owner\\n   * is allowed to transfer / burn cryptofolio items. Make sure that allowance\\n   * is removed from previous owner.\\n   *\\n   * @param owner The new owner of the underlying NFT\\n   */\\n  function setOwner(address owner) external;\\n\\n  /**\\n   * @dev Allow owner (of parent NFT) to approve external operators to transfer\\n   * our cryptofolio items\\n   *\\n   * The NFT owner is allowed to approve operator to handle cryptofolios.\\n   *\\n   * @param operator The operator\\n   * @param allow True to approve for all NFTs, false to revoke approval\\n   */\\n  function setApprovalForAll(address operator, bool allow) external;\\n\\n  /**\\n   * @dev Burn all cryptofolio items\\n   *\\n   * In case an underlying NFT is burned, we also burn the cryptofolio.\\n   */\\n  function burn() external;\\n}\\n\"\r\n    },\r\n    \"contracts/src/token/interfaces/IWOWSERC1155.sol\": {\r\n      \"content\": \"/*\\n * Copyright (C) 2021 The Wolfpack\\n * This file is part of wolves.finance - https://github.com/wolvesofwallstreet/wolves.finance\\n *\\n * SPDX-License-Identifier: Apache-2.0\\n * See the file LICENSES/README.md for more information.\\n */\\n\\npragma solidity >=0.7.0 <0.8.0;\\n\\n/**\\n * @notice Cryptofolio interface\\n *\\n * TODO: Describe cryptofolios\\n */\\ninterface IWOWSERC1155 {\\n  //////////////////////////////////////////////////////////////////////////////\\n  // Getters\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Check if the specified address is a known tradefloor\\n   *\\n   * @param account The address to check\\n   *\\n   * @return True if the address is a known tradefloor, false otherwise\\n   */\\n  function isTradeFloor(address account) external view returns (bool);\\n\\n  /**\\n   * @dev Get the token ID of a given address\\n   *\\n   * A cross check is required because token ID 0 is valid.\\n   *\\n   * @param tokenAddress The address to convert to a token ID\\n   *\\n   * @return The token ID on success, or uint256(-1) if `tokenAddress` does not\\n   * belong to a token ID\\n   */\\n  function addressToTokenId(address tokenAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Get the address for a given token ID\\n   *\\n   * @param tokenId The token ID to convert\\n   *\\n   * @return The address, or address(0) in case the token ID does not belong\\n   * to an NFT\\n   */\\n  function tokenIdToAddress(uint256 tokenId) external view returns (address);\\n\\n  /**\\n   * @dev Get the next mintable token ID for the specified card\\n   *\\n   * @param level The level of the card\\n   * @param cardId The token ID of the card\\n   *\\n   * @return bool True if a free token ID was found, false otherwise\\n   * @return uint256 The first free token ID if one was found, or invalid otherwise\\n   */\\n  function getNextMintableTokenId(uint8 level, uint8 cardId)\\n    external\\n    view\\n    returns (bool, uint256);\\n\\n  /**\\n   * @dev Return the next mintable custom token ID\\n   */\\n  function getNextMintableCustomToken() external view returns (uint256);\\n\\n  //////////////////////////////////////////////////////////////////////////////\\n  // State modifiers\\n  //////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * @dev Set the URI for either predefined cards or custom cards\\n   *\\n   * For changing the default URI for predefined cards, token ID 0 must be\\n   * passed. Custom token ID's (> 32-bit range) get their own URI per token ID.\\n   *\\n   * @param tokenId The token ID whose URI is being set. Use `tokenId` == 0 to\\n   * set the default URI. `tokenId` >= 0xFFFFFFFF is for custom URIs.\\n   * @param _uri The URI, also allowing for the ERC-1155 {id} mechanism.\\n   */\\n  function setURI(uint256 tokenId, string memory _uri) external;\\n\\n  /**\\n   * @dev Set the URI which is returned for custom cards without specific URI\\n   *\\n   * @param _uri The URI, also allowing for the ERC-1155 {id} mechanism.\\n   */\\n  function setCustomDefaultURI(string memory _uri) external;\\n\\n  /**\\n   * @dev Each custom card has its own level. Level will be used when\\n   * calculating rewards and raiding power.\\n   *\\n   * @param tokenId The ID of the token whose level is being set\\n   * @param cardLevel The new level of the specified token\\n   */\\n  function setCustomCardLevel(uint256 tokenId, uint8 cardLevel) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sft\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"CryptoFolioAdded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_tradefloors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tradefloor\",\"type\":\"address\"}],\"name\":\"getCryptofolio\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"idsLength\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WOWSCryptofolio","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}