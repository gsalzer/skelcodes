{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"StitchedPunksShop.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// 2021-04-10 - Release Version\\n\\npragma solidity 0.7.6;\\n\\n// @openzeppelin/contracts/utils/Context.sol introduces execution context to replace msg.sender with _msgSender()\\n// implement admin role\\nimport \\\"./Ownable.sol\\\";\\n\\n// interfaces for fetching ownership of common and wrapped Cryptopunks\\ninterface ICryptoPunks {\\n\\tfunction punkIndexToAddress(uint) external view returns(address);\\n}\\ninterface IWrappedPunks {\\n\\tfunction ownerOf(uint256) external view returns (address);\\n}\\n\\ncontract StitchedPunksShop is Ownable {\\n    // access to existing CryptoPunks and WrappedPunks contracts\\n\\tICryptoPunks internal CryptoPunks = ICryptoPunks(0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB);\\n\\tIWrappedPunks internal WrappedPunks = IWrappedPunks(0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6);\\n\\n    // current price for submitting an order\\n    uint256 public currentOrderPrice = 1 ether;\\n\\n    // order details\\n    struct OrderDetails {\\n        // punk ID this order refers to:\\n        uint16 punkId;\\n        // current status of order:\\n        // 0 = \\\"not created yet\\\"\\n        // 10 = \\\"order created and paid\\\"\\n        // 20 = \\\"crafting StitchedPunk\\\"\\n        // 30 = \\\"shipped\\\"\\n        // 40 = \\\"received and NFT redeemed\\\"\\n        uint8 status;\\n        // owner who submitted the order:\\n        address owner;\\n    }\\n\\n    // order status for punk ID\\n    uint16[] public orderedPunkIds;\\n    mapping(uint16 =\\u003e OrderDetails) public orderStatus;\\n\\n    // events\\n    event OrderCreated(uint16 indexed punkId, address indexed owner);\\n    event OrderUpdated(uint16 indexed punkId, uint8 indexed newStatus);\\n\\n    function withdraw() external onlyOwner() {\\n        payable(owner()).transfer(address(this).balance);\\n    }\\n\\n    function setOrderPrice(uint256 newPrice) external onlyOwner() {\\n        currentOrderPrice = newPrice;\\n    }\\n\\n    // returns current owner of a given CryptoPunk (if common CryptoPunk)\\n    function getOwnerForCryptoPunk(uint16 punkIndex) public view returns (address) {\\n        return CryptoPunks.punkIndexToAddress(punkIndex);\\n    }\\n\\n    // returns current owner of a given WrappedPunk (if wrapped CryptoPunk)\\n    function getOwnerForWrappedPunk(uint16 punkIndex) public view returns (address) {\\n        try WrappedPunks.ownerOf(punkIndex) returns (address wrappedPunkOwner) {\\n            return wrappedPunkOwner;\\n        } catch Error(string memory) {\\n            // catches failing revert() and require()\\n            // ERC721: if token does not exist, require() fails in target contract\\n            return address(0);\\n        } catch (bytes memory) {\\n            // low-level: catches a failing assertion, etc.\\n            return address(0);\\n        }\\n    }\\n\\n    // checks if wallet owns a given CryptoPunk\\n    function isOwnerOfPunk(address wallet, uint16 punkIndex) public view returns (bool) {\\n        return getOwnerForCryptoPunk(punkIndex) == wallet || getOwnerForWrappedPunk(punkIndex) == wallet;\\n    }\\n\\n    function submitOrder(uint16 punkIndex) external payable {\\n        // currentOrderPrice has to be paid\\n        require(msg.value \\u003e= currentOrderPrice, \\\"price is too low\\\");\\n        // sender has to be owner of the punk (common or wrapped)\\n        require(isOwnerOfPunk(_msgSender(), punkIndex), \\\"you need to own this punk\\\");\\n        // punk must not already be ordered\\n        require(orderStatus[punkIndex].status == 0, \\\"punk was already ordered\\\");\\n\\n        // save order details\\n        orderStatus[punkIndex] = OrderDetails(punkIndex, 10, _msgSender());\\n        orderedPunkIds.push(punkIndex);\\n\\n        emit OrderCreated(punkIndex, _msgSender());\\n    }\\n\\n    function updateOrderStatus(uint16 punkIndex, uint8 newStatus) public onlyOwner() {\\n        // punk has to be ordered already\\n        require(orderStatus[punkIndex].status != 0, \\\"punk was not yet ordered\\\");\\n\\n        // update order status\\n        orderStatus[punkIndex].status = newStatus;\\n\\n        emit OrderUpdated(punkIndex, newStatus);\\n    }\\n\\n    // StitchedPunksNFT contract address\\n    address public stitchedPunksNFTAddress = address(0);\\n\\n    // will be called after the StitchedPunksNFT contract was deployed\\n    function setStitchedPunksNFTAddress(address newAddress) public onlyOwner() {\\n        stitchedPunksNFTAddress = newAddress;\\n    }\\n\\n    // update order status when the NFT is redeemed/minted (must be called from the StitchedPunksNFT contract)\\n    function updateOrderRedeemNFT(uint16 punkIndex) external {\\n        require(stitchedPunksNFTAddress == _msgSender(), \\\"caller is not the StitchedPunksNFT contract\\\");\\n\\n        // update order status: 40 = \\\"received and NFT redeemed\\\"\\n        uint8 newStatus = 40;\\n\\n        // punk has to be ordered already\\n        require(orderStatus[punkIndex].status != 0, \\\"punk was not yet ordered\\\");\\n\\n        // update order status\\n        orderStatus[punkIndex].status = newStatus;\\n\\n        emit OrderUpdated(punkIndex, newStatus);\\n    }\\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"punkId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"punkId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"OrderUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"currentOrderPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"getOwnerForCryptoPunk\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"getOwnerForWrappedPunk\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"isOwnerOfPunk\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"orderStatus\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"punkId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderedPunkIds\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setOrderPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setStitchedPunksNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stitchedPunksNFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"submitOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"updateOrderRedeemNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"updateOrderStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"StitchedPunksShop","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8ea7078596a109c3db3864e650850ad429e476f9f85c6c1438fc1f0d8366ab92"}]}