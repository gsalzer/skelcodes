{"status":"1","message":"OK","result":[{"SourceCode":"// Price Oracle for Reeth Token\r\n// This contract uses Uniswap v2 TWAP to obtain the token price\r\n// It initially uses 10 minute averages but can be updated on the fly by governance\r\n\r\npragma solidity =0.6.6;\r\n\r\ninterface UniswapV2Pair {\r\n    function price0CumulativeLast() external view returns (uint256);\r\n    function price1CumulativeLast() external view returns (uint256);\r\n    function getReserves() external view returns (uint112, uint112, uint32);\r\n}\r\n\r\ncontract ReethPriceOracle {\r\n\r\n    address public owner;\r\n    bool private _firstCapture = true;\r\n    uint256 private _reethDecimals = 18; // Same as YAM\r\n    uint256 private _reethETHPrice = 0;\r\n    uint256 private _reethPriceWindow = 0; // The time period this price was calculated over, determines its weight\r\n    uint256 private _tokenIndex = 0;\r\n    uint256 public lastREETHPriceUpdate; // The last time the price was updated\r\n    uint256 public updateFrequency = 10 minutes; // Oracle can be updated at least every 10 minutes\r\n\r\n    uint256 constant DIVISION_FACTOR = 100000;\r\n    \r\n    // TWAP details\r\n    address public mainLiquidity;\r\n    uint256 private lastTWAPCumulativePrice;\r\n    uint32 private lastTWAPBlockTime;\r\n    uint256 private lastTWAPPrice;\r\n    \r\n    // Events\r\n    event NoLiquidity();\r\n    event FirstPriceCapture(); // First time price update is called, must wait til another time to update\r\n    event FailedPriceCapture(); // Not quick enough price movement for a twap to be calculated\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyGovernance() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    function changeLiquidityToken(address _lp, uint256 _pos) internal {\r\n        mainLiquidity = _lp;\r\n        _tokenIndex = _pos;\r\n        _reethETHPrice = 0;\r\n        _reethPriceWindow = 0;\r\n        lastTWAPBlockTime = 0;\r\n        lastTWAPCumulativePrice = 0;\r\n        lastREETHPriceUpdate = 0;\r\n        _firstCapture = true;\r\n    }\r\n    \r\n    function getLatestREETHPrice() external view returns (uint256) {\r\n        // Returns the stored price with 18 decimals of precision\r\n        return _reethETHPrice;\r\n    }\r\n    \r\n    // This function can be called manually but will most likely be called by the monetary policy upon token transfers most often\r\n    function updateREETHPrice() external {\r\n        if(mainLiquidity == address(0)) { return; }\r\n        if(now < lastREETHPriceUpdate + updateFrequency){ return; } // Do nothing if update is called too soon\r\n        uint256 period = now - lastREETHPriceUpdate; // Get the time between the last update and now\r\n        lastREETHPriceUpdate = now;\r\n        // We will use a combination of the Twap and weighted averages to determine the current price\r\n        UniswapV2Pair pair = UniswapV2Pair(mainLiquidity);\r\n        (, uint112 reserve1, uint32 _blockTime) = pair.getReserves();\r\n        if(reserve1 == 0){\r\n            // Liquidity is gone/non-existant, can't update the price\r\n            // Reset the oracle\r\n            _reethETHPrice = 0;\r\n            _reethPriceWindow = 0;\r\n            lastTWAPBlockTime = 0;\r\n            lastTWAPCumulativePrice = 0;\r\n            _firstCapture = true;\r\n            emit NoLiquidity();\r\n            return;\r\n        }\r\n        if(lastTWAPBlockTime != _blockTime){\r\n            // Uniswap twap price has updated, update our twap price\r\n            if(_firstCapture == true){\r\n                // Never had a price before, save the price accumulators\r\n                if(_tokenIndex == 0){\r\n                    lastTWAPCumulativePrice = pair.price0CumulativeLast();\r\n                }else{\r\n                    lastTWAPCumulativePrice = pair.price1CumulativeLast();\r\n                }\r\n                lastTWAPBlockTime = _blockTime;\r\n                _firstCapture = false;\r\n                emit FirstPriceCapture();\r\n                return;\r\n            }else{\r\n                // We already have a price cumulative, capture a new price\r\n                uint256 cumuPrice = 0;\r\n                if(_tokenIndex == 0){\r\n                    cumuPrice = pair.price0CumulativeLast();\r\n                }else{\r\n                    cumuPrice = pair.price1CumulativeLast();\r\n                }\r\n                // This is price in relationship to base pair\r\n                lastTWAPPrice = ((cumuPrice - lastTWAPCumulativePrice) / (_blockTime - lastTWAPBlockTime) * (10**_reethDecimals)) >> 112;\r\n                lastTWAPCumulativePrice = cumuPrice;\r\n                lastTWAPBlockTime = _blockTime;\r\n            }\r\n        }\r\n        if(lastTWAPPrice == 0){\r\n            // Still no price calculation possible since no action on trading pair since last call\r\n            emit FailedPriceCapture();\r\n            return;\r\n        }\r\n        if(_reethPriceWindow == 0){\r\n            // First time price is calculated, set it to the twap price\r\n            _reethPriceWindow = updateFrequency;\r\n            _reethETHPrice = lastTWAPPrice;\r\n        }else{\r\n            // There is already a price window and price, use weighted averages to determine the weight\r\n            uint256 price = lastTWAPPrice;\r\n            _reethETHPrice = (_reethETHPrice * (_reethPriceWindow * DIVISION_FACTOR / (_reethPriceWindow + period)) / DIVISION_FACTOR);\r\n            _reethETHPrice += (price * (period * DIVISION_FACTOR / (_reethPriceWindow + period)) / DIVISION_FACTOR);\r\n            _reethPriceWindow = period; // Set the window to the new period\r\n        }\r\n    }\r\n    \r\n    // Governance\r\n    function governanceChangeFrequency(uint256 _freq) external onlyGovernance {\r\n        updateFrequency = _freq;\r\n    }\r\n    \r\n    // Timelock variables\r\n    \r\n    uint256 private _timelockStart; // The start of the timelock to change governance variables\r\n    uint256 private _timelockType; // The function that needs to be changed\r\n    uint256 constant TIMELOCK_DURATION = 86400; // Timelock is 24 hours\r\n    \r\n    // Reusable timelock variables\r\n    address private _timelock_address;\r\n    uint256 private _timelock_data;\r\n    \r\n    modifier timelockConditionsMet(uint256 _type) {\r\n        require(_timelockType == _type, \"Timelock not acquired for this function\");\r\n        _timelockType = 0; // Reset the type once the timelock is used\r\n        require(now >= _timelockStart + TIMELOCK_DURATION, \"Timelock time not met\");\r\n        _;\r\n    }\r\n    \r\n    // Change the owner of the token contract\r\n    // --------------------\r\n    function startGovernanceChange(address _address) external onlyGovernance {\r\n        _timelockStart = now;\r\n        _timelockType = 1;\r\n        _timelock_address = _address;       \r\n    }\r\n    \r\n    function finishGovernanceChange() external onlyGovernance timelockConditionsMet(1) {\r\n        owner = _timelock_address;\r\n    }\r\n    // --------------------\r\n    \r\n    // Update main liquidity token pair\r\n    // --------------------\r\n    function startUpdateLiquidityToken(address _address, uint256 _index) external onlyGovernance {\r\n        _timelockStart = now;\r\n        _timelockType = 2;\r\n        _timelock_address = _address;     \r\n        _timelock_data = _index;\r\n        if(mainLiquidity == address(0)){\r\n            changeLiquidityToken(_address, _index);\r\n            _timelockType = 0;\r\n        }\r\n    }\r\n    \r\n    function finishUpdateLiquidityToken() external onlyGovernance timelockConditionsMet(2) {\r\n        changeLiquidityToken(_timelock_address, _timelock_data);\r\n    }\r\n    // --------------------   \r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FailedPriceCapture\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FirstPriceCapture\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NoLiquidity\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"finishGovernanceChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishUpdateLiquidityToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestREETHPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_freq\",\"type\":\"uint256\"}],\"name\":\"governanceChangeFrequency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastREETHPriceUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainLiquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"startGovernanceChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"startUpdateLiquidityToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateREETHPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ReethPriceOracle","CompilerVersion":"v0.6.6+commit.6c089d02","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6a959563be9c75ef1a05e22c310f3f7befb50b1cbaa120aa9b1e2df731d12288"}]}