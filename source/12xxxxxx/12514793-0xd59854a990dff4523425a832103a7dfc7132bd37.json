{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenDistribution/BasedRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\nimport \\\"openzeppelin-solidity/contracts/math/Math.sol\\\";\\nimport \\\"./IERC20Detailed.sol\\\";\\nimport \\\"./IRewardDistributionRecipient.sol\\\";\\nimport \\\"./LPTokenWrapper.sol\\\";\\n\\n// solhint-enable max-line-length\\npragma solidity >=0.6.0 <0.8.0;\\n\\ncontract BasedRewards is LPTokenWrapper, IRewardDistributionRecipient {\\n    IERC20Detailed public blo;\\n    uint256 public duration;\\n\\n    uint256 public initreward;\\n    uint256 public starttime;\\n    uint256 public periodFinish = 0;\\n    uint256 public rewardRate = 0;\\n    uint256 public lastUpdateTime;\\n    uint256 public rewardPerTokenStored;\\n    uint256 public totalRewards = 0;\\n\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\n    mapping(address => uint256) public rewards;\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n\\n    modifier updateReward(address account) {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n        if (account != address(0)) {\\n            rewards[account] = earned(account);\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n        }\\n        _;\\n    }\\n\\n    constructor (\\n        address _b, // staking token address\\n        address _blo, // reward token address\\n        uint256 _duration, // reward duration (endTimestamp - startTimestamp)\\n        uint256 _initreward, // total reward amount\\n        uint256 _starttime // reward start time\\n    ) public LPTokenWrapper(_b) {\\n        blo = IERC20Detailed(_blo);\\n\\n        duration = _duration;\\n        starttime = _starttime;\\n        notifyRewardAmount(_initreward);\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        if (block.timestamp > starttime) {\\n            return Math.min(block.timestamp, periodFinish);\\n        }\\n        return starttime;\\n    }\\n\\n    function rewardPerToken() public view returns (uint256) {\\n        if (totalSupply() == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored.add(\\n                lastTimeRewardApplicable()\\n                    .sub(lastUpdateTime)\\n                    .mul(rewardRate)\\n                    .mul(1e18)\\n                    .div(totalSupply())\\n            );\\n    }\\n\\n    function earned(address account) public view returns (uint256) {\\n        return\\n            balanceOf(account)\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\n                .div(1e18)\\n                .add(rewards[account]);\\n    }\\n\\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\\n    function stake(uint256 amount) public override updateReward(msg.sender) {\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\n        super.stake(amount);\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\\n        require(amount > 0, \\\"Cannot withdraw 0\\\");\\n        super.withdraw(amount);\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function exit() external {\\n        withdraw(balanceOf(msg.sender));\\n        getReward();\\n    }\\n\\n    function getReward() public updateReward(msg.sender) checkStart {\\n        uint256 reward = earned(msg.sender);\\n        if (reward > 0) {\\n            rewards[msg.sender] = 0;\\n            blo.safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n            totalRewards = totalRewards.add(reward);\\n        }\\n    }\\n\\n    modifier checkStart(){\\n        require(block.timestamp > starttime, \\\"Not started\\\");\\n        _;\\n    }\\n\\n    function notifyRewardAmount(uint256 reward)\\n        internal\\n        override\\n        updateReward(address(0))\\n    {\\n        rewardRate = reward.div(duration);\\n        initreward = reward;\\n        lastUpdateTime = starttime;\\n        periodFinish = starttime.add(duration);\\n        emit RewardAdded(reward);\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TokenDistribution/IERC20Detailed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP including optional functions.\\n */\\ninterface IERC20Detailed is IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function name() external view returns (string memory);\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function symbol() external view returns (string memory);\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function decimals() external view returns (uint8);\\n}\"\r\n    },\r\n    \"contracts/TokenDistribution/IRewardDistributionRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport \\\"openzeppelin-solidity/contracts/access/Ownable.sol\\\";\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nabstract contract IRewardDistributionRecipient is Ownable {\\n    address rewardDistribution;\\n\\n    function notifyRewardAmount(uint256 reward) internal virtual;\\n\\n    modifier onlyRewardDistribution() {\\n        require(_msgSender() == rewardDistribution, \\\"Caller is not reward distribution\\\");\\n        _;\\n    }\\n\\n    function setRewardDistribution(address _rewardDistribution)\\n        external\\n        onlyOwner\\n    {\\n        rewardDistribution = _rewardDistribution;\\n    }\\n}\"\r\n    },\r\n    \"contracts/TokenDistribution/LPTokenWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"./IERC20Detailed.sol\\\";\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\ncontract LPTokenWrapper {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20Detailed;\\n\\n    IERC20Detailed public b;\\n\\n    uint256 private _totalSupply;\\n    mapping(address => uint256) private _balances;\\n\\n    constructor (address _b) internal {\\n        b = IERC20Detailed(_b);\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function stake(uint256 amount) public virtual {\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n        b.safeTransferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        b.safeTransfer(msg.sender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TokenDistribution/TokenVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/access/Ownable.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @title TokenVesting\\n * @dev A token holder contract that can release its token balance gradually like a\\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\\n * owner.\\n */\\ncontract TokenVesting is Ownable {\\n    // The vesting schedule is time-based (i.e. using block timestamps as opposed to e.g. block numbers), and is\\n    // therefore sensitive to timestamp manipulation (which is something miners can do, to a certain degree). Therefore,\\n    // it is recommended to avoid using short time durations (less than a minute). Typical vesting schemes, with a\\n    // cliff period of a year and a duration of four years, are safe to use.\\n    // solhint-disable not-rely-on-time\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event TokensReleased(address token, uint256 amount);\\n    event TokenVestingRevoked(address token);\\n\\n    // beneficiary of tokens after they are released\\n    address private _beneficiary;\\n\\n    // Durations and timestamps are expressed in UNIX time, the same units as block.timestamp.\\n    uint256 private _cliff;\\n    uint256 private _start;\\n    uint256 private _duration;\\n\\n    bool private _revocable;\\n\\n    mapping (address => uint256) private _released;\\n    mapping (address => bool) private _revoked;\\n\\n    /**\\n     * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\\n     * beneficiary, gradually in a linear fashion until start + duration. By then all\\n     * of the balance will have vested.\\n     * @param beneficiary address of the beneficiary to whom vested tokens are transferred\\n     * @param cliffDuration duration in seconds of the cliff in which tokens will begin to vest\\n     * @param start the time (as Unix time) at which point vesting starts\\n     * @param duration duration in seconds of the period in which the tokens will vest\\n     * @param revocable whether the vesting is revocable or not\\n     */\\n    constructor (address beneficiary, uint256 start, uint256 cliffDuration, uint256 duration, bool revocable) public {\\n        require(beneficiary != address(0), \\\"TokenVesting: beneficiary is the zero address\\\");\\n        // solhint-disable-next-line max-line-length\\n        require(cliffDuration <= duration, \\\"TokenVesting: cliff is longer than duration\\\");\\n        require(duration > 0, \\\"TokenVesting: duration is 0\\\");\\n        // solhint-disable-next-line max-line-length\\n        require(start.add(duration) > block.timestamp, \\\"TokenVesting: final time is before current time\\\");\\n\\n        _beneficiary = beneficiary;\\n        _revocable = revocable;\\n        _duration = duration;\\n        _cliff = start.add(cliffDuration);\\n        _start = start;\\n    }\\n\\n    /**\\n     * @return the beneficiary of the tokens.\\n     */\\n    function beneficiary() public view returns (address) {\\n        return _beneficiary;\\n    }\\n\\n    /**\\n     * @return the cliff time of the token vesting.\\n     */\\n    function cliff() public view returns (uint256) {\\n        return _cliff;\\n    }\\n\\n    /**\\n     * @return the start time of the token vesting.\\n     */\\n    function start() public view returns (uint256) {\\n        return _start;\\n    }\\n\\n    /**\\n     * @return the duration of the token vesting.\\n     */\\n    function duration() public view returns (uint256) {\\n        return _duration;\\n    }\\n\\n    /**\\n     * @return true if the vesting is revocable.\\n     */\\n    function revocable() public view returns (bool) {\\n        return _revocable;\\n    }\\n\\n    /**\\n     * @return the amount of the token released.\\n     */\\n    function released(address token) public view returns (uint256) {\\n        return _released[token];\\n    }\\n\\n    /**\\n     * @return true if the token is revoked.\\n     */\\n    function revoked(address token) public view returns (bool) {\\n        return _revoked[token];\\n    }\\n\\n    /**\\n     * @notice Transfers vested tokens to beneficiary.\\n     * @param token ERC20 token which is being vested\\n     */\\n    function release(IERC20 token) public {\\n        uint256 unreleased = _releasableAmount(token);\\n\\n        require(unreleased > 0, \\\"TokenVesting: no tokens are due\\\");\\n\\n        _released[address(token)] = _released[address(token)].add(unreleased);\\n\\n        token.safeTransfer(_beneficiary, unreleased);\\n\\n        emit TokensReleased(address(token), unreleased);\\n    }\\n\\n    /**\\n     * @notice Allows the owner to revoke the vesting. Tokens already vested\\n     * remain in the contract, the rest are returned to the owner.\\n     * @param token ERC20 token which is being vested\\n     */\\n    function revoke(IERC20 token) public onlyOwner {\\n        require(_revocable, \\\"TokenVesting: cannot revoke\\\");\\n        require(!_revoked[address(token)], \\\"TokenVesting: token already revoked\\\");\\n\\n        uint256 balance = token.balanceOf(address(this));\\n\\n        uint256 unreleased = _releasableAmount(token);\\n        uint256 refund = balance.sub(unreleased);\\n\\n        _revoked[address(token)] = true;\\n\\n        token.safeTransfer(owner(), refund);\\n\\n        emit TokenVestingRevoked(address(token));\\n    }\\n\\n    /**\\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\\n     * @param token ERC20 token which is being vested\\n     */\\n    function _releasableAmount(IERC20 token) private view returns (uint256) {\\n        return _vestedAmount(token).sub(_released[address(token)]);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount that has already vested.\\n     * @param token ERC20 token which is being vested\\n     */\\n    function _vestedAmount(IERC20 token) private view returns (uint256) {\\n        uint256 currentBalance = token.balanceOf(address(this));\\n        uint256 totalBalance = currentBalance.add(_released[address(token)]);\\n\\n        if (block.timestamp < _cliff) {\\n            return 0;\\n        } else if (block.timestamp >= _start.add(_duration) || _revoked[address(token)]) {\\n            return totalBalance;\\n        } else {\\n            return totalBalance.mul(block.timestamp.sub(_start)).div(_duration);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniswapOracle/UniswapConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"openzeppelin-solidity/contracts/access/Ownable.sol\\\";\\n\\ninterface CErc20 {\\n    function underlying() external view returns (address);\\n}\\n\\ncontract UniswapConfig is Ownable {\\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\\n    enum PriceSource {\\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\\n        REPORTER   /// implies the price is set by the reporter\\n    }\\n\\n    /// @dev Describe how the USD price should be determined for an asset.\\n    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\\n    struct TokenConfig {\\n        address cToken;\\n        address underlying;\\n        bytes32 symbolHash;\\n        uint256 baseUnit;\\n        PriceSource priceSource;\\n        uint256 fixedPrice;\\n        address uniswapMarket;\\n        bool isUniswapReversed;\\n    }\\n\\n    mapping(uint => TokenConfig) public tokens;\\n    mapping(address => uint) public cTokenIndex;\\n    mapping(address => uint) public underlyingIndex;\\n    mapping(bytes32 => uint) public symbolHashIndex;\\n\\n    /// @notice The number of tokens this contract actually supports\\n    uint public numTokens;\\n\\n    function _addTokensInternal(TokenConfig[] memory configs) internal {\\n        for (uint i = 0; i < configs.length; i++) {\\n            // +1 so index 0 stays empty\\n            uint index = i + numTokens + 1;\\n            tokens[index] = configs[i];\\n            cTokenIndex[configs[i].cToken] = index;\\n            underlyingIndex[configs[i].underlying] = index;\\n            symbolHashIndex[configs[i].symbolHash] = index;\\n        }\\n\\n        numTokens = numTokens + configs.length;\\n    }\\n\\n    function getCTokenIndex(address cToken) internal view returns (uint) {\\n        return cTokenIndex[cToken];\\n    }\\n\\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\\n        return underlyingIndex[underlying];\\n    }\\n\\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\\n        return symbolHashIndex[symbolHash];\\n    }\\n\\n    /**\\n     * @notice Get the i-th config, according to the order they were passed in originally\\n     * @param i The index of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\\n        require(i <= numTokens, \\\"token config not found\\\");\\n\\n        return tokens[i];\\n    }\\n\\n    /**\\n     * @notice Get the config for symbol\\n     * @param symbol The symbol of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\\n    }\\n\\n    /**\\n     * @notice Get the config for the symbolHash\\n     * @param symbolHash The keccack256 of the symbol of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\\n        uint index = getSymbolHashIndex(symbolHash);\\n        if (index != 0) {\\n            return getTokenConfig(index);\\n        }\\n\\n        revert(\\\"token config not found\\\");\\n    }\\n\\n    /**\\n     * @notice Get the config for the cToken\\n     * @dev If a config for the cToken is not found, falls back to searching for the underlying.\\n     * @param cToken The address of the cToken of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {\\n        uint index = getCTokenIndex(cToken);\\n        if (index != 0) {\\n            return getTokenConfig(index);\\n        }\\n\\n        return getTokenConfigByUnderlying(CErc20(cToken).underlying());\\n    }\\n\\n    /**\\n     * @notice Get the config for an underlying asset\\n     * @param underlying The address of the underlying asset of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\\n        uint index = getUnderlyingIndex(underlying);\\n        if (index != 0) {\\n            return getTokenConfig(index);\\n        }\\n\\n        revert(\\\"token config not found\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniswapOracle/UniswapAnchoredView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./UniswapConfig.sol\\\";\\nimport \\\"./UniswapLib.sol\\\";\\n\\nstruct Observation {\\n    uint timestamp;\\n    uint acc;\\n}\\n\\ncontract UniswapAnchoredView is UniswapConfig {\\n    using FixedPoint for *;\\n\\n    /// @notice The number of wei in 1 ETH\\n    uint public constant ethBaseUnit = 1e18;\\n\\n    /// @notice A common scaling factor to maintain precision\\n    uint public constant expScale = 1e18;\\n\\n    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\\n    uint public immutable anchorPeriod;\\n\\n    /// @notice Official prices by symbol hash\\n    mapping(bytes32 => uint) public prices;\\n\\n    /// @notice The old observation for each symbolHash\\n    mapping(bytes32 => Observation) public oldObservations;\\n\\n    /// @notice The new observation for each symbolHash\\n    mapping(bytes32 => Observation) public newObservations;\\n\\n    /// @notice The event emitted when anchor price is updated\\n    event AnchorPriceUpdated(address cToken, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\\n\\n    /// @notice The event emitted when the uniswap window changes\\n    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\\n\\n    bytes32 public immutable nativeTokenHash;\\n    bytes32 constant rotateHash = keccak256(abi.encodePacked(\\\"rotate\\\"));\\n\\n    /**\\n     * @notice Construct a uniswap anchored view for a set of token configurations\\n     * @dev Note that to avoid immature TWAPs, the system must run for at least a single anchorPeriod before using.\\n     * @param anchorPeriod_ The minimum amount of time required for the old uniswap price accumulator to be replaced\\n     */\\n    constructor(uint anchorPeriod_, string memory nativeTokenSymbol_) public {\\n        anchorPeriod = anchorPeriod_;\\n        nativeTokenHash = keccak256(abi.encodePacked(nativeTokenSymbol_));\\n    }\\n\\n    function addTokens(TokenConfig[] memory configs) public onlyOwner {\\n        for (uint i = 0; i < configs.length; i++) {\\n            TokenConfig memory config = configs[i];\\n            bytes32 symbolHash = config.symbolHash;\\n            require(config.baseUnit > 0, \\\"baseUnit must be greater than zero\\\");\\n            require(newObservations[symbolHash].timestamp == uint(0), \\\"cannot change current token\\\");\\n            address uniswapMarket = config.uniswapMarket;\\n            if (config.priceSource == PriceSource.REPORTER) {\\n                require(uniswapMarket != address(0), \\\"reported prices must have an anchor\\\");\\n                uint cumulativePrice = currentCumulativePrice(config);\\n                oldObservations[symbolHash].timestamp = block.timestamp;\\n                newObservations[symbolHash].timestamp = block.timestamp;\\n                oldObservations[symbolHash].acc = cumulativePrice;\\n                newObservations[symbolHash].acc = cumulativePrice;\\n                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\\n            } else {\\n                require(uniswapMarket == address(0), \\\"only reported prices utilize an anchor\\\");\\n            }\\n        }\\n\\n        _addTokensInternal(configs);\\n    }\\n\\n    /**\\n     * @notice Get the official price for a symbol\\n     * @param symbol The symbol to fetch the price of\\n     * @return Price denominated in USD, with 6 decimals\\n     */\\n    function price(string memory symbol) external view returns (uint) {\\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\\n        if (config.priceSource == PriceSource.REPORTER) return prices[config.symbolHash];\\n        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\\n        if (config.priceSource == PriceSource.FIXED_ETH) {\\n            uint usdPerEth = prices[nativeTokenHash];\\n            require(usdPerEth > 0, \\\"ETH price not set, cannot convert to dollars\\\");\\n            return mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\\n        }\\n        return 0;\\n    }\\n\\n    function priceInternal(TokenConfig memory config) internal returns (uint) {\\n        if (config.priceSource == PriceSource.REPORTER) {\\n            Observation memory newObservation = newObservations[config.symbolHash];\\n            // Update new and old observations if elapsed time is greater than or equal to anchor period\\n            uint timeElapsed = block.timestamp - newObservation.timestamp;\\n            if (timeElapsed >= anchorPeriod || prices[config.symbolHash] == 0) {\\n                postPriceInternal(config);\\n            }\\n            return prices[config.symbolHash];\\n        }\\n        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\\n        if (config.priceSource == PriceSource.FIXED_ETH) {\\n            uint usdPerEth = prices[nativeTokenHash];\\n            require(usdPerEth > 0, \\\"ETH price not set, cannot convert to dollars\\\");\\n            return mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the underlying price of a cToken\\n     * @dev Implements the PriceOracle interface for Compound v2.\\n     * @param cToken The cToken address for price retrieval\\n     * @return Price denominated in USD, with 18 decimals, for the given cToken address\\n     */\\n    function getUnderlyingPriceView(address cToken) external view returns (uint) {\\n        TokenConfig memory config = getTokenConfigByCToken(cToken);\\n        uint price;\\n        if (config.priceSource == PriceSource.REPORTER) price = prices[config.symbolHash];\\n        if (config.priceSource == PriceSource.FIXED_USD) price = config.fixedPrice;\\n        if (config.priceSource == PriceSource.FIXED_ETH) {\\n            uint usdPerEth = prices[nativeTokenHash];\\n            require(usdPerEth > 0, \\\"ETH price not set, cannot convert to dollars\\\");\\n            price = mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\\n        }\\n         // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\\n         // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\\n        return mul(1e18, price) / config.baseUnit;\\n    }\\n\\n    /**\\n     * @notice Get the underlying price of a cToken\\n     * @dev Implements the PriceOracle interface for Compound v2.\\n     * @param cToken The cToken address for price retrieval\\n     * @return Price denominated in USD, with 18 decimals, for the given cToken address\\n     */\\n    function getUnderlyingPrice(address cToken) external returns (uint) {\\n        TokenConfig memory config = getTokenConfigByCToken(cToken);\\n         // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\\n         // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\\n        return mul(1e18, priceInternal(config)) / config.baseUnit;\\n    }\\n\\n    function postPriceInternal(TokenConfig memory config) internal {\\n        uint ethPrice = fetchEthPrice();\\n\\n        uint anchorPrice;\\n        if (config.symbolHash == nativeTokenHash) {\\n            anchorPrice = ethPrice;\\n        } else {\\n            anchorPrice = fetchAnchorPrice(config, ethPrice);\\n        }\\n\\n        prices[config.symbolHash] = anchorPrice;\\n    }\\n\\n    /**\\n     * @dev Fetches the current token/eth price accumulator from uniswap.\\n     */\\n    function currentCumulativePrice(TokenConfig memory config) internal view returns (uint) {\\n        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\\n        if (config.isUniswapReversed) {\\n            return cumulativePrice1;\\n        } else {\\n            return cumulativePrice0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Fetches the current eth/usd price from uniswap, with 18 decimals of precision.\\n     *  Conversion factor is 1e30 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\\n     */\\n    function fetchEthPrice() internal returns (uint) {\\n        return fetchAnchorPrice(getTokenConfigBySymbolHash(nativeTokenHash), 1e30);\\n    }\\n\\n    /**\\n     * @dev Fetches the current token/usd price from uniswap, with 18 decimals of precision.\\n     * @param conversionFactor 1e30 if seeking the ETH price, and a 18 decimal ETH-USDC price in the case of other assets\\n     */\\n    function fetchAnchorPrice(TokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\\n\\n        // This should be impossible, but better safe than sorry\\n        require(block.timestamp > oldTimestamp, \\\"now must come after before\\\");\\n        uint timeElapsed = block.timestamp - oldTimestamp;\\n\\n        // Calculate uniswap time-weighted average price\\n        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\\n        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\\n        uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, conversionFactor);\\n        uint anchorPrice;\\n\\n        // Adjust rawUniswapPrice according to the units of the non-ETH asset\\n        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\\n        anchorPrice = mul(unscaledPriceMantissa / expScale, config.baseUnit) / ethBaseUnit;\\n\\n        emit AnchorPriceUpdated(config.cToken, anchorPrice, oldTimestamp, block.timestamp);\\n\\n        return anchorPrice;\\n    }\\n\\n    /**\\n     * @dev Get time-weighted average prices for a token at the current timestamp.\\n     *  Update new and old observations of lagging window if period elapsed.\\n     */\\n    function pokeWindowValues(TokenConfig memory config) internal returns (uint, uint, uint) {\\n        bytes32 symbolHash = config.symbolHash;\\n        uint cumulativePrice = currentCumulativePrice(config);\\n\\n        Observation memory newObservation = newObservations[symbolHash];\\n\\n        // Update new and old observations if elapsed time is greater than or equal to anchor period\\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\\n        if (timeElapsed >= anchorPeriod) {\\n            oldObservations[symbolHash].timestamp = newObservation.timestamp;\\n            oldObservations[symbolHash].acc = newObservation.acc;\\n\\n            newObservations[symbolHash].timestamp = block.timestamp;\\n            newObservations[symbolHash].acc = cumulativePrice;\\n            emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\\n        }\\n        return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\\n    }\\n\\n    /// @dev Overflow proof multiplication\\n    function mul(uint a, uint b) internal pure returns (uint) {\\n        if (a == 0) return 0;\\n        uint c = a * b;\\n        require(c / a == b, \\\"multiplication overflow\\\");\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniswapOracle/UniswapLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << 112) / denominator);\\n    }\\n\\n    // decode a uq112x112 into a uint with 18 decimals of precision\\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\\n        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\\n        // instead, get close to:\\n        //  (x * 1e18) >> 112\\n        // without risk of overflowing, e.g.:\\n        //  (x) / 2 ** (112 - lg(1e18))\\n        return uint(self._x) / 5192296858534827;\\n    }\\n}\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\\ninterface IUniswapV2Pair {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"anchorPeriod_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"nativeTokenSymbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anchorPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"}],\"name\":\"AnchorPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"UniswapWindowUpdated\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig[]\",\"name\":\"configs\",\"type\":\"tuple[]\"}],\"name\":\"addTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"anchorPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cTokenIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethBaseUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getTokenConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getTokenConfigByCToken\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getTokenConfigBySymbol\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"}],\"name\":\"getTokenConfigBySymbolHash\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getTokenConfigByUnderlying\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPriceView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeTokenHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"newObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"oldObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"symbolHashIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapConfig.PriceSource\",\"name\":\"priceSource\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"fixedPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"underlyingIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniswapAnchoredView","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000384000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000034554480000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}