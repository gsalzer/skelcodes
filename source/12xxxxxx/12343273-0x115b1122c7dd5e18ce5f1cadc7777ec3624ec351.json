{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n/**\r\n * @title FixidityLib\r\n * @author Gadi Guy, Alberto Cuesta Canada\r\n * @notice This library provides fixed point arithmetic with protection against\r\n * overflow. \r\n * All operations are done with int256 and the operands must have been created \r\n * with any of the newFrom* functions, which shift the comma digits() to the \r\n * right and check for limits.\r\n * When using this library be sure of using maxNewFixed() as the upper limit for\r\n * creation of fixed point numbers. Use maxFixedMul(), maxFixedDiv() and\r\n * maxFixedAdd() if you want to be certain that those operations don't \r\n * overflow.\r\n */\r\nlibrary FixidityLib {\r\n\r\n    /**\r\n     * @notice Number of positions that the comma is shifted to the right.\r\n     */\r\n    function digits() internal pure returns(uint8) {\r\n        return 24;\r\n    }\r\n    \r\n    /**\r\n     * @notice This is 1 in the fixed point units used in this library.\r\n     * @dev Test fixed1() equals 10^digits()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function fixed1() internal pure returns(int256) {\r\n        return 1000000000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice The amount of decimals lost on each multiplication operand.\r\n     * @dev Test mulPrecision() equals sqrt(fixed1)\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function mulPrecision() internal pure returns(int256) {\r\n        return 1000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be represented in an int256\r\n     * @dev Test maxInt256() equals 2^255 -1\r\n     */\r\n    function maxInt256() internal pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\r\n    }\r\n\r\n    /**\r\n     * @notice Minimum value that can be represented in an int256\r\n     * @dev Test minInt256 equals (2^255) * (-1)\r\n     */\r\n    function minInt256() internal pure returns(int256) {\r\n        return -57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be converted to fixed point. Optimize for\r\n     * @dev deployment. \r\n     * Test maxNewFixed() equals maxInt256() / fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxNewFixed() internal pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be converted to fixed point. Optimize for\r\n     * deployment. \r\n     * @dev Test minNewFixed() equals -(maxInt256()) / fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function minNewFixed() internal pure returns(int256) {\r\n        return -57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as an addition operator.\r\n     * @dev Test maxFixedAdd() equals maxInt256()-1 / 2\r\n     * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\r\n     * Test add(maxFixedAdd()+1,maxFixedAdd()) throws \r\n     * Test add(-maxFixedAdd(),-maxFixedAdd()) equals -maxFixedAdd() - maxFixedAdd()\r\n     * Test add(-maxFixedAdd(),-maxFixedAdd()-1) throws \r\n     */\r\n    function maxFixedAdd() internal pure returns(int256) {\r\n        return 28948022309329048855892746252171976963317496166410141009864396001978282409983;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum negative value that can be safely in a subtraction.\r\n     * @dev Test maxFixedSub() equals minInt256() / 2\r\n     */\r\n    function maxFixedSub() internal pure returns(int256) {\r\n        return -28948022309329048855892746252171976963317496166410141009864396001978282409984;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a multiplication operator.\r\n     * @dev Calculated as sqrt(maxInt256()*fixed1()). \r\n     * Be careful with your sqrt() implementation. I couldn't find a calculator\r\n     * that would give the exact square root of maxInt256*fixed1 so this number\r\n     * is below the real number by no more than 3*10**28. It is safe to use as\r\n     * a limit for your multiplications, although powers of two of numbers over\r\n     * this value might still work.\r\n     * Test multiply(maxFixedMul(),maxFixedMul()) equals maxFixedMul() * maxFixedMul()\r\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) throws \r\n     * Test multiply(-maxFixedMul(),maxFixedMul()) equals -maxFixedMul() * maxFixedMul()\r\n     * Test multiply(-maxFixedMul(),maxFixedMul()+1) throws \r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedMul() internal pure returns(int256) {\r\n        return 240615969168004498257251713877715648331380787511296;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a dividend.\r\n     * @dev divide(maxFixedDiv,newFixedFraction(1,fixed1())) = maxInt256().\r\n     * Test maxFixedDiv() equals maxInt256()/fixed1()\r\n     * Test divide(maxFixedDiv(),multiply(mulPrecision(),mulPrecision())) = maxFixedDiv()*(10^digits())\r\n     * Test divide(maxFixedDiv()+1,multiply(mulPrecision(),mulPrecision())) throws\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedDiv() internal pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a divisor.\r\n     * @dev Test maxFixedDivisor() equals fixed1()*fixed1() - Or 10**(digits()*2)\r\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2)) = returns 10*fixed1()\r\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2 + 1)) = throws\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedDivisor() internal pure returns(int256) {\r\n        return 1000000000000000000000000000000000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 to fixed point units, equivalent to multiplying\r\n     * by 10^digits().\r\n     * @dev Test newFixed(0) returns 0\r\n     * Test newFixed(1) returns fixed1()\r\n     * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\r\n     * Test newFixed(maxNewFixed()+1) fails\r\n     */\r\n    function newFixed(int256 x)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(x <= maxNewFixed());\r\n        assert(x >= minNewFixed());\r\n        return x * fixed1();\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 in the fixed point representation of this \r\n     * library to a non decimal. All decimal digits will be truncated.\r\n     */\r\n    function fromFixed(int256 x)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return x / fixed1();\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 which is already in some fixed point \r\n     * representation to a different fixed precision representation.\r\n     * Both the origin and destination precisions must be 38 or less digits.\r\n     * Origin values with a precision higher than the destination precision\r\n     * will be truncated accordingly.\r\n     * @dev \r\n     * Test convertFixed(1,0,0) returns 1;\r\n     * Test convertFixed(1,1,1) returns 1;\r\n     * Test convertFixed(1,1,0) returns 0;\r\n     * Test convertFixed(1,0,1) returns 10;\r\n     * Test convertFixed(10,1,0) returns 1;\r\n     * Test convertFixed(10,0,1) returns 100;\r\n     * Test convertFixed(100,1,0) returns 10;\r\n     * Test convertFixed(100,0,1) returns 1000;\r\n     * Test convertFixed(1000,2,0) returns 10;\r\n     * Test convertFixed(1000,0,2) returns 100000;\r\n     * Test convertFixed(1000,2,1) returns 100;\r\n     * Test convertFixed(1000,1,2) returns 10000;\r\n     * Test convertFixed(maxInt256,1,0) returns maxInt256/10;\r\n     * Test convertFixed(maxInt256,0,1) throws\r\n     * Test convertFixed(maxInt256,38,0) returns maxInt256/(10**38);\r\n     * Test convertFixed(1,0,38) returns 10**38;\r\n     * Test convertFixed(maxInt256,39,0) throws\r\n     * Test convertFixed(1,0,39) throws\r\n     */\r\n    function convertFixed(int256 x, uint8 _originDigits, uint8 _destinationDigits)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(_originDigits <= 38 && _destinationDigits <= 38);\r\n        \r\n        uint8 decimalDifference;\r\n        if ( _originDigits > _destinationDigits ){\r\n            decimalDifference = _originDigits - _destinationDigits;\r\n            return x/int256((uint128(10)**uint128(decimalDifference)));\r\n        }\r\n        else if ( _originDigits < _destinationDigits ){\r\n            decimalDifference = _destinationDigits - _originDigits;\r\n            // Cast uint8 -> uint128 is safe\r\n            // Exponentiation is safe:\r\n            //     _originDigits and _destinationDigits limited to 38 or less\r\n            //     decimalDifference = abs(_destinationDigits - _originDigits)\r\n            //     decimalDifference < 38\r\n            //     10**38 < 2**128-1\r\n            assert(x <= maxInt256()/int256(uint128(10)**uint128(decimalDifference)));\r\n            assert(x >= minInt256()/int256(uint128(10)**uint128(decimalDifference)));\r\n            return x*(int256(uint128(10)**uint128(decimalDifference)));\r\n        }\r\n        // _originDigits == digits()) \r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 which is already in some fixed point \r\n     * representation to that of this library. The _originDigits parameter is the\r\n     * precision of x. Values with a precision higher than FixidityLib.digits()\r\n     * will be truncated accordingly.\r\n     */\r\n    function newFixed(int256 x, uint8 _originDigits)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return convertFixed(x, _originDigits, digits());\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 in the fixed point representation of this \r\n     * library to a different representation. The _destinationDigits parameter is the\r\n     * precision of the output x. Values with a precision below than \r\n     * FixidityLib.digits() will be truncated accordingly.\r\n     */\r\n    function fromFixed(int256 x, uint8 _destinationDigits)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return convertFixed(x, digits(), _destinationDigits);\r\n    }\r\n\r\n    /**\r\n     * @notice Converts two int256 representing a fraction to fixed point units,\r\n     * equivalent to multiplying dividend and divisor by 10^digits().\r\n     * @dev \r\n     * Test newFixedFraction(maxFixedDiv()+1,1) fails\r\n     * Test newFixedFraction(1,maxFixedDiv()+1) fails\r\n     * Test newFixedFraction(1,0) fails     \r\n     * Test newFixedFraction(0,1) returns 0\r\n     * Test newFixedFraction(1,1) returns fixed1()\r\n     * Test newFixedFraction(maxFixedDiv(),1) returns maxFixedDiv()*fixed1()\r\n     * Test newFixedFraction(1,fixed1()) returns 1\r\n     * Test newFixedFraction(1,fixed1()-1) returns 0\r\n     */\r\n    function newFixedFraction(\r\n        int256 numerator, \r\n        int256 denominator\r\n        )\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(numerator <= maxNewFixed());\r\n        assert(denominator <= maxNewFixed());\r\n        assert(denominator != 0);\r\n        int256 convertedNumerator = newFixed(numerator);\r\n        int256 convertedDenominator = newFixed(denominator);\r\n        return divide(convertedNumerator, convertedDenominator);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the integer part of a fixed point number.\r\n     * @dev \r\n     * Test integer(0) returns 0\r\n     * Test integer(fixed1()) returns fixed1()\r\n     * Test integer(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\r\n     * Test integer(-fixed1()) returns -fixed1()\r\n     * Test integer(newFixed(-maxNewFixed())) returns -maxNewFixed()*fixed1()\r\n     */\r\n    function integer(int256 x) internal pure returns (int256) {\r\n        return (x / fixed1()) * fixed1(); // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the fractional part of a fixed point number. \r\n     * In the case of a negative number the fractional is also negative.\r\n     * @dev \r\n     * Test fractional(0) returns 0\r\n     * Test fractional(fixed1()) returns 0\r\n     * Test fractional(fixed1()-1) returns 10^24-1\r\n     * Test fractional(-fixed1()) returns 0\r\n     * Test fractional(-fixed1()+1) returns -10^24-1\r\n     */\r\n    function fractional(int256 x) internal pure returns (int256) {\r\n        return x - (x / fixed1()) * fixed1(); // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice Converts to positive if negative.\r\n     * Due to int256 having one more negative number than positive numbers \r\n     * abs(minInt256) reverts.\r\n     * @dev \r\n     * Test abs(0) returns 0\r\n     * Test abs(fixed1()) returns -fixed1()\r\n     * Test abs(-fixed1()) returns fixed1()\r\n     * Test abs(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\r\n     * Test abs(newFixed(minNewFixed())) returns -minNewFixed()*fixed1()\r\n     */\r\n    function abs(int256 x) internal pure returns (int256) {\r\n        if (x >= 0) {\r\n            return x;\r\n        } else {\r\n            int256 result = -x;\r\n            assert (result > 0);\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice x+y. If any operator is higher than maxFixedAdd() it \r\n     * might overflow.\r\n     * In solidity maxInt256 + 1 = minInt256 and viceversa.\r\n     * @dev \r\n     * Test add(maxFixedAdd(),maxFixedAdd()) returns maxInt256()-1\r\n     * Test add(maxFixedAdd()+1,maxFixedAdd()+1) fails\r\n     * Test add(-maxFixedSub(),-maxFixedSub()) returns minInt256()\r\n     * Test add(-maxFixedSub()-1,-maxFixedSub()-1) fails\r\n     * Test add(maxInt256(),maxInt256()) fails\r\n     * Test add(minInt256(),minInt256()) fails\r\n     */\r\n    function add(int256 x, int256 y) internal pure returns (int256) {\r\n        int256 z = x + y;\r\n        if (x > 0 && y > 0) assert(z > x && z > y);\r\n        if (x < 0 && y < 0) assert(z < x && z < y);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n     * @notice x-y. You can use add(x,-y) instead. \r\n     * @dev Tests covered by add(x,y)\r\n     */\r\n    function subtract(int256 x, int256 y) internal pure returns (int256) {\r\n        return add(x,-y);\r\n    }\r\n\r\n    /**\r\n     * @notice x*y. If any of the operators is higher than maxFixedMul() it \r\n     * might overflow.\r\n     * @dev \r\n     * Test multiply(0,0) returns 0\r\n     * Test multiply(maxFixedMul(),0) returns 0\r\n     * Test multiply(0,maxFixedMul()) returns 0\r\n     * Test multiply(maxFixedMul(),fixed1()) returns maxFixedMul()\r\n     * Test multiply(fixed1(),maxFixedMul()) returns maxFixedMul()\r\n     * Test all combinations of (2,-2), (2, 2.5), (2, -2.5) and (0.5, -0.5)\r\n     * Test multiply(fixed1()/mulPrecision(),fixed1()*mulPrecision())\r\n     * Test multiply(maxFixedMul()-1,maxFixedMul()) equals multiply(maxFixedMul(),maxFixedMul()-1)\r\n     * Test multiply(maxFixedMul(),maxFixedMul()) returns maxInt256() // Probably not to the last digits\r\n     * Test multiply(maxFixedMul()+1,maxFixedMul()) fails\r\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) fails\r\n     */\r\n    function multiply(int256 x, int256 y) internal pure returns (int256) {\r\n        if (x == 0 || y == 0) return 0;\r\n        if (y == fixed1()) return x;\r\n        if (x == fixed1()) return y;\r\n\r\n        // Separate into integer and fractional parts\r\n        // x = x1 + x2, y = y1 + y2\r\n        int256 x1 = integer(x) / fixed1();\r\n        int256 x2 = fractional(x);\r\n        int256 y1 = integer(y) / fixed1();\r\n        int256 y2 = fractional(y);\r\n        \r\n        // (x1 + x2) * (y1 + y2) = (x1 * y1) + (x1 * y2) + (x2 * y1) + (x2 * y2)\r\n        int256 x1y1 = x1 * y1;\r\n        if (x1 != 0) assert(x1y1 / x1 == y1); // Overflow x1y1\r\n        \r\n        // x1y1 needs to be multiplied back by fixed1\r\n        // solium-disable-next-line mixedcase\r\n        int256 fixed_x1y1 = x1y1 * fixed1();\r\n        if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed1()); // Overflow x1y1 * fixed1\r\n        x1y1 = fixed_x1y1;\r\n\r\n        int256 x2y1 = x2 * y1;\r\n        if (x2 != 0) assert(x2y1 / x2 == y1); // Overflow x2y1\r\n\r\n        int256 x1y2 = x1 * y2;\r\n        if (x1 != 0) assert(x1y2 / x1 == y2); // Overflow x1y2\r\n\r\n        x2 = x2 / mulPrecision();\r\n        y2 = y2 / mulPrecision();\r\n        int256 x2y2 = x2 * y2;\r\n        if (x2 != 0) assert(x2y2 / x2 == y2); // Overflow x2y2\r\n\r\n        // result = fixed1() * x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2 / fixed1();\r\n        int256 result = x1y1;\r\n        result = add(result, x2y1); // Add checks for overflow\r\n        result = add(result, x1y2); // Add checks for overflow\r\n        result = add(result, x2y2); // Add checks for overflow\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * @notice 1/x\r\n     * @dev \r\n     * Test reciprocal(0) fails\r\n     * Test reciprocal(fixed1()) returns fixed1()\r\n     * Test reciprocal(fixed1()*fixed1()) returns 1 // Testing how the fractional is truncated\r\n     * Test reciprocal(2*fixed1()*fixed1()) returns 0 // Testing how the fractional is truncated\r\n     */\r\n    function reciprocal(int256 x) internal pure returns (int256) {\r\n        assert(x != 0);\r\n        return (fixed1()*fixed1()) / x; // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice x/y. If the dividend is higher than maxFixedDiv() it \r\n     * might overflow. You can use multiply(x,reciprocal(y)) instead.\r\n     * There is a loss of precision on division for the lower mulPrecision() decimals.\r\n     * @dev \r\n     * Test divide(fixed1(),0) fails\r\n     * Test divide(maxFixedDiv(),1) = maxFixedDiv()*(10^digits())\r\n     * Test divide(maxFixedDiv()+1,1) throws\r\n     * Test divide(maxFixedDiv(),maxFixedDiv()) returns fixed1()\r\n     */\r\n    function divide(int256 x, int256 y) internal pure returns (int256) {\r\n        if (y == fixed1()) return x;\r\n        assert(y != 0);\r\n        assert(y <= maxFixedDivisor());\r\n        return multiply(x, reciprocal(y));\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IFuelTank {\r\n  function openNozzle() external;\r\n  function addTokens(address user, uint amount) external;\r\n}\r\n\r\ncontract MeowDAO is IERC20, Context {\r\n  using FixidityLib for int256;\r\n\r\n  uint256 _totalSupply = 0;\r\n  string private _name;\r\n  string private _symbol;\r\n\r\n  uint8 private _decimals = 13;\r\n  uint private _contractStart;\r\n\r\n  address public grumpyAddress;\r\n  address public grumpyFuelTankAddress;\r\n  uint public swapEndTime;\r\n\r\n  bool public launched = false;\r\n\r\n  uint256 public totalStartingSupply = 10**10 * 10**13; //10_000_000_000.0_000_000_000_000 10 billion MEOWS. 10^23\r\n\r\n  mapping (address => uint256) private _balances;\r\n  mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n  mapping (address => uint) public periodStart;\r\n  mapping (address => bool) public currentlyStaked;\r\n  mapping (address => uint) public unlockStartTime;\r\n  mapping (address => address) public currentVotes;\r\n  mapping (address => uint256) public voteWeights;\r\n\r\n  mapping (address => uint256) public stakingCoordinatesTime;\r\n  mapping (address => uint256) public stakingCoordinatesAmount;\r\n\r\n  mapping(address => uint256) public voteCounts;\r\n  address[] public voteIterator;\r\n  mapping(address => bool) public walletWasVotedFor;\r\n  address public currentCharityWallet;\r\n\r\n  constructor(address _grumpyAddress, address _grumpyFuelTankAddress, string memory __name, string memory __symbol) {\r\n    _name = __name;\r\n    _symbol = __symbol;\r\n\r\n    _contractStart = block.timestamp;\r\n\r\n    grumpyAddress = _grumpyAddress;\r\n    grumpyFuelTankAddress = _grumpyFuelTankAddress;\r\n\r\n    swapEndTime = block.timestamp + (86400 * 5);\r\n  }\r\n\r\n  function _swapGrumpyInternal(address user, uint256 amount) private {\r\n    require(block.timestamp < swapEndTime);\r\n    require(!isStaked(user), \"cannot swap into staked wallet\");\r\n    \r\n    IERC20(grumpyAddress).transferFrom(user, grumpyFuelTankAddress, amount);\r\n    IFuelTank(grumpyFuelTankAddress).addTokens(user, amount);\r\n\r\n    _balances[user] += amount;\r\n\r\n    _totalSupply += amount;\r\n\r\n    emit Transfer(address(0), user, amount);\r\n  }\r\n\r\n  function swapGrumpy(uint256 amount) public {\r\n    _swapGrumpyInternal(_msgSender(), amount);\r\n  }\r\n\r\n  function initializeCoinThruster() external {\r\n    require(block.timestamp >= swapEndTime, \"NotReady\");\r\n    require(launched == false, \"AlreadyLaunched\");\r\n\r\n    IFuelTank(grumpyFuelTankAddress).openNozzle();\r\n\r\n    if (totalStartingSupply > _totalSupply) {\r\n      uint256 remainingTokens = totalStartingSupply - _totalSupply;\r\n\r\n      _balances[grumpyFuelTankAddress] = _balances[grumpyFuelTankAddress] + remainingTokens;\r\n      _totalSupply += remainingTokens;\r\n\r\n      emit Transfer(address(0), grumpyFuelTankAddress, remainingTokens);\r\n    }\r\n\r\n    launched = true;\r\n  }\r\n\r\n  function getBlockTime() public view returns (uint) {\r\n    return block.timestamp;\r\n  }\r\n\r\n  function isStaked(address wallet) public view returns (bool) {\r\n    return currentlyStaked[wallet];\r\n  }\r\n\r\n  function isUnlocked(address wallet) private returns (bool) {\r\n    uint unlockStarted = unlockStartTime[wallet];\r\n\r\n    if (unlockStarted == 0) return true;\r\n\r\n    uint unlockedAt = unlockStarted + (86400 * 5);\r\n\r\n    if (block.timestamp > unlockedAt) {\r\n      unlockStartTime[wallet] = 0;\r\n      return true;\r\n    }\r\n    else return false;\r\n  }\r\n\r\n  function _stakeWalletFor(address sender) private returns (bool) {\r\n    require(!isStaked(sender));\r\n    require(enoughFundsToStake(sender), \"InsfcntFnds\");\r\n    require(isUnlocked(sender), \"WalletIsLocked\");\r\n\r\n    currentlyStaked[sender] = true;\r\n    unlockStartTime[sender] = 0;\r\n    currentVotes[sender] = address(0);\r\n    periodStart[sender] = block.timestamp;\r\n\r\n    stakingCoordinatesTime[sender] = block.timestamp;\r\n    stakingCoordinatesAmount[sender] = _balances[sender];\r\n\r\n    return true;\r\n  }\r\n\r\n  function stakeWallet() public returns (bool) {\r\n    return _stakeWalletFor(_msgSender());\r\n  }\r\n\r\n  function _unstakeWalletFor(address sender, bool shouldReify) private {\r\n    require(isStaked(sender));\r\n\r\n    if (shouldReify) reifyYield(sender);\r\n\r\n    if (voteWeights[sender] != 0) {\r\n      removeVoteWeight(sender);\r\n      updateCharityWallet();\r\n    }\r\n\r\n    currentlyStaked[sender] = false;\r\n    currentVotes[sender] = address(0);\r\n    voteWeights[sender] = 0;\r\n    periodStart[sender] = 0;\r\n\r\n    stakingCoordinatesTime[sender] = 0;\r\n    stakingCoordinatesAmount[sender] = 0;\r\n\r\n    unlockStartTime[sender] = block.timestamp;\r\n  } \r\n\r\n  function unstakeWallet() public {\r\n    _unstakeWalletFor(_msgSender(), true);\r\n  }\r\n\r\n  function unstakeWalletSansReify() public {\r\n    _unstakeWalletFor(_msgSender(), false);\r\n  }\r\n\r\n  function voteIteratorLength() external view returns (uint) {\r\n    return voteIterator.length;\r\n  }\r\n\r\n  function voteWithRebuildIfNecessary(address charityWalletVote) public {\r\n    if (voteIterator.length == 12 && !walletWasVotedFor[charityWalletVote]) {\r\n      rebuildVotingIterator();\r\n    }\r\n    _voteForAddressBy(charityWalletVote, _msgSender());\r\n  }\r\n\r\n  function rebuildVotingIterator() public {\r\n    require(voteIterator.length == 12, \"Voting Iterator not full\");\r\n\r\n    address[12] memory voteCopy;\r\n    for (uint i = 0; i < 12; i++) {\r\n      voteCopy[i] = voteIterator[i];\r\n    }\r\n\r\n    //insertion sort copy\r\n    for (uint i = 1; i < 12; i++)\r\n    {\r\n      address keyAddress = voteCopy[i];\r\n      uint key = voteCounts[keyAddress];\r\n\r\n      uint j = i - 1;\r\n\r\n      bool broke = false;\r\n      while (j >= 0 && voteCounts[voteCopy[j]] < key) {\r\n        voteCopy[j + 1] = voteCopy[j];\r\n\r\n        if (j == 0) {\r\n          broke = true;\r\n          break;\r\n        }\r\n        else j--;\r\n      }\r\n\r\n      if (broke) voteCopy[0] = keyAddress;\r\n      else voteCopy[j + 1] = keyAddress;\r\n    }\r\n\r\n    for (uint i = 11; i >= 6; i--) {\r\n      address vote = voteCopy[i];\r\n      walletWasVotedFor[vote] = false;\r\n    }\r\n\r\n    delete voteIterator;\r\n    for (uint i = 0; i < 6; i++) {\r\n      voteIterator.push(voteCopy[i]);\r\n    }\r\n\r\n  }\r\n\r\n  function _voteForAddressBy(address charityWalletVote, address sender) private {\r\n    require(isStaked(sender));\r\n\r\n    trackCandidate(charityWalletVote);\r\n\r\n    removeVoteWeight(sender);\r\n    setVoteWeight(sender);\r\n    addVoteWeight(sender, charityWalletVote);\r\n    updateCharityWallet();\r\n  }\r\n\r\n  function trackCandidate(address charityWalletCandidate) private {\r\n    // If wallet was never voted for before add it to voteIterator\r\n    if (!walletWasVotedFor[charityWalletCandidate]) {\r\n      require(voteIterator.length < 12, \"Vote Iterator must be rebuilt\");\r\n\r\n      voteIterator.push(charityWalletCandidate);\r\n      walletWasVotedFor[charityWalletCandidate] = true;\r\n    }\r\n  }\r\n\r\n  function removeVoteWeight(address sender) private {\r\n    address vote = currentVotes[sender];\r\n    voteCounts[vote] = voteCounts[vote] - voteWeights[sender];\r\n  }\r\n\r\n  function setVoteWeight(address sender) private {\r\n    uint256 newVoteWeight = _balances[sender];\r\n    voteWeights[sender] = newVoteWeight;\r\n  }\r\n\r\n  function addVoteWeight(address sender, address charityWalletVote) private {\r\n    voteCounts[charityWalletVote] = voteCounts[charityWalletVote] + voteWeights[sender];\r\n    currentVotes[sender] = charityWalletVote;\r\n  }\r\n\r\n  function voteForAddress(address charityWalletVote) public {\r\n    _voteForAddressBy(charityWalletVote, _msgSender());\r\n  }\r\n\r\n  event NewCharityWallet(address oldW, address newW);\r\n\r\n  function updateCharityWallet() private {\r\n    uint256 maxVoteValue = 0; \r\n    address winner = address(0);\r\n\r\n    for (uint i = 0; i < voteIterator.length; i++) {\r\n      address currentWallet = voteIterator[i];\r\n      uint256 voteValue = voteCounts[currentWallet];\r\n\r\n      if (voteValue > maxVoteValue) {\r\n        maxVoteValue = voteValue;\r\n        winner = currentWallet;\r\n      }\r\n    }\r\n\r\n    if (currentCharityWallet == winner) return;\r\n\r\n    emit NewCharityWallet(currentCharityWallet, winner);\r\n\r\n    currentCharityWallet = winner;\r\n  }\r\n\r\n  function validCharityWallet() internal view returns (bool) {\r\n    return currentCharityWallet != address(0) && !isStaked(currentCharityWallet);\r\n  }\r\n\r\n  function getCompoundingFactor(address wallet) private view returns (uint) {\r\n    return block.timestamp - periodStart[wallet];\r\n  }\r\n\r\n  function calculateYield(uint256 principal, uint n) public pure returns (uint256) {\r\n    int256 fixedPrincipal = int256(principal).newFixed();\r\n\r\n    int256 rate = int256(2144017221509).newFixedFraction(1000000000000000000000);\r\n    int256 fixed2 = int256(2).newFixed();\r\n\r\n    while (n > 0) {\r\n      if (n % 2 == 1) {\r\n        fixedPrincipal = fixedPrincipal.add(fixedPrincipal.multiply(rate));\r\n        n -= 1;\r\n      }\r\n      else {\r\n        rate = (fixed2.multiply(rate))\r\n          .add(rate.multiply(rate));\r\n        n /= 2;\r\n      }\r\n    }\r\n    return uint256(fixedPrincipal.fromFixed()) - principal;\r\n  }\r\n\r\n  function getTransactionFee(uint256 txAmt) private view returns (uint256){\r\n    uint period = block.timestamp - _contractStart;\r\n\r\n    if (period > 31536000) return 0;\r\n    else if (period > 23652000) return txAmt / 400;\r\n    else if (period > 15768000) return txAmt / 200;\r\n    else if (period > 7884000) return (txAmt / 400) * 3;\r\n    else return txAmt / 100;\r\n  } \r\n\r\n  function reifyYield(address wallet) public {\r\n    require(isStaked(wallet), 'MstBeStkd');\r\n\r\n    uint compoundingFactor = getCompoundingFactor(wallet);\r\n\r\n    if (compoundingFactor < 60) return;\r\n\r\n    uint256 yield = calculateYield(_balances[wallet], compoundingFactor);\r\n\r\n    _balances[wallet] += yield;\r\n\r\n    if (validCharityWallet()) {\r\n      uint256 charityYield = (yield / 7) * 3;\r\n      _balances[currentCharityWallet] += charityYield;\r\n      _totalSupply += (yield + charityYield);\r\n    } else {\r\n      _totalSupply += yield;\r\n    }\r\n\r\n    periodStart[wallet] = block.timestamp;\r\n  }\r\n\r\n  function enoughFundsToStake(address wallet) private view returns (bool) {\r\n    return _balances[wallet] >= 10000000000000000;\r\n  }\r\n\r\n  function name() external view returns (string memory) {\r\n    return _name;\r\n  } \r\n\r\n  function symbol() external view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  function decimals() external view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  function contractStart() external view returns (uint) {\r\n    return _contractStart;\r\n  }\r\n\r\n  function totalSupply() external view override returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address account) public view virtual override returns (uint256) {\r\n    uint b = _balances[account];\r\n\r\n    if (isStaked(account) && currentCharityWallet != account) {\r\n      return b + calculateYield(b, getCompoundingFactor(account));\r\n    }\r\n    return b;\r\n  }\r\n\r\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n    require(!isStaked(sender), \"StkdWlltCnntTrnsf\");\r\n    require(isUnlocked(sender), \"LockedWlltCnntTrnsfr\");\r\n    require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\r\n\r\n    if (isStaked(recipient)) {\r\n      reifyYield(recipient);\r\n    }\r\n\r\n    uint sentAmount = amount; \r\n\r\n    if (validCharityWallet()) {\r\n      uint256 txFee = getTransactionFee(amount);\r\n\r\n      if (txFee != 0) {\r\n        sentAmount -= txFee;\r\n        _balances[currentCharityWallet] += txFee;\r\n      }\r\n    }\r\n\r\n    _balances[sender] -= amount;\r\n    _balances[recipient] += sentAmount;\r\n\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  function approve(address spender, uint256 amount) public override returns (bool) {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n    require(owner != address(0), \"ERC20: approve from the zero address\");\r\n    require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n\r\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n    require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n    _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n    uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n    _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n    return true;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_grumpyAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_grumpyFuelTankAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"__name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"__symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldW\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newW\",\"type\":\"address\"}],\"name\":\"NewCharityWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"calculateYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentCharityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"currentVotes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"currentlyStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"grumpyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"grumpyFuelTankAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeCoinThruster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launched\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"periodStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebuildVotingIterator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"reifyYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingCoordinatesAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingCoordinatesTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapGrumpy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStartingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"unlockStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeWalletSansReify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteCounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"charityWalletVote\",\"type\":\"address\"}],\"name\":\"voteForAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voteIterator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteIteratorLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteWeights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"charityWalletVote\",\"type\":\"address\"}],\"name\":\"voteWithRebuildIfNecessary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletWasVotedFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MeowDAO","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000093b2fff814fcaeffb01406e80b4ecd89ca6a021b00000000000000000000000018f47e7fe583d8a8297daaa9f8ac89b63b96b8e4000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000184d656f7744414f20476f7665726e616e636520546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000044d454f5700000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ad762d19dfb9ad27d8d8063bf861ae736c433b067bdb435a571e4879976cef41"}]}