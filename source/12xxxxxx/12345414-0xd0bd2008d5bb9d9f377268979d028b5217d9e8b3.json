{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.8.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IConfig.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\ninterface IConfig {\r\n    enum EventType {FUND_CREATED, FUND_UPDATED, STAKE_CREATED, STAKE_UPDATED, REG_CREATED, REG_UPDATED, PFUND_CREATED, PFUND_UPDATED}\r\n\r\n    function ceo() external view returns (address);\r\n\r\n    function protocolPool() external view returns (address);\r\n\r\n    function protocolToken() external view returns (address);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function nameRegistry() external view returns (address);\r\n\r\n    //  function investTokenWhitelist() external view returns (address[] memory);\r\n\r\n    function tokenMinFundSize(address token) external view returns (uint256);\r\n\r\n    function investFeeRate() external view returns (uint256);\r\n\r\n    function redeemFeeRate() external view returns (uint256);\r\n\r\n    function claimFeeRate() external view returns (uint256);\r\n\r\n    function poolCreationRate() external view returns (uint256);\r\n\r\n    function slot0() external view returns (uint256);\r\n\r\n    function slot1() external view returns (uint256);\r\n\r\n    function slot2() external view returns (uint256);\r\n\r\n    function slot3() external view returns (uint256);\r\n\r\n    function slot4() external view returns (uint256);\r\n\r\n    function notify(EventType _type, address _src) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IStake.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\ninterface IStake {\r\n    function claim0(address _owner) external;\r\n\r\n    function initialize(\r\n        address stakeToken,\r\n        address rewardToken,\r\n        uint256 start,\r\n        uint256 end,\r\n        uint256 rewardPerBlock\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/libs/TransferHelper.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper: APPROVE_FAILED'\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper: TRANSFER_FAILED'\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper: TRANSFER_FROM_FAILED'\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Stake.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\n\r\n\r\n\r\ninterface IConfigable {\r\n    function getConfig() external returns (IConfig);\r\n}\r\n\r\ncontract Stake is IStake {\r\n    event StakeUpdated(\r\n        address indexed staker,\r\n        bool isIncrease,\r\n        uint256 stakeChanged,\r\n        uint256 stakeAmount\r\n    );\r\n\r\n    event Claimed(address indexed staker, uint256 reward);\r\n\r\n    // stake token address, ERC20\r\n    address public stakeToken;\r\n\r\n    bool initialized;\r\n\r\n    bool locker;\r\n\r\n    // reward token address, ERC20\r\n    address public rewardToken;\r\n\r\n    // Mining start date(epoch second)\r\n    uint256 public startDateOfMining;\r\n\r\n    // Mining end date(epoch second)\r\n    uint256 public endDateOfMining;\r\n\r\n    // controller address\r\n    address controller;\r\n\r\n    // reward per Second\r\n    uint256 public rewardPerSecond;\r\n\r\n    // timestamp of last updated\r\n    uint256 public lastUpdatedTimestamp;\r\n\r\n    uint256 public rewardPerTokenStored;\r\n\r\n    // staked total\r\n    uint256 private _totalSupply;\r\n\r\n    struct StakerInfo {\r\n        // exclude reward's amount\r\n        uint256 rewardDebt;\r\n        // stake total\r\n        uint256 amount;\r\n        // pending reward\r\n        uint256 reward;\r\n    }\r\n\r\n    // staker's StakerInfo\r\n    mapping(address => StakerInfo) public stakers;\r\n\r\n    /* ========== MODIFIER ========== */\r\n\r\n    modifier stakeable() {\r\n        require(\r\n            block.timestamp <= endDateOfMining,\r\n            \"stake not begin or complete\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier enable() {\r\n        require(initialized, \"initialized = false\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyController {\r\n        require(controller == msg.sender, \"only controller\");\r\n        _;\r\n    }\r\n\r\n    modifier lock() {\r\n        require(locker == false, \"locked\");\r\n        locker = true;\r\n        _;\r\n        locker = false;\r\n    }\r\n\r\n    modifier updateReward(address _staker) {\r\n        rewardPerTokenStored = rewardPerToken();\r\n        lastUpdatedTimestamp = lastTimeRewardApplicable();\r\n        if (_staker != address(0)) {\r\n            stakers[_staker].reward = rewardOf(_staker);\r\n            stakers[_staker].rewardDebt = rewardPerTokenStored;\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor() {}\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n    /**\r\n     * @dev initialize contract\r\n     * @param _stake address of stake token\r\n     * @param _reward address of reward token\r\n     * @param _start epoch seconds of mining starts\r\n     * @param _end epoch seconds of mining complete\r\n     * @param _totalReward totalReward\r\n     */\r\n    function initialize(\r\n        address _stake,\r\n        address _reward,\r\n        uint256 _start,\r\n        uint256 _end,\r\n        uint256 _totalReward\r\n    ) external override {\r\n        require(!initialized, \"initialized = true\");\r\n        // only initialize once\r\n        initialized = true;\r\n        controller = msg.sender;\r\n        stakeToken = _stake;\r\n        rewardToken = _reward;\r\n        startDateOfMining = _start;\r\n        endDateOfMining = _end;\r\n        rewardPerSecond = _totalReward / (_end - _start);\r\n    }\r\n\r\n    /**\r\n     * @dev stake token\r\n     * @param _amount amount of token to be staked\r\n     */\r\n    function stake(uint256 _amount)\r\n        external\r\n        enable()\r\n        lock()\r\n        updateReward(msg.sender)\r\n    {\r\n        require(_amount > 0, \"amount = 0\");\r\n        require(block.timestamp <= endDateOfMining, \"stake complete\");\r\n        _totalSupply += _amount;\r\n        stakers[msg.sender].amount += _amount;\r\n        TransferHelper.safeTransferFrom(\r\n            stakeToken,\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n        emit StakeUpdated(\r\n            msg.sender,\r\n            true,\r\n            _amount,\r\n            stakers[msg.sender].amount\r\n        );\r\n        _notify();\r\n    }\r\n\r\n    /**\r\n     * @dev unstake token\r\n     * @param _amount amount of token to be unstaked\r\n     */\r\n    function unstake(uint256 _amount)\r\n        public\r\n        enable()\r\n        lock()\r\n        updateReward(msg.sender)\r\n    {\r\n        require(_amount > 0, \"amount = 0\");\r\n        require(stakers[msg.sender].amount >= _amount, \"insufficient amount\");\r\n        _claim(msg.sender);\r\n        _totalSupply -= _amount;\r\n        stakers[msg.sender].amount -= _amount;\r\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\r\n        emit StakeUpdated(\r\n            msg.sender,\r\n            false,\r\n            _amount,\r\n            stakers[msg.sender].amount\r\n        );\r\n        _notify();\r\n    }\r\n\r\n    /**\r\n     * @dev claim rewards\r\n     */\r\n    function claim() external enable() lock() updateReward(msg.sender) {\r\n        _claim(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev quit, claim reward + unstake all\r\n     */\r\n    function quit() external enable() lock() updateReward(msg.sender) {\r\n        unstake(stakers[msg.sender].amount);\r\n        _claim(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev claim rewards, only owner allowed\r\n     * @param _staker staker address\r\n     */\r\n    function claim0(address _staker)\r\n        external\r\n        override\r\n        onlyController()\r\n        enable()\r\n        updateReward(msg.sender)\r\n    {\r\n        _claim(_staker);\r\n    }\r\n\r\n    /* ========== VIEWs ========== */\r\n    function lastTimeRewardApplicable() public view returns (uint256) {\r\n        if (block.timestamp < startDateOfMining) return startDateOfMining;\r\n        return\r\n            block.timestamp > endDateOfMining\r\n                ? endDateOfMining\r\n                : block.timestamp;\r\n    }\r\n\r\n    function rewardPerToken() public view returns (uint256) {\r\n        if (_totalSupply == 0 || block.timestamp < startDateOfMining) {\r\n            return 0;\r\n        }\r\n        return\r\n            rewardPerTokenStored +\r\n            (((lastTimeRewardApplicable() - lastUpdatedTimestamp) *\r\n                rewardPerSecond) * 1e18) /\r\n            _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev amount of stake per address\r\n     * @param _staker staker address\r\n     * @return amount of stake\r\n     */\r\n    function stakeOf(address _staker) external view returns (uint256) {\r\n        return stakers[_staker].amount;\r\n    }\r\n\r\n    /**\r\n     * @dev amount of reward per address\r\n     * @param _staker address\r\n     * @return value reward amount of _staker\r\n     */\r\n    function rewardOf(address _staker) public view returns (uint256 value) {\r\n        StakerInfo memory info = stakers[_staker];\r\n        if (info.amount == 0) return 0;\r\n        return\r\n            (info.amount * (rewardPerToken() - info.rewardDebt)) /\r\n            1e18 +\r\n            info.reward;\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n    /**\r\n     * @dev claim reward\r\n     * @param _staker address\r\n     */\r\n    function _claim(address _staker) private {\r\n        uint256 reward = stakers[_staker].reward;\r\n        if (reward > 0) {\r\n            stakers[_staker].reward = 0;\r\n            IConfig config = IConfigable(controller).getConfig();\r\n            uint256 claimFeeRate = config.claimFeeRate();\r\n            uint256 out = (reward * (10000 - claimFeeRate)) / 10000;\r\n            uint256 fee = reward - out;\r\n            TransferHelper.safeTransfer(rewardToken, _staker, out);\r\n\r\n            if (fee > 0) {\r\n                // transfer to feeTo\r\n                TransferHelper.safeTransfer(rewardToken, config.feeTo(), fee);\r\n            }\r\n            emit Claimed(_staker, reward);\r\n            _notify();\r\n        }\r\n    }\r\n\r\n    function _notify() private {\r\n        IConfigable(controller).getConfig().notify(\r\n            IConfig.EventType.STAKE_UPDATED,\r\n            address(this)\r\n        );\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isIncrease\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeChanged\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"StakeUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"claim0\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endDateOfMining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stake\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalReward\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdatedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"rewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"stakeOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDateOfMining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Stake","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9bb982e00a0472cb89fee1ce58280981c334a298b24e1e5ee94806289ed57aec"}]}