{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DynamicFee.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Num.sol\\\";\\nimport \\\"./IDynamicFee.sol\\\";\\n\\ncontract DynamicFee is IDynamicFee, Bronze, Num {\\n\\n    function spow3(int _value)\\n    internal pure\\n    returns(int){\\n        return ((_value * _value) / iBONE) * _value / iBONE;\\n    }\\n\\n    function calcExpStart(\\n        int _inBalance,\\n        int _outBalance\\n    )\\n    internal pure\\n    returns(int) {\\n        return (_inBalance - _outBalance) * iBONE / (_inBalance + _outBalance);\\n    }\\n\\n    function calcSpotFee(\\n        int _expStart,\\n        uint _baseFee,\\n        uint _feeAmp,\\n        uint _maxFee\\n    )\\n    external pure override\\n    returns(uint) {\\n        if(_expStart >= 0) {\\n            return min(_baseFee + _feeAmp * uint(_expStart * _expStart) / BONE, _maxFee);\\n        } else {\\n            return _baseFee / 2;\\n        }\\n    }\\n\\n    function calc(\\n        int[3] memory _inRecord,\\n        int[3] memory _outRecord,\\n        int _baseFee,\\n        int _feeAmp,\\n        int _maxFee\\n    )\\n    external pure override\\n    returns(int fee, int expStart)\\n    {\\n\\n        expStart = calcExpStart(_inRecord[0], _outRecord[0]);\\n        int _expEnd = (_inRecord[0] - _outRecord[0] + _inRecord[2] + _outRecord[2]) * iBONE /\\n            (_inRecord[0] + _outRecord[0] + _inRecord[2] - _outRecord[2]);\\n\\n        if(expStart >= 0) {\\n            fee = _baseFee + ((_feeAmp) * (spow3(_expEnd) - spow3(expStart))) * iBONE / (3 * (_expEnd - expStart));\\n        } else if(_expEnd <= 0) {\\n            fee = _baseFee / 2;\\n        } else {\\n            fee = calcExpEndFee(\\n                _inRecord,\\n                _outRecord,\\n                _baseFee,\\n                _feeAmp,\\n                _expEnd\\n            );\\n        }\\n\\n        if(_maxFee <  fee) {\\n            fee = _maxFee;\\n        }\\n\\n        if(iBONE / 1000 >  fee) {\\n            fee = iBONE / 1000;\\n        }\\n    }\\n\\n    function calcExpEndFee(\\n        int[3] memory _inRecord,\\n        int[3] memory _outRecord,\\n        int _baseFee,\\n        int _feeAmp,\\n        int _expEnd\\n    )\\n        internal\\n        pure\\n        returns (int)\\n    {\\n        int inBalanceLeveraged = getLeveragedBalance(_inRecord[0], _inRecord[1]);\\n        int tokenAmountIn1 = inBalanceLeveraged * (_outRecord[0] - _inRecord[0]) * iBONE /\\n        (inBalanceLeveraged + getLeveragedBalance(_outRecord[0], _outRecord[1])) / iBONE;\\n        int inBalanceLeveragedChanged = inBalanceLeveraged + _inRecord[2] * iBONE;\\n        int tokenAmountIn2 = inBalanceLeveragedChanged * (_inRecord[0] - _outRecord[0] + _inRecord[2] + _outRecord[2]) * iBONE /\\n        (inBalanceLeveragedChanged + ((getLeveragedBalance(_outRecord[0], _outRecord[1]) - _outRecord[2] * iBONE))) / iBONE;\\n\\n        int fee = tokenAmountIn1 * _baseFee / (iBONE * 2);\\n        fee = fee + tokenAmountIn2 * (_baseFee + _feeAmp * (_expEnd * _expEnd / iBONE) / 3) / iBONE;\\n        return fee * iBONE / (tokenAmountIn1 + tokenAmountIn2);\\n    }\\n\\n    function getLeveragedBalance(\\n        int _balance,\\n        int _leverage\\n    )\\n    internal pure\\n    returns(int)\\n    {\\n        return _balance * _leverage;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Num.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Const.sol\\\";\\n\\ncontract Num is Const {\\n\\n    function toi(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function floor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return toi(a) * BONE;\\n    }\\n\\n    function add(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n    }\\n\\n    function sub(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        bool flag;\\n        (c, flag) = subSign(a, b);\\n        require(!flag, \\\"SUB_UNDERFLOW\\\");\\n    }\\n\\n    function subSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function mul(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"MUL_OVERFLOW\\\");\\n        c = c1 / BONE;\\n    }\\n\\n    function div(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        require(b != 0, \\\"DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"DIV_INTERNAL\\\"); // mul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"DIV_INTERNAL\\\"); //  add require\\n        c = c1 / b;\\n    }\\n\\n    // DSMath.wpow\\n    function powi(uint a, uint n)\\n        internal pure\\n        returns (uint z)\\n    {\\n        z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = mul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = mul(z, a);\\n            }\\n        }\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `powi` for `b^e` and `powK` for k iterations\\n    // of approximation of b^0.w\\n    function pow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_POW_BASE, \\\"POW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_POW_BASE, \\\"POW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = floor(exp);\\n        uint remain = sub(exp, whole);\\n\\n        uint wholePow = powi(base, toi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = powApprox(base, remain, POW_PRECISION);\\n        return mul(wholePow, partialResult);\\n    }\\n\\n    function powApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint sum)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = subSign(base, BONE);\\n        uint term = BONE;\\n        sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom\\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = subSign(a, sub(bigK, BONE));\\n            term = mul(term, mul(c, x));\\n            term = div(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = sub(sum, term);\\n            } else {\\n                sum = add(sum, term);\\n            }\\n        }\\n    }\\n\\n    function min(uint first, uint second)\\n        internal pure\\n        returns (uint)\\n    {\\n        if(first < second) {\\n            return first;\\n        }\\n        return second;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IDynamicFee.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface IDynamicFee {\\n\\n    function calc(\\n        int[3] memory _inRecord,\\n        int[3] memory _outRecord,\\n        int _baseFee,\\n        int _feeAmp,\\n        int _maxFee\\n    )\\n    external\\n    returns(int fee, int expStart);\\n\\n    function calcSpotFee(\\n        int _expStart,\\n        uint _baseFee,\\n        uint _feeAmp,\\n        uint _maxFee\\n    )\\n    external\\n    returns(uint);\\n}\\n\\n\\n\"\r\n    },\r\n    \"contracts/Const.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Color.sol\\\";\\n\\ncontract Const is Bronze {\\n    uint public constant BONE              = 10**18;\\n    int public constant  iBONE             = int(BONE);\\n\\n    uint public constant MIN_POW_BASE      = 1 wei;\\n    uint public constant MAX_POW_BASE      = (2 * BONE) - 1 wei;\\n    uint public constant POW_PRECISION     = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"contracts/Color.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nabstract contract Color {\\n    function getColor()\\n        external view virtual\\n        returns (bytes32);\\n}\\n\\ncontract Bronze is Color {\\n    function getColor()\\n        external view override\\n        returns (bytes32) {\\n            return bytes32(\\\"BRONZE\\\");\\n        }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_POW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_POW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256[3]\",\"name\":\"_inRecord\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"_outRecord\",\"type\":\"int256[3]\"},{\"internalType\":\"int256\",\"name\":\"_baseFee\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_feeAmp\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_maxFee\",\"type\":\"int256\"}],\"name\":\"calc\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"fee\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"expStart\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_expStart\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_baseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getColor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iBONE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DynamicFee","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}