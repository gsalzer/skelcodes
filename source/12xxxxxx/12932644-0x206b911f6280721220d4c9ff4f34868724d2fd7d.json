{"status":"1","message":"OK","result":[{"SourceCode":"{\"hiDollar.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.4.26;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable \\n{\\n  address public owner;\\n  address private proposedOwner;\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n  \\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner, \\\"lack permission\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev propose a new owner by an existing owner\\n   * @param _newOwner The address proposed to transfer ownership to.\\n   */\\n  function proposeOwner(address _newOwner) public onlyOwner {\\n    proposedOwner = _newOwner;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   */\\n  function takeOwnership() public {\\n    require(proposedOwner == msg.sender, \\\"not the proposed owner\\\");\\n    _transferOwnership(proposedOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address _newOwner) internal {\\n    require(_newOwner != address(0), \\\"zero address not allowed\\\");\\n    emit OwnershipTransferred(owner, _newOwner);\\n    owner = _newOwner;\\n  }\\n  \\n}\\n\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n */\\ncontract Pausable is Ownable \\n{\\n  event Pause();\\n  event Unpause();\\n\\n  bool public paused; //default as false\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused, \\\"already paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused, \\\"not paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() onlyOwner whenNotPaused public {\\n    paused = true;\\n    emit Pause();\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpauseunpause, returns to normal state\\n   */\\n  function unpause() onlyOwner whenPaused public {\\n    paused = false;\\n    emit Unpause();\\n  }\\n\\n}\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/179\\n */\\ncontract ERC20Basic \\n{\\n  function balanceOf(address who) public view returns (uint256);\\n  function transfer(address to, uint256 value) public returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 is ERC20Basic \\n{\\n  function allowance(address owner, address spender) public view returns (uint256);\\n\\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\\n\\n  function approve(address spender, uint256 value) public returns (bool);\\n  \\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic \\n{\\n  using SafeMath for uint256;\\n\\n  mapping(address =\\u003e uint256) balances;\\n\\n  uint256 public totalSupply;\\n\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint256 _value) public returns (bool) {\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    emit Transfer(msg.sender, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view returns (uint256) {\\n    return balances[_owner];\\n  }\\n\\n}\\n\\n\\n/**\\n * @title Standard ERC20 token\\n * @dev Implementation of the basic standard token.\\n * @dev https://github.com/ethereum/EIPs/issues/20\\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n */\\ncontract StandardToken is ERC20, BasicToken \\n{\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint256 the amount of tokens to be transferred\\n   */\\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\n    require(_to != address(0));\\n    require(_value \\u003c= balances[_from]);\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n    balances[_from] = balances[_from].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n    emit Transfer(_from, _to, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n   *\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n   * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint256 _value) public returns (bool) {\\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return A uint256 specifying the amount of tokens still available for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view returns (uint256) {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  /**\\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\\n   *\\n   * approve should be called when allowed[_spender] == 0. To increment\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param _spender The address which will spend the funds.\\n   * @param _addedValue The amount of tokens to increase the allowance by.\\n   */\\n  function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\\n    allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n   *\\n   * approve should be called when allowed[_spender] == 0. To decrement\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\n   * the first transaction is mined)\\n   * From MonolithDAO Token.sol\\n   * @param _spender The address which will spend the funds.\\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\\n   */\\n  function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\\n    uint256 oldValue = allowed[msg.sender][_spender];\\n    if (_subtractedValue \\u003e oldValue) {\\n      allowed[msg.sender][_spender] = 0;\\n    } else {\\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n    }\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n  \\n}\\n\\n\\n/**\\n * @title Pausable token\\n * @dev StandardToken modified with pausable transfers.\\n **/\\ncontract PausableToken is StandardToken, Pausable \\n{\\n\\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\\n    return super.transfer(_to, _value);\\n  }\\n\\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\\n    return super.transferFrom(_from, _to, _value);\\n  }\\n\\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\\n    return super.approve(_spender, _value);\\n  }\\n\\n  function increaseApproval(address _spender, uint256 _addedValue) public whenNotPaused returns (bool success) {\\n    return super.increaseApproval(_spender, _addedValue);\\n  }\\n\\n  function decreaseApproval(address _spender, uint256 _subtractedValue) public whenNotPaused returns (bool success) {\\n    return super.decreaseApproval(_spender, _subtractedValue);\\n  }\\n\\n}\\n\\n\\n/**\\n * @title Frozenable Token\\n * @dev Illegal address that can be frozened.\\n */\\ncontract FrozenableToken is Ownable \\n{\\n    mapping (address =\\u003e bool) public Approvers; \\n\\n    mapping (address =\\u003e bool) public frozenAccount;\\n\\n    event FrozenFunds(address indexed to, bool frozen);\\n\\n    modifier whenNotFrozen(address _who) {\\n      require(!frozenAccount[msg.sender] \\u0026\\u0026 !frozenAccount[_who], \\\"account frozen\\\");\\n      _;\\n    }\\n\\n    function setApprover(address _wallet, bool _approve) public onlyOwner {\\n        Approvers[_wallet] = _approve;\\n\\n        if (!_approve)\\n          delete Approvers[_wallet];\\n    }\\n\\n    function freezeAccount(address _to, bool _freeze) public {\\n        require(Approvers[msg.sender], \\\"lack approvers permission\\\");\\n        require(_to != address(0), \\\"not to self\\\");\\n\\n        frozenAccount[_to] = _freeze;\\n        emit FrozenFunds(_to, _freeze);\\n    }\\n\\n}\\n\\n\\n/**\\n*------------------Mintable token----------------------------\\n*/\\ncontract MintableToken is StandardToken, Ownable {\\n    \\n      event Mint(address indexed to, uint256 amount);\\n\\n      /**\\n      * @dev Mint method\\n      * @param _to newly minted tokens will be sent to this address \\n      * @param _amount amount to mint\\n      * @return A boolean that indicates if the operation was successful.\\n      */\\n      function _mint(address _to, uint256 _amount) internal returns (bool) {\\n        totalSupply = totalSupply.add(_amount);\\n        balances[_to] = balances[_to].add(_amount);\\n\\n        emit Mint(_to, _amount);\\n        emit Transfer(address(0), _to, _amount);\\n\\n        return true;\\n      }\\n}\\n\\n\\n\\n/**\\n * @title hiDollar\\n * @author hi.com\\n */\\ncontract hiDollar is PausableToken, FrozenableToken, MintableToken\\n{\\n    using SafeMath for uint256;\\n\\n    string public constant name = \\\"hi Dollar\\\";\\n    string public constant symbol = \\\"HI\\\";\\n    uint256 public constant decimals = 18;\\n    uint public constant totalHolders = 6; // total number is fixed, wont change in future\\n                                  // but holders address can be updated thru setMintSplitHolder method\\n\\n    // uint256 INITIAL_SUPPLY = 10 *(10 ** 5) * (10 ** uint256(decimals));\\n    uint256 private INITIAL_SUPPLY = 0;\\n\\n    mapping (uint =\\u003e address) public holders;\\n    mapping (uint =\\u003e uint256) public MintSplitHolderRatios; //index -\\u003e ratio boosted by 10000\\n    mapping (address =\\u003e bool) public Proposers; \\n    mapping (address =\\u003e uint256) public Proposals; //address -\\u003e mintAmount\\n\\n    /**\\n     * @dev Initializes the total release\\n     */\\n    constructor() public {\\n        holders[0] = 0xb660539dd01A78ACB3c7CF77BfcCE735081ec004; //HI_LID\\n        holders[1] = 0x8376EEF57D86A8c1DFEE8E91E75912e361A940e0; //HI_EG\\n        holders[2] = 0x572aB5eC71354Eb80e6D18e394b3e71BA8e282F5; //HI_NLTI\\n        holders[3] = 0x93aeC0ADc392C09666B4d56654F39a375AEbD4C1; //HI_CR\\n        holders[4] = 0xFb3BEb5B1258e438982956c9f023d4F7bD683E4E; //HI_FR\\n        holders[5] = 0xBF990D24F7167b97b836457d380ACCdCb1782201; //HI_FT\\n\\n        MintSplitHolderRatios[0] = 2720; //27.2%\\n        MintSplitHolderRatios[1] = 1820; //18.2%\\n        MintSplitHolderRatios[2] = 1820; //18.2%\\n        MintSplitHolderRatios[3] = 1360; //13.6%\\n        MintSplitHolderRatios[4] = 1360; //13.6%\\n        MintSplitHolderRatios[5] = 920;  //9.2%, remaining\\n        \\n        totalSupply = INITIAL_SUPPLY;\\n        balances[msg.sender] = totalSupply;\\n        emit Transfer(address(0), msg.sender, totalSupply);\\n    }\\n \\n    /**\\n     * @dev transfer token for a specified address\\n     * @param _to The address to transfer to.\\n     * @param _value The amount to be transferred.\\n     */\\n    function transfer(address _to, uint256 _value) public whenNotFrozen(_to) returns (bool) {\\n        return super.transfer(_to, _value);\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another\\n     * @param _from address The address which you want to send tokens from\\n     * @param _to address The address which you want to transfer to\\n     * @param _value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotFrozen(_from) returns (bool) {\\n        return super.transferFrom(_from, _to, _value);\\n    }        \\n    \\n   \\n    function setProposer(address _wallet, bool _on) public onlyOwner {\\n        Proposers[_wallet] = _on;\\n\\n        if (!_on)\\n          delete Proposers[_wallet];\\n    }\\n\\n    /**\\n     *  to update an split holder ratio at the index\\n     *  index ranges from 0..totalHolders -1\\n     */\\n    function setMintSplitHolder(uint256 index, address _wallet, uint256 _ratio) public onlyOwner returns (bool) {\\n        if (index \\u003e totalHolders - 1)\\n          return false;\\n\\n        holders[ index ] = _wallet;\\n        MintSplitHolderRatios[ index ] = _ratio;\\n\\n        return true;\\n    }\\n\\n    /**\\n    * @dev propose to mint\\n    * @param _amount amount to mint\\n    * @return mint propose ID\\n    */\\n    function proposeMint(uint256 _amount) public returns(bool) {\\n        require(Proposers[msg.sender], \\\"Non-proposer not allowed\\\");\\n\\n        Proposals[msg.sender] = _amount; //mint once for a propoer at a time otherwise would be overwritten\\n        return true;\\n    }\\n\\n    function approveMint(address _proposer, uint256 _amount, bool _approve) public returns(bool) {\\n      require( Approvers[msg.sender], \\\"None-approver not allowed\\\" );\\n\\n      if (!_approve) {\\n          delete Proposals[_proposer];\\n          return true;\\n      }\\n\\n      require( _amount \\u003e 0, \\\"zero amount not allowed\\\" );\\n      require( Proposals[_proposer] \\u003e= _amount, \\\"Over-approve mint amount not allowed\\\" );\\n\\n      uint256 remaining = _amount;\\n      address _to;\\n      for (uint256 i = 0; i \\u003c totalHolders - 1; i++) {\\n        _to = holders[i];\\n        uint256 _amt = _amount.mul(MintSplitHolderRatios[i]).div(10000);\\n        remaining = remaining.sub(_amt);\\n\\n        _mint(_to, _amt);\\n      }\\n\\n      _to = holders[totalHolders - 1];\\n      _mint(_to, remaining); //for the last holder in the list\\n\\n      Proposals[_proposer] -= _amount;\\n      if (Proposals[_proposer] == 0)\\n        delete Proposals[_proposer];\\n\\n      return true;\\n\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.4.26;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath \\n{\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (_a == 0) {\\n      return 0;\\n    }\\n\\n    c = _a * _b;\\n    require(c / _a == _b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    // assert(_b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = _a / _b;\\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\\u0027t hold\\n    return _a / _b;\\n  }\\n\\n  /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n   * @dev Adds two numbers, throws on overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    require(c \\u003e= a);\\n    return c;\\n  }\\n  \\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Proposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Approvers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"setMintSplitHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposer\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_approve\",\"type\":\"bool\"}],\"name\":\"approveMint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MintSplitHolderRatios\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Proposers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"proposeMint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_approve\",\"type\":\"bool\"}],\"name\":\"setApprover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_on\",\"type\":\"bool\"}],\"name\":\"setProposer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"hiDollar","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://97a604f2c29c944963ae087c8c82ac4d510e9cd4bb62a310f57c06c5a5af7b9e"}]}