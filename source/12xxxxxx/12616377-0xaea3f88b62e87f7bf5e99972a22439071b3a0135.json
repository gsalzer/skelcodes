{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\npragma solidity 0.7.4;\r\n\r\ninterface IERC1155 {\r\n\r\n  /****************************************|\r\n  |                 Events                 |\r\n  |_______________________________________*/\r\n\r\n  /**\r\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\r\n   *   Operator MUST be msg.sender\r\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\r\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\r\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\r\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\r\n   */\r\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\r\n\r\n  /**\r\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\r\n   *   Operator MUST be msg.sender\r\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\r\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\r\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\r\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\r\n   */\r\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\r\n\r\n  /**\r\n   * @dev MUST emit when an approval is updated\r\n   */\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n\r\n  /****************************************|\r\n  |                Functions               |\r\n  |_______________________________________*/\r\n\r\n  /**\r\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\r\n    * @dev MUST emit TransferSingle event on success\r\n    * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\r\n    * MUST throw if `_to` is the zero address\r\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\r\n    * MUST throw on any other error\r\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n    * @param _from    Source address\r\n    * @param _to      Target address\r\n    * @param _id      ID of the token type\r\n    * @param _amount  Transfered amount\r\n    * @param _data    Additional data with no specified format, sent in call to `_to`\r\n    */\r\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\r\n\r\n  /**\r\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\r\n    * @dev MUST emit TransferBatch event on success\r\n    * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\r\n    * MUST throw if `_to` is the zero address\r\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\r\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\r\n    * MUST throw on any other error\r\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\r\n    * @param _from     Source addresses\r\n    * @param _to       Target addresses\r\n    * @param _ids      IDs of each token type\r\n    * @param _amounts  Transfer amounts per token type\r\n    * @param _data     Additional data with no specified format, sent in call to `_to`\r\n  */\r\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\r\n\r\n  /**\r\n   * @notice Get the balance of an account's Tokens\r\n   * @param _owner  The address of the token holder\r\n   * @param _id     ID of the Token\r\n   * @return        The _owner's balance of the Token type requested\r\n   */\r\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the balance of multiple account/token pairs\r\n   * @param _owners The addresses of the token holders\r\n   * @param _ids    ID of the Tokens\r\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\r\n   */\r\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\r\n\r\n  /**\r\n   * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller's tokens\r\n   * @dev MUST emit the ApprovalForAll event on success\r\n   * @param _operator  Address to add to the set of authorized operators\r\n   * @param _approved  True if the operator is approved, false to revoke approval\r\n   */\r\n  function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n  /**\r\n   * @notice Queries the approval status of an operator for a given owner\r\n   * @param _owner     The owner of the Tokens\r\n   * @param _operator  Address of authorized operator\r\n   * @return isOperator True if the operator is approved, false if not\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\r\n}\r\n\r\npragma solidity 0.7.4;\r\n\r\ncontract PortionExchangeV2 {\r\n\tstruct ERC1155Offer {\r\n\t\tuint tokenId;\r\n\t\tuint quantity;\r\n\t\tuint price;\r\n\t\taddress seller;\r\n\t}\r\n\r\n\tevent TokenPriceListed (uint indexed _tokenId, address indexed _owner, uint _price);\r\n\tevent TokenPriceDeleted (uint indexed _tokenId);\r\n\tevent TokenSold (uint indexed _tokenId, uint _price, bool _soldForPRT);\r\n\tevent TokenOwned (uint indexed _tokenId, address indexed _previousOwner, address indexed _newOwner);\r\n\tevent Token1155OfferListed (uint indexed _tokenId, uint indexed _offerId, address indexed _owner, uint _quantity, uint _price);\r\n\tevent Token1155OfferDeleted (uint indexed _tokenId, uint indexed _offerId);\r\n\tevent Token1155Sold(uint indexed _tokenId, uint indexed _offerId, uint _quantity, uint _price, bool _soldForPRT);\r\n\tevent Token1155Owned (uint indexed _tokenId, address indexed _previousOwner, address indexed _newOwner, uint _quantity);\r\n\r\n\taddress public signerAddress;\r\n\taddress owner;\r\n\r\n\tbytes32 public name = \"PortionExchangeV2\";\r\n\r\n\tuint public offerIdCounter;\r\n\tuint public safeVolatilityPeriod;\r\n\r\n\tIERC20 public portionTokenContract;\r\n\tIERC721 public artTokenContract;\r\n\tIERC1155 public artToken1155Contract;\r\n\r\n\tmapping(address => uint) public nonces;\r\n\tmapping(uint => uint) public ERC721Prices;\r\n\tmapping(uint => ERC1155Offer) public ERC1155Offers;\r\n\tmapping(address => mapping(uint => uint)) public tokensListed;\r\n\r\n\tconstructor (\r\n\t\taddress _signerAddress,\r\n\t\taddress _artTokenAddress,\r\n\t\taddress _artToken1155Address,\r\n\t\taddress _portionTokenAddress\r\n\t)\r\n\t{\r\n\t\trequire (_signerAddress != address(0));\r\n\t\trequire (_artTokenAddress != address(0));\r\n\t\trequire (_artToken1155Address != address(0));\r\n\t\trequire (_portionTokenAddress != address(0));\r\n\r\n\t\towner = msg.sender;\r\n\t\tsignerAddress = _signerAddress;\r\n\t\tartTokenContract = IERC721(_artTokenAddress);\r\n\t\tartToken1155Contract = IERC1155(_artToken1155Address);\r\n\t\tportionTokenContract = IERC20(_portionTokenAddress);\r\n\r\n\t\tsafeVolatilityPeriod = 4 hours;\r\n\t}\r\n\r\n\tfunction listToken(\r\n\t\tuint _tokenId,\r\n\t\tuint _price\r\n\t)\r\n\texternal\r\n\t{\r\n\t\trequire(_price > 0);\r\n\t\trequire(artTokenContract.ownerOf(_tokenId) == msg.sender);\r\n\t\trequire(ERC721Prices[_tokenId] == 0);\r\n\t\tERC721Prices[_tokenId] = _price;\r\n\t\temit TokenPriceListed(_tokenId, msg.sender, _price);\r\n\t}\r\n\r\n\tfunction listToken1155(\r\n\t\tuint _tokenId,\r\n\t\tuint _quantity,\r\n\t\tuint _price\r\n\t)\r\n\texternal\r\n\t{\r\n\t\trequire(_price > 0);\r\n\t\trequire(artToken1155Contract.balanceOf(msg.sender, _tokenId) >= tokensListed[msg.sender][_tokenId] + _quantity);\r\n\r\n\t\tuint offerId = offerIdCounter++;\r\n\t\tERC1155Offers[offerId] = ERC1155Offer({\r\n\t\t\ttokenId: _tokenId,\r\n\t\t\tquantity: _quantity,\r\n\t\t\tprice: _price,\r\n\t\t\tseller: msg.sender\r\n\t\t});\r\n\r\n\t\ttokensListed[msg.sender][_tokenId] += _quantity;\r\n\t\temit Token1155OfferListed(_tokenId, offerId, msg.sender, _quantity, _price);\r\n\t}\r\n\r\n\tfunction removeListToken(\r\n\t\tuint _tokenId\r\n\t)\r\n\texternal\r\n\t{\r\n\t\trequire(artTokenContract.ownerOf(_tokenId) == msg.sender);\r\n\t\tdeleteTokenPrice(_tokenId);\r\n\t}\r\n\r\n\tfunction removeListToken1155(\r\n\t\tuint _offerId\r\n\t)\r\n\texternal\r\n\t{\r\n\t\trequire(ERC1155Offers[_offerId].seller == msg.sender);\r\n\t\tdeleteToken1155Offer(_offerId);\r\n\t}\r\n\r\n\tfunction deleteTokenPrice(\r\n\t\tuint _tokenId\r\n\t)\r\n\tinternal\r\n\t{\r\n\t\tdelete ERC721Prices[_tokenId];\r\n\t\temit TokenPriceDeleted(_tokenId);\r\n\t}\r\n\r\n\tfunction deleteToken1155Offer(\r\n\t\tuint _offerId\r\n\t)\r\n\tinternal\r\n\t{\r\n\t\tERC1155Offer memory offer = ERC1155Offers[_offerId];\r\n\t\ttokensListed[offer.seller][offer.tokenId] -= offer.quantity;\r\n\r\n\t\tdelete ERC1155Offers[_offerId];\r\n\t\temit Token1155OfferDeleted(offer.tokenId, _offerId);\r\n\t}\r\n\r\n\tfunction buyToken(\r\n\t\tuint _tokenId\r\n\t)\r\n\texternal\r\n\tpayable\r\n\t{\r\n\t\trequire(ERC721Prices[_tokenId] > 0, \"token is not for sale\");\r\n\t\trequire(ERC721Prices[_tokenId] <= msg.value);\r\n\r\n\t\taddress tokenOwner = artTokenContract.ownerOf(_tokenId);\r\n\r\n\t\taddress payable payableTokenOwner = payable(tokenOwner);\r\n\t\t(bool sent, ) = payableTokenOwner.call{value: msg.value}(\"\");\r\n\t\trequire(sent);\r\n\r\n\t\tartTokenContract.safeTransferFrom(tokenOwner, msg.sender, _tokenId);\r\n\r\n\t\temit TokenSold(_tokenId, msg.value, false);\r\n\t\temit TokenOwned(_tokenId, tokenOwner, msg.sender);\r\n\r\n\t\tdeleteTokenPrice(_tokenId);\r\n\t}\r\n\r\n\tfunction buyToken1155(\r\n\t\tuint _offerId,\r\n\t\tuint _quantity\r\n\t)\r\n\texternal\r\n\tpayable\r\n\t{\r\n\t\tERC1155Offer memory offer = ERC1155Offers[_offerId];\r\n\r\n\t\trequire(offer.price > 0, \"offer does not exist\");\r\n\t\trequire(offer.quantity >= _quantity);\r\n\t\trequire(offer.price * _quantity <= msg.value);\r\n\r\n\t\taddress payable payableSeller = payable(offer.seller);\r\n\t\t(bool sent, ) = payableSeller.call{value: msg.value}(\"\");\r\n\t\trequire(sent);\r\n\r\n\t\tartToken1155Contract.safeTransferFrom(offer.seller, msg.sender, offer.tokenId, _quantity, \"\");\r\n\r\n\t\temit Token1155Sold(offer.tokenId, _offerId, _quantity, offer.price, false);\r\n\t\temit Token1155Owned(offer.tokenId, offer.seller, msg.sender, _quantity);\r\n\r\n\t\tif (offer.quantity == _quantity) {\r\n\t\t\tdeleteToken1155Offer(_offerId);\r\n\t\t} else {\r\n\t\t\tERC1155Offers[_offerId].quantity -= _quantity;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buyTokenForPRT(\r\n\t\tuint _tokenId,\r\n\t\tuint _priceInPRT,\r\n\t\tuint _nonce,\r\n\t\tbytes calldata _signature,\r\n\t\tuint _timestamp\r\n\t)\r\n\texternal\r\n\t{\r\n\t\tbytes32 hash = keccak256(abi.encodePacked(_tokenId, _priceInPRT, _nonce, _timestamp));\r\n\t\tbytes32 ethSignedMessageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\t\trequire(recoverSignerAddress(ethSignedMessageHash, _signature) == signerAddress, \"invalid secret signer\");\r\n\r\n\t\trequire(nonces[msg.sender] < _nonce, \"invalid nonce\");\r\n\t\tif (safeVolatilityPeriod > 0) {\r\n\t\t\trequire(_timestamp + safeVolatilityPeriod >= block.timestamp, \"safe volatility period exceeded\");\r\n\t\t}\r\n\t\trequire(ERC721Prices[_tokenId] > 0, \"token is not for sale\");\r\n\r\n\t\tnonces[msg.sender] = _nonce;\r\n\r\n\t\taddress tokenOwner = artTokenContract.ownerOf(_tokenId);\r\n\r\n\t\tbool sent = portionTokenContract.transferFrom(msg.sender, tokenOwner, _priceInPRT);\r\n\t\trequire(sent);\r\n\r\n\t\tartTokenContract.safeTransferFrom(tokenOwner, msg.sender, _tokenId);\r\n\r\n\t\temit TokenSold(_tokenId, _priceInPRT, true);\r\n\t\temit TokenOwned(_tokenId, tokenOwner, msg.sender);\r\n\r\n\t\tdeleteTokenPrice(_tokenId);\r\n\t}\r\n\r\n\tfunction buyToken1155ForPRT(\r\n\t\tuint _offerId,\r\n\t\tuint _quantity,\r\n\t\tuint _priceInPRT,\r\n\t\tuint _nonce,\r\n\t\tbytes calldata _signature,\r\n\t\tuint _timestamp\r\n\t)\r\n\texternal\r\n\t{\r\n\t\tbytes32 hash = keccak256(abi.encodePacked(_offerId, _quantity, _priceInPRT, _nonce, _timestamp));\r\n\t\tbytes32 ethSignedMessageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\t\trequire(recoverSignerAddress(ethSignedMessageHash, _signature) == signerAddress, \"invalid secret signer\");\r\n\r\n\t\tERC1155Offer memory offer = ERC1155Offers[_offerId];\r\n\r\n\t\trequire(nonces[msg.sender] < _nonce, \"invalid nonce\");\r\n\t\tif (safeVolatilityPeriod > 0) {\r\n\t\t\trequire(_timestamp + safeVolatilityPeriod >= block.timestamp, \"safe volatility period exceeded\");\r\n\t\t}\r\n\t\trequire(offer.price > 0, \"offer does not exist\");\r\n\t\trequire(offer.quantity >= _quantity);\r\n\r\n\t\tnonces[msg.sender] = _nonce;\r\n\r\n\t\tportionTokenContract.transferFrom(msg.sender, offer.seller, _priceInPRT * _quantity);\r\n\t\tartToken1155Contract.safeTransferFrom(offer.seller, msg.sender, offer.tokenId, _quantity, \"\");\r\n\r\n\t\temit Token1155Sold(offer.tokenId, _offerId, _quantity, _priceInPRT, true);\r\n\t\temit Token1155Owned(offer.tokenId, offer.seller, msg.sender, _quantity);\r\n\r\n\t\tif (offer.quantity == _quantity) {\r\n\t\t\tdeleteToken1155Offer(_offerId);\r\n\t\t} else {\r\n\t\t\tERC1155Offers[_offerId].quantity -= _quantity;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setSigner(\r\n\t\taddress _newSignerAddress\r\n\t)\r\n\texternal\r\n\t{\r\n\t\trequire(msg.sender == owner);\r\n\t\tsignerAddress = _newSignerAddress;\r\n\t}\r\n\r\n\tfunction setSafeVolatilityPeriod(\r\n\t\tuint _newSafeVolatilityPeriod\r\n\t)\r\n\texternal\r\n\t{\r\n\t\trequire(msg.sender == owner);\r\n\t\tsafeVolatilityPeriod = _newSafeVolatilityPeriod;\r\n\t}\r\n\r\n\tfunction recoverSignerAddress(\r\n\t\tbytes32 _hash,\r\n\t\tbytes memory _signature\r\n\t)\r\n\tinternal\r\n\tpure\r\n\treturns (address)\r\n\t{\r\n\t\trequire(_signature.length == 65, \"invalid signature length\");\r\n\r\n\t\tbytes32 r;\r\n\t\tbytes32 s;\r\n\t\tuint8 v;\r\n\r\n\t\tassembly {\r\n\t\t\tr := mload(add(_signature, 32))\r\n\t\t\ts := mload(add(_signature, 64))\r\n\t\t\tv := and(mload(add(_signature, 65)), 255)\r\n\t\t}\r\n\r\n\t\tif (v < 27) {\r\n\t\t\tv += 27;\r\n\t\t}\r\n\r\n\t\tif (v != 27 && v != 28) {\r\n\t\t\treturn address(0);\r\n\t\t}\r\n\r\n\t\treturn ecrecover(_hash, v, r, s);\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_artTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_artToken1155Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_portionTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"Token1155OfferDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Token1155OfferListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"Token1155Owned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_soldForPRT\",\"type\":\"bool\"}],\"name\":\"Token1155Sold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"TokenOwned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenPriceDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"TokenPriceListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_soldForPRT\",\"type\":\"bool\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ERC1155Offers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ERC721Prices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artToken1155Contract\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artTokenContract\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"buyToken1155\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceInPRT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"buyToken1155ForPRT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceInPRT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"buyTokenForPRT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"listToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"listToken1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offerIdCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"portionTokenContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"removeListToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"removeListToken1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeVolatilityPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSafeVolatilityPeriod\",\"type\":\"uint256\"}],\"name\":\"setSafeVolatilityPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSignerAddress\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensListed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PortionExchangeV2","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000025410b89c8061e0208f1af11c9273a61e4206153000000000000000000000000da98f59e1edecb2545d7b07b794e704ed6cf1f7a0000000000000000000000000adf0bc748296bcba9f394d783a5f5e9406d68740000000000000000000000006d0f5149c502faf215c89ab306ec3e50b15e2892","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b19770a6c021c4b085ed02ee5bfdddc39ea123d60fb4f6dec4e28e9a8d5b64e3"}]}