{"status":"1","message":"OK","result":[{"SourceCode":"{\"GameInterface.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ninterface GameInterface {\\n    function maxBet(uint _num, uint _bankRoll) external view returns(uint);\\n\\n    function resultNumber(bytes32 _serverSeed, bytes32 _userSeed, uint _num) external view returns(uint);\\n\\n    function userProfit(uint _num, uint _betValue, uint _resultNum) external view returns(int);\\n\\n    function maxUserProfit(uint _num, uint _betValue) external view returns(int);\\n}\\n\"},\"Plinko.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./GameInterface.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\nimport \\\"../SafeMath.sol\\\";\\nimport \\\"../SafeCast.sol\\\";\\n\\n\\ncontract Plinko is GameInterface, Utilities {\\n    using SafeCast for uint;\\n    using SafeMath for uint;\\n\\n    uint public constant MAX_BET_DIVIDER = 10000;\\n\\n    uint public constant PAYOUT_DIVIDER = 10;\\n\\n    mapping (uint =\\u003e mapping(uint =\\u003e uint16)) public MAX_BET;\\n\\n    mapping (uint =\\u003e mapping(uint =\\u003e uint16[])) public PAYOUT;\\n\\n    constructor() public {\\n        MAX_BET[1][8] = 264;\\n        MAX_BET[1][12] = 607;\\n        MAX_BET[1][16] = 758;\\n        MAX_BET[2][8] = 55;\\n        MAX_BET[2][12] = 175;\\n        MAX_BET[2][16] = 208;\\n        MAX_BET[3][8] = 24;\\n        MAX_BET[3][12] = 77;\\n        MAX_BET[3][16] = 68;\\n\\n        PAYOUT[1][8] = [4, 9, 14, 19, 73];\\n        PAYOUT[1][12] = [4, 10, 11, 15, 18, 31, 100];\\n        PAYOUT[1][16] = [4, 10, 11, 12, 16, 17, 18, 75, 130];\\n        PAYOUT[2][8] = [3, 5, 15, 37, 160];\\n        PAYOUT[2][12] = [3, 6, 14, 20, 30, 42, 220];\\n        PAYOUT[2][16] = [2, 5, 14, 17, 19, 40, 63, 96, 250];\\n        PAYOUT[3][8] = [1, 3, 10, 71, 210];\\n        PAYOUT[3][12] = [1, 4, 11, 31, 46, 81, 270];\\n        PAYOUT[3][16] = [1, 3, 11, 20, 32, 56, 100, 260, 800];\\n    }\\n\\n    modifier onlyValidNum(uint _betNum) {\\n        uint risk = getRisk(_betNum);\\n        uint rows = getRows(_betNum);\\n\\n        require(risk \\u003e= 1 \\u0026\\u0026 risk \\u003c= 3 \\u0026\\u0026 (rows == 8 || rows == 12 || rows == 16) , \\\"Invalid num\\\");\\n        _;\\n    }\\n\\n    modifier onlyValidResultNum(uint _betNum, uint _resultNum) {\\n        uint rows = getRows(_betNum);\\n        require(_resultNum \\u003e= 0 \\u0026\\u0026 _resultNum \\u003c (1 \\u003c\\u003c rows));\\n        _;\\n    }\\n\\n    function maxBet(uint _betNum, uint _bankRoll) external onlyValidNum(_betNum) view returns(uint) {\\n        uint risk = getRisk(_betNum);\\n        uint rows = getRows(_betNum);\\n\\n        uint maxBetValue = MAX_BET[risk][rows];\\n\\n        return _bankRoll.mul(maxBetValue).div(MAX_BET_DIVIDER);\\n    }\\n\\n    function resultNumber(bytes32 _serverSeed, bytes32 _userSeed, uint _betNum) external onlyValidNum(_betNum) view returns(uint) {\\n        uint randNum = Utilities.generateRandomNumber(_serverSeed, _userSeed);\\n        uint rows = getRows(_betNum);\\n        return randNum \\u0026 ((1 \\u003c\\u003c rows) - 1);\\n    }\\n\\n    function userProfit(uint _betNum, uint _betValue, uint _resultNum)\\n        external\\n        onlyValidNum(_betNum)\\n        onlyValidResultNum(_betNum, _resultNum)\\n        view\\n        returns(int)\\n    {\\n        uint risk = getRisk(_betNum);\\n        uint rows = getRows(_betNum);\\n\\n        uint result = countBits(_resultNum, rows);\\n        uint resultIndex = calculateResultIndex(result, rows);\\n        uint16 payoutValue = PAYOUT[risk][rows][resultIndex];\\n\\n        return calculateProfit(payoutValue, _betValue);\\n    }\\n\\n\\n    function maxUserProfit(uint _betNum, uint _betValue) external onlyValidNum(_betNum) view returns(int) {\\n        uint risk = getRisk(_betNum);\\n        uint rows = getRows(_betNum);\\n\\n        uint16[] storage payout = PAYOUT[risk][rows];\\n        uint maxPayout = 0;\\n        for (uint i = 0; i \\u003c payout.length; i++) {\\n            if (payout[i] \\u003e maxPayout) {\\n                maxPayout = payout[i];\\n            }\\n        }\\n\\n        return calculateProfit(maxPayout, _betValue);\\n    }\\n\\n    function calculateProfit(uint _payout, uint _betValue) private pure returns(int) {\\n        return _betValue.mul(_payout).div(PAYOUT_DIVIDER).castToInt().sub(_betValue.castToInt());\\n    }\\n\\n    function calculateResultIndex(uint _result, uint _rows) private pure returns(uint) {\\n        uint halfRows = _rows / 2;\\n        return _result \\u003c halfRows ? halfRows - _result : _result - halfRows;\\n    }\\n\\n    function getRisk(uint _num) private pure returns(uint) {\\n        return (_num / 100) % 10;\\n    }\\n\\n    function getRows(uint _num) private pure returns(uint) {\\n        return _num % 100;\\n    }\\n\\n    function countBits(uint _num, uint _rows) private pure returns(uint) {\\n        uint selectedBits = 0;\\n        // Could be calculated more efficient.\\n        // But as it\\u0027s only needed if a conflict arises, let\\u0027s keep it simple.\\n        for (uint i = 0; i \\u003c _rows; i++) {\\n            if (_num \\u0026 (1 \\u003c\\u003c i) \\u003e 0) {\\n                selectedBits += 1;\\n            }\\n        }\\n        return selectedBits;\\n    }\\n}\\n\"},\"SafeCast.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nlibrary SafeCast {\\n    /**\\n     * Cast unsigned a to signed a.\\n     */\\n    function castToInt(uint a) internal pure returns(int) {\\n        assert(a \\u003c (1 \\u003c\\u003c 255));\\n        return int(a);\\n    }\\n\\n    /**\\n     * Cast signed a to unsigned a.\\n     */\\n    function castToUint(int a) internal pure returns(uint) {\\n        assert(a \\u003e= 0);\\n        return uint(a);\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error.\\n * From zeppelin-solidity\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two unsigned integers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Multiplies two signed integers, throws on overflow.\\n    */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n        int256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two unsigned integers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Integer division of two signed integers, truncating the quotient.\\n    */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        // Overflow only happens when the smallest negative int is multiplied by -1.\\n        int256 INT256_MIN = int256((uint256(1) \\u003c\\u003c 255));\\n        assert(a != INT256_MIN || b != - 1);\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two signed integers, throws on overflow.\\n    */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        assert((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a));\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two unsigned integers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two signed integers, throws on overflow.\\n    */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        assert((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\n        return c;\\n    }\\n}\\n\"},\"Utilities.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"../SafeMath.sol\\\";\\nimport \\\"../SafeCast.sol\\\";\\n\\n\\ncontract Utilities {\\n    using SafeCast for int;\\n    using SafeCast for uint;\\n    using SafeMath for int;\\n    using SafeMath for uint;\\n\\n    uint constant public PROBABILITY_DIVISOR = 10000;\\n    uint constant public HOUSE_EDGE = 150;\\n    uint constant public HOUSE_EDGE_DIVISOR = 10000;\\n\\n    /**\\n     * @dev Calc max bet we allow\\n     * We definitely do not allow bets greater than kelly criterion would allow.\\n     * =\\u003e The max bet is limited to the max profit of houseEdge * bankroll.\\n     * =\\u003e maxBet = houseEdge / (1/p * (1 - houseEdge) - 1) * bankroll, with p is win probability.\\n     * The max bet can be further restricted on backend.\\n     * @param _winProbability winProbability.\\n     * @return max allowed bet.\\n     */\\n    function maxBetFromProbability(uint _winProbability, uint _bankRoll) public pure returns(uint) {\\n        assert(0 \\u003c _winProbability \\u0026\\u0026 _winProbability \\u003c PROBABILITY_DIVISOR);\\n\\n        uint tmp1 = PROBABILITY_DIVISOR.mul(HOUSE_EDGE_DIVISOR).div(_winProbability);\\n        uint tmp2 = PROBABILITY_DIVISOR.mul(HOUSE_EDGE).div(_winProbability);\\n\\n        uint enumerator = HOUSE_EDGE.mul(_bankRoll);\\n        uint denominator = tmp1.sub(tmp2).sub(HOUSE_EDGE_DIVISOR);\\n        return enumerator.div(denominator);\\n    }\\n\\n    /**\\n     * Calculate user profit from total won.\\n     * @param _totalWon user winnings.\\n     * @param _betValue bet value.\\n     * @return user profit.\\n     */\\n    function calcProfitFromTotalWon(uint _totalWon, uint _betValue) public pure returns(int) {\\n        uint houseEdgeValue = _totalWon.mul(HOUSE_EDGE).div(HOUSE_EDGE_DIVISOR);\\n\\n        return _totalWon.castToInt().sub(houseEdgeValue.castToInt()).sub(_betValue.castToInt());\\n    }\\n\\n    /**\\n     * @dev Generates a 256 bit random number by combining server and user seed.\\n     * @param _serverSeed server seed.\\n     * @param _userSeed user seed.\\n     * @return random number generated by combining server and user seed.\\n     */\\n    function generateRandomNumber(bytes32 _serverSeed, bytes32 _userSeed) public pure returns(uint) {\\n        bytes32 combinedHash = keccak256(abi.encodePacked(_serverSeed, _userSeed));\\n        return uint(combinedHash);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MAX_BET\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BET_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PAYOUT\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PAYOUT_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROBABILITY_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalWon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"}],\"name\":\"calcProfitFromTotalWon\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_userSeed\",\"type\":\"bytes32\"}],\"name\":\"generateRandomNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bankRoll\",\"type\":\"uint256\"}],\"name\":\"maxBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_winProbability\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bankRoll\",\"type\":\"uint256\"}],\"name\":\"maxBetFromProbability\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"}],\"name\":\"maxUserProfit\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_userSeed\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_betNum\",\"type\":\"uint256\"}],\"name\":\"resultNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_resultNum\",\"type\":\"uint256\"}],\"name\":\"userProfit\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Plinko","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"bzzr://4860d8c10d7d1ba7a3c6b82516ce5b42a6c7886380fc752acc3e1ab4e8899b5b"}]}