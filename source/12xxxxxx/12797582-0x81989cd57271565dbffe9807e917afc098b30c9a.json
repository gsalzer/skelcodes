{"status":"1","message":"OK","result":[{"SourceCode":"// hevm: flattened sources of contracts/ERC721BridgeV2.sol\r\n\r\npragma solidity >=0.4.23 <0.5.0 >=0.4.24 <0.5.0;\r\n\r\n////// contracts/interfaces/IAuthority.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\ncontract IAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\n////// contracts/DSAuth.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\n/* import './interfaces/IAuthority.sol'; */\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\n/**\r\n * @title DSAuth\r\n * @dev The DSAuth contract is reference implement of https://github.com/dapphub/ds-auth\r\n * But in the isAuthorized method, the src from address(this) is remove for safty concern.\r\n */\r\ncontract DSAuth is DSAuthEvents {\r\n    IAuthority   public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(IAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == owner) {\r\n            return true;\r\n        } else if (authority == IAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n////// contracts/PausableDSAuth.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\n/* import \"./DSAuth.sol\"; */\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract PausableDSAuth is DSAuth {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n////// contracts/SettingIds.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\n/**\r\n    Id definitions for SettingsRegistry.sol\r\n    Can be used in conjunction with the settings registry to get properties\r\n*/\r\ncontract SettingIds {\r\n    // 0x434f4e54524143545f52494e475f45524332305f544f4b454e00000000000000\r\n    bytes32 public constant CONTRACT_RING_ERC20_TOKEN = \"CONTRACT_RING_ERC20_TOKEN\";\r\n\r\n    // 0x434f4e54524143545f4b544f4e5f45524332305f544f4b454e00000000000000\r\n    bytes32 public constant CONTRACT_KTON_ERC20_TOKEN = \"CONTRACT_KTON_ERC20_TOKEN\";\r\n\r\n    // 0x434f4e54524143545f474f4c445f45524332305f544f4b454e00000000000000\r\n    bytes32 public constant CONTRACT_GOLD_ERC20_TOKEN = \"CONTRACT_GOLD_ERC20_TOKEN\";\r\n\r\n    // 0x434f4e54524143545f574f4f445f45524332305f544f4b454e00000000000000\r\n    bytes32 public constant CONTRACT_WOOD_ERC20_TOKEN = \"CONTRACT_WOOD_ERC20_TOKEN\";\r\n\r\n    // 0x434f4e54524143545f57415445525f45524332305f544f4b454e000000000000\r\n    bytes32 public constant CONTRACT_WATER_ERC20_TOKEN = \"CONTRACT_WATER_ERC20_TOKEN\";\r\n\r\n    // 0x434f4e54524143545f464952455f45524332305f544f4b454e00000000000000\r\n    bytes32 public constant CONTRACT_FIRE_ERC20_TOKEN = \"CONTRACT_FIRE_ERC20_TOKEN\";\r\n\r\n    // 0x434f4e54524143545f534f494c5f45524332305f544f4b454e00000000000000\r\n    bytes32 public constant CONTRACT_SOIL_ERC20_TOKEN = \"CONTRACT_SOIL_ERC20_TOKEN\";\r\n\r\n    // 0x434f4e54524143545f4f424a4543545f4f574e45525348495000000000000000\r\n    bytes32 public constant CONTRACT_OBJECT_OWNERSHIP = \"CONTRACT_OBJECT_OWNERSHIP\";\r\n\r\n    // 0x434f4e54524143545f544f4b454e5f4c4f434154494f4e000000000000000000\r\n    bytes32 public constant CONTRACT_TOKEN_LOCATION = \"CONTRACT_TOKEN_LOCATION\";\r\n\r\n    // 0x434f4e54524143545f4c414e445f424153450000000000000000000000000000\r\n    bytes32 public constant CONTRACT_LAND_BASE = \"CONTRACT_LAND_BASE\";\r\n\r\n    // 0x434f4e54524143545f555345525f504f494e5453000000000000000000000000\r\n    bytes32 public constant CONTRACT_USER_POINTS = \"CONTRACT_USER_POINTS\";\r\n\r\n    // 0x434f4e54524143545f494e5445525354454c4c41525f454e434f444552000000\r\n    bytes32 public constant CONTRACT_INTERSTELLAR_ENCODER = \"CONTRACT_INTERSTELLAR_ENCODER\";\r\n\r\n    // 0x434f4e54524143545f4449564944454e44535f504f4f4c000000000000000000\r\n    bytes32 public constant CONTRACT_DIVIDENDS_POOL = \"CONTRACT_DIVIDENDS_POOL\";\r\n\r\n    // 0x434f4e54524143545f544f4b454e5f5553450000000000000000000000000000\r\n    bytes32 public constant CONTRACT_TOKEN_USE = \"CONTRACT_TOKEN_USE\";\r\n\r\n    // 0x434f4e54524143545f524556454e55455f504f4f4c0000000000000000000000\r\n    bytes32 public constant CONTRACT_REVENUE_POOL = \"CONTRACT_REVENUE_POOL\";\r\n\r\n    // 0x434f4e54524143545f4252494447455f504f4f4c000000000000000000000000\r\n    bytes32 public constant CONTRACT_BRIDGE_POOL = \"CONTRACT_BRIDGE_POOL\";\r\n\r\n    // 0x434f4e54524143545f4552433732315f42524944474500000000000000000000\r\n    bytes32 public constant CONTRACT_ERC721_BRIDGE = \"CONTRACT_ERC721_BRIDGE\";\r\n\r\n    // 0x434f4e54524143545f5045545f42415345000000000000000000000000000000\r\n    bytes32 public constant CONTRACT_PET_BASE = \"CONTRACT_PET_BASE\";\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // this can be considered as transaction fee.\r\n    // Values 0-10,000 map to 0%-100%\r\n    // set ownerCut to 4%\r\n    // ownerCut = 400;\r\n    // 0x55494e545f41554354494f4e5f43555400000000000000000000000000000000\r\n    bytes32 public constant UINT_AUCTION_CUT = \"UINT_AUCTION_CUT\";  // Denominator is 10000\r\n\r\n    // 0x55494e545f544f4b454e5f4f464645525f435554000000000000000000000000\r\n    bytes32 public constant UINT_TOKEN_OFFER_CUT = \"UINT_TOKEN_OFFER_CUT\";  // Denominator is 10000\r\n\r\n    // Cut referer takes on each auction, measured in basis points (1/100 of a percent).\r\n    // which cut from transaction fee.\r\n    // Values 0-10,000 map to 0%-100%\r\n    // set refererCut to 4%\r\n    // refererCut = 400;\r\n    // 0x55494e545f524546455245525f43555400000000000000000000000000000000\r\n    bytes32 public constant UINT_REFERER_CUT = \"UINT_REFERER_CUT\";\r\n\r\n    // 0x55494e545f4252494447455f4645450000000000000000000000000000000000\r\n    bytes32 public constant UINT_BRIDGE_FEE = \"UINT_BRIDGE_FEE\";\r\n\r\n    // 0x434f4e54524143545f4c414e445f5245534f5552434500000000000000000000\r\n    bytes32 public constant CONTRACT_LAND_RESOURCE = \"CONTRACT_LAND_RESOURCE\";\r\n}\r\n\r\n////// contracts/interfaces/IBurnableERC20.sol\r\n/* pragma solidity ^0.4.23; */\r\n\r\ncontract IBurnableERC20 {\r\n    function burn(address _from, uint _value) public;\r\n}\r\n\r\n////// contracts/interfaces/IERC165.sol\r\n\r\n/* pragma solidity ^0.4.24; */\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ncontract IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n////// contracts/interfaces/IERC1155.sol\r\n\r\n/* pragma solidity ^0.4.24; */\r\n\r\n/* import \"./IERC165.sol\"; */\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ncontract IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] accounts, uint256[] ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data) external;\r\n}\r\n\r\n////// contracts/interfaces/IERC1155Receiver.sol\r\n\r\n/* pragma solidity ^0.4.24; */\r\n\r\n/**\r\n * _Available since v3.1._\r\n */\r\ncontract IERC1155Receiver {\r\n\r\n    bytes4 internal constant ERC1155_RECEIVED_VALUE = 0xf23a6e61;\r\n    bytes4 internal constant ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\r\n\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] ids,\r\n        uint256[] values,\r\n        bytes data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n}\r\n\r\n////// contracts/interfaces/IERC721.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\n/* import \"./IERC165.sol\"; */\r\n\r\n/**\r\n * @title IERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721 is IERC165 {\r\n\r\n  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n  /*\r\n   * 0x80ac58cd ===\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n  /*\r\n   * 0x4f558e79 ===\r\n   *   bytes4(keccak256('exists(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n  /**\r\n   * 0x780e9d63 ===\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n  /**\r\n   * 0x5b5e139f ===\r\n   *   bytes4(keccak256('name()')) ^\r\n   *   bytes4(keccak256('symbol()')) ^\r\n   *   bytes4(keccak256('tokenURI(uint256)'))\r\n   */\r\n\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n////// contracts/interfaces/IERC721Receiver.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   * after a `safetransfer`. This function MAY throw to revert and reject the\r\n   * transfer. Return of other than the magic value MUST result in the\r\n   * transaction being reverted.\r\n   * Note: the contract address is always the message sender.\r\n   * @param _operator The address which called `safeTransferFrom` function\r\n   * @param _from The address which previously owned the token\r\n   * @param _tokenId The NFT identifier which is being transferred\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    returns(bytes4);\r\n}\r\n\r\n////// contracts/interfaces/IInterstellarEncoderV3.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\ncontract IInterstellarEncoderV3 {\r\n    uint256 constant CLEAR_HIGH =  0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\r\n\r\n    uint256 public constant MAGIC_NUMBER = 42;    // Interstellar Encoding Magic Number.\r\n    uint256 public constant CHAIN_ID = 1; // Ethereum mainet.\r\n    uint256 public constant CURRENT_LAND = 1; // 1 is Atlantis, 0 is NaN.\r\n\r\n    enum ObjectClass { \r\n        NaN,\r\n        LAND,\r\n        APOSTLE,\r\n        OBJECT_CLASS_COUNT\r\n    }\r\n\r\n    function registerNewObjectClass(address _objectContract, uint8 objectClass) public;\r\n\r\n    function encodeTokenId(address _tokenAddress, uint8 _objectClass, uint128 _objectIndex) public view returns (uint256 _tokenId);\r\n\r\n    function encodeTokenIdForObjectContract(\r\n        address _tokenAddress, address _objectContract, uint128 _objectId) public view returns (uint256 _tokenId);\r\n\r\n    function encodeTokenIdForOuterObjectContract(\r\n        address _objectContract, address nftAddress, address _originNftAddress, uint128 _objectId, uint16 _producerId, uint8 _convertType) public view returns (uint256);\r\n\r\n    function getContractAddress(uint256 _tokenId) public view returns (address);\r\n\r\n    function getObjectId(uint256 _tokenId) public view returns (uint128 _objectId);\r\n\r\n    function getObjectClass(uint256 _tokenId) public view returns (uint8);\r\n\r\n    function getObjectAddress(uint256 _tokenId) public view returns (address);\r\n\r\n    function getProducerId(uint256 _tokenId) public view returns (uint16);\r\n\r\n    function getOriginAddress(uint256 _tokenId) public view returns (address);\r\n\r\n}\r\n\r\n////// contracts/interfaces/IMintableERC20.sol\r\n/* pragma solidity ^0.4.23; */\r\n\r\ncontract IMintableERC20 {\r\n\r\n    function mint(address _to, uint256 _value) public;\r\n}\r\n\r\n////// contracts/interfaces/INFTAdaptor.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\n\r\ncontract INFTAdaptor {\r\n    function toMirrorTokenId(uint256 _originTokenId) public view returns (uint256);\r\n\r\n    function toMirrorTokenIdAndIncrease(uint256 _originTokenId) public returns (uint256);\r\n\r\n    function toOriginTokenId(uint256 _mirrorTokenId) public view returns (uint256);\r\n\r\n    function approveOriginToken(address _bridge, uint256 _originTokenId) public;\r\n\r\n    function ownerInOrigin(uint256 _originTokenId) public view returns (address);\r\n\r\n    function cacheMirrorTokenId(uint256 _originTokenId, uint256 _mirrorTokenId) public;\r\n}\r\n\r\n////// contracts/interfaces/IPetBase.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\ncontract IPetBase {\r\n    function pet2TiedStatus(uint256 _mirrorTokenId) public returns (uint256, uint256);\r\n}\r\n\r\n////// contracts/interfaces/ISettingsRegistry.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\ncontract ISettingsRegistry {\r\n    enum SettingsValueTypes { NONE, UINT, STRING, ADDRESS, BYTES, BOOL, INT }\r\n\r\n    function uintOf(bytes32 _propertyName) public view returns (uint256);\r\n\r\n    function stringOf(bytes32 _propertyName) public view returns (string);\r\n\r\n    function addressOf(bytes32 _propertyName) public view returns (address);\r\n\r\n    function bytesOf(bytes32 _propertyName) public view returns (bytes);\r\n\r\n    function boolOf(bytes32 _propertyName) public view returns (bool);\r\n\r\n    function intOf(bytes32 _propertyName) public view returns (int);\r\n\r\n    function setUintProperty(bytes32 _propertyName, uint _value) public;\r\n\r\n    function setStringProperty(bytes32 _propertyName, string _value) public;\r\n\r\n    function setAddressProperty(bytes32 _propertyName, address _value) public;\r\n\r\n    function setBytesProperty(bytes32 _propertyName, bytes _value) public;\r\n\r\n    function setBoolProperty(bytes32 _propertyName, bool _value) public;\r\n\r\n    function setIntProperty(bytes32 _propertyName, int _value) public;\r\n\r\n    function getValueTypeOf(bytes32 _propertyName) public view returns (uint /* SettingsValueTypes */ );\r\n\r\n    event ChangeProperty(bytes32 indexed _propertyName, uint256 _type);\r\n}\r\n\r\n////// contracts/ERC721BridgeV2.sol\r\n/* pragma solidity ^0.4.24; */\r\n\r\n/* import \"./PausableDSAuth.sol\"; */\r\n/* import \"./interfaces/ISettingsRegistry.sol\"; */\r\n/* import \"./SettingIds.sol\"; */\r\n/* import \"./interfaces/IInterstellarEncoderV3.sol\"; */\r\n/* import \"./interfaces/IMintableERC20.sol\"; */\r\n/* import \"./interfaces/IBurnableERC20.sol\"; */\r\n/* import \"./interfaces/INFTAdaptor.sol\"; */\r\n/* import \"./interfaces/IERC1155.sol\"; */\r\n/* import \"./interfaces/IERC1155Receiver.sol\"; */\r\n/* import \"./interfaces/IERC721.sol\"; */\r\n/* import \"./interfaces/IERC721Receiver.sol\"; */\r\n/* import \"./interfaces/IPetBase.sol\"; */\r\n\r\n\r\n/*\r\n * naming convention:\r\n * originTokenId - token outside evolutionLand\r\n * mirrorTokenId - mirror token\r\n */\r\ncontract ERC721BridgeV2 is SettingIds, PausableDSAuth, IERC721Receiver, IERC1155Receiver {\r\n\r\n    /*\r\n     *  Storage\r\n    */\r\n    bool private singletonLock = false;\r\n\r\n    ISettingsRegistry public registry;\r\n\r\n\r\n    // originNFTContract => its adator\r\n    // for instance, CryptoKitties => CryptoKittiesAdaptor\r\n    // this need to be registered by owner\r\n    mapping(address => address) public originNFT2Adaptor;\r\n\r\n    // tokenId_inside => tokenId_outside\r\n    mapping(uint256 => uint256) public mirrorId2OriginId;\r\n\r\n    mapping(uint256 => uint256) public mirrorId2OriginId1155;\r\n\r\n    /*\r\n     *  Event\r\n     */\r\n    // event BridgeIn(uint256 originTokenId, uint256 mirrorTokenId, address originContract, address adaptorAddress, address owner);\r\n\r\n    event SwapIn(address originContract, uint256 originTokenId, uint256 mirrorTokenId, address owner);\r\n    event SwapOut(address originContract, uint256 originTokenId, uint256 mirrorTokenId, address owner);\r\n\r\n    function registerAdaptor(address _originNftAddress, address _erc721Adaptor) public whenNotPaused onlyOwner {\r\n        originNFT2Adaptor[_originNftAddress] = _erc721Adaptor;\r\n    }\r\n\r\n    function swapOut721(uint256 _mirrorTokenId) public  {\r\n        IInterstellarEncoderV3 interstellarEncoder = IInterstellarEncoderV3(registry.addressOf(SettingIds.CONTRACT_INTERSTELLAR_ENCODER));\r\n        address nftContract = interstellarEncoder.getOriginAddress(_mirrorTokenId);\r\n        require(nftContract != address(0), \"No such NFT contract\");\r\n        address adaptor = originNFT2Adaptor[nftContract];\r\n        require(adaptor != address(0), \"not registered!\");\r\n        require(ownerOfMirror(_mirrorTokenId) == msg.sender, \"you have no right to swap it out!\");\r\n\r\n        address petBase = registry.addressOf(SettingIds.CONTRACT_PET_BASE);\r\n        (uint256 apostleTokenId,) = IPetBase(petBase).pet2TiedStatus(_mirrorTokenId);\r\n        require(apostleTokenId == 0, \"Pet has been tied.\");\r\n        uint256 originTokenId = mirrorId2OriginId[_mirrorTokenId];\r\n        address objectOwnership = registry.addressOf(SettingIds.CONTRACT_OBJECT_OWNERSHIP);\r\n        address owner = IERC721(objectOwnership).ownerOf(_mirrorTokenId);\r\n        if (owner != address(this)) {\r\n            IERC721(nftContract).approve(address(this), originTokenId); // kitty must approve first \r\n            IERC721(nftContract).transferFrom(address(this), msg.sender, originTokenId);\r\n        }\r\n        IBurnableERC20(objectOwnership).burn(owner, _mirrorTokenId);\r\n        delete mirrorId2OriginId[_mirrorTokenId];\r\n        emit SwapOut(nftContract, originTokenId, _mirrorTokenId, msg.sender);\r\n    }\r\n\r\n\t// V2 add - Support PolkaPet\r\n    function swapOut1155(uint256 _mirrorTokenId) public  {\r\n        IInterstellarEncoderV3 interstellarEncoder = IInterstellarEncoderV3(registry.addressOf(SettingIds.CONTRACT_INTERSTELLAR_ENCODER));\r\n        address nftContract = interstellarEncoder.getOriginAddress(_mirrorTokenId);\r\n        require(nftContract != address(0), \"No such NFT contract\");\r\n        address adaptor = originNFT2Adaptor[nftContract];\r\n        require(adaptor != address(0), \"not registered!\");\r\n        address objectOwnership = registry.addressOf(SettingIds.CONTRACT_OBJECT_OWNERSHIP);\r\n        require(IERC721(objectOwnership).ownerOf(_mirrorTokenId) == msg.sender, \"you have no right to swap it out!\");\r\n\r\n        address petBase = registry.addressOf(SettingIds.CONTRACT_PET_BASE);\r\n        (uint256 apostleTokenId,) = IPetBase(petBase).pet2TiedStatus(_mirrorTokenId);\r\n        require(apostleTokenId == 0, \"Pet has been tied.\");\r\n        uint256 originTokenId = mirrorId2OriginId1155[_mirrorTokenId];\r\n        IBurnableERC20(objectOwnership).burn(msg.sender, _mirrorTokenId);\r\n        IERC1155(nftContract).safeTransferFrom(address(this), msg.sender, originTokenId, 1, \"\");\r\n        delete mirrorId2OriginId1155[_mirrorTokenId];\r\n        emit SwapOut(nftContract, originTokenId, _mirrorTokenId, msg.sender);\r\n    }\r\n\r\n    function ownerOf(uint256 _mirrorTokenId) public view returns (address) {\r\n        return ownerOfMirror(_mirrorTokenId);\r\n    }\r\n\r\n    // return human owner of the token\r\n    function mirrorOfOrigin(address _originNFT, uint256 _originTokenId) public view returns (uint256) {\r\n        INFTAdaptor adapter = INFTAdaptor(originNFT2Adaptor[_originNFT]);\r\n\r\n        return adapter.toMirrorTokenId(_originTokenId);\r\n    }\r\n\r\n    // return human owner of the token\r\n    function ownerOfMirror(uint256 _mirrorTokenId) public view returns (address) {\r\n        address objectOwnership = registry.addressOf(SettingIds.CONTRACT_OBJECT_OWNERSHIP);\r\n        address owner = IERC721(objectOwnership).ownerOf(_mirrorTokenId);\r\n        if(owner != address(this)) {\r\n            return owner;\r\n        } else {\r\n            uint originTokenId = mirrorId2OriginId[_mirrorTokenId];\r\n            return INFTAdaptor(originNFT2Adaptor[originOwnershipAddress(_mirrorTokenId)]).ownerInOrigin(originTokenId);\r\n        }\r\n    }\r\n\r\n    function originOwnershipAddress(uint256 _mirrorTokenId) public view returns (address) {\r\n        IInterstellarEncoderV3 interstellarEncoder = IInterstellarEncoderV3(registry.addressOf(SettingIds.CONTRACT_INTERSTELLAR_ENCODER));\r\n\r\n        return interstellarEncoder.getOriginAddress(_mirrorTokenId);\r\n    }\r\n\r\n    function isBridged(uint256 _mirrorTokenId) public view returns (bool) {\r\n        return (mirrorId2OriginId[_mirrorTokenId] != 0);\r\n    }\r\n\r\n    // V2 add - Support PolkaPet\r\n    function swapIn1155(address _originNftAddress, uint256 _originTokenId, uint256 _value) public whenNotPaused() {\r\n        address _from = msg.sender;\r\n        IERC1155(_originNftAddress).safeTransferFrom(_from, address(this), _originTokenId, _value, \"\");\r\n        address adaptor = originNFT2Adaptor[_originNftAddress];\r\n        require(adaptor != address(0), \"Not registered!\");\r\n        address objectOwnership = registry.addressOf(SettingIds.CONTRACT_OBJECT_OWNERSHIP);\r\n        for (uint256 i = 0; i < _value; i++) {\r\n            uint256 mirrorTokenId = INFTAdaptor(adaptor).toMirrorTokenIdAndIncrease(_originTokenId);\r\n            IMintableERC20(objectOwnership).mint(_from, mirrorTokenId);\r\n            mirrorId2OriginId1155[mirrorTokenId] = _originTokenId;\r\n            // emit BridgeIn(_originTokenId, mirrorTokenId, _originNftAddress, adaptor, _from);\r\n            emit SwapIn(_originNftAddress, _originTokenId, mirrorTokenId, _from);\r\n        }\r\n    }\r\n\r\n    function swapIn721(address _originNftAddress, uint256 _originTokenId) public whenNotPaused() {\r\n        address _owner = msg.sender;\r\n        IERC721(_originNftAddress).transferFrom(_owner, address(this), _originTokenId);\r\n        address adaptor = originNFT2Adaptor[_originNftAddress];\r\n        require(adaptor != address(0), \"Not registered!\");\r\n        uint256 mirrorTokenId = INFTAdaptor(adaptor).toMirrorTokenId(_originTokenId);\r\n        address objectOwnership = registry.addressOf(SettingIds.CONTRACT_OBJECT_OWNERSHIP);\r\n        require(!isBridged(mirrorTokenId), \"Already swap in\");\r\n        INFTAdaptor(adaptor).cacheMirrorTokenId(_originTokenId, mirrorTokenId);\r\n        mirrorId2OriginId[mirrorTokenId] = _originTokenId;\r\n        IMintableERC20(objectOwnership).mint(_owner, mirrorTokenId);\r\n        emit SwapIn(_originNftAddress, _originTokenId, mirrorTokenId, _owner);\r\n    }\r\n\r\n    function onERC721Received(\r\n      address /*_operator*/,\r\n      address /*_from*/,\r\n      uint256 /*_tokenId*/,\r\n      bytes /*_data*/\r\n    )\r\n      public \r\n      returns(bytes4) \r\n    {\r\n        return ERC721_RECEIVED;\r\n    }\r\n\r\n    function onERC1155Received(\r\n      address /*operator*/,\r\n      address /*from*/,\r\n      uint256 /*id*/,\r\n      uint256 /*value*/,\r\n      bytes /*data*/\r\n    )\r\n      external\r\n      returns(bytes4)\r\n    {\r\n        return ERC1155_RECEIVED_VALUE; \r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n      address /*operator*/,\r\n      address /*from*/,\r\n      uint256[] /*ids*/,\r\n      uint256[] /*values*/,\r\n      bytes /*data*/\r\n    )\r\n      external\r\n      returns(bytes4)\r\n    {\r\n        return ERC1155_BATCH_RECEIVED_VALUE;\t\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_USER_POINTS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mirrorId2OriginId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_BRIDGE_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_BRIDGE_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_WATER_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_GOLD_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_RING_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_AUCTION_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originNftAddress\",\"type\":\"address\"},{\"name\":\"_originTokenId\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"swapIn1155\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_originNFT\",\"type\":\"address\"},{\"name\":\"_originTokenId\",\"type\":\"uint256\"}],\"name\":\"mirrorOfOrigin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_TOKEN_LOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"originNFT2Adaptor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_KTON_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_WOOD_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_FIRE_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mirrorId2OriginId1155\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"swapOut721\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_LAND_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"originOwnershipAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_INTERSTELLAR_ENCODER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_PET_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originNftAddress\",\"type\":\"address\"},{\"name\":\"_erc721Adaptor\",\"type\":\"address\"}],\"name\":\"registerAdaptor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_SOIL_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"isBridged\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOfMirror\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originNftAddress\",\"type\":\"address\"},{\"name\":\"_originTokenId\",\"type\":\"uint256\"}],\"name\":\"swapIn721\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_OBJECT_OWNERSHIP\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_TOKEN_USE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ERC721_BRIDGE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_REVENUE_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_LAND_RESOURCE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_REFERER_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"swapOut1155\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_TOKEN_OFFER_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_DIVIDENDS_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"originContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"originTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mirrorTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SwapIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"originContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"originTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mirrorTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SwapOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"ERC721BridgeV2","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c6a53fe5e66571dc6dbd3b16d0db42159d42f37656185a7f688755843fb557f0"}]}