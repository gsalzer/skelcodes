{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\n/**\\n * @title Address\\n * @dev Check if the address is a contract using eip-1052\\n */\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 \\u0026\\u0026 codehash != accountHash);\\n    }\\n}\"},\"Context.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\ncontract Context {\\n    constructor () internal { }\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\n/**\\n * @dev The ERC20 standard implementation.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint;\\n\\n    mapping (address =\\u003e uint) private _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) private _allowances;\\n\\n    uint private _totalSupply;\\n\\n    function totalSupply() public view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint amount) public returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view returns (uint) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint amount) public returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint amount) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address account) external view returns (uint);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\"},\"IWETH.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\ninterface IWETH {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function allowance(address, address) external view returns (uint);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint wad) external;\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function approve(address guy, uint wad) external returns (bool);\\n\\n    function transfer(address dst, uint wad) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\\n}\"},\"LPToken.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity 0.5.17;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n\\ncontract LPToken is ERC20 {\\n    string public constant name     = \\\"DEXG Liquidity Pool\\\";\\n    string public constant symbol   = \\\"DEXG-LP\\\";\\n    uint8  public constant decimals = 18;\\n}\"},\"Math.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003e= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"},\"Owned.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\ncontract Ownable {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        newOwner = address(0);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyNewOwner() {\\n        require(msg.sender != address(0));\\n        require(msg.sender == newOwner);\\n        _;\\n    }\\n    \\n    function isOwner(address account) public view returns (bool) {\\n        if(account == owner) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n\\n    function transferOwnership(address _newOwner) public onlyOwner {\\n        require(_newOwner != address(0));\\n        newOwner = _newOwner;\\n    }\\n\\n    function acceptOwnership() public onlyNewOwner {\\n        emit OwnershipTransferred(owner, newOwner);        \\n        owner = newOwner;\\n        newOwner = address(0);\\n    }\\n}\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.5.17;\\n\\nimport \\\"./Owned.sol\\\";\\n\\n\\ncontract Pausable is Ownable {\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    constructor () public {\\n        _paused = false;\\n    }    \\n\\n    modifier whenNotPaused() {\\n        require(!_paused);\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(_paused);\\n        _;\\n    }\\n\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    function pause() public onlyOwner whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    function unpause() public onlyOwner whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\\n * available, which can be aplied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n */\\ncontract ReentrancyGuard {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor () internal {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n}\\n\"},\"RewardDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity 0.5.17;\\n\\nimport \\\"./Math.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./Owned.sol\\\";\\nimport \\\"./Context.sol\\\";\\n\\n\\ncontract IRewardPool {\\n    function notifyRewards(uint reward) external;\\n}\\n\\ncontract Aggregator is Ownable, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n    /// Protocol developers rewards\\n    uint public constant FEE_FACTOR = 3;\\n\\n    // Beneficial address\\n    address public beneficial;\\n\\n    /// Reward token\\n    IERC20 public rewardToken;\\n\\n    // Reward pool address\\n    address public rewardPool;\\n\\n    constructor(address _token1, address _rewardPool) public {\\n        beneficial = msg.sender;\\n        \\n        rewardToken = IERC20(_token1);\\n        rewardPool = _rewardPool;\\n    }\\n\\n    /// Capture tokens or any other tokens\\n    function capture(address _token) onlyOwner external {\\n        require(_token != address(rewardToken), \\\"capture: can not capture reward tokens\\\");\\n\\n        uint balance = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).safeTransfer(beneficial, balance);\\n    }  \\n\\n    function notifyRewards() onlyOwner nonReentrant external {\\n        uint reward = rewardToken.balanceOf(address(this));\\n\\n        /// Split the governance and protocol developers rewards\\n        uint _developerRewards = reward.div(FEE_FACTOR);\\n        uint _governanceRewards = reward.sub(_developerRewards);\\n\\n        rewardToken.safeTransfer(beneficial, _developerRewards);\\n        rewardToken.safeTransfer(rewardPool, _governanceRewards);\\n\\n        IRewardPool(rewardPool).notifyRewards(_governanceRewards);\\n    }\\n}\\n\\ncontract RewardPool is Ownable, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n    event TokenDeposit(address account, uint amount);\\n    event TokenWithdraw(address account, uint amount);\\n    event TokenClaim(address account, uint amount);\\n    event RewardAdded(uint reward);\\n\\n    bytes32 public merkleRoot;\\n\\n    uint public periodFinish = 0;\\n    uint public rewardRate = 0;\\n    uint public lastUpdateTime;\\n    uint public rewardPerTokenStored = 0;\\n    uint public rewardsDuration = 7 days;\\n\\n    // Beneficial address\\n    address public beneficial = address(this);\\n\\n    // User award balance\\n    mapping(address =\\u003e uint) public rewards;\\n    mapping(address =\\u003e uint) public userRewardPerTokenPaid;\\n\\n    /// Staking token\\n    IERC20 private _token0;\\n\\n    /// Reward token\\n    IERC20 private _token1;\\n\\n    /// Total rewards\\n    uint private _rewards;\\n    uint private _remainingRewards;\\n\\n    /// Total amount of user staking tokens\\n    uint private _totalSupply;\\n\\n    /// The amount of tokens staked\\n    mapping(address =\\u003e uint) private _balances;\\n\\n    /// The remaining withdrawals of staked tokens\\n    mapping(address =\\u003e uint) internal withdrawalOf;  \\n\\n    /// The remaining withdrawals of reward tokens\\n    mapping(address =\\u003e uint) internal claimOf;\\n\\n    address public rewardDistribution;\\n\\n    modifier updateReward(address account) {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n        if (account != address(0)) {\\n            rewards[account] = earned(account);\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n        }\\n        _;\\n    }\\n\\n    modifier onlyRewardDistribution() {\\n        require(msg.sender == rewardDistribution, \\\"Caller is not reward distribution\\\");\\n        _;\\n    }\\n    \\n    constructor (address token0, address token1) public {\\n        require(token0 != address(0), \\\"FeePool: zero address\\\");\\n        require(token1 != address(0), \\\"FeePool: zero address\\\");\\n\\n        _token0 = IERC20(token0);\\n        _token1 = IERC20(token1);\\n    }\\n\\n    function setBeneficial(address _beneficial) onlyOwner external {\\n        require(_beneficial != address(this), \\\"setBeneficial: can not send to self\\\");\\n        require(_beneficial != address(0), \\\"setBeneficial: can not burn tokens\\\");\\n        beneficial = _beneficial;\\n    }\\n\\n    function setRewardDistribution(address _rewardDistribution)\\n        external\\n        onlyOwner\\n    {\\n        rewardDistribution = _rewardDistribution;\\n    }\\n    \\n    /// Capture tokens or any other tokens\\n    function capture(address _token) onlyOwner external {\\n        require(_token != address(_token0), \\\"capture: can not capture staking tokens\\\");\\n        require(_token != address(_token1), \\\"capture: can not capture reward tokens\\\");\\n        require(beneficial != address(this), \\\"capture: can not send to self\\\");\\n        require(beneficial != address(0), \\\"capture: can not burn tokens\\\");\\n        uint balance = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).safeTransfer(beneficial, balance);\\n    }  \\n\\n    function _setMerkleRoot(bytes32 merkleRoot_) internal {\\n        merkleRoot = merkleRoot_;\\n    }\\n\\n    function notifyRewards(uint reward)\\n        external\\n        onlyRewardDistribution\\n        updateReward(address(0))\\n    {\\n        if (block.timestamp \\u003e= periodFinish) {\\n            rewardRate = reward.div(rewardsDuration);\\n        } else {\\n            uint remaining = periodFinish.sub(block.timestamp);\\n            uint leftover = remaining.mul(rewardRate);\\n            rewardRate = reward.add(leftover).div(rewardsDuration);\\n        }\\n\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\n        // This keeps the reward rate in the right range, preventing overflows due to\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\n        uint balance = _token1.balanceOf(address(this));\\n        require(rewardRate \\u003c= balance.div(rewardsDuration), \\\"notifyRewards: provided reward too high\\\");\\n\\n        lastUpdateTime = block.timestamp;\\n        periodFinish = block.timestamp.add(rewardsDuration);\\n        emit RewardAdded(reward);\\n    }\\n\\n    /// Deposit staking tokens\\n    function deposit(uint amount) \\n        external \\n        nonReentrant\\n        updateReward(msg.sender)\\n    {\\n        /// Verify the eligible wallet        \\n        require(amount \\u003e 0, \\\"deposit: cannot stake 0\\\");\\n        require(_token0.balanceOf(msg.sender) \\u003e= amount, \\\"deposit: insufficient balance\\\");\\n        \\n        _totalSupply = _totalSupply.add(amount);          \\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n        _token0.safeTransferFrom(msg.sender, address(this), amount);\\n        \\n        emit TokenDeposit(msg.sender, amount);\\n    }\\n\\n    /// Withdraw staked tokens\\n    function withdraw(uint amount) \\n        external \\n        nonReentrant\\n        updateReward(msg.sender)\\n    {\\n        require(amount \\u003e 0, \\\"withdraw: amount invalid\\\");\\n        require(msg.sender != address(0), \\\"withdraw: zero address\\\");\\n        /// Not overflow\\n        require(_balances[msg.sender] \\u003e= amount);\\n        _totalSupply = _totalSupply.sub(amount);                \\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        /// Keep track user withdraws\\n        withdrawalOf[msg.sender] = withdrawalOf[msg.sender].add(amount); \\n        _token0.safeTransfer(msg.sender, amount);\\n        emit TokenWithdraw(msg.sender, amount);\\n    }\\n\\n    /// Claim reward tokens\\n    function claim() \\n        external \\n        nonReentrant\\n        updateReward(msg.sender)\\n    {\\n        require(msg.sender != address(0), \\\"claim: zero address\\\");        \\n        uint reward = rewards[msg.sender];\\n        require(reward \\u003e 0, \\\"claim: zero rewards\\\");        \\n        require(_token1.balanceOf(address(this)) \\u003e= reward, \\\"claim: insufficient balance\\\");        \\n\\n        rewards[msg.sender] = 0;\\n        claimOf[msg.sender] = claimOf[msg.sender].add(reward);\\n        _token1.safeTransfer(msg.sender, reward);\\n        emit TokenClaim(msg.sender, reward);\\n    }\\n\\n    function getWithdrawalOf(address _stakeholder) external view returns (uint) {\\n        return withdrawalOf[_stakeholder];\\n    }\\n\\n    function getClaimOf(address _stakeholder) external view returns (uint) {\\n        return claimOf[_stakeholder];\\n    }\\n\\n    /// Get remaining rewards of the time period\\n    function remainingRewards() external view returns(uint) {\\n        return _remainingRewards;\\n    }\\n\\n    /// Retrieve the stake for a stakeholder\\n    function stakeOf(address _stakeholder) external view returns (uint) {\\n        return _balances[_stakeholder];\\n    }\\n\\n    /// Retrieve the stake for a stakeholder\\n    function rewardOf(address _stakeholder) external view returns (uint) {\\n        return earned(_stakeholder);\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint) {\\n        return Math.min(block.timestamp, periodFinish);\\n    }\\n\\n    function rewardPerToken() public view returns (uint) {\\n        if (getTotalStakes() == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored.add(\\n                lastTimeRewardApplicable()\\n                    .sub(lastUpdateTime)\\n                    .mul(rewardRate)\\n                    .mul(1e18)\\n                    .div(getTotalStakes())\\n            );\\n    }\\n\\n    function earned(address account) public view returns (uint) {\\n        return balanceOf(account)\\n            .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\n            .div(1e18)\\n            .add(rewards[account]);\\n    }\\n\\n    /// The total supply of all staked tokens\\n    function getTotalStakes() public view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint) {\\n        return _balances[account];\\n    }     \\n}\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length \\u003e 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n\\nlibrary SafeMath {\\n    function add(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n    function sub(uint a, uint b) internal pure returns (uint) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n        require(b \\u003c= a, errorMessage);\\n        uint c = a - b;\\n\\n        return c;\\n    }\\n    function mul(uint a, uint b) internal pure returns (uint) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n    function div(uint a, uint b) internal pure returns (uint) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint c = a / b;\\n\\n        return c;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardPool\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficial\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"capture\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"notifyRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Aggregator","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000079bed70344fd949c5a081dc318489f906ca99a0c","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://455e3108bc5aa4711ec73cc27d01f5b748008bd469b285f13733fb2f2ab25c7c"}]}