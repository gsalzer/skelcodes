{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.2;\npragma experimental ABIEncoderV2;\n\n\nlibrary ProtocolAdapterTypes {\n    enum OptionType {Invalid, Put, Call}\n\n    // We have 2 types of purchase methods so far - by contract and by 0x.\n    // Contract is simple because it involves just specifying the option terms you want to buy.\n    // ZeroEx involves an off-chain API call which prepares a ZeroExOrder object to be passed into the tx.\n    enum PurchaseMethod {Invalid, Contract, ZeroEx}\n\n    /**\n     * @notice Terms of an options contract\n     * @param underlying is the underlying asset of the options. E.g. For ETH $800 CALL, ETH is the underlying.\n     * @param strikeAsset is the asset used to denote the asset paid out when exercising the option. E.g. For ETH $800 CALL, USDC is the underlying.\n     * @param collateralAsset is the asset used to collateralize a short position for the option.\n     * @param expiry is the expiry of the option contract. Users can only exercise after expiry in Europeans.\n     * @param strikePrice is the strike price of an optio contract. E.g. For ETH $800 CALL, 800*10**18 is the USDC.\n     * @param optionType is the type of option, can only be OptionType.Call or OptionType.Put\n     * @param paymentToken is the token used to purchase the option. E.g. Buy UNI/USDC CALL with WETH as the paymentToken.\n     */\n    struct OptionTerms {\n        address underlying;\n        address strikeAsset;\n        address collateralAsset;\n        uint256 expiry;\n        uint256 strikePrice;\n        ProtocolAdapterTypes.OptionType optionType;\n        address paymentToken;\n    }\n\n    /**\n     * @notice 0x order for purchasing otokens\n     * @param exchangeAddress [deprecated] is the address we call to conduct a 0x trade. Slither flagged this as a potential vulnerability so we hardcoded it.\n     * @param buyTokenAddress is the otoken address\n     * @param sellTokenAddress is the token used to purchase USDC. This is USDC most of the time.\n     * @param allowanceTarget is the address the adapter needs to provide sellToken allowance to so the swap happens\n     * @param protocolFee is the fee paid (in ETH) when conducting the trade\n     * @param makerAssetAmount is the buyToken amount\n     * @param takerAssetAmount is the sellToken amount\n     * @param swapData is the encoded msg.data passed by the 0x api response\n     */\n    struct ZeroExOrder {\n        address exchangeAddress;\n        address buyTokenAddress;\n        address sellTokenAddress;\n        address allowanceTarget;\n        uint256 protocolFee;\n        uint256 makerAssetAmount;\n        uint256 takerAssetAmount;\n        bytes swapData;\n    }\n}\n\ninterface IProtocolAdapter {\n    /**\n     * @notice Emitted when a new option contract is purchased\n     */\n    event Purchased(\n        address indexed caller,\n        string indexed protocolName,\n        address indexed underlying,\n        uint256 amount,\n        uint256 optionID\n    );\n\n    /**\n     * @notice Emitted when an option contract is exercised\n     */\n    event Exercised(\n        address indexed caller,\n        address indexed options,\n        uint256 indexed optionID,\n        uint256 amount,\n        uint256 exerciseProfit\n    );\n\n    /**\n     * @notice Name of the adapter. E.g. \"HEGIC\", \"OPYN_V1\". Used as index key for adapter addresses\n     */\n    function protocolName() external pure returns (string memory);\n\n    /**\n     * @notice Boolean flag to indicate whether to use option IDs or not.\n     * Fungible protocols normally use tokens to represent option contracts.\n     */\n    function nonFungible() external pure returns (bool);\n\n    /**\n     * @notice Returns the purchase method used to purchase options\n     */\n    function purchaseMethod()\n        external\n        pure\n        returns (ProtocolAdapterTypes.PurchaseMethod);\n\n    /**\n     * @notice Check if an options contract exist based on the passed parameters.\n     * @param optionTerms is the terms of the option contract\n     */\n    function optionsExist(ProtocolAdapterTypes.OptionTerms calldata optionTerms)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Get the options contract's address based on the passed parameters\n     * @param optionTerms is the terms of the option contract\n     */\n    function getOptionsAddress(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external view returns (address);\n\n    /**\n     * @notice Gets the premium to buy `purchaseAmount` of the option contract in ETH terms.\n     * @param optionTerms is the terms of the option contract\n     * @param purchaseAmount is the number of options purchased\n     */\n    function premium(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 purchaseAmount\n    ) external view returns (uint256 cost);\n\n    /**\n     * @notice Amount of profit made from exercising an option contract (current price - strike price). 0 if exercising out-the-money.\n     * @param options is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     * @param amount is the amount of tokens or options contract to exercise. Only relevant for fungle protocols like Opyn\n     */\n    function exerciseProfit(\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (uint256 profit);\n\n    function canExercise(\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (bool);\n\n    /**\n     * @notice Purchases the options contract.\n     * @param optionTerms is the terms of the option contract\n     * @param amount is the purchase amount in Wad units (10**18)\n     */\n    function purchase(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 amount,\n        uint256 maxCost\n    ) external payable returns (uint256 optionID);\n\n    /**\n     * @notice Exercises the options contract.\n     * @param options is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     * @param amount is the amount of tokens or options contract to exercise. Only relevant for fungle protocols like Opyn\n     * @param recipient is the account that receives the exercised profits. This is needed since the adapter holds all the positions and the msg.sender is an instrument contract.\n     */\n    function exercise(\n        address options,\n        uint256 optionID,\n        uint256 amount,\n        address recipient\n    ) external payable;\n\n    /**\n     * @notice Opens a short position for a given `optionTerms`.\n     * @param optionTerms is the terms of the option contract\n     * @param amount is the short position amount\n     */\n    function createShort(\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 amount\n    ) external returns (uint256);\n\n    /**\n     * @notice Closes an existing short position. In the future, we may want to open this up to specifying a particular short position to close.\n     */\n    function closeShort() external returns (uint256);\n}\n\n// \n/**\n * @notice ProtocolAdapter is used to shadow IProtocolAdapter to provide functions that delegatecall's the underlying IProtocolAdapter functions.\n */\nlibrary ProtocolAdapter {\n    function delegateOptionsExist(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external view returns (bool) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"optionsExist((address,address,address,uint256,uint256,uint8,address))\",\n                    optionTerms\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (bool));\n    }\n\n    function delegateGetOptionsAddress(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms\n    ) external view returns (address) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"getOptionsAddress((address,address,address,uint256,uint256,uint8,address))\",\n                    optionTerms\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (address));\n    }\n\n    function delegatePremium(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 purchaseAmount\n    ) external view returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"premium((address,address,address,uint256,uint256,uint8,address),uint256)\",\n                    optionTerms,\n                    purchaseAmount\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegateExerciseProfit(\n        IProtocolAdapter adapter,\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"exerciseProfit(address,uint256,uint256)\",\n                    options,\n                    optionID,\n                    amount\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegatePurchase(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 purchaseAmount,\n        uint256 maxCost\n    ) external returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"purchase((address,address,address,uint256,uint256,uint8,address),uint256,uint256)\",\n                    optionTerms,\n                    purchaseAmount,\n                    maxCost\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegatePurchaseWithZeroEx(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        ProtocolAdapterTypes.ZeroExOrder calldata zeroExOrder\n    ) external {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"purchaseWithZeroEx((address,address,address,uint256,uint256,uint8,address),(address,address,address,address,uint256,uint256,uint256,bytes))\",\n                    optionTerms,\n                    zeroExOrder\n                )\n            );\n        revertWhenFail(success, result);\n    }\n\n    function delegateExercise(\n        IProtocolAdapter adapter,\n        address options,\n        uint256 optionID,\n        uint256 amount,\n        address recipient\n    ) external {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"exercise(address,uint256,uint256,address)\",\n                    options,\n                    optionID,\n                    amount,\n                    recipient\n                )\n            );\n        revertWhenFail(success, result);\n    }\n\n    function delegateClaimRewards(\n        IProtocolAdapter adapter,\n        address rewardsAddress,\n        uint256[] calldata optionIDs\n    ) external returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"claimRewards(address,uint256[])\",\n                    rewardsAddress,\n                    optionIDs\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegateRewardsClaimable(\n        IProtocolAdapter adapter,\n        address rewardsAddress,\n        uint256[] calldata optionIDs\n    ) external view returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"rewardsClaimable(address,uint256[])\",\n                    rewardsAddress,\n                    optionIDs\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegateCreateShort(\n        IProtocolAdapter adapter,\n        ProtocolAdapterTypes.OptionTerms calldata optionTerms,\n        uint256 amount\n    ) external returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"createShort((address,address,address,uint256,uint256,uint8,address),uint256)\",\n                    optionTerms,\n                    amount\n                )\n            );\n        revertWhenFail(success, result);\n        return abi.decode(result, (uint256));\n    }\n\n    function delegateCloseShort(IProtocolAdapter adapter)\n        external\n        returns (uint256)\n    {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\"closeShort()\")\n            );\n        require(success, getRevertMsg(result));\n        return abi.decode(result, (uint256));\n    }\n\n    function revertWhenFail(bool success, bytes memory returnData)\n        private\n        pure\n    {\n        if (success) return;\n        revert(getRevertMsg(returnData));\n    }\n\n    function getRevertMsg(bytes memory _returnData)\n        private\n        pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"ProtocolAdapter: reverted\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IProtocolAdapter\",\"name\":\"adapter\",\"type\":\"IProtocolAdapter\"},{\"internalType\":\"address\",\"name\":\"options\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optionID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"delegateExerciseProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocolAdapter\",\"name\":\"adapter\",\"type\":\"IProtocolAdapter\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"enum ProtocolAdapterTypes.OptionType\",\"name\":\"optionType\",\"type\":\"ProtocolAdapterTypes.OptionType\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct ProtocolAdapterTypes.OptionTerms\",\"name\":\"optionTerms\",\"type\":\"tuple\"}],\"name\":\"delegateGetOptionsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocolAdapter\",\"name\":\"adapter\",\"type\":\"IProtocolAdapter\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"enum ProtocolAdapterTypes.OptionType\",\"name\":\"optionType\",\"type\":\"ProtocolAdapterTypes.OptionType\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct ProtocolAdapterTypes.OptionTerms\",\"name\":\"optionTerms\",\"type\":\"tuple\"}],\"name\":\"delegateOptionsExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocolAdapter\",\"name\":\"adapter\",\"type\":\"IProtocolAdapter\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strikeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"enum ProtocolAdapterTypes.OptionType\",\"name\":\"optionType\",\"type\":\"ProtocolAdapterTypes.OptionType\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct ProtocolAdapterTypes.OptionTerms\",\"name\":\"optionTerms\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"purchaseAmount\",\"type\":\"uint256\"}],\"name\":\"delegatePremium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocolAdapter\",\"name\":\"adapter\",\"type\":\"IProtocolAdapter\"},{\"internalType\":\"address\",\"name\":\"rewardsAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"optionIDs\",\"type\":\"uint256[]\"}],\"name\":\"delegateRewardsClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ProtocolAdapter","CompilerVersion":"v0.7.2+commit.51b20bc0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}