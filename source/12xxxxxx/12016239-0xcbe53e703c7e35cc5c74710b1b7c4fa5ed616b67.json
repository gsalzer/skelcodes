{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ens/ENSHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../common/lifecycle/Initializable.sol\\\";\\nimport \\\"./resolvers/ENSAddressResolver.sol\\\";\\nimport \\\"./resolvers/ENSNameResolver.sol\\\";\\nimport \\\"./ENSRegistry.sol\\\";\\n\\n/**\\n * @title ENS helper\\n *\\n * @author Stanisław Głogowski <stan@pillarproject.io>\\n */\\ncontract ENSHelper is Initializable {\\n  ENSRegistry public registry;\\n\\n  /**\\n   * @dev Public constructor\\n   */\\n  constructor() public Initializable() {}\\n\\n  // external functions\\n\\n  /**\\n   * @notice Initializes `ENSLookupHelper` contract\\n   * @param registry_ ENS registry address\\n   */\\n  function initialize(\\n    ENSRegistry registry_\\n  )\\n    external\\n    onlyInitializer\\n  {\\n    registry = registry_;\\n  }\\n\\n  // external functions (views)\\n\\n  /**\\n   * @notice Gets nodes addresses\\n   * @param nodes array of nodes\\n   * @return nodes addresses\\n   */\\n  function getAddresses(\\n    bytes32[] memory nodes\\n  )\\n    external\\n    view\\n    returns (address[] memory)\\n  {\\n    uint nodesLen = nodes.length;\\n    address[] memory result = new address[](nodesLen);\\n\\n    for (uint i = 0; i < nodesLen; i++) {\\n      result[i] = _getAddress(nodes[i]);\\n    }\\n\\n    return result;\\n  }\\n\\n  /**\\n   * @notice Gets nodes names\\n   * @param nodes array of nodes\\n   * @return nodes names\\n   */\\n  function getNames(\\n    bytes32[] memory nodes\\n  )\\n    external\\n    view\\n    returns (string[] memory)\\n  {\\n    uint nodesLen = nodes.length;\\n    string[] memory result = new string[](nodesLen);\\n\\n    for (uint i = 0; i < nodesLen; i++) {\\n      result[i] = _getName(nodes[i]);\\n    }\\n\\n    return result;\\n  }\\n\\n  // private functions (views)\\n\\n  function _getAddress(\\n    bytes32 node\\n  )\\n    private\\n    view\\n    returns (address)\\n  {\\n    address result;\\n    address resolver = registry.resolver(node);\\n\\n    if (resolver != address(0)) {\\n      try ENSAddressResolver(resolver).addr(node) returns (address addr) {\\n        result = addr;\\n      } catch {\\n        //\\n      }\\n    }\\n\\n    return result;\\n  }\\n\\n  function _getName(\\n    bytes32 node\\n  )\\n    private\\n    view\\n    returns (string memory)\\n  {\\n    string memory result;\\n    address resolver = registry.resolver(node);\\n\\n    if (resolver != address(0)) {\\n      try ENSNameResolver(resolver).name(node) returns (string memory name) {\\n        result = name;\\n      } catch {\\n        //\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/common/lifecycle/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Contract module which provides access control mechanism, where\\n * there is the initializer account that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initializer account will be tx.origin during contract deployment and will be removed on first use.\\n * Use `onlyInitializer` modifier on contract initialize process.\\n *\\n * @author Stanisław Głogowski <stan@pillarproject.io>\\n */\\ncontract Initializable {\\n  address private initializer;\\n\\n  // events\\n\\n  /**\\n   * @dev Emitted after `onlyInitializer`\\n   * @param initializer initializer address\\n   */\\n  event Initialized(\\n    address initializer\\n  );\\n\\n  // modifiers\\n\\n  /**\\n   * @dev Throws if tx.origin is not the initializer\\n   */\\n  modifier onlyInitializer() {\\n    require(\\n      // solhint-disable-next-line avoid-tx-origin\\n      tx.origin == initializer,\\n      \\\"Initializable: tx.origin is not the initializer\\\"\\n    );\\n\\n    /// @dev removes initializer\\n    initializer = address(0);\\n\\n    _;\\n\\n    emit Initialized(\\n      // solhint-disable-next-line avoid-tx-origin\\n      tx.origin\\n    );\\n  }\\n\\n  /**\\n   * @dev Internal constructor\\n   */\\n  constructor()\\n    internal\\n  {\\n    // solhint-disable-next-line avoid-tx-origin\\n    initializer = tx.origin;\\n  }\\n\\n   // external functions (views)\\n\\n  /**\\n   * @notice Check if contract is initialized\\n   * @return true when contract is initialized\\n   */\\n  function isInitialized()\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return initializer == address(0);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/ens/resolvers/ENSAddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"./ENSAbstractResolver.sol\\\";\\n\\n\\n/**\\n * @title ENS abstract address resolver\\n *\\n * @dev Base on https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/profiles/AddrResolver.sol\\n */\\nabstract contract ENSAddressResolver is ENSAbstractResolver {\\n  bytes4 internal constant INTERFACE_ADDR_ID = bytes4(keccak256(abi.encodePacked(\\\"addr(bytes32)\\\")));\\n  bytes4 internal constant INTERFACE_ADDRESS_ID = bytes4(keccak256(abi.encodePacked(\\\"addr(bytes32,uint)\\\")));\\n\\n  uint internal constant COIN_TYPE_ETH = 60;\\n\\n  mapping(bytes32 => mapping(uint => bytes)) internal resolverAddresses;\\n\\n  // events\\n\\n  event AddrChanged(\\n    bytes32 indexed node,\\n    address addr\\n  );\\n\\n  event AddressChanged(\\n    bytes32 indexed node,\\n    uint coinType,\\n    bytes newAddress\\n  );\\n\\n  // external functions\\n\\n  function setAddr(\\n    bytes32 node,\\n    address addr_\\n  )\\n    external\\n    onlyNodeOwner(node)\\n  {\\n    _setAddr(node, addr_);\\n  }\\n\\n  function setAddr(\\n    bytes32 node,\\n    uint coinType,\\n    bytes memory addr_\\n  )\\n    external\\n    onlyNodeOwner(node)\\n  {\\n    _setAddr(node, coinType, addr_);\\n  }\\n\\n  // external functions (views)\\n\\n  function addr(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (address)\\n  {\\n    return _addr(node);\\n  }\\n\\n  function addr(\\n    bytes32 node,\\n    uint coinType\\n  )\\n    external\\n    view\\n    returns (bytes memory)\\n  {\\n    return resolverAddresses[node][coinType];\\n  }\\n\\n  // internal functions\\n\\n  function _setAddr(\\n    bytes32 node,\\n    address addr_\\n  )\\n    internal\\n  {\\n    _setAddr(node, COIN_TYPE_ETH, _addressToBytes(addr_));\\n  }\\n\\n  function _setAddr(\\n    bytes32 node,\\n    uint coinType,\\n    bytes memory addr_\\n  )\\n    internal\\n  {\\n    emit AddressChanged(node, coinType, addr_);\\n\\n    if(coinType == COIN_TYPE_ETH) {\\n      emit AddrChanged(node, _bytesToAddress(addr_));\\n    }\\n\\n    resolverAddresses[node][coinType] = addr_;\\n  }\\n\\n  // internal functions (views)\\n\\n  function _addr(\\n    bytes32 node\\n  )\\n    internal\\n    view\\n    returns (address)\\n  {\\n    address result;\\n\\n    bytes memory addr_ = resolverAddresses[node][COIN_TYPE_ETH];\\n\\n    if (addr_.length > 0) {\\n      result = _bytesToAddress(addr_);\\n    }\\n\\n    return result;\\n  }\\n\\n  // private function (pure)\\n\\n  function _bytesToAddress(\\n    bytes memory data\\n  )\\n    private\\n    pure\\n    returns(address payable)\\n  {\\n    address payable result;\\n\\n    require(data.length == 20);\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      result := div(mload(add(data, 32)), exp(256, 12))\\n    }\\n\\n    return result;\\n  }\\n\\n  function _addressToBytes(\\n    address addr_\\n  )\\n    private\\n    pure\\n    returns(bytes memory)\\n  {\\n    bytes memory result = new bytes(20);\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      mstore(add(result, 32), mul(addr_, exp(256, 12)))\\n    }\\n\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/ens/resolvers/ENSNameResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"./ENSAbstractResolver.sol\\\";\\n\\n\\n/**\\n * @title ENS abstract name resolver\\n *\\n * @dev Base on https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/profiles/NameResolver.sol\\n */\\nabstract contract ENSNameResolver is ENSAbstractResolver {\\n  bytes4 internal constant INTERFACE_NAME_ID = bytes4(keccak256(abi.encodePacked(\\\"name(bytes32)\\\")));\\n\\n  mapping(bytes32 => string) internal resolverNames;\\n\\n  // events\\n\\n  event NameChanged(\\n    bytes32 indexed node,\\n    string name\\n  );\\n\\n  // external functions\\n\\n  function setName(\\n    bytes32 node,\\n    string calldata name\\n  )\\n    external\\n    onlyNodeOwner(node)\\n  {\\n    resolverNames[node] = name;\\n\\n    emit NameChanged(node, name);\\n  }\\n\\n  // external functions (views)\\n\\n  function name(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (string memory)\\n  {\\n    return resolverNames[node];\\n  }\\n}\\n\"\r\n    },\r\n    \"src/ens/ENSRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/**\\n * @title ENS registry\\n *\\n * @dev Base on https://github.com/ensdomains/ens/blob/ff0f41747c05f1598973b0fe7ad0d9e09565dfcd/contracts/ENSRegistry.sol\\n */\\ncontract ENSRegistry {\\n  struct Record {\\n    address owner;\\n    address resolver;\\n    uint64 ttl;\\n  }\\n\\n  mapping (bytes32 => Record) private records;\\n  mapping (address => mapping(address => bool)) private operators;\\n\\n  // events\\n\\n  event NewOwner(\\n    bytes32 indexed node,\\n    bytes32 indexed label,\\n    address owner\\n  );\\n\\n  event Transfer(\\n    bytes32 indexed node,\\n    address owner\\n  );\\n\\n  event NewResolver(\\n    bytes32 indexed node,\\n    address resolver\\n  );\\n\\n  event NewTTL(\\n    bytes32 indexed node,\\n    uint64 ttl\\n  );\\n\\n  event ApprovalForAll(\\n    address indexed owner,\\n    address indexed operator,\\n    bool approved\\n  );\\n\\n  // modifiers\\n\\n  modifier authorised(\\n    bytes32 node\\n  )\\n  {\\n    address owner = records[node].owner;\\n\\n    require(\\n      owner == msg.sender || operators[owner][msg.sender],\\n      \\\"ENSRegistry: reverted by authorised modifier\\\"\\n    );\\n\\n    _;\\n  }\\n\\n  /**\\n   * @dev Public constructor\\n   */\\n  constructor()\\n    public\\n  {\\n    // solhint-disable-next-line avoid-tx-origin\\n    records[0x0].owner = tx.origin;\\n  }\\n\\n  // external functions\\n\\n  function setRecord(\\n    bytes32 node,\\n    address owner_,\\n    address resolver_,\\n    uint64 ttl_\\n  )\\n    external\\n  {\\n    setOwner(node, owner_);\\n\\n    _setResolverAndTTL(node, resolver_, ttl_);\\n  }\\n\\n  function setTTL(\\n    bytes32 node,\\n    uint64 ttl_\\n  )\\n    external\\n    authorised(node)\\n  {\\n    records[node].ttl = ttl_;\\n\\n    emit NewTTL(node, ttl_);\\n  }\\n\\n  function setSubnodeRecord(\\n    bytes32 node,\\n    bytes32 label,\\n    address owner_,\\n    address resolver_,\\n    uint64 ttl_\\n  )\\n    external\\n  {\\n    bytes32 subNode = setSubnodeOwner(node, label, owner_);\\n\\n    _setResolverAndTTL(subNode, resolver_, ttl_);\\n  }\\n\\n  function setApprovalForAll(\\n    address operator,\\n    bool approved\\n  )\\n    external\\n  {\\n    operators[msg.sender][operator] = approved;\\n\\n    emit ApprovalForAll(\\n      msg.sender,\\n      operator,\\n      approved\\n    );\\n  }\\n\\n  // external functions (views)\\n\\n  function owner(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (address)\\n  {\\n    address addr = records[node].owner;\\n\\n    if (addr == address(this)) {\\n      return address(0x0);\\n    }\\n\\n    return addr;\\n  }\\n\\n  function resolver(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (address)\\n  {\\n    return records[node].resolver;\\n  }\\n\\n  function ttl(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (uint64)\\n  {\\n    return records[node].ttl;\\n  }\\n\\n  function recordExists(\\n    bytes32 node\\n  )\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return records[node].owner != address(0x0);\\n  }\\n\\n  function isApprovedForAll(\\n    address owner_,\\n    address operator\\n  )\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return operators[owner_][operator];\\n  }\\n\\n  // public functions\\n\\n  function setOwner(\\n    bytes32 node,\\n    address owner_\\n  )\\n    public\\n    authorised(node)\\n  {\\n    records[node].owner = owner_;\\n\\n    emit Transfer(node, owner_);\\n  }\\n\\n  function setResolver(\\n    bytes32 node,\\n    address resolver_\\n  )\\n    public\\n    authorised(node)\\n  {\\n    records[node].resolver = resolver_;\\n\\n    emit NewResolver(node, resolver_);\\n  }\\n\\n  function setSubnodeOwner(\\n    bytes32 node,\\n    bytes32 label,\\n    address owner_\\n  )\\n    public\\n    authorised(node)\\n    returns(bytes32)\\n  {\\n    bytes32 subNode = keccak256(abi.encodePacked(node, label));\\n\\n    records[subNode].owner = owner_;\\n\\n    emit NewOwner(node, label, owner_);\\n\\n    return subNode;\\n  }\\n\\n  // private functions\\n\\n  function _setResolverAndTTL(\\n    bytes32 node,\\n    address resolver_,\\n    uint64 ttl_\\n  )\\n    private\\n  {\\n    if (resolver_ != records[node].resolver) {\\n      records[node].resolver = resolver_;\\n\\n      emit NewResolver(node, resolver_);\\n    }\\n\\n    if (ttl_ != records[node].ttl) {\\n      records[node].ttl = ttl_;\\n\\n      emit NewTTL(node, ttl_);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/ens/resolvers/ENSAbstractResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/**\\n * @title ENS abstract resolver\\n *\\n * @dev Base on https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/ResolverBase.sol\\n */\\nabstract contract ENSAbstractResolver {\\n  // modifiers\\n\\n  modifier onlyNodeOwner(bytes32 node)\\n  {\\n    require(\\n      _isNodeOwner(node),\\n      \\\"ENSAbstractResolver: reverted by onlyNodeOwner modifier\\\"\\n    );\\n\\n    _;\\n  }\\n\\n  // internal functions (views)\\n\\n  function _isNodeOwner(\\n    bytes32 node\\n  )\\n    internal\\n    virtual\\n    view\\n    returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"initializer\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"nodes\",\"type\":\"bytes32[]\"}],\"name\":\"getAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"nodes\",\"type\":\"bytes32[]\"}],\"name\":\"getNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ENSRegistry\",\"name\":\"registry_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract ENSRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ENSHelper","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}