{"status":"1","message":"OK","result":[{"SourceCode":"{\"sale.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./token.sol\\\";\\n\\ncontract FILXTokenSale {\\n    address payable admin;\\n    FilxToken public tokenContract;\\n\\n\\n    constructor(FilxToken _tokenContract) public {\\n        admin = msg.sender;\\n        tokenContract = _tokenContract;\\n    }\\n\\n    function buyTokens(uint256 _numberOfTokens) public payable{\\n        \\n        require(\\n            _numberOfTokens == msg.value / 10**14,\\n            \\\"Number of tokens does not match with the value\\\"\\n        );\\n        \\n\\n        require(\\n            tokenContract.balanceOf(address(this)) \\u003e= _numberOfTokens,\\n            \\\"Contact does not have enough tokens\\\"\\n        );\\n        require(\\n            tokenContract.transfer(msg.sender, _numberOfTokens),\\n            \\\"Some problem with token transfer\\\"\\n        );\\n    }\\n\\n    function endSale() public {\\n        require(msg.sender == admin, \\\"Only the admin can call this function\\\");\\n        require(\\n            tokenContract.transfer(\\n                address(0),\\n                tokenContract.balanceOf(address(this))\\n            ),\\n            \\\"Unable to transfer tokens to 0x0000\\\"\\n        );\\n        // destroy contract\\n        selfdestruct(admin);\\n    }\\n}\"},\"token.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ncontract FilxToken {\\n    string public name = \\\"FILX Token\\\"; \\n    string public symbol = \\\"FILX\\\"; \\n    uint256 public totalSupply;\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _spender,\\n        uint256 _value\\n    );\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n\\n    constructor(uint256 _initialSupply) public {\\n        balanceOf[msg.sender] = _initialSupply;\\n        totalSupply = _initialSupply;\\n    }\\n\\n    function transfer(address _to, uint256 _value)\\n        public\\n        returns (bool success)\\n    {\\n        require(balanceOf[msg.sender] \\u003e= _value, \\\"Not enough balance\\\");\\n        balanceOf[msg.sender] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value)\\n        public\\n        returns (bool success)\\n    {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) public returns (bool success) {\\n        require(\\n            balanceOf[_from] \\u003e= _value,\\n            \\\"_from does not have enough tokens\\\"\\n        );\\n        require(\\n            allowance[_from][msg.sender] \\u003e= _value,\\n            \\\"Spender limit exceeded\\\"\\n        );\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        allowance[_from][msg.sender] -= _value;\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"FILXTokenSale","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000092179e3019fd9885318ef52a39ef53b63a02e10a","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://700a35dab57775bbedceecf7b5c0a8bd2ddb3d49918d52bf0c68e201845adb02"}]}