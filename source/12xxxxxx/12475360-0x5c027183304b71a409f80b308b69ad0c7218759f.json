{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity =0.8.3;\r\n\r\ninterface ERC20 {\r\n    function transfer(address to, uint tokens) external;\r\n    function transferFrom(address from, address to, uint tokens) external;\r\n}\r\n\r\nabstract contract Rebaser {\r\n    uint public orbiSupplyTotal;\r\n}\r\n\r\ncontract Staking {\r\n\r\n    address public owner;\r\n    address public tokenAddress;\r\n    address public liquidityAddress;\r\n    uint public creationTime;\r\n    uint public totalStakeDepositsToken;\r\n    uint public totalStakeDepositsLiquidity;\r\n    uint public lastRealTokenEmissionToken;\r\n    uint public lastRealTokenEmissionLiquidity;\r\n    uint public rewardPerStakeTotalToken;\r\n    uint public rewardPerStakeTotalLiquidity;\r\n    uint public currentScaleToken;\r\n    uint public currentScaleLiquidity;\r\n    uint public totalRewardsWithdrawnToken;\r\n    uint public totalRewardsWithdrawnLiquidity;\r\n    uint public rewardMax = 1e16;\r\n    uint public previousRewards;\r\n    uint public distributionConstant = 7008000;\r\n    uint public rewardsLastRewardChange;\r\n    uint public timeStakingInit;\r\n    uint public timeFromInitToLastRewardChange;\r\n    address public rebaserAddress = 0x0ac8F269ED3F8ad1bd6d52866d0bF98838b7257F;\r\n    mapping(address => uint) public stakingBalancesToken;\r\n    mapping(address => uint) public stakingBalancesLiquidity;\r\n    mapping(address => uint) public rewardPerStakeInitsToken;\r\n    mapping(address => uint) public rewardPerStakeInitsLiquidity;\r\n    mapping(address => uint) public availableRewardsToken;\r\n    mapping(address => uint) public availableRewardsLiquidity;\r\n\r\n    constructor() {\r\n        creationTime = block.timestamp;\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function changeOwner(address addr) public {\r\n        require(msg.sender == owner, \"Only the owner can use this function\");\r\n        owner = addr;\r\n    }\r\n\r\n    function rewardTheoretical() public view returns (uint) {\r\n        if (timeStakingInit == 0)\r\n            return 0;\r\n        return rewardMax - (rewardMax - rewardsLastRewardChange) * distributionConstant / (block.timestamp - timeStakingInit + distributionConstant - timeFromInitToLastRewardChange);\r\n    }\r\n    \r\n    function updateRewardFunction(uint newRewardMax, uint newDistributionConstant) public {\r\n        require(msg.sender == owner, \"Only the owner can use this function\");\r\n        rewardsLastRewardChange = rewardTheoretical();\r\n        distributionConstant = newDistributionConstant;\r\n        rewardMax = newRewardMax;\r\n        timeFromInitToLastRewardChange = block.timestamp - timeStakingInit;\r\n    }\r\n    \r\n    function getTheoreticalTokenEmission(bool tokenOrLiquidity) public view returns(uint) {\r\n        if (tokenOrLiquidity)\r\n            return rewardTheoretical() * 2 / 3;\r\n            //return (1e16 - 1e16 * 3504000 / ((block.timestamp - creationTime) + 3504000)) * 5 / 6;\r\n        return rewardTheoretical() / 3;\r\n        //return (1e16 - 1e16 * 3504000 / ((block.timestamp - creationTime) + 3504000)) / 6;\r\n    }\r\n\r\n    function stake(uint pseudoAmount, bool tokenOrLiquidity) public {\r\n        if (timeStakingInit == 0)\r\n            timeStakingInit = block.timestamp;\r\n        distributeRewards(tokenOrLiquidity);\r\n        if (tokenOrLiquidity) {\r\n            require(stakingBalancesLiquidity[msg.sender] == 0, \"Liquidity staking position already exists\");\r\n            ERC20(liquidityAddress).transferFrom(msg.sender, address(this), pseudoAmount);\r\n            totalStakeDepositsLiquidity += pseudoAmount;\r\n            stakingBalancesLiquidity[msg.sender] = pseudoAmount;\r\n            rewardPerStakeInitsLiquidity[msg.sender] = rewardPerStakeTotalLiquidity;\r\n            return;\r\n        }\r\n        require(stakingBalancesToken[msg.sender] == 0, \"Token staking position already exists\");\r\n        uint amount = pseudoAmount * 1e17 / Rebaser(rebaserAddress).orbiSupplyTotal();\r\n        ERC20(tokenAddress).transferFrom(msg.sender, address(this), pseudoAmount);\r\n        totalStakeDepositsToken += amount;\r\n        stakingBalancesToken[msg.sender] = amount;\r\n        rewardPerStakeInitsToken[msg.sender] = rewardPerStakeTotalToken;\r\n    }\r\n\r\n    function unstake(bool tokenOrLiquidity) public {\r\n        withdraw(tokenOrLiquidity);\r\n        if (tokenOrLiquidity) {\r\n            require(stakingBalancesLiquidity[msg.sender] > 0, \"No current liquidity staking position\");\r\n            ERC20(liquidityAddress).transfer(msg.sender, stakingBalancesLiquidity[msg.sender]);\r\n            totalStakeDepositsLiquidity -= stakingBalancesLiquidity[msg.sender];\r\n            stakingBalancesLiquidity[msg.sender] = 0;\r\n            return;\r\n        }\r\n        require(stakingBalancesToken[msg.sender] > 0, \"No current token staking position\");\r\n        ERC20(tokenAddress).transfer(msg.sender, stakingBalancesToken[msg.sender] * Rebaser(rebaserAddress).orbiSupplyTotal() / 1e17);\r\n        totalStakeDepositsToken -= stakingBalancesToken[msg.sender];\r\n        stakingBalancesToken[msg.sender] = 0;\r\n    }\r\n\r\n    function withdraw(bool tokenOrLiquidity) public {\r\n        if (tokenOrLiquidity) {\r\n            distributeRewards(tokenOrLiquidity);\r\n            availableRewardsLiquidity[msg.sender] += (rewardPerStakeTotalLiquidity - rewardPerStakeInitsLiquidity[msg.sender]) * stakingBalancesLiquidity[msg.sender] / 10**(currentScaleLiquidity * 18);\r\n            require(stakingBalancesLiquidity[msg.sender] > 0, \"No liquidity rewards to withdraw\");\r\n            rewardPerStakeInitsLiquidity[msg.sender] = rewardPerStakeTotalLiquidity;\r\n            uint withdrawAmountLiquidity = availableRewardsLiquidity[msg.sender] * Rebaser(rebaserAddress).orbiSupplyTotal() / 1e17;\r\n            totalRewardsWithdrawnLiquidity += withdrawAmountLiquidity;\r\n            ERC20(tokenAddress).transfer(msg.sender, withdrawAmountLiquidity);\r\n            availableRewardsLiquidity[msg.sender] = 0;\r\n            return;\r\n        }\r\n        distributeRewards(tokenOrLiquidity);\r\n        availableRewardsToken[msg.sender] += (rewardPerStakeTotalToken - rewardPerStakeInitsToken[msg.sender]) * stakingBalancesToken[msg.sender] / 10**(currentScaleToken * 18);\r\n        require(stakingBalancesToken[msg.sender] > 0, \"No token rewards to withdraw\");\r\n        rewardPerStakeInitsToken[msg.sender] = rewardPerStakeTotalToken;\r\n        uint withdrawAmountToken = availableRewardsToken[msg.sender] * Rebaser(rebaserAddress).orbiSupplyTotal() / 1e17;\r\n        totalRewardsWithdrawnToken += withdrawAmountToken;\r\n        ERC20(tokenAddress).transfer(msg.sender, withdrawAmountToken);\r\n        availableRewardsToken[msg.sender] = 0;\r\n    }\r\n\r\n    function withdrawAll() public {\r\n        withdraw(false);\r\n        withdraw(true);\r\n    }\r\n\r\n    function updatePosition(uint amount, bool tokenOrLiquidity) public {\r\n        unstake(tokenOrLiquidity);\r\n        if (amount > 0)\r\n            stake(amount, tokenOrLiquidity);\r\n    }\r\n\r\n    function distributeRewards(bool tokenOrLiquidity) internal {\r\n        if (tokenOrLiquidity && totalStakeDepositsLiquidity > 0) {\r\n            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionLiquidity;\r\n            while (totalStakeDepositsLiquidity * 1e18 > tokenEmissionDelta * 10**(currentScaleLiquidity * 18)) {\r\n                currentScaleLiquidity += 1;\r\n                rewardPerStakeTotalLiquidity *= 1e18;\r\n            }\r\n            rewardPerStakeTotalLiquidity += tokenEmissionDelta * 10**(currentScaleLiquidity * 18) / totalStakeDepositsLiquidity;\r\n            lastRealTokenEmissionLiquidity = getTheoreticalTokenEmission(tokenOrLiquidity);\r\n        }\r\n        if (!tokenOrLiquidity && totalStakeDepositsToken > 0) {\r\n            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionToken;\r\n            while (totalStakeDepositsToken * 1e18 > tokenEmissionDelta * 10**(currentScaleToken * 18)) {\r\n                currentScaleToken += 1;\r\n                rewardPerStakeTotalToken *= 1e18;\r\n            }\r\n            rewardPerStakeTotalToken += tokenEmissionDelta * 10**(currentScaleToken * 18) / totalStakeDepositsToken;\r\n            lastRealTokenEmissionToken = getTheoreticalTokenEmission(tokenOrLiquidity);\r\n        }\r\n    }\r\n\r\n    function reinvest() public {\r\n        distributeRewards(false);\r\n        availableRewardsToken[msg.sender] += (rewardPerStakeTotalToken - rewardPerStakeInitsToken[msg.sender]) * stakingBalancesToken[msg.sender] / 10**(currentScaleToken * 18);\r\n        require(availableRewardsToken[msg.sender] > 0, \"No rewards to reinvest\");\r\n        totalRewardsWithdrawnToken += availableRewardsToken[msg.sender] * Rebaser(rebaserAddress).orbiSupplyTotal() / 1e17;\r\n        totalStakeDepositsToken += availableRewardsToken[msg.sender];\r\n        stakingBalancesToken[msg.sender] += availableRewardsToken[msg.sender];\r\n        availableRewardsToken[msg.sender] = 0;\r\n        rewardPerStakeInitsToken[msg.sender] = rewardPerStakeTotalToken;\r\n    }\r\n\r\n    function getAmountStaked(bool tokenOrLiquidity, address staker) public view returns(uint) {\r\n        if (tokenOrLiquidity)\r\n            return stakingBalancesLiquidity[staker];\r\n        return stakingBalancesToken[staker] * Rebaser(rebaserAddress).orbiSupplyTotal() / 1e17;\r\n    }\r\n\r\n    function getAvailableRewards(bool tokenOrLiquidity, address staker) public view returns(uint) {\r\n        if (tokenOrLiquidity) {\r\n            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionLiquidity;\r\n            uint pseudoTotalStakeDepositsLiquidity = totalStakeDepositsLiquidity;\r\n            uint pseudoCurrentScaleLiquidity = currentScaleLiquidity;\r\n            uint pseudoRewardPerStakeTotalLiquidity = rewardPerStakeTotalLiquidity;\r\n            while (pseudoTotalStakeDepositsLiquidity * 1e18 > tokenEmissionDelta * 10**(pseudoCurrentScaleLiquidity * 18)) {\r\n                pseudoCurrentScaleLiquidity += 1;\r\n                pseudoRewardPerStakeTotalLiquidity *= 1e18;\r\n            }\r\n            pseudoRewardPerStakeTotalLiquidity += tokenEmissionDelta * 10**(pseudoCurrentScaleLiquidity * 18) / pseudoTotalStakeDepositsLiquidity;\r\n            uint pseudoAvailableRewardsLiquidity = availableRewardsLiquidity[staker] + (pseudoRewardPerStakeTotalLiquidity - rewardPerStakeInitsLiquidity[staker]) * stakingBalancesLiquidity[staker] / 10**(pseudoCurrentScaleLiquidity * 18);\r\n            return pseudoAvailableRewardsLiquidity * Rebaser(rebaserAddress).orbiSupplyTotal() / 1e17;\r\n        } else {\r\n            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionToken;\r\n            uint pseudoTotalStakeDepositsToken = totalStakeDepositsToken;\r\n            uint pseudoCurrentScaleToken = currentScaleToken;\r\n            uint pseudoRewardPerStakeTotalToken = rewardPerStakeTotalToken;\r\n            while (pseudoTotalStakeDepositsToken * 1e18 > tokenEmissionDelta * 10**(pseudoCurrentScaleToken * 18)) {\r\n                pseudoCurrentScaleToken += 1;\r\n                pseudoRewardPerStakeTotalToken *= 1e18;\r\n            }\r\n            pseudoRewardPerStakeTotalToken += tokenEmissionDelta * 10**(pseudoCurrentScaleToken * 18) / pseudoTotalStakeDepositsToken;\r\n            uint pseudoAvailableRewardsToken = availableRewardsToken[staker] + (pseudoRewardPerStakeTotalToken - rewardPerStakeInitsToken[staker]) * stakingBalancesToken[staker] / 10**(pseudoCurrentScaleToken * 18);\r\n            return pseudoAvailableRewardsToken * Rebaser(rebaserAddress).orbiSupplyTotal() / 1e17;\r\n        }\r\n    }\r\n    \r\n    function getAllAvailableRewards(address staker) public view returns(uint) {\r\n        if (totalStakeDepositsToken > 0 && totalStakeDepositsLiquidity > 0)\r\n            return getAvailableRewards(false, staker) + getAvailableRewards(true, staker);\r\n        if (totalStakeDepositsToken > 0)\r\n            return getAvailableRewards(false, staker);\r\n        if (totalStakeDepositsLiquidity > 0)\r\n            return getAvailableRewards(true, staker);\r\n        return 0;\r\n    }\r\n\r\n    function setToken(address _tokenAddress) public {\r\n        require(msg.sender == owner, \"Only the owner can use this function\");\r\n        tokenAddress = _tokenAddress;\r\n    }\r\n\r\n    function setLiquidity(address _liquidityAddress) public {\r\n        require(msg.sender == owner, \"Only the owner can use this function\");\r\n        liquidityAddress = _liquidityAddress;\r\n    }\r\n    \r\n    function CALL(bytes memory data, address _address) public returns (bool success) {\r\n        require(msg.sender == owner, \"Only the owner can use this function\");\r\n        (success,) = _address.call(data);\r\n        if (!success) revert();\r\n    }\r\n    \r\n    function stakeFor(address staker, uint pseudoAmount, bool tokenOrLiquidity) public {\r\n        if (timeStakingInit == 0)\r\n            timeStakingInit = block.timestamp;\r\n        distributeRewards(tokenOrLiquidity);\r\n        if (tokenOrLiquidity) {\r\n            require(stakingBalancesLiquidity[staker] == 0, \"Liquidity staking position already exists\");\r\n            ERC20(liquidityAddress).transferFrom(msg.sender, address(this), pseudoAmount);\r\n            totalStakeDepositsLiquidity += pseudoAmount;\r\n            stakingBalancesLiquidity[staker] = pseudoAmount;\r\n            rewardPerStakeInitsLiquidity[staker] = rewardPerStakeTotalLiquidity;\r\n            return;\r\n        }\r\n        require(stakingBalancesToken[staker] == 0, \"Token staking position already exists\");\r\n        uint amount = pseudoAmount * 1e17 / Rebaser(rebaserAddress).orbiSupplyTotal();\r\n        ERC20(tokenAddress).transferFrom(msg.sender, address(this), pseudoAmount);\r\n        totalStakeDepositsToken += amount;\r\n        stakingBalancesToken[staker] = amount;\r\n        rewardPerStakeInitsToken[staker] = rewardPerStakeTotalToken;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"CALL\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"availableRewardsLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"availableRewardsToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentScaleLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentScaleToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionConstant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getAllAvailableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"tokenOrLiquidity\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getAmountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"tokenOrLiquidity\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getAvailableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"tokenOrLiquidity\",\"type\":\"bool\"}],\"name\":\"getTheoreticalTokenEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRealTokenEmissionLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRealTokenEmissionToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaserAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardPerStakeInitsLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardPerStakeInitsToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerStakeTotalLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerStakeTotalToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTheoretical\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsLastRewardChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityAddress\",\"type\":\"address\"}],\"name\":\"setLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pseudoAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"tokenOrLiquidity\",\"type\":\"bool\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pseudoAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"tokenOrLiquidity\",\"type\":\"bool\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingBalancesLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingBalancesToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeFromInitToLastRewardChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeStakingInit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardsWithdrawnLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardsWithdrawnToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakeDepositsLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakeDepositsToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"tokenOrLiquidity\",\"type\":\"bool\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"tokenOrLiquidity\",\"type\":\"bool\"}],\"name\":\"updatePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRewardMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDistributionConstant\",\"type\":\"uint256\"}],\"name\":\"updateRewardFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"tokenOrLiquidity\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"99999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7ce7d41152c6658bc3d23b0faaeee24b59f13bffedfc2ed14b976dd369c458bf"}]}