{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/abstracts/Manageable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\n\\nabstract contract Manageable is AccessControlUpgradeable {\\n    bytes32 public constant MANAGER_ROLE = keccak256(\\\"MANAGER_ROLE\\\");\\n\\n    modifier onlyManager() {\\n        require(\\n            hasRole(MANAGER_ROLE, _msgSender()),\\n            \\\"Caller is not a manager role\\\"\\n        );\\n        _;\\n    }\\n\\n    /** Roles management - only for multi sig address */\\n    function setupRole(bytes32 role, address account) external onlyManager {\\n        _setupRole(role, account);\\n    }\\n\\n    function isManager() external view returns (bool) {\\n        return hasRole(MANAGER_ROLE, _msgSender());\\n    }\\n} \"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable {\\n    function __AccessControl_init() internal initializer {\\n        __Context_init_unchained();\\n        __AccessControl_init_unchained();\\n    }\\n\\n    function __AccessControl_init_unchained() internal initializer {\\n    }\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using AddressUpgradeable for address;\\n\\n    struct RoleData {\\n        EnumerableSetUpgradeable.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mining/AxionMineManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.8;\\n\\nimport './AxionMine.sol';\\nimport '../abstracts/Manageable.sol';\\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\\n\\ncontract AxionMineManager is Initializable, Manageable {\\n    address[] internal mineAddresses;\\n\\n    IUniswapV2Factory internal uniswapFactory;\\n\\n    address public rewardTokenAddress;\\n    address public liqRepNFTAddress;\\n    address public OG5555_25NFTAddress;\\n    address public OG5555_100NFTAddress;\\n\\n    function createMine(\\n        address _lpTokenAddress,\\n        uint256 _rewardTokenAmount,\\n        uint256 _blockReward,\\n        uint256 _startBlock\\n    ) external onlyManager {\\n        require(_startBlock >= block.number, 'PAST_START_BLOCK');\\n\\n        IUniswapV2Pair lpPair = IUniswapV2Pair(_lpTokenAddress);\\n\\n        address lpPairAddress =\\n            uniswapFactory.getPair(lpPair.token0(), lpPair.token1());\\n\\n        require(lpPairAddress == _lpTokenAddress, 'UNISWAP_PAIR_NOT_FOUND');\\n\\n        TransferHelper.safeTransferFrom(\\n            rewardTokenAddress,\\n            msg.sender,\\n            address(this),\\n            _rewardTokenAmount\\n        );\\n\\n        AxionMine mine = new AxionMine(msg.sender);\\n\\n        TransferHelper.safeApprove(\\n            rewardTokenAddress,\\n            address(mine),\\n            _rewardTokenAmount\\n        );\\n        \\n        mine.initialize(\\n            rewardTokenAddress,\\n            _rewardTokenAmount,\\n            _lpTokenAddress,\\n            _startBlock,\\n            _blockReward,\\n            liqRepNFTAddress,\\n            OG5555_25NFTAddress,\\n            OG5555_100NFTAddress\\n        );\\n\\n        mineAddresses.push(address(mine));\\n    }\\n\\n    function deleteMine(uint256 index) external onlyManager {\\n        delete mineAddresses[index];\\n    }\\n\\n    function initialize(\\n        address _manager,\\n        address _rewardTokenAddress,\\n        address _liqRepNFTAddress,\\n        address _OG5555_25NFTAddress,\\n        address _OG5555_100NFTAddress,\\n        address _uniswapFactoryAddress\\n    ) public initializer {\\n        _setupRole(MANAGER_ROLE, _manager);\\n\\n        rewardTokenAddress = _rewardTokenAddress;\\n        liqRepNFTAddress = _liqRepNFTAddress;\\n        OG5555_25NFTAddress = _OG5555_25NFTAddress;\\n        OG5555_100NFTAddress = _OG5555_100NFTAddress;\\n\\n        uniswapFactory = IUniswapV2Factory(_uniswapFactoryAddress);\\n    }\\n\\n    function getMineAddresses() external view returns (address[] memory) {\\n        return mineAddresses;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mining/AxionMine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.8;\\n\\nimport '../abstracts/Manageable.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\\n\\ncontract AxionMine is Initializable, Manageable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    struct Miner {\\n        uint256 lpDeposit;\\n        uint256 accReward;\\n    }\\n\\n    struct Mine {\\n        IERC20 lpToken;\\n        IERC20 rewardToken;\\n        uint256 startBlock;\\n        uint256 lastRewardBlock;\\n        uint256 blockReward;\\n        uint256 accRewardPerLPToken;\\n        IERC721 liqRepNFT;\\n        IERC721 OG5555_25NFT;\\n        IERC721 OG5555_100NFT;\\n    }\\n\\n    Mine public mineInfo;\\n\\n    mapping(address => Miner) public minerInfo;\\n\\n    event Deposit(address indexed minerAddress, uint256 lpTokenAmount);\\n    event Withdraw(address indexed minerAddress, uint256 lpTokenAmount);\\n    event WithdrawReward(\\n        address indexed minerAddress,\\n        uint256 rewardTokenAmount\\n    );\\n\\n    modifier mineUpdater() {\\n        updateMine();\\n        _;\\n    }\\n\\n    function updateMine() internal {\\n        if (block.number <= mineInfo.lastRewardBlock) {\\n            return;\\n        }\\n\\n        uint256 lpSupply = mineInfo.lpToken.balanceOf(address(this));\\n\\n        if (lpSupply != 0) {\\n            mineInfo.accRewardPerLPToken = getAccRewardPerLPToken(lpSupply);\\n        }\\n\\n        mineInfo.lastRewardBlock = block.number;\\n    }\\n\\n    function getAccRewardPerLPToken(uint256 _lpSupply)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 newBlocks = block.number.sub(mineInfo.lastRewardBlock);\\n        uint256 reward = newBlocks.mul(mineInfo.blockReward);\\n\\n        return\\n            mineInfo.accRewardPerLPToken.add(reward.mul(1e12).div(_lpSupply));\\n    }\\n\\n    function getAccReward(uint256 _lpDeposit) internal view returns (uint256) {\\n        return _lpDeposit.mul(mineInfo.accRewardPerLPToken).div(1e12);\\n    }\\n\\n    function withdrawReward() external mineUpdater {\\n        Miner storage miner = minerInfo[msg.sender];\\n\\n        uint256 accReward = getAccReward(miner.lpDeposit);\\n\\n        uint256 reward = handleNFT(accReward.sub(miner.accReward));\\n\\n        require(reward != 0, 'NOTHING_TO_WITHDRAW');\\n        \\n        miner.accReward = accReward;\\n\\n        safeRewardTransfer(reward);\\n\\n        emit WithdrawReward(msg.sender, reward);\\n    }\\n\\n    function depositLPTokens(uint256 _amount) external mineUpdater {\\n        require(_amount != 0, 'ZERO_AMOUNT');\\n\\n        Miner storage miner = minerInfo[msg.sender];\\n\\n        uint256 reward = getReward(miner);\\n\\n        if (reward != 0) {\\n            safeRewardTransfer(reward);\\n            emit WithdrawReward(msg.sender, reward);\\n        }\\n\\n        mineInfo.lpToken.safeTransferFrom(\\n            address(msg.sender),\\n            address(this),\\n            _amount\\n        );\\n        emit Deposit(msg.sender, _amount);\\n\\n        miner.lpDeposit = miner.lpDeposit.add(_amount);\\n        miner.accReward = getAccReward(miner.lpDeposit);\\n    }\\n\\n    function withdrawLPTokens(uint256 _amount) external mineUpdater {\\n        Miner storage miner = minerInfo[msg.sender];\\n\\n        require(miner.lpDeposit != 0, 'NOTHING_TO_WITHDRAW');\\n        require(miner.lpDeposit >= _amount, 'INVALID_AMOUNT');\\n\\n        uint256 reward = getReward(miner);\\n\\n        miner.lpDeposit = miner.lpDeposit.sub(_amount);\\n        miner.accReward = getAccReward(miner.lpDeposit);\\n\\n        if (reward != 0) {\\n            safeRewardTransfer(reward);\\n            emit WithdrawReward(msg.sender, reward);\\n        }\\n\\n        mineInfo.lpToken.safeTransfer(address(msg.sender), _amount);\\n        emit Withdraw(msg.sender, _amount);\\n    }\\n\\n    function withdrawAll() external mineUpdater {\\n        Miner storage miner = minerInfo[msg.sender];\\n\\n        require(miner.lpDeposit != 0, 'NOTHING_TO_WITHDRAW');\\n\\n        uint256 reward = getReward(miner);\\n        uint256 userLpDeposit = miner.lpDeposit;\\n        miner.lpDeposit = 0;\\n        miner.accReward = 0;\\n\\n        if (reward != 0) {\\n            safeRewardTransfer(reward);\\n            emit WithdrawReward(msg.sender, reward);\\n        }\\n\\n        mineInfo.lpToken.safeTransfer(address(msg.sender), userLpDeposit);\\n        emit Withdraw(msg.sender, userLpDeposit);\\n\\n\\n    }\\n\\n    function safeRewardTransfer(uint256 _amount) internal {\\n        uint256 rewardBalance = mineInfo.rewardToken.balanceOf(address(this));\\n        if (rewardBalance == 0) return;\\n\\n        if (_amount > rewardBalance) {\\n            mineInfo.rewardToken.transfer(msg.sender, rewardBalance);\\n        } else {\\n            mineInfo.rewardToken.transfer(msg.sender, _amount);\\n        }\\n    }\\n\\n    function getReward(Miner storage miner) internal view returns (uint256) {\\n        return handleNFT(getAccReward(miner.lpDeposit).sub(miner.accReward));\\n    }\\n\\n    function handleNFT(uint256 _amount) internal view returns (uint256) {\\n        uint256 penalty = _amount.div(10);\\n\\n        if (mineInfo.liqRepNFT.balanceOf(msg.sender) == 0) {\\n            _amount = _amount.sub(penalty);\\n        }\\n\\n        if (mineInfo.OG5555_25NFT.balanceOf(msg.sender) == 0) {\\n            _amount = _amount.sub(penalty);\\n        }\\n\\n        if (mineInfo.OG5555_100NFT.balanceOf(msg.sender) == 0) {\\n            _amount = _amount.sub(penalty);\\n        }\\n\\n        return _amount;\\n    }\\n\\n    function transferRewardTokens(address _to) external onlyManager {\\n        uint256 rewardBalance = mineInfo.rewardToken.balanceOf(address(this));\\n        mineInfo.rewardToken.transfer(_to, rewardBalance);\\n    }\\n\\n    constructor(address _mineManager) public {\\n        _setupRole(MANAGER_ROLE, _mineManager);\\n    }\\n\\n    function initialize(\\n        address _rewardTokenAddress,\\n        uint256 _rewardTokenAmount,\\n        address _lpTokenAddress,\\n        uint256 _startBlock,\\n        uint256 _blockReward,\\n        address _liqRepNFTAddress,\\n        address _OG5555_25NFTAddress,\\n        address _OG5555_100NFTAddress\\n    ) public initializer {\\n        TransferHelper.safeTransferFrom(\\n            address(_rewardTokenAddress),\\n            msg.sender,\\n            address(this),\\n            _rewardTokenAmount\\n        );\\n\\n        uint256 lastRewardBlock =\\n            block.number > _startBlock ? block.number : _startBlock;\\n\\n        mineInfo = Mine(\\n            IERC20(_lpTokenAddress),\\n            IERC20(_rewardTokenAddress),\\n            _startBlock,\\n            lastRewardBlock,\\n            _blockReward,\\n            0,\\n            IERC721(_liqRepNFTAddress),\\n            IERC721(_OG5555_25NFTAddress),\\n            IERC721(_OG5555_100NFTAddress)\\n        );\\n    }\\n\\n    function getPendingReward() external view returns (uint256) {\\n        uint256 rewardBalance = mineInfo.rewardToken.balanceOf(address(this));\\n        if (rewardBalance == 0) return 0;\\n\\n        Miner storage miner = minerInfo[msg.sender];\\n\\n        uint256 accRewardPerLPToken = mineInfo.accRewardPerLPToken;\\n        uint256 lpSupply = mineInfo.lpToken.balanceOf(address(this));\\n\\n        if (block.number > mineInfo.lastRewardBlock && lpSupply != 0) {\\n            accRewardPerLPToken = getAccRewardPerLPToken(lpSupply);\\n        }\\n\\n        return\\n            handleNFT(\\n                miner.lpDeposit.mul(accRewardPerLPToken).div(1e12).sub(\\n                    miner.accReward\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"../../math/SafeMathUpgradeable.sol\\\";\\nimport \\\"../../proxy/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\\n    using SafeMathUpgradeable for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n    uint256[44] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n/** OpenZeppelin Dependencies Upgradeable */\\n// import \\\"@openzeppelin/contracts-upgradeable/contracts/proxy/Initializable.sol\\\";\\nimport '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\\n/** OpenZepplin non-upgradeable Swap Token (hex3t) */\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n/** Local Interfaces */\\nimport './interfaces/IToken.sol';\\n\\ncontract Token is\\n    IToken,\\n    Initializable,\\n    ERC20Upgradeable,\\n    AccessControlUpgradeable\\n{\\n    using SafeMathUpgradeable for uint256;\\n\\n    /** Role Variables */\\n    bytes32 public constant MIGRATOR_ROLE = keccak256('MIGRATOR_ROLE');\\n    bytes32 private constant MANAGER_ROLE = keccak256('MANAGER_ROLE');\\n    bytes32 private constant MINTER_ROLE = keccak256('MINTER_ROLE');\\n    bytes32 private constant SWAPPER_ROLE = keccak256('SWAPPER_ROLE');\\n    bytes32 private constant SETTER_ROLE = keccak256('SETTER_ROLE');\\n\\n    IERC20 private swapToken;\\n    bool private swapIsOver;\\n    uint256 public swapTokenBalance;\\n    bool public init_;\\n\\n    /** Role Modifiers */\\n    modifier onlyMinter() {\\n        require(hasRole(MINTER_ROLE, _msgSender()), 'Caller is not a minter');\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        require(hasRole(MANAGER_ROLE, _msgSender()), 'Caller is not a manager');\\n        _;\\n    }\\n\\n    modifier onlyMigrator() {\\n        require(\\n            hasRole(MIGRATOR_ROLE, _msgSender()),\\n            'Caller is not a migrator'\\n        );\\n        _;\\n    }\\n\\n    /** Initialize functions */\\n    function initialize(\\n        address _manager,\\n        address _migrator,\\n        string memory _name,\\n        string memory _symbol\\n    ) public initializer {\\n        _setupRole(MANAGER_ROLE, _manager);\\n        _setupRole(MIGRATOR_ROLE, _migrator);\\n        __ERC20_init(_name, _symbol);\\n\\n        /** I do not understand this */\\n        swapIsOver = false;\\n    }\\n\\n    function initSwapperAndSwapToken(address _swapToken, address _swapper)\\n        external\\n        onlyMigrator\\n    {\\n        /** Setup */\\n        _setupRole(SWAPPER_ROLE, _swapper);\\n        swapToken = IERC20(_swapToken);\\n    }\\n\\n    function init(address[] calldata instances) external onlyMigrator {\\n        require(!init_, 'NativeSwap: init is active');\\n        init_ = true;\\n\\n        for (uint256 index = 0; index < instances.length; index++) {\\n            _setupRole(MINTER_ROLE, instances[index]);\\n        }\\n        swapIsOver = true;\\n    }\\n\\n    /** End initialize Functions */\\n\\n    function getMinterRole() external pure returns (bytes32) {\\n        return MINTER_ROLE;\\n    }\\n\\n    function getSwapperRole() external pure returns (bytes32) {\\n        return SWAPPER_ROLE;\\n    }\\n\\n    function getSetterRole() external pure returns (bytes32) {\\n        return SETTER_ROLE;\\n    }\\n\\n    function getSwapTOken() external view returns (IERC20) {\\n        return swapToken;\\n    }\\n\\n    function getSwapTokenBalance(uint256) external view returns (uint256) {\\n        return swapTokenBalance;\\n    }\\n\\n    function mint(address to, uint256 amount) external override onlyMinter {\\n        _mint(to, amount);\\n    }\\n\\n    function burn(address from, uint256 amount) external override onlyMinter {\\n        _burn(from, amount);\\n    }\\n\\n    // Helpers\\n    function getNow() external view returns (uint256) {\\n        return now;\\n    }\\n\\n    /** Roles management - only for multi sig address */\\n    function setupRole(bytes32 role, address account) external onlyManager {\\n        _setupRole(role, account);\\n    }\\n\\n    function recovery(\\n        address recoverFor,\\n        address tokenToRecover,\\n        uint256 amount\\n    ) external onlyMigrator {\\n        IERC20(tokenToRecover).transfer(recoverFor, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IToken {\\n    function mint(address to, uint256 amount) external;\\n\\n    function burn(address from, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/NativeSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n\\n/** OpenZeppelin Dependencies Upgradable */\\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\\nimport '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\\n/** OpenZeppelin non ugpradable (Needed for the \\\"Swap Token hex3t\\\") */\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n/** Local Interfaces */\\nimport './interfaces/IToken.sol';\\nimport './interfaces/IAuction.sol';\\n\\ncontract NativeSwap is Initializable, AccessControlUpgradeable {\\n    using SafeMathUpgradeable for uint256;\\n\\n    event TokensSwapped(\\n        address indexed account,\\n        uint256 indexed stepsFromStart,\\n        uint256 userAmount,\\n        uint256 penaltyAmount\\n    );\\n\\n    /** Role variables */\\n    bytes32 public constant MIGRATOR_ROLE = keccak256('MIGRATOR_ROLE');\\n    bytes32 public constant MANAGER_ROLE = keccak256('MANAGER_ROLE');\\n    /** Basic variables */\\n    uint256 public start;\\n    uint256 public period;\\n    uint256 public stepTimestamp;\\n    /** Contract Variables */\\n    IERC20 public swapToken;\\n    IToken public mainToken;\\n    IAuction public auction;\\n    /** Mappings */\\n    mapping(address => uint256) public swapTokenBalanceOf;\\n\\n    /** Booleans */\\n    bool public init_;\\n\\n    /** Variables after initial contract launch must go below here. https://github.com/OpenZeppelin/openzeppelin-sdk/issues/37 */\\n    /** End Variables after launch */\\n\\n    /** Roles */\\n    modifier onlyManager() {\\n        require(hasRole(MANAGER_ROLE, _msgSender()), 'Caller is not a manager');\\n        _;\\n    }\\n    modifier onlyMigrator() {\\n        require(\\n            hasRole(MIGRATOR_ROLE, _msgSender()),\\n            'Caller is not a migrator'\\n        );\\n        _;\\n    }\\n\\n    /** Init functions */\\n    function initialize(address _manager, address _migrator)\\n        public\\n        initializer\\n    {\\n        _setupRole(MANAGER_ROLE, _manager);\\n        _setupRole(MIGRATOR_ROLE, _migrator);\\n        init_ = false;\\n    }\\n\\n    function init(\\n        uint256 _period,\\n        uint256 _stepTimestamp,\\n        address _swapToken,\\n        address _mainToken,\\n        address _auction\\n    ) external onlyMigrator {\\n        require(!init_, 'init is active');\\n        init_ = true;\\n\\n        period = _period;\\n        stepTimestamp = _stepTimestamp;\\n        swapToken = IERC20(_swapToken);\\n        mainToken = IToken(_mainToken);\\n        auction = IAuction(_auction);\\n\\n        if (start == 0) {\\n            start = now;\\n        }\\n    }\\n\\n    /** End init functions */\\n\\n    function deposit(uint256 _amount) external {\\n        require(\\n            swapToken.transferFrom(msg.sender, address(this), _amount),\\n            'NativeSwap: transferFrom error'\\n        );\\n        swapTokenBalanceOf[msg.sender] = swapTokenBalanceOf[msg.sender].add(\\n            _amount\\n        );\\n    }\\n\\n    function withdraw(uint256 _amount) external {\\n        require(_amount >= swapTokenBalanceOf[msg.sender], 'balance < amount');\\n        swapTokenBalanceOf[msg.sender] = swapTokenBalanceOf[msg.sender].sub(\\n            _amount\\n        );\\n        swapToken.transfer(msg.sender, _amount);\\n    }\\n\\n    function swapNativeToken() external {\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n        require(stepsFromStart <= period, 'swapNativeToken: swap is over');\\n        uint256 amount = swapTokenBalanceOf[msg.sender];\\n        require(amount != 0, 'swapNativeToken: amount == 0');\\n        uint256 deltaPenalty = calculateDeltaPenalty(amount);\\n        uint256 amountOut = amount.sub(deltaPenalty);\\n        swapTokenBalanceOf[msg.sender] = 0;\\n        mainToken.mint(address(auction), deltaPenalty);\\n        auction.callIncomeDailyTokensTrigger(deltaPenalty);\\n        mainToken.mint(msg.sender, amountOut);\\n\\n        emit TokensSwapped(msg.sender, stepsFromStart, amount, deltaPenalty);\\n    }\\n\\n    function calculateDeltaPenalty(uint256 amount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n        if (stepsFromStart > period) return amount;\\n        return amount.mul(stepsFromStart).div(period);\\n    }\\n\\n    function calculateStepsFromStart() public view returns (uint256) {\\n        return now.sub(start).div(stepTimestamp);\\n    }\\n\\n    /** Roles management - only for multi sig address */\\n    function setupRole(bytes32 role, address account) external onlyManager {\\n        _setupRole(role, account);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IAuction {\\n    function callIncomeDailyTokensTrigger(uint256 amount) external;\\n\\n    function callIncomeWeeklyTokensTrigger(uint256 amount) external;\\n\\n    function addReservesToAuction(uint256 daysInFuture, uint256 amount) external returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/restorable/NativeSwapRestorable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n/** OpenZeppelin Dependencies Upgradeable */\\n// import \\\"@openzeppelin/contracts-upgradeable/contracts/proxy/Initializable.sol\\\";\\nimport '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\\n/** OpenZepplin non-upgradeable Swap Token (hex3t) */\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n/** Local Interfaces */\\nimport '../NativeSwap.sol';\\n\\ncontract NativeSwapRestorable is NativeSwap {\\n    /* Setter methods for contract migration */\\n    function setStart(uint256 _start) external onlyMigrator {\\n        start = _start;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/UniswapV2Router02Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract UniswapV2Router02Mock {\\n    address public WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n    uint256 public lastAmountsOutMin;\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts) {\\n        (deadline);\\n        IERC20(path[1]).transfer(to, 0);\\n        uint256[] memory amountsOut = new uint256[](2);\\n        amountsOut[0] = msg.value;\\n        amountsOut[1] = amountOutMin;\\n        lastAmountsOutMin = amountOutMin;\\n        return amountsOut;\\n    }\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        pure\\n        returns (uint256[] memory amounts)\\n    {\\n        (path);\\n        uint256[] memory amountsOut = new uint256[](2);\\n        amountsOut[0] = amountIn;\\n        amountsOut[1] = amountIn;\\n        return amountsOut;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/restorable/TokenRestorable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n/** OpenZeppelin Dependencies Upgradeable */\\n// import \\\"@openzeppelin/contracts-upgradeable/contracts/proxy/Initializable.sol\\\";\\nimport '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\\n/** OpenZepplin non-upgradeable Swap Token (hex3t) */\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n/** Local Interfaces */\\nimport '../Token.sol';\\n\\ncontract TokenRestorable is Token {\\n    /* Setter methods for contract migration */\\n    function setNormalVariables(uint256 _swapTokenBalance)\\n        external\\n        onlyMigrator\\n    {\\n        swapTokenBalance = _swapTokenBalance;\\n    }\\n\\n    function bulkMint(\\n        address[] calldata userAddresses,\\n        uint256[] calldata amounts\\n    ) external onlyMigrator {\\n        for (uint256 idx = 0; idx < userAddresses.length; idx = idx + 1) {\\n            _mint(userAddresses[idx], amounts[idx]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/restorable/StakingRestorable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n/** OpenZeppelin Dependencies Upgradeable */\\n// import \\\"@openzeppelin/contracts-upgradeable/contracts/proxy/Initializable.sol\\\";\\nimport '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\\n/** OpenZepplin non-upgradeable Swap Token (hex3t) */\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n/** Local Interfaces */\\nimport '../Staking.sol';\\n\\ncontract StakingRestorable is Staking {\\n    function init(\\n        address _mainTokenAddress,\\n        address _auctionAddress,\\n        address _stakingV1Address,\\n        uint256 _stepTimestamp,\\n        uint256 _lastSessionIdV1\\n    ) external onlyMigrator {\\n        require(!init_, 'Staking: init is active');\\n        init_ = true;\\n        /** Setup */\\n        _setupRole(EXTERNAL_STAKER_ROLE, _auctionAddress);\\n\\n        addresses = Addresses({\\n            mainToken: _mainTokenAddress,\\n            auction: _auctionAddress,\\n            subBalances: address(0)\\n        });\\n\\n        stakingV1 = IStakingV1(_stakingV1Address);\\n        stepTimestamp = _stepTimestamp;\\n\\n        if (startContract == 0) {\\n            startContract = now;\\n            nextPayoutCall = startContract.add(_stepTimestamp);\\n        }\\n        if (_lastSessionIdV1 != 0) {\\n            lastSessionIdV1 = _lastSessionIdV1;\\n        }\\n        if (shareRate == 0) {\\n            shareRate = 1e18;\\n        }\\n    }\\n\\n    function addStakedAmount(uint256 _staked) external onlyMigrator {\\n        totalStakedAmount = totalStakedAmount.add(_staked);\\n    }\\n\\n    function addShareTotalSupply(uint256 _shares) external onlyMigrator {\\n        sharesTotalSupply = sharesTotalSupply.add(_shares);\\n    }\\n\\n    // migration functions\\n    function setOtherVars(\\n        uint256 _startTime,\\n        uint256 _shareRate,\\n        uint256 _sharesTotalSupply,\\n        uint256 _nextPayoutCall,\\n        uint256 _globalPayin,\\n        uint256 _globalPayout,\\n        uint256[] calldata _payouts,\\n        uint256[] calldata _sharesTotalSupplyVec,\\n        uint256 _lastSessionId\\n    ) external onlyMigrator {\\n        startContract = _startTime;\\n        shareRate = _shareRate;\\n        sharesTotalSupply = _sharesTotalSupply;\\n        nextPayoutCall = _nextPayoutCall;\\n        globalPayin = _globalPayin;\\n        globalPayout = _globalPayout;\\n        lastSessionId = _lastSessionId;\\n        lastSessionIdV1 = _lastSessionId;\\n\\n        for (uint256 i = 0; i < _payouts.length; i++) {\\n            payouts.push(\\n                Payout({\\n                    payout: _payouts[i],\\n                    sharesTotalSupply: _sharesTotalSupplyVec[i]\\n                })\\n            );\\n        }\\n    }\\n\\n    function setSessionsOf(\\n        address[] calldata _wallets,\\n        uint256[] calldata _sessionIds\\n    ) external onlyMigrator {\\n        for (uint256 idx = 0; idx < _wallets.length; idx = idx.add(1)) {\\n            sessionsOf[_wallets[idx]].push(_sessionIds[idx]);\\n        }\\n    }\\n\\n    function setBasePeriod(uint256 _basePeriod) external onlyMigrator {\\n        basePeriod = _basePeriod;\\n    }\\n\\n    /** TESTING ONLY */\\n    function setLastSessionId(uint256 _lastSessionId) external onlyMigrator {\\n        lastSessionIdV1 = _lastSessionId.sub(1);\\n        lastSessionId = _lastSessionId;\\n    }\\n\\n    function setSharesTotalSupply(uint256 _sharesTotalSupply)\\n        external\\n        onlyMigrator\\n    {\\n        sharesTotalSupply = _sharesTotalSupply;\\n    }\\n\\n    function setTotalStakedAmount(uint256 _totalStakedAmount)\\n        external\\n        onlyMigrator\\n    {\\n        totalStakedAmount = _totalStakedAmount;\\n    }\\n\\n    /**\\n     * Fix stake\\n     * */\\n    // function fixShareRateOnStake(address _staker, uint256 _stakeId)\\n    //     external\\n    //     onlyMigrator\\n    // {\\n    //     Session storage session = sessionDataOf[_staker][_stakeId]; // Get Session\\n    //     require(\\n    //         session.withdrawn == false && session.shares != 0,\\n    //         'STAKING: Session has already been withdrawn'\\n    //     );\\n    //     sharesTotalSupply = sharesTotalSupply.sub(session.shares); // Subtract shares total share supply\\n    //     session.shares = _getStakersSharesAmount(\\n    //         session.amount,\\n    //         session.start,\\n    //         session.end\\n    //     ); // update shares\\n    //     sharesTotalSupply = sharesTotalSupply.add(session.shares); // Add to total share suuply\\n    // }\\n\\n    /**\\n     * Fix v1 unstakers\\n     * Unfortunately due to people not understanding that we were updating to v2, we need to fix some of our users stakes\\n     * This code will be removed as soon as we fix stakes\\n     * In order to run this code it will take at minimum 4 devs / core team to accept any stake\\n     * This function can not be ran by just anyone.\\n     */\\n    // function fixV1Stake(address _staker, uint256 _sessionId)\\n    //     external\\n    //     onlyMigrator\\n    // {\\n    //     require(_sessionId <= lastSessionIdV1, 'Staking: Invalid sessionId'); // Require that the sessionId we are looking for is > v1Id\\n\\n    //     // Ensure that the session does not exist\\n    //     Session storage session = sessionDataOf[_staker][_sessionId];\\n    //     require(\\n    //         session.shares == 0 && session.withdrawn == false,\\n    //         'Staking: Stake already fixed and or withdrawn'\\n    //     );\\n\\n    //     // Find the v1 stake && ensure the stake has not been withdrawn\\n    //     (\\n    //         uint256 amount,\\n    //         uint256 start,\\n    //         uint256 end,\\n    //         uint256 shares,\\n    //         uint256 firstPayout\\n    //     ) = stakingV1.sessionDataOf(_staker, _sessionId);\\n\\n    //     require(shares == 0, 'Staking: Stake has not been withdrawn');\\n\\n    //     // Get # of staking days\\n    //     uint256 stakingDays = (end.sub(start)).div(stepTimestamp);\\n\\n    //     stakeInternalCommon(\\n    //         _sessionId,\\n    //         amount,\\n    //         start,\\n    //         end < now ? now : end,\\n    //         stakingDays,\\n    //         firstPayout,\\n    //         _staker\\n    //     );\\n    // }\\n\\n    // Used for tests only\\n    function resetTotalSharesOfAccount() external {\\n        isVcaRegistered[msg.sender] = false;\\n        totalVcaRegisteredShares = totalVcaRegisteredShares.sub(\\n            totalSharesOf[msg.sender]\\n        );\\n        totalSharesOf[msg.sender] = 0;\\n    }\\n\\n    /** No longer needed */\\n    function setShareRate(uint256 _shareRate) external onlyManager {\\n        shareRate = _shareRate;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n\\nimport '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol';\\n\\nimport './interfaces/IToken.sol';\\nimport './interfaces/IAuction.sol';\\nimport './interfaces/IStaking.sol';\\nimport './interfaces/IStakingV1.sol';\\n\\ncontract Staking is IStaking, Initializable, AccessControlUpgradeable {\\n    using SafeMathUpgradeable for uint256;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n\\n    /** Events */\\n    event Stake(\\n        address indexed account,\\n        uint256 indexed sessionId,\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end,\\n        uint256 shares\\n    );\\n\\n    event MaxShareUpgrade(\\n        address indexed account,\\n        uint256 indexed sessionId,\\n        uint256 amount,\\n        uint256 newAmount,\\n        uint256 shares,\\n        uint256 newShares,\\n        uint256 start,\\n        uint256 end\\n    );\\n\\n    event Unstake(\\n        address indexed account,\\n        uint256 indexed sessionId,\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end,\\n        uint256 shares\\n    );\\n\\n    event MakePayout(\\n        uint256 indexed value,\\n        uint256 indexed sharesTotalSupply,\\n        uint256 indexed time\\n    );\\n\\n    event AccountRegistered(\\n        address indexed account,\\n        uint256 indexed totalShares\\n    );\\n\\n    event WithdrawLiquidDiv(\\n        address indexed account,\\n        address indexed tokenAddress,\\n        uint256 indexed interest\\n    );\\n\\n    /** Structs */\\n    struct Payout {\\n        uint256 payout;\\n        uint256 sharesTotalSupply;\\n    }\\n\\n    struct Session {\\n        uint256 amount;\\n        uint256 start;\\n        uint256 end;\\n        uint256 shares;\\n        uint256 firstPayout;\\n        uint256 lastPayout;\\n        bool withdrawn;\\n        uint256 payout;\\n    }\\n\\n    struct Addresses {\\n        address mainToken;\\n        address auction;\\n        address subBalances;\\n    }\\n\\n    struct BPDPool {\\n        uint96[5] pool;\\n        uint96[5] shares;\\n    }\\n    struct BPDPool128 {\\n        uint128[5] pool;\\n        uint128[5] shares;\\n    }\\n\\n    Addresses public addresses;\\n    IStakingV1 public stakingV1;\\n\\n    /** Roles */\\n    bytes32 public constant MIGRATOR_ROLE = keccak256('MIGRATOR_ROLE');\\n    bytes32 public constant EXTERNAL_STAKER_ROLE =\\n        keccak256('EXTERNAL_STAKER_ROLE');\\n    bytes32 public constant MANAGER_ROLE = keccak256('MANAGER_ROLE');\\n\\n    /** Public Variables */\\n    uint256 public shareRate; //shareRate used to calculate the number of shares\\n    uint256 public sharesTotalSupply; //total shares supply\\n    uint256 public nextPayoutCall; //used to calculate when the daily makePayout() should run\\n    uint256 public stepTimestamp; // 24h * 60 * 60\\n    uint256 public startContract; //time the contract started\\n    uint256 public globalPayout;\\n    uint256 public globalPayin;\\n    uint256 public lastSessionId; //the ID of the last stake\\n    uint256 public lastSessionIdV1; //the ID of the last stake from layer 1 staking contract\\n\\n    /** Mappings / Arrays */\\n    // individual staking sessions\\n    mapping(address => mapping(uint256 => Session)) public sessionDataOf;\\n    //array with staking sessions of an address\\n    mapping(address => uint256[]) public sessionsOf;\\n    //array with daily payouts\\n    Payout[] public payouts;\\n\\n    /** Booleans */\\n    bool public init_;\\n\\n    uint256 public basePeriod; //350 days, time of the first BPD\\n    uint256 public totalStakedAmount; //total amount of staked AXN\\n\\n    bool private maxShareEventActive; //true if maxShare upgrade is enabled\\n\\n    uint16 private maxShareMaxDays; //maximum number of days a stake length can be in order to qualify for maxShare upgrade\\n    uint256 private shareRateScalingFactor; //scaling factor, default 1 to be used on the shareRate calculation\\n\\n    uint256 internal totalVcaRegisteredShares; //total number of shares from accounts that registered for the VCA\\n\\n    mapping(address => uint256) internal tokenPricePerShare; //price per share for every token that is going to be offered as divident through the VCA\\n    EnumerableSetUpgradeable.AddressSet internal divTokens; //list of dividends tokens\\n\\n    //keep track if an address registered for VCA\\n    mapping(address => bool) internal isVcaRegistered;\\n    //total shares of active stakes for an address\\n    mapping(address => uint256) internal totalSharesOf;\\n    //mapping address-> VCA token used for VCA divs calculation. The way the system works is that deductBalances is starting as totalSharesOf x price of the respective token. So when the token price appreciates, the interest earned is the difference between totalSharesOf x new price - deductBalance [respective token]\\n    mapping(address => mapping(address => uint256)) internal deductBalances;\\n\\n    bool internal paused;\\n\\n    /* New variables must go below here. */\\n    BPDPool bpd;\\n    BPDPool128 bpd128;\\n\\n    modifier onlyManager() {\\n        require(hasRole(MANAGER_ROLE, _msgSender()), 'Caller is not a manager');\\n        _;\\n    }\\n\\n    modifier onlyMigrator() {\\n        require(\\n            hasRole(MIGRATOR_ROLE, _msgSender()),\\n            'Caller is not a migrator'\\n        );\\n        _;\\n    }\\n\\n    modifier onlyExternalStaker() {\\n        require(\\n            hasRole(EXTERNAL_STAKER_ROLE, _msgSender()),\\n            'Caller is not a external staker'\\n        );\\n        _;\\n    }\\n\\n    modifier onlyAuction() {\\n        require(msg.sender == addresses.auction, 'Caller is not the auction');\\n        _;\\n    }\\n\\n    modifier pausable() {\\n        require(\\n            paused == false || hasRole(MIGRATOR_ROLE, _msgSender()),\\n            'Contract is paused'\\n        );\\n        _;\\n    }\\n\\n    function initialize(address _manager, address _migrator)\\n        public\\n        initializer\\n    {\\n        _setupRole(MANAGER_ROLE, _manager);\\n        _setupRole(MIGRATOR_ROLE, _migrator);\\n        init_ = false;\\n    }\\n\\n    // @param account {address} - address of account\\n    function sessionsOf_(address account)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return sessionsOf[account];\\n    }\\n\\n    //staking function which receives AXN and creates the stake - takes as param the amount of AXN and the number of days to be staked\\n    //staking days need to be >0 and lower than max days which is 5555\\n    // @param amount {uint256} - AXN amount to be staked\\n    // @param stakingDays {uint256} - number of days to be staked\\n    function stake(uint256 amount, uint256 stakingDays) external pausable {\\n        require(stakingDays != 0, 'Staking: Staking days < 1');\\n        require(stakingDays <= 5555, 'Staking: Staking days > 5555');\\n\\n        //call stake internal method\\n        stakeInternal(amount, stakingDays, msg.sender);\\n        //on stake axion gets burned\\n        IToken(addresses.mainToken).burn(msg.sender, amount);\\n    }\\n\\n    //external stake creates a stake for a different account than the caller. It takes an extra param the staker address\\n    // @param amount {uint256} - AXN amount to be staked\\n    // @param stakingDays {uint256} - number of days to be staked\\n    // @param staker {address} - account address to create the stake for\\n    function externalStake(\\n        uint256 amount,\\n        uint256 stakingDays,\\n        address staker\\n    ) external override onlyExternalStaker pausable {\\n        require(stakingDays != 0, 'Staking: Staking days < 1');\\n        require(stakingDays <= 5555, 'Staking: Staking days > 5555');\\n\\n        stakeInternal(amount, stakingDays, staker);\\n    }\\n\\n    // @param amount {uint256} - AXN amount to be staked\\n    // @param stakingDays {uint256} - number of days to be staked\\n    // @param staker {address} - account address to create the stake for\\n    function stakeInternal(\\n        uint256 amount,\\n        uint256 stakingDays,\\n        address staker\\n    ) internal {\\n        //once a day we need to call makePayout which takes the interest earned for the last day and adds it into the payout array\\n        if (now >= nextPayoutCall) makePayout();\\n\\n        //ensure the user is registered for VCA if not call it\\n        if (isVcaRegistered[staker] == false)\\n            setTotalSharesOfAccountInternal(staker);\\n\\n        //time of staking start is now\\n        uint256 start = now;\\n        //time of stake end is now + number of days * stepTimestamp which is 24 hours\\n        uint256 end = now.add(stakingDays.mul(stepTimestamp));\\n\\n        //increase the last stake ID\\n        lastSessionId = lastSessionId.add(1);\\n\\n        stakeInternalCommon(\\n            lastSessionId,\\n            amount,\\n            start,\\n            end,\\n            stakingDays,\\n            payouts.length,\\n            staker\\n        );\\n    }\\n\\n    //payment function uses param address and amount to be paid. Amount is minted to address\\n    // @param to {address} - account address to send the payment to\\n    // @param amount {uint256} - AXN amount to be paid\\n    function _initPayout(address to, uint256 amount) internal {\\n        IToken(addresses.mainToken).mint(to, amount);\\n        globalPayout = globalPayout.add(amount);\\n    }\\n\\n    //staking interest calculation goes through the payout array and calculates the interest based on the number of shares the user has and the payout for every day\\n    // @param firstPayout {uint256} - id of the first day of payout for the stake\\n    // @param lastPayout {uint256} - id of the last day of payout for the stake\\n    // @param shares {uint256} - number of shares of the stake\\n    function calculateStakingInterest(\\n        uint256 firstPayout,\\n        uint256 lastPayout,\\n        uint256 shares\\n    ) public view returns (uint256) {\\n        uint256 stakingInterest;\\n        //calculate lastIndex as minimum of lastPayout from stake session and current day (payouts.length).\\n        uint256 lastIndex = MathUpgradeable.min(payouts.length, lastPayout);\\n\\n        for (uint256 i = firstPayout; i < lastIndex; i++) {\\n            uint256 payout =\\n                payouts[i].payout.mul(shares).div(payouts[i].sharesTotalSupply);\\n\\n            stakingInterest = stakingInterest.add(payout);\\n        }\\n\\n        return stakingInterest;\\n    }\\n\\n    //unstake function\\n    // @param sessionID {uint256} - id of the stake\\n    function unstake(uint256 sessionId) external pausable {\\n        Session storage session = sessionDataOf[msg.sender][sessionId];\\n\\n        //ensure the stake hasn't been withdrawn before\\n        require(\\n            session.shares != 0 && session.withdrawn == false,\\n            'Staking: Stake withdrawn or not set'\\n        );\\n\\n        uint256 actualEnd = now;\\n        //calculate the amount the stake earned; to be paid\\n        uint256 amountOut = unstakeInternal(session, sessionId, actualEnd);\\n\\n        // To account\\n        _initPayout(msg.sender, amountOut);\\n    }\\n\\n    //unstake function for layer1 stakes\\n    // @param sessionID {uint256} - id of the layer 1 stake\\n    function unstakeV1(uint256 sessionId) external pausable {\\n        //lastSessionIdv1 is the last stake ID from v1 layer\\n        require(sessionId <= lastSessionIdV1, 'Staking: Invalid sessionId');\\n\\n        Session storage session = sessionDataOf[msg.sender][sessionId];\\n\\n        // Unstaked already\\n        require(\\n            session.shares == 0 && session.withdrawn == false,\\n            'Staking: Stake withdrawn'\\n        );\\n\\n        (\\n            uint256 amount,\\n            uint256 start,\\n            uint256 end,\\n            uint256 shares,\\n            uint256 firstPayout\\n        ) = stakingV1.sessionDataOf(msg.sender, sessionId);\\n\\n        // Unstaked in v1 / doesn't exist\\n        require(shares != 0, 'Staking: Stake withdrawn or not set');\\n\\n        uint256 stakingDays = (end - start) / stepTimestamp;\\n        uint256 lastPayout = stakingDays + firstPayout;\\n\\n        uint256 actualEnd = now;\\n        //calculate amount to be paid\\n        uint256 amountOut =\\n            unstakeV1Internal(\\n                sessionId,\\n                amount,\\n                start,\\n                end,\\n                actualEnd,\\n                shares,\\n                firstPayout,\\n                lastPayout\\n            );\\n\\n        // To account\\n        _initPayout(msg.sender, amountOut);\\n    }\\n\\n    //calculate the amount the stake earned and any penalty because of early/late unstake\\n    // @param amount {uint256} - amount of AXN staked\\n    // @param start {uint256} - start date of the stake\\n    // @param end {uint256} - end date of the stake\\n    // @param stakingInterest {uint256} - interest earned of the stake\\n    function getAmountOutAndPenalty(\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end,\\n        uint256 stakingInterest\\n    ) public view returns (uint256, uint256) {\\n        uint256 stakingSeconds = end.sub(start);\\n        uint256 stakingDays = stakingSeconds.div(stepTimestamp);\\n        uint256 secondsStaked = now.sub(start);\\n        uint256 daysStaked = secondsStaked.div(stepTimestamp);\\n        uint256 amountAndInterest = amount.add(stakingInterest);\\n\\n        // Early\\n        if (stakingDays > daysStaked) {\\n            uint256 payOutAmount =\\n                amountAndInterest.mul(secondsStaked).div(stakingSeconds);\\n\\n            uint256 earlyUnstakePenalty = amountAndInterest.sub(payOutAmount);\\n\\n            return (payOutAmount, earlyUnstakePenalty);\\n            // In time\\n        } else if (daysStaked < stakingDays.add(14)) {\\n            return (amountAndInterest, 0);\\n            // Late\\n        } else if (daysStaked < stakingDays.add(714)) {\\n            return (amountAndInterest, 0);\\n            /** Remove late penalties for now */\\n            // uint256 daysAfterStaking = daysStaked - stakingDays;\\n\\n            // uint256 payOutAmount =\\n            //     amountAndInterest.mul(uint256(714).sub(daysAfterStaking)).div(\\n            //         700\\n            //     );\\n\\n            // uint256 lateUnstakePenalty = amountAndInterest.sub(payOutAmount);\\n\\n            // return (payOutAmount, lateUnstakePenalty);\\n\\n            // Nothing\\n        } else {\\n            return (0, amountAndInterest);\\n        }\\n    }\\n\\n    //makePayout function runs once per day and takes all the AXN earned as interest and puts it into payout array for the day\\n    function makePayout() public {\\n        require(now >= nextPayoutCall, 'Staking: Wrong payout time');\\n\\n        uint256 payout = _getPayout();\\n\\n        payouts.push(\\n            Payout({payout: payout, sharesTotalSupply: sharesTotalSupply})\\n        );\\n\\n        nextPayoutCall = nextPayoutCall.add(stepTimestamp);\\n\\n        //call updateShareRate once a day as sharerate increases based on the daily Payout amount\\n        updateShareRate(payout);\\n\\n        emit MakePayout(payout, sharesTotalSupply, now);\\n    }\\n\\n    function _getPayout() internal returns (uint256) {\\n        //amountTokenInDay - AXN from auction buybacks goes into the staking contract\\n        uint256 amountTokenInDay =\\n            IERC20Upgradeable(addresses.mainToken).balanceOf(address(this));\\n\\n        globalPayin = globalPayin.add(amountTokenInDay);\\n\\n        if (globalPayin > globalPayout) {\\n            globalPayin = globalPayin.sub(globalPayout);\\n            globalPayout = 0;\\n        } else {\\n            globalPayin = 0;\\n            globalPayout = 0;\\n        }\\n\\n        uint256 currentTokenTotalSupply =\\n            (IERC20Upgradeable(addresses.mainToken).totalSupply()).add(\\n                globalPayin\\n            );\\n\\n        IToken(addresses.mainToken).burn(address(this), amountTokenInDay);\\n        //we add 8% inflation\\n        uint256 inflation =\\n            uint256(8).mul(currentTokenTotalSupply.add(totalStakedAmount)).div(\\n                36500\\n            );\\n\\n        globalPayin = globalPayin.add(inflation);\\n\\n        return amountTokenInDay.add(inflation);\\n    }\\n\\n    // formula for shares calculation given a number of AXN and a start and end date\\n    // @param amount {uint256} - amount of AXN\\n    // @param start {uint256} - start date of the stake\\n    // @param end {uint256} - end date of the stake\\n    function _getStakersSharesAmount(\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (uint256) {\\n        uint256 stakingDays = (end.sub(start)).div(stepTimestamp);\\n        uint256 numerator = amount.mul(uint256(1819).add(stakingDays));\\n        uint256 denominator = uint256(1820).mul(shareRate);\\n\\n        return (numerator).mul(1e18).div(denominator);\\n    }\\n\\n    // @param amount {uint256} - amount of AXN\\n    // @param shares {uint256} - number of shares\\n    // @param start {uint256} - start date of the stake\\n    // @param end {uint256} - end date of the stake\\n    // @param stakingInterest {uint256} - interest earned by the stake\\n    function _getShareRate(\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 start,\\n        uint256 end,\\n        uint256 stakingInterest\\n    ) internal view returns (uint256) {\\n        uint256 stakingDays = (end.sub(start)).div(stepTimestamp);\\n\\n        uint256 numerator =\\n            (amount.add(stakingInterest)).mul(uint256(1819).add(stakingDays));\\n\\n        uint256 denominator = uint256(1820).mul(shares);\\n\\n        return (numerator).mul(1e18).div(denominator);\\n    }\\n\\n    //takes a matures stake and allows restake instead of having to withdraw the axn and stake it back into another stake\\n    //restake will take the principal + interest earned + allow a topup\\n    // @param sessionID {uint256} - id of the stake\\n    // @param stakingDays {uint256} - number of days to be staked\\n    // @param topup {uint256} - amount of AXN to be added as topup to the stake\\n    function restake(\\n        uint256 sessionId,\\n        uint256 stakingDays,\\n        uint256 topup\\n    ) external pausable {\\n        require(stakingDays != 0, 'Staking: Staking days < 1');\\n        require(stakingDays <= 5555, 'Staking: Staking days > 5555');\\n\\n        Session storage session = sessionDataOf[msg.sender][sessionId];\\n\\n        require(\\n            session.shares != 0 && session.withdrawn == false,\\n            'Staking: Stake withdrawn/invalid'\\n        );\\n\\n        uint256 actualEnd = now;\\n\\n        require(session.end <= actualEnd, 'Staking: Stake not mature');\\n\\n        uint256 amountOut = unstakeInternal(session, sessionId, actualEnd);\\n\\n        if (topup != 0) {\\n            IToken(addresses.mainToken).burn(msg.sender, topup);\\n            amountOut = amountOut.add(topup);\\n        }\\n\\n        stakeInternal(amountOut, stakingDays, msg.sender);\\n    }\\n\\n    //same as restake but for layer 1 stakes\\n    // @param sessionID {uint256} - id of the stake\\n    // @param stakingDays {uint256} - number of days to be staked\\n    // @param topup {uint256} - amount of AXN to be added as topup to the stake\\n    function restakeV1(\\n        uint256 sessionId,\\n        uint256 stakingDays,\\n        uint256 topup\\n    ) external pausable {\\n        require(sessionId <= lastSessionIdV1, 'Staking: Invalid sessionId');\\n        require(stakingDays != 0, 'Staking: Staking days < 1');\\n        require(stakingDays <= 5555, 'Staking: Staking days > 5555');\\n\\n        Session storage session = sessionDataOf[msg.sender][sessionId];\\n\\n        require(\\n            session.shares == 0 && session.withdrawn == false,\\n            'Staking: Stake withdrawn'\\n        );\\n\\n        (\\n            uint256 amount,\\n            uint256 start,\\n            uint256 end,\\n            uint256 shares,\\n            uint256 firstPayout\\n        ) = stakingV1.sessionDataOf(msg.sender, sessionId);\\n\\n        // Unstaked in v1 / doesn't exist\\n        require(shares != 0, 'Staking: Stake withdrawn');\\n\\n        uint256 actualEnd = now;\\n\\n        require(end <= actualEnd, 'Staking: Stake not mature');\\n\\n        uint256 sessionStakingDays = (end - start) / stepTimestamp;\\n        uint256 lastPayout = sessionStakingDays + firstPayout;\\n\\n        uint256 amountOut =\\n            unstakeV1Internal(\\n                sessionId,\\n                amount,\\n                start,\\n                end,\\n                actualEnd,\\n                shares,\\n                firstPayout,\\n                lastPayout\\n            );\\n\\n        if (topup != 0) {\\n            IToken(addresses.mainToken).burn(msg.sender, topup);\\n            amountOut = amountOut.add(topup);\\n        }\\n\\n        stakeInternal(amountOut, stakingDays, msg.sender);\\n    }\\n\\n    // @param session {Session} - session of the stake\\n    // @param sessionId {uint256} - id of the stake\\n    // @param actualEnd {uint256} - the date when the stake was actually been unstaked\\n    function unstakeInternal(\\n        Session storage session,\\n        uint256 sessionId,\\n        uint256 actualEnd\\n    ) internal returns (uint256) {\\n        uint256 amountOut =\\n            unstakeInternalCommon(\\n                sessionId,\\n                session.amount,\\n                session.start,\\n                session.end,\\n                actualEnd,\\n                session.shares,\\n                session.firstPayout,\\n                session.lastPayout\\n            );\\n\\n        session.end = actualEnd;\\n        session.withdrawn = true;\\n        session.payout = amountOut;\\n\\n        return amountOut;\\n    }\\n\\n    // @param sessionID {uint256} - id of the stake\\n    // @param amount {uint256} - amount of AXN\\n    // @param start {uint256} - start date of the stake\\n    // @param end {uint256} - end date of the stake\\n    // @param actualEnd {uint256} - actual end date of the stake\\n    // @param shares {uint256} - number of stares of the stake\\n    // @param firstPayout {uint256} - id of the first payout for the stake\\n    // @param lastPayout {uint256} - if of the last payout for the stake\\n    // @param stakingDays {uint256} - number of staking days\\n    function unstakeV1Internal(\\n        uint256 sessionId,\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end,\\n        uint256 actualEnd,\\n        uint256 shares,\\n        uint256 firstPayout,\\n        uint256 lastPayout\\n    ) internal returns (uint256) {\\n        uint256 amountOut =\\n            unstakeInternalCommon(\\n                sessionId,\\n                amount,\\n                start,\\n                end,\\n                actualEnd,\\n                shares,\\n                firstPayout,\\n                lastPayout\\n            );\\n\\n        sessionDataOf[msg.sender][sessionId] = Session({\\n            amount: amount,\\n            start: start,\\n            end: actualEnd,\\n            shares: shares,\\n            firstPayout: firstPayout,\\n            lastPayout: lastPayout,\\n            withdrawn: true,\\n            payout: amountOut\\n        });\\n\\n        sessionsOf[msg.sender].push(sessionId);\\n\\n        return amountOut;\\n    }\\n\\n    // @param sessionID {uint256} - id of the stake\\n    // @param amount {uint256} - amount of AXN\\n    // @param start {uint256} - start date of the stake\\n    // @param end {uint256} - end date of the stake\\n    // @param actualEnd {uint256} - actual end date of the stake\\n    // @param shares {uint256} - number of stares of the stake\\n    // @param firstPayout {uint256} - id of the first payout for the stake\\n    // @param lastPayout {uint256} - if of the last payout for the stake\\n    function unstakeInternalCommon(\\n        uint256 sessionId,\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end,\\n        uint256 actualEnd,\\n        uint256 shares,\\n        uint256 firstPayout,\\n        uint256 lastPayout\\n    ) internal returns (uint256) {\\n        if (now >= nextPayoutCall) makePayout();\\n        if (isVcaRegistered[msg.sender] == false)\\n            setTotalSharesOfAccountInternal(msg.sender);\\n\\n        uint256 stakingInterest =\\n            calculateStakingInterest(firstPayout, lastPayout, shares);\\n\\n        sharesTotalSupply = sharesTotalSupply.sub(shares);\\n        totalStakedAmount = totalStakedAmount.sub(amount);\\n        totalVcaRegisteredShares = totalVcaRegisteredShares.sub(shares);\\n\\n        uint256 oldTotalSharesOf = totalSharesOf[msg.sender];\\n        totalSharesOf[msg.sender] = totalSharesOf[msg.sender].sub(shares);\\n\\n        rebalance(msg.sender, oldTotalSharesOf);\\n\\n        (uint256 amountOut, uint256 penalty) =\\n            getAmountOutAndPenalty(amount, start, end, stakingInterest);\\n\\n        // add bpd to amount amountOut if stakingDays >= basePeriod\\n        uint256 stakingDays = (actualEnd - start) / stepTimestamp;\\n        if (stakingDays >= basePeriod) {\\n            // We use \\\"Actual end\\\" so that if a user tries to withdraw their BPD early they don't get the shares\\n            uint256 bpdAmount =\\n                calcBPD(start, actualEnd < end ? actualEnd : end, shares);\\n            amountOut = amountOut.add(bpdAmount);\\n        }\\n\\n        // To auction\\n        if (penalty != 0) {\\n            _initPayout(addresses.auction, penalty);\\n            IAuction(addresses.auction).callIncomeDailyTokensTrigger(penalty);\\n        }\\n\\n        emit Unstake(\\n            msg.sender,\\n            sessionId,\\n            amountOut,\\n            start,\\n            actualEnd,\\n            shares\\n        );\\n\\n        return amountOut;\\n    }\\n\\n    // @param sessionID {uint256} - id of the stake\\n    // @param amount {uint256} - amount of AXN\\n    // @param start {uint256} - start date of the stake\\n    // @param end {uint256} - end date of the stake\\n    // @param stakingDays {uint256} - number of staking days\\n    // @param firstPayout {uint256} - id of the first payout for the stake\\n    // @param lastPayout {uint256} - if of the last payout for the stake\\n    // @param staker {address} - address of the staker account\\n    function stakeInternalCommon(\\n        uint256 sessionId,\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end,\\n        uint256 stakingDays,\\n        uint256 firstPayout,\\n        address staker\\n    ) internal {\\n        uint256 shares = _getStakersSharesAmount(amount, start, end);\\n\\n        sharesTotalSupply = sharesTotalSupply.add(shares);\\n        totalStakedAmount = totalStakedAmount.add(amount);\\n        totalVcaRegisteredShares = totalVcaRegisteredShares.add(shares);\\n\\n        uint256 oldTotalSharesOf = totalSharesOf[staker];\\n        totalSharesOf[staker] = totalSharesOf[staker].add(shares);\\n\\n        rebalance(staker, oldTotalSharesOf);\\n\\n        sessionDataOf[staker][sessionId] = Session({\\n            amount: amount,\\n            start: start,\\n            end: end,\\n            shares: shares,\\n            firstPayout: firstPayout,\\n            lastPayout: firstPayout + stakingDays,\\n            withdrawn: false,\\n            payout: 0\\n        });\\n\\n        sessionsOf[staker].push(sessionId);\\n\\n        // add shares to bpd pool\\n        addBPDShares(shares, start, end);\\n\\n        emit Stake(staker, sessionId, amount, start, end, shares);\\n    }\\n\\n    //function to withdraw the dividends earned for a specific token\\n    // @param tokenAddress {address} - address of the dividend token\\n    function withdrawDivToken(address tokenAddress) external {\\n        withdrawDivTokenInternal(tokenAddress, totalSharesOf[msg.sender]);\\n    }\\n\\n    function withdrawDivTokenInternal(\\n        address tokenAddress,\\n        uint256 _totalSharesOf\\n    ) internal {\\n        uint256 tokenInterestEarned =\\n            getTokenInterestEarnedInternal(\\n                msg.sender,\\n                tokenAddress,\\n                _totalSharesOf\\n            );\\n\\n        // after dividents are paid we need to set the deductBalance of that token to current token price * total shares of the account\\n        deductBalances[msg.sender][tokenAddress] = totalSharesOf[msg.sender]\\n            .mul(tokenPricePerShare[tokenAddress]);\\n\\n        /** 0xFF... is our ethereum placeholder address */\\n        if (\\n            tokenAddress != address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)\\n        ) {\\n            IERC20Upgradeable(tokenAddress).transfer(\\n                msg.sender,\\n                tokenInterestEarned\\n            );\\n        } else {\\n            msg.sender.transfer(tokenInterestEarned);\\n        }\\n\\n        emit WithdrawLiquidDiv(msg.sender, tokenAddress, tokenInterestEarned);\\n    }\\n\\n    //calculate the interest earned by an address for a specific dividend token\\n    // @param accountAddress {address} - address of account\\n    // @param tokenAddress {address} - address of the dividend token\\n    function getTokenInterestEarned(\\n        address accountAddress,\\n        address tokenAddress\\n    ) external view returns (uint256) {\\n        return\\n            getTokenInterestEarnedInternal(\\n                accountAddress,\\n                tokenAddress,\\n                totalSharesOf[accountAddress]\\n            );\\n    }\\n\\n    // @param accountAddress {address} - address of account\\n    // @param tokenAddress {address} - address of the dividend token\\n    function getTokenInterestEarnedInternal(\\n        address accountAddress,\\n        address tokenAddress,\\n        uint256 _totalSharesOf\\n    ) internal view returns (uint256) {\\n        return\\n            _totalSharesOf\\n                .mul(tokenPricePerShare[tokenAddress])\\n                .sub(deductBalances[accountAddress][tokenAddress])\\n                .div(10**36); //we divide since we multiplied the price by 10**36 for precision\\n    }\\n\\n    //the rebalance function recalculates the deductBalances of an user after the total number of shares changes as a result of a stake/unstake\\n    // @param staker {address} - address of account\\n    // @param oldTotalSharesOf {uint256} - previous number of shares for the account\\n    function rebalance(address staker, uint256 oldTotalSharesOf) internal {\\n        for (uint8 i = 0; i < divTokens.length(); i++) {\\n            uint256 tokenInterestEarned =\\n                oldTotalSharesOf.mul(tokenPricePerShare[divTokens.at(i)]).sub(\\n                    deductBalances[staker][divTokens.at(i)]\\n                );\\n\\n            if (\\n                totalSharesOf[staker].mul(tokenPricePerShare[divTokens.at(i)]) <\\n                tokenInterestEarned\\n            ) {\\n                withdrawDivTokenInternal(divTokens.at(i), oldTotalSharesOf);\\n            } else {\\n                deductBalances[staker][divTokens.at(i)] = totalSharesOf[staker]\\n                    .mul(tokenPricePerShare[divTokens.at(i)])\\n                    .sub(tokenInterestEarned);\\n            }\\n        }\\n    }\\n\\n    //registration function that sets the total number of shares for an account and inits the deductBalances\\n    // @param account {address} - address of account\\n    function setTotalSharesOfAccountInternal(address account)\\n        internal\\n        pausable\\n    {\\n        require(\\n            isVcaRegistered[account] == false ||\\n                hasRole(MIGRATOR_ROLE, msg.sender),\\n            'STAKING: Account already registered.'\\n        );\\n\\n        uint256 totalShares;\\n        //pull the layer 2 staking sessions for the account\\n        uint256[] storage sessionsOfAccount = sessionsOf[account];\\n\\n        for (uint256 i = 0; i < sessionsOfAccount.length; i++) {\\n            if (sessionDataOf[account][sessionsOfAccount[i]].withdrawn)\\n                //make sure the stake is active; not withdrawn\\n                continue;\\n\\n            totalShares = totalShares.add( //sum total shares\\n                sessionDataOf[account][sessionsOfAccount[i]].shares\\n            );\\n        }\\n\\n        //pull stakes from layer 1\\n        uint256[] memory v1SessionsOfAccount = stakingV1.sessionsOf_(account);\\n\\n        for (uint256 i = 0; i < v1SessionsOfAccount.length; i++) {\\n            if (sessionDataOf[account][v1SessionsOfAccount[i]].shares != 0)\\n                //make sure the stake was not withdran.\\n                continue;\\n\\n            if (v1SessionsOfAccount[i] > lastSessionIdV1) continue; //make sure we only take layer 1 stakes in consideration\\n\\n            (\\n                uint256 amount,\\n                uint256 start,\\n                uint256 end,\\n                uint256 shares,\\n                uint256 firstPayout\\n            ) = stakingV1.sessionDataOf(account, v1SessionsOfAccount[i]);\\n\\n            (amount);\\n            (start);\\n            (end);\\n            (firstPayout);\\n\\n            if (shares == 0) continue;\\n\\n            totalShares = totalShares.add(shares); //calclate total shares\\n        }\\n\\n        isVcaRegistered[account] = true; //confirm the registration was completed\\n\\n        if (totalShares != 0) {\\n            totalSharesOf[account] = totalShares;\\n            totalVcaRegisteredShares = totalVcaRegisteredShares.add( //update the global total number of VCA registered shares\\n                totalShares\\n            );\\n\\n            //init deductBalances with the present values\\n            for (uint256 i = 0; i < divTokens.length(); i++) {\\n                deductBalances[account][divTokens.at(i)] = totalShares.mul(\\n                    tokenPricePerShare[divTokens.at(i)]\\n                );\\n            }\\n        }\\n\\n        emit AccountRegistered(account, totalShares);\\n    }\\n\\n    //function to allow anyone to call the registration of another address\\n    // @param _address {address} - address of account\\n    function setTotalSharesOfAccount(address _address) external {\\n        setTotalSharesOfAccountInternal(_address);\\n    }\\n\\n    //function that will update the price per share for a dividend token. it is called from within the auction contract as a result of a venture auction bid\\n    // @param bidderAddress {address} - the address of the bidder\\n    // @param originAddress {address} - the address of origin/dev fee\\n    // @param tokenAddress {address} - the divident token address\\n    // @param amountBought {uint256} - the amount in ETH that was bid in the auction\\n    function updateTokenPricePerShare(\\n        address payable bidderAddress,\\n        address payable originAddress,\\n        address tokenAddress,\\n        uint256 amountBought\\n    ) external payable override onlyAuction {\\n        // uint256 amountForBidder = amountBought.mul(10526315789473685).div(1e17);\\n        uint256 amountForOrigin = amountBought.mul(5).div(100); //5% fee goes to dev\\n        uint256 amountForBidder = amountBought.mul(10).div(100); //10% is being returned to bidder\\n        uint256 amountForDivs =\\n            amountBought.sub(amountForOrigin).sub(amountForBidder); //remaining is the actual amount that was used to buy the token\\n\\n        if (\\n            tokenAddress != address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)\\n        ) {\\n            IERC20Upgradeable(tokenAddress).transfer(\\n                bidderAddress, //pay the bidder the 10%\\n                amountForBidder\\n            );\\n\\n            IERC20Upgradeable(tokenAddress).transfer(\\n                originAddress, //pay the dev fee the 5%\\n                amountForOrigin\\n            );\\n        } else {\\n            //if token is ETH we use the transfer function\\n            bidderAddress.transfer(amountForBidder);\\n            originAddress.transfer(amountForOrigin);\\n        }\\n\\n        tokenPricePerShare[tokenAddress] = tokenPricePerShare[tokenAddress].add( //increase the token price per share with the amount bought divided by the total Vca registered shares\\n            amountForDivs.mul(10**36).div(totalVcaRegisteredShares)\\n        );\\n    }\\n\\n    //add a new dividend token\\n    // @param tokenAddress {address} - dividend token address\\n    function addDivToken(address tokenAddress) external override onlyAuction {\\n        if (!divTokens.contains(tokenAddress)) {\\n            //make sure the token is not already added\\n            divTokens.add(tokenAddress);\\n        }\\n    }\\n\\n    //function to increase the share rate price\\n    //the update happens daily and used the amount of AXN sold through regular auction to calculate the amount to increase the share rate with\\n    // @param _payout {uint256} - amount of AXN that was bought back through the regular auction\\n    function updateShareRate(uint256 _payout) internal {\\n        uint256 currentTokenTotalSupply =\\n            IERC20Upgradeable(addresses.mainToken).totalSupply();\\n\\n        uint256 growthFactor =\\n            _payout.mul(1e18).div(\\n                currentTokenTotalSupply + totalStakedAmount + 1 //we calculate the total AXN supply as circulating + staked\\n            );\\n\\n        if (shareRateScalingFactor == 0) {\\n            //use a shareRateScalingFactor which can be set in order to tune the speed of shareRate increase\\n            shareRateScalingFactor = 1;\\n        }\\n\\n        shareRate = shareRate\\n            .mul(1e18 + shareRateScalingFactor.mul(growthFactor)) //1e18 used for precision.\\n            .div(1e18);\\n    }\\n\\n    //function to set the shareRateScalingFactor\\n    // @param _scalingFactor {uint256} - scaling factor number\\n    function setShareRateScalingFactor(uint256 _scalingFactor)\\n        external\\n        onlyManager\\n    {\\n        shareRateScalingFactor = _scalingFactor;\\n    }\\n\\n    //function that allows a stake to be upgraded to a stake with a length of 5555 days without incuring any penalties\\n    //the function takes the current earned interest and uses the principal + interest to create a new stake\\n    //for v2 stakes it's only updating the current existing stake info, it's not creating a new stake\\n    // @param sessionId {uint256} - id of the staking session\\n    function maxShare(uint256 sessionId) external pausable {\\n        Session storage session = sessionDataOf[msg.sender][sessionId];\\n\\n        require(\\n            session.shares != 0 && session.withdrawn == false,\\n            'STAKING: Stake withdrawn or not set'\\n        );\\n\\n        (\\n            uint256 newStart,\\n            uint256 newEnd,\\n            uint256 newAmount,\\n            uint256 newShares\\n        ) =\\n            maxShareUpgrade(\\n                session.firstPayout,\\n                session.lastPayout,\\n                session.shares,\\n                session.amount\\n            );\\n\\n        addBPDMaxShares(\\n            session.shares,\\n            session.start,\\n            session.end,\\n            newShares,\\n            newStart,\\n            newEnd\\n        );\\n\\n        maxShareInternal(\\n            sessionId,\\n            session.shares,\\n            newShares,\\n            session.amount,\\n            newAmount,\\n            newStart,\\n            newEnd\\n        );\\n\\n        sessionDataOf[msg.sender][sessionId].amount = newAmount;\\n        sessionDataOf[msg.sender][sessionId].end = newEnd;\\n        sessionDataOf[msg.sender][sessionId].start = newStart;\\n        sessionDataOf[msg.sender][sessionId].shares = newShares;\\n        sessionDataOf[msg.sender][sessionId].firstPayout = payouts.length;\\n        sessionDataOf[msg.sender][sessionId].lastPayout = payouts.length + 5555;\\n    }\\n\\n    //similar to the maxShare function, but for layer 1 stakes only\\n    // @param sessionId {uint256} - id of the staking session\\n    function maxShareV1(uint256 sessionId) external pausable {\\n        require(sessionId <= lastSessionIdV1, 'STAKING: Invalid sessionId');\\n\\n        Session storage session = sessionDataOf[msg.sender][sessionId];\\n\\n        require(\\n            session.shares == 0 && session.withdrawn == false,\\n            'STAKING: Stake withdrawn'\\n        );\\n\\n        (\\n            uint256 amount,\\n            uint256 start,\\n            uint256 end,\\n            uint256 shares,\\n            uint256 firstPayout\\n        ) = stakingV1.sessionDataOf(msg.sender, sessionId);\\n        uint256 stakingDays = (end - start) / stepTimestamp;\\n        uint256 lastPayout = stakingDays + firstPayout;\\n\\n        (\\n            uint256 newStart,\\n            uint256 newEnd,\\n            uint256 newAmount,\\n            uint256 newShares\\n        ) = maxShareUpgrade(firstPayout, lastPayout, shares, amount);\\n\\n        addBPDMaxShares(shares, start, end, newShares, newStart, newEnd);\\n\\n        maxShareInternal(\\n            sessionId,\\n            shares,\\n            newShares,\\n            amount,\\n            newAmount,\\n            newStart,\\n            newEnd\\n        );\\n\\n        sessionDataOf[msg.sender][sessionId] = Session({\\n            amount: newAmount,\\n            start: newStart,\\n            end: newEnd,\\n            shares: newShares,\\n            firstPayout: payouts.length,\\n            lastPayout: payouts.length + 5555,\\n            withdrawn: false,\\n            payout: 0\\n        });\\n\\n        sessionsOf[msg.sender].push(sessionId);\\n    }\\n\\n    //function to calculate the new start, end, new amount and new shares for a max share upgrade\\n    // @param firstPayout {uint256} - id of the first Payout\\n    // @param lasttPayout {uint256} - id of the last Payout\\n    // @param shares {uint256} - number of shares\\n    // @param amount {uint256} - amount of AXN\\n    function maxShareUpgrade(\\n        uint256 firstPayout,\\n        uint256 lastPayout,\\n        uint256 shares,\\n        uint256 amount\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        require(\\n            maxShareEventActive == true,\\n            'STAKING: Max Share event is not active'\\n        );\\n        require(\\n            lastPayout - firstPayout <= maxShareMaxDays,\\n            'STAKING: Max Share Upgrade - Stake must be less then max share max days'\\n        );\\n\\n        uint256 stakingInterest =\\n            calculateStakingInterest(firstPayout, lastPayout, shares);\\n\\n        uint256 newStart = now;\\n        uint256 newEnd = newStart + (stepTimestamp * 5555);\\n        uint256 newAmount = stakingInterest + amount;\\n        uint256 newShares =\\n            _getStakersSharesAmount(newAmount, newStart, newEnd);\\n\\n        require(\\n            newShares > shares,\\n            'STAKING: New shares are not greater then previous shares'\\n        );\\n\\n        return (newStart, newEnd, newAmount, newShares);\\n    }\\n\\n    // @param sessionId {uint256} - id of the staking session\\n    // @param oldShares {uint256} - previous number of shares\\n    // @param newShares {uint256} - new number of shares\\n    // @param oldAmount {uint256} - old amount of AXN\\n    // @param newAmount {uint256} - new amount of AXN\\n    // @param newStart {uint256} - new start date for the stake\\n    // @param newEnd {uint256} - new end date for the stake\\n    function maxShareInternal(\\n        uint256 sessionId,\\n        uint256 oldShares,\\n        uint256 newShares,\\n        uint256 oldAmount,\\n        uint256 newAmount,\\n        uint256 newStart,\\n        uint256 newEnd\\n    ) internal {\\n        if (now >= nextPayoutCall) makePayout();\\n        if (isVcaRegistered[msg.sender] == false)\\n            setTotalSharesOfAccountInternal(msg.sender);\\n\\n        sharesTotalSupply = sharesTotalSupply.add(newShares - oldShares);\\n        totalStakedAmount = totalStakedAmount.add(newAmount - oldAmount);\\n        totalVcaRegisteredShares = totalVcaRegisteredShares.add(\\n            newShares - oldShares\\n        );\\n\\n        uint256 oldTotalSharesOf = totalSharesOf[msg.sender];\\n        totalSharesOf[msg.sender] = totalSharesOf[msg.sender].add(\\n            newShares - oldShares\\n        );\\n\\n        rebalance(msg.sender, oldTotalSharesOf);\\n\\n        emit MaxShareUpgrade(\\n            msg.sender,\\n            sessionId,\\n            oldAmount,\\n            newAmount,\\n            oldShares,\\n            newShares,\\n            newStart,\\n            newEnd\\n        );\\n    }\\n\\n    // stepTimestamp\\n    // startContract\\n    function calculateStepsFromStart() public view returns (uint256) {\\n        return now.sub(startContract).div(stepTimestamp);\\n    }\\n\\n    /** Set Max Shares */\\n    function setMaxShareEventActive(bool _active) external onlyManager {\\n        maxShareEventActive = _active;\\n    }\\n\\n    function getMaxShareEventActive() external view returns (bool) {\\n        return maxShareEventActive;\\n    }\\n\\n    function setMaxShareMaxDays(uint16 _maxShareMaxDays) external onlyManager {\\n        maxShareMaxDays = _maxShareMaxDays;\\n    }\\n\\n    function setTotalVcaRegisteredShares(uint256 _shares)\\n        external\\n        onlyMigrator\\n    {\\n        totalVcaRegisteredShares = _shares;\\n    }\\n\\n    function setPaused(bool _paused) external {\\n        require(\\n            hasRole(MIGRATOR_ROLE, msg.sender) ||\\n                hasRole(MANAGER_ROLE, msg.sender),\\n            'STAKING: User must be manager or migrator'\\n        );\\n        paused = _paused;\\n    }\\n\\n    function getPaused() external view returns (bool) {\\n        return paused;\\n    }\\n\\n    function getMaxShareMaxDays() external view returns (uint16) {\\n        return maxShareMaxDays;\\n    }\\n\\n    /** Roles management - only for multi sig address */\\n    function setupRole(bytes32 role, address account) external onlyManager {\\n        _setupRole(role, account);\\n    }\\n\\n    function getDivTokens() external view returns (address[] memory) {\\n        address[] memory divTokenAddresses = new address[](divTokens.length());\\n\\n        for (uint8 i = 0; i < divTokens.length(); i++) {\\n            divTokenAddresses[i] = divTokens.at(i);\\n        }\\n\\n        return divTokenAddresses;\\n    }\\n\\n    function getTotalSharesOf(address account) external view returns (uint256) {\\n        return totalSharesOf[account];\\n    }\\n\\n    function getTotalVcaRegisteredShares() external view returns (uint256) {\\n        return totalVcaRegisteredShares;\\n    }\\n\\n    function getIsVCARegistered(address staker) external view returns (bool) {\\n        return isVcaRegistered[staker];\\n    }\\n\\n    function setBPDPools(\\n        uint128[5] calldata poolAmount,\\n        uint128[5] calldata poolShares\\n    ) external onlyMigrator {\\n        for (uint8 i = 0; i < poolAmount.length; i++) {\\n            bpd128.pool[i] = poolAmount[i];\\n            bpd128.shares[i] = poolShares[i];\\n        }\\n    }\\n\\n    function findBPDEligible(uint256 starttime, uint256 endtime)\\n        external\\n        view\\n        returns (uint16[2] memory)\\n    {\\n        return findBPDs(starttime, endtime);\\n    }\\n\\n    function findBPDs(uint256 starttime, uint256 endtime)\\n        internal\\n        view\\n        returns (uint16[2] memory)\\n    {\\n        uint16[2] memory bpdInterval;\\n        uint256 denom = stepTimestamp.mul(350);\\n        bpdInterval[0] = uint16(\\n            MathUpgradeable.min(5, starttime.sub(startContract).div(denom))\\n        ); // (starttime - t0) // 350\\n        uint256 bpdEnd =\\n            uint256(bpdInterval[0]) + endtime.sub(starttime).div(denom);\\n        bpdInterval[1] = uint16(MathUpgradeable.min(bpdEnd, 5)); // bpd_first + nx350\\n\\n        return bpdInterval;\\n    }\\n\\n    function addBPDMaxShares(\\n        uint256 oldShares,\\n        uint256 oldStart,\\n        uint256 oldEnd,\\n        uint256 newShares,\\n        uint256 newStart,\\n        uint256 newEnd\\n    ) internal {\\n        uint16[2] memory oldBpdInterval = findBPDs(oldStart, oldEnd);\\n        uint16[2] memory newBpdInterval = findBPDs(newStart, newEnd);\\n        for (uint16 i = oldBpdInterval[0]; i < newBpdInterval[1]; i++) {\\n            uint256 shares = newShares;\\n            if (oldBpdInterval[1] > i) {\\n                shares = shares.sub(oldShares);\\n            }\\n            bpd128.shares[i] += uint128(shares); // we only do integer shares, no decimals\\n        }\\n    }\\n\\n    function addBPDShares(\\n        uint256 shares,\\n        uint256 starttime,\\n        uint256 endtime\\n    ) internal {\\n        uint16[2] memory bpdInterval = findBPDs(starttime, endtime);\\n        for (uint16 i = bpdInterval[0]; i < bpdInterval[1]; i++) {\\n            bpd128.shares[i] += uint128(shares); // we only do integer shares, no decimals\\n        }\\n    }\\n\\n    function calcBPDOnWithdraw(uint256 shares, uint16[2] memory bpdInterval)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 bpdAmount;\\n        uint256 shares1e18 = shares.mul(1e18);\\n        for (uint16 i = bpdInterval[0]; i < bpdInterval[1]; i++) {\\n            bpdAmount += shares1e18.div(bpd128.shares[i]).mul(bpd128.pool[i]);\\n        }\\n\\n        return bpdAmount.div(1e18);\\n    }\\n\\n    /** CalcBPD\\n        @param start - Start of the stake\\n        @param end - ACTUAL End of the stake. We want to calculate using the actual end. We'll use findBPD's to figure out what BPD's the user is eligible for\\n        @param shares - Shares of stake\\n     */\\n    function calcBPD(\\n        uint256 start,\\n        uint256 end,\\n        uint256 shares\\n    ) public view returns (uint256) {\\n        uint16[2] memory bpdInterval = findBPDs(start, end);\\n        return calcBPDOnWithdraw(shares, bpdInterval);\\n    }\\n\\n    function getBPD()\\n        external\\n        view\\n        returns (uint128[5] memory, uint128[5] memory)\\n    {\\n        return (bpd128.pool, bpd128.shares);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IStaking {\\n    function externalStake(\\n        uint256 amount,\\n        uint256 stakingDays,\\n        address staker\\n    ) external;\\n\\n    function updateTokenPricePerShare(\\n        address payable bidderAddress,\\n        address payable originAddress,\\n        address tokenAddress,\\n        uint256 amountBought\\n    ) external payable;\\n\\n    function addDivToken(address tokenAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IStakingV1 {\\n    function sessionDataOf(address, uint256)\\n        external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    function sessionsOf_(address)\\n        external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/DataReader.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.25 <0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n// OpenZeppelin Base\\nimport '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\\n// Abstracts\\nimport './abstracts/Manageable.sol';\\nimport './Staking.sol';\\n// Interfaces\\nimport './interfaces/IAuctionData.sol';\\nimport './interfaces/IStakingData.sol';\\nimport './interfaces/IStakingV1.sol';\\nimport './interfaces/IAuctionV1.sol';\\n\\ncontract DataReader is Initializable, Manageable {\\n    using SafeMathUpgradeable for uint256;\\n\\n    struct StakeV1 {\\n        uint256 sessionId;\\n        uint256 amount;\\n        uint256 start;\\n        uint256 end;\\n        uint256 shares;\\n        uint256 firstPayout;\\n    }\\n\\n    struct StakeV2 {\\n        uint256 sessionId;\\n        uint256 amount;\\n        uint256 start;\\n        uint256 end;\\n        uint256 shares;\\n        uint256 firstPayout;\\n        uint256 lastPayout;\\n        bool withdrawn;\\n        uint256 payout;\\n    }\\n\\n    struct AuctionBid {\\n        uint256 auctionId;\\n        uint256 eth;\\n        address ref;\\n    }\\n\\n    IStakingData internal staking;\\n    IStakingV1 internal stakingV1;\\n    IAuctionData internal auction;\\n    IAuctionV1 internal auctionV1;\\n\\n    function initialize(\\n        address _manager,\\n        address _staking,\\n        address _stakingV1,\\n        address _auction,\\n        address _auctionV1\\n    ) public initializer {\\n        _setupRole(MANAGER_ROLE, _manager);\\n\\n        staking = IStakingData(_staking);\\n        stakingV1 = IStakingV1(_stakingV1);\\n        auction = IAuctionData(_auction);\\n        auctionV1 = IAuctionV1(_auctionV1);\\n    }\\n\\n    function getAuctionBidsV1(address account)\\n        external\\n        view\\n        returns (AuctionBid[] memory)\\n    {\\n        uint256[] memory v1BidsOfAccount = auctionV1.auctionsOf_(account);\\n        AuctionBid[] memory bids = new AuctionBid[](v1BidsOfAccount.length);\\n\\n        for (uint256 i = 0; i < v1BidsOfAccount.length; i++) {\\n            (uint256 eth, address ref) =\\n                auctionV1.auctionBetOf(v1BidsOfAccount[i], account);\\n\\n            if (v1BidsOfAccount[i] > auction.lastAuctionEventIdV1()) continue;\\n\\n            bids[i] = AuctionBid({\\n                auctionId: v1BidsOfAccount[i],\\n                eth: eth,\\n                ref: ref\\n            });\\n        }\\n\\n        return bids;\\n    }\\n\\n    function getAuctionBidsV2(address account)\\n        external\\n        view\\n        returns (AuctionBid[] memory)\\n    {\\n        uint256[] memory v2BidsOfAccount = auction.auctionsOf_(account);\\n        AuctionBid[] memory bids = new AuctionBid[](v2BidsOfAccount.length);\\n\\n        for (uint256 i = 0; i < v2BidsOfAccount.length; i++) {\\n            (uint256 eth, address ref) =\\n                auction.auctionBidOf(v2BidsOfAccount[i], account);\\n\\n            bids[i] = AuctionBid({\\n                auctionId: v2BidsOfAccount[i],\\n                eth: eth,\\n                ref: ref\\n            });\\n        }\\n\\n        return bids;\\n    }\\n\\n    function getSessionsV2(address account)\\n        external\\n        view\\n        returns (StakeV2[] memory)\\n    {\\n        uint256[] memory v2SessionsOfAccount = staking.sessionsOf_(account);\\n        StakeV2[] memory stakes = new StakeV2[](v2SessionsOfAccount.length);\\n        for (uint256 i = 0; i < v2SessionsOfAccount.length; i++) {\\n            (\\n                uint256 amount,\\n                uint256 start,\\n                uint256 end,\\n                uint256 shares,\\n                uint256 firstPayout,\\n                uint256 lastPayout,\\n                bool withdrawn,\\n                uint256 payout\\n            ) = staking.sessionDataOf(account, v2SessionsOfAccount[i]);\\n\\n            stakes[i] = StakeV2({\\n                sessionId: v2SessionsOfAccount[i],\\n                amount: amount,\\n                start: start,\\n                end: end,\\n                shares: shares,\\n                firstPayout: firstPayout,\\n                lastPayout: lastPayout,\\n                withdrawn: withdrawn,\\n                payout: payout\\n            });\\n        }\\n\\n        return stakes;\\n    }\\n\\n    function getSessionsV1(address account)\\n        external\\n        view\\n        returns (StakeV1[] memory)\\n    {\\n        uint256[] memory v1SessionsOfAccount = stakingV1.sessionsOf_(account);\\n        StakeV1[] memory stakes = new StakeV1[](v1SessionsOfAccount.length);\\n        for (uint256 i = 0; i < v1SessionsOfAccount.length; i++) {\\n            if (v1SessionsOfAccount[i] > staking.lastSessionIdV1()) continue; //make sure we only take layer 1 stakes in consideration\\n\\n            (\\n                uint256 amount,\\n                uint256 start,\\n                uint256 end,\\n                uint256 shares,\\n                uint256 firstPayout\\n            ) = stakingV1.sessionDataOf(account, v1SessionsOfAccount[i]);\\n\\n            stakes[i] = StakeV1({\\n                sessionId: v1SessionsOfAccount[i],\\n                amount: amount,\\n                start: start,\\n                end: end,\\n                shares: shares,\\n                firstPayout: firstPayout\\n            });\\n        }\\n\\n        return stakes;\\n    }\\n\\n    function getDaoShares(address account) external view returns (uint256) {\\n        uint256 totalShares;\\n\\n        uint256[] memory v2SessionsOfAccount = staking.sessionsOf_(account);\\n        for (uint256 i = 0; i < v2SessionsOfAccount.length; i++) {\\n            (\\n                ,\\n                uint256 start,\\n                uint256 end,\\n                uint256 shares,\\n                ,\\n                ,\\n                bool withdrawn,\\n\\n            ) = staking.sessionDataOf(account, v2SessionsOfAccount[i]);\\n            uint256 stakingDays = (end - start) / staking.stepTimestamp();\\n\\n            if (withdrawn || stakingDays < 350) {\\n                continue;\\n            }\\n\\n            totalShares = totalShares.add(shares);\\n        }\\n\\n        uint256[] memory v1SessionsOfAccount = stakingV1.sessionsOf_(account);\\n\\n        for (uint256 i = 0; i < v1SessionsOfAccount.length; i++) {\\n            (, , , uint256 sharesV2, , , , ) =\\n                staking.sessionDataOf(account, v1SessionsOfAccount[i]);\\n\\n            if (sharesV2 != 0)\\n                //make sure the stake was not withdran.\\n                continue;\\n\\n            if (v1SessionsOfAccount[i] > staking.lastSessionIdV1()) continue; //make sure we only take layer 1 stakes in consideration\\n\\n            (, uint256 start, uint256 end, uint256 shares, ) =\\n                stakingV1.sessionDataOf(account, v1SessionsOfAccount[i]);\\n\\n            uint256 stakingDays = (end - start) / staking.stepTimestamp();\\n            if (shares == 0 || stakingDays < 350) continue;\\n\\n            totalShares = totalShares.add(shares); //calclate total shares\\n        }\\n\\n        return totalShares;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAuctionData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IAuctionData {\\n    function auctionsOf_(address) external view returns (uint256[] memory);\\n\\n    function auctionBidOf(uint256, address)\\n        external\\n        view\\n        returns (uint256, address);\\n\\n    function lastAuctionEventIdV1() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IStakingData {\\n    function sessionDataOf(address, uint256)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            bool,\\n            uint256\\n        );\\n\\n    function sessionsOf_(address) external view returns (uint256[] memory);\\n\\n    function lastSessionIdV1() external view returns (uint256);\\n\\n    function stepTimestamp() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAuctionV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IAuctionV1 {\\n    function auctionsOf_(address) external view returns (uint256[] memory);\\n\\n    function auctionBetOf(uint256, address)\\n        external\\n        view\\n        returns (uint256, address);\\n}\\n\"\r\n    },\r\n    \"contracts/Auction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n\\n/** OpenZeppelin Dependencies */\\n// import \\\"@openzeppelin/contracts-upgradeable/contracts/proxy/Initializable.sol\\\";\\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\\n/** Uniswap */\\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\\n/** Local Interfaces */\\nimport './interfaces/IToken.sol';\\nimport './interfaces/IAuction.sol';\\nimport './interfaces/IStaking.sol';\\nimport './interfaces/IAuctionV1.sol';\\n\\ncontract Auction is IAuction, Initializable, AccessControlUpgradeable {\\n    using SafeMathUpgradeable for uint256;\\n\\n    /** Events */\\n    event Bid(\\n        address indexed account,\\n        uint256 value,\\n        uint256 indexed auctionId,\\n        uint256 time\\n    );\\n\\n    event VentureBid(\\n        address indexed account,\\n        uint256 ethBid,\\n        uint256 indexed auctionId,\\n        uint256 time,\\n        address[] coins,\\n        uint256[] amountBought\\n    );\\n\\n    event Withdraval(\\n        address indexed account,\\n        uint256 value,\\n        uint256 indexed auctionId,\\n        uint256 time,\\n        uint256 stakeDays\\n    );\\n\\n    event AuctionIsOver(uint256 eth, uint256 token, uint256 indexed auctionId);\\n\\n    /** Structs */\\n    struct AuctionReserves {\\n        uint256 eth; // Amount of Eth in the auction\\n        uint256 token; // Amount of Axn in auction for day\\n        uint256 uniswapLastPrice; // Last known uniswap price from last bid\\n        uint256 uniswapMiddlePrice; // Using middle price days to calculate avg price\\n    }\\n\\n    struct UserBid {\\n        uint256 eth; // Amount of ethereum\\n        address ref; // Referrer address for bid\\n        bool withdrawn; // Determine withdrawn\\n    }\\n\\n    struct Addresses {\\n        address mainToken; // Axion token address\\n        address staking; // Staking platform\\n        address payable uniswap; // Uniswap Main Router\\n        address payable recipient; // Origin address for excess ethereum in auction\\n    }\\n\\n    struct Options {\\n        uint256 autoStakeDays; // # of days bidder must stake once axion is won from auction\\n        uint256 referrerPercent; // Referral Bonus %\\n        uint256 referredPercent; // Referral Bonus %\\n        bool referralsOn; // If on referrals are used on auction\\n        uint256 discountPercent; // Discount in comparison to uniswap price in auction\\n        uint256 premiumPercent; // Premium in comparions to unsiwap price in auction\\n    }\\n\\n    /** Roles */\\n    bytes32 public constant MIGRATOR_ROLE = keccak256('MIGRATOR_ROLE');\\n    bytes32 public constant MANAGER_ROLE = keccak256('MANAGER_ROLE');\\n    bytes32 public constant CALLER_ROLE = keccak256('CALLER_ROLE');\\n\\n    /** Mapping */\\n    mapping(uint256 => AuctionReserves) public reservesOf; // [day],\\n    mapping(address => uint256[]) public auctionsOf;\\n    mapping(uint256 => mapping(address => UserBid)) public auctionBidOf;\\n    mapping(uint256 => mapping(address => bool)) public existAuctionsOf;\\n\\n    /** Simple types */\\n    uint256 public lastAuctionEventId; // Index for Auction\\n    uint256 public lastAuctionEventIdV1; // Last index for layer 1 auction\\n    uint256 public start; // Beginning of contract\\n    uint256 public stepTimestamp; // # of seconds per \\\"axion day\\\" (86400)\\n\\n    Options public options; // Auction options (see struct above)\\n    Addresses public addresses; // (See Address struct above)\\n    IAuctionV1 public auctionV1; // V1 Auction contract for backwards compatibility\\n\\n    bool public init_; // Unneeded legacy variable to ensure init is only called once.\\n\\n    mapping(uint256 => mapping(address => uint256)) public autoStakeDaysOf; // NOT USED\\n\\n    uint256 public middlePriceDays; // When calculating auction price this is used to determine average\\n\\n    struct VentureToken {\\n        address coin; // address of token to buy from swap\\n        uint96 percentage; // % of token to buy NOTE: (On a VCA day all Venture tokens % should add up to 100%)\\n    }\\n\\n    struct AuctionData {\\n        uint8 mode; // 1 = VCA, 0 = Normal Auction\\n        VentureToken[] tokens; // Tokens to buy in VCA\\n    }\\n\\n    AuctionData[7] internal auctions; // 7 values for 7 days of the week\\n    uint8 internal ventureAutoStakeDays; // # of auto stake days for VCA Auction\\n\\n    /* UGPADEABILITY: New variables must go below here. */\\n\\n    /** modifiers */\\n    modifier onlyCaller() {\\n        require(\\n            hasRole(CALLER_ROLE, _msgSender()),\\n            'Caller is not a caller role'\\n        );\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        require(\\n            hasRole(MANAGER_ROLE, _msgSender()),\\n            'Caller is not a manager role'\\n        );\\n        _;\\n    }\\n\\n    modifier onlyMigrator() {\\n        require(\\n            hasRole(MIGRATOR_ROLE, _msgSender()),\\n            'Caller is not a migrator'\\n        );\\n        _;\\n    }\\n\\n    /** Update Price of current auction\\n        Get current axion day\\n        Get uniswapLastPrice\\n        Set middlePrice\\n     */\\n    function _updatePrice() internal {\\n        uint256 currentAuctionId = getCurrentAuctionId();\\n\\n        /** Set reserves of */\\n        reservesOf[currentAuctionId].uniswapLastPrice = getUniswapLastPrice();\\n        reservesOf[currentAuctionId]\\n            .uniswapMiddlePrice = getUniswapMiddlePriceForDays();\\n    }\\n\\n    /**\\n        Get token paths\\n        Use uniswap to buy tokens back and send to staking platform using (addresses.staking)\\n\\n        @param tokenAddress {address} - Token to buy from uniswap\\n        @param amountOutMin {uint256} - Slippage tolerance for router\\n        @param amount {uint256} - Min amount expected\\n        @param deadline {uint256} - Deadline for trade (used for uniswap router)\\n     */\\n    function _swapEthForToken(\\n        address tokenAddress,\\n        uint256 amountOutMin,\\n        uint256 amount,\\n        uint256 deadline\\n    ) private returns (uint256) {\\n        address[] memory path = new address[](2);\\n\\n        path[0] = IUniswapV2Router02(addresses.uniswap).WETH();\\n        path[1] = tokenAddress;\\n\\n        return\\n            IUniswapV2Router02(addresses.uniswap).swapExactETHForTokens{\\n                value: amount\\n            }(amountOutMin, path, addresses.staking, deadline)[1];\\n    }\\n\\n    /**\\n        Bid function which routes to either venture bid or bid internal\\n\\n        @param amountOutMin {uint256[]} - Slippage tolerance for uniswap router \\n        @param deadline {uint256} - Deadline for trade (used for uniswap router)\\n        @param ref {address} - Referrer Address to get % axion from bid\\n     */\\n    function bid(\\n        uint256[] calldata amountOutMin,\\n        uint256 deadline,\\n        address ref\\n    ) external payable {\\n        uint256 currentDay = getCurrentDay();\\n        uint8 auctionMode = auctions[currentDay].mode;\\n\\n        if (auctionMode == 0) {\\n            bidInternal(amountOutMin[0], deadline, ref);\\n        } else if (auctionMode == 1) {\\n            ventureBid(amountOutMin, deadline, currentDay);\\n        }\\n    }\\n\\n    /**\\n        BidInternal - Buys back axion from uniswap router and sends to staking platform\\n\\n        @param amountOutMin {uint256} - Slippage tolerance for uniswap router \\n        @param deadline {uint256} - Deadline for trade (used for uniswap router)\\n        @param ref {address} - Referrer Address to get % axion from bid\\n     */\\n    function bidInternal(\\n        uint256 amountOutMin,\\n        uint256 deadline,\\n        address ref\\n    ) internal {\\n        _saveAuctionData();\\n        _updatePrice();\\n\\n        /** Can not refer self */\\n        require(_msgSender() != ref, 'msg.sender == ref');\\n\\n        /** Get percentage for recipient and uniswap (Extra function really unnecessary) */\\n        (uint256 toRecipient, uint256 toUniswap) =\\n            _calculateRecipientAndUniswapAmountsToSend();\\n\\n        /** Buy back tokens from uniswap and send to staking contract */\\n        _swapEthForToken(\\n            addresses.mainToken,\\n            amountOutMin,\\n            toUniswap,\\n            deadline\\n        );\\n\\n        /** Get Auction ID */\\n        uint256 auctionId = getCurrentAuctionId();\\n\\n        /** If referralsOn is true allow to set ref */\\n        if (options.referralsOn == true) {\\n            auctionBidOf[auctionId][_msgSender()].ref = ref;\\n        }\\n\\n        /** Run common shared functionality between VCA and Normal */\\n        bidCommon(auctionId);\\n\\n        /** Transfer any eithereum in contract to recipient address */\\n        addresses.recipient.transfer(toRecipient);\\n\\n        /** Send event to blockchain */\\n        emit Bid(msg.sender, msg.value, auctionId, now);\\n    }\\n\\n    /**\\n        BidInternal - Buys back axion from uniswap router and sends to staking platform\\n\\n        @param amountOutMin {uint256[]} - Slippage tolerance for uniswap router \\n        @param deadline {uint256} - Deadline for trade (used for uniswap router)\\n        @param currentDay {uint256} - currentAuctionId\\n     */\\n    function ventureBid(\\n        uint256[] memory amountOutMin,\\n        uint256 deadline,\\n        uint256 currentDay\\n    ) internal {\\n        _saveAuctionData();\\n        _updatePrice();\\n\\n        /** Get the token(s) of the day */\\n        VentureToken[] storage tokens = auctions[currentDay].tokens;\\n        /** Create array to determine amount bought for each token */\\n        address[] memory coinsBought = new address[](tokens.length);\\n        uint256[] memory amountsBought = new uint256[](tokens.length);\\n\\n        /** Loop over tokens to purchase */\\n        for (uint8 i = 0; i < tokens.length; i++) {\\n            /** Determine amount to purchase based on ethereum bid */\\n            uint256 amountBought;\\n            uint256 amountToBuy = msg.value.mul(tokens[i].percentage).div(100);\\n\\n            /** If token is 0xFFfFfF... we buy no token and just distribute the bidded ethereum */\\n            if (\\n                tokens[i].coin !=\\n                address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)\\n            ) {\\n                amountBought = _swapEthForToken(\\n                    tokens[i].coin,\\n                    amountOutMin[i],\\n                    amountToBuy,\\n                    deadline\\n                );\\n\\n                IStaking(addresses.staking).updateTokenPricePerShare(\\n                    msg.sender,\\n                    addresses.recipient,\\n                    tokens[i].coin,\\n                    amountBought\\n                );\\n            } else {\\n                amountBought = amountToBuy;\\n\\n                IStaking(addresses.staking).updateTokenPricePerShare{\\n                    value: amountToBuy\\n                }(msg.sender, addresses.recipient, tokens[i].coin, amountToBuy); // Payable amount\\n            }\\n\\n            coinsBought[i] = tokens[i].coin;\\n            amountsBought[i] = amountBought;\\n        }\\n\\n        uint256 currentAuctionId = getCurrentAuctionId();\\n        bidCommon(currentAuctionId);\\n\\n        emit VentureBid(\\n            msg.sender,\\n            msg.value,\\n            currentAuctionId,\\n            now,\\n            coinsBought,\\n            amountsBought\\n        );\\n    }\\n\\n    /**\\n        Bid Common - Set common values for bid\\n\\n        @param auctionId (uint256) - ID of auction\\n     */\\n    function bidCommon(uint256 auctionId) internal {\\n        /** Set auctionBid for bidder */\\n        auctionBidOf[auctionId][_msgSender()].eth = auctionBidOf[auctionId][\\n            _msgSender()\\n        ]\\n            .eth\\n            .add(msg.value);\\n\\n        /** Set existsOf in order to include all auction bids for current user into one */\\n        if (!existAuctionsOf[auctionId][_msgSender()]) {\\n            auctionsOf[_msgSender()].push(auctionId);\\n            existAuctionsOf[auctionId][_msgSender()] = true;\\n        }\\n\\n        reservesOf[auctionId].eth = reservesOf[auctionId].eth.add(msg.value);\\n    }\\n\\n    /**\\n        getUniswapLastPrice - Use uniswap router to determine current price based on ethereum\\n    */\\n    function getUniswapLastPrice() internal view returns (uint256) {\\n        address[] memory path = new address[](2);\\n\\n        path[0] = IUniswapV2Router02(addresses.uniswap).WETH();\\n        path[1] = addresses.mainToken;\\n\\n        uint256 price =\\n            IUniswapV2Router02(addresses.uniswap).getAmountsOut(1e18, path)[1];\\n\\n        return price;\\n    }\\n\\n    /**\\n        getUniswapMiddlePriceForDays\\n            Use the \\\"last known price\\\" for the last {middlePriceDays} days to determine middle price by taking an average\\n     */\\n    function getUniswapMiddlePriceForDays() internal view returns (uint256) {\\n        uint256 currentAuctionId = getCurrentAuctionId();\\n\\n        uint256 index = currentAuctionId;\\n        uint256 sum;\\n        uint256 points;\\n\\n        while (points != middlePriceDays) {\\n            if (reservesOf[index].uniswapLastPrice != 0) {\\n                sum = sum.add(reservesOf[index].uniswapLastPrice);\\n                points = points.add(1);\\n            }\\n\\n            if (index == 0) break;\\n\\n            index = index.sub(1);\\n        }\\n\\n        if (sum == 0) return getUniswapLastPrice();\\n        else return sum.div(points);\\n    }\\n\\n    /**\\n        withdraw - Withdraws an auction bid and stakes axion in staking contract\\n\\n        @param auctionId {uint256} - Auction to withdraw from\\n        @param stakeDays {uint256} - # of days to stake in portal\\n     */\\n    function withdraw(uint256 auctionId, uint256 stakeDays) external {\\n        _saveAuctionData();\\n        _updatePrice();\\n\\n        /** Require the # of days staking > options */\\n        uint8 auctionMode = auctions[auctionId.mod(7)].mode;\\n        if (auctionMode == 0) {\\n            require(\\n                stakeDays >= options.autoStakeDays,\\n                'Auction: stakeDays < minimum days'\\n            );\\n        } else if (auctionMode == 1) {\\n            require(\\n                stakeDays >= ventureAutoStakeDays,\\n                'Auction: stakeDays < minimum days'\\n            );\\n        }\\n\\n        /** Require # of staking days < 5556 */\\n        require(stakeDays <= 5555, 'Auction: stakeDays > 5555');\\n\\n        uint256 currentAuctionId = getCurrentAuctionId();\\n        UserBid storage userBid = auctionBidOf[auctionId][_msgSender()];\\n\\n        /** Ensure auctionId of withdraw is not todays auction, and user bid has not been withdrawn and eth > 0 */\\n        require(currentAuctionId > auctionId, 'Auction: Auction is active');\\n        require(\\n            userBid.eth > 0 && userBid.withdrawn == false,\\n            'Auction: Zero bid or withdrawn'\\n        );\\n\\n        /** Set Withdrawn to true */\\n        userBid.withdrawn = true;\\n\\n        /** Call common withdraw functions */\\n        withdrawInternal(\\n            userBid.ref,\\n            userBid.eth,\\n            auctionId,\\n            currentAuctionId,\\n            stakeDays\\n        );\\n    }\\n\\n    /**\\n        withdraw - Withdraws an auction bid and stakes axion in staking contract\\n\\n        @param auctionId {uint256} - Auction to withdraw from\\n        @param stakeDays {uint256} - # of days to stake in portal\\n        NOTE: No longer needed, as there is most likely not more bids from v1 that have not been withdraw \\n     */\\n    function withdrawV1(uint256 auctionId, uint256 stakeDays) external {\\n        _saveAuctionData();\\n        _updatePrice();\\n\\n        // Backward compatability with v1 auction\\n        require(\\n            auctionId <= lastAuctionEventIdV1,\\n            'Auction: Invalid auction id'\\n        );\\n        /** Ensure stake days > options  */\\n        require(\\n            stakeDays >= options.autoStakeDays,\\n            'Auction: stakeDays < minimum days'\\n        );\\n        require(stakeDays <= 5555, 'Auction: stakeDays > 5555');\\n\\n        uint256 currentAuctionId = getCurrentAuctionId();\\n        require(currentAuctionId > auctionId, 'Auction: Auction is active');\\n\\n        /** This stops a user from using WithdrawV1 twice, since the bid is put into memory at the end */\\n        UserBid storage userBid = auctionBidOf[auctionId][_msgSender()];\\n        require(\\n            userBid.eth == 0 && userBid.withdrawn == false,\\n            'Auction: Invalid auction ID'\\n        );\\n\\n        (uint256 eth, address ref) =\\n            auctionV1.auctionBetOf(auctionId, _msgSender());\\n        require(eth > 0, 'Auction: Zero balance in auction/invalid auction ID');\\n\\n        /** Common withdraw functionality */\\n        withdrawInternal(ref, eth, auctionId, currentAuctionId, stakeDays);\\n\\n        /** Bring v1 auction bid to v2 */\\n        auctionBidOf[auctionId][_msgSender()] = UserBid({\\n            eth: eth,\\n            ref: ref,\\n            withdrawn: true\\n        });\\n\\n        auctionsOf[_msgSender()].push(auctionId);\\n    }\\n\\n    function withdrawInternal(\\n        address ref,\\n        uint256 eth,\\n        uint256 auctionId,\\n        uint256 currentAuctionId,\\n        uint256 stakeDays\\n    ) internal {\\n        /** Calculate payout for bidder */\\n        uint256 payout = _calculatePayout(auctionId, eth);\\n        uint256 uniswapPayoutWithPercent =\\n            _calculatePayoutWithUniswap(auctionId, eth, payout);\\n\\n        /** If auction is undersold, send overage to weekly auction */\\n        if (payout > uniswapPayoutWithPercent) {\\n            uint256 nextWeeklyAuction = calculateNearestWeeklyAuction();\\n\\n            reservesOf[nextWeeklyAuction].token = reservesOf[nextWeeklyAuction]\\n                .token\\n                .add(payout.sub(uniswapPayoutWithPercent));\\n\\n            payout = uniswapPayoutWithPercent;\\n        }\\n\\n        /** If referrer is empty simple task */\\n        if (address(ref) == address(0)) {\\n            /** Burn tokens and then call external stake on staking contract */\\n            IToken(addresses.mainToken).burn(address(this), payout);\\n            IStaking(addresses.staking).externalStake(\\n                payout,\\n                stakeDays,\\n                _msgSender()\\n            );\\n\\n            emit Withdraval(\\n                msg.sender,\\n                payout,\\n                currentAuctionId,\\n                now,\\n                stakeDays\\n            );\\n        } else {\\n            /** Burn tokens and determine referral amount */\\n            IToken(addresses.mainToken).burn(address(this), payout);\\n            (uint256 toRefMintAmount, uint256 toUserMintAmount) =\\n                _calculateRefAndUserAmountsToMint(payout);\\n\\n            /** Add referral % to payout */\\n            payout = payout.add(toUserMintAmount);\\n\\n            /** Call external stake for referrer and bidder */\\n            IStaking(addresses.staking).externalStake(\\n                payout,\\n                stakeDays,\\n                _msgSender()\\n            );\\n\\n            /** We do not want to mint if the referral address is the dEaD address */\\n            if(address(ref) != address(0x000000000000000000000000000000000000dEaD)) {\\n                IStaking(addresses.staking).externalStake(toRefMintAmount, 14, ref);\\n            }\\n\\n            emit Withdraval(\\n                msg.sender,\\n                payout,\\n                currentAuctionId,\\n                now,\\n                stakeDays\\n            );\\n        }\\n    }\\n\\n    /** External Contract Caller functions \\n        @param amount {uint256} - amount to add to next dailyAuction\\n    */\\n    function callIncomeDailyTokensTrigger(uint256 amount)\\n        external\\n        override\\n        onlyCaller\\n    {\\n        // Adds a specified amount of axion to tomorrows auction\\n        uint256 currentAuctionId = getCurrentAuctionId();\\n        uint256 nextAuctionId = currentAuctionId + 1;\\n\\n        reservesOf[nextAuctionId].token = reservesOf[nextAuctionId].token.add(\\n            amount\\n        );\\n    }\\n\\n    /** Add Reserves to specified Auction\\n        @param daysInFuture {uint256} - CurrentAuctionId + daysInFuture to send Axion to\\n        @param amount {uint256} - Amount of axion to add to auction\\n     */\\n    function addReservesToAuction(uint256 daysInFuture, uint256 amount)\\n        external\\n        override\\n        onlyCaller\\n        returns (uint256)\\n    {\\n        // Adds a specified amount of axion to a future auction\\n        require(\\n            daysInFuture <= 365,\\n            'AUCTION: Days in future can not be greater then 365'\\n        );\\n\\n        uint256 currentAuctionId = getCurrentAuctionId();\\n        uint256 auctionId = currentAuctionId + daysInFuture;\\n\\n        reservesOf[auctionId].token = reservesOf[auctionId].token.add(amount);\\n\\n        return auctionId;\\n    }\\n\\n    /** Add reserves to next weekly auction\\n        @param amount {uint256} - Amount of axion to add to auction\\n     */\\n    function callIncomeWeeklyTokensTrigger(uint256 amount)\\n        external\\n        override\\n        onlyCaller\\n    {\\n        // Adds a specified amount of axion to the next nearest weekly auction\\n        uint256 nearestWeeklyAuction = calculateNearestWeeklyAuction();\\n\\n        reservesOf[nearestWeeklyAuction].token = reservesOf[\\n            nearestWeeklyAuction\\n        ]\\n            .token\\n            .add(amount);\\n    }\\n\\n    /** Calculate functions */\\n    function calculateNearestWeeklyAuction() public view returns (uint256) {\\n        uint256 currentAuctionId = getCurrentAuctionId();\\n        return currentAuctionId.add(uint256(7).sub(currentAuctionId.mod(7)));\\n    }\\n\\n    /** Get current day of week\\n     * EX: friday = 0, saturday = 1, sunday = 2 etc...\\n     */\\n    function getCurrentDay() internal view returns (uint256) {\\n        uint256 currentAuctionId = getCurrentAuctionId();\\n        return currentAuctionId.mod(7);\\n    }\\n\\n    function getCurrentAuctionId() public view returns (uint256) {\\n        return now.sub(start).div(stepTimestamp);\\n    }\\n\\n    function calculateStepsFromStart() public view returns (uint256) {\\n        return now.sub(start).div(stepTimestamp);\\n    }\\n\\n    /** Determine payout and overage\\n        @param auctionId {uint256} - Auction id to calculate price from\\n        @param amount {uint256} - Amount to use to determine overage\\n        @param payout {uint256} - payout\\n     */\\n    function _calculatePayoutWithUniswap(\\n        uint256 auctionId,\\n        uint256 amount,\\n        uint256 payout\\n    ) internal view returns (uint256) {\\n        // Get payout for user\\n        uint256 uniswapPayout =\\n            reservesOf[auctionId].uniswapMiddlePrice.mul(amount).div(1e18);\\n\\n        // Get payout with percentage based on discount, premium\\n        uint256 uniswapPayoutWithPercent =\\n            uniswapPayout\\n                .add(uniswapPayout.mul(options.discountPercent).div(100))\\n                .sub(uniswapPayout.mul(options.premiumPercent).div(100));\\n\\n        if (payout > uniswapPayoutWithPercent) {\\n            return uniswapPayoutWithPercent;\\n        } else {\\n            return payout;\\n        }\\n    }\\n\\n    /** Determine payout based on amount of token and ethereum\\n        @param auctionId {uint256} - auction to determine payout of\\n        @param amount {uint256} - amount of axion\\n     */\\n    function _calculatePayout(uint256 auctionId, uint256 amount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            amount.mul(reservesOf[auctionId].token).div(\\n                reservesOf[auctionId].eth\\n            );\\n    }\\n\\n    /** Get Percentages for recipient and uniswap for ethereum bid Unnecessary function */\\n    function _calculateRecipientAndUniswapAmountsToSend()\\n        private\\n        returns (uint256, uint256)\\n    {\\n        uint256 toRecipient = msg.value.mul(20).div(100);\\n        uint256 toUniswap = msg.value.sub(toRecipient);\\n\\n        return (toRecipient, toUniswap);\\n    }\\n\\n    /** Determine amount of axion to mint for referrer based on amount\\n        @param amount {uint256} - amount of axion\\n\\n        @return (uint256, uint256)\\n     */\\n    function _calculateRefAndUserAmountsToMint(uint256 amount)\\n        private\\n        view\\n        returns (uint256, uint256)\\n    {\\n        uint256 toRefMintAmount = amount.mul(options.referrerPercent).div(100);\\n        uint256 toUserMintAmount = amount.mul(options.referredPercent).div(100);\\n\\n        return (toRefMintAmount, toUserMintAmount);\\n    }\\n\\n    /** Save auction data\\n        Determines if auction is over. If auction is over set lastAuctionId to currentAuctionId\\n    */\\n    function _saveAuctionData() internal {\\n        uint256 currentAuctionId = getCurrentAuctionId();\\n        AuctionReserves memory reserves = reservesOf[lastAuctionEventId];\\n\\n        if (lastAuctionEventId < currentAuctionId) {\\n            emit AuctionIsOver(\\n                reserves.eth,\\n                reserves.token,\\n                lastAuctionEventId\\n            );\\n            lastAuctionEventId = currentAuctionId;\\n        }\\n    }\\n\\n    function initialize(address _manager, address _migrator)\\n        public\\n        initializer\\n    {\\n        _setupRole(MANAGER_ROLE, _manager);\\n        _setupRole(MIGRATOR_ROLE, _migrator);\\n        init_ = false;\\n    }\\n\\n    /** Public Setter Functions */\\n    function setReferrerPercentage(uint256 percent) external onlyManager {\\n        options.referrerPercent = percent;\\n    }\\n\\n    function setReferredPercentage(uint256 percent) external onlyManager {\\n        options.referredPercent = percent;\\n    }\\n\\n    function setReferralsOn(bool _referralsOn) external onlyManager {\\n        options.referralsOn = _referralsOn;\\n    }\\n\\n    function setAutoStakeDays(uint256 _autoStakeDays) external onlyManager {\\n        options.autoStakeDays = _autoStakeDays;\\n    }\\n\\n    function setVentureAutoStakeDays(uint8 _autoStakeDays)\\n        external\\n        onlyManager\\n    {\\n        ventureAutoStakeDays = _autoStakeDays;\\n    }\\n\\n    function setDiscountPercent(uint256 percent) external onlyManager {\\n        options.discountPercent = percent;\\n    }\\n\\n    function setPremiumPercent(uint256 percent) external onlyManager {\\n        options.premiumPercent = percent;\\n    }\\n\\n    function setMiddlePriceDays(uint256 _middleDays) external onlyManager {\\n        middlePriceDays = _middleDays;\\n    }\\n\\n    /** Roles management - only for multi sig address */\\n    function setupRole(bytes32 role, address account) external onlyManager {\\n        _setupRole(role, account);\\n    }\\n\\n    /** VCA Setters */\\n    /**\\n        @param _day {uint8} 0 - 6 value. 0 represents Saturday, 6 Represents Friday\\n        @param _mode {uint8} 0 or 1. 1 VCA, 0 Normal\\n     */\\n    function setAuctionMode(uint8 _day, uint8 _mode) external onlyManager {\\n        auctions[_day].mode = _mode;\\n    }\\n\\n    /**\\n        @param day {uint8} 0 - 6 value. 0 represents Saturday, 6 Represents Friday\\n        @param coins {address[]} - Addresses to buy from uniswap\\n        @param percentages {uint8[]} - % of coin to buy, must add up to 100%\\n     */\\n    function setTokensOfDay(\\n        uint8 day,\\n        address[] calldata coins,\\n        uint8[] calldata percentages\\n    ) external onlyManager {\\n        AuctionData storage auction = auctions[day];\\n\\n        auction.mode = 1;\\n        delete auction.tokens;\\n\\n        uint8 percent = 0;\\n        for (uint8 i; i < coins.length; i++) {\\n            auction.tokens.push(VentureToken(coins[i], percentages[i]));\\n            percent = percentages[i] + percent;\\n            IStaking(addresses.staking).addDivToken(coins[i]);\\n        }\\n\\n        require(\\n            percent == 100,\\n            'AUCTION: Percentage for venture day must equal 100'\\n        );\\n    }\\n\\n    /** Getter functions */\\n    function auctionsOf_(address account)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return auctionsOf[account];\\n    }\\n\\n    function getAuctionModes() external view returns (uint8[7] memory) {\\n        uint8[7] memory auctionModes;\\n\\n        for (uint8 i; i < auctions.length; i++) {\\n            auctionModes[i] = auctions[i].mode;\\n        }\\n\\n        return auctionModes;\\n    }\\n\\n    function getTokensOfDay(uint8 _day)\\n        external\\n        view\\n        returns (address[] memory, uint256[] memory)\\n    {\\n        VentureToken[] memory ventureTokens = auctions[_day].tokens;\\n\\n        address[] memory tokens = new address[](ventureTokens.length);\\n        uint256[] memory percentages = new uint256[](ventureTokens.length);\\n\\n        for (uint8 i; i < ventureTokens.length; i++) {\\n            tokens[i] = ventureTokens[i].coin;\\n            percentages[i] = ventureTokens[i].percentage;\\n        }\\n\\n        return (tokens, percentages);\\n    }\\n\\n    function getVentureAutoStakeDays() external view returns (uint8) {\\n        return ventureAutoStakeDays;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/restorable/AuctionRestorable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n/** OpenZeppelin Dependencies Upgradeable */\\n// import \\\"@openzeppelin/contracts-upgradeable/contracts/proxy/Initializable.sol\\\";\\nimport '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\\n/** OpenZepplin non-upgradeable Swap Token (hex3t) */\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n/** Local Interfaces */\\nimport '../Auction.sol';\\n\\ncontract AuctionRestorable is Auction {\\n    function init(\\n        uint256 _stepTimestamp,\\n        address _mainTokenAddress,\\n        address _stakingAddress,\\n        address payable _uniswapAddress,\\n        address payable _recipientAddress,\\n        address _nativeSwapAddress,\\n        address _auctionV1Address\\n    ) external onlyMigrator {\\n        require(!init_, 'Init is active');\\n        init_ = true;\\n        /** Roles */\\n        _setupRole(CALLER_ROLE, _nativeSwapAddress);\\n        _setupRole(CALLER_ROLE, _stakingAddress);\\n\\n        // Timer\\n        if (start == 0) {\\n            start = now;\\n        }\\n\\n        stepTimestamp = _stepTimestamp;\\n\\n        // Options\\n        options = Options({\\n            autoStakeDays: 14,\\n            referrerPercent: 20,\\n            referredPercent: 10,\\n            referralsOn: true,\\n            discountPercent: 20,\\n            premiumPercent: 0\\n        });\\n\\n        // Addresses\\n        auctionV1 = IAuctionV1(_auctionV1Address);\\n        addresses = Addresses({\\n            mainToken: _mainTokenAddress,\\n            staking: _stakingAddress,\\n            uniswap: _uniswapAddress,\\n            recipient: _recipientAddress\\n        });\\n    }\\n\\n    /** Setter methods for contract migration */\\n    function setNormalVariables(uint256 _lastAuctionEventId, uint256 _start)\\n        external\\n        onlyMigrator\\n    {\\n        start = _start;\\n        lastAuctionEventId = _lastAuctionEventId;\\n        lastAuctionEventIdV1 = _lastAuctionEventId;\\n    }\\n\\n    /** TESTING ONLY */\\n    function setLastSessionId(uint256 _lastSessionId) external onlyMigrator {\\n        lastAuctionEventIdV1 = _lastSessionId.sub(1);\\n        lastAuctionEventId = _lastSessionId;\\n    }\\n\\n    function setReservesOf(\\n        uint256[] calldata sessionIds,\\n        uint256[] calldata eths,\\n        uint256[] calldata tokens,\\n        uint256[] calldata uniswapLastPrices,\\n        uint256[] calldata uniswapMiddlePrices\\n    ) external onlyMigrator {\\n        for (uint256 i = 0; i < sessionIds.length; i = i.add(1)) {\\n            reservesOf[sessionIds[i]] = AuctionReserves({\\n                eth: eths[i],\\n                token: tokens[i],\\n                uniswapLastPrice: uniswapLastPrices[i],\\n                uniswapMiddlePrice: uniswapMiddlePrices[i]\\n            });\\n        }\\n    }\\n\\n    function setAuctionsOf(\\n        address[] calldata _userAddresses,\\n        uint256[] calldata _sessionPerAddressCounts,\\n        uint256[] calldata _sessionIds\\n    ) external onlyMigrator {\\n        uint256 sessionIdIdx = 0;\\n        for (uint256 i = 0; i < _userAddresses.length; i = i + 1) {\\n            address userAddress = _userAddresses[i];\\n            uint256 sessionCount = _sessionPerAddressCounts[i];\\n            uint256[] memory sessionIds = new uint256[](sessionCount);\\n            for (uint256 j = 0; j < sessionCount; j = j + 1) {\\n                sessionIds[j] = _sessionIds[sessionIdIdx];\\n                sessionIdIdx = sessionIdIdx + 1;\\n            }\\n            auctionsOf[userAddress] = sessionIds;\\n        }\\n    }\\n\\n    function setAuctionBidOf(\\n        uint256 sessionId,\\n        address[] calldata userAddresses,\\n        uint256[] calldata eths,\\n        address[] calldata refs\\n    ) external onlyMigrator {\\n        for (uint256 i = 0; i < userAddresses.length; i = i.add(1)) {\\n            auctionBidOf[sessionId][userAddresses[i]] = UserBid({\\n                eth: eths[i],\\n                ref: refs[i],\\n                withdrawn: false\\n            });\\n        }\\n    }\\n\\n    function setExistAuctionsOf(\\n        uint256 sessionId,\\n        address[] calldata userAddresses,\\n        bool[] calldata exists\\n    ) external onlyMigrator {\\n        for (uint256 i = 0; i < userAddresses.length; i = i.add(1)) {\\n            existAuctionsOf[sessionId][userAddresses[i]] = exists[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AuctionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n\\n/** OpenZeppelin Dependencies */\\n// import \\\"@openzeppelin/contracts-upgradeable/contracts/proxy/Initializable.sol\\\";\\nimport '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\\n\\n/** Local Interfaces */\\nimport './interfaces/IAuctionManager.sol';\\nimport './interfaces/IAuction.sol';\\nimport './interfaces/IToken.sol';\\n\\nimport './abstracts/Manageable.sol';\\n\\n/**\\nAuction MANAGER should mint up to 250bln axion and most\\nAuction MANAGER should send 50bln to BPD over 5years\\nAuction MANAGER should send up to 200bln to auction\\n*/\\n\\ncontract AuctionManager is IAuctionManager, Initializable, Manageable {\\n    using SafeMathUpgradeable for uint256;\\n\\n    /** Events */\\n    event SentToAuction(uint256 indexed auctionId, uint256 indexed amount);\\n    event SentToBPD(uint256 indexed amount);\\n\\n    /** Structs */\\n    struct Addresses {\\n        address axion;\\n        address auction;\\n        address bpd;\\n    }\\n    /** Constants */\\n    uint256 public constant MAX_MINT = 250000000000;\\n\\n    /** Variables */\\n    uint256 public mintedBPD;\\n    uint256 public mintedAuction;\\n    Addresses public addresses;\\n\\n    /** Inits */\\n    function initialize(\\n        address _manager,\\n        address _axion,\\n        address _auction\\n    ) public initializer {\\n        _setupRole(MANAGER_ROLE, _manager);\\n        _setupRole(DEFAULT_ADMIN_ROLE, _manager);\\n        addresses.axion = _axion;\\n        addresses.bpd = address(0);\\n        addresses.auction = _auction;\\n        mintedBPD = 0;\\n        mintedAuction = 0;\\n    }\\n\\n    /** Main public manager functions */\\n    function sendToAuction(uint256 daysInFuture, uint256 amount)\\n        external\\n        onlyManager\\n    {\\n        _sendToAuction(daysInFuture, amount);\\n    }\\n\\n    function sendToAuctions(\\n        uint256[] calldata daysInFuture,\\n        uint256[] calldata amounts\\n    ) external onlyManager {\\n        require(\\n            daysInFuture.length == amounts.length,\\n            'AUCTION MANAGER: Array lengths must be equal'\\n        );\\n\\n        for (uint256 i = 0; i < daysInFuture.length; i++) {\\n            _sendToAuction(daysInFuture[i], amounts[i]);\\n        }\\n    }\\n\\n    function _sendToAuction(uint256 daysInFuture, uint256 amount) private {\\n        mintedAuction = mintedAuction.add(amount);\\n        require(\\n            mintedAuction.add(mintedBPD) <= MAX_MINT,\\n            'AUCTION MANAGER: Max mint has been reached'\\n        );\\n\\n        /** Mint the tokens send to Auction */\\n        uint256 actualAmount = amount.mul(1e18);\\n        IToken(addresses.axion).mint(addresses.auction, actualAmount);\\n        uint256 auctionId =\\n            IAuction(addresses.auction).addReservesToAuction(\\n                daysInFuture,\\n                actualAmount\\n            );\\n\\n        emit SentToAuction(auctionId, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAuctionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IAuctionManager {\\n}\\n\"\r\n    },\r\n    \"contracts/archive/AuctionV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\\nimport './interfaces/ITokenV1.sol';\\nimport './interfaces/IAuctionV1.sol';\\nimport './interfaces/IStakingV1.sol';\\n\\ncontract AuctionV1 is IAuctionV1, AccessControl {\\n    using SafeMath for uint256;\\n\\n    event Bet(\\n        address indexed account,\\n        uint256 value,\\n        uint256 indexed auctionId,\\n        uint256 indexed time\\n    );\\n\\n    event Withdraval(\\n        address indexed account,\\n        uint256 value,\\n        uint256 indexed auctionId,\\n        uint256 indexed time\\n    );\\n\\n    event AuctionIsOver(uint256 eth, uint256 token, uint256 indexed auctionId);\\n\\n    bytes32 public constant MANAGER_ROLE = keccak256('MANAGER_ROLE');\\n    bytes32 public constant CALLER_ROLE = keccak256('CALLER_ROLE');\\n\\n    struct AuctionReserves {\\n        uint256 eth;\\n        uint256 token;\\n        uint256 uniswapLastPrice;\\n        uint256 uniswapMiddlePrice;\\n    }\\n\\n    struct UserBet {\\n        uint256 eth;\\n        address ref;\\n    }\\n\\n    mapping(uint256 => AuctionReserves) public reservesOf;\\n    mapping(address => uint256[]) public auctionsOf;\\n    mapping(uint256 => mapping(address => UserBet)) public auctionBetOf;\\n    mapping(uint256 => mapping(address => bool)) public existAuctionsOf;\\n\\n    uint256 public lastAuctionEventId;\\n    uint256 public start;\\n    uint256 public stepTimestamp;\\n    uint256 public uniswapPercent;\\n    address public mainToken;\\n    address public staking;\\n    address payable public uniswap;\\n    address payable public recipient;\\n    bool public init_;\\n\\n    modifier onlyCaller() {\\n        require(\\n            hasRole(CALLER_ROLE, _msgSender()),\\n            'Caller is not a caller role'\\n        );\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        require(\\n            hasRole(MANAGER_ROLE, _msgSender()),\\n            'Caller is not a caller role'\\n        );\\n        _;\\n    }\\n\\n    function init(\\n        uint256 _stepTimestamp,\\n        address _manager,\\n        address _mainToken,\\n        address _staking,\\n        address payable _uniswap,\\n        address payable _recipient,\\n        address _nativeSwap,\\n        address _foreignSwap,\\n        address _subbalances\\n    ) external {\\n        _setupRole(MANAGER_ROLE, _manager);\\n        _setupRole(CALLER_ROLE, _nativeSwap);\\n        _setupRole(CALLER_ROLE, _foreignSwap);\\n        _setupRole(CALLER_ROLE, _staking);\\n        _setupRole(CALLER_ROLE, _subbalances);\\n        start = now;\\n        stepTimestamp = _stepTimestamp;\\n        uniswapPercent = 20;\\n        mainToken = _mainToken;\\n        staking = _staking;\\n        uniswap = _uniswap;\\n        recipient = _recipient;\\n    }\\n\\n    function auctionsOf_(address account)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return auctionsOf[account];\\n    }\\n\\n    function setUniswapPercent(uint256 percent) external {\\n        uniswapPercent = percent;\\n    }\\n\\n    function getUniswapLastPrice() public view returns (uint256) {\\n        address[] memory path = new address[](2);\\n\\n        path[0] = IUniswapV2Router02(uniswap).WETH();\\n        path[1] = mainToken;\\n\\n        uint256 price =\\n            IUniswapV2Router02(uniswap).getAmountsOut(1e18, path)[1];\\n\\n        return price;\\n    }\\n\\n    function getUniswapMiddlePriceForSevenDays() public view returns (uint256) {\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n\\n        uint256 index = stepsFromStart;\\n        uint256 sum;\\n        uint256 points;\\n\\n        while (points != 7) {\\n            if (reservesOf[index].uniswapLastPrice != 0) {\\n                sum = sum.add(reservesOf[index].uniswapLastPrice);\\n                points = points.add(1);\\n            }\\n\\n            if (index == 0) break;\\n\\n            index = index.sub(1);\\n        }\\n\\n        if (sum == 0) return getUniswapLastPrice();\\n        else return sum.div(points);\\n    }\\n\\n    function _updatePrice() internal {\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n\\n        reservesOf[stepsFromStart].uniswapLastPrice = getUniswapLastPrice();\\n\\n        reservesOf[stepsFromStart]\\n            .uniswapMiddlePrice = getUniswapMiddlePriceForSevenDays();\\n    }\\n\\n    function bet(uint256 deadline, address ref) external payable {\\n        _saveAuctionData();\\n        _updatePrice();\\n\\n        require(_msgSender() != ref, 'msg.sender == ref');\\n\\n        (uint256 toRecipient, uint256 toUniswap) =\\n            _calculateRecipientAndUniswapAmountsToSend();\\n\\n        _swapEth(toUniswap, deadline);\\n\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n\\n        auctionBetOf[stepsFromStart][_msgSender()].ref = ref;\\n\\n        auctionBetOf[stepsFromStart][_msgSender()].eth = auctionBetOf[\\n            stepsFromStart\\n        ][_msgSender()]\\n            .eth\\n            .add(msg.value);\\n\\n        if (!existAuctionsOf[stepsFromStart][_msgSender()]) {\\n            auctionsOf[_msgSender()].push(stepsFromStart);\\n            existAuctionsOf[stepsFromStart][_msgSender()] = true;\\n        }\\n\\n        reservesOf[stepsFromStart].eth = reservesOf[stepsFromStart].eth.add(\\n            msg.value\\n        );\\n\\n        recipient.transfer(toRecipient);\\n\\n        emit Bet(msg.sender, msg.value, stepsFromStart, now);\\n    }\\n\\n    function withdraw(uint256 auctionId) external {\\n        _saveAuctionData();\\n        _updatePrice();\\n\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n\\n        require(stepsFromStart > auctionId, 'auction is active');\\n\\n        uint256 auctionETHUserBalance =\\n            auctionBetOf[auctionId][_msgSender()].eth;\\n\\n        auctionBetOf[auctionId][_msgSender()].eth = 0;\\n\\n        require(auctionETHUserBalance > 0, 'zero balance in auction');\\n\\n        uint256 payout = _calculatePayout(auctionId, auctionETHUserBalance);\\n\\n        uint256 uniswapPayoutWithPercent =\\n            _calculatePayoutWithUniswap(\\n                auctionId,\\n                auctionETHUserBalance,\\n                payout\\n            );\\n\\n        if (payout > uniswapPayoutWithPercent) {\\n            uint256 nextWeeklyAuction = calculateNearestWeeklyAuction();\\n\\n            reservesOf[nextWeeklyAuction].token = reservesOf[nextWeeklyAuction]\\n                .token\\n                .add(payout.sub(uniswapPayoutWithPercent));\\n\\n            payout = uniswapPayoutWithPercent;\\n        }\\n\\n        if (address(auctionBetOf[auctionId][_msgSender()].ref) == address(0)) {\\n            ITokenV1(mainToken).burn(address(this), payout);\\n\\n            IStakingV1(staking).externalStake(payout, 14, _msgSender());\\n\\n            emit Withdraval(msg.sender, payout, stepsFromStart, now);\\n        } else {\\n            ITokenV1(mainToken).burn(address(this), payout);\\n\\n            (uint256 toRefMintAmount, uint256 toUserMintAmount) =\\n                _calculateRefAndUserAmountsToMint(payout);\\n\\n            payout = payout.add(toUserMintAmount);\\n\\n            IStakingV1(staking).externalStake(payout, 14, _msgSender());\\n\\n            emit Withdraval(msg.sender, payout, stepsFromStart, now);\\n\\n            IStakingV1(staking).externalStake(\\n                toRefMintAmount,\\n                14,\\n                auctionBetOf[auctionId][_msgSender()].ref\\n            );\\n        }\\n    }\\n\\n    function callIncomeDailyTokensTrigger(uint256 amount)\\n        external\\n        override\\n        onlyCaller\\n    {\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n        uint256 nextAuctionId = stepsFromStart.add(1);\\n\\n        reservesOf[nextAuctionId].token = reservesOf[nextAuctionId].token.add(\\n            amount\\n        );\\n    }\\n\\n    function callIncomeWeeklyTokensTrigger(uint256 amount)\\n        external\\n        override\\n        onlyCaller\\n    {\\n        uint256 nearestWeeklyAuction = calculateNearestWeeklyAuction();\\n\\n        reservesOf[nearestWeeklyAuction].token = reservesOf[\\n            nearestWeeklyAuction\\n        ]\\n            .token\\n            .add(amount);\\n    }\\n\\n    function calculateNearestWeeklyAuction() public view returns (uint256) {\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n        return stepsFromStart.add(uint256(7).sub(stepsFromStart.mod(7)));\\n    }\\n\\n    function calculateStepsFromStart() public view returns (uint256) {\\n        return now.sub(start).div(stepTimestamp);\\n    }\\n\\n    function _calculatePayoutWithUniswap(\\n        uint256 auctionId,\\n        uint256 amount,\\n        uint256 payout\\n    ) internal view returns (uint256) {\\n        uint256 uniswapPayout =\\n            reservesOf[auctionId].uniswapMiddlePrice.mul(amount).div(1e18);\\n\\n        uint256 uniswapPayoutWithPercent =\\n            uniswapPayout.add(uniswapPayout.mul(uniswapPercent).div(100));\\n\\n        if (payout > uniswapPayoutWithPercent) {\\n            return uniswapPayoutWithPercent;\\n        } else {\\n            return payout;\\n        }\\n    }\\n\\n    function _calculatePayout(uint256 auctionId, uint256 amount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            amount.mul(reservesOf[auctionId].token).div(\\n                reservesOf[auctionId].eth\\n            );\\n    }\\n\\n    function _calculateRecipientAndUniswapAmountsToSend()\\n        private\\n        returns (uint256, uint256)\\n    {\\n        uint256 toRecipient = msg.value.mul(20).div(100);\\n        uint256 toUniswap = msg.value.sub(toRecipient);\\n\\n        return (toRecipient, toUniswap);\\n    }\\n\\n    function _calculateRefAndUserAmountsToMint(uint256 amount)\\n        private\\n        pure\\n        returns (uint256, uint256)\\n    {\\n        uint256 toRefMintAmount = amount.mul(20).div(100);\\n        uint256 toUserMintAmount = amount.mul(10).div(100);\\n\\n        return (toRefMintAmount, toUserMintAmount);\\n    }\\n\\n    function _swapEth(uint256 amount, uint256 deadline) private {\\n        address[] memory path = new address[](2);\\n\\n        path[0] = IUniswapV2Router02(uniswap).WETH();\\n        path[1] = mainToken;\\n\\n        IUniswapV2Router02(uniswap).swapExactETHForTokens{value: amount}(\\n            0,\\n            path,\\n            staking,\\n            deadline\\n        );\\n    }\\n\\n    function _saveAuctionData() internal {\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n        AuctionReserves memory reserves = reservesOf[stepsFromStart];\\n\\n        if (lastAuctionEventId < stepsFromStart) {\\n            emit AuctionIsOver(reserves.eth, reserves.token, stepsFromStart);\\n            lastAuctionEventId = stepsFromStart;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/archive/interfaces/ITokenV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface ITokenV1 {\\n    function mint(address to, uint256 amount) external;\\n\\n    function burn(address from, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/archive/interfaces/IAuctionV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IAuctionV1 {\\n    function callIncomeDailyTokensTrigger(uint256 amount) external;\\n\\n    function callIncomeWeeklyTokensTrigger(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/archive/interfaces/IStakingV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IStakingV1 {\\n    function externalStake(\\n        uint256 amount,\\n        uint256 stakingDays,\\n        address staker\\n    ) external;\\n\\n    function sessionDataOf(address, uint256)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/archive/StakingV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport './interfaces/ITokenV1.sol';\\nimport './interfaces/IAuctionV1.sol';\\nimport './interfaces/IStakingV1.sol';\\nimport './interfaces/ISubBalancesV1.sol';\\n\\ncontract StakingV1 is IStakingV1, AccessControl {\\n    using SafeMath for uint256;\\n\\n    event Stake(\\n        address indexed account,\\n        uint256 indexed sessionId,\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end,\\n        uint256 shares\\n    );\\n\\n    event Unstake(\\n        address indexed account,\\n        uint256 indexed sessionId,\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end,\\n        uint256 shares\\n    );\\n\\n    event MakePayout(\\n        uint256 indexed value,\\n        uint256 indexed sharesTotalSupply,\\n        uint256 indexed time\\n    );\\n\\n    uint256 private _sessionsIds;\\n\\n    bytes32 public constant EXTERNAL_STAKER_ROLE =\\n        keccak256('EXTERNAL_STAKER_ROLE');\\n\\n    struct Payout {\\n        uint256 payout;\\n        uint256 sharesTotalSupply;\\n    }\\n\\n    struct Session {\\n        uint256 amount;\\n        uint256 start;\\n        uint256 end;\\n        uint256 shares;\\n        uint256 nextPayout;\\n    }\\n\\n    address public mainToken;\\n    address public auction;\\n    address public subBalances;\\n    uint256 public shareRate;\\n    uint256 public sharesTotalSupply;\\n    uint256 public nextPayoutCall;\\n    uint256 public stepTimestamp;\\n    uint256 public startContract;\\n    uint256 public globalPayout;\\n    uint256 public globalPayin;\\n\\n    mapping(address => mapping(uint256 => Session))\\n        public\\n        override sessionDataOf;\\n    mapping(address => uint256[]) public sessionsOf;\\n    Payout[] public payouts;\\n\\n    modifier onlyExternalStaker() {\\n        require(\\n            hasRole(EXTERNAL_STAKER_ROLE, _msgSender()),\\n            'Caller is not a external staker'\\n        );\\n        _;\\n    }\\n\\n    function init(\\n        address _mainToken,\\n        address _auction,\\n        address _subBalances,\\n        address _foreignSwap,\\n        uint256 _stepTimestamp\\n    ) external {\\n        _setupRole(EXTERNAL_STAKER_ROLE, _foreignSwap);\\n        _setupRole(EXTERNAL_STAKER_ROLE, _auction);\\n        mainToken = _mainToken;\\n        auction = _auction;\\n        subBalances = _subBalances;\\n        shareRate = 1e18;\\n        stepTimestamp = _stepTimestamp;\\n        nextPayoutCall = now.add(_stepTimestamp);\\n        startContract = now;\\n    }\\n\\n    function sessionsOf_(address account)\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return sessionsOf[account];\\n    }\\n\\n    function stake(uint256 amount, uint256 stakingDays) external {\\n        if (now >= nextPayoutCall) makePayout();\\n\\n        require(stakingDays > 0, 'stakingDays < 1');\\n\\n        uint256 start = now;\\n        uint256 end = now.add(stakingDays.mul(stepTimestamp));\\n\\n        ITokenV1(mainToken).burn(msg.sender, amount);\\n        _sessionsIds = _sessionsIds.add(1);\\n        uint256 sessionId = _sessionsIds;\\n        uint256 shares = _getStakersSharesAmount(amount, start, end);\\n        sharesTotalSupply = sharesTotalSupply.add(shares);\\n\\n        sessionDataOf[msg.sender][sessionId] = Session({\\n            amount: amount,\\n            start: start,\\n            end: end,\\n            shares: shares,\\n            nextPayout: payouts.length\\n        });\\n\\n        sessionsOf[msg.sender].push(sessionId);\\n\\n        ISubBalancesV1(subBalances).callIncomeStakerTrigger(\\n            msg.sender,\\n            sessionId,\\n            start,\\n            end,\\n            shares\\n        );\\n\\n        emit Stake(msg.sender, sessionId, amount, start, end, shares);\\n    }\\n\\n    function externalStake(\\n        uint256 amount,\\n        uint256 stakingDays,\\n        address staker\\n    ) external override {\\n        if (now >= nextPayoutCall) makePayout();\\n\\n        require(stakingDays > 0, 'stakingDays < 1');\\n\\n        uint256 start = now;\\n        uint256 end = now.add(stakingDays.mul(stepTimestamp));\\n\\n        _sessionsIds = _sessionsIds.add(1);\\n        uint256 sessionId = _sessionsIds;\\n        uint256 shares = _getStakersSharesAmount(amount, start, end);\\n        sharesTotalSupply = sharesTotalSupply.add(shares);\\n\\n        sessionDataOf[staker][sessionId] = Session({\\n            amount: amount,\\n            start: start,\\n            end: end,\\n            shares: shares,\\n            nextPayout: payouts.length\\n        });\\n\\n        sessionsOf[staker].push(sessionId);\\n\\n        ISubBalancesV1(subBalances).callIncomeStakerTrigger(\\n            staker,\\n            sessionId,\\n            start,\\n            end,\\n            shares\\n        );\\n\\n        emit Stake(staker, sessionId, amount, start, end, shares);\\n    }\\n\\n    function _initPayout(address to, uint256 amount) internal {\\n        ITokenV1(mainToken).mint(to, amount);\\n        globalPayout = globalPayout.add(amount);\\n    }\\n\\n    function calculateStakingInterest(\\n        uint256 sessionId,\\n        address account,\\n        uint256 shares\\n    ) public view returns (uint256) {\\n        uint256 stakingInterest;\\n\\n        for (\\n            uint256 i = sessionDataOf[account][sessionId].nextPayout;\\n            i < payouts.length;\\n            i++\\n        ) {\\n            uint256 payout =\\n                payouts[i].payout.mul(shares).div(payouts[i].sharesTotalSupply);\\n\\n            stakingInterest = stakingInterest.add(payout);\\n        }\\n\\n        return stakingInterest;\\n    }\\n\\n    function _updateShareRate(\\n        address account,\\n        uint256 shares,\\n        uint256 stakingInterest,\\n        uint256 sessionId\\n    ) internal {\\n        uint256 newShareRate =\\n            _getShareRate(\\n                sessionDataOf[account][sessionId].amount,\\n                shares,\\n                sessionDataOf[account][sessionId].start,\\n                sessionDataOf[account][sessionId].end,\\n                stakingInterest\\n            );\\n\\n        if (newShareRate > shareRate) {\\n            shareRate = newShareRate;\\n        }\\n    }\\n\\n    function unstake(uint256 sessionId) external {\\n        if (now >= nextPayoutCall) makePayout();\\n\\n        require(\\n            sessionDataOf[msg.sender][sessionId].shares > 0,\\n            'Staking: Shares balance is empty'\\n        );\\n\\n        uint256 shares = sessionDataOf[msg.sender][sessionId].shares;\\n\\n        sessionDataOf[msg.sender][sessionId].shares = 0;\\n\\n        if (sessionDataOf[msg.sender][sessionId].nextPayout >= payouts.length) {\\n            // To auction\\n            uint256 amount = sessionDataOf[msg.sender][sessionId].amount;\\n\\n            _initPayout(auction, amount);\\n            IAuctionV1(auction).callIncomeDailyTokensTrigger(amount);\\n\\n            emit Unstake(\\n                msg.sender,\\n                sessionId,\\n                amount,\\n                sessionDataOf[msg.sender][sessionId].start,\\n                sessionDataOf[msg.sender][sessionId].end,\\n                shares\\n            );\\n\\n            ISubBalancesV1(subBalances).callOutcomeStakerTrigger(\\n                msg.sender,\\n                sessionId,\\n                sessionDataOf[msg.sender][sessionId].start,\\n                sessionDataOf[msg.sender][sessionId].end,\\n                shares\\n            );\\n\\n            return;\\n        }\\n\\n        uint256 stakingInterest =\\n            calculateStakingInterest(sessionId, msg.sender, shares);\\n\\n        _updateShareRate(msg.sender, shares, stakingInterest, sessionId);\\n\\n        sharesTotalSupply = sharesTotalSupply.sub(shares);\\n\\n        (uint256 amountOut, uint256 penalty) =\\n            getAmountOutAndPenalty(sessionId, stakingInterest);\\n\\n        // To auction\\n        _initPayout(auction, penalty);\\n        IAuctionV1(auction).callIncomeDailyTokensTrigger(penalty);\\n\\n        // To account\\n        _initPayout(msg.sender, amountOut);\\n\\n        emit Unstake(\\n            msg.sender,\\n            sessionId,\\n            amountOut,\\n            sessionDataOf[msg.sender][sessionId].start,\\n            sessionDataOf[msg.sender][sessionId].end,\\n            shares\\n        );\\n\\n        ISubBalancesV1(subBalances).callOutcomeStakerTrigger(\\n            msg.sender,\\n            sessionId,\\n            sessionDataOf[msg.sender][sessionId].start,\\n            sessionDataOf[msg.sender][sessionId].end,\\n            sessionDataOf[msg.sender][sessionId].shares\\n        );\\n    }\\n\\n    /** This is for testing purposes to fix v1 unstakes */\\n    function unstakeTest(uint256 sessionId) external {\\n        require(\\n            sessionDataOf[msg.sender][sessionId].shares != 0,\\n            'Staking: Shares balance is empty'\\n        );\\n\\n        sessionDataOf[msg.sender][sessionId].shares = 0;\\n    }\\n\\n    function getAmountOutAndPenalty(uint256 sessionId, uint256 stakingInterest)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        uint256 stakingDays =\\n            (\\n                sessionDataOf[msg.sender][sessionId].end.sub(\\n                    sessionDataOf[msg.sender][sessionId].start\\n                )\\n            )\\n                .div(stepTimestamp);\\n\\n        uint256 daysStaked =\\n            (now.sub(sessionDataOf[msg.sender][sessionId].start)).div(\\n                stepTimestamp\\n            );\\n\\n        uint256 amountAndInterest =\\n            sessionDataOf[msg.sender][sessionId].amount.add(stakingInterest);\\n\\n        // Early\\n        if (stakingDays > daysStaked) {\\n            uint256 payOutAmount =\\n                amountAndInterest.mul(daysStaked).div(stakingDays);\\n\\n            uint256 earlyUnstakePenalty = amountAndInterest.sub(payOutAmount);\\n\\n            return (payOutAmount, earlyUnstakePenalty);\\n            // In time\\n        } else if (\\n            stakingDays <= daysStaked && daysStaked < stakingDays.add(14)\\n        ) {\\n            return (amountAndInterest, 0);\\n            // Late\\n        } else if (\\n            stakingDays.add(14) <= daysStaked &&\\n            daysStaked < stakingDays.add(714)\\n        ) {\\n            uint256 daysAfterStaking = daysStaked.sub(stakingDays);\\n\\n            uint256 payOutAmount =\\n                amountAndInterest.mul(uint256(714).sub(daysAfterStaking)).div(\\n                    700\\n                );\\n\\n            uint256 lateUnstakePenalty = amountAndInterest.sub(payOutAmount);\\n\\n            return (payOutAmount, lateUnstakePenalty);\\n            // Nothing\\n        } else if (stakingDays.add(714) <= daysStaked) {\\n            return (0, amountAndInterest);\\n        }\\n\\n        return (0, 0);\\n    }\\n\\n    function makePayout() public {\\n        require(now >= nextPayoutCall, 'Staking: Wrong payout time');\\n\\n        uint256 payout = _getPayout();\\n\\n        payouts.push(\\n            Payout({payout: payout, sharesTotalSupply: sharesTotalSupply})\\n        );\\n\\n        nextPayoutCall = nextPayoutCall.add(stepTimestamp);\\n\\n        emit MakePayout(payout, sharesTotalSupply, now);\\n    }\\n\\n    function readPayout() external view returns (uint256) {\\n        uint256 amountTokenInDay = IERC20(mainToken).balanceOf(address(this));\\n\\n        uint256 currentTokenTotalSupply =\\n            (IERC20(mainToken).totalSupply()).add(globalPayin);\\n\\n        uint256 inflation =\\n            uint256(8).mul(currentTokenTotalSupply.add(sharesTotalSupply)).div(\\n                36500\\n            );\\n\\n        return amountTokenInDay.add(inflation);\\n    }\\n\\n    function _getPayout() internal returns (uint256) {\\n        uint256 amountTokenInDay = IERC20(mainToken).balanceOf(address(this));\\n\\n        globalPayin = globalPayin.add(amountTokenInDay);\\n\\n        if (globalPayin > globalPayout) {\\n            globalPayin = globalPayin.sub(globalPayout);\\n            globalPayout = 0;\\n        } else {\\n            globalPayin = 0;\\n            globalPayout = 0;\\n        }\\n\\n        uint256 currentTokenTotalSupply =\\n            (IERC20(mainToken).totalSupply()).add(globalPayin);\\n\\n        ITokenV1(mainToken).burn(address(this), amountTokenInDay);\\n\\n        uint256 inflation =\\n            uint256(8).mul(currentTokenTotalSupply.add(sharesTotalSupply)).div(\\n                36500\\n            );\\n\\n        globalPayin = globalPayin.add(inflation);\\n\\n        return amountTokenInDay.add(inflation);\\n    }\\n\\n    function _getStakersSharesAmount(\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (uint256) {\\n        uint256 stakingDays = (end.sub(start)).div(stepTimestamp);\\n        uint256 numerator = amount.mul(uint256(1819).add(stakingDays));\\n        uint256 denominator = uint256(1820).mul(shareRate);\\n\\n        return (numerator).mul(1e18).div(denominator);\\n    }\\n\\n    function _getShareRate(\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 start,\\n        uint256 end,\\n        uint256 stakingInterest\\n    ) internal view returns (uint256) {\\n        uint256 stakingDays = (end.sub(start)).div(stepTimestamp);\\n\\n        uint256 numerator =\\n            (amount.add(stakingInterest)).mul(uint256(1819).add(stakingDays));\\n\\n        uint256 denominator = uint256(1820).mul(shares);\\n\\n        return (numerator).mul(1e18).div(denominator);\\n    }\\n\\n    // Helper\\n    function getNow0x() external view returns (uint256) {\\n        return now;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/archive/interfaces/ISubBalancesV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface ISubBalancesV1 {\\n    function callIncomeStakerTrigger(\\n        address staker,\\n        uint256 sessionId,\\n        uint256 start,\\n        uint256 end,\\n        uint256 shares\\n    ) external;\\n\\n    function callOutcomeStakerTrigger(\\n        address staker,\\n        uint256 sessionId,\\n        uint256 start,\\n        uint256 end,\\n        uint256 shares\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/archive/SubBalancesV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\nimport './interfaces/ITokenV1.sol';\\nimport './interfaces/IAuctionV1.sol';\\nimport './interfaces/IForeignSwapV1.sol';\\nimport './interfaces/IBPDV1.sol';\\nimport './interfaces/ISubBalancesV1.sol';\\n\\ncontract SubBalancesV1 is ISubBalancesV1, AccessControl {\\n    using SafeMath for uint256;\\n\\n    event PoolCreated(uint256 paydayTime, uint256 poolAmount);\\n\\n    bytes32 public constant SETTER_ROLE = keccak256('SETTER_ROLE');\\n    bytes32 public constant STAKING_ROLE = keccak256('CALLER_ROLE');\\n\\n    struct StakeSession {\\n        address staker;\\n        uint256 shares;\\n        // uint256 sessionId;\\n        uint256 start;\\n        uint256 end;\\n        uint256 finishTime;\\n        bool[5] payDayEligible;\\n        bool withdrawn;\\n    }\\n\\n    struct SubBalance {\\n        // mapping (address => uint256[]) userStakings;\\n        // mapping (uint256 => StakeSession) stakeSessions;\\n        uint256 totalShares;\\n        uint256 totalWithdrawAmount;\\n        uint256 payDayTime;\\n        // uint256 payDayEnd;\\n        uint256 requiredStakePeriod;\\n        bool minted;\\n    }\\n\\n    SubBalance[5] public subBalanceList;\\n\\n    address public mainToken;\\n    address public foreignSwap;\\n    address public bigPayDayPool;\\n    address public auction;\\n    uint256 public startTimestamp;\\n    uint256 public stepTimestamp;\\n    uint256 public basePeriod;\\n    uint256[5] public PERIODS;\\n\\n    uint256 public currentSharesTotalSupply;\\n\\n    // Users\\n    mapping(address => uint256[]) userStakings;\\n    mapping(uint256 => StakeSession) stakeSessions;\\n\\n    function init(\\n        address _mainToken,\\n        address _foreignSwap,\\n        address _bigPayDayPool,\\n        address _auction,\\n        address _staking,\\n        uint256 _stepTimestamp,\\n        uint256 _basePeriod\\n    ) public {\\n        _setupRole(STAKING_ROLE, _staking);\\n        mainToken = _mainToken;\\n        foreignSwap = _foreignSwap;\\n        bigPayDayPool = _bigPayDayPool;\\n        auction = _auction;\\n        stepTimestamp = _stepTimestamp;\\n        basePeriod = _basePeriod;\\n        startTimestamp = now;\\n\\n        for (uint256 i = 0; i < subBalanceList.length; i++) {\\n            PERIODS[i] = _basePeriod.mul(i.add(1));\\n            SubBalance storage subBalance = subBalanceList[i];\\n            subBalance.payDayTime = startTimestamp.add(\\n                stepTimestamp.mul(PERIODS[i])\\n            );\\n            // subBalance.payDayEnd = subBalance.payDayStart.add(stepTimestamp);\\n            subBalance.requiredStakePeriod = PERIODS[i];\\n        }\\n    }\\n\\n    function getStartTimes()\\n        public\\n        view\\n        returns (uint256[5] memory startTimes)\\n    {\\n        for (uint256 i = 0; i < subBalanceList.length; i++) {\\n            startTimes[i] = subBalanceList[i].payDayTime;\\n        }\\n    }\\n\\n    function getPoolsMinted() public view returns (bool[5] memory poolsMinted) {\\n        for (uint256 i = 0; i < subBalanceList.length; i++) {\\n            poolsMinted[i] = subBalanceList[i].minted;\\n        }\\n    }\\n\\n    function getPoolsMintedAmounts()\\n        public\\n        view\\n        returns (uint256[5] memory poolsMintedAmounts)\\n    {\\n        for (uint256 i = 0; i < subBalanceList.length; i++) {\\n            poolsMintedAmounts[i] = subBalanceList[i].totalWithdrawAmount;\\n        }\\n    }\\n\\n    function getClosestYearShares() public view returns (uint256 shareAmount) {\\n        for (uint256 i = 0; i < subBalanceList.length; i++) {\\n            if (!subBalanceList[i].minted) {\\n                continue;\\n            } else {\\n                shareAmount = subBalanceList[i].totalShares;\\n                return shareAmount;\\n            }\\n\\n            // return 0;\\n        }\\n    }\\n\\n    function getSessionStats(uint256 sessionId)\\n        public\\n        view\\n        returns (\\n            address staker,\\n            uint256 shares,\\n            uint256 start,\\n            uint256 sessionEnd,\\n            bool withdrawn\\n        )\\n    {\\n        StakeSession storage stakeSession = stakeSessions[sessionId];\\n        staker = stakeSession.staker;\\n        shares = stakeSession.shares;\\n        start = stakeSession.start;\\n        if (stakeSession.finishTime > 0) {\\n            sessionEnd = stakeSession.finishTime;\\n        } else {\\n            sessionEnd = stakeSession.end;\\n        }\\n        withdrawn = stakeSession.withdrawn;\\n    }\\n\\n    function getSessionEligibility(uint256 sessionId)\\n        public\\n        view\\n        returns (bool[5] memory stakePayDays)\\n    {\\n        StakeSession storage stakeSession = stakeSessions[sessionId];\\n        for (uint256 i = 0; i < subBalanceList.length; i++) {\\n            stakePayDays[i] = stakeSession.payDayEligible[i];\\n        }\\n    }\\n\\n    function calculateSessionPayout(uint256 sessionId)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        StakeSession storage stakeSession = stakeSessions[sessionId];\\n\\n        uint256 subBalancePayoutAmount;\\n        uint256[5] memory bpdRawAmounts =\\n            IBPDV1(bigPayDayPool).getPoolYearAmounts();\\n        for (uint256 i = 0; i < subBalanceList.length; i++) {\\n            SubBalance storage subBalance = subBalanceList[i];\\n\\n            uint256 subBalanceAmount;\\n            uint256 addAmount;\\n            if (subBalance.minted) {\\n                subBalanceAmount = subBalance.totalWithdrawAmount;\\n            } else {\\n                (subBalanceAmount, addAmount) = _bpdAmountFromRaw(\\n                    bpdRawAmounts[i]\\n                );\\n            }\\n            if (stakeSession.payDayEligible[i]) {\\n                uint256 stakerShare =\\n                    stakeSession.shares.mul(1e18).div(subBalance.totalShares);\\n                uint256 stakerAmount =\\n                    subBalanceAmount.mul(stakerShare).div(1e18);\\n                subBalancePayoutAmount = subBalancePayoutAmount.add(\\n                    stakerAmount\\n                );\\n            }\\n        }\\n\\n        uint256 stakingDays =\\n            stakeSession.end.sub(stakeSession.start).div(stepTimestamp);\\n        uint256 stakeEnd;\\n        if (stakeSession.finishTime != 0) {\\n            stakeEnd = stakeSession.finishTime;\\n        } else {\\n            stakeEnd = stakeSession.end;\\n        }\\n\\n        uint256 daysStaked =\\n            stakeEnd.sub(stakeSession.start).div(stepTimestamp);\\n\\n        // Early unstaked\\n        if (stakingDays > daysStaked) {\\n            uint256 payoutAmount =\\n                subBalancePayoutAmount.mul(daysStaked).div(stakingDays);\\n            uint256 earlyUnstakePenalty =\\n                subBalancePayoutAmount.sub(payoutAmount);\\n            return (payoutAmount, earlyUnstakePenalty);\\n            // Unstaked in time, no penalty\\n        } else if (\\n            stakingDays <= daysStaked && daysStaked < stakingDays.add(14)\\n        ) {\\n            return (subBalancePayoutAmount, 0);\\n            // Unstaked late\\n        } else if (\\n            stakingDays.add(14) <= daysStaked &&\\n            daysStaked < stakingDays.add(714)\\n        ) {\\n            uint256 daysAfterStaking = daysStaked.sub(stakingDays);\\n            uint256 payoutAmount =\\n                subBalancePayoutAmount\\n                    .mul(uint256(714).sub(daysAfterStaking))\\n                    .div(700);\\n            uint256 lateUnstakePenalty =\\n                subBalancePayoutAmount.sub(payoutAmount);\\n            return (payoutAmount, lateUnstakePenalty);\\n            // Too much time\\n        } else if (stakingDays.add(714) <= daysStaked) {\\n            return (0, subBalancePayoutAmount);\\n        }\\n\\n        return (0, 0);\\n    }\\n\\n    function withdrawPayout(uint256 sessionId) public {\\n        StakeSession storage stakeSession = stakeSessions[sessionId];\\n\\n        require(stakeSession.finishTime != 0, 'cannot withdraw before unclaim');\\n        require(!stakeSession.withdrawn, 'already withdrawn');\\n        require(\\n            _msgSender() == stakeSession.staker,\\n            'caller not matching sessionId'\\n        );\\n        (uint256 payoutAmount, uint256 penaltyAmount) =\\n            calculateSessionPayout(sessionId);\\n\\n        stakeSession.withdrawn = true;\\n\\n        if (payoutAmount > 0) {\\n            IERC20(mainToken).transfer(_msgSender(), payoutAmount);\\n        }\\n\\n        if (penaltyAmount > 0) {\\n            IERC20(mainToken).transfer(auction, penaltyAmount);\\n            IAuctionV1(auction).callIncomeDailyTokensTrigger(penaltyAmount);\\n        }\\n    }\\n\\n    function callIncomeStakerTrigger(\\n        address staker,\\n        uint256 sessionId,\\n        uint256 start,\\n        uint256 end,\\n        uint256 shares\\n    ) external override {\\n        require(\\n            end > start,\\n            'SUBBALANCES: Stake end must be after stake start'\\n        );\\n        uint256 stakeDays = end.sub(start).div(stepTimestamp);\\n\\n        // Skipping user if period less that year\\n        if (stakeDays >= basePeriod) {\\n            // Setting pay day eligibility for user in advance when he stakes\\n            bool[5] memory stakerPayDays;\\n            for (uint256 i = 0; i < subBalanceList.length; i++) {\\n                SubBalance storage subBalance = subBalanceList[i];\\n\\n                // Setting eligibility only if payday is not passed and stake end more that this pay day\\n                if (\\n                    subBalance.payDayTime > start && end > subBalance.payDayTime\\n                ) {\\n                    stakerPayDays[i] = true;\\n\\n                    subBalance.totalShares = subBalance.totalShares.add(shares);\\n                }\\n            }\\n\\n            // Saving user\\n            stakeSessions[sessionId] = StakeSession({\\n                staker: staker,\\n                shares: shares,\\n                start: start,\\n                end: end,\\n                finishTime: 0,\\n                payDayEligible: stakerPayDays,\\n                withdrawn: false\\n            });\\n            userStakings[staker].push(sessionId);\\n        }\\n\\n        // Adding to shares\\n        currentSharesTotalSupply = currentSharesTotalSupply.add(shares);\\n    }\\n\\n    function callOutcomeStakerTrigger(\\n        address staker,\\n        uint256 sessionId,\\n        uint256 start,\\n        uint256 end,\\n        uint256 shares\\n    ) external override {\\n        (staker);\\n        require(\\n            end > start,\\n            'SUBBALANCES: Stake end must be after stake start'\\n        );\\n        uint256 stakeDays = end.sub(start).div(stepTimestamp);\\n        uint256 realStakeEnd = now;\\n        // uint256 daysStaked = realStakeEnd.sub(stakeStart).div(stepTimestamp);\\n\\n        if (stakeDays >= basePeriod) {\\n            StakeSession storage stakeSession = stakeSessions[sessionId];\\n\\n            // Rechecking eligibility of paydays\\n            for (uint256 i = 0; i < subBalanceList.length; i++) {\\n                SubBalance storage subBalance = subBalanceList[i];\\n\\n                // Removing from payday if unstaked before\\n                if (realStakeEnd < subBalance.payDayTime) {\\n                    bool wasEligible = stakeSession.payDayEligible[i];\\n                    stakeSession.payDayEligible[i] = false;\\n\\n                    if (wasEligible) {\\n                        if (shares > subBalance.totalShares) {\\n                            subBalance.totalShares = 0;\\n                        } else {\\n                            subBalance.totalShares = subBalance.totalShares.sub(\\n                                shares\\n                            );\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // Setting real stake end\\n            stakeSessions[sessionId].finishTime = realStakeEnd;\\n        }\\n\\n        // Substract shares from total\\n        if (shares > currentSharesTotalSupply) {\\n            currentSharesTotalSupply = 0;\\n        } else {\\n            currentSharesTotalSupply = currentSharesTotalSupply.sub(shares);\\n        }\\n    }\\n\\n    // Pool logic\\n    function generatePool() external returns (bool) {\\n        for (uint256 i = 0; i < subBalanceList.length; i++) {\\n            SubBalance storage subBalance = subBalanceList[i];\\n\\n            if (now > subBalance.payDayTime && !subBalance.minted) {\\n                uint256 yearTokens = getPoolFromBPD(i);\\n                (uint256 bpdTokens, uint256 addAmount) =\\n                    _bpdAmountFromRaw(yearTokens);\\n\\n                ITokenV1(mainToken).mint(address(this), addAmount);\\n                subBalance.totalWithdrawAmount = bpdTokens;\\n                subBalance.minted = true;\\n\\n                emit PoolCreated(now, bpdTokens);\\n                return true;\\n            }\\n        }\\n    }\\n\\n    // Pool logic\\n    function getPoolFromBPD(uint256 poolNumber)\\n        internal\\n        returns (uint256 poolAmount)\\n    {\\n        poolAmount = IBPDV1(bigPayDayPool).transferYearlyPool(poolNumber);\\n    }\\n\\n    // Pool logic\\n    function _bpdAmountFromRaw(uint256 yearTokenAmount)\\n        internal\\n        view\\n        returns (uint256 totalAmount, uint256 addAmount)\\n    {\\n        uint256 currentTokenTotalSupply = IERC20(mainToken).totalSupply();\\n\\n        uint256 inflation =\\n            uint256(8)\\n                .mul(currentTokenTotalSupply.add(currentSharesTotalSupply))\\n                .div(36500);\\n\\n        uint256 criticalMassCoeff =\\n            IForeignSwapV1(foreignSwap).getCurrentClaimedAmount().mul(1e18).div(\\n                IForeignSwapV1(foreignSwap).getTotalSnapshotAmount()\\n            );\\n\\n        uint256 viralityCoeff =\\n            IForeignSwapV1(foreignSwap)\\n                .getCurrentClaimedAddresses()\\n                .mul(1e18)\\n                .div(IForeignSwapV1(foreignSwap).getTotalSnapshotAddresses());\\n\\n        uint256 totalUprisingCoeff =\\n            uint256(1e18).add(criticalMassCoeff).add(viralityCoeff);\\n\\n        totalAmount = yearTokenAmount\\n            .add(inflation)\\n            .mul(totalUprisingCoeff)\\n            .div(1e18);\\n        addAmount = totalAmount.sub(yearTokenAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/archive/interfaces/IForeignSwapV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IForeignSwapV1 {\\n    function getCurrentClaimedAmount() external view returns (uint256);\\n\\n    function getTotalSnapshotAmount() external view returns (uint256);\\n\\n    function getCurrentClaimedAddresses() external view returns (uint256);\\n\\n    function getTotalSnapshotAddresses() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/archive/interfaces/IBPDV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IBPDV1 {\\n    function callIncomeTokensTrigger(uint256 incomeAmountToken) external;\\n\\n    function transferYearlyPool(uint256 poolNumber) external returns (uint256);\\n\\n    function getPoolYearAmounts()\\n        external\\n        view\\n        returns (uint256[5] memory poolAmounts);\\n}\\n\"\r\n    },\r\n    \"contracts/archive/ForeignSwapV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport '@openzeppelin/contracts/cryptography/ECDSA.sol';\\nimport './interfaces/ITokenV1.sol';\\nimport './interfaces/IAuctionV1.sol';\\nimport './interfaces/IStakingV1.sol';\\nimport './interfaces/IBPDV1.sol';\\nimport './interfaces/IForeignSwapV1.sol';\\n\\ncontract ForeignSwapV1 is IForeignSwapV1, AccessControl {\\n    using SafeMath for uint256;\\n\\n    event TokensClaimed(\\n        address indexed account,\\n        uint256 indexed stepsFromStart,\\n        uint256 userAmount,\\n        uint256 penaltyuAmount\\n    );\\n\\n    bytes32 public constant SETTER_ROLE = keccak256('SETTER_ROLE');\\n\\n    uint256 public start;\\n    uint256 public stepTimestamp;\\n    uint256 public stakePeriod;\\n    uint256 public maxClaimAmount;\\n    // uint256 public constant PERIOD = 350;\\n\\n    address public mainToken;\\n    address public staking;\\n    address public auction;\\n    address public bigPayDayPool;\\n    address public signerAddress;\\n\\n    mapping(address => uint256) public claimedBalanceOf;\\n\\n    uint256 internal claimedAmount;\\n    uint256 internal totalSnapshotAmount;\\n    uint256 internal claimedAddresses;\\n    uint256 internal totalSnapshotAddresses;\\n\\n    modifier onlySetter() {\\n        require(hasRole(SETTER_ROLE, _msgSender()), 'Caller is not a setter');\\n        _;\\n    }\\n\\n    function init(\\n        address _signer,\\n        uint256 _stepTimestamp,\\n        uint256 _stakePeriod,\\n        uint256 _maxClaimAmount,\\n        address _mainToken,\\n        address _auction,\\n        address _staking,\\n        address _bigPayDayPool,\\n        uint256 _totalSnapshotAmount,\\n        uint256 _totalSnapshotAddresses\\n    ) external {\\n        signerAddress = _signer;\\n        start = now;\\n        stepTimestamp = _stepTimestamp;\\n        stakePeriod = _stakePeriod;\\n        maxClaimAmount = _maxClaimAmount;\\n        mainToken = _mainToken;\\n        staking = _staking;\\n        auction = _auction;\\n        bigPayDayPool = _bigPayDayPool;\\n        totalSnapshotAmount = _totalSnapshotAmount;\\n        totalSnapshotAddresses = _totalSnapshotAddresses;\\n    }\\n\\n    function getCurrentClaimedAmount()\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return claimedAmount;\\n    }\\n\\n    function getTotalSnapshotAmount() external view override returns (uint256) {\\n        return totalSnapshotAmount;\\n    }\\n\\n    function getCurrentClaimedAddresses()\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return claimedAddresses;\\n    }\\n\\n    function getTotalSnapshotAddresses()\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return totalSnapshotAddresses;\\n    }\\n\\n    function getMessageHash(uint256 amount, address account)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(amount, account));\\n    }\\n\\n    function check(uint256 amount, bytes memory signature)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        bytes32 messageHash = getMessageHash(amount, address(msg.sender));\\n        return ECDSA.recover(messageHash, signature) == signerAddress;\\n    }\\n\\n    function getUserClaimableAmountFor(uint256 amount)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        if (amount > 0) {\\n            (uint256 amountOut, uint256 delta, uint256 deltaAuctionWeekly) =\\n                getClaimableAmount(amount);\\n            uint256 deltaPenalized = delta.add(deltaAuctionWeekly);\\n            return (amountOut, deltaPenalized);\\n        } else {\\n            return (0, 0);\\n        }\\n    }\\n\\n    function claimFromForeign(uint256 amount, bytes memory signature)\\n        public\\n        returns (bool)\\n    {\\n        require(amount > 0, 'CLAIM: amount <= 0');\\n        require(\\n            check(amount, signature),\\n            'CLAIM: cannot claim because signature is not correct'\\n        );\\n        require(claimedBalanceOf[msg.sender] == 0, 'CLAIM: cannot claim twice');\\n\\n        (uint256 amountOut, uint256 delta, uint256 deltaAuctionWeekly) =\\n            getClaimableAmount(amount);\\n\\n        uint256 deltaPart = delta.div(stakePeriod);\\n        uint256 deltaAuctionDaily = deltaPart.mul(stakePeriod.sub(uint256(1)));\\n\\n        ITokenV1(mainToken).mint(auction, deltaAuctionDaily);\\n        IAuctionV1(auction).callIncomeDailyTokensTrigger(deltaAuctionDaily);\\n\\n        if (deltaAuctionWeekly > 0) {\\n            ITokenV1(mainToken).mint(auction, deltaAuctionWeekly);\\n            IAuctionV1(auction).callIncomeWeeklyTokensTrigger(\\n                deltaAuctionWeekly\\n            );\\n        }\\n\\n        ITokenV1(mainToken).mint(bigPayDayPool, deltaPart);\\n        IBPDV1(bigPayDayPool).callIncomeTokensTrigger(deltaPart);\\n        IStakingV1(staking).externalStake(amountOut, stakePeriod, msg.sender);\\n\\n        claimedBalanceOf[msg.sender] = amount;\\n        claimedAmount = claimedAmount.add(amount);\\n        claimedAddresses = claimedAddresses.add(uint256(1));\\n\\n        emit TokensClaimed(\\n            msg.sender,\\n            calculateStepsFromStart(),\\n            amountOut,\\n            deltaPart\\n        );\\n\\n        return true;\\n    }\\n\\n    function calculateStepsFromStart() public view returns (uint256) {\\n        return (now.sub(start)).div(stepTimestamp);\\n    }\\n\\n    // function calculateStakeEndTime(uint256 startTime) internal view returns (uint256) {\\n    //     uint256 stakePeriod = stepTimestamp.mul(stakePeriod);\\n    //     return  startTime.add(stakePeriod);\\n    // }\\n\\n    function getClaimableAmount(uint256 amount)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 deltaAuctionWeekly = 0;\\n        if (amount > maxClaimAmount) {\\n            deltaAuctionWeekly = amount.sub(maxClaimAmount);\\n            amount = maxClaimAmount;\\n        }\\n\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n        uint256 daysPassed =\\n            stepsFromStart > stakePeriod ? stakePeriod : stepsFromStart;\\n        uint256 delta = amount.mul(daysPassed).div(stakePeriod);\\n        uint256 amountOut = amount.sub(delta);\\n\\n        return (amountOut, delta, deltaAuctionWeekly);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/archive/NativeSwapV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport './interfaces/ITokenV1.sol';\\nimport './interfaces/IAuctionV1.sol';\\n\\ncontract NativeSwapV1 {\\n    using SafeMath for uint256;\\n\\n    event TokensSwapped(\\n        address indexed account,\\n        uint256 indexed stepsFromStart,\\n        uint256 userAmount,\\n        uint256 penaltyAmount\\n    );\\n\\n    uint256 public start;\\n    uint256 public period;\\n    uint256 public stepTimestamp;\\n    IERC20 public swapToken;\\n    ITokenV1 public mainToken;\\n    IAuctionV1 public auction;\\n\\n    mapping(address => uint256) public swapTokenBalanceOf;\\n\\n    function init(\\n        uint256 _period,\\n        uint256 _stepTimestamp,\\n        address _swapToken,\\n        address _mainToken,\\n        address _auction\\n    ) external {\\n        period = _period;\\n        stepTimestamp = _stepTimestamp;\\n        swapToken = IERC20(_swapToken);\\n        mainToken = ITokenV1(_mainToken);\\n        auction = IAuctionV1(_auction);\\n        start = now;\\n    }\\n\\n    function deposit(uint256 _amount) external {\\n        require(\\n            swapToken.transferFrom(msg.sender, address(this), _amount),\\n            'NativeSwap: transferFrom error'\\n        );\\n        swapTokenBalanceOf[msg.sender] = swapTokenBalanceOf[msg.sender].add(\\n            _amount\\n        );\\n    }\\n\\n    function withdraw(uint256 _amount) external {\\n        require(_amount >= swapTokenBalanceOf[msg.sender], 'balance < amount');\\n        swapTokenBalanceOf[msg.sender] = swapTokenBalanceOf[msg.sender].sub(\\n            _amount\\n        );\\n        swapToken.transfer(msg.sender, _amount);\\n    }\\n\\n    function swapNativeToken() external {\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n        require(stepsFromStart <= period, 'swapNativeToken: swap is over');\\n        uint256 amount = swapTokenBalanceOf[msg.sender];\\n        uint256 deltaPenalty = calculateDeltaPenalty(amount);\\n        uint256 amountOut = amount.sub(deltaPenalty);\\n        require(amount > 0, 'swapNativeToken: amount == 0');\\n        swapTokenBalanceOf[msg.sender] = 0;\\n        mainToken.mint(address(auction), deltaPenalty);\\n        auction.callIncomeDailyTokensTrigger(deltaPenalty);\\n        mainToken.mint(msg.sender, amountOut);\\n\\n        emit TokensSwapped(msg.sender, stepsFromStart, amount, deltaPenalty);\\n    }\\n\\n    function calculateDeltaPenalty(uint256 amount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 stepsFromStart = calculateStepsFromStart();\\n        if (stepsFromStart > period) return amount;\\n        return amount.mul(stepsFromStart).div(period);\\n    }\\n\\n    function calculateStepsFromStart() public view returns (uint256) {\\n        return now.sub(start).div(stepTimestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/archive/TokenV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport './interfaces/ITokenV1.sol';\\n\\nimport 'hardhat/console.sol';\\n\\ncontract TokenV1 is ITokenV1, ERC20, AccessControl {\\n    using SafeMath for uint256;\\n\\n    bytes32 private constant MINTER_ROLE = keccak256('MINTER_ROLE');\\n    bytes32 private constant SWAPPER_ROLE = keccak256('SWAPPER_ROLE');\\n    bytes32 private constant SETTER_ROLE = keccak256('SETTER_ROLE');\\n\\n    IERC20 private swapToken;\\n    bool private swapIsOver;\\n    uint256 private swapTokenBalance;\\n\\n    modifier onlyMinter() {\\n        require(hasRole(MINTER_ROLE, _msgSender()), 'Caller is not a minter');\\n        _;\\n    }\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _swapToken\\n    ) public ERC20(_name, _symbol) {\\n        swapToken = IERC20(_swapToken);\\n        swapIsOver = false;\\n    }\\n\\n    function init(address[] calldata instances) external {\\n        require(instances.length == 5, 'NativeSwap: wrong instances number');\\n\\n        for (uint256 index = 0; index < instances.length; index++) {\\n            _setupRole(MINTER_ROLE, instances[index]);\\n        }\\n        renounceRole(SETTER_ROLE, _msgSender());\\n        swapIsOver = true;\\n    }\\n\\n    function getMinterRole() external pure returns (bytes32) {\\n        return MINTER_ROLE;\\n    }\\n\\n    function getSetterRole() external pure returns (bytes32) {\\n        return SETTER_ROLE;\\n    }\\n\\n    function getSwapTOken() external view returns (IERC20) {\\n        return swapToken;\\n    }\\n\\n    function getSwapTokenBalance(uint256) external view returns (uint256) {\\n        return swapTokenBalance;\\n    }\\n\\n    function mint(address to, uint256 amount) external override {\\n        _mint(to, amount);\\n    }\\n\\n    function burn(address from, uint256 amount) external override {\\n        _burn(from, amount);\\n    }\\n\\n    // Helpers\\n    function getNow() external view returns (uint256) {\\n        return now;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/EnumerableSet.sol\\\";\\nimport \\\"../../utils/EnumerableMap.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = baseURI();\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(base, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(base, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view virtual returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId); // internal owner\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\"); // internal owner\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\\n * supported.\\n */\\nlibrary EnumerableMap {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        // Storage of map keys and values\\n        MapEntry[] _entries;\\n\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            // The entry is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n            // Move the last entry to the index where the entry to delete is\\n            map._entries[toDeleteIndex] = lastEntry;\\n            // Update the index for the moved entry\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved entry was stored\\n            map._entries.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n   /**\\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of entries inside the\\n    * array, and it may change when more entries are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length > index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, \\\"EnumerableMap: nonexistent key\\\"); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the element stored at position `index` in the set. O(1).\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\n\\ncontract TERC721 is ERC721, AccessControl {\\n    uint256 id = 0;\\n\\n    constructor(string memory name, string memory symbol)\\n        public\\n        ERC721(name, symbol)\\n    {}\\n\\n    function mint(address to) public returns (uint256) {\\n        id++;\\n        _mint(to, id);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\ncontract TERC20 is ERC20, AccessControl {\\n    using SafeMath for uint256;\\n\\n    event Deposit(address indexed sender, uint256 amountIn, uint256 amountOut);\\n    event Withdrawal(\\n        address indexed sender,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n\\n    uint256 public constant LIMIT = 250000000000e18;\\n    uint256 public constant RATE = 1e6;\\n\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint256 initMintAmount,\\n        address initMintRecipient\\n    ) public ERC20(name, symbol) {\\n        _mint(initMintRecipient, initMintAmount);\\n    }\\n\\n    receive() external payable {\\n        deposit();\\n    }\\n\\n    function deposit() public payable {\\n        require(totalSupply() < LIMIT, \\\"limit exceeded\\\");\\n        uint256 amountOut = msg.value.mul(RATE);\\n        require(totalSupply().add(amountOut) < LIMIT, \\\"insufficient reserve\\\");\\n        _mint(msg.sender, amountOut);\\n        Deposit(msg.sender, msg.value, amountOut);\\n    }\\n\\n    function withdraw() external {\\n        uint256 amountOut = balanceOf(msg.sender).div(RATE);\\n        _burn(msg.sender, balanceOf(msg.sender));\\n        msg.sender.transfer(amountOut);\\n        Withdrawal(msg.sender, balanceOf(msg.sender), amountOut);\\n    }\\n\\n    function mint(address to, uint256 amount) external {\\n        _mint(to, amount);\\n    }\\n\\n    function burn(address from, uint256 amount) external {\\n        _burn(from, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/archive/BPDV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\nimport './interfaces/IBPDV1.sol';\\n\\ncontract BPDV1 is IBPDV1, AccessControl {\\n    using SafeMath for uint256;\\n\\n    bytes32 public constant SETTER_ROLE = keccak256('SETTER_ROLE');\\n    bytes32 public constant SWAP_ROLE = keccak256('SWAP_ROLE');\\n    bytes32 public constant SUBBALANCE_ROLE = keccak256('SUBBALANCE_ROLE');\\n\\n    uint256[5] public poolYearAmounts;\\n    bool[5] public poolTransferred;\\n    uint256[5] public poolYearPercentages = [10, 15, 20, 25, 30];\\n\\n    address public mainToken;\\n\\n    uint256 public constant PERCENT_DENOMINATOR = 100;\\n\\n    modifier onlySetter() {\\n        require(hasRole(SETTER_ROLE, _msgSender()), 'Caller is not a setter');\\n        _;\\n    }\\n\\n    function init(\\n        address _mainToken,\\n        address _foreignSwap,\\n        address _subBalancePool\\n    ) public {\\n        _setupRole(SWAP_ROLE, _foreignSwap);\\n        _setupRole(SUBBALANCE_ROLE, _subBalancePool);\\n        mainToken = _mainToken;\\n    }\\n\\n    function getPoolYearAmounts()\\n        external\\n        view\\n        override\\n        returns (uint256[5] memory poolAmounts)\\n    {\\n        return poolYearAmounts;\\n    }\\n\\n    function getClosestPoolAmount() public view returns (uint256 poolAmount) {\\n        for (uint256 i = 0; i < poolYearAmounts.length; i++) {\\n            if (poolTransferred[i]) {\\n                continue;\\n            } else {\\n                poolAmount = poolYearAmounts[i];\\n                return poolAmount;\\n            }\\n\\n            // return 0;\\n        }\\n    }\\n\\n    function callIncomeTokensTrigger(uint256 incomeAmountToken)\\n        external\\n        override\\n    {\\n        // Divide income to years\\n        uint256 part = incomeAmountToken.div(PERCENT_DENOMINATOR);\\n\\n        uint256 remainderPart = incomeAmountToken;\\n        for (uint256 i = 0; i < poolYearAmounts.length; i++) {\\n            if (i != poolYearAmounts.length - 1) {\\n                uint256 poolPart = part.mul(poolYearPercentages[i]);\\n                poolYearAmounts[i] = poolYearAmounts[i].add(poolPart);\\n                remainderPart = remainderPart.sub(poolPart);\\n            } else {\\n                poolYearAmounts[i] = poolYearAmounts[i].add(remainderPart);\\n            }\\n        }\\n    }\\n\\n    function transferYearlyPool(uint256 poolNumber)\\n        external\\n        override\\n        returns (uint256 transferAmount)\\n    {\\n        for (uint256 i = 0; i < poolYearAmounts.length; i++) {\\n            if (poolNumber == i) {\\n                require(!poolTransferred[i], 'Already transferred');\\n                transferAmount = poolYearAmounts[i];\\n                poolTransferred[i] = true;\\n\\n                IERC20(mainToken).transfer(_msgSender(), transferAmount);\\n                return transferAmount;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstracts/Migratable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.25 <0.7.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\n\\nabstract contract Migratable is AccessControlUpgradeable {\\n    bytes32 public constant MIGRATOR_ROLE = keccak256(\\\"MIGRATOR_ROLE\\\");\\n\\n    modifier onlyMigrator() {\\n        require(\\n            hasRole(MIGRATOR_ROLE, _msgSender()),\\n            \\\"Caller is not a migrator\\\"\\n        );\\n        _;\\n    }\\n} \"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 0\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAuctionBidsV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"internalType\":\"struct DataReader.AuctionBid[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAuctionBidsV2\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"internalType\":\"struct DataReader.AuctionBid[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getDaoShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getSessionsV1\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sessionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstPayout\",\"type\":\"uint256\"}],\"internalType\":\"struct DataReader.StakeV1[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getSessionsV2\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sessionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPayout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"internalType\":\"struct DataReader.StakeV2[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingV1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_auction\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_auctionV1\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setupRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DataReader","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}