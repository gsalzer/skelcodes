{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n// Author: Steve Medley\r\n// https://github.com/Civitas-Fundamenta\r\n// steve@fundamenta.network\r\n\r\ninterface TokenInterface {\r\n    function mintTo(address user, uint256 amount) external;\r\n    function burnFrom(address user, uint256 amount) external;\r\n}\r\n\r\n\r\n// Author: Steve Medley\r\n// https://github.com/Civitas-Fundamenta\r\n// steve@fundamenta.network\r\n\r\nlibrary Signer\r\n{\r\n    function recoverSigner(bytes32 dataHash, bytes memory sig) internal pure returns (address)\r\n    {\r\n        require(sig.length == 65, \"Signature incorrect length\");\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            r := mload(add(sig, 0x20))\r\n            s := mload(add(sig, 0x40))\r\n            v := byte(0, mload(add(sig, 0x60)))\r\n        }\r\n\r\n        return ecrecover(dataHash, v, r, s);\r\n    }\r\n\r\n    function recoverPrefixedTxData(bytes memory sig, bytes memory txData) internal pure returns (address)\r\n    {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n112\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, txData));\r\n        address signer = recoverSigner(prefixedHash, sig);\r\n        return signer;\r\n    }\r\n\r\n    function recover(bytes memory sig, bytes memory txData) internal pure returns (address)\r\n    {\r\n        address signer = recoverSigner(keccak256(txData), sig);\r\n        return signer;\r\n    }\r\n}\r\n\r\n\r\n// Author: Steve Medley\r\n// https://github.com/Civitas-Fundamenta\r\n// steve@fundamenta.network\r\n\r\nlibrary BitShifter\r\n{\r\n    function readUint64(bytes memory buffer, uint offset) internal pure returns (uint64)\r\n    {\r\n        require(buffer.length >= offset + 32, \"Uint64 out of range\");\r\n\r\n        uint256 res;\r\n        assembly {\r\n            res := mload(add(buffer, add(0x20, offset)))\r\n        }\r\n\r\n        return uint64(res >> 192);\r\n    }\r\n\r\n    function readUint256(bytes memory buffer, uint offset) internal pure returns (uint256)\r\n    {\r\n        require(buffer.length >= offset + 32, \"Uint256 out of range\");\r\n\r\n        uint256 res;\r\n        assembly {\r\n            res := mload(add(buffer, add(0x20, offset)))\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    function readAddress(bytes memory buffer, uint offset) internal pure returns (address)\r\n    {\r\n        require(buffer.length >= offset + 32, \"Address out of range\");\r\n\r\n        address res;\r\n        assembly {\r\n            res := mload(add(buffer, add(0x20, offset)))\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    function decompose(bytes memory txData) internal pure returns (uint256, uint64, uint64, uint256, address)\r\n    {\r\n        uint256 numTokens = readUint256(txData, 0);\r\n        uint64 withdrawalBridgeId = readUint64(txData, 32);\r\n        uint64 depositBridgeId = readUint64(txData, 40);\r\n        uint256 nonce = readUint256(txData, 48);\r\n        address user = readAddress(txData, 80);\r\n\r\n        return ( numTokens, withdrawalBridgeId, depositBridgeId, nonce, user );\r\n    }\r\n}\r\n\r\n\r\n// Author: Steve Medley\r\n// https://github.com/Civitas-Fundamenta\r\n// steve@fundamenta.network\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Author: Steve Medley\r\n// https://github.com/Civitas-Fundamenta\r\n// steve@fundamenta.network\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n    function grantRole(bytes32 role, address account) external;\r\n    function revokeRole(bytes32 role, address account) external;\r\n    function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping (address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping (bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControl).interfaceId\r\n            || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\r\n        return _roles[role].members[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) public virtual override {\r\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to grant\");\r\n\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) public virtual override {\r\n        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to revoke\");\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) public virtual override {\r\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event. Note that unlike {grantRole}, this function doesn't perform any\r\n     * checks on the calling account.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * This function should only be called from the constructor when setting\r\n     * up the initial roles for the system.\r\n     *\r\n     * Using this function in any other way is effectively circumventing the admin\r\n     * system imposed by {AccessControl}.\r\n     * ====\r\n     */\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\r\n        _roles[role].adminRole = adminRole;\r\n    }\r\n\r\n    function _grantRole(bytes32 role, address account) private {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].members[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    function _revokeRole(bytes32 role, address account) private {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].members[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}\r\n\r\n\r\nabstract contract SecureContract is AccessControl\r\n{\r\n    event ContractPaused (uint height, address user);\r\n    event ContractUnpaused (uint height, address user);\r\n\r\n    bytes32 public constant _ADMIN = keccak256(\"_ADMIN\");\r\n\r\n    bool private paused_;\r\n\r\n    modifier pause()\r\n    {\r\n        require(!paused_, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier isAdmin()\r\n    {\r\n        require(hasRole(_ADMIN, msg.sender), \"Permission denied\");\r\n        _;\r\n    }\r\n\r\n    constructor()\r\n    {\r\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _setupRole(_ADMIN, msg.sender);\r\n        paused_ = true;\r\n    }\r\n\r\n    function setPaused(bool paused) public isAdmin\r\n    {\r\n        if (paused != paused_)\r\n        {\r\n            paused_ = paused;\r\n            if (paused)\r\n                emit ContractPaused(block.number, msg.sender);\r\n            else \r\n                emit ContractUnpaused(block.number, msg.sender);\r\n        }\r\n    }\r\n\r\n    function queryPaused() public view returns (bool)\r\n    {\r\n        return paused_;\r\n    }\r\n}\r\n\r\n\r\ncontract CiviPortBridge is SecureContract\r\n{\r\n    bytes32 public constant _DEPOSIT = keccak256(\"_DEPOSIT\");\r\n\r\n    event Deposit(uint256 indexed nonce, bytes data);\r\n    event Withdraw(uint256 indexed nonce, bytes data);\r\n\r\n    mapping(uint256 => bool) private withdrawNonces;\r\n    mapping(uint256 => bool) private depositNonces;\r\n\r\n    TokenInterface private token_;\r\n    uint64 private bridgeId_;\r\n    uint8 private numSigners_;\r\n\r\n    using BitShifter for bytes;\r\n\r\n    constructor(address tokenContract, uint64 bridgeId, uint8 numSigners) SecureContract()\r\n    {\r\n        _setupRole(_DEPOSIT, msg.sender);\r\n        _setRoleAdmin(_DEPOSIT, _ADMIN);\r\n        token_ = TokenInterface(tokenContract);\r\n        bridgeId_ = bridgeId;\r\n        numSigners_ = numSigners;\r\n    }\r\n\r\n    function queryWithdrawNonceUsed(bytes memory nonceBytes) public view returns (bool)\r\n    {\r\n        uint256 nonce = nonceBytes.readUint256(0);\r\n        return withdrawNonces[nonce];\r\n    }\r\n\r\n    function queryDepositNonceUsed(bytes memory nonceBytes) public view returns (bool)\r\n    {\r\n        uint256 nonce = nonceBytes.readUint256(0);\r\n        return depositNonces[nonce];\r\n    }\r\n\r\n    function queryToken() public view returns (TokenInterface)\r\n    {\r\n        return token_;\r\n    }\r\n\r\n    function queryBridgeID() public view returns (uint64)\r\n    {\r\n        return bridgeId_;\r\n    }\r\n\r\n    function queryConfirmationCount() public view returns (uint8)\r\n    {\r\n        return numSigners_;\r\n    }\r\n\r\n    function setConfirmationCount(uint8 count) public isAdmin\r\n    {\r\n        numSigners_ = count;\r\n    }\r\n\r\n    function exists(address[] memory array, address entry) private pure returns (bool)\r\n    {\r\n        uint len = array.length;\r\n        for (uint i = 0; i < len; i++)\r\n        {\r\n            if (array[i] == entry)\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function deposit(bytes memory clientSignature, bytes[] memory serverSignatures, bytes memory transactionData) public pause\r\n    {\r\n        address clientSigner = Signer.recoverPrefixedTxData(clientSignature, transactionData);\r\n        uint8 sigCount = (uint8)(serverSignatures.length);\r\n        require (sigCount >= numSigners_, \"Not enough signatures\");\r\n\r\n        address[] memory usedAddresses = new address[](numSigners_);\r\n\r\n        for (uint i = 0; i < numSigners_; i++)\r\n        {\r\n            address serverSigner = Signer.recoverPrefixedTxData(serverSignatures[i], transactionData);\r\n            require (hasRole(_DEPOSIT, serverSigner), \"Multisig signer not permitted\");\r\n            require (!exists(usedAddresses, serverSigner), \"Duplicate multisig signer\");\r\n            usedAddresses[i] = serverSigner;\r\n        }\r\n\r\n        uint256 numTokens;\r\n        uint64 withdrawalBridgeId;\r\n        uint64 depositBridgeId;\r\n        uint256 nonce;\r\n        address user;\r\n\r\n        (numTokens, withdrawalBridgeId, depositBridgeId, nonce, user) = transactionData.decompose();\r\n\r\n        require (clientSigner == user, \"Not signed by client\");\r\n        require (clientSigner == msg.sender, \"Not sent by client\");\r\n        require (depositBridgeId == bridgeId_, \"Incorrect network\");\r\n        require (!depositNonces[nonce], \"Nonce already used\");\r\n\r\n        token_.mintTo(user, numTokens);\r\n\r\n        depositNonces[nonce] = true;\r\n\r\n        emit Deposit(nonce, transactionData);\r\n    }\r\n\r\n    function withdraw(bytes memory clientSignature, bytes memory transactionData) public pause\r\n    {\r\n        address signer = Signer.recoverPrefixedTxData(clientSignature, transactionData);\r\n\r\n        uint256 numTokens;\r\n        uint64 withdrawalBridgeId;\r\n        uint64 depositBridgeId;\r\n        uint256 nonce;\r\n        address user;\r\n\r\n        (numTokens, withdrawalBridgeId, depositBridgeId, nonce, user) = transactionData.decompose();\r\n\r\n        require (signer == user, \"Not signed by client\");\r\n        require (signer == msg.sender, \"Not sent by client\");\r\n        require (withdrawalBridgeId == bridgeId_, \"Incorrect network\");\r\n        require (!withdrawNonces[nonce], \"Nonce already used\");\r\n\r\n        token_.burnFrom(user, numTokens);\r\n\r\n        withdrawNonces[nonce] = true;\r\n\r\n        emit Withdraw(nonce, transactionData);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"bridgeId\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"numSigners\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ContractPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ContractUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ADMIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DEPOSIT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"clientSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"serverSignatures\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes\",\"name\":\"transactionData\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryBridgeID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryConfirmationCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"nonceBytes\",\"type\":\"bytes\"}],\"name\":\"queryDepositNonceUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryToken\",\"outputs\":[{\"internalType\":\"contract TokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"nonceBytes\",\"type\":\"bytes\"}],\"name\":\"queryWithdrawNonceUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"count\",\"type\":\"uint8\"}],\"name\":\"setConfirmationCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"clientSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"transactionData\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CiviPortBridge","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000aa9d866666c2a3748d6b23ff69e63e52f08d9ab400000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000002","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e95ba8f95cfb1fe909b5e9da7b9687dc1f51111e332aae3eb11f5184e909d53e"}]}