{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/utils/SafeMath.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"add\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"sub\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"mul\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"div\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/MerkleProof.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle trees (hash trees),\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\n// File: contracts/assets/TokenBankInterface.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract TokenBankInterface{\r\n  function issue(address token_addr, address payable _to, uint _amount) public returns (bool success);\r\n}\r\n\r\n// File: contracts/utils/Ownable.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract Ownable {\r\n    address private _contract_owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = msg.sender;\r\n        _contract_owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _contract_owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_contract_owner, newOwner);\r\n        _contract_owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/plugins/MerkleDrop.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MerkleDrop is Ownable{\r\n  using SafeMath for uint;\r\n\r\n  address public token;\r\n  string public info;\r\n  TokenBankInterface public token_bank;\r\n  uint public total_dropped;\r\n  bytes32 public merkle_root;\r\n\r\n  bool public paused;\r\n  mapping(address => bool) private claim_status;\r\n\r\n  constructor(string memory _info, address _token_bank, address _token,\r\n              bytes32 _merkle_root)  public{\r\n    token = _token;\r\n    info = _info;\r\n    token_bank = TokenBankInterface(_token_bank);\r\n    total_dropped = 0;\r\n    merkle_root = _merkle_root;\r\n    paused = false;\r\n  }\r\n\r\n  event MerkleDropPause(bool pause);\r\n  function pause() public onlyOwner{\r\n    paused = true;\r\n    emit MerkleDropPause(true);\r\n  }\r\n  function unpause() public onlyOwner{\r\n    paused = false;\r\n    emit MerkleDropPause(false);\r\n  }\r\n\r\n  event DropToken(address claimer, address to, uint amount);\r\n  function claim(address payable to, uint amount, bytes32[] memory proof)  public returns(bool){\r\n    require(paused == false, \"already paused\");\r\n    require(claim_status[msg.sender] == false, \"you claimed already\");\r\n\r\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));\r\n\r\n    bool ret = MerkleProof.verify(proof, merkle_root, leaf);\r\n    require(ret, \"invalid merkle proof\");\r\n\r\n    claim_status[msg.sender] = true;\r\n    token_bank.issue(token, to, amount);\r\n    total_dropped = total_dropped.safeAdd(amount);\r\n    emit DropToken(msg.sender, to, amount);\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract MerkleDropFactory{\r\n\r\n  event NewMerkleDrop(address addr);\r\n  function createMerkleDrop(string memory _info, address _token_bank,\r\n                            address _token, bytes32 _merkle_root) public returns(address){\r\n    MerkleDrop mm = new MerkleDrop(_info, _token_bank, _token,\r\n                                  _merkle_root);\r\n    mm.transferOwnership(msg.sender);\r\n    emit NewMerkleDrop(address(mm));\r\n    return address(mm);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_info\",\"type\":\"string\"},{\"name\":\"_token_bank\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_merkle_root\",\"type\":\"bytes32\"}],\"name\":\"createMerkleDrop\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NewMerkleDrop\",\"type\":\"event\"}]","ContractName":"MerkleDropFactory","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"SafeMath:071108ad85d7a766b41e0f5e5195537a8fc8e74d","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://be9624e129071219d3e30cee142b1f8efe17feb3e2df6abd0bd9b4bc3c897255"}]}