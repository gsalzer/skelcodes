{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.4; \r\n\r\nlibrary EthAddressLib {\r\n    /**\r\n     * @dev returns the address used within the protocol to identify ETH\r\n     * @return the address assigned to ETH\r\n     */\r\n    function ethAddress() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n} \r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) =\r\n            target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n} \r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function abs(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a < b) {\r\n            return b - a;\r\n        }\r\n        return a - b;\r\n    }\r\n} \r\n\r\ncontract Exponential {\r\n    uint256 constant expScale = 1e18;\r\n    uint256 constant doubleScale = 1e36;\r\n    uint256 constant halfExpScale = expScale / 2;\r\n\r\n    using SafeMath for uint256;\r\n\r\n    function getExp(uint256 num, uint256 denom)\r\n        public\r\n        pure\r\n        returns (uint256 rational)\r\n    {\r\n        rational = num.mul(expScale).div(denom);\r\n    }\r\n\r\n    function getDiv(uint256 num, uint256 denom)\r\n        public\r\n        pure\r\n        returns (uint256 rational)\r\n    {\r\n        rational = num.mul(expScale).div(denom);\r\n    }\r\n\r\n    function addExp(uint256 a, uint256 b) public pure returns (uint256 result) {\r\n        result = a.add(b);\r\n    }\r\n\r\n    function subExp(uint256 a, uint256 b) public pure returns (uint256 result) {\r\n        result = a.sub(b);\r\n    }\r\n\r\n    function mulExp(uint256 a, uint256 b) public pure returns (uint256) {\r\n        uint256 doubleScaledProduct = a.mul(b);\r\n\r\n        uint256 doubleScaledProductWithHalfScale =\r\n            halfExpScale.add(doubleScaledProduct);\r\n\r\n        return doubleScaledProductWithHalfScale.div(expScale);\r\n    }\r\n\r\n    function divExp(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return getDiv(a, b);\r\n    }\r\n\r\n    function mulExp3(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 c\r\n    ) public pure returns (uint256) {\r\n        return mulExp(mulExp(a, b), c);\r\n    }\r\n\r\n    function mulScalar(uint256 a, uint256 scalar)\r\n        public\r\n        pure\r\n        returns (uint256 scaled)\r\n    {\r\n        scaled = a.mul(scalar);\r\n    }\r\n\r\n    function mulScalarTruncate(uint256 a, uint256 scalar)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 product = mulScalar(a, scalar);\r\n        return truncate(product);\r\n    }\r\n\r\n    function mulScalarTruncateAddUInt(\r\n        uint256 a,\r\n        uint256 scalar,\r\n        uint256 addend\r\n    ) public pure returns (uint256) {\r\n        uint256 product = mulScalar(a, scalar);\r\n        return truncate(product).add(addend);\r\n    }\r\n\r\n    function divScalarByExpTruncate(uint256 scalar, uint256 divisor)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 fraction = divScalarByExp(scalar, divisor);\r\n        return truncate(fraction);\r\n    }\r\n\r\n    function divScalarByExp(uint256 scalar, uint256 divisor)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numerator = expScale.mul(scalar);\r\n        return getExp(numerator, divisor);\r\n    }\r\n\r\n    function divScalar(uint256 a, uint256 scalar)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a.div(scalar);\r\n    }\r\n\r\n    function truncate(uint256 exp) public pure returns (uint256) {\r\n        return exp.div(expScale);\r\n    }\r\n} \r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n} \r\n\r\ninterface IFToken is IERC20 {\r\n    function mint(address user, uint256 amount) external returns (bytes memory);\r\n\r\n    function borrow(address borrower, uint256 borrowAmount)\r\n        external\r\n        returns (bytes memory);\r\n\r\n    function withdraw(\r\n        address payable withdrawer,\r\n        uint256 withdrawTokensIn,\r\n        uint256 withdrawAmountIn\r\n    ) external returns (uint256, bytes memory);\r\n\r\n    function underlying() external view returns (address);\r\n\r\n    function accrueInterest() external;\r\n\r\n    function getAccountState(address account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function MonitorEventCallback(\r\n        address who,\r\n        bytes32 funcName,\r\n        bytes calldata payload\r\n    ) external;\r\n\r\n    function exchangeRateCurrent() external view returns (uint256 exchangeRate);\r\n\r\n    function repay(address borrower, uint256 repayAmount)\r\n        external\r\n        returns (uint256, bytes memory);\r\n\r\n    function borrowBalanceStored(address account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function exchangeRateStored() external view returns (uint256 exchangeRate);\r\n\r\n    function liquidateBorrow(\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 repayAmount,\r\n        address fTokenCollateral\r\n    ) external returns (bytes memory);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint256);\r\n\r\n    function balanceOfUnderlying(address owner) external returns (uint256);\r\n\r\n    function _reduceReserves(uint256 reduceAmount) external;\r\n\r\n    function _addReservesFresh(uint256 addAmount) external;\r\n\r\n    function cancellingOut(address striker)\r\n        external\r\n        returns (bool strikeOk, bytes memory strikeLog);\r\n\r\n    function APR() external view returns (uint256);\r\n\r\n    function APY() external view returns (uint256);\r\n\r\n    function calcBalanceOfUnderlying(address owner)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function borrowSafeRatio() external view returns (uint256);\r\n\r\n    function tokenCash(address token, address account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getBorrowRate() external view returns (uint256);\r\n\r\n    function addTotalCash(uint256 _addAmount) external;\r\n\r\n    function subTotalCash(uint256 _subAmount) external;\r\n\r\n    function totalCash() external view returns (uint256);\r\n\r\n    function totalReserves() external view returns (uint256);\r\n\r\n    function totalBorrows() external view returns (uint256);\r\n} \r\n\r\ninterface IOracle {\r\n    function get(address token) external view returns (uint256, bool);\r\n} \r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance =\r\n            token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance =\r\n            token.allowance(address(this), spender).sub(\r\n                value,\r\n                \"SafeERC20: decreased allowance below zero\"\r\n            );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata =\r\n            address(token).functionCall(\r\n                data,\r\n                \"SafeERC20: low-level call failed\"\r\n            );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n} \r\n\r\nenum RewardType {\r\n    DefaultType,\r\n    Deposit,\r\n    Borrow,\r\n    Withdraw,\r\n    Repay,\r\n    Liquidation,\r\n    TokenIn,\r\n    TokenOut\r\n} \r\n\r\ninterface IBank {\r\n    function MonitorEventCallback(bytes32 funcName, bytes calldata payload)\r\n        external;\r\n\r\n    function deposit(address token, uint256 amount) external payable;\r\n\r\n    function borrow(address token, uint256 amount) external;\r\n\r\n    function withdraw(address underlying, uint256 withdrawTokens) external;\r\n\r\n    function withdrawUnderlying(address underlying, uint256 amount) external;\r\n\r\n    function repay(address token, uint256 amount) external payable;\r\n\r\n    function liquidateBorrow(\r\n        address borrower,\r\n        address underlyingBorrow,\r\n        address underlyingCollateral,\r\n        uint256 repayAmount\r\n    ) external payable;\r\n\r\n    function tokenIn(address token, uint256 amountIn) external payable;\r\n\r\n    function tokenOut(address token, uint256 amountOut) external;\r\n\r\n    function cancellingOut(address token) external;\r\n\r\n    function paused() external view returns (bool);\r\n}\r\n\r\n// reward token pool interface (FOR)\r\ninterface IRewardPool {\r\n    function theForceToken() external view returns (address);\r\n\r\n    function bankController() external view returns (address);\r\n\r\n    function admin() external view returns (address);\r\n\r\n    function deposit(uint256 amount) external;\r\n\r\n    function withdraw(uint256 amount) external;\r\n\r\n    function withdraw() external;\r\n\r\n    function setTheForceToken(address _theForceToken) external;\r\n\r\n    function setBankController(address _bankController) external;\r\n\r\n    function reward(address who, uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private initializing;\r\n\r\n    /**\r\n     * @dev Modifier to use in the initializer function of a contract.\r\n     */\r\n    modifier initializer() {\r\n        require(\r\n            initializing || isConstructor() || !initialized,\r\n            \"Contract instance has already been initialized\"\r\n        );\r\n\r\n        bool isTopLevelCall = !initializing;\r\n        if (isTopLevelCall) {\r\n            initializing = true;\r\n            initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        assembly {\r\n            cs := extcodesize(self)\r\n        }\r\n        return cs == 0;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n} \r\npragma experimental ABIEncoderV2;\r\n\r\ncontract BankController is Exponential, Initializable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    struct Market {\r\n        address fTokenAddress;\r\n        bool isValid;\r\n        uint256 collateralAbility;\r\n        mapping(address => bool) accountsIn;\r\n        uint256 liquidationIncentive;\r\n    }\r\n\r\n    mapping(address => Market) public markets;\r\n\r\n    address public bankEntryAddress;\r\n    address public theForceToken;\r\n\r\n    mapping(uint256 => uint256) public rewardFactors; // RewardType ==> rewardFactor (1e18 scale);\r\n\r\n    mapping(address => IFToken[]) public accountAssets;\r\n\r\n    IFToken[] public allMarkets;\r\n\r\n    address[] public allUnderlyingMarkets;\r\n\r\n    IOracle public oracle;\r\n\r\n    address public mulsig;\r\n\r\n    modifier auth {\r\n        require(\r\n            msg.sender == admin || msg.sender == bankEntryAddress,\r\n            \"msg.sender need admin or bank\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setBankEntryAddress(address _newBank) external auth {\r\n        bankEntryAddress = _newBank;\r\n    }\r\n\r\n    function marketsContains(address fToken) public view returns (bool) {\r\n        return allFtokenMarkets[fToken];\r\n    }\r\n\r\n    uint256 public closeFactor;\r\n\r\n    address public admin;\r\n\r\n    address public proposedAdmin;\r\n\r\n    address public rewardPool;\r\n\r\n    uint256 public transferEthGasCost;\r\n\r\n    // @notice Borrow caps enforced by borrowAllowed for each token address. Defaults to zero which corresponds to unlimited borrowing.\r\n    mapping(address => uint256) public borrowCaps;\r\n\r\n    // @notice Supply caps enforced by mintAllowed for each token address. Defaults to zero which corresponds to unlimited supplying.\r\n    mapping(address => uint256) public supplyCaps;\r\n\r\n    struct TokenConfig {\r\n        bool depositDisabled;\r\n        bool borrowDisabled;\r\n        bool withdrawDisabled;\r\n        bool repayDisabled;\r\n        bool liquidateBorrowDisabled;\r\n    }\r\n\r\n    //underlying => TokenConfig\r\n    mapping(address => TokenConfig) public tokenConfigs;\r\n\r\n    mapping(address => uint256) public underlyingLiquidationThresholds;\r\n    event SetLiquidationThreshold(\r\n        address indexed underlying,\r\n        uint256 threshold\r\n    );\r\n\r\n    bool private entered;\r\n    modifier nonReentrant() {\r\n        require(!entered, \"re-entered\");\r\n        entered = true;\r\n        _;\r\n        entered = false;\r\n    }\r\n\r\n    uint256 public flashloanFeeBips; // 9 for 0.0009\r\n    address public flashloanVault; // flash loan vault(recv flash loan fee);\r\n    event SetFlashloanParams(\r\n        address indexed sender,\r\n        uint256 bips,\r\n        address flashloanVault\r\n    );\r\n\r\n    // fToken => supported or not, using mapping to save gas instead of iterator array\r\n    mapping(address => bool) public allFtokenMarkets;\r\n    event SetAllFtokenMarkets(bytes data);\r\n\r\n    // fToken => exchangeUnit, to save gas instead of runtime calc\r\n    mapping(address => uint256) public allFtokenExchangeUnits;\r\n\r\n    // _setMarketBorrowSupplyCaps = _setMarketBorrowCaps + _setMarketSupplyCaps\r\n    function _setMarketBorrowSupplyCaps(\r\n        address[] calldata tokens,\r\n        uint256[] calldata newBorrowCaps,\r\n        uint256[] calldata newSupplyCaps\r\n    ) external {\r\n        require(msg.sender == admin, \"only admin can set borrow/supply caps\");\r\n\r\n        uint256 numMarkets = tokens.length;\r\n        uint256 numBorrowCaps = newBorrowCaps.length;\r\n        uint256 numSupplyCaps = newSupplyCaps.length;\r\n\r\n        require(\r\n            numMarkets != 0 &&\r\n                numMarkets == numBorrowCaps &&\r\n                numMarkets == numSupplyCaps,\r\n            \"invalid input\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < numMarkets; i++) {\r\n            borrowCaps[tokens[i]] = newBorrowCaps[i];\r\n            supplyCaps[tokens[i]] = newSupplyCaps[i];\r\n        }\r\n    }\r\n\r\n    function setTokenConfig(\r\n        address t,\r\n        bool _depositDisabled,\r\n        bool _borrowDisabled,\r\n        bool _withdrawDisabled,\r\n        bool _repayDisabled,\r\n        bool _liquidateBorrowDisabled\r\n    ) external {\r\n        require(msg.sender == admin, \"only admin can set token configs\");\r\n        tokenConfigs[t] = TokenConfig(\r\n            _depositDisabled,\r\n            _borrowDisabled,\r\n            _withdrawDisabled,\r\n            _repayDisabled,\r\n            _liquidateBorrowDisabled\r\n        );\r\n    }\r\n\r\n    function setLiquidationThresolds(\r\n        address[] calldata underlyings,\r\n        uint256[] calldata _liquidationThresolds\r\n    ) external onlyAdmin {\r\n        uint256 n = underlyings.length;\r\n        require(n == _liquidationThresolds.length && n >= 1, \"length: wtf?\");\r\n        for (uint256 i = 0; i < n; i++) {\r\n            uint256 ltv = markets[underlyings[i]].collateralAbility;\r\n            require(ltv <= _liquidationThresolds[i], \"risk param error\");\r\n            underlyingLiquidationThresholds[\r\n                underlyings[i]\r\n            ] = _liquidationThresolds[i];\r\n            emit SetLiquidationThreshold(\r\n                underlyings[i],\r\n                _liquidationThresolds[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function setFlashloanParams(\r\n        uint256 _flashloanFeeBips,\r\n        address _flashloanVault\r\n    ) external onlyAdmin {\r\n        require(\r\n            _flashloanFeeBips <= 10000 && _flashloanVault != address(0),\r\n            \"flashloan param error\"\r\n        );\r\n        flashloanFeeBips = _flashloanFeeBips;\r\n        flashloanVault = _flashloanVault;\r\n        emit SetFlashloanParams(msg.sender, _flashloanFeeBips, _flashloanVault);\r\n    }\r\n\r\n    function setAllFtokenMarkets(address[] calldata ftokens)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        uint256 n = ftokens.length;\r\n        for (uint256 i = 0; i < n; i++) {\r\n            allFtokenMarkets[ftokens[i]] = true;\r\n            allFtokenExchangeUnits[ftokens[i]] = _calcExchangeUnit(ftokens[i]);\r\n        }\r\n        emit SetAllFtokenMarkets(abi.encode(ftokens));\r\n    }\r\n\r\n    function initialize(address _mulsig) public initializer {\r\n        admin = msg.sender;\r\n        mulsig = _mulsig;\r\n        transferEthGasCost = 5000;\r\n    }\r\n\r\n    modifier onlyMulSig {\r\n        require(msg.sender == mulsig, \"require admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin, \"require admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFToken(address fToken) {\r\n        require(marketsContains(fToken), \"only supported fToken\");\r\n        _;\r\n    }\r\n\r\n    event AddTokenToMarket(address underlying, address fToken);\r\n\r\n    function proposeNewAdmin(address admin_) external onlyMulSig {\r\n        proposedAdmin = admin_;\r\n    }\r\n\r\n    function claimAdministration() external {\r\n        require(msg.sender == proposedAdmin, \"Not proposed admin.\");\r\n        admin = proposedAdmin;\r\n        proposedAdmin = address(0);\r\n    }\r\n\r\n    function getFTokeAddress(address underlying) public view returns (address) {\r\n        return markets[underlying].fTokenAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account)\r\n        external\r\n        view\r\n        returns (IFToken[] memory)\r\n    {\r\n        IFToken[] memory assetsIn = accountAssets[account];\r\n\r\n        return assetsIn;\r\n    }\r\n\r\n    function checkAccountsIn(address account, IFToken fToken)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            markets[IFToken(address(fToken)).underlying()].accountsIn[account];\r\n    }\r\n\r\n    function userEnterMarket(IFToken fToken, address borrower) internal {\r\n        Market storage marketToJoin = markets[fToken.underlying()];\r\n\r\n        require(marketToJoin.isValid, \"Market not valid\");\r\n\r\n        if (marketToJoin.accountsIn[borrower]) {\r\n            return;\r\n        }\r\n\r\n        marketToJoin.accountsIn[borrower] = true;\r\n\r\n        accountAssets[borrower].push(fToken);\r\n    }\r\n\r\n    function transferCheck(\r\n        address fToken,\r\n        address src,\r\n        address dst,\r\n        uint256 transferTokens\r\n    ) external onlyFToken(msg.sender) {\r\n        withdrawCheck(fToken, src, transferTokens);\r\n        userEnterMarket(IFToken(fToken), dst);\r\n    }\r\n\r\n    function withdrawCheck(\r\n        address fToken,\r\n        address withdrawer,\r\n        uint256 withdrawTokens\r\n    ) public view returns (uint256) {\r\n        address underlying = IFToken(fToken).underlying();\r\n        require(markets[underlying].isValid, \"Market not valid\");\r\n        require(\r\n            !tokenConfigs[underlying].withdrawDisabled,\r\n            \"withdraw disabled\"\r\n        );\r\n\r\n        (uint256 sumCollaterals, uint256 sumBorrows) =\r\n            getUserLiquidity(withdrawer, IFToken(fToken), withdrawTokens, 0);\r\n        require(sumCollaterals >= sumBorrows, \"Cannot withdraw tokens\");\r\n    }\r\n\r\n    function transferIn(\r\n        address account,\r\n        address underlying,\r\n        uint256 amount\r\n    ) public payable nonReentrant {\r\n        require(\r\n            msg.sender == bankEntryAddress || msg.sender == account,\r\n            \"auth failed\"\r\n        );\r\n        if (underlying != EthAddressLib.ethAddress()) {\r\n            require(msg.value == 0, \"ERC20 do not accecpt ETH.\");\r\n            uint256 balanceBefore = IERC20(underlying).balanceOf(address(this));\r\n            IERC20(underlying).safeTransferFrom(account, address(this), amount);\r\n            uint256 balanceAfter = IERC20(underlying).balanceOf(address(this));\r\n            require(\r\n                balanceAfter - balanceBefore == amount,\r\n                \"TransferIn amount not valid\"\r\n            );\r\n            // erc 20 => transferFrom\r\n        } else {\r\n            // payable\r\n            require(msg.value >= amount, \"Eth value is not enough\");\r\n            if (msg.value > amount) {\r\n                //send back excess ETH\r\n                uint256 excessAmount = msg.value.sub(amount);\r\n                //solium-disable-next-line\r\n                (bool result, ) =\r\n                    account.call{value: excessAmount, gas: transferEthGasCost}(\r\n                        \"\"\r\n                    );\r\n                require(result, \"Transfer of ETH failed\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function transferToUser(\r\n        address underlying,\r\n        address payable account,\r\n        uint256 amount\r\n    ) external onlyFToken(msg.sender) {\r\n        require(\r\n            markets[IFToken(msg.sender).underlying()].isValid,\r\n            \"TransferToUser not allowed\"\r\n        );\r\n        transferToUserInternal(underlying, account, amount);\r\n    }\r\n\r\n    function transferFlashloanAsset(\r\n        address underlying,\r\n        address payable account,\r\n        uint256 amount\r\n    ) external {\r\n        require(msg.sender == bankEntryAddress, \"only bank auth\");\r\n        transferToUserInternal(underlying, account, amount);\r\n    }\r\n\r\n    function transferToUserInternal(\r\n        address underlying,\r\n        address payable account,\r\n        uint256 amount\r\n    ) internal {\r\n        if (underlying != EthAddressLib.ethAddress()) {\r\n            // erc 20\r\n            // ERC20(token).safeTransfer(user, _amount);\r\n            IERC20(underlying).safeTransfer(account, amount);\r\n        } else {\r\n            (bool result, ) =\r\n                account.call{value: amount, gas: transferEthGasCost}(\"\");\r\n            require(result, \"Transfer of ETH failed\");\r\n        }\r\n    }\r\n\r\n    function setTransferEthGasCost(uint256 _transferEthGasCost)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        transferEthGasCost = _transferEthGasCost;\r\n    }\r\n\r\n    function getCashPrior(address underlying) public view returns (uint256) {\r\n        IFToken fToken = IFToken(getFTokeAddress(underlying));\r\n        return fToken.totalCash();\r\n    }\r\n\r\n    function getCashAfter(address underlying, uint256 transferInAmount)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return getCashPrior(underlying).add(transferInAmount);\r\n    }\r\n\r\n    function mintCheck(\r\n        address underlying,\r\n        address minter,\r\n        uint256 amount\r\n    ) external {\r\n        require(marketsContains(msg.sender), \"MintCheck fails\");\r\n        require(markets[underlying].isValid, \"Market not valid\");\r\n        require(!tokenConfigs[underlying].depositDisabled, \"deposit disabled\");\r\n\r\n        uint256 supplyCap = supplyCaps[underlying];\r\n        // Supply cap of 0 corresponds to unlimited supplying\r\n        if (supplyCap != 0) {\r\n            uint256 totalSupply = IFToken(msg.sender).totalSupply();\r\n            uint256 _exchangeRate = IFToken(msg.sender).exchangeRateStored();\r\n            uint256 totalUnderlyingSupply =\r\n                mulScalarTruncate(_exchangeRate, totalSupply);\r\n            uint256 nextTotalUnderlyingSupply =\r\n                totalUnderlyingSupply.add(amount);\r\n            require(\r\n                nextTotalUnderlyingSupply < supplyCap,\r\n                \"market supply cap reached\"\r\n            );\r\n        }\r\n\r\n        if (!markets[underlying].accountsIn[minter]) {\r\n            userEnterMarket(IFToken(getFTokeAddress(underlying)), minter);\r\n        }\r\n    }\r\n\r\n    function borrowCheck(\r\n        address account,\r\n        address underlying,\r\n        address fToken,\r\n        uint256 borrowAmount\r\n    ) external {\r\n        require(\r\n            underlying == IFToken(msg.sender).underlying(),\r\n            \"invalid underlying token\"\r\n        );\r\n        require(markets[underlying].isValid, \"BorrowCheck fails\");\r\n        require(!tokenConfigs[underlying].borrowDisabled, \"borrow disabled\");\r\n\r\n        uint256 borrowCap = borrowCaps[underlying];\r\n        // Borrow cap of 0 corresponds to unlimited borrowing\r\n        if (borrowCap != 0) {\r\n            uint256 totalBorrows = IFToken(msg.sender).totalBorrows();\r\n            uint256 nextTotalBorrows = totalBorrows.add(borrowAmount);\r\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\r\n        }\r\n\r\n        require(markets[underlying].isValid, \"Market not valid\");\r\n        (, bool valid) = fetchAssetPrice(underlying);\r\n        require(valid, \"Price is not valid\");\r\n        if (!markets[underlying].accountsIn[account]) {\r\n            userEnterMarket(IFToken(getFTokeAddress(underlying)), account);\r\n        }\r\n        (uint256 sumCollaterals, uint256 sumBorrows) =\r\n            getUserLiquidity(account, IFToken(fToken), 0, borrowAmount);\r\n        require(sumBorrows > 0, \"borrow value too low\");\r\n        require(sumCollaterals >= sumBorrows, \"insufficient liquidity\");\r\n    }\r\n\r\n    function repayCheck(address underlying) external view {\r\n        require(markets[underlying].isValid, \"Market not valid\");\r\n        require(!tokenConfigs[underlying].repayDisabled, \"repay disabled\");\r\n    }\r\n\r\n    function getTotalDepositAndBorrow(address account)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        return getUserLiquidity(account, IFToken(0), 0, 0);\r\n    }\r\n\r\n    function getAccountLiquidity(address account)\r\n        public\r\n        view\r\n        returns (uint256 liquidity, uint256 shortfall)\r\n    {\r\n        (uint256 sumCollaterals, uint256 sumBorrows) =\r\n            getTotalDepositAndBorrow(account);\r\n        // These are safe, as the underflow condition is checked first\r\n        if (sumCollaterals > sumBorrows) {\r\n            return (sumCollaterals - sumBorrows, 0);\r\n        } else {\r\n            return (0, sumBorrows - sumCollaterals);\r\n        }\r\n    }\r\n\r\n    // Get price of oracle\r\n    function fetchAssetPrice(address token)\r\n        public\r\n        view\r\n        returns (uint256, bool)\r\n    {\r\n        require(address(oracle) != address(0), \"oracle not set\");\r\n        return oracle.get(token);\r\n    }\r\n\r\n    function setOracle(address _oracle) external onlyAdmin {\r\n        oracle = IOracle(_oracle);\r\n    }\r\n\r\n    function _supportMarket(\r\n        IFToken fToken,\r\n        uint256 _collateralAbility,\r\n        uint256 _liquidationIncentive\r\n    ) external onlyAdmin {\r\n        address underlying = fToken.underlying();\r\n\r\n        require(!markets[underlying].isValid, \"martket existed\");\r\n        require(tokenDecimals(underlying) <= 18, \"unsupported token decimals\");\r\n\r\n        markets[underlying] = Market({\r\n            isValid: true,\r\n            collateralAbility: _collateralAbility,\r\n            fTokenAddress: address(fToken),\r\n            liquidationIncentive: _liquidationIncentive\r\n        });\r\n\r\n        addTokenToMarket(underlying, address(fToken));\r\n\r\n        allFtokenMarkets[address(fToken)] = true;\r\n        allFtokenExchangeUnits[address(fToken)] = _calcExchangeUnit(\r\n            address(fToken)\r\n        );\r\n    }\r\n\r\n    function addTokenToMarket(address underlying, address fToken) internal {\r\n        for (uint256 i = 0; i < allUnderlyingMarkets.length; i++) {\r\n            require(allUnderlyingMarkets[i] != underlying, \"token exists\");\r\n            require(allMarkets[i] != IFToken(fToken), \"token exists\");\r\n        }\r\n        allMarkets.push(IFToken(fToken));\r\n        allUnderlyingMarkets.push(underlying);\r\n\r\n        emit AddTokenToMarket(underlying, fToken);\r\n    }\r\n\r\n    function _setCollateralAbility(\r\n        address[] calldata underlyings,\r\n        uint256[] calldata newCollateralAbilities,\r\n        uint256[] calldata _liquidationIncentives\r\n    ) external onlyAdmin {\r\n        uint256 n = underlyings.length;\r\n        require(\r\n            n == newCollateralAbilities.length &&\r\n                n == _liquidationIncentives.length &&\r\n                n >= 1,\r\n            \"invalid length\"\r\n        );\r\n        for (uint256 i = 0; i < n; i++) {\r\n            address u = underlyings[i];\r\n            require(markets[u].isValid, \"Market not valid\");\r\n            Market storage market = markets[u];\r\n            market.collateralAbility = newCollateralAbilities[i];\r\n            market.liquidationIncentive = _liquidationIncentives[i];\r\n        }\r\n    }\r\n\r\n    function setCloseFactor(uint256 _closeFactor) external onlyAdmin {\r\n        closeFactor = _closeFactor;\r\n    }\r\n\r\n    function setMarketIsValid(address underlying, bool isValid)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        Market storage market = markets[underlying];\r\n        market.isValid = isValid;\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() external view returns (IFToken[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function seizeCheck(address fTokenCollateral, address fTokenBorrowed)\r\n        external\r\n        view\r\n    {\r\n        require(!IBank(bankEntryAddress).paused(), \"system paused!\");\r\n        require(\r\n            markets[IFToken(fTokenCollateral).underlying()].isValid &&\r\n                markets[IFToken(fTokenBorrowed).underlying()].isValid &&\r\n                marketsContains(fTokenCollateral) &&\r\n                marketsContains(fTokenBorrowed),\r\n            \"Seize market not valid\"\r\n        );\r\n    }\r\n\r\n    struct LiquidityLocals {\r\n        uint256 sumCollateral;\r\n        uint256 sumBorrows;\r\n        uint256 fTokenBalance;\r\n        uint256 borrowBalance;\r\n        uint256 exchangeRate;\r\n        uint256 oraclePrice;\r\n        uint256 collateralAbility;\r\n        uint256 collateral;\r\n    }\r\n\r\n    function getUserLiquidity(\r\n        address account,\r\n        IFToken fTokenNow,\r\n        uint256 withdrawTokens,\r\n        uint256 borrowAmount\r\n    ) public view returns (uint256, uint256) {\r\n        IFToken[] memory assets = accountAssets[account];\r\n        LiquidityLocals memory vars;\r\n        for (uint256 i = 0; i < assets.length; i++) {\r\n            IFToken asset = assets[i];\r\n            (vars.fTokenBalance, vars.borrowBalance, vars.exchangeRate) = asset\r\n                .getAccountState(account);\r\n            vars.collateralAbility = markets[asset.underlying()]\r\n                .collateralAbility;\r\n            (uint256 oraclePrice, bool valid) =\r\n                fetchAssetPrice(asset.underlying());\r\n            require(valid, \"Price is not valid\");\r\n            vars.oraclePrice = oraclePrice;\r\n\r\n            uint256 fixUnit = calcExchangeUnit(address(asset));\r\n            uint256 exchangeRateFixed = mulScalar(vars.exchangeRate, fixUnit);\r\n\r\n            vars.collateral = mulExp3(\r\n                vars.collateralAbility,\r\n                exchangeRateFixed,\r\n                vars.oraclePrice\r\n            );\r\n\r\n            vars.sumCollateral = mulScalarTruncateAddUInt(\r\n                vars.collateral,\r\n                vars.fTokenBalance,\r\n                vars.sumCollateral\r\n            );\r\n\r\n            vars.borrowBalance = vars.borrowBalance.mul(fixUnit);\r\n            vars.borrowBalance = vars.borrowBalance.mul(1e18).div(\r\n                vars.collateralAbility\r\n            );\r\n\r\n            vars.sumBorrows = mulScalarTruncateAddUInt(\r\n                vars.oraclePrice,\r\n                vars.borrowBalance,\r\n                vars.sumBorrows\r\n            );\r\n\r\n            if (asset == fTokenNow) {\r\n                vars.sumBorrows = mulScalarTruncateAddUInt(\r\n                    vars.collateral,\r\n                    withdrawTokens,\r\n                    vars.sumBorrows\r\n                );\r\n\r\n                borrowAmount = borrowAmount.mul(fixUnit);\r\n                borrowAmount = borrowAmount.mul(1e18).div(\r\n                    vars.collateralAbility\r\n                );\r\n\r\n                vars.sumBorrows = mulScalarTruncateAddUInt(\r\n                    vars.oraclePrice,\r\n                    borrowAmount,\r\n                    vars.sumBorrows\r\n                );\r\n            }\r\n        }\r\n\r\n        return (vars.sumCollateral, vars.sumBorrows);\r\n    }\r\n\r\n    struct HealthFactorLocals {\r\n        uint256 sumLiquidity;\r\n        uint256 sumLiquidityPlusThreshold;\r\n        uint256 sumBorrows;\r\n        uint256 fTokenBalance;\r\n        uint256 borrowBalance;\r\n        uint256 exchangeRate;\r\n        uint256 oraclePrice;\r\n        uint256 liquidationThreshold;\r\n        uint256 liquidity;\r\n        uint256 liquidityPlusThreshold;\r\n    }\r\n\r\n    function getHealthFactor(address account)\r\n        public\r\n        view\r\n        returns (uint256 healthFactor)\r\n    {\r\n        IFToken[] memory assets = accountAssets[account];\r\n        HealthFactorLocals memory vars;\r\n        uint256 _healthFactor = uint256(-1);\r\n        for (uint256 i = 0; i < assets.length; i++) {\r\n            IFToken asset = assets[i];\r\n            address underlying = asset.underlying();\r\n            (vars.fTokenBalance, vars.borrowBalance, vars.exchangeRate) = asset\r\n                .getAccountState(account);\r\n            vars.liquidationThreshold = underlyingLiquidationThresholds[\r\n                underlying\r\n            ];\r\n            (uint256 oraclePrice, bool valid) = fetchAssetPrice(underlying);\r\n            require(valid, \"Price is not valid\");\r\n            vars.oraclePrice = oraclePrice;\r\n\r\n            uint256 fixUnit = calcExchangeUnit(address(asset));\r\n            uint256 exchangeRateFixed = mulScalar(vars.exchangeRate, fixUnit);\r\n\r\n            vars.liquidityPlusThreshold = mulExp3(\r\n                vars.liquidationThreshold,\r\n                exchangeRateFixed,\r\n                vars.oraclePrice\r\n            );\r\n            vars.sumLiquidityPlusThreshold = mulScalarTruncateAddUInt(\r\n                vars.liquidityPlusThreshold,\r\n                vars.fTokenBalance,\r\n                vars.sumLiquidityPlusThreshold\r\n            );\r\n\r\n            vars.borrowBalance = vars.borrowBalance.mul(fixUnit);\r\n            vars.borrowBalance = vars.borrowBalance.mul(1e18).div(\r\n                vars.liquidationThreshold\r\n            );\r\n\r\n            vars.sumBorrows = mulScalarTruncateAddUInt(\r\n                vars.oraclePrice,\r\n                vars.borrowBalance,\r\n                vars.sumBorrows\r\n            );\r\n        }\r\n\r\n        if (vars.sumBorrows > 0) {\r\n            _healthFactor = divExp(\r\n                vars.sumLiquidityPlusThreshold,\r\n                vars.sumBorrows\r\n            );\r\n        }\r\n\r\n        return _healthFactor;\r\n    }\r\n\r\n    function tokenDecimals(address token) public view returns (uint256) {\r\n        return\r\n            token == EthAddressLib.ethAddress()\r\n                ? 18\r\n                : uint256(IERC20(token).decimals());\r\n    }\r\n\r\n    function isFTokenValid(address fToken) external view returns (bool) {\r\n        return markets[IFToken(fToken).underlying()].isValid;\r\n    }\r\n\r\n    function liquidateBorrowCheck(\r\n        address fTokenBorrowed,\r\n        address fTokenCollateral,\r\n        address borrower,\r\n        address liquidator,\r\n        uint256 repayAmount\r\n    ) external onlyFToken(msg.sender) {\r\n        address underlyingBorrowed = IFToken(fTokenBorrowed).underlying();\r\n        address underlyingCollateral = IFToken(fTokenCollateral).underlying();\r\n        require(\r\n            !tokenConfigs[underlyingBorrowed].liquidateBorrowDisabled,\r\n            \"liquidateBorrow: liquidate borrow disabled\"\r\n        );\r\n        require(\r\n            !tokenConfigs[underlyingCollateral].liquidateBorrowDisabled,\r\n            \"liquidateBorrow: liquidate colleteral disabled\"\r\n        );\r\n\r\n        uint256 hf = getHealthFactor(borrower);\r\n        require(hf < 1e18, \"HealthFactor > 1\");\r\n        userEnterMarket(IFToken(fTokenCollateral), liquidator);\r\n\r\n        uint256 borrowBalance =\r\n            IFToken(fTokenBorrowed).borrowBalanceStored(borrower);\r\n        uint256 maxClose = mulScalarTruncate(closeFactor, borrowBalance);\r\n        require(repayAmount <= maxClose, \"Too much repay\");\r\n    }\r\n\r\n    function _calcExchangeUnit(address fToken) internal view returns (uint256) {\r\n        uint256 fTokenDecimals = uint256(IFToken(fToken).decimals());\r\n        uint256 underlyingDecimals =\r\n            tokenDecimals(IFToken(fToken).underlying());\r\n\r\n        return 10**SafeMath.abs(fTokenDecimals, underlyingDecimals);\r\n    }\r\n\r\n    function calcExchangeUnit(address fToken) public view returns (uint256) {\r\n        return allFtokenExchangeUnits[fToken];\r\n    }\r\n\r\n    function liquidateTokens(\r\n        address fTokenBorrowed,\r\n        address fTokenCollateral,\r\n        uint256 actualRepayAmount\r\n    ) external view returns (uint256) {\r\n        (uint256 borrowPrice, bool borrowValid) =\r\n            fetchAssetPrice(IFToken(fTokenBorrowed).underlying());\r\n        (uint256 collateralPrice, bool collateralValid) =\r\n            fetchAssetPrice(IFToken(fTokenCollateral).underlying());\r\n        require(borrowValid && collateralValid, \"Price not valid\");\r\n\r\n        /*\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint256 exchangeRate = IFToken(fTokenCollateral).exchangeRateStored();\r\n\r\n        uint256 fixCollateralUnit = calcExchangeUnit(fTokenCollateral);\r\n        uint256 fixBorrowlUnit = calcExchangeUnit(fTokenBorrowed);\r\n\r\n        uint256 numerator =\r\n            mulExp(\r\n                markets[IFToken(fTokenCollateral).underlying()]\r\n                    .liquidationIncentive,\r\n                borrowPrice\r\n            );\r\n        exchangeRate = exchangeRate.mul(fixCollateralUnit);\r\n\r\n        actualRepayAmount = actualRepayAmount.mul(fixBorrowlUnit);\r\n\r\n        uint256 denominator = mulExp(collateralPrice, exchangeRate);\r\n        uint256 seizeTokens =\r\n            mulScalarTruncate(\r\n                divExp(numerator, denominator),\r\n                actualRepayAmount\r\n            );\r\n\r\n        return seizeTokens;\r\n    }\r\n\r\n    struct ReserveWithdrawalLogStruct {\r\n        address token_address;\r\n        uint256 reserve_withdrawed;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    function reduceReserves(\r\n        address underlying,\r\n        address payable account,\r\n        uint256 reduceAmount\r\n    ) public onlyMulSig {\r\n        IFToken fToken = IFToken(getFTokeAddress(underlying));\r\n        fToken._reduceReserves(reduceAmount);\r\n        transferToUserInternal(underlying, account, reduceAmount);\r\n        fToken.subTotalCash(reduceAmount);\r\n\r\n        ReserveWithdrawalLogStruct memory rds =\r\n            ReserveWithdrawalLogStruct(\r\n                underlying,\r\n                reduceAmount,\r\n                fToken.exchangeRateStored(),\r\n                fToken.getBorrowRate(),\r\n                fToken.tokenCash(underlying, address(this))\r\n            );\r\n\r\n        IBank(bankEntryAddress).MonitorEventCallback(\r\n            \"ReserveWithdrawal\",\r\n            abi.encode(rds)\r\n        );\r\n    }\r\n\r\n    function batchReduceReserves(\r\n        address[] calldata underlyings,\r\n        address payable account,\r\n        uint256[] calldata reduceAmounts\r\n    ) external onlyMulSig {\r\n        require(underlyings.length == reduceAmounts.length, \"length not match\");\r\n        uint256 n = underlyings.length;\r\n        for (uint256 i = 0; i < n; i++) {\r\n            reduceReserves(underlyings[i], account, reduceAmounts[i]);\r\n        }\r\n    }\r\n\r\n    function batchReduceAllReserves(\r\n        address[] calldata underlyings,\r\n        address payable account\r\n    ) external onlyMulSig {\r\n        uint256 n = underlyings.length;\r\n        for (uint256 i = 0; i < n; i++) {\r\n            IFToken fToken = IFToken(getFTokeAddress(underlyings[i]));\r\n            uint256 amount =\r\n                SafeMath.min(\r\n                    fToken.totalReserves(),\r\n                    fToken.tokenCash(underlyings[i], address(this))\r\n                );\r\n            if (amount > 0) {\r\n                reduceReserves(underlyings[i], account, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function batchReduceAllReserves(address payable account)\r\n        external\r\n        onlyMulSig\r\n    {\r\n        uint256 n = allUnderlyingMarkets.length;\r\n        for (uint256 i = 0; i < n; i++) {\r\n            address underlying = allUnderlyingMarkets[i];\r\n            IFToken fToken = IFToken(getFTokeAddress(underlying));\r\n            uint256 amount =\r\n                SafeMath.min(\r\n                    fToken.totalReserves(),\r\n                    fToken.tokenCash(underlying, address(this))\r\n                );\r\n            if (amount > 0) {\r\n                reduceReserves(underlying, account, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    struct ReserveDepositLogStruct {\r\n        address token_address;\r\n        uint256 reserve_funded;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    function balance(address token) external view returns (uint256) {\r\n        if (token == EthAddressLib.ethAddress()) {\r\n            return address(this).balance;\r\n        }\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev receive function enforces that the caller is a contract, to support flashloan transfers\r\n     **/\r\n    receive() external payable {\r\n        //only contracts can send ETH to the bank controller\r\n        require(\r\n            address(msg.sender).isContract(),\r\n            \"Only contracts can send ether to the bank controller\"\r\n        );\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fToken\",\"type\":\"address\"}],\"name\":\"AddTokenToMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SetAllFtokenMarkets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bips\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"flashloanVault\",\"type\":\"address\"}],\"name\":\"SetFlashloanParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"SetLiquidationThreshold\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"underlyings\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newCollateralAbilities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_liquidationIncentives\",\"type\":\"uint256[]\"}],\"name\":\"_setCollateralAbility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newBorrowCaps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newSupplyCaps\",\"type\":\"uint256[]\"}],\"name\":\"_setMarketBorrowSupplyCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFToken\",\"name\":\"fToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAbility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationIncentive\",\"type\":\"uint256\"}],\"name\":\"_supportMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountAssets\",\"outputs\":[{\"internalType\":\"contract IFToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"addExp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allFtokenExchangeUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allFtokenMarkets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allMarkets\",\"outputs\":[{\"internalType\":\"contract IFToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allUnderlyingMarkets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bankEntryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"underlyings\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"batchReduceAllReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"batchReduceAllReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"underlyings\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"reduceAmounts\",\"type\":\"uint256[]\"}],\"name\":\"batchReduceReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"borrowCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fToken\",\"type\":\"address\"}],\"name\":\"calcExchangeUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"contract IFToken\",\"name\":\"fToken\",\"type\":\"address\"}],\"name\":\"checkAccountsIn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAdministration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"divExp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scalar\",\"type\":\"uint256\"}],\"name\":\"divScalar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"scalar\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"divScalarByExp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"scalar\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"divScalarByExpTruncate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"fetchAssetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashloanFeeBips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashloanVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfall\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllMarkets\",\"outputs\":[{\"internalType\":\"contract IFToken[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAssetsIn\",\"outputs\":[{\"internalType\":\"contract IFToken[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transferInAmount\",\"type\":\"uint256\"}],\"name\":\"getCashAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getCashPrior\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denom\",\"type\":\"uint256\"}],\"name\":\"getDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rational\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denom\",\"type\":\"uint256\"}],\"name\":\"getExp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rational\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getFTokeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getHealthFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"healthFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTotalDepositAndBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"contract IFToken\",\"name\":\"fTokenNow\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"getUserLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mulsig\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fToken\",\"type\":\"address\"}],\"name\":\"isFTokenValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fTokenBorrowed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"liquidateBorrowCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fTokenBorrowed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"actualRepayAmount\",\"type\":\"uint256\"}],\"name\":\"liquidateTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fTokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"collateralAbility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationIncentive\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fToken\",\"type\":\"address\"}],\"name\":\"marketsContains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"mulExp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"}],\"name\":\"mulExp3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scalar\",\"type\":\"uint256\"}],\"name\":\"mulScalar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"scaled\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scalar\",\"type\":\"uint256\"}],\"name\":\"mulScalarTruncate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scalar\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addend\",\"type\":\"uint256\"}],\"name\":\"mulScalarTruncateAddUInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mulsig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"proposeNewAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reduceAmount\",\"type\":\"uint256\"}],\"name\":\"reduceReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"repayCheck\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardFactors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fTokenCollateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fTokenBorrowed\",\"type\":\"address\"}],\"name\":\"seizeCheck\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"ftokens\",\"type\":\"address[]\"}],\"name\":\"setAllFtokenMarkets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newBank\",\"type\":\"address\"}],\"name\":\"setBankEntryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_closeFactor\",\"type\":\"uint256\"}],\"name\":\"setCloseFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_flashloanFeeBips\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_flashloanVault\",\"type\":\"address\"}],\"name\":\"setFlashloanParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"underlyings\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_liquidationThresolds\",\"type\":\"uint256[]\"}],\"name\":\"setLiquidationThresolds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"name\":\"setMarketIsValid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_depositDisabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_borrowDisabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_withdrawDisabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_repayDisabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_liquidateBorrowDisabled\",\"type\":\"bool\"}],\"name\":\"setTokenConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transferEthGasCost\",\"type\":\"uint256\"}],\"name\":\"setTransferEthGasCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"subExp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"theForceToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenConfigs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"depositDisabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"borrowDisabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withdrawDisabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"repayDisabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"liquidateBorrowDisabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transferTokens\",\"type\":\"uint256\"}],\"name\":\"transferCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferEthGasCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFlashloanAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferIn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exp\",\"type\":\"uint256\"}],\"name\":\"truncate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"underlyingLiquidationThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"withdrawer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawCheck\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BankController","CompilerVersion":"v0.6.4+commit.1dca32f3","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"petersburg","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f4131b18c2742d2a1a886f123e879087b17ccaa8973c1a6bcf80131671ea7e45"}]}