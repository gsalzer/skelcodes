{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PoolView.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./IPool.sol\\\";\\nimport \\\"./libs/complifi/tokens/IERC20Metadata.sol\\\";\\n\\ncontract PoolView {\\n    struct TokenRecord {\\n        address self;\\n        uint256 balance;\\n        uint256 leverage;\\n        uint8 decimals;\\n        uint256 userBalance;\\n    }\\n\\n    struct Token {\\n        address self;\\n        uint256 totalSupply;\\n        uint8 decimals;\\n        uint256 userBalance;\\n    }\\n\\n    struct Config {\\n        address derivativeVault;\\n        address dynamicFee;\\n        address repricer;\\n        uint exposureLimit;\\n        uint volatility;\\n        uint pMin;\\n        uint qMin;\\n        uint8 qMinDecimals;\\n        uint baseFee;\\n        uint maxFee;\\n        uint feeAmp;\\n        uint8 decimals;\\n    }\\n\\n    function getPoolInfo(address _pool)\\n    external view\\n    returns (\\n        TokenRecord memory primary,\\n        TokenRecord memory complement,\\n        Token memory poolToken,\\n        Config memory config\\n    )\\n    {\\n        IPool pool = IPool(_pool);\\n\\n        address _primaryAddress = address(pool.derivativeVault().primaryToken());\\n        primary = TokenRecord(\\n            _primaryAddress,\\n            pool.getBalance(_primaryAddress),\\n            pool.getLeverage(_primaryAddress),\\n            IERC20Metadata(_primaryAddress).decimals(),\\n            IERC20(_primaryAddress).balanceOf(msg.sender)\\n        );\\n\\n        address _complementAddress = address(pool.derivativeVault().complementToken());\\n        complement = TokenRecord(\\n            _complementAddress,\\n            pool.getBalance(_complementAddress),\\n            pool.getLeverage(_complementAddress),\\n            IERC20Metadata(_complementAddress).decimals(),\\n            IERC20(_complementAddress).balanceOf(msg.sender)\\n        );\\n\\n        poolToken = Token(\\n            _pool,\\n            pool.totalSupply(),\\n            IERC20Metadata(_pool).decimals(),\\n            IERC20(_pool).balanceOf(msg.sender)\\n        );\\n\\n        config = Config(\\n            address(pool.derivativeVault()),\\n            address(pool.dynamicFee()),\\n            address(pool.repricer()),\\n            pool.exposureLimit(),\\n            pool.volatility(),\\n            pool.pMin(),\\n            pool.qMin(),\\n            IERC20Metadata(_primaryAddress).decimals(),\\n            pool.baseFee(),\\n            pool.maxFee(),\\n            pool.feeAmp(),\\n            IERC20Metadata(_pool).decimals()\\n        );\\n    }\\n\\n    function getPoolTokenData(address _pool)\\n    external view\\n    returns (\\n        address primary,\\n        uint primaryBalance,\\n        uint primaryLeverage,\\n        uint8 primaryDecimals,\\n        address complement,\\n        uint complementBalance,\\n        uint complementLeverage,\\n        uint8 complementDecimals,\\n        uint lpTotalSupply,\\n        uint8 lpDecimals\\n    )\\n    {\\n        IPool pool = IPool(_pool);\\n\\n        primary = address(pool.derivativeVault().primaryToken());\\n        complement = address(pool.derivativeVault().complementToken());\\n\\n        primaryBalance = pool.getBalance(primary);\\n        primaryLeverage = pool.getLeverage(primary);\\n        primaryDecimals = IERC20Metadata(primary).decimals();\\n\\n        complementBalance = pool.getBalance(complement);\\n        complementLeverage = pool.getLeverage(complement);\\n        complementDecimals = IERC20Metadata(complement).decimals();\\n\\n        lpTotalSupply  = pool.totalSupply();\\n        lpDecimals = IERC20Metadata(_pool).decimals();\\n    }\\n\\n    function getPoolConfig(address _pool)\\n    external view\\n    returns (\\n        address derivativeVault,\\n        address dynamicFee,\\n        address repricer,\\n        uint exposureLimit,\\n        uint volatility,\\n        uint pMin,\\n        uint qMin,\\n        uint baseFee,\\n        uint maxFee,\\n        uint feeAmp\\n    )\\n    {\\n        IPool pool = IPool(_pool);\\n        derivativeVault = address(pool.derivativeVault());\\n        dynamicFee = address(pool.dynamicFee());\\n        repricer = address(pool.repricer());\\n        pMin = pool.pMin();\\n        qMin = pool.qMin();\\n        exposureLimit = pool.exposureLimit();\\n        baseFee = pool.baseFee();\\n        feeAmp = pool.feeAmp();\\n        maxFee = pool.maxFee();\\n        volatility = pool.volatility();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IPool.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Token.sol\\\";\\nimport \\\"./IVault.sol\\\";\\n\\ninterface IPool is IERC20 {\\n\\n    function repricingBlock() external view returns(uint);\\n\\n    function baseFee() external view returns(uint);\\n    function feeAmp() external view returns(uint);\\n    function maxFee() external view returns(uint);\\n\\n    function pMin() external view returns(uint);\\n    function qMin() external view returns(uint);\\n    function exposureLimit() external view returns(uint);\\n    function volatility() external view returns(uint);\\n\\n    function derivativeVault() external view returns(IVault);\\n    function dynamicFee() external view returns(address);\\n    function repricer() external view returns(address);\\n\\n    function isFinalized()\\n    external view\\n    returns (bool);\\n\\n    function getNumTokens()\\n    external view\\n    returns (uint);\\n\\n    function getTokens()\\n    external view\\n    returns (address[] memory tokens);\\n\\n    function getLeverage(address token)\\n    external view\\n    returns (uint);\\n\\n    function getBalance(address token)\\n    external view\\n    returns (uint);\\n\\n    function getController()\\n    external view\\n    returns (address);\\n\\n    function setController(address manager)\\n    external;\\n\\n\\n    function joinPool(uint poolAmountOut, uint[2] calldata maxAmountsIn)\\n    external;\\n\\n    function exitPool(uint poolAmountIn, uint[2] calldata minAmountsOut)\\n    external;\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint minAmountOut\\n    )\\n    external\\n    returns (uint tokenAmountOut, uint spotPriceAfter);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/complifi/tokens/IERC20Metadata.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IERC20Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/Token.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Num.sol\\\";\\n\\n// Highly opinionated token implementation\\n\\ninterface IERC20 {\\n\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address whom) external view returns (uint);\\n    function allowance(address src, address dst) external view returns (uint);\\n\\n    function approve(address dst, uint amt) external returns (bool);\\n    function transfer(address dst, uint amt) external returns (bool);\\n    function transferFrom(\\n        address src, address dst, uint amt\\n    ) external returns (bool);\\n}\\n\\ncontract TokenBase is Num {\\n\\n    mapping(address => uint)                   internal _balance;\\n    mapping(address => mapping(address=>uint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = add(_balance[address(this)], amt);\\n        _totalSupply = add(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] >= amt, \\\"INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = sub(_balance[address(this)], amt);\\n        _totalSupply = sub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] >= amt, \\\"INSUFFICIENT_BAL\\\");\\n        _balance[src] = sub(_balance[src], amt);\\n        _balance[dst] = add(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract Token is TokenBase, IERC20 {\\n\\n    string  private _name;\\n    string  private _symbol;\\n    uint8   private constant _decimals = 18;\\n\\n    function setName(string memory name) internal {\\n        _name = name;\\n    }\\n\\n    function setSymbol(string memory symbol) internal {\\n        _symbol = symbol;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns(uint8) {\\n        return _decimals;\\n    }\\n\\n    function allowance(address src, address dst) external view override returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view override returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public view override returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external override returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = add(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = sub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external override returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\\n        uint oldValue = _allowance[src][msg.sender];\\n        require(msg.sender == src || amt <= oldValue, \\\"TOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src && oldValue != uint256(-1)) {\\n            _allowance[src][msg.sender] = sub(oldValue, amt);\\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IVault.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Token.sol\\\";\\nimport \\\"./libs/complifi/IDerivativeSpecification.sol\\\";\\n\\ninterface IVault {\\n    /// @notice vault initialization time\\n    function initializationTime() external view returns(uint256);\\n    /// @notice start of live period\\n    function liveTime() external view returns(uint256);\\n    /// @notice end of live period\\n    function settleTime() external view returns(uint256);\\n\\n    /// @notice underlying value at the start of live period\\n    function underlyingStarts(uint index) external view returns(int256);\\n    /// @notice underlying value at the end of live period\\n    function underlyingEnds(uint index) external view returns(int256);\\n\\n    /// @notice primary token conversion rate multiplied by 10 ^ 12\\n    function primaryConversion() external view returns(uint256);\\n    /// @notice complement token conversion rate multiplied by 10 ^ 12\\n    function complementConversion() external view returns(uint256);\\n\\n    // @notice derivative specification address\\n    function derivativeSpecification() external view returns(IDerivativeSpecification);\\n    // @notice collateral token address\\n    function collateralToken() external view returns(IERC20);\\n    // @notice oracle address\\n    function oracles(uint index) external view returns(address);\\n    function oracleIterators(uint index) external view returns(address);\\n\\n    // @notice primary token address\\n    function primaryToken() external view returns(IERC20);\\n    // @notice complement token address\\n    function complementToken() external view returns(IERC20);\\n}\\n\"\r\n    },\r\n    \"contracts/Num.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Const.sol\\\";\\n\\ncontract Num is Const {\\n\\n    function toi(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function floor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return toi(a) * BONE;\\n    }\\n\\n    function add(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n    }\\n\\n    function sub(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        bool flag;\\n        (c, flag) = subSign(a, b);\\n        require(!flag, \\\"SUB_UNDERFLOW\\\");\\n    }\\n\\n    function subSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function mul(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"MUL_OVERFLOW\\\");\\n        c = c1 / BONE;\\n    }\\n\\n    function div(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        require(b != 0, \\\"DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"DIV_INTERNAL\\\"); // mul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"DIV_INTERNAL\\\"); //  add require\\n        c = c1 / b;\\n    }\\n\\n    // DSMath.wpow\\n    function powi(uint a, uint n)\\n        internal pure\\n        returns (uint z)\\n    {\\n        z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = mul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = mul(z, a);\\n            }\\n        }\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `powi` for `b^e` and `powK` for k iterations\\n    // of approximation of b^0.w\\n    function pow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_POW_BASE, \\\"POW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_POW_BASE, \\\"POW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = floor(exp);\\n        uint remain = sub(exp, whole);\\n\\n        uint wholePow = powi(base, toi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = powApprox(base, remain, POW_PRECISION);\\n        return mul(wholePow, partialResult);\\n    }\\n\\n    function powApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint sum)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = subSign(base, BONE);\\n        uint term = BONE;\\n        sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom\\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = subSign(a, sub(bigK, BONE));\\n            term = mul(term, mul(c, x));\\n            term = div(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = sub(sum, term);\\n            } else {\\n                sum = add(sum, term);\\n            }\\n        }\\n    }\\n\\n    function min(uint first, uint second)\\n        internal pure\\n        returns (uint)\\n    {\\n        if(first < second) {\\n            return first;\\n        }\\n        return second;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Const.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Color.sol\\\";\\n\\ncontract Const is Bronze {\\n    uint public constant BONE              = 10**18;\\n    int public constant  iBONE             = int(BONE);\\n\\n    uint public constant MIN_POW_BASE      = 1 wei;\\n    uint public constant MAX_POW_BASE      = (2 * BONE) - 1 wei;\\n    uint public constant POW_PRECISION     = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"contracts/Color.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nabstract contract Color {\\n    function getColor()\\n        external view virtual\\n        returns (bytes32);\\n}\\n\\ncontract Bronze is Color {\\n    function getColor()\\n        external view override\\n        returns (bytes32) {\\n            return bytes32(\\\"BRONZE\\\");\\n        }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/complifi/IDerivativeSpecification.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\n/// @title Derivative Specification interface\\n/// @notice Immutable collection of derivative attributes\\n/// @dev Created by the derivative's author and published to the DerivativeSpecificationRegistry\\ninterface IDerivativeSpecification {\\n    /// @notice Proof of a derivative specification\\n    /// @dev Verifies that contract is a derivative specification\\n    /// @return true if contract is a derivative specification\\n    function isDerivativeSpecification() external pure returns (bool);\\n\\n    /// @notice Set of oracles that are relied upon to measure changes in the state of the world\\n    /// between the start and the end of the Live period\\n    /// @dev Should be resolved through OracleRegistry contract\\n    /// @return oracle symbols\\n    function oracleSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Algorithm that, for the type of oracle used by the derivative,\\n    /// finds the value closest to a given timestamp\\n    /// @dev Should be resolved through OracleIteratorRegistry contract\\n    /// @return oracle iterator symbols\\n    function oracleIteratorSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Type of collateral that users submit to mint the derivative\\n    /// @dev Should be resolved through CollateralTokenRegistry contract\\n    /// @return collateral token symbol\\n    function collateralTokenSymbol() external view returns (bytes32);\\n\\n    /// @notice Mapping from the change in the underlying variable (as defined by the oracle)\\n    /// and the initial collateral split to the final collateral split\\n    /// @dev Should be resolved through CollateralSplitRegistry contract\\n    /// @return collateral split symbol\\n    function collateralSplitSymbol() external view returns (bytes32);\\n\\n    /// @notice Lifecycle parameter that define the length of the derivative's Live period.\\n    /// @dev Set in seconds\\n    /// @return live period value\\n    function livePeriod() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of primary asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of primary asset\\n    /// @return primary nominal value\\n    function primaryNominalValue() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of complement asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of complement asset\\n    /// @return complement nominal value\\n    function complementNominalValue() external view returns (uint256);\\n\\n    /// @notice Minting fee rate due to the author of the derivative specification.\\n    /// @dev Percentage fee multiplied by 10 ^ 12\\n    /// @return author fee\\n    function authorFee() external view returns (uint256);\\n\\n    /// @notice Symbol of the derivative\\n    /// @dev Should be resolved through DerivativeSpecificationRegistry contract\\n    /// @return derivative specification symbol\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Return optional long name of the derivative\\n    /// @dev Isn't used directly in the protocol\\n    /// @return long name\\n    function name() external view returns (string memory);\\n\\n    /// @notice Optional URI to the derivative specs\\n    /// @dev Isn't used directly in the protocol\\n    /// @return URI to the derivative specs\\n    function baseURI() external view returns (string memory);\\n\\n    /// @notice Derivative spec author\\n    /// @dev Used to set and receive author's fee\\n    /// @return address of the author\\n    function author() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"getPoolConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"derivativeVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dynamicFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"repricer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exposureLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"getPoolInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"self\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolView.TokenRecord\",\"name\":\"primary\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"self\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolView.TokenRecord\",\"name\":\"complement\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"self\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolView.Token\",\"name\":\"poolToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"derivativeVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dynamicFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"repricer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exposureLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qMin\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"qMinDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmp\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct PoolView.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"getPoolTokenData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"primary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"primaryBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"primaryLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"primaryDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"complement\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"complementBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"complementLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"complementDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"lpTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"lpDecimals\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PoolView","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}