{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.3;\r\n\r\ninterface IDharmaActionRegistry {\r\n  function initialize() external;\r\n}\r\n\r\n/**\r\n * @title DharmaActionRegistry\r\n * @author cf\r\n * @notice This contract delegates all logic, to an implementation contract\r\n * whose address is held by the upgrade-beacon specified at initialization.\r\n */\r\ncontract DharmaActionRegistry {\r\n  // Declare upgrade beacon address as a immutable (i.e. not in contract storage).\r\n  // The value is set at deployment in the constructor.\r\n  address immutable _UPGRADE_BEACON;\r\n\r\n  /**\r\n   * @notice In the constructor, set the upgrade-beacon address.\r\n   * implementation set on the upgrade beacon, supplying initialization calldata\r\n   * as a constructor argument. The deployment will revert and pass along the\r\n   * revert reason in the event that this initialization delegatecall reverts.\r\n   * @param upgradeBeaconAddress address to set as the upgrade-beacon that\r\n   * holds the implementation contract\r\n   */\r\n  constructor(address upgradeBeaconAddress) {\r\n    // Ensure upgrade-beacon is specified\r\n    require(upgradeBeaconAddress != address(0), \"Must specify an upgrade-beacon address.\");\r\n\r\n    // Ensure that the upgrade-beacon contract has code via extcodesize.\r\n    uint256 upgradeBeaconSize;\r\n    assembly { upgradeBeaconSize := extcodesize(upgradeBeaconAddress) }\r\n    require(upgradeBeaconSize > 0, \"upgrade-beacon must have contract code.\");\r\n\r\n    _UPGRADE_BEACON = upgradeBeaconAddress;\r\n\r\n    // retrieve implementation to initialize - this is the same logic as _implementation\r\n    (bool ok, bytes memory returnData) = upgradeBeaconAddress.staticcall(\"\");\r\n\r\n    // Revert and pass along revert message if call to upgrade beacon reverts.\r\n    if(!ok) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n\r\n    // Get the implementation to the address returned from the upgrade beacon.\r\n    address implementation = abi.decode(returnData, (address));\r\n\r\n    // Delegatecall into the implementation, supplying initialization calldata.\r\n    (ok, ) = implementation.delegatecall(abi.encodeWithSelector(IDharmaActionRegistry.initialize.selector));\r\n\r\n    // Revert and include revert data if delegatecall to implementation reverts.\r\n    if (!ok) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice In the fallback, delegate execution to the implementation set on\r\n   * the upgrade beacon.\r\n   */\r\n  fallback() external {\r\n    // Delegate execution to implementation contract provided by upgrade beacon.\r\n    _delegate(_implementation());\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to get the current implementation from the\r\n   * upgrade beacon. This is accomplished via a staticcall to the beacon with no\r\n   * data, and the beacon will return an abi-encoded implementation address.\r\n   * @return implementation address of the implementation.\r\n   */\r\n  function _implementation() private view returns (address implementation) {\r\n    // Get the current implementation address from the upgrade beacon.\r\n    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall(\"\");\r\n\r\n    // Revert and pass along revert message if call to upgrade beacon reverts.\r\n    require(ok, string(returnData));\r\n\r\n    // Set the implementation to the address returned from the upgrade beacon.\r\n    implementation = abi.decode(returnData, (address));\r\n  }\r\n\r\n  /**\r\n   * @notice Private function that delegates execution to an implementation\r\n   * contract. This is a low level function that doesn't return to its internal\r\n   * call site. It will return whatever is returned by the implementation to the\r\n   * external caller, reverting and returning the revert data if implementation\r\n   * reverts.\r\n   * @param implementation address to delegate.\r\n   */\r\n  function _delegate(address implementation) private {\r\n    assembly {\r\n    // Copy msg.data. We take full control of memory in this inline assembly\r\n    // block because it will not return to Solidity code. We overwrite the\r\n    // Solidity scratch pad at memory position 0.\r\n      calldatacopy(0, 0, calldatasize())\r\n\r\n    // Delegatecall to the implementation, supplying calldata and gas.\r\n    // Out and outsize are set to zero - instead, use the return buffer.\r\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n    // Copy the returned data from the return buffer.\r\n      returndatacopy(0, 0, returndatasize())\r\n\r\n      switch result\r\n      // Delegatecall returns 0 on error.\r\n      case 0 { revert(0, returndatasize()) }\r\n      default { return(0, returndatasize()) }\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"upgradeBeaconAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}]","ContractName":"DharmaActionRegistry","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d2ed0f115d750887d4e5c6c1e881d8bf70a1ec33","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e71331354c871e1192fbf8b92d2d4cf056b8c76bf855141855bf2ae0c23b6fd2"}]}