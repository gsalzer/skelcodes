{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/koloale/orion-projects/orion-exchange-bsc-test/contracts/OrionVaultInterface.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\n\\ninterface OrionVaultInterface {\\n\\n    /**\\n     * @dev Returns locked or frozen stake balance only\\n     * @param user address\\n     */\\n    function getLockedStakeBalance(address user) external view returns (uint64);\\n\\n    /**\\n     * @dev send some orion from user's stake to receiver balance\\n     * @dev This function is used during liquidations, to reimburse liquidator\\n     *      with orions from stake for decreasing liabilities.\\n     * @param user - user whose stake will be decreased\\n     * @param receiver - user which get orions\\n     * @param amount - amount of withdrawn tokens\\n     */\\n    function seizeFromStake(address user, address receiver, uint64 amount) external;\\n\\n}\\n\"\r\n    },\r\n    \"/Users/koloale/orion-projects/orion-exchange-bsc-test/contracts/PriceOracleDataTypes.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface PriceOracleDataTypes {\\n    struct PriceDataOut {\\n        uint64 price;\\n        uint64 timestamp;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/Users/koloale/orion-projects/orion-exchange-bsc-test/contracts/PriceOracleInterface.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./PriceOracleDataTypes.sol\\\";\\n\\ninterface PriceOracleInterface is PriceOracleDataTypes {\\n    function assetPrices(address) external view returns (PriceDataOut memory);\\n    function givePrices(address[] calldata assetAddresses) external view returns (PriceDataOut[] memory);\\n}\\n\"\r\n    },\r\n    \"/Users/koloale/orion-projects/orion-exchange-bsc-test/contracts/libs/MarginalFunctionality.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\nimport \\\"../PriceOracleInterface.sol\\\";\\nimport \\\"../OrionVaultInterface.sol\\\";\\n\\n\\nlibrary MarginalFunctionality {\\n\\n    struct Liability {\\n        address asset;\\n        uint64 timestamp;\\n        uint192 outstandingAmount;\\n    }\\n\\n    enum PositionState {\\n        POSITIVE,\\n        NEGATIVE, // weighted position below 0\\n        OVERDUE,  // liability is not returned for too long\\n        NOPRICE,  // some assets has no price or expired\\n        INCORRECT // some of the basic requirements are not met:\\n                  // too many liabilities, no locked stake, etc\\n    }\\n    struct Position {\\n        PositionState state;\\n        int256 weightedPosition;\\n        int256 totalPosition;\\n        int256 totalLiabilities;\\n    }\\n\\n    struct UsedConstants {\\n      address user;\\n      address _oracleAddress;\\n      address _orionVaultContractAddress;\\n      address _orionTokenAddress;\\n      uint64 positionOverdue;\\n      uint64 priceOverdue;\\n      uint8 stakeRisk;\\n      uint8 liquidationPremium;\\n    }\\n\\n\\n    /**\\n     * @dev method to multiply numbers with uint8 based percent numbers\\n     */\\n    function uint8Percent(int192 _a, uint8 b) internal pure returns (int192 c) {\\n        int a = int256(_a);\\n        int d = 255;\\n        c = int192((a>65536) ? (a/d)*b : a*b/d );\\n    }\\n\\n    /**\\n     * @dev method to calc weighted and absolute collateral value\\n     * @notice it only count for assets in collateralAssets list, all other\\n               assets will add 0 to position.\\n     * @return outdated wether any price is outdated\\n     * @return weightedPosition in ORN\\n     * @return totalPosition in ORN\\n     */\\n    function calcAssets(address[] storage collateralAssets,\\n                        mapping(address => mapping(address => int192)) storage assetBalances,\\n                        mapping(address => uint8) storage assetRisks,\\n                        UsedConstants memory constants)\\n             internal view returns\\n        (bool outdated, int192 weightedPosition, int192 totalPosition) {\\n        uint256 collateralAssetsLength = collateralAssets.length;\\n        for(uint256 i = 0; i < collateralAssetsLength; i++) {\\n          address asset = collateralAssets[i];\\n          if(assetBalances[constants.user][asset]<0)\\n              continue; // will be calculated in calcLiabilities\\n          (uint64 price, uint64 timestamp) = (1e8, 0xfffffff000000000);\\n\\n          if(asset != constants._orionTokenAddress) {\\n            PriceOracleInterface.PriceDataOut memory assetPriceData = PriceOracleInterface(constants._oracleAddress).assetPrices(asset);//TODO givePrices\\n            (price, timestamp) = (assetPriceData.price, assetPriceData.timestamp);\\n          }\\n\\n          // balance: i192, price u64 => balance*price fits i256\\n          // since generally balance <= N*maxInt112 (where N is number operations with it),\\n          // assetValue <= N*maxInt112*maxUInt64/1e8.\\n          // That is if N<= 2**17 *1e8 = 1.3e13  we can neglect overflows here\\n          int192 assetValue = int192(int256(assetBalances[constants.user][asset])*price/1e8);\\n          // Overflows logic holds here as well, except that N is the number of\\n          // operations for all assets\\n          if(assetValue>0) {\\n            weightedPosition += uint8Percent(assetValue, assetRisks[asset]);\\n            totalPosition += assetValue;\\n            // if assetValue == 0  ignore outdated price\\n            outdated = outdated ||\\n                            ((timestamp + constants.priceOverdue) < block.timestamp);\\n          }\\n        }\\n        return (outdated, weightedPosition, totalPosition);\\n    }\\n\\n    function calcLiabilities(mapping(address => Liability[]) storage liabilities,\\n                             mapping(address => mapping(address => int192)) storage assetBalances,\\n                             UsedConstants memory constants\\n                             )\\n             internal view returns\\n        (bool outdated, bool overdue, int192 weightedPosition, int192 totalPosition) {\\n        uint256 liabilitiesLength = liabilities[constants.user].length;\\n        for(uint256 i = 0; i < liabilitiesLength; i++) {\\n          Liability storage liability = liabilities[constants.user][i];\\n          PriceOracleInterface.PriceDataOut memory assetPriceData = PriceOracleInterface(constants._oracleAddress).assetPrices(liability.asset);//TODO givePrices\\n          (uint64 price, uint64 timestamp) = (assetPriceData.price, assetPriceData.timestamp);\\n          // balance: i192, price u64 => balance*price fits i256\\n          // since generally balance <= N*maxInt112 (where N is number operations with it),\\n          // assetValue <= N*maxInt112*maxUInt64/1e8.\\n          // That is if N<= 2**17 *1e8 = 1.3e13  we can neglect overflows here\\n          int192 liabilityValue = int192(\\n                                         int256(assetBalances[constants.user][liability.asset])\\n                                         *price/1e8\\n                                        );\\n          weightedPosition += liabilityValue; //already negative since balance is negative\\n          totalPosition += liabilityValue;\\n          overdue = overdue || ((liability.timestamp + constants.positionOverdue) < block.timestamp);\\n          outdated = outdated ||\\n                          ((timestamp + constants.priceOverdue) < block.timestamp);\\n        }\\n\\n        return (outdated, overdue, weightedPosition, totalPosition);\\n    }\\n\\n    /**\\n     * @dev method to calc Position\\n     * @return result position structure\\n     */\\n    function calcPosition(\\n                        address[] storage collateralAssets,\\n                        mapping(address => Liability[]) storage liabilities,\\n                        mapping(address => mapping(address => int192)) storage assetBalances,\\n                        mapping(address => uint8) storage assetRisks,\\n                        UsedConstants memory constants\\n                        )\\n             public view returns (Position memory result) {\\n        (bool outdatedPrice, int192 weightedPosition, int192 totalPosition) =\\n          calcAssets(collateralAssets,\\n                     assetBalances,\\n                     assetRisks,\\n                     constants);\\n        (bool _outdatedPrice, bool overdue, int192 _weightedPosition, int192 _totalPosition) =\\n           calcLiabilities(liabilities,\\n                           assetBalances,\\n                           constants\\n                           );\\n        uint64 lockedAmount = OrionVaultInterface(constants._orionVaultContractAddress)\\n                                  .getLockedStakeBalance(constants.user);\\n        int192 weightedStake = uint8Percent(int192(lockedAmount), constants.stakeRisk);\\n        weightedPosition += weightedStake;\\n        totalPosition += lockedAmount;\\n\\n        weightedPosition += _weightedPosition;\\n        totalPosition += _totalPosition;\\n        outdatedPrice = outdatedPrice || _outdatedPrice;\\n        bool incorrect = (liabilities[constants.user].length>0) && (lockedAmount==0);\\n        if(_totalPosition<0) {\\n          result.totalLiabilities = _totalPosition;\\n        }\\n        if(weightedPosition<0) {\\n          result.state = PositionState.NEGATIVE;\\n        }\\n        if(outdatedPrice) {\\n          result.state = PositionState.NOPRICE;\\n        }\\n        if(overdue) {\\n          result.state = PositionState.OVERDUE;\\n        }\\n        if(incorrect) {\\n          result.state = PositionState.INCORRECT;\\n        }\\n        result.weightedPosition = weightedPosition;\\n        result.totalPosition = totalPosition;\\n    }\\n\\n    function removeLiability(address user,\\n                             address asset,\\n                             mapping(address => Liability[]) storage liabilities)\\n        public      {\\n        uint256 length = liabilities[user].length;\\n        for (uint256 i = 0; i < length; i++) {\\n          if (liabilities[user][i].asset == asset) {\\n            if (length>1) {\\n              liabilities[user][i] = liabilities[user][length - 1];\\n            }\\n            liabilities[user].pop();\\n            break;\\n          }\\n        }\\n    }\\n\\n    function updateLiability(address user,\\n                             address asset,\\n                             mapping(address => Liability[]) storage liabilities,\\n                             uint112 depositAmount,\\n                             int192 currentBalance)\\n        public      {\\n        if(currentBalance>=0) {\\n            removeLiability(user,asset,liabilities);\\n        } else {\\n            uint256 i;\\n            uint256 liabilitiesLength=liabilities[user].length;\\n            for(; i<liabilitiesLength-1; i++) {\\n                if(liabilities[user][i].asset == asset)\\n                  break;\\n              }\\n            Liability storage liability = liabilities[user][i];\\n            if(depositAmount>=liability.outstandingAmount) {\\n                liability.outstandingAmount = uint192(-currentBalance);\\n                liability.timestamp = uint64(block.timestamp);\\n            } else {\\n                liability.outstandingAmount -= depositAmount;\\n            }\\n        }\\n    }\\n\\n    function partiallyLiquidate(address[] storage collateralAssets,\\n                                mapping(address => Liability[]) storage liabilities,\\n                                mapping(address => mapping(address => int192)) storage assetBalances,\\n                                mapping(address => uint8) storage assetRisks,\\n                                UsedConstants memory constants,\\n                                address redeemedAsset,\\n                                uint112 amount) public {\\n        //Note: constants.user - is broker who will be liquidated\\n        Position memory initialPosition = calcPosition(collateralAssets,\\n                                           liabilities,\\n                                           assetBalances,\\n                                           assetRisks,\\n                                           constants);\\n        require(initialPosition.state == PositionState.NEGATIVE ||\\n                initialPosition.state == PositionState.OVERDUE  , \\\"E7\\\");\\n        address liquidator = msg.sender;\\n        require(assetBalances[liquidator][redeemedAsset]>=amount,\\\"E8\\\");\\n        require(assetBalances[constants.user][redeemedAsset]<0,\\\"E15\\\");\\n        assetBalances[liquidator][redeemedAsset] -= amount;\\n        assetBalances[constants.user][redeemedAsset] += amount;\\n        if(assetBalances[constants.user][redeemedAsset] >= 0)\\n          removeLiability(constants.user, redeemedAsset, liabilities);\\n        PriceOracleInterface.PriceDataOut memory assetPriceData = PriceOracleInterface(constants._oracleAddress).assetPrices(redeemedAsset);\\n        (uint64 price, uint64 timestamp) = (assetPriceData.price, assetPriceData.timestamp);\\n        require((timestamp + constants.priceOverdue) > block.timestamp, \\\"E9\\\"); //Price is outdated\\n\\n        reimburseLiquidator(amount, price, liquidator, assetBalances, constants);\\n        Position memory finalPosition = calcPosition(collateralAssets,\\n                                           liabilities,\\n                                           assetBalances,\\n                                           assetRisks,\\n                                           constants);\\n        require( int(finalPosition.state)<3 && //POSITIVE,NEGATIVE or OVERDUE\\n                 (finalPosition.weightedPosition>initialPosition.weightedPosition),\\n                 \\\"E10\\\");//Incorrect state position after liquidation\\n       if(finalPosition.state == PositionState.POSITIVE)\\n         require (finalPosition.weightedPosition<10e8,\\\"Can not liquidate to very positive state\\\");\\n\\n    }\\n\\n    function reimburseLiquidator(\\n                       uint112 amount,\\n                       uint64 price,\\n                       address liquidator,\\n                       mapping(address => mapping(address => int192)) storage assetBalances,\\n                       UsedConstants memory constants)\\n             internal\\n             {\\n        int192 _orionAmount = int192(int256(amount)*price/1e8);\\n        _orionAmount += uint8Percent(_orionAmount,constants.liquidationPremium); //Liquidation premium\\n        require(_orionAmount == int64(_orionAmount), \\\"E11\\\");\\n        int64 orionAmount = int64(_orionAmount);\\n        // There is only 100m Orion tokens, fits i64\\n        int64 onBalanceOrion = int64(assetBalances[constants.user][constants._orionTokenAddress]);\\n        (int64 fromBalance, int64 fromStake) = (onBalanceOrion>orionAmount)?\\n                                                 (orionAmount, 0) :\\n                                                 (onBalanceOrion>0)?\\n                                                   (onBalanceOrion, orionAmount-onBalanceOrion) :\\n                                                   (0, orionAmount);\\n\\n        if(fromBalance>0) {\\n          assetBalances[constants.user][constants._orionTokenAddress] -= int192(fromBalance);\\n          assetBalances[liquidator][constants._orionTokenAddress] += int192(fromBalance);\\n        }\\n        if(fromStake>0) {\\n          OrionVaultInterface(constants._orionVaultContractAddress).seizeFromStake(constants.user, liquidator, uint64(fromStake));\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[]","ContractName":"MarginalFunctionality","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}