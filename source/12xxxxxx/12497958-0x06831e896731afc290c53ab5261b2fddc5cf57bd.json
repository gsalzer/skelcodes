{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n  function initialize() external;\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address account) external view returns (uint);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n  function symbol() external view returns (string memory);\r\n  function decimals() external view returns (uint);\r\n  function approve(address spender, uint amount) external returns (bool);\r\n  function mint(address account, uint amount) external;\r\n  function burn(address account, uint amount) external;\r\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), owner);\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == owner;\r\n  }\r\n\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(owner, address(0));\r\n    owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract MasterPool is Ownable {\r\n\r\n  struct UserInfo {\r\n    uint amount;\r\n    uint rewardDebt;\r\n  }\r\n\r\n  // Info of each pool.\r\n  struct PoolInfo {\r\n    IERC20 lpToken;        // Address of LP token contract.\r\n    uint allocPoints;      // How many allocation points assigned to this pool. RewardTokens to distribute per block.\r\n    uint lastRewardBlock;  // Last block number that RewardTokens distribution occurs.\r\n    uint accRewardTokenPerShare; // Accumulated RewardTokens per share, times 1e12. See below.\r\n  }\r\n\r\n  struct PoolPosition {\r\n    uint pid;\r\n    bool added; // To prevent duplicates.\r\n  }\r\n\r\n  IERC20 public rewardToken;\r\n  uint public rewardTokenPerBlock;\r\n\r\n  // Info of each pool.\r\n  PoolInfo[] public poolInfo;\r\n  // Info of each user that stakes LP tokens.\r\n  mapping (uint => mapping (address => UserInfo)) public userInfo;\r\n  mapping (address => PoolPosition) public pidByToken;\r\n  // Total allocation poitns. Must be the sum of all allocation points in all pools.\r\n  uint public totalAllocPoints;\r\n  // The block number when RewardToken mining starts.\r\n  uint public startBlock;\r\n\r\n  event Deposit(address indexed user, uint indexed pid, uint amount);\r\n  event Withdraw(address indexed user, uint indexed pid, uint amount);\r\n  event EmergencyWithdraw(address indexed user, uint indexed pid, uint amount);\r\n\r\n  event PoolUpdate(\r\n    address indexed lpToken,\r\n    uint    indexed pid,\r\n    uint            allocPoints,\r\n    bool    indexed withUpdate\r\n  );\r\n\r\n  constructor(\r\n    IERC20 _rewardToken,\r\n    uint _rewardTokenPerBlock,\r\n    uint _startBlock\r\n  ) {\r\n    rewardToken = _rewardToken;\r\n    rewardTokenPerBlock = _rewardTokenPerBlock;\r\n    startBlock = _startBlock;\r\n  }\r\n\r\n  function poolLength() external view returns (uint) {\r\n    return poolInfo.length;\r\n  }\r\n\r\n  // Add a new lp to the pool. Can only be called by the owner.\r\n  function add(address _lpToken, uint _allocPoints, bool _withUpdate) public onlyOwner {\r\n\r\n    require(pidByToken[_lpToken].added == false, \"MasterPool: already added\");\r\n\r\n    if (_withUpdate) {\r\n      massUpdatePools();\r\n    }\r\n\r\n    uint lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n    totalAllocPoints = totalAllocPoints + _allocPoints;\r\n    poolInfo.push(PoolInfo({\r\n      lpToken: IERC20(_lpToken),\r\n      allocPoints: _allocPoints,\r\n      lastRewardBlock: lastRewardBlock,\r\n      accRewardTokenPerShare: 0\r\n    }));\r\n\r\n    pidByToken[_lpToken] = PoolPosition({\r\n      pid: poolInfo.length - 1,\r\n      added: true\r\n    });\r\n\r\n    emit PoolUpdate(_lpToken, poolInfo.length - 1, _allocPoints, _withUpdate);\r\n  }\r\n\r\n  // Update the given pool's RewardToken allocation point. Can only be called by the owner.\r\n  function set(uint _pid, uint _allocPoints, bool _withUpdate) public onlyOwner {\r\n\r\n    if (_withUpdate) {\r\n      massUpdatePools();\r\n    }\r\n\r\n    totalAllocPoints = totalAllocPoints - poolInfo[_pid].allocPoints + _allocPoints;\r\n    poolInfo[_pid].allocPoints = _allocPoints;\r\n\r\n    emit PoolUpdate(address(poolInfo[_pid].lpToken), _pid, _allocPoints, _withUpdate);\r\n  }\r\n\r\n  // View function to see pending RewardTokens on frontend.\r\n  function pendingRewards(uint _pid, address _user) external view returns (uint) {\r\n\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    UserInfo storage user = userInfo[_pid][_user];\r\n    uint accRewardTokenPerShare = pool.accRewardTokenPerShare;\r\n    uint lpSupply = pool.lpToken.balanceOf(address(this));\r\n\r\n    if (block.number > pool.lastRewardBlock && lpSupply != 0) {\r\n      uint multiplier = block.number - pool.lastRewardBlock;\r\n      uint rewardTokenReward = multiplier * rewardTokenPerBlock * pool.allocPoints / totalAllocPoints;\r\n      accRewardTokenPerShare += rewardTokenReward * 1e12 / lpSupply;\r\n    }\r\n\r\n    return (user.amount * accRewardTokenPerShare / 1e12) - user.rewardDebt;\r\n  }\r\n\r\n  // Update reward vairables for all pools. Be careful of gas spending!\r\n  function massUpdatePools() public {\r\n      uint length = poolInfo.length;\r\n      for (uint pid = 0; pid < length; ++pid) {\r\n        updatePool(pid);\r\n      }\r\n  }\r\n\r\n  // Update reward variables of the given pool to be up-to-date.\r\n  function updatePool(uint _pid) public {\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    if (block.number <= pool.lastRewardBlock) {\r\n      return;\r\n    }\r\n    uint lpSupply = pool.lpToken.balanceOf(address(this));\r\n    if (lpSupply == 0) {\r\n      pool.lastRewardBlock = block.number;\r\n      return;\r\n    }\r\n    uint multiplier = block.number - pool.lastRewardBlock;\r\n    uint rewardTokenReward = multiplier * rewardTokenPerBlock * pool.allocPoints / totalAllocPoints;\r\n    pool.accRewardTokenPerShare += rewardTokenReward * 1e12 / lpSupply;\r\n    pool.lastRewardBlock = block.number;\r\n  }\r\n\r\n  function deposit(uint _pid, uint _amount) public {\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    UserInfo storage user = userInfo[_pid][msg.sender];\r\n    updatePool(_pid);\r\n\r\n    if (user.amount > 0) {\r\n      uint pending = (user.amount * pool.accRewardTokenPerShare / 1e12) - user.rewardDebt;\r\n      safeRewardTokenTransfer(msg.sender, pending);\r\n    }\r\n\r\n    pool.lpToken.transferFrom(address(msg.sender), address(this), _amount);\r\n    user.amount += _amount;\r\n    user.rewardDebt = user.amount * pool.accRewardTokenPerShare / 1e12;\r\n    emit Deposit(msg.sender, _pid, _amount);\r\n  }\r\n\r\n  function withdraw(uint _pid, uint _amount) public {\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    UserInfo storage user = userInfo[_pid][msg.sender];\r\n    require(user.amount >= _amount, \"MasterPool: user.amount >= _amount\");\r\n    updatePool(_pid);\r\n    uint pending = (user.amount * pool.accRewardTokenPerShare / 1e12) - user.rewardDebt;\r\n    safeRewardTokenTransfer(msg.sender, pending);\r\n    user.amount = user.amount - _amount;\r\n    user.rewardDebt = user.amount * pool.accRewardTokenPerShare / 1e12;\r\n    pool.lpToken.transfer(address(msg.sender), _amount);\r\n    emit Withdraw(msg.sender, _pid, _amount);\r\n  }\r\n\r\n  function emergencyWithdraw(uint _pid) public {\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    UserInfo storage user = userInfo[_pid][msg.sender];\r\n    pool.lpToken.transfer(address(msg.sender), user.amount);\r\n    emit EmergencyWithdraw(msg.sender, _pid, user.amount);\r\n    user.amount = 0;\r\n    user.rewardDebt = 0;\r\n  }\r\n\r\n  // Allows to migrate rewards to a new staking contract.\r\n  function migrateRewards(address _recipient, uint _amount) public onlyOwner {\r\n    rewardToken.transfer(_recipient, _amount);\r\n  }\r\n\r\n  // Safe rewardToken transfer function, just in case if rounding error causes pool to not have enough RewardTokens.\r\n  function safeRewardTokenTransfer(address _to, uint _amount) internal {\r\n    uint rewardTokenBal = rewardToken.balanceOf(address(this));\r\n    if (_amount > rewardTokenBal) {\r\n      rewardToken.transfer(_to, rewardTokenBal);\r\n    } else {\r\n      rewardToken.transfer(_to, _amount);\r\n    }\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardTokenPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoints\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"withUpdate\",\"type\":\"bool\"}],\"name\":\"PoolUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoints\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"migrateRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pidByToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"added\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardTokenPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokenPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoints\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MasterPool","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000008a75dbc7167714ceac1a8e43a8d643a4edd625a00000000000000000000000000000000000000000000000104e70464b15800000000000000000000000000000000000000000000000000000000000000bec2e0","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3cc8a8e3f2260cf98c2d57cc27f792ba95d0e8534490cba845d8f74ab06237ba"}]}