{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libs/NFTDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title A library used to construct ERC721 token URIs and SVG images\\n\\n/*********************************\\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\\n * ░░░░░░▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒░░░ *\\n * ░░░░░░▒▒░░░▒▒▒▒░░▒▒░░░▒▒▒▒░░░ *\\n * ░░▒▒▒▒▒▒░░░▒▒▒▒▒▒▒▒░░░▒▒▒▒░░░ *\\n * ░░▒▒░░▒▒░░░▒▒▒▒░░▒▒░░░▒▒▒▒░░░ *\\n * ░░▒▒░░▒▒░░░▒▒▒▒░░▒▒░░░▒▒▒▒░░░ *\\n * ░░░░░░▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒░░░ *\\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Base64 } from 'base64-sol/base64.sol';\\nimport { MultiPartRLEToSVG } from './MultiPartRLEToSVG.sol';\\n\\nlibrary NFTDescriptor {\\n    struct TokenURIParams {\\n        string name;\\n        string description;\\n        bytes[] parts;\\n        string background;\\n    }\\n\\n    /**\\n     * @notice Construct an ERC721 token URI.\\n     */\\n    function constructTokenURI(TokenURIParams memory params, mapping(uint8 => string[]) storage palettes)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        string memory image = generateSVGImage(\\n            MultiPartRLEToSVG.SVGParams({ parts: params.parts, background: params.background }),\\n            palettes\\n        );\\n\\n        // prettier-ignore\\n        return string(\\n            abi.encodePacked(\\n                'data:application/json;base64,',\\n                Base64.encode(\\n                    bytes(\\n                        abi.encodePacked('{\\\"name\\\":\\\"', params.name, '\\\", \\\"description\\\":\\\"', params.description, '\\\", \\\"image\\\": \\\"', 'data:image/svg+xml;base64,', image, '\\\"}')\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Generate an SVG image for use in the ERC721 token URI.\\n     */\\n    function generateSVGImage(MultiPartRLEToSVG.SVGParams memory params, mapping(uint8 => string[]) storage palettes)\\n        public\\n        view\\n        returns (string memory svg)\\n    {\\n        return Base64.encode(bytes(MultiPartRLEToSVG.generateSVG(params, palettes)));\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides a function for encoding some bytes in base64\\nlibrary Base64 {\\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n        \\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n            \\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n            \\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n            \\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n            \\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               dataPtr := add(dataPtr, 3)\\n               \\n               // read 3 bytes\\n               let input := mload(dataPtr)\\n               \\n               // write 4 characters\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\\n               resultPtr := add(resultPtr, 1)\\n            }\\n            \\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/MultiPartRLEToSVG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title A library used to convert multi-part RLE compressed images to SVG\\n\\n/*********************************\\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\\n * ░░░░░░▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒░░░ *\\n * ░░░░░░▒▒░░░▒▒▒▒░░▒▒░░░▒▒▒▒░░░ *\\n * ░░▒▒▒▒▒▒░░░▒▒▒▒▒▒▒▒░░░▒▒▒▒░░░ *\\n * ░░▒▒░░▒▒░░░▒▒▒▒░░▒▒░░░▒▒▒▒░░░ *\\n * ░░▒▒░░▒▒░░░▒▒▒▒░░▒▒░░░▒▒▒▒░░░ *\\n * ░░░░░░▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒░░░ *\\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nlibrary MultiPartRLEToSVG {\\n    struct SVGParams {\\n        bytes[] parts;\\n        string background;\\n    }\\n\\n    struct ContentBounds {\\n        uint8 top;\\n        uint8 right;\\n        uint8 bottom;\\n        uint8 left;\\n    }\\n\\n    struct Rect {\\n        uint8 length;\\n        uint8 colorIndex;\\n    }\\n\\n    struct DecodedImage {\\n        uint8 paletteIndex;\\n        ContentBounds bounds;\\n        uint256 width;\\n        Rect[] rects;\\n    }\\n\\n    /**\\n     * @notice Given RLE image parts and color palettes, merge to generate a single SVG image.\\n     */\\n    function generateSVG(SVGParams memory params, mapping(uint8 => string[]) storage palettes)\\n        internal\\n        view\\n        returns (string memory svg)\\n    {\\n        // prettier-ignore\\n        return string(\\n            abi.encodePacked(\\n                '<svg width=\\\"320\\\" height=\\\"320\\\" viewBox=\\\"0 0 320 320\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" shape-rendering=\\\"crispEdges\\\">',\\n                '<rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"#', params.background, '\\\" />',\\n                _generateSVGRects(params, palettes),\\n                '</svg>'\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Given RLE image parts and color palettes, generate SVG rects.\\n     */\\n    // prettier-ignore\\n    function _generateSVGRects(SVGParams memory params, mapping(uint8 => string[]) storage palettes)\\n        private\\n        view\\n        returns (string memory svg)\\n    {\\n        string[33] memory lookup = [\\n            '0', '10', '20', '30', '40', '50', '60', '70', \\n            '80', '90', '100', '110', '120', '130', '140', '150', \\n            '160', '170', '180', '190', '200', '210', '220', '230', \\n            '240', '250', '260', '270', '280', '290', '300', '310',\\n            '320' \\n        ];\\n        string memory rects;\\n        for (uint8 p = 0; p < params.parts.length; p++) {\\n            DecodedImage memory image = _decodeRLEImage(params.parts[p]);\\n            string[] storage palette = palettes[image.paletteIndex];\\n            uint256 currentX = image.bounds.left;\\n            uint256 currentY = image.bounds.top;\\n            uint256 cursor;\\n            string[16] memory buffer;\\n\\n            string memory part;\\n            for (uint256 i = 0; i < image.rects.length; i++) {\\n                Rect memory rect = image.rects[i];\\n                if (rect.colorIndex != 0) {\\n                    buffer[cursor] = lookup[rect.length];          // width\\n                    buffer[cursor + 1] = lookup[currentX];         // x\\n                    buffer[cursor + 2] = lookup[currentY];         // y\\n                    buffer[cursor + 3] = palette[rect.colorIndex]; // color\\n\\n                    cursor += 4;\\n\\n                    if (cursor >= 16) {\\n                        part = string(abi.encodePacked(part, _getChunk(cursor, buffer)));\\n                        cursor = 0;\\n                    }\\n                }\\n\\n                currentX += rect.length;\\n                if (currentX - image.bounds.left == image.width) {\\n                    currentX = image.bounds.left;\\n                    currentY++;\\n                }\\n            }\\n\\n            if (cursor != 0) {\\n                part = string(abi.encodePacked(part, _getChunk(cursor, buffer)));\\n            }\\n            rects = string(abi.encodePacked(rects, part));\\n        }\\n        return rects;\\n    }\\n\\n    /**\\n     * @notice Return a string that consists of all rects in the provided `buffer`.\\n     */\\n    // prettier-ignore\\n    function _getChunk(uint256 cursor, string[16] memory buffer) private pure returns (string memory) {\\n        string memory chunk;\\n        for (uint256 i = 0; i < cursor; i += 4) {\\n            chunk = string(\\n                abi.encodePacked(\\n                    chunk,\\n                    '<rect width=\\\"', buffer[i], '\\\" height=\\\"10\\\" x=\\\"', buffer[i + 1], '\\\" y=\\\"', buffer[i + 2], '\\\" fill=\\\"#', buffer[i + 3], '\\\" />'\\n                )\\n            );\\n        }\\n        return chunk;\\n    }\\n\\n    /**\\n     * @notice Decode a single RLE compressed image into a `DecodedImage`.\\n     */\\n    function _decodeRLEImage(bytes memory image) private pure returns (DecodedImage memory) {\\n        uint8 paletteIndex = uint8(image[0]);\\n        ContentBounds memory bounds = ContentBounds({\\n            top: uint8(image[1]),\\n            right: uint8(image[2]),\\n            bottom: uint8(image[3]),\\n            left: uint8(image[4])\\n        });\\n        uint256 width = bounds.right - bounds.left;\\n\\n        uint256 cursor;\\n        Rect[] memory rects = new Rect[]((image.length - 5) / 2);\\n        for (uint256 i = 5; i < image.length; i += 2) {\\n            rects[cursor] = Rect({ length: uint8(image[i]), colorIndex: uint8(image[i + 1]) });\\n            cursor++;\\n        }\\n        return DecodedImage({ paletteIndex: paletteIndex, bounds: bounds, width: width, rects: rects });\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[]","ContractName":"NFTDescriptor","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}