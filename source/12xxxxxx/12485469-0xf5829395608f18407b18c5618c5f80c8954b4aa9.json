{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/utils/Address.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SafeMath.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/TokenPool.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title A simple holder of tokens.\r\n * This is a simple contract to hold tokens. It's useful in the case where a separate contract\r\n * needs to hold multiple distinct pools of the same token.\r\n */\r\ncontract TokenPool {\r\n    IUniswapV2Router02 public uniswapRouterV2;\r\n    IUniswapV2Factory public uniswapFactory;\r\n    address public rptContract;\r\n\r\n    constructor() public {\r\n      uniswapRouterV2 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n      uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n      rptContract = 0xa0Bb0027C28ade4Ac628b7f81e7b93Ec71b4E020;\r\n    }\r\n\r\n    function balance(address token) public view returns (uint256) {\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function () external payable {}\r\n\r\n\r\n    function swapETHForRPT() external {\r\n        if(address(this).balance > 0) {\r\n          address[] memory uniswapPairPath = new address[](2);\r\n          uniswapPairPath[0] = rptContract; // RPT contract address\r\n          uniswapPairPath[1] = uniswapRouterV2.WETH(); // weth address\r\n\r\n          uniswapRouterV2.swapExactETHForTokensSupportingFeeOnTransferTokens.value(address(this).balance)(\r\n                  0,\r\n                  uniswapPairPath,\r\n                  address(this),\r\n                  block.timestamp\r\n              );\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )  external payable;\r\n}\r\n\r\n// File: contracts/RugProofMaster.sol\r\n\r\n/*\r\nRug Proof Master Contract\r\n\r\nWebsite: rugproof.io\r\n\r\nThe Rug Proof Master Contract is an experimental rug proof token sale platform.\r\n\r\nThis contract allows token sellers to predefine liquidity % amounts that are validated and trustless.\r\nThis allows buyers of the token sale to have confidence in what they are buying, as it ensures liquidity gets locked.\r\n\r\nA 1% platform tax is applied which market buys RPT and locks it into the burn pool.\r\n\r\nAt the end of a successful sale, any remaining tokens are sent to the burn pool.\r\n\r\nIf a sale does not meet its softcap after the end time, users can get their ETH refund minus the 1% platform tax.\r\n*/\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\ncontract RugProofMaster {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    struct SaleInfo {\r\n      address contractAddress; // address of the token\r\n      address payable receiveAddress; // address to receive ETH\r\n      uint256 tokenAmount; // amount of tokens to sell\r\n      uint256 tokenRatio; // ratio of ETH to token\r\n      uint256 totalEth; // total eth currently raised\r\n      uint256 softcap; // amount of ETH we need to set this as a success\r\n      uint32 counter; // amount of buyers\r\n      uint32 timestampStartSec; // unix second start\r\n      uint32 timestampEndSec; // unix second end\r\n      uint8 liquidityLockPercent; // 20 = 20%, capped at 100%, intervals of 1%\r\n      bool isEnded; // signals the end of this sale\r\n      bool isSuccess; // if false, users can claim their eth back\r\n      mapping(address => uint256) ethContributed; // amount of eth contributed per address\r\n    }\r\n\r\n    SaleInfo[] public tokenSales;\r\n\r\n    IUniswapV2Router02 public uniswapRouterV2;\r\n    IUniswapV2Factory public uniswapFactory;\r\n\r\n    //inaccessible contract that stores funds\r\n    //cannot use 0 address because some tokens prohibit it without a burn function\r\n    TokenPool public burnPool;\r\n\r\n    // address for the RPT token\r\n    address public rptContract;\r\n\r\n    // Amount of wei raised in this contracts lifetime\r\n    uint256 public _weiRaised;\r\n\r\n    uint256 public rptTax;\r\n\r\n    address public owner;\r\n\r\n    bool private _notEntered;\r\n\r\n    mapping(address => bool) public contractVerified;\r\n\r\n    event LogCreateNewSale(address _contract, uint256 _tokenAmount);\r\n    event LogContractVerified(address _contract, bool _verified);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"RugProofMaster::OnlyOwner: Not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        _notEntered = true;\r\n    }\r\n\r\n    function initialize() public {\r\n        require(owner == address(0x0), \"RugProofMaster::Initialize: Already initialized\");\r\n\r\n        uniswapRouterV2 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n        rptContract = 0xa0Bb0027C28ade4Ac628b7f81e7b93Ec71b4E020;\r\n\r\n        burnPool = new TokenPool();\r\n        rptTax = 1;\r\n        owner = msg.sender;\r\n\r\n        _notEntered = true;\r\n    }\r\n\r\n    function setContractVerified(address _verified, bool _isVerified) external onlyOwner {\r\n        contractVerified[_verified] = _isVerified;\r\n        emit LogContractVerified(_verified, _isVerified);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the % tax for each purchase. This tax sends market buys and burns RPT\r\n     *\r\n     */\r\n    function setTax(uint256 _rptTax) public onlyOwner {\r\n        require(_rptTax <= 100, \"RugProofMaster::setTax: tax is too high\");\r\n        rptTax = _rptTax;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Creates a token sale with a timer.\r\n     *\r\n     *      _contractAddress: contract of the token being sold\r\n     *      _tokenAmount: amount of tokens being sold\r\n     *      _tokenRatio: price of the token vs ETH i.e. 1e9 and a user buys 0.5 ETH worth => tokenRatio * ETHAmount / ETH Decimals = (1e9 * 0.5e18)/1e18\r\n     *      _timestampStartSec: unix time in seconds when the sale starts\r\n     *      _timestampStartSec: unix time in seconds when the sale ends\r\n     *      _liquidityLockPercent: % of the sale that should go to locked ETH liquidity i.e. 50 => 50%. Capped at 100, increments of 1%\r\n     *      _softcap: ETH amount that is needed for the sale to be a success\r\n     */\r\n    function createNewTokenSale(\r\n      address _contractAddress, uint256 _tokenAmount,\r\n      uint256 _tokenRatio, uint32 _timestampEndSec,\r\n      uint8 _liquidityLockPercent, uint256 _softcap, bool wantVerified) external payable {\r\n\r\n        require(_contractAddress != address(0), \"CreateNewTokenSale: Cannot use the zero address\");\r\n        require(msg.sender != address(this), \"CreateNewTokenSale: Cannot call from this contract\");\r\n        require(_tokenAmount != 0, \"CreateNewTokenSale: Cannot sell zero tokens\");\r\n        require(_tokenRatio != 0, \"CreateNewTokenSale: Cannot have a zero ratio\");\r\n        require(_softcap != 0, \"CreateNewTokenSale: Cannot have a zero softcap\");\r\n        require(_timestampEndSec > now, \"CreateNewTokenSale: Cannot start sale after end time\");\r\n        require(_liquidityLockPercent <= 100, \"CreateNewTokenSale: Cannot have higher than 100% liquidity lock\");\r\n\r\n        if(wantVerified == true){\r\n          require(msg.value == 2e18, \"createNewTokenSale::wantVerified: msg.value is must be 2 ETH\");\r\n          address(owner).toPayable().transfer(2e18);\r\n        }\r\n\r\n        // check how many tokens we receive\r\n        // this is an important step to ensure we log proper amounts if this is a deflationary token\r\n        // approve must be called before this function is executed. Need to approve this contract address to send the token amount\r\n        uint256 tokenBalanceBeforeTransfer = IERC20(_contractAddress).balanceOf(address(this));\r\n        IERC20(_contractAddress).transferFrom(address(msg.sender), address(this), _tokenAmount);\r\n        uint256 tokensReceived = IERC20(_contractAddress).balanceOf(address(this)).sub(tokenBalanceBeforeTransfer);\r\n\r\n\r\n        SaleInfo memory saleInfo = SaleInfo(\r\n          _contractAddress, msg.sender, tokensReceived, _tokenRatio, 0, _softcap,\r\n          0, uint32(now), _timestampEndSec, _liquidityLockPercent, false, false\r\n          );\r\n\r\n        tokenSales.push(saleInfo);\r\n        emit LogCreateNewSale(_contractAddress, _tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Enabled ability for tokens to be withdrawn by buyers after the sale has ended successfully.\r\n                     On a successful sale (softcap reached by time, or hardcap reached), this function:\r\n                     1. Creates uniswap pair if not created.\r\n                     2. adds token liquidity to uniswap pair.\r\n                     3. burns tokens if hardcap was not met\r\n     *\r\n     *      contractIndex: index of the token sale. See tokenSales variable\r\n     *\r\n     */\r\n    function endTokenSale(uint256 contractIndex) external {\r\n        SaleInfo storage tokenSaleInfo = tokenSales[contractIndex];\r\n\r\n        uint256 hardcapETH = tokenSaleInfo.tokenAmount.mul(1e18).div(tokenSaleInfo.tokenRatio);\r\n\r\n        //require(tokenSaleInfo.receiveAddress == msg.sender, \"endTokenSale: can only be called by funding owner\");\r\n        require(tokenSaleInfo.isEnded == false, \"endTokenSale: token sale has ended already\");\r\n        require(block.timestamp > tokenSaleInfo.timestampEndSec || tokenSaleInfo.totalEth >= hardcapETH , \"endTokenSale: token sale is not over yet\");\r\n        require(IERC20(tokenSaleInfo.contractAddress).balanceOf(address(this)) >= tokenSaleInfo.tokenAmount,  \"endTokenSale: contract does not have enough tokens\");\r\n\r\n        // flag that allows ends this funding round\r\n        // also allows token withdrawals and refunds if failed\r\n        tokenSaleInfo.isEnded = true;\r\n\r\n        // sale was a success if we hit the softcap\r\n        if(tokenSaleInfo.totalEth >= tokenSaleInfo.softcap){\r\n          tokenSaleInfo.isSuccess = true;\r\n\r\n          uint256 saleEthToLock = tokenSaleInfo.totalEth.mul(tokenSaleInfo.liquidityLockPercent).div(100);\r\n          uint256 saleEthToUnlock = tokenSaleInfo.totalEth.sub(saleEthToLock);\r\n\r\n          uint256 tokenAmountToLock = saleEthToLock.mul(tokenSaleInfo.tokenRatio).div(1e18);\r\n          uint256 tokenAmountToUnlock = saleEthToUnlock.mul(tokenSaleInfo.tokenRatio).div(1e18);\r\n\r\n          // send the ETH to the owner of the sale so they can pay for the uniswap pair\r\n          tokenSaleInfo.receiveAddress.transfer(saleEthToUnlock);\r\n\r\n          // create uniswap pair\r\n          createUniswapPairMainnet(tokenSaleInfo.contractAddress);\r\n\r\n          // burn the rest of the tokens if there are any left\r\n          uint256 tokenAmountToBurn = tokenSaleInfo.tokenAmount.sub(tokenAmountToLock).sub(tokenAmountToUnlock);\r\n\r\n          if(tokenAmountToBurn > 0){\r\n            IERC20(tokenSaleInfo.contractAddress).transfer(address(burnPool), tokenAmountToBurn);\r\n          }\r\n\r\n          // add liquidity to uniswap pair\r\n          addLiquidity(tokenSaleInfo.contractAddress, tokenAmountToLock, saleEthToLock);\r\n\r\n        } else {\r\n          tokenSaleInfo.isSuccess = false;\r\n          // transfer the token amount from this address back to the owner\r\n          IERC20(tokenSaleInfo.contractAddress).transfer(tokenSaleInfo.receiveAddress, tokenSaleInfo.tokenAmount);\r\n        }\r\n\r\n        burnPool.swapETHForRPT();\r\n    }\r\n\r\n    function _overrideEndTokenSale(uint256 contractIndex) external onlyOwner {\r\n        SaleInfo storage tokenSaleInfo = tokenSales[contractIndex];\r\n\r\n        require(tokenSaleInfo.isEnded == false, \"endTokenSale: token sale has ended already\");\r\n        tokenSaleInfo.isEnded = true;\r\n\r\n        tokenSaleInfo.isSuccess = false;\r\n        // transfer the token amount from this address back to the owner\r\n        IERC20(tokenSaleInfo.contractAddress).transfer(tokenSaleInfo.receiveAddress, tokenSaleInfo.tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Buys tokens from the token sale from the function caller. A tax is applied here based on the rptTax.\r\n     *               ETH tax is sent to the burn pool which can be used to market buy RPT. This is nonrefundable\r\n     *\r\n     *               Prevents users from buying in if the hardcap is met, or if the sale is expired.\r\n     *\r\n     *      contractIndex: index of the token sale. See tokenSales variable\r\n     *\r\n     */\r\n    function buyTokens(uint256 contractIndex) external payable nonReentrant{\r\n      require(msg.value != 0, \"buyTokens: msg.value is 0\");\r\n\r\n      uint256 weiAmount = msg.value;\r\n      uint256 weiAmountTax = weiAmount.mul(rptTax).div(100);\r\n\r\n      SaleInfo storage tokenSaleInfo = tokenSales[contractIndex];\r\n\r\n      // make sure this sale exists\r\n      require(tokenSales.length > contractIndex, \"buyTokens: no token sale for this index\");\r\n\r\n      // make sure we are not raising too much ETH\r\n      uint256 hardcapETH = tokenSaleInfo.tokenAmount.mul(1e18).div(tokenSaleInfo.tokenRatio);\r\n\r\n      require(hardcapETH > tokenSaleInfo.totalEth, \"buyTokens: Sale has reached hardcap\");\r\n      // make sure this sale is not over\r\n      require(tokenSaleInfo.timestampEndSec > block.timestamp && tokenSaleInfo.isEnded == false, \"buyTokens: Token sale is over\");\r\n\r\n      //refund overflow\r\n      if(hardcapETH > tokenSaleInfo.totalEth.add(weiAmount)){\r\n        uint256 refundAmount = tokenSaleInfo.totalEth.add(weiAmount).sub(hardcapETH);\r\n        address(msg.sender).transfer(refundAmount);\r\n      }\r\n\r\n      // log raised eth, only can buy what the final payment is (minus the rpt tax)\r\n      tokenSaleInfo.ethContributed[msg.sender] = tokenSaleInfo.ethContributed[msg.sender].add(weiAmount.sub(weiAmountTax));\r\n      tokenSaleInfo.totalEth = tokenSaleInfo.totalEth.add(weiAmount.sub(weiAmountTax));\r\n\r\n      // increment buyer\r\n      tokenSaleInfo.counter++;\r\n\r\n      // log global raised amount\r\n      _weiRaised = _weiRaised.add(weiAmount);\r\n\r\n      // send eth to burn pool to marketbuy later\r\n      address(burnPool).transfer(weiAmountTax);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws tokens the are bought from the sale if the message sender has any.\r\n     *\r\n     *\r\n     *      contractIndex: index of the token sale. See tokenSales variable\r\n     *\r\n     */\r\n    function claimTokens(uint256 contractIndex) external {\r\n      require(tokenSales.length > contractIndex, \"claimTokens: no available token sale\");\r\n\r\n      SaleInfo storage tokenSaleInfo = tokenSales[contractIndex];\r\n      require(tokenSaleInfo.isEnded == true, \"claimTokens: token sale has not ended\");\r\n      require(tokenSaleInfo.isSuccess == true, \"claimTokens: token sale was not successful\");\r\n      require(tokenSaleInfo.ethContributed[msg.sender] > 0, \"claimTokens: address contributed nothing\");\r\n\r\n      uint256 tokenAmountToSend = tokenSaleInfo.ethContributed[msg.sender].mul(tokenSaleInfo.tokenRatio).div(1e18);\r\n\r\n      // prevent caller from re-entering\r\n      tokenSaleInfo.ethContributed[msg.sender] = 0;\r\n\r\n      IERC20(tokenSaleInfo.contractAddress).transfer(address(msg.sender), tokenAmountToSend);\r\n    }\r\n\r\n    /**\r\n     * @dev If a sale was not successful, allows users to withdraw their ETH from the sale minus the tax amount\r\n     *\r\n     *\r\n     *      contractIndex: index of the token sale. See tokenSales variable\r\n     *\r\n     */\r\n    function withdrawRefundedETH(uint256 contractIndex) external {\r\n      require(tokenSales.length > contractIndex, \"withdrawRefundedETH: no available token sale\");\r\n\r\n      SaleInfo storage tokenSaleInfo = tokenSales[contractIndex];\r\n      // allow refunds when sale is over and was not a success\r\n      if(tokenSaleInfo.isEnded == true && tokenSaleInfo.isSuccess == false && tokenSaleInfo.ethContributed[msg.sender] > 0){\r\n        //refund eth back to msgOwner\r\n        address(msg.sender).transfer(tokenSaleInfo.ethContributed[msg.sender]);\r\n        // set eth contributed to this sale as 0\r\n        tokenSaleInfo.ethContributed[msg.sender] = 0;\r\n      }\r\n    }\r\n\r\n\r\n    function getTokenSalesOne() public view returns (address[] memory, address[] memory, uint256[] memory, uint256[] memory)\r\n    {\r\n      address[] memory contractAddresses = new address[](tokenSales.length);\r\n      address[] memory receiveAddresses = new address[](tokenSales.length);\r\n      uint256[] memory tokenAmounts = new uint256[](tokenSales.length);\r\n      uint256[] memory tokenRatios = new uint256[](tokenSales.length);\r\n\r\n      for (uint i = 0; i < tokenSales.length; i++) {\r\n          SaleInfo storage saleInfo = tokenSales[i];\r\n          contractAddresses[i] = saleInfo.contractAddress;\r\n          receiveAddresses[i] = saleInfo.receiveAddress;\r\n          tokenAmounts[i] = saleInfo.tokenAmount;\r\n          tokenRatios[i] = saleInfo.tokenRatio;\r\n      }\r\n\r\n      return (contractAddresses, receiveAddresses, tokenAmounts, tokenRatios);\r\n    }\r\n    function getTokenSalesTwo() public view returns (uint32[] memory, uint32[] memory, uint8[] memory, uint256[] memory)\r\n    {\r\n      uint32[] memory timestampStartSec = new uint32[](tokenSales.length);\r\n      uint32[] memory timestampEndSec = new uint32[](tokenSales.length);\r\n      uint8[] memory liquidityLockPercents = new uint8[](tokenSales.length);\r\n      uint256[] memory totalEths = new uint256[](tokenSales.length);\r\n\r\n      for (uint i = 0; i < tokenSales.length; i++) {\r\n          SaleInfo storage saleInfo = tokenSales[i];\r\n          timestampStartSec[i] = saleInfo.timestampStartSec;\r\n          timestampEndSec[i] = saleInfo.timestampEndSec;\r\n          liquidityLockPercents[i] = saleInfo.liquidityLockPercent;\r\n          totalEths[i] = saleInfo.totalEth;\r\n      }\r\n\r\n      return (timestampStartSec, timestampEndSec, liquidityLockPercents, totalEths);\r\n    }\r\n    function getTokenSalesThree() public view returns (bool[] memory, bool[] memory, uint256[] memory, uint32[] memory, uint256[] memory)\r\n    {\r\n      bool[] memory isEnded = new bool[](tokenSales.length);\r\n      bool[] memory isSuccess = new bool[](tokenSales.length);\r\n      uint256[] memory softcaps = new uint256[](tokenSales.length);\r\n      uint32[] memory counters = new uint32[](tokenSales.length);\r\n      uint256[] memory contributions = new uint256[](tokenSales.length);\r\n\r\n      for (uint i = 0; i < tokenSales.length; i++) {\r\n          SaleInfo storage saleInfo = tokenSales[i];\r\n          isEnded[i] = saleInfo.isEnded;\r\n          isSuccess[i] = saleInfo.isSuccess;\r\n          softcaps[i] = saleInfo.softcap;\r\n          counters[i] = saleInfo.counter;\r\n          contributions[i] = saleInfo.ethContributed[msg.sender];\r\n      }\r\n\r\n      return (isEnded, isSuccess, softcaps, counters, contributions);\r\n    }\r\n\r\n    function getContribution(uint contractIndex) public view returns (uint256){\r\n      require(tokenSales.length > contractIndex, \"withdrawRefundedETH: no available token sale\");\r\n\r\n      uint256 ethContributed = tokenSales[contractIndex].ethContributed[msg.sender];\r\n\r\n      return (ethContributed);\r\n    }\r\n\r\n    function createUniswapPairMainnet(address _contractAddress) internal returns (bool) {\r\n        require(_contractAddress != address(0), \"CreateUniswapPairMainnet: cannot create uniswap pair for zero address\");\r\n        address pairAddress = uniswapFactory.getPair(_contractAddress, address(uniswapRouterV2.WETH()));\r\n\r\n        // zero address means this pair has not been created, we need to create it\r\n        if(pairAddress == address(0)){\r\n          address tokenUniswapPair = uniswapFactory.createPair( address(uniswapRouterV2.WETH()), _contractAddress);\r\n\r\n          require(tokenUniswapPair != address(0), \"createUniswapPairMainnet: issue creating pair\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function addLiquidity(address contractAddress, uint256 tokenAmount, uint256 ethAmount) internal {\r\n        // need to approve the token movement\r\n        IERC20(contractAddress).approve(address(uniswapRouterV2), tokenAmount);\r\n\r\n        // transfer lp tokens directly into burn pool\r\n        uniswapRouterV2.addLiquidityETH.value(ethAmount)(\r\n                contractAddress,\r\n                tokenAmount,\r\n                0,\r\n                0,\r\n                address(burnPool),\r\n                block.timestamp\r\n            );\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_verified\",\"type\":\"bool\"}],\"name\":\"LogContractVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"LogCreateNewSale\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contractIndex\",\"type\":\"uint256\"}],\"name\":\"_overrideEndTokenSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_weiRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnPool\",\"outputs\":[{\"internalType\":\"contract TokenPool\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contractIndex\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contractIndex\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_timestampEndSec\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"_liquidityLockPercent\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_softcap\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wantVerified\",\"type\":\"bool\"}],\"name\":\"createNewTokenSale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contractIndex\",\"type\":\"uint256\"}],\"name\":\"endTokenSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contractIndex\",\"type\":\"uint256\"}],\"name\":\"getContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenSalesOne\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenSalesThree\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenSalesTwo\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rptContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rptTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verified\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isVerified\",\"type\":\"bool\"}],\"name\":\"setContractVerified\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rptTax\",\"type\":\"uint256\"}],\"name\":\"setTax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSales\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"receiveAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"softcap\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"counter\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timestampStartSec\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timestampEndSec\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"liquidityLockPercent\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSuccess\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapRouterV2\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"contractIndex\",\"type\":\"uint256\"}],\"name\":\"withdrawRefundedETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RugProofMaster","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"petersburg","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://8f52a20439b4b5c822dae3980f7abba369063031fe5f49a398c116f3db7cc7d8"}]}