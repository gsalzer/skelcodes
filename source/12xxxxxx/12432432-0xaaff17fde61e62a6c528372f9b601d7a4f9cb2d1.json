{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/callManagers/PangolinRebalanceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.1;\\n\\nimport {\\n    IPangolinRouter\\n} from \\\"@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../interfaces/IExperiPie.sol\\\";\\nimport \\\"../interfaces/IPangolinRebalanceManager.sol\\\";\\n\\ncontract PangolinRebalanceManager is IPangolinRebalanceManager {\\n    IExperiPie public immutable basket;\\n    IPangolinRouter public immutable pangolin;\\n    address public rebalanceManager; \\n    IERC20 private immutable nativeToken;\\n\\n    event Rebalanced(address indexed basket);\\n    event Swaped(\\n        address indexed basket,\\n        address indexed fromToken,\\n        address indexed toToken,\\n        uint256 quantity,\\n        uint256 returnedQuantity\\n    );\\n    event RebalanceManagerSet(address indexed rebalanceManager);\\n\\n    constructor(address _basket, address _pangolin, address _nativeToken) {\\n        require(_basket != address(0), \\\"INVALID_BASKET\\\");\\n        require(_pangolin != address(0), \\\"INVALID_PANGOLIN\\\");\\n        require(_nativeToken != address(0), \\\"INVALID_NATIVE_TOKEN\\\");\\n\\n        basket = IExperiPie(_basket);\\n        pangolin = IPangolinRouter(_pangolin);\\n        rebalanceManager = msg.sender;\\n        nativeToken = IERC20(_nativeToken);\\n    }\\n\\n    modifier onlyRebalanceManager() {\\n        require(\\n            msg.sender == rebalanceManager, \\\"NOT_ALLOWED\\\"\\n        );\\n        _;\\n    }\\n\\n    function setRebalanceManager(address _rebalanceManager) external onlyRebalanceManager {\\n        rebalanceManager = _rebalanceManager;\\n        emit RebalanceManagerSet(_rebalanceManager);\\n    }\\n\\n    function _swap(\\n        address fromToken,\\n        address toToken,\\n        uint256 quantity,\\n        uint256 minReturn,\\n        address recipient,\\n        uint256 deadline\\n    ) internal {\\n        // approve fromToken to pangolin\\n        // IERC20(fromToken).approve(address(pangolin), uint256(-1));\\n        if(IERC20(fromToken).allowance(address(basket), address(pangolin)) < quantity){\\n            basket.singleCall(\\n                fromToken,\\n                abi.encodeWithSelector(\\n                    IERC20(fromToken).approve.selector,\\n                    address(pangolin),\\n                    uint256(-1)\\n                ),\\n                0\\n            );\\n        }\\n\\n        // Swap on pangolin\\n        // pangolin.swapExactTokensForTokens(amount, minReturnAmount, path, recipient, deadline);\\n        address[] memory path = new address[](3);\\n        path[0] = fromToken;\\n        path[1] = address(nativeToken);\\n        path[2] = toToken;\\n        basket.singleCall(\\n            address(pangolin),\\n            abi.encodeWithSelector(\\n                pangolin.swapExactTokensForTokens.selector,\\n                quantity,\\n                minReturn,\\n                path,\\n                recipient,\\n                deadline\\n            ),\\n            0\\n        );\\n\\n        emit Swaped(address(basket), fromToken, toToken, quantity, minReturn);\\n    }\\n\\n    function removeToken(address _token) internal {\\n        uint256 balance = basket.balance(_token);\\n        bool inPool = basket.getTokenInPool(_token);\\n        //if there is a token balance of the token is not in the pool, skip\\n        if (balance != 0 || !inPool) {\\n            return;\\n        }\\n\\n        // remove token\\n        basket.singleCall(\\n            address(basket),\\n            abi.encodeWithSelector(basket.removeToken.selector, _token),\\n            0\\n        );\\n    }\\n\\n    function addToken(address _token) internal {\\n        uint256 balance = basket.balance(_token);\\n        bool inPool = basket.getTokenInPool(_token);\\n        // If token has no balance or is already in the pool, skip\\n        if (balance == 0 || inPool) {\\n            return;\\n        }\\n\\n        // add token\\n        basket.singleCall(\\n            address(basket),\\n            abi.encodeWithSelector(basket.addToken.selector, _token),\\n            0\\n        );\\n    }\\n\\n    function lockBasketData(uint256 _block)\\n        internal\\n        returns (bytes memory data)\\n    {\\n        basket.singleCall(\\n            address(basket),\\n            abi.encodeWithSelector(basket.setLock.selector, _block),\\n            0\\n        );\\n    }\\n\\n    /**\\n        @notice Rebalance underling token\\n        @param _swaps Swaps to perform\\n        @param _deadline Unix timestamp after which the transaction will revert.\\n    */\\n    function rebalance(SwapStruct[] calldata _swaps, uint256 _deadline)\\n        external\\n        override\\n        onlyRebalanceManager\\n    {\\n        lockBasketData(block.number + 30);\\n\\n        // remove token from array\\n        for (uint256 i; i < _swaps.length; i++) {\\n            SwapStruct memory swap = _swaps[i];\\n\\n            //swap token\\n            _swap(\\n                swap.from,\\n                swap.to,\\n                swap.quantity,\\n                swap.minReturn,\\n                address(basket),\\n                _deadline\\n            );\\n\\n            //add to token if missing\\n            addToken(swap.to);\\n\\n            //remove from token if resulting quantity is 0\\n            removeToken(swap.from);\\n        }\\n        emit Rebalanced(address(basket));\\n    }\\n}\\n\"\r\n    },\r\n    \"@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IPangolinRouter {\\n    function factory() external pure returns (address);\\n    function WAVAX() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityAVAX(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityAVAX(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountAVAX);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityAVAXWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountAVAX);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountAVAX);\\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountAVAXMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountAVAX);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExperiPie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@pie-dao/diamond/contracts/interfaces/IERC173.sol\\\";\\nimport \\\"@pie-dao/diamond/contracts/interfaces/IDiamondLoupe.sol\\\";\\nimport \\\"@pie-dao/diamond/contracts/interfaces/IDiamondCut.sol\\\";\\nimport \\\"./IBasketFacet.sol\\\";\\nimport \\\"./IERC20Facet.sol\\\";\\nimport \\\"./ICallFacet.sol\\\";\\n\\n/**\\n    @title ExperiPie Interface\\n    @dev Combines all ExperiPie facet interfaces into one\\n*/\\ninterface IExperiPie is\\n    IERC20,\\n    IBasketFacet,\\n    IERC20Facet,\\n    IERC173,\\n    ICallFacet,\\n    IDiamondLoupe,\\n    IDiamondCut\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPangolinRebalanceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.1;\\n\\nimport {\\n    IPangolinRouter\\n} from \\\"@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol\\\";\\nimport \\\"./IExperiPie.sol\\\";\\n\\ninterface IPangolinRebalanceManager {\\n    struct SwapStruct {\\n        address from; //Token to sell\\n        address to; //Token to buy\\n        uint256 quantity; //Quantity to sell\\n        uint256 minReturn; //Minimum quantity to buy //todo change to price for safty\\n    }\\n\\n    /**\\n        @notice Rebalance underling token\\n        @param _swaps Swaps to perform\\n        @param _deadline Unix timestamp after which the transaction will revert.\\n    */\\n    function rebalance(SwapStruct[] calldata _swaps, uint256 _deadline)\\n        external;\\n}\\n\"\r\n    },\r\n    \"@pie-dao/diamond/contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.1;\\r\\n\\r\\n/// @title ERC-173 Contract Ownership Standard\\r\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\r\\n/* is ERC165 */\\r\\ninterface IERC173 {\\r\\n    /// @dev This emits when ownership of a contract changes.\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /// @notice Get the address of the owner\\r\\n    /// @return owner_ The address of the owner.\\r\\n    function owner() external view returns (address owner_);\\r\\n\\r\\n    /// @notice Set the address of the new owner of the contract\\r\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\r\\n    /// @param _newOwner The address of the new owner of the contract\\r\\n    function transferOwnership(address _newOwner) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@pie-dao/diamond/contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.1;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n// A loupe is a small magnifying glass used to look at diamonds.\\r\\n// These functions look at diamonds\\r\\ninterface IDiamondLoupe {\\r\\n    /// These functions are expected to be called frequently\\r\\n    /// by tools.\\r\\n\\r\\n    struct Facet {\\r\\n        address facetAddress;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\r\\n    /// @return facets_ Facet\\r\\n    function facets() external view returns (Facet[] memory facets_);\\r\\n\\r\\n    /// @notice Gets all the function selectors supported by a specific facet.\\r\\n    /// @param _facet The facet address.\\r\\n    /// @return facetFunctionSelectors_\\r\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\r\\n\\r\\n    /// @notice Get all the facet addresses used by a diamond.\\r\\n    /// @return facetAddresses_\\r\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\r\\n\\r\\n    /// @notice Gets the facet that supports the given selector.\\r\\n    /// @dev If facet is not found return address(0).\\r\\n    /// @param _functionSelector The function selector.\\r\\n    /// @return facetAddress_ The facet address.\\r\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@pie-dao/diamond/contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.1;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n/******************************************************************************/\\r\\n\\r\\ninterface IDiamondCut {\\r\\n    enum FacetCutAction {Add, Replace, Remove}\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBasketFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.7.1;\\n\\ninterface IBasketFacet {\\n    event TokenAdded(address indexed _token);\\n    event TokenRemoved(address indexed _token);\\n    event EntryFeeSet(uint256 fee);\\n    event ExitFeeSet(uint256 fee);\\n    event AnnualizedFeeSet(uint256 fee);\\n    event FeeBeneficiarySet(address indexed beneficiary);\\n    event EntryFeeBeneficiaryShareSet(uint256 share);\\n    event ExitFeeBeneficiaryShareSet(uint256 share);\\n\\n    event PoolJoined(address indexed who, uint256 amount, uint16 _referral);\\n    event PoolExited(address indexed who, uint256 amount, uint16 _referral);\\n    event FeeCharged(uint256 amount);\\n    event LockSet(uint256 lockBlock);\\n    event CapSet(uint256 cap);\\n\\n    /**\\n        @notice Sets entry fee paid when minting\\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\\n    */\\n    function setEntryFee(uint256 _fee) external;\\n\\n    /**\\n        @notice Get the entry fee\\n        @return Current entry fee\\n    */\\n    function getEntryFee() external view returns (uint256);\\n\\n    /**\\n        @notice Set the exit fee paid when exiting\\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\\n    */\\n    function setExitFee(uint256 _fee) external;\\n\\n    /**\\n        @notice Get the exit fee\\n        @return Current exit fee\\n    */\\n    function getExitFee() external view returns (uint256);\\n\\n    /**\\n        @notice Set the annualized fee. Often referred to as streaming fee\\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\\n    */\\n    function setAnnualizedFee(uint256 _fee) external;\\n\\n    /**\\n        @notice Get the annualized fee.\\n        @return Current annualized fee.\\n    */\\n    function getAnnualizedFee() external view returns (uint256);\\n\\n    /**\\n        @notice Set the address receiving the fees.\\n    */\\n    function setFeeBeneficiary(address _beneficiary) external;\\n\\n    /**\\n        @notice Get the fee benificiary\\n        @return The current fee beneficiary\\n    */\\n    function getFeeBeneficiary() external view returns (address);\\n\\n    /**\\n        @notice Set the fee beneficiaries share of the entry fee\\n        @notice _share Share of the fee. 1e18 == 100%. Capped at 100%\\n    */\\n    function setEntryFeeBeneficiaryShare(uint256 _share) external;\\n\\n    /**\\n        @notice Get the entry fee beneficiary share\\n        @return Feeshare amount\\n    */\\n    function getEntryFeeBeneficiaryShare() external view returns (uint256);\\n\\n    /**\\n        @notice Set the fee beneficiaries share of the exit fee\\n        @notice _share Share of the fee. 1e18 == 100%. Capped at 100%\\n    */\\n    function setExitFeeBeneficiaryShare(uint256 _share) external;\\n\\n    /**\\n        @notice Get the exit fee beneficiary share\\n        @return Feeshare amount\\n    */\\n    function getExitFeeBeneficiaryShare() external view returns (uint256);\\n\\n    /**\\n        @notice Calculate the oustanding annualized fee\\n        @return Amount of pool tokens to be minted to charge the annualized fee\\n    */\\n    function calcOutStandingAnnualizedFee() external view returns (uint256);\\n\\n    /**\\n        @notice Charges the annualized fee\\n    */\\n    function chargeOutstandingAnnualizedFee() external;\\n\\n    /**\\n        @notice Pulls underlying from caller and mints the pool token\\n        @param _amount Amount of pool tokens to mint\\n        @param _referral Partners may receive rewards with their referral code\\n    */\\n    function joinPool(uint256 _amount, uint16 _referral) external;\\n\\n    /**\\n        @notice Burns pool tokens from the caller and returns underlying assets\\n    */\\n    function exitPool(uint256 _amount, uint16 _referral) external;\\n\\n    /**\\n        @notice Get if the pool is locked or not. (not accepting exit and entry)\\n        @return Boolean indicating if the pool is locked\\n    */\\n    function getLock() external view returns (bool);\\n\\n    /**\\n        @notice Get the block until which the pool is locked\\n        @return The lock block\\n    */\\n    function getLockBlock() external view returns (uint256);\\n\\n    /**\\n        @notice Set the lock block\\n        @param _lock Block height of the lock\\n    */\\n    function setLock(uint256 _lock) external;\\n\\n    /**\\n        @notice Get the maximum of pool tokens that can be minted\\n        @return Cap\\n    */\\n    function getCap() external view returns (uint256);\\n\\n    /**\\n        @notice Set the maximum of pool tokens that can be minted\\n        @param _maxCap Max cap\\n    */\\n    function setCap(uint256 _maxCap) external;\\n\\n    /**\\n        @notice Get the amount of tokens owned by the pool\\n        @param _token Addres of the token\\n        @return Amount owned by the contract\\n    */\\n    function balance(address _token) external view returns (uint256);\\n\\n    /**\\n        @notice Get the tokens in the pool\\n        @return Array of tokens in the pool\\n    */\\n    function getTokens() external view returns (address[] memory);\\n\\n    /**\\n        @notice Add a token to the pool. Should have at least a balance of 10**6\\n        @param _token Address of the token to add\\n    */\\n    function addToken(address _token) external;\\n\\n    /**\\n        @notice Removes a token from the pool\\n        @param _token Address of the token to remove\\n    */\\n    function removeToken(address _token) external;\\n\\n    /**\\n        @notice Checks if a token was added to the pool\\n        @param _token address of the token\\n        @return If token is in the pool or not\\n    */\\n    function getTokenInPool(address _token) external view returns (bool);\\n\\n    /**\\n        @notice Calculate the amounts of underlying needed to mint that pool amount.\\n        @param _amount Amount of pool tokens to mint\\n        @return tokens Tokens needed\\n        @return amounts Amounts of underlying needed\\n    */\\n    function calcTokensForAmount(uint256 _amount)\\n        external\\n        view\\n        returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /**\\n        @notice Calculate the amounts of underlying to receive when burning that pool amount\\n        @param _amount Amount of pool tokens to burn\\n        @return tokens Tokens returned\\n        @return amounts Amounts of underlying returned\\n    */\\n    function calcTokensForAmountExit(uint256 _amount)\\n        external\\n        view\\n        returns (address[] memory tokens, uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\ninterface IERC20Facet {\\n    /**\\n        @notice Get the token name\\n        @return The token name\\n    */\\n    function name() external view returns (string memory);\\n\\n    /**\\n        @notice Get the token symbol\\n        @return The token symbol \\n    */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n        @notice Get the amount of decimals\\n        @return Amount of decimals\\n    */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n        @notice Mints tokens. Can only be called by the contract owner or the contract itself\\n        @param _receiver Address receiving the tokens\\n        @param _amount Amount to mint\\n    */\\n    function mint(address _receiver, uint256 _amount) external;\\n\\n    /**\\n        @notice Burns tokens. Can only be called by the contract owner or the contract itself\\n        @param _from Address to burn from\\n        @param _amount Amount to burn\\n    */\\n    function burn(address _from, uint256 _amount) external;\\n\\n    /**\\n        @notice Sets up the metadata and initial supply. Can be called by the contract owner\\n        @param _initialSupply Initial supply of the token\\n        @param _name Name of the token\\n        @param _symbol Symbol of the token\\n    */\\n    function initialize(\\n        uint256 _initialSupply,\\n        string memory _name,\\n        string memory _symbol\\n    ) external;\\n\\n    /**\\n        @notice Set the token name of the contract. Can only be called by the contract owner or the contract itself\\n        @param _name New token name\\n    */\\n    function setName(string calldata _name) external;\\n\\n    /**\\n        @notice Set the token symbol of the contract. Can only be called by the contract owner or the contract itself\\n        @param _symbol New token symbol\\n    */\\n    function setSymbol(string calldata _symbol) external;\\n\\n    /**\\n        @notice Increase the amount of tokens another address can spend\\n        @param _spender Spender\\n        @param _amount Amount to increase by\\n    */\\n    function increaseApproval(address _spender, uint256 _amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n        @notice Decrease the amount of tokens another address can spend\\n        @param _spender Spender\\n        @param _amount Amount to decrease by\\n    */\\n    function decreaseApproval(address _spender, uint256 _amount)\\n        external\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICallFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\ninterface ICallFacet {\\n    event CallerAdded(address indexed caller);\\n    event CallerRemoved(address indexed caller);\\n    event Call(\\n        address indexed caller,\\n        address indexed target,\\n        bytes data,\\n        uint256 value\\n    );\\n\\n    /**\\n        @notice Lets whitelisted callers execute a batch of arbitrary calls from the pool. Reverts if one of the calls fails\\n        @param _targets Array of addresses of targets to call\\n        @param _calldata Array of calldata for each call\\n        @param _values Array of amounts of ETH to send with the call\\n    */\\n    function call(\\n        address[] memory _targets,\\n        bytes[] memory _calldata,\\n        uint256[] memory _values\\n    ) external;\\n\\n    /**\\n        @notice Lets whitelisted callers execute a batch of arbitrary calls from the pool without sending any Ether. Reverts if one of the calls fail\\n        @param _targets Array of addresses of targets to call\\n        @param _calldata Array of calldata for each call\\n    */\\n    function callNoValue(address[] memory _targets, bytes[] memory _calldata)\\n        external;\\n\\n    /**\\n        @notice Lets whitelisted callers execute a single arbitrary call from the pool. Reverts if the call fails\\n        @param _target Address of the target to call\\n        @param _calldata Calldata of the call\\n        @param _value Amount of ETH to send with the call\\n    */\\n    function singleCall(\\n        address _target,\\n        bytes calldata _calldata,\\n        uint256 _value\\n    ) external;\\n\\n    /**\\n        @notice Add a whitelisted caller. Can only be called by the contract owner\\n        @param _caller Caller to add\\n    */\\n    function addCaller(address _caller) external;\\n\\n    /**\\n        @notice Remove a whitelisted caller. Can only be called by the contract owner\\n    */\\n    function removeCaller(address _caller) external;\\n\\n    /**\\n        @notice Checks if an address is a whitelisted caller\\n        @param _caller Address to check\\n        @return If the address is whitelisted\\n    */\\n    function canCall(address _caller) external view returns (bool);\\n\\n    /**\\n        @notice Get all whitelisted callers\\n        @return Array of whitelisted callers\\n    */\\n    function getCallers() external view returns (address[] memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_basket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pangolin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nativeToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rebalanceManager\",\"type\":\"address\"}],\"name\":\"RebalanceManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"basket\",\"type\":\"address\"}],\"name\":\"Rebalanced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"basket\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnedQuantity\",\"type\":\"uint256\"}],\"name\":\"Swaped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"basket\",\"outputs\":[{\"internalType\":\"contract IExperiPie\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pangolin\",\"outputs\":[{\"internalType\":\"contract IPangolinRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"}],\"internalType\":\"struct IPangolinRebalanceManager.SwapStruct[]\",\"name\":\"_swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalanceManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rebalanceManager\",\"type\":\"address\"}],\"name\":\"setRebalanceManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PangolinRebalanceManager","CompilerVersion":"v0.7.1+commit.f4a555be","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001660f10b4d610cf482194356ece8efd65b15ba830000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}