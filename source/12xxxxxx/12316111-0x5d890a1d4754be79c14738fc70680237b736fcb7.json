{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/app/contracts/pactBasePool/PactBasePool.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: MIT\\\"\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../vendors/contracts/access/Whitelist.sol\\\";\\nimport \\\"../vendors/contracts/TxStorage.sol\\\";\\nimport \\\"../vendors/interfaces/IUniswapOracle.sol\\\";\\nimport \\\"../vendors/interfaces/IERC20.sol\\\";\\nimport \\\"../vendors/libraries/SafeMath.sol\\\";\\nimport \\\"../vendors/libraries/SafeERC20.sol\\\";\\nimport \\\"../vendors/libraries/TransferHelper.sol\\\";\\n\\n\\ncontract PactBasePool is Whitelist, TxStorage {\\n    \\n    using SafeMath for uint;\\n    using SafeERC20 for IERC20;\\n\\n    address public _oracleAddress;\\n    address public _PACT;\\n\\n    uint public _minBuy;\\n    uint public _price;\\n\\n    event Deposit(uint amount, uint price);\\n    event Withdraw(uint tokensAmount, uint price);\\n    \\n    constructor (\\n        address governanceAddress,\\n        address oracleAddress,\\n        address PACT,\\n        uint minBuy\\n\\n    ) public GovernanceOwnable(governanceAddress) {\\n        require (oracleAddress != address(0), \\\"ORACLE ADDRESS SHOULD BE NOT NULL\\\");\\n        require (PACT != address(0), \\\"PACT ADDRESS SHOULD BE NOT NULL\\\");\\n\\n        _oracleAddress = oracleAddress;\\n        _PACT = PACT;\\n        \\n        _minBuy = minBuy == 0 ? 10000e18 : minBuy;\\n    }\\n    \\n    \\n    function buylimitsUpdate( uint minLimit) public onlyGovernance {\\n        _minBuy = minLimit;\\n    }\\n    \\n    \\n    function changeOracleAddress (address oracleAddress) \\n      public \\n      onlyGovernance {\\n        require (oracleAddress != address(0), \\\"NEW ORACLE ADDRESS SHOULD BE NOT NULL\\\");\\n\\n        _oracleAddress = oracleAddress;\\n    }\\n\\n\\n\\tfunction calcPriceEthPact(uint amountInEth) public view returns (uint) {\\n        uint price = IUniswapOracle(_oracleAddress).consultAB(1e18);\\n        if (price > 1e18){\\n            return amountInEth.mul(price.div(1e18));\\n        }\\n        return amountInEth.mul(uint(1e18).div(price));\\n\\t}\\n\\n\\tfunction calcPricePactEth(uint amountInPact) public view returns (uint) {\\n        uint price = IUniswapOracle(_oracleAddress).consultAB(1e18);\\n        if (price > 1e18){\\n            return amountInPact.div(price.div(1e18));\\n        }\\n        return amountInPact.div(uint(1e18).div(price));\\n\\t}\\n\\n\\n    function changeEthToToken() public onlyWhitelisted payable {\\n        uint amountIn = msg.value;\\n        IUniswapOracle(_oracleAddress).update();\\n        uint tokensAmount = calcPriceEthPact(amountIn);\\n        IERC20 PACT = IERC20(_PACT);\\n\\n        require(tokensAmount >= _minBuy, \\\"BUY LIMIT\\\");\\n        require(tokensAmount <= PACT.balanceOf(address(this)), \\\"NOT ENOUGH PACT TOKENS ON BASEPOOl CONTRACT BALANCE\\\");\\n\\n        PACT.safeTransfer(msg.sender, tokensAmount);\\n        transactionAdd(tokensAmount,amountIn);\\n\\n        emit Deposit(tokensAmount, amountIn);\\n    }\\n    \\n\\n    function returnToken(uint index) external onlyWhitelisted {\\n        IERC20 PACT = IERC20(_PACT);\\n        checkTrransaction(msg.sender , index);\\n        (uint amount, uint price,,,) = getTransaction(msg.sender , index);\\n        \\n        require(address(this).balance >= price, \\\"NOT ENOUGH ETH ON BASEPOOl CONTRACT BALANCE\\\");\\n        require(PACT.allowance(msg.sender, address(this)) >= amount, \\\"NOT ENOUGH DELEGATED PACT TOKENS ON DESTINATION BALANCE\\\");\\n\\n        closedTransaction(msg.sender, index);\\n        PACT.safeTransferFrom(msg.sender, amount);\\n        TransferHelper.safeTransferETH(msg.sender, price);\\n\\n        emit Withdraw(amount, price);\\n    }\\n\\n\\n    function withdrawEthForExpiredTransaction(address to) public onlyGovernance{\\n        uint actualBalanceOfTransactions = amountOfActualTransactions();\\n        uint balance = address(this).balance;\\n        require(balance > actualBalanceOfTransactions,\\\"\\\");\\n        TransferHelper.safeTransferETH(to,balance.sub(actualBalanceOfTransactions));   \\n    }\\n    \\n} \"\r\n    },\r\n    \"/app/contracts/vendors/contracts/TxStorage.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: MIT\\\"\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/SafeMath.sol\\\";\\nimport \\\"./access/GovernanceOwnable.sol\\\";\\n\\nabstract contract TxStorage is GovernanceOwnable{\\n\\tusing SafeMath for uint;\\n\\n    uint private expirePeriod = 7776000;\\n\\n    struct Transaction {\\n\\t\\tuint ammount;\\t\\t\\n\\t\\tuint price;\\t\\n        uint timestamp;\\n        uint expireTimeStamp;\\n        bool closed;\\n\\t}\\n\\n\\n    mapping(address => mapping (uint => Transaction)) internal transactionsHistory;\\n    mapping(address => uint) internal index;\\n    address [] public userList;\\n\\n    function setExparePeriud(uint _epirePeriod) external onlyGovernance payable{\\n        expirePeriod = _epirePeriod;\\n    }\\n\\n    function transactionAdd(uint ammount, uint price) internal{\\n       uint timestamp = block.timestamp;\\n       _transactionAdd(msg.sender, ammount, price, timestamp, timestamp.add(expirePeriod));\\n    }\\n\\n    function closedTransaction(address to, uint _index) internal {\\n         transactionsHistory[to][_index].closed = true;\\n    }\\n\\n    function _transactionAdd(address to, uint ammount, uint price, uint timestamp, uint expireTimeStamp) internal {\\n        if (index[to]==0){\\n            userList.push(to);\\n        }\\n        index[to] +=1;\\n        transactionsHistory[to][index[to]] = Transaction(ammount, price, timestamp, expireTimeStamp, false);\\n    }\\n\\n\\n    function amountOfActualTransactions() public view returns (uint result) {\\n        for (uint i = 0; i < userList.length; i++) {\\n            for (uint a = 0; a <= index[userList[i]]; a++) {\\n               if (transactionsHistory[userList[i]][a].expireTimeStamp > block.timestamp){\\n                   result += transactionsHistory[userList[i]][a].price;\\n               }\\n            }           \\n        }\\n        return result;\\n    }\\n\\n    function getTransaction(address to, uint _index) public view returns (uint ammount, uint price, uint timestamp, uint expireTimeStamp, bool closed) {\\n       require(transactionsHistory[to][_index].timestamp != 0 , \\\"INDEX OUT OF RANGE\\\");\\n       ammount = transactionsHistory[to][_index].ammount;\\n       price =transactionsHistory[to][_index].price;\\n       timestamp = transactionsHistory[to][_index].timestamp;\\n       expireTimeStamp = transactionsHistory[to][_index].expireTimeStamp;\\n       closed = transactionsHistory[to][_index].closed;\\n    }\\n\\n\\n    function checkTrransaction(address to, uint _index) internal view{\\n       Transaction memory transaction = transactionsHistory[to][_index];\\n       require(transaction.timestamp != 0 , \\\"INDEX OUT OF RANGE\\\");\\n       require(!transaction.closed , \\\"THE TRANSACTION IS CLOSED\\\");\\n       require(block.timestamp <= transaction.expireTimeStamp, \\\"TRANSACTION TIME EXPIRED\\\");\\n    }\\n\\n\\n    function getTransactionlastIndex(address to) external view returns (uint ) {\\n        return index[to];\\n    }\\n\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/contracts/access/GovernanceOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"../../interfaces/IGovernanceOwnable.sol\\\";\\n\\nabstract contract GovernanceOwnable is IGovernanceOwnable {\\n    address private _governanceAddress;\\n\\n    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    constructor (address governance_) public {\\n        require(governance_ != address(0), \\\"Governance address should be not null\\\");\\n        _governanceAddress = governance_;\\n        emit GovernanceSetTransferred(address(0), governance_);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current governanceAddress.\\n     */\\n    function governance() public view override returns (address) {\\n        return _governanceAddress;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the governanceAddress.\\n     */\\n    modifier onlyGovernance() {\\n        require(_governanceAddress == msg.sender, \\\"Governance: caller is not the governance\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev SetGovernance of the contract to a new account (`newGovernance`).\\n     * Can only be called by the current onlyGovernance.\\n     */\\n    function setGovernance(address newGovernance) public virtual override onlyGovernance {\\n        require(newGovernance != address(0), \\\"GovernanceOwnable: new governance is the zero address\\\");\\n        emit GovernanceSetTransferred(_governanceAddress, newGovernance);\\n        _governanceAddress = newGovernance;\\n    }\\n\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/contracts/access/Whitelist.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: MIT\\\"\\npragma solidity 0.6.12;\\n\\n\\nimport \\\"./GovernanceOwnable.sol\\\";\\n\\nabstract contract Whitelist is GovernanceOwnable {\\n    mapping(address => bool) whitelist;\\n    event AddedToWhitelist(address indexed account);\\n    event RemovedFromWhitelist(address indexed account);\\n\\n    modifier onlyWhitelisted() {\\n        require(isWhitelisted(msg.sender));\\n        _;\\n    }\\n\\n    function whitelistAdd(address _address) public onlyGovernance {\\n        whitelist[_address] = true;\\n        emit AddedToWhitelist(_address);\\n    }\\n\\n    function whitelistRemove(address _address) public onlyGovernance {\\n        whitelist[_address] = false;\\n        emit RemovedFromWhitelist(_address);\\n    }\\n\\n    function isWhitelisted(address _address) public view returns(bool) {\\n        return whitelist[_address];\\n    }\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    function balanceOf(address tokenOwner) external view returns (uint balance);\\r\\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\\r\\n    function approve(address spender, uint tokens) external returns (bool success);\\r\\n    function transfer(address to, uint tokens) external returns (bool success);\\r\\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\r\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IGovernanceOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n\\ninterface IGovernanceOwnable {\\n    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    function governance() external view returns (address);\\n    function setGovernance(address newGovernance) external;\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/interfaces/IUniswapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IUniswapOracle {\\n\\tfunction getPair() external view returns (address);\\n\\tfunction update() external;\\n\\tfunction getTimeElapsed(address tokenIn, address tokenOut) external view returns (uint);\\n    function consultAB(uint amountIn) external view  returns (uint amountOut);\\n    function consultBA(uint amountIn) external view  returns (uint amountOut);\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function safeName(IERC20 token) internal view returns(string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function safeDecimals(IERC20 token) public view returns (uint8) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\r\\n    }\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"SafeERC20: Transfer failed\\\");\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"SafeERC20: TransferFrom failed\\\");\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return add(a, b, \\\"SafeMath: Add Overflow\\\");\\r\\n    }\\r\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, errorMessage);// \\\"SafeMath: Add Overflow\\\"\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: Underflow\\\");\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;// \\\"SafeMath: Underflow\\\"\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mul(a, b, \\\"SafeMath: Mul Overflow\\\");\\r\\n    }\\r\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, errorMessage);// \\\"SafeMath: Mul Overflow\\\"\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/app/contracts/vendors/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governanceAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"PACT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minBuy\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceSetTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_PACT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_oracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountOfActualTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minLimit\",\"type\":\"uint256\"}],\"name\":\"buylimitsUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInEth\",\"type\":\"uint256\"}],\"name\":\"calcPriceEthPact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInPact\",\"type\":\"uint256\"}],\"name\":\"calcPricePactEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeEthToToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"}],\"name\":\"changeOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ammount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"closed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"getTransactionlastIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"returnToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epirePeriod\",\"type\":\"uint256\"}],\"name\":\"setExparePeriud\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"whitelistAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"whitelistRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawEthForExpiredTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PactBasePool","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002ef29a0a5a90d3205d901af3fb8f83cd79992817000000000000000000000000dabbcc619179e541cc2aa7dd297c4707ab04e8f600000000000000000000000080d290a6fdce62709e17669af8affb0d77c6edb80000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}