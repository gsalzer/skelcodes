{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/enamakel/Work/mahadao.com/arthcoin/arthcoin-v2/contracts/Arth/Pools/ArthPoolLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {SafeMath} from '../../utils/math/SafeMath.sol';\\n\\nlibrary ArthPoolLibrary {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * Data structs.\\n     */\\n\\n    struct MintFAParams {\\n        uint256 arthxPriceGMU;\\n        uint256 collateralPriceGMU;\\n        uint256 arthxAmount;\\n        uint256 collateralAmount;\\n        uint256 collateralRatio;\\n    }\\n\\n    struct BuybackARTHXParams {\\n        uint256 excessCollateralGMUValueD18;\\n        uint256 arthxPriceGMU;\\n        uint256 collateralPriceGMU;\\n        uint256 arthxAmount;\\n    }\\n\\n    uint256 private constant _PRICE_PRECISION = 1e6;\\n\\n    /**\\n     * Public.\\n     */\\n\\n    function calcMint1t1ARTH(\\n        uint256 collateralPrice,\\n        uint256 collateralAmountD18\\n    ) public pure returns (uint256) {\\n        return (collateralAmountD18.mul(collateralPrice)).div(1e6);\\n    }\\n\\n    function calcOverCollateralizedMintAmounts(\\n        uint256 collateralRatio,\\n        uint256 algorithmicRatio,\\n        uint256 collateralPrice,\\n        uint256 arthxPrice,\\n        uint256 collateralAmountD18\\n    )\\n        public\\n        pure\\n        returns (\\n            uint256,  // ARTH Mint amount.\\n            uint256  // ARTHX Mint amount.\\n        )\\n    {\\n        uint256 collateralValue = (\\n            collateralAmountD18\\n            .mul(collateralPrice)\\n            .div(1e6)\\n        );\\n\\n        uint256 arthValueToMint = collateralValue.mul(collateralRatio).div(1e6);\\n        uint256 arthxValueToMint = collateralValue.mul(algorithmicRatio).div(1e6);\\n\\n        return (\\n            arthValueToMint,\\n            arthxValueToMint.mul(1e6).div(arthxPrice)\\n        );\\n    }\\n\\n    function calcMintAlgorithmicARTH(\\n        uint256 arthxPriceGMU,\\n        uint256 collateralAmountD18\\n    ) public pure returns (uint256) {\\n        return collateralAmountD18.mul(arthxPriceGMU).div(1e6);\\n    }\\n\\n    // Must be internal because of the struct\\n    function calcMintFractionalARTH(MintFAParams memory params)\\n        internal\\n        pure\\n        returns (uint256, uint256)\\n    {\\n        // Since solidity truncates division, every division operation must be the last operation in the equation to ensure minimum error\\n        // The contract must check the proper ratio was sent to mint ARTH. We do this by seeing the minimum mintable ARTH based on each amount\\n        uint256 arthxGMUValueD18;\\n        uint256 collateralGMUValueD18;\\n\\n        // Scoping for stack concerns\\n        {\\n            // USD amounts of the collateral and the ARTHX\\n            arthxGMUValueD18 = params.arthxAmount.mul(params.arthxPriceGMU).div(\\n                1e6\\n            );\\n            collateralGMUValueD18 = params\\n                .collateralAmount\\n                .mul(params.collateralPriceGMU)\\n                .div(1e6);\\n        }\\n        uint256 calcARTHXGMUValueD18 =\\n            (collateralGMUValueD18.mul(1e6).div(params.collateralRatio)).sub(\\n                collateralGMUValueD18\\n            );\\n\\n        uint256 calcARTHXNeeded =\\n            calcARTHXGMUValueD18.mul(1e6).div(params.arthxPriceGMU);\\n\\n        return (\\n            collateralGMUValueD18.add(calcARTHXGMUValueD18),\\n            calcARTHXNeeded\\n        );\\n    }\\n\\n    function calcOverCollateralizedRedeemAmounts(\\n        uint256 collateralRatio,\\n        // uint256 algorithmicRatio,\\n        uint256 arthxPrice,\\n        uint256 collateralPriceGMU,\\n        uint256 arthAmount\\n        //, uint256 arthxAmount\\n    )\\n        public\\n        pure\\n        returns (\\n            uint256,  // Collateral amount to return.\\n            uint256   // ARTHX amount needed.\\n        )\\n    {\\n        // uint256 totalInputValue = arthAmount.add(\\n        //     arthxAmount.mul(arthxPrice).div(1e6)\\n        // );\\n\\n        // // Ensures inputs are in ratios mentioned.\\n        // require(\\n        //     totalInputValue.mul(collateralRatio).div(1e6) == arthAmount,\\n        //     'ArthPoolLibrary: invalid ratios'\\n        // );\\n        // require(\\n        //     totalInputValue.mul(algorithmicRatio).div(1e6) == arthxAmount.mul(arthxPrice).div(1e6),\\n        //     'ArthPoolLibrary: invalid ratios'\\n        // );\\n\\n        // return (\\n        //     totalInputValue.mul(1e6).div(collateralPriceGMU)\\n        // );\\n\\n        uint256 arthxValueNeeded = (\\n            arthAmount\\n                .mul(1e6)\\n                .div(collateralRatio)\\n                .sub(arthAmount)\\n        );\\n        uint256 arthxNeeded = arthxValueNeeded.mul(1e6).div(arthxPrice);\\n\\n        return (\\n            arthAmount.add(arthxValueNeeded).mul(1e6).div(collateralPriceGMU),\\n            arthxNeeded\\n        );\\n    }\\n\\n    function calcRedeem1t1ARTH(uint256 collateralPriceGMU, uint256 arthAmount)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return arthAmount.mul(1e6).div(collateralPriceGMU);\\n    }\\n\\n    // Must be internal because of the struct\\n    function calcBuyBackARTHX(BuybackARTHXParams memory params)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        // If the total collateral value is higher than the amount required at the current collateral ratio then buy back up to the possible ARTHX with the desired collateral\\n        require(\\n            params.excessCollateralGMUValueD18 > 0,\\n            'No excess collateral to buy back!'\\n        );\\n\\n        // Make sure not to take more than is available\\n        uint256 arthxGMUValueD18 =\\n            params.arthxAmount.mul(params.arthxPriceGMU).div(1e6);\\n        require(\\n            arthxGMUValueD18 <= params.excessCollateralGMUValueD18,\\n            'You are trying to buy back more than the excess!'\\n        );\\n\\n        // Get the equivalent amount of collateral based on the market value of ARTHX provided\\n        uint256 collateralEquivalentD18 =\\n            arthxGMUValueD18.mul(1e6).div(params.collateralPriceGMU);\\n        // collateralEquivalentD18 = collateralEquivalentD18.sub((collateralEquivalentD18.mul(params.buybackFee)).div(1e6));\\n\\n        return (collateralEquivalentD18);\\n    }\\n\\n    // Returns value of collateral that must increase to reach recollateralization target (if 0 means no recollateralization)\\n    function recollateralizeAmount(\\n        uint256 totalSupply,\\n        uint256 globalCollateralRatio,\\n        uint256 globalCollatValue\\n    ) public pure returns (uint256) {\\n        uint256 targetCollateralValue =\\n            totalSupply.mul(globalCollateralRatio).div(1e6); // We want 18 decimals of precision so divide by 1e6; totalSupply is 1e18 and globalCollateralRatio is 1e6\\n\\n        // Subtract the current value of collateral from the target value needed, if higher than 0 then system needs to recollateralize\\n        return targetCollateralValue.sub(globalCollatValue); // If recollateralization is not needed, throws a subtraction underflow\\n        // return(recollateralization_left);\\n    }\\n\\n    function calcRecollateralizeARTHInner(\\n        uint256 collateralAmount,\\n        uint256 collateralPrice,\\n        uint256 globalCollatValue,\\n        uint256 arthTotalSupply,\\n        uint256 globalCollateralRatio\\n    )\\n        public\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 collateralValueAttempted =\\n            collateralAmount.mul(collateralPrice).div(1e6);\\n        uint256 effectiveCollateralRatio =\\n            globalCollatValue.mul(1e6).div(arthTotalSupply); //returns it in 1e6\\n\\n        uint256 recollateralizePossible =\\n            (\\n                globalCollateralRatio.mul(arthTotalSupply).sub(\\n                    arthTotalSupply.mul(effectiveCollateralRatio)\\n                )\\n            )\\n                .div(1e6);\\n\\n        uint256 amountToRecollateralize;\\n        if (collateralValueAttempted <= recollateralizePossible) {\\n            amountToRecollateralize = collateralValueAttempted;\\n        } else {\\n            amountToRecollateralize = recollateralizePossible;\\n        }\\n\\n        return (\\n            amountToRecollateralize.mul(1e6).div(collateralPrice),\\n            amountToRecollateralize,\\n            recollateralizePossible\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/enamakel/Work/mahadao.com/arthcoin/arthcoin-v2/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmountD18\",\"type\":\"uint256\"}],\"name\":\"calcMint1t1ARTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"arthxPriceGMU\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmountD18\",\"type\":\"uint256\"}],\"name\":\"calcMintAlgorithmicARTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"algorithmicRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arthxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmountD18\",\"type\":\"uint256\"}],\"name\":\"calcOverCollateralizedMintAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arthxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralPriceGMU\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arthAmount\",\"type\":\"uint256\"}],\"name\":\"calcOverCollateralizedRedeemAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"globalCollatValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arthTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"globalCollateralRatio\",\"type\":\"uint256\"}],\"name\":\"calcRecollateralizeARTHInner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralPriceGMU\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arthAmount\",\"type\":\"uint256\"}],\"name\":\"calcRedeem1t1ARTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"globalCollateralRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"globalCollatValue\",\"type\":\"uint256\"}],\"name\":\"recollateralizeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ArthPoolLibrary","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}