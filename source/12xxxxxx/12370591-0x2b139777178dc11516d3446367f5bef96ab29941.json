{"status":"1","message":"OK","result":[{"SourceCode":"// File: @opengsn/contracts/src/interfaces/IRelayRecipient.sol\r\n// SPDX-License-Identifier:MIT\r\npragma solidity >=0.7.6;\r\n\r\n/**\r\n * a contract must implement this interface in order to support relayed transaction.\r\n * It is better to inherit the BaseRelayRecipient as its implementation.\r\n */\r\nabstract contract IRelayRecipient {\r\n\r\n    /**\r\n     * return if the forwarder is trusted to forward relayed transactions to us.\r\n     * the forwarder is required to verify the sender's signature, and verify\r\n     * the call is not a replay.\r\n     */\r\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\r\n\r\n    /**\r\n     * return the sender of this call.\r\n     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes\r\n     * of the msg.data.\r\n     * otherwise, return `msg.sender`\r\n     * should be used in the contract anywhere instead of msg.sender\r\n     */\r\n    function _msgSender() internal virtual view returns (address payable);\r\n\r\n    /**\r\n     * return the msg.data of this call.\r\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\r\n     * of the msg.data - so this method will strip those 20 bytes off.\r\n     * otherwise (if the call was made directly and not through the forwarder), return `msg.data`\r\n     * should be used in the contract instead of msg.data, where this difference matters.\r\n     */\r\n    function _msgData() internal virtual view returns (bytes memory);\r\n\r\n    function versionRecipient() external virtual view returns (string memory);\r\n}\r\n\r\n// File: @opengsn/contracts/src/BaseRelayRecipient.sol\r\n// solhint-disable no-inline-assembly\r\npragma solidity >=0.7.6;\r\n\r\n\r\n/**\r\n * A base contract to be inherited by any contract that want to receive relayed transactions\r\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\r\n */\r\nabstract contract BaseRelayRecipient is IRelayRecipient {\r\n\r\n    /*\r\n     * Forwarder singleton we accept calls from\r\n     */\r\n    address public trustedForwarder;\r\n\r\n    function isTrustedForwarder(address forwarder) public override view returns(bool) {\r\n        return forwarder == trustedForwarder;\r\n    }\r\n\r\n    /**\r\n     * return the sender of this call.\r\n     * if the call came through our trusted forwarder, return the original sender.\r\n     * otherwise, return `msg.sender`.\r\n     * should be used in the contract anywhere instead of msg.sender\r\n     */\r\n    function _msgSender() internal override virtual view returns (address payable ret) {\r\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\r\n            // At this point we know that the sender is a trusted forwarder,\r\n            // so we trust that the last bytes of msg.data are the verified sender address.\r\n            // extract sender address from the end of msg.data\r\n            assembly {\r\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\r\n            }\r\n        } else {\r\n            return msg.sender;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return the msg.data of this call.\r\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\r\n     * of the msg.data - so this method will strip those 20 bytes off.\r\n     * otherwise, return `msg.data`\r\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\r\n     * signing or hashing the\r\n     */\r\n    function _msgData() internal override virtual view returns (bytes memory ret) {\r\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\r\n            return msg.data[0:msg.data.length-20];\r\n        } else {\r\n            return msg.data;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/CaptureTheFlag.sol\r\n/**\r\n */\r\npragma solidity ^0.7.6;\r\n\r\ncontract CaptureTheFlag is BaseRelayRecipient {\r\n\r\n    event FlagCaptured(address previousHolder, address currentHolder);\r\n\r\n    address public currentHolder = address(0);\r\n\r\n    function captureTheFlag() external {\r\n        address previousHolder = currentHolder;\r\n\r\n        currentHolder = _msgSender();\r\n\r\n        emit FlagCaptured(previousHolder, currentHolder);\r\n    }\r\n\r\n    constructor(address forwarder) {\r\n        trustedForwarder = forwarder;\r\n    }\r\n\r\n    string public override versionRecipient = \"2.2.0\";\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousHolder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentHolder\",\"type\":\"address\"}],\"name\":\"FlagCaptured\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"captureTheFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"versionRecipient\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CaptureTheFlag","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000aa3e82b4c4093b4ba13cb5714382c99adbf750ca","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4d4cbe9745fe447dd8753671feb6d8f7a5aa52756ef57ca026f0459142ea72f3"}]}