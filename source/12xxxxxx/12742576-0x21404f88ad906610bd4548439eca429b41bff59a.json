{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: Apache License, Version 2.0\n\npragma solidity 0.7.6;\n\n\n\n// Part: Address\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// Part: ECDSA\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n// Part: IERC165\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// Part: IERC20\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// Part: ReentrancyGuard\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n// Part: SafeMath\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n// Part: EIP712\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private _CACHED_DOMAIN_SEPARATOR;\n    uint256 private _CACHED_CHAIN_ID;\n\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private _TYPE_HASH;\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    //    constructor(string memory name, string memory version) {\n    //        bytes32 hashedName = keccak256(bytes(name));\n    //        bytes32 hashedVersion = keccak256(bytes(version));\n    //        bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    //        _HASHED_NAME = hashedName;\n    //        _HASHED_VERSION = hashedVersion;\n    //        _CACHED_CHAIN_ID = _getChainId();\n    //        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n    //        _TYPE_HASH = typeHash;\n    //    }\n    /**\n     * for proxy, use initialize instead.\n     * set 'owner', 'galaxy community' and register 1155, metadata interface.\n     */\n    function initialize() internal {\n        // EIP712(\"Galaxy\", \"1.0.0\");\n        string memory name = \"Galaxy\";\n        string memory version = \"1.0.0\";\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        this;\n        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n\n// Part: IERC1155\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n\n// Part: IStarNFT\n\n/**\n * @title IStarNFT\n * @author Galaxy Protocol\n *\n * Interface for operating with StarNFTs.\n */\ninterface IStarNFT is IERC1155 {\n    /* ============ Events =============== */\n//    event PowahUpdated(uint256 indexed id, uint256 indexed oldPoints, uint256 indexed newPoints);\n\n    /* ============ Functions ============ */\n\n    function isOwnerOf(address, uint256) external view returns (bool);\n//    function starInfo(uint256) external view returns (uint128 powah, uint128 mintBlock, address originator);\n//    function quasarInfo(uint256) external view returns (uint128 mintBlock, IERC20 stakeToken, uint256 amount, uint256 campaignID);\n//    function superInfo(uint256) external view returns (uint128 mintBlock, IERC20[] memory stakeToken, uint256[] memory amount, uint256 campaignID);\n\n    // mint\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n\n    // asset-backing mint\n//    function mintQuasar(address account, uint256 powah, uint256 cid, IERC20 stakeToken, uint256 amount) external returns (uint256);\n//    function burnQuasar(address account, uint256 id) external;\n\n    // asset-backing forge\n//    function mintSuper(address account, uint256 powah, uint256 campaignID, IERC20[] calldata stakeTokens, uint256[] calldata amounts) external returns (uint256);\n//    function burnSuper(address account, uint256 id) external;\n    // update\n//    function updatePowah(address owner, uint256 id, uint256 powah) external;\n}\n\n// File: SpaceStation.sol\n\n/**\n * @title SpaceStation\n * @author Galaxy Protocol\n *\n * Campaign contract that allows privileged DAOs to initiate campaigns for members to claim StarNFTs.\n */\ncontract SpaceStation is ReentrancyGuard, EIP712 {\n    using Address for address;\n    using SafeMath for uint256;\n\n    /* ============ Events ============ */\n    event EventActivateCampaign(uint256 _cid);\n    event EventActivateStakeCampaign(uint256 _cid);\n    event EventExpireCampaign(uint256 _cid);\n    event EventClaim(uint256 _cid, uint256 _dummyId, uint256 _nftID, address _sender);\n    event EventClaimBatch(uint256 _cid, uint256[] _dummyIdArr, uint256[] _nftIDArr, address _sender);\n    event EventStakeIn(uint256 _cid, address _sender, uint256 _stakeAmount, address _erc20);\n    event EventStakeOut(address _starNFT, uint256 _nftID);\n    event EventForgeNoStake(uint256 _cid, address _sender, address _starNFT, uint256[] _nftIDs);\n    event EventForgeWithStake(uint256 _cid, address _sender, address _starNFT, uint256[] _nftIDs, uint256 _stakeAmount, address _erc20);\n\n    /* ============ Modifiers ============ */\n    /**\n     * Throws if the address is not a validated starNFT contract\n     */\n    modifier onlyStarNFT(IStarNFT _starNFTAddress)  {\n        require(_starNFTs[_starNFTAddress], \"Invalid Star NFT contract address\");\n        _;\n    }\n    /**\n     * Throws if the sender is not the manager\n     */\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    /**\n     * Throws if the sender is not the Treasury's manager\n     */\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    /**\n     * Throws if the contract paused\n     */\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n\n    /* ============ Enums ================ */\n\n    // Operation a user could interact with Galaxy per campaign of DAO\n    enum Operation {\n        Default,\n        Claim,\n        StakeIn,\n        StakeOut,\n        Forge\n    }\n\n    /* ============ Structs ============ */\n\n    struct CampaignStakeConfig {\n        address erc20;                  // Address of token being staked\n        uint256 minStakeAmount;         // Minimum amount of token to stake required, included\n        uint256 maxStakeAmount;         // Maximum amount of token to stake required, included\n        uint256 lockBlockNum;           // To indicate when token lock-up period is met\n        bool burnRequired;              // Require NFT burnt if staked out\n        bool isEarlyStakeOutAllowed;    // Whether early stake out is allowed or not\n        uint256 earlyStakeOutFine;      // If early stake out is allowed, the applied penalty\n    }\n\n    struct CampaignFeeConfig {\n        address erc20;                 // Address of token asset if required\n        uint256 erc20Fee;              // Amount of token if required\n        uint256 platformFee;           // Amount of fee for using the service if applicable\n        bool isActive;                 // Indicate whether this campaign exists and is active\n    }\n\n    /* ============ State Variables ============ */\n\n    // The manager which has privilege to add, remove starNFT address.\n    address public manager;\n    // Treasury manager which receives platform fee.\n    address public treasury_manager;\n\n    // Mapping that stores all stake requirement for a given activated campaign.\n    mapping(uint256 => CampaignStakeConfig) public campaignStakeConfigs;\n\n    // Mapping that stores all fee requirements per Operation for a given activated campaign.\n    // If no fee is required at all, Operation(DEFAULT) should set to all zero values.\n    // Operation(DEFAULT) should always exist.\n    mapping(uint256 => mapping(Operation => CampaignFeeConfig)) public campaignFeeConfigs;\n\n    // Set that contains all validated starNFT contract addresses\n    mapping(IStarNFT => bool) private _starNFTs;\n\n    // Mapping that records fees totals owned by galaxy-treasury,\n    // Separate from escrow backed-asset from users.\n    uint256 public galaxyTreasuryNetwork;\n    mapping(address => uint256) public galaxyTreasuryERC20;\n    // contract is initialized\n    bool public initialized;\n    // contract is paused\n    bool public paused;\n\n    // hasMinted(signature => bool) that records if the user account has already used the signature.\n    mapping(uint256 => bool) public hasMinted;\n\n    /* ============ Constructor ============ */\n\n    constructor() {}\n\n    function initialize(\n        address _manager,\n        address _treasury_manager\n    ) external {\n        require(!initialized, \"Contract already initialized\");\n        if (_manager != address(0)) {\n            manager = _manager;\n        } else {\n            // `manager` defaults to msg.sender on construction if no valid manager address passed in.\n            manager = msg.sender;\n        }\n        if (_treasury_manager != address(0)) {\n            treasury_manager = _treasury_manager;\n        } else {\n            // `treasury_manager` defaults to msg.sender on construction if no valid treasury_manager address passed in.\n            treasury_manager = msg.sender;\n        }\n\n        initialized = true;\n    }\n\n    function initEIP712() public {\n        super.initialize();\n    }\n\n    /* ============ External Functions ============ */\n\n    function activateCampaign(\n        uint256 _cid,\n        Operation[] calldata _op,\n        uint256[] calldata _platformFee,\n        uint256[] calldata _erc20Fee,\n        address[] calldata _erc20\n    ) external onlyManager {\n        _setFees(_cid, _op, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n\n    /**\n     * Expire a non-stake campaign. Those with asset-backed quasar_nft campaigns won't get touched.\n     * NOTE: should only reset non-stake campaigns.\n     */\n    function expireCampaign(uint256 _cid, Operation[] calldata _op) external onlyManager {\n        require(_op.length > 0, \"Array(_op) should not be empty.\");\n        for (uint256 i = 0; i < _op.length; i++) {\n            delete campaignFeeConfigs[_cid][_op[i]];\n        }\n        emit EventExpireCampaign(_cid);\n    }\n\n\n    //    /**\n    //     * Activate a stake campaign.\n    //     * @param _params bytes1: Bitwise params for stake requirements\n    //     * {\n    //     *   burnRequired,         // First bit, Require NFT burnt if staked out\n    //     *   earlyStakeOutFine     // Second bit, Whether early stake out is allowed or not\n    //     * }\n    //     * 0b00000000 0x00  => false, false\n    //     * 0b01000000 0x40  => false, true\n    //     * 0b10000000 0x80  => true, false\n    //     * 0b11000000 0xc0  => true, true\n    //     */\n    //    function activateStakeCampaign(\n    //        uint256 _cid,\n    //        address _stakeErc20,\n    //        uint256 _minStakeAmount,\n    //        uint256 _maxStakeAmount,\n    //        uint256 _lockBlockNum,\n    //        bytes1 _params,\n    //        uint256 _earlyStakeOutFine,\n    //        Operation[] calldata _op,\n    //        uint256[] calldata _platformFee,\n    //        uint256[] calldata _erc20Fee,\n    //        address[] calldata _erc20\n    //    ) external onlyManager {\n    //        require(_stakeErc20 != address(0), \"Stake Token must not be null address\");\n    //        require(_minStakeAmount > 0, \"Min stake amount should be greater than 0 for stake campaign\");\n    //        require(_minStakeAmount <= _maxStakeAmount, \"StakeAmount min should less than or equal to max\");\n    //\n    //        _setFees(_cid, _op, _platformFee, _erc20Fee, _erc20);\n    //\n    //        _setStake(_cid, _stakeErc20, _minStakeAmount, _maxStakeAmount, _lockBlockNum, _params, _earlyStakeOutFine);\n    //\n    //        emit EventActivateStakeCampaign(_cid);\n    //    }\n\n    // TODO: add merkle proof and direct `Operation` support.\n\n    function claim(uint256 _cid, IStarNFT _starNFT, uint256 _dummyId, uint256 _powah, bytes calldata _signature) external payable onlyNoPaused {\n        require(!hasMinted[_dummyId], \"Already minted\");\n        require(_verify(_hash(_starNFT, _dummyId, _powah, msg.sender), _signature), \"Invalid signature\");\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, Operation.Claim);\n        uint256 nftID = _starNFT.mint(msg.sender, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, msg.sender);\n    }\n\n    function claimBatch(uint256 _cid, IStarNFT _starNFT, uint256[] calldata _dummyIdArr, uint256[] calldata _powahArr, bytes calldata _signature) external payable onlyNoPaused {\n        require(_dummyIdArr.length > 0, \"Array(_dummyIdArr) should not be empty.\");\n        require(_powahArr.length == _dummyIdArr.length, \"Array(_powahArr) length mismatch\");\n\n        for (uint i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], \"Already minted\");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n\n        // { // scope to avoid stack too deep errors\n        _payFees(_cid, Operation.Claim);\n        require(_verify(_hashBatch(_starNFT, _dummyIdArr, _powahArr, msg.sender), _signature), \"Invalid signature\");\n        uint256[] memory nftIdArr = _starNFT.mintBatch(msg.sender, _powahArr.length, _powahArr);\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, msg.sender);\n        // }\n    }\n\n    //    function stakeIn(uint256 _cid, uint256 stakeAmount) external payable nonReentrant onlyNoPaused {\n    //        _payFees(_cid, Operation.StakeIn);\n    //        _stakeIn(_cid, stakeAmount);\n    //        emit EventStakeIn(_cid, msg.sender, stakeAmount, campaignStakeConfigs[_cid].erc20);\n    //    }\n    //\n    //    // CALL STAR_NFT*\n    //    function stakeOutQuasar(IStarNFT _starNFT, uint256 _nftID) external payable onlyStarNFT(_starNFT) nonReentrant {\n    //        require(_starNFT.isOwnerOf(msg.sender, _nftID), \"Must be owner of this Quasar NFT\");\n    //        // 1.1 get info, make sure nft has backing-asset\n    //        (uint256 _mintBlock, IERC20 _stakeToken, uint256 _amount, uint256 _cid) = _starNFT.quasarInfo(_nftID);\n    //        require(address(_stakeToken) != address(0), \"Backing-asset token must not be null address\");\n    //        require(_amount > 0, \"Backing-asset amount must be greater than 0\");\n    //        // 2. check early stake out fine if applies\n    //        _payFine(_cid, _mintBlock);\n    //        // 3. pay fee\n    //        _payFees(_cid, Operation.StakeOut);\n    //        // 4. transfer back (backed asset)\n    //        require(_stakeToken.transfer(msg.sender, _amount), \"Stake out transfer assert back failed\");\n    //        // 5. postStakeOut (quasar->star nft; burn quasar)\n    //        if (campaignStakeConfigs[_cid].burnRequired) {\n    //            _starNFT.burn(msg.sender, _nftID);\n    //        } else {\n    //            _starNFT.burnQuasar(msg.sender, _nftID);\n    //        }\n    //        emit EventStakeOut(address(_starNFT), _nftID);\n    //    }\n    //\n    //    function stakeOutSuper(IStarNFT _starNFT, uint256 _nftID) external payable onlyStarNFT(_starNFT) nonReentrant {\n    //        require(_starNFT.isOwnerOf(msg.sender, _nftID), \"Must be owner of this Super NFT\");\n    //        // 1.1 get info, make sure nft has backing-asset\n    //        (uint256 _mintBlock, IERC20[] memory _stakeToken, uint256[] memory _amount, uint256 _cid) = IStarNFT(_starNFT).superInfo(_nftID);\n    //        require(_stakeToken.length > 0, \"Array(_stakeToken) should not be empty.\");\n    //        require(_stakeToken.length == _amount.length, \"Array(_amount) length mismatch\");\n    //        // 2. check early stake out fine if applies\n    //        _payFine(_cid, _mintBlock);\n    //        // 3. pay fee\n    //        _payFees(_cid, Operation.StakeOut);\n    //        // 4. transfer back (backed asset)\n    //        for (uint256 i = 0; i < _stakeToken.length; i++) {\n    //            require(address(_stakeToken[i]) != address(0), \"Backing-asset token must not be null address\");\n    //            require(_amount[i] > 0, \"Backing-asset amount must be greater than 0\");\n    //            require(_stakeToken[i].transfer(msg.sender, _amount[i]), \"Stake out transfer assert back failed\");\n    //        }\n    //        // 5. postStakeOut (super->star nft; burn super)\n    //        if (campaignStakeConfigs[_cid].burnRequired) {\n    //            _starNFT.burn(msg.sender, _nftID);\n    //        } else {\n    //            _starNFT.burnSuper(msg.sender, _nftID);\n    //        }\n    //        emit EventStakeOut(address(_starNFT), _nftID);\n    //    }\n\n    //    function forgeNoStake(uint256 _cid, IStarNFT _starNFT, uint256[] calldata _nftIDs) external payable onlyStarNFT(_starNFT) nonReentrant onlyNoPaused {\n    //        for (uint i = 0; i < _nftIDs.length; i++) {\n    //            require(_starNFT.isOwnerOf(msg.sender, _nftIDs[i]), \"Not the owner\");\n    //        }\n    //        _payFees(_cid, Operation.Forge);\n    //        _starNFT.burnBatch(msg.sender, _nftIDs);\n    //        emit EventForgeNoStake(_cid, msg.sender, address(_starNFT), _nftIDs);\n    //    }\n\n    //    function forgeStake(uint256 _cid, IStarNFT _starNFT, uint256[] calldata _nftIDs, uint256 stakeAmount) external payable onlyStarNFT(_starNFT) nonReentrant onlyNoPaused {\n    //        for (uint i = 0; i < _nftIDs.length; i++) {\n    //            require(_starNFT.isOwnerOf(msg.sender, _nftIDs[i]), \"Not the owner\");\n    //        }\n    //        _payFees(_cid, Operation.Forge);\n    //        _stakeIn(_cid, stakeAmount);\n    //        _starNFT.burnBatch(msg.sender, _nftIDs);\n    //        emit EventForgeWithStake(_cid, msg.sender, address(_starNFT), _nftIDs, stakeAmount, campaignStakeConfigs[_cid].erc20);\n    //    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n\n    /**\n     * PRIVILEGED MODULE FUNCTION. Function that update manager address.\n     */\n    function updateManager(address newAddress) external onlyManager {\n        require(newAddress != address(0), \"Manager address must not be null address\");\n        manager = newAddress;\n    }\n\n    /**\n     * PRIVILEGED MODULE FUNCTION. Function that update treasure manager address.\n     */\n    function updateTreasureManager(address payable newAddress) external onlyTreasuryManager {\n        require(newAddress != address(0), \"Treasure manager must not be null address\");\n        treasury_manager = newAddress;\n    }\n\n    /**\n     * PRIVILEGED MODULE FUNCTION. Function that adds a validated starNFT address.\n     */\n    function addValidatedStarNFTAddress(IStarNFT _starNFT) external onlyManager {\n        require(address(_starNFT) != address(0), \"Validate StarNFT contract must not be null address\");\n        _starNFTs[_starNFT] = true;\n    }\n    /**\n     * PRIVILEGED MODULE FUNCTION. Function that removes a validated starNFT address.\n     */\n    function removeValidatedStarNFTAddress(IStarNFT _starNFT) external onlyManager {\n        require(address(_starNFT) != address(0), \"Invalidate StarNFT contract must not be null address\");\n        _starNFTs[_starNFT] = false;\n    }\n\n    /**\n     * PRIVILEGED MODULE FUNCTION. Function that withdraw fees[network] total owned by galaxy-treasury to manager.\n     * TODO: delete me after withdraw all network fee\n     */\n    function networkWithdraw() external onlyTreasuryManager {\n        // get the amount of Ether/BNB fees stored in this contract owned by galaxy-treasury\n        uint256 amount = galaxyTreasuryNetwork;\n        require(amount > 0, \"Treasury of network should be greater than 0\");\n\n        // modify state first\n        galaxyTreasuryNetwork = 0;\n        // send Ether/BNB fees to manager\n        // Manager can receive Ether/BNB since the address of manager is payable\n        (bool success,) = manager.call{value : amount}(\"\");\n        require(success, \"Failed to send Ether/BNB fees to treasury manager\");\n    }\n\n    //    /**\n    //     * PRIVILEGED MODULE FUNCTION. Function that withdraw fees[erc20] total owned by galaxy-treasury to manager.\n    //     * TODO: delete me after withdraw all erc20 fee\n    //     */\n    //    function erc20Withdraw(address erc20) external onlyTreasuryManager nonReentrant {\n    //        // get the amount of erc20 fees stored in this contract owned by galaxy-treasury\n    //        uint256 amount = galaxyTreasuryERC20[erc20];\n    //        require(amount > 0, \"Treasury of ERC20 should be greater than 0\");\n    //\n    //        // modify state first\n    //        galaxyTreasuryERC20[erc20] = 0;\n    //        // send erc20 fees to manager\n    //        require(IERC20(erc20).transfer(manager, amount), \"Failed to send Erc20 fees to treasury manager\");\n    //    }\n\n    /**\n      * @dev stake out quasar in emergency mode\n      */\n    //    function emergencyWithdrawQuasar(IStarNFT _starNFT, uint256 _nftID) external onlyStarNFT(_starNFT) nonReentrant {\n    //        require(paused, \"Not paused\");\n    //        require(_starNFT.isOwnerOf(msg.sender, _nftID), \"Must be owner of this Quasar NFT\");\n    //        // 1.1 get info, make sure nft has backing-asset\n    //        (uint256 _mintBlock, IERC20 _stakeToken, uint256 _amount, uint256 _cid) = _starNFT.quasarInfo(_nftID);\n    //        require(address(_stakeToken) != address(0), \"Backing-asset token must not be null address\");\n    //        require(_amount > 0, \"Backing-asset amount must be greater than 0\");\n    //        // 4. transfer back (backed asset)\n    //        require(_stakeToken.transfer(msg.sender, _amount), \"Stake out transfer assert back failed\");\n    //        // 5. postStakeOut (quasar->star nft; burn quasar)\n    //        if (campaignStakeConfigs[_cid].burnRequired) {\n    //            _starNFT.burn(msg.sender, _nftID);\n    //        } else {\n    //            _starNFT.burnQuasar(msg.sender, _nftID);\n    //        }\n    //        emit EventStakeOut(address(_starNFT), _nftID);\n    //    }\n\n    /**\n      * @dev stake out super in emergency mode\n      */\n    //    function emergencyWithdrawSuper(IStarNFT _starNFT, uint256 _nftID) external onlyStarNFT(_starNFT) nonReentrant {\n    //        require(paused, \"Not paused\");\n    //        require(_starNFT.isOwnerOf(msg.sender, _nftID), \"Must be owner of this Super NFT\");\n    //        // 1.1 get info, make sure nft has backing-asset\n    //        (uint256 _mintBlock, IERC20[] memory _stakeToken, uint256[] memory _amount, uint256 _cid) = IStarNFT(_starNFT).superInfo(_nftID);\n    //        require(_stakeToken.length > 0, \"Array(_stakeToken) should not be empty.\");\n    //        require(_stakeToken.length == _amount.length, \"Array(_amount) length mismatch\");\n    //        // 4. transfer back (backed asset)\n    //        for (uint256 i = 0; i < _stakeToken.length; i++) {\n    //            require(address(_stakeToken[i]) != address(0), \"Backing-asset token must not be null address\");\n    //            require(_amount[i] > 0, \"Backing-asset amount must be greater than 0\");\n    //            require(_stakeToken[i].transfer(msg.sender, _amount[i]), \"Stake out transfer assert back failed\");\n    //        }\n    //        // 5. postStakeOut (super->star nft; burn super)\n    //        if (campaignStakeConfigs[_cid].burnRequired) {\n    //            _starNFT.burn(msg.sender, _nftID);\n    //        } else {\n    //            _starNFT.burnSuper(msg.sender, _nftID);\n    //        }\n    //        emit EventStakeOut(address(_starNFT), _nftID);\n    //    }\n\n    /* ============ External Getter Functions ============ */\n\n    //    function stakeOutInfo(IStarNFT _starNFTAddress, uint256 _nft_id) external onlyStarNFT(_starNFTAddress) view returns (\n    //        bool _allowStakeOut,\n    //        uint256 _allowBlock,\n    //        bool _requireBurn,\n    //        uint256 _earlyStakeOutFine,\n    //        uint256 _noFineBlock\n    //    ) {\n    //        (uint256 _createBlock, IERC20 _stakeToken, uint256 _amount, uint256 _cid) = _starNFTAddress.quasarInfo(_nft_id);\n    //        if (address(_stakeToken) == address(0)) {\n    //            // no asset\n    //            return (false, 0, false, 0, 0);\n    //        }\n    //        _requireBurn = campaignStakeConfigs[_cid].burnRequired;\n    //        //        uint256 lockBlockNum = campaignStakeConfigs[_cid].lockBlockNum;\n    //        if (block.number >= campaignStakeConfigs[_cid].lockBlockNum.add(_createBlock)) {\n    //            return (true, 0, _requireBurn, 0, 0);\n    //        }\n    //        _allowBlock = campaignStakeConfigs[_cid].lockBlockNum + _createBlock;\n    //        if (!campaignStakeConfigs[_cid].isEarlyStakeOutAllowed) {\n    //            // not allow early stakeout\n    //            return (false, _allowBlock, _requireBurn, 0, 0);\n    //        }\n    //        _allowStakeOut = true;\n    //        _allowBlock = _createBlock;\n    //        _noFineBlock = _createBlock + campaignStakeConfigs[_cid].lockBlockNum;\n    //        _earlyStakeOutFine = _noFineBlock\n    //        .sub(block.number)\n    //        .mul(10000)\n    //        .mul(campaignStakeConfigs[_cid].earlyStakeOutFine)\n    //        .div(campaignStakeConfigs[_cid].lockBlockNum)\n    //        .div(10000);\n    //    }\n    //\n    //    function superStakeOutInfo(IStarNFT _starNFTAddress, uint256 _nft_id) external onlyStarNFT(_starNFTAddress) view returns (\n    //        bool _allowStakeOut,\n    //        uint256 _allowBlock,\n    //        bool _requireBurn,\n    //        uint256 _earlyStakeOutFine,\n    //        uint256 _noFineBlock\n    //    ) {\n    //        (uint256 _createBlock, IERC20[] memory _stakeToken, , uint256 _cid) = _starNFTAddress.superInfo(_nft_id);\n    //        if (_stakeToken.length == 0) {\n    //            // no asset\n    //            return (false, 0, false, 0, 0);\n    //        }\n    //        _requireBurn = campaignStakeConfigs[_cid].burnRequired;\n    //        //        uint256 lockBlockNum = campaignStakeConfigs[_cid].lockBlockNum;\n    //        if (block.number >= campaignStakeConfigs[_cid].lockBlockNum.add(_createBlock)) {\n    //            return (true, 0, _requireBurn, 0, 0);\n    //        }\n    //        _allowBlock = campaignStakeConfigs[_cid].lockBlockNum + _createBlock;\n    //        if (!campaignStakeConfigs[_cid].isEarlyStakeOutAllowed) {\n    //            // not allow early stakeout\n    //            return (false, _allowBlock, _requireBurn, 0, 0);\n    //        }\n    //        _allowStakeOut = true;\n    //        _allowBlock = _createBlock;\n    //        _noFineBlock = _createBlock + campaignStakeConfigs[_cid].lockBlockNum;\n    //        _earlyStakeOutFine = _noFineBlock\n    //        .sub(block.number)\n    //        .mul(10000)\n    //        .mul(campaignStakeConfigs[_cid].earlyStakeOutFine)\n    //        .div(campaignStakeConfigs[_cid].lockBlockNum)\n    //        .div(10000);\n    //    }\n\n    function isValidatedStarNFTAddress(IStarNFT _starNFT) external returns (bool) {\n        return _starNFTs[_starNFT];\n    }\n\n    /* ============ Internal Functions ============ */\n    function _hash(IStarNFT _starNFT, uint256 _dummyId, uint256 _powah, address _account) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(abi.encode(\n                keccak256(\"NFT(address starNFT,uint256 dummyId,uint256 powah,address account)\"),\n                _starNFT, _dummyId, _powah, _account\n            )));\n    }\n\n    function _hashBatch(IStarNFT _starNFT, uint256[] calldata _dummyIdArr, uint256[] calldata _powahArr, address _account) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(abi.encode(\n                keccak256(\"NFT(address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)\"),\n                _starNFT, _dummyIdArr, _powahArr, _account\n            )));\n    }\n\n    function _verify(bytes32 digest, bytes calldata signature) internal view returns (bool) {\n        return ECDSA.recover(digest, signature) == manager;\n    }\n\n    //    // TODO: delete me, Only for sig testing purpose.\n    //    function _verifyGetSigner(bytes32 digest, bytes calldata signature) public view returns (address, bool) {\n    //        return (ECDSA.recover(digest, signature), ECDSA.recover(digest, signature) == manager);\n    //    }\n    //    function _setManagerForSigTest(address tmp) external {\n    //        manager = tmp;\n    //    }\n\n    function _setFees(\n        uint256 _cid,\n        Operation[] calldata _op,\n        uint256[] calldata _platformFee,\n        uint256[] calldata _erc20Fee,\n        address[] calldata _erc20\n    ) private {\n        require(_op.length > 0, \"Array(_op) should not be empty.\");\n        // Don't use validate arrays because empty arrays are valid\n        require(_op.length == _platformFee.length, \"Array(_platformFee) length mismatch\");\n        require(_op.length == _erc20Fee.length, \"Array(_erc20Fee) length mismatch\");\n        require(_op.length == _erc20.length, \"Array(_erc20) length mismatch\");\n\n        for (uint256 i = 0; i < _op.length; i++) {\n            require((_erc20[i] == address(0) && _erc20Fee[i] == 0) || (_erc20[i] != address(0) && _erc20Fee[i] != 0), \"Invalid erc20 fee requirement arguments\");\n            campaignFeeConfigs[_cid][_op[i]] = CampaignFeeConfig(_erc20[i], _erc20Fee[i], _platformFee[i], true);\n        }\n    }\n\n    //    function _setStake(\n    //        uint256 _cid,\n    //        address _erc20,\n    //        uint256 _minStakeAmount,\n    //        uint256 _maxStakeAmount,\n    //        uint256 _lockBlockNum,\n    //        bytes1 _params,\n    //        uint256 _earlyStakeOutFine\n    //    ) private {\n    //        campaignStakeConfigs[_cid] = CampaignStakeConfig(\n    //            _erc20,\n    //            _minStakeAmount,\n    //            _maxStakeAmount,\n    //            _lockBlockNum,\n    //            _params & bytes1(0x80) != 0,\n    //            _params & bytes1(0x40) != 0,\n    //            _earlyStakeOutFine\n    //        );\n    //    }\n\n    function _payFees(uint256 _cid, Operation _op) private {\n        require(campaignFeeConfigs[_cid][Operation.Default].isActive, \"Operation(DEFAULT) should be activated\");\n\n        // 0. which fee record to use\n        Operation op_key = campaignFeeConfigs[_cid][_op].isActive ? _op : Operation.Default;\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid][op_key];\n        // 1. pay platformFee if needed\n        if (feeConf.platformFee > 0) {\n            (bool success,) = treasury_manager.call{value : feeConf.platformFee}(new bytes(0));\n            require(success, 'Platform fee transfer failed');\n        }\n        // 2. pay erc20_fee if needed\n        if (feeConf.erc20Fee > 0) {\n            // user wallet transfer <erc20> of <feeConf.erc20Fee> to <this contract>.\n            require(IERC20(feeConf.erc20).transferFrom(msg.sender, treasury_manager, feeConf.erc20Fee), \"Transfer erc20_fee failed\");\n        }\n    }\n\n    //    function _payFine(uint256 _cid, uint256 _mintBlock) private {\n    //        uint256 lockBlockNum = campaignStakeConfigs[_cid].lockBlockNum;\n    //        // 1.2 only need to check early-stake-out config if lock up time has not been met yet\n    //        if (block.number < _mintBlock + lockBlockNum) {\n    //            require(campaignStakeConfigs[_cid].isEarlyStakeOutAllowed, \"Early stake out not allowed\");\n    //            // calc fine if allow early stake out\n    //            uint256 _fine = (_mintBlock + lockBlockNum)\n    //            .sub(block.number)\n    //            .mul(10000)\n    //            .mul(campaignStakeConfigs[_cid].earlyStakeOutFine)\n    //            .div(lockBlockNum)\n    //            .div(10000);\n    //            // Fine will be adding to treasury with platformFee in _payFees() if applies.\n    //            // require(msg.value >= campaignFeeConfigs[_cid][Operation.StakeOut].platformFee.add(_fine), \"Insufficient fine\");\n    //            // stakeOutQuasar and stakeOutSuper doesn't need pay network fee\n    //            uint256 total = _fine.add(campaignFeeConfigs[_cid][Operation.StakeOut].platformFee);\n    //            require(msg.value >= total, \"Insufficient fine\");\n    //            // transfer fine and platform fee\n    //            if (total > 0) {\n    //                (bool success,) = treasury_manager.call{value : total}(new bytes(0));\n    //                require(success, 'Platform fee and fine transfer failed');\n    //            }\n    //        }\n    //    }\n\n    //    function _stakeIn(uint256 _cid, uint256 stakeAmount) private {\n    //        // Stake in if needed\n    //        require(campaignStakeConfigs[_cid].erc20 != address(0), \"Stake campaign should be activated\");\n    //        require(stakeAmount >= campaignStakeConfigs[_cid].minStakeAmount, \"StakeAmount should >= minStakeAmount\");\n    //        require(stakeAmount <= campaignStakeConfigs[_cid].maxStakeAmount, \"StakeAmount should <= maxStakeAmount\");\n    //        // transfer <erc20> of <stakeAmount> to <this contract> from user wallet.\n    //        require(IERC20(campaignStakeConfigs[_cid].erc20).transferFrom(msg.sender, address(this), stakeAmount), \"Stake in erc20 failed\");\n    //    }\n\n    /**\n     * Due to reason error bloat, internal functions are used to reduce bytecode size\n     */\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, \"Only manager can call\");\n    }\n\n    function _validateOnlyTreasuryManager() internal view {\n        require(msg.sender == treasury_manager, \"Only treasury manager can call\");\n    }\n\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, \"Contract paused\");\n    }\n}\n","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"}],\"name\":\"EventActivateCampaign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"}],\"name\":\"EventActivateStakeCampaign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_dummyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"EventClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_dummyIdArr\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_nftIDArr\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"EventClaimBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"}],\"name\":\"EventExpireCampaign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_nftIDs\",\"type\":\"uint256[]\"}],\"name\":\"EventForgeNoStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_nftIDs\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"}],\"name\":\"EventForgeWithStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"}],\"name\":\"EventStakeIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_nftID\",\"type\":\"uint256\"}],\"name\":\"EventStakeOut\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"internalType\":\"enum SpaceStation.Operation[]\",\"name\":\"_op\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_platformFee\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_erc20Fee\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_erc20\",\"type\":\"address[]\"}],\"name\":\"activateCampaign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"}],\"name\":\"addValidatedStarNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"enum SpaceStation.Operation\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"campaignFeeConfigs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"erc20Fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"platformFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"campaignStakeConfigs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockBlockNum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"burnRequired\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEarlyStakeOutAllowed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"earlyStakeOutFine\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_dummyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_powah\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_dummyIdArr\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powahArr\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"claimBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cid\",\"type\":\"uint256\"},{\"internalType\":\"enum SpaceStation.Operation[]\",\"name\":\"_op\",\"type\":\"uint8[]\"}],\"name\":\"expireCampaign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"galaxyTreasuryERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"galaxyTreasuryNetwork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hasMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initEIP712\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury_manager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"}],\"name\":\"isValidatedStarNFTAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStarNFT\",\"name\":\"_starNFT\",\"type\":\"address\"}],\"name\":\"removeValidatedStarNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury_manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateTreasureManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SpaceStation","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":""}]}