{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v1/markets/eth/uniswap/UniswapV3Exchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"../../../../../interfaces/exchanges/IUniV3.sol\\\";\\nimport \\\"../../../../../interfaces/markets/tokens/IERC20.sol\\\";\\n\\nlibrary UniswapV3Exchange {\\n\\n    address public constant DEX = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n        bool isInputEth;\\n    }\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address tokenIn;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        bool isInputEth;\\n    }\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n        bool isInputEth;\\n    }\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address tokenIn;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        bool isInputEth;\\n    }\\n\\n    struct MultiCall {\\n        bytes[] data;\\n        address tokenIn;\\n        uint256 amountIn;\\n        bool isInputEth;\\n    }\\n\\n    function _checkCallResult(bool _success) internal pure {\\n        if (!_success) {\\n            // Copy revert reason from call\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function _approve(address _token, uint256 _amount, bool isInputEth) internal {\\n        if (!isInputEth) {\\n            if (IERC20(_token).allowance(address(this), DEX) < _amount) {\\n                IERC20(_token).approve(DEX, ~uint256(0));\\n            }\\n        }\\n    }\\n\\n    function exactInputSingle(ExactInputSingleParams calldata params) external {\\n        // approve token if needed\\n        _approve(params.tokenIn, params.amountIn, params.isInputEth);\\n        \\n        bytes memory _data = abi.encodeWithSelector(\\n            IUniV3.exactInputSingle.selector,\\n            params.tokenIn,\\n            params.tokenOut,\\n            params.fee,\\n            params.recipient,\\n            params.deadline,\\n            params.amountIn,\\n            params.amountOutMinimum,\\n            params.sqrtPriceLimitX96\\n        );\\n        \\n        (bool success, ) = DEX.call{value: params.isInputEth ? params.amountIn : 0}(_data);\\n        \\n        _checkCallResult(success);\\n    }\\n\\n    function exactInput(ExactInputParams calldata params) external {\\n        // approve token if needed\\n        _approve(params.tokenIn, params.amountIn, params.isInputEth);\\n\\n        bytes memory _data = abi.encodeWithSelector(\\n            IUniV3.exactInput.selector,\\n            params.path,\\n            params.recipient,\\n            params.deadline,\\n            params.amountIn,\\n            params.amountOutMinimum\\n        );\\n        \\n        (bool success, ) = DEX.call{value: params.isInputEth ? params.amountIn : 0}(_data);\\n        \\n        _checkCallResult(success);\\n    }\\n\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external {\\n        // approve token if needed\\n        _approve(params.tokenIn, params.amountInMaximum, params.isInputEth);\\n\\n        bytes memory _data = abi.encodeWithSelector(\\n            IUniV3.exactOutputSingle.selector,\\n            params.tokenIn,\\n            params.tokenOut,\\n            params.fee,\\n            params.recipient,\\n            params.deadline,\\n            params.amountOut,\\n            params.amountInMaximum,\\n            params.sqrtPriceLimitX96\\n        );\\n        \\n        (bool success, ) = DEX.call{value: params.isInputEth ? params.amountInMaximum : 0}(_data);\\n        \\n        _checkCallResult(success);\\n    }\\n\\n    function exactOutput(ExactOutputParams calldata params) external {\\n        // approve token if needed\\n        _approve(params.tokenIn, params.amountInMaximum, params.isInputEth);\\n\\n        bytes memory _data = abi.encodeWithSelector(\\n            IUniV3.exactOutputSingle.selector,\\n            params.path,\\n            params.recipient,\\n            params.deadline,\\n            params.amountOut,\\n            params.amountInMaximum\\n        );\\n        \\n        (bool success, ) = DEX.call{value: params.isInputEth ? params.amountInMaximum : 0}(_data);\\n        \\n        _checkCallResult(success);\\n    }\\n\\n    function multicall(MultiCall calldata params) external {\\n        // approve token if needed\\n        _approve(params.tokenIn, params.amountIn, params.isInputEth);\\n        \\n        bytes memory _data = abi.encodeWithSelector(\\n            IUniV3.multicall.selector,\\n            params.data\\n        );\\n\\n        (bool success, ) = DEX.call{value: params.isInputEth ? params.amountIn : 0}(_data);\\n        \\n        _checkCallResult(success);\\n    }\\n}\"\r\n    },\r\n    \"interfaces/exchanges/IUniV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IUniV3 {\\n    \\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n    \\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n\\n    /// @notice Enables calling multiple methods in a single call to the contract\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\n}\"\r\n    },\r\n    \"interfaces/markets/tokens/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IERC20 {\\n    /**\\n        * @dev Returns the amount of tokens owned by `account`.\\n        */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n        *\\n        * Returns a boolean value indicating whether the operation succeeded.\\n        *\\n        * Emits a {Transfer} event.\\n        */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"DEX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniswapV3Exchange","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}