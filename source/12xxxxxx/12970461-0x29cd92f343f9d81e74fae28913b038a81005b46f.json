{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n\\n  constructor(\\n    address newOwner\\n  )\\n    ConfirmedOwnerWithProposal(\\n      newOwner,\\n      address(0)\\n    )\\n  {\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(\\n    address indexed from,\\n    address indexed to\\n  );\\n  event OwnershipTransferred(\\n    address indexed from,\\n    address indexed to\\n  );\\n\\n  constructor(\\n    address newOwner,\\n    address pendingOwner\\n  ) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(\\n    address to\\n  )\\n    public\\n    override\\n    onlyOwner()\\n  {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership()\\n    external\\n    override\\n  {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner()\\n    public\\n    view\\n    override\\n    returns (\\n      address\\n    )\\n  {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(\\n    address to\\n  )\\n    private\\n  {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership()\\n    internal\\n    view\\n  {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner()\\n    external\\n    returns (\\n      address\\n    );\\n\\n  function transferOwnership(\\n    address recipient\\n  )\\n    external;\\n\\n  function acceptOwnership()\\n    external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ValidatorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"./interfaces/TypeAndVersionInterface.sol\\\";\\n\\ncontract ValidatorProxy is AggregatorValidatorInterface, TypeAndVersionInterface, ConfirmedOwner {\\n\\n  /// @notice Uses a single storage slot to store the current address\\n  struct AggregatorConfiguration {\\n    address target;\\n    bool hasNewProposal;\\n  }\\n\\n  struct ValidatorConfiguration {\\n    AggregatorValidatorInterface target;\\n    bool hasNewProposal;\\n  }\\n\\n  // Configuration for the current aggregator\\n  AggregatorConfiguration private s_currentAggregator;\\n  // Proposed aggregator address\\n  address private s_proposedAggregator;\\n\\n  // Configuration for the current validator\\n  ValidatorConfiguration private s_currentValidator;\\n  // Proposed validator address\\n  AggregatorValidatorInterface private s_proposedValidator;\\n\\n  event AggregatorProposed(\\n    address indexed aggregator\\n  );\\n  event AggregatorUpgraded(\\n    address indexed previous,\\n    address indexed current\\n  );\\n  event ValidatorProposed(\\n    AggregatorValidatorInterface indexed validator\\n  );\\n  event ValidatorUpgraded(\\n    AggregatorValidatorInterface indexed previous,\\n    AggregatorValidatorInterface indexed current\\n  );\\n  /// @notice The proposed aggregator called validate, but the call was not passed on to any validators\\n  event ProposedAggregatorValidateCall(\\n    address indexed proposed,\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  );\\n\\n  /**\\n   * @notice Construct the ValidatorProxy with an aggregator and a validator\\n   * @param aggregator address\\n   * @param validator address\\n   */\\n  constructor(\\n    address aggregator,\\n    AggregatorValidatorInterface validator\\n  )\\n    ConfirmedOwner(msg.sender)\\n  {\\n    s_currentAggregator = AggregatorConfiguration({\\n      target: aggregator,\\n      hasNewProposal: false\\n    });\\n    s_currentValidator = ValidatorConfiguration({\\n      target: validator,\\n      hasNewProposal: false\\n    });\\n  }\\n\\n  /**\\n   * @notice Validate a transmission\\n   * @dev Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`.\\n   * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target`\\n   * and the `s_proposedValidator`, if it is set.\\n   * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that\\n   * the call was received.\\n   * @dev To guard against external `validate` calls reverting, we use raw calls here.\\n   * We favour `call` over try-catch to ensure that failures are avoided even if the validator address is incorrectly\\n   * set as a non-contract address.\\n   * @dev If the `aggregator` and `validator` are the same contract or collude, this could exhibit reentrancy behavior.\\n   * However, since that contract would have to be explicitly written for reentrancy and that the `owner` would have\\n   * to configure this contract to use that malicious contract, we refrain from using mutex or check here.\\n   * @dev This does not perform any checks on any roundId, so it is possible that a validator receive different reports\\n   * for the same roundId at different points in time. Validator implementations should be aware of this.\\n   * @param previousRoundId uint256\\n   * @param previousAnswer int256\\n   * @param currentRoundId uint256\\n   * @param currentAnswer int256\\n   * @return bool\\n   */\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  )\\n    external\\n    override\\n    returns (\\n      bool\\n    )\\n  {\\n    address currentAggregator = s_currentAggregator.target;\\n    if (msg.sender != currentAggregator) {\\n      address proposedAggregator = s_proposedAggregator;\\n      require(msg.sender == proposedAggregator, \\\"Not a configured aggregator\\\");\\n      // If the aggregator is still in proposed state, emit an event and don't push to any validator.\\n      // This is to confirm that `validate` is being called prior to upgrade.\\n      emit ProposedAggregatorValidateCall(\\n        proposedAggregator,\\n        previousRoundId,\\n        previousAnswer,\\n        currentRoundId,\\n        currentAnswer\\n      );\\n      return true;\\n    }\\n\\n    // Send the validate call to the current validator\\n    ValidatorConfiguration memory currentValidator = s_currentValidator;\\n    address currentValidatorAddress = address(currentValidator.target);\\n    require(currentValidatorAddress != address(0), \\\"No validator set\\\");\\n    currentValidatorAddress.call(\\n      abi.encodeWithSelector(\\n        AggregatorValidatorInterface.validate.selector,\\n        previousRoundId,\\n        previousAnswer,\\n        currentRoundId,\\n        currentAnswer\\n      )\\n    );\\n    // If there is a new proposed validator, send the validate call to that validator also\\n    if (currentValidator.hasNewProposal) {\\n      address(s_proposedValidator).call(\\n        abi.encodeWithSelector(\\n          AggregatorValidatorInterface.validate.selector,\\n          previousRoundId,\\n          previousAnswer,\\n          currentRoundId,\\n          currentAnswer\\n        )\\n      );\\n    }\\n    return true;\\n  }\\n\\n  /** AGGREGATOR CONFIGURATION FUNCTIONS **/\\n\\n  /**\\n   * @notice Propose an aggregator\\n   * @dev A zero address can be used to unset the proposed aggregator. Only owner can call.\\n   * @param proposed address\\n   */\\n  function proposeNewAggregator(\\n    address proposed\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    require(s_proposedAggregator != proposed && s_currentAggregator.target != proposed, \\\"Invalid proposal\\\");\\n    s_proposedAggregator = proposed;\\n    // If proposed is zero address, hasNewProposal = false\\n    s_currentAggregator.hasNewProposal = (proposed != address(0));\\n    emit AggregatorProposed(proposed);\\n  }\\n\\n  /**\\n   * @notice Upgrade the aggregator by setting the current aggregator as the proposed aggregator.\\n   * @dev Must have a proposed aggregator. Only owner can call.\\n   */\\n  function upgradeAggregator()\\n    external\\n    onlyOwner()\\n  {\\n    // Get configuration in memory\\n    AggregatorConfiguration memory current = s_currentAggregator;\\n    address previous = current.target;\\n    address proposed = s_proposedAggregator;\\n\\n    // Perform the upgrade\\n    require(current.hasNewProposal, \\\"No proposal\\\");\\n    s_currentAggregator = AggregatorConfiguration({\\n      target: proposed,\\n      hasNewProposal: false\\n    });\\n    delete s_proposedAggregator;\\n\\n    emit AggregatorUpgraded(previous, proposed);\\n  }\\n\\n  /**\\n   * @notice Get aggregator details\\n   * @return current address\\n   * @return hasProposal bool\\n   * @return proposed address\\n   */\\n  function getAggregators()\\n    external\\n    view\\n    returns(\\n      address current,\\n      bool hasProposal,\\n      address proposed\\n    )\\n  {\\n    current = s_currentAggregator.target;\\n    hasProposal = s_currentAggregator.hasNewProposal;\\n    proposed = s_proposedAggregator;\\n  }\\n\\n  /** VALIDATOR CONFIGURATION FUNCTIONS **/\\n\\n  /**\\n   * @notice Propose an validator\\n   * @dev A zero address can be used to unset the proposed validator. Only owner can call.\\n   * @param proposed address\\n   */\\n  function proposeNewValidator(\\n    AggregatorValidatorInterface proposed\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    require(s_proposedValidator != proposed && s_currentValidator.target != proposed, \\\"Invalid proposal\\\");\\n    s_proposedValidator = proposed;\\n    // If proposed is zero address, hasNewProposal = false\\n    s_currentValidator.hasNewProposal = (address(proposed) != address(0));\\n    emit ValidatorProposed(proposed);\\n  }\\n\\n  /**\\n   * @notice Upgrade the validator by setting the current validator as the proposed validator.\\n   * @dev Must have a proposed validator. Only owner can call.\\n   */\\n  function upgradeValidator()\\n    external\\n    onlyOwner()\\n  {\\n    // Get configuration in memory\\n    ValidatorConfiguration memory current = s_currentValidator;\\n    AggregatorValidatorInterface previous = current.target;\\n    AggregatorValidatorInterface proposed = s_proposedValidator;\\n\\n    // Perform the upgrade\\n    require(current.hasNewProposal, \\\"No proposal\\\");\\n    s_currentValidator = ValidatorConfiguration({\\n      target: proposed,\\n      hasNewProposal: false\\n    });\\n    delete s_proposedValidator;\\n\\n    emit ValidatorUpgraded(previous, proposed);\\n  }\\n\\n  /**\\n   * @notice Get validator details\\n   * @return current address\\n   * @return hasProposal bool\\n   * @return proposed address\\n   */\\n  function getValidators()\\n    external\\n    view\\n    returns(\\n      AggregatorValidatorInterface current,\\n      bool hasProposal,\\n      AggregatorValidatorInterface proposed\\n    )\\n  {\\n    current = s_currentValidator.target;\\n    hasProposal = s_currentValidator.hasNewProposal;\\n    proposed = s_proposedValidator;\\n  }\\n\\n  /**\\n   * @notice The type and version of this contract\\n   * @return Type and version string\\n   */\\n  function typeAndVersion()\\n    external\\n    pure\\n    virtual\\n    override\\n    returns (\\n      string memory\\n    )\\n  {\\n    return \\\"ValidatorProxy 1.0.0\\\";\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorValidatorInterface.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorValidatorInterface {\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  )\\n    external\\n    returns (\\n      bool\\n    );\\n}\"\r\n    },\r\n    \"src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface{\\n  function typeAndVersion()\\n    external\\n    pure\\n    virtual\\n    returns (\\n      string memory\\n    );\\n}\"\r\n    },\r\n    \"src/v0.8/dev/Flags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"../SimpleReadAccessController.sol\\\";\\nimport \\\"../interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\n\\n/* dev dependencies - to be re/moved after audit */\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\n\\n/**\\n * @title The Flags contract\\n * @notice Allows flags to signal to any reader on the access control list.\\n * The owner can set flags, or designate other addresses to set flags. \\n * Raise flag actions are controlled by its own access controller.\\n * Lower flag actions are controlled by its own access controller.\\n * An expected pattern is to allow addresses to raise flags on themselves, so if you are subscribing to\\n * FlagOn events you should filter for addresses you care about.\\n */\\ncontract Flags is TypeAndVersionInterface, FlagsInterface, SimpleReadAccessController {\\n\\n  AccessControllerInterface public raisingAccessController;\\n  AccessControllerInterface public loweringAccessController;\\n\\n  mapping(address => bool) private flags;\\n\\n  event FlagRaised(\\n    address indexed subject\\n  );\\n  event FlagLowered(\\n    address indexed subject\\n  );\\n  event RaisingAccessControllerUpdated(\\n    address indexed previous,\\n    address indexed current\\n  );\\n  event LoweringAccessControllerUpdated(\\n    address indexed previous,\\n    address indexed current\\n  );\\n\\n  /**\\n   * @param racAddress address for the raising access controller.\\n   * @param lacAddress address for the lowering access controller.\\n   */\\n  constructor(\\n    address racAddress,\\n    address lacAddress\\n  ) {\\n    setRaisingAccessController(racAddress);\\n    setLoweringAccessController(lacAddress);\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - Flags 1.1.0: upgraded to solc 0.8, added lowering access controller\\n   * - Flags 1.0.0: initial release\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion()\\n    external\\n    pure\\n    virtual\\n    override\\n    returns (\\n      string memory\\n    )\\n  {\\n    return \\\"Flags 1.1.0\\\";\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subject The contract address being checked for a flag.\\n   * @return A true value indicates that a flag was raised and a\\n   * false value indicates that no flag was raised.\\n   */\\n  function getFlag(\\n    address subject\\n  )\\n    external\\n    view\\n    override\\n    checkAccess()\\n    returns (bool)\\n  {\\n    return flags[subject];\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subjects An array of addresses being checked for a flag.\\n   * @return An array of bools where a true value for any flag indicates that\\n   * a flag was raised and a false value indicates that no flag was raised.\\n   */\\n  function getFlags(\\n    address[] calldata subjects\\n  )\\n    external\\n    view\\n    override\\n    checkAccess()\\n    returns (bool[] memory)\\n  {\\n    bool[] memory responses = new bool[](subjects.length);\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      responses[i] = flags[subjects[i]];\\n    }\\n    return responses;\\n  }\\n\\n  /**\\n   * @notice enable the warning flag for an address.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subject The contract address whose flag is being raised\\n   */\\n  function raiseFlag(\\n    address subject\\n  )\\n    external\\n    override\\n  {\\n    require(_allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    _tryToRaiseFlag(subject);\\n  }\\n\\n  /**\\n   * @notice enable the warning flags for multiple addresses.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subjects List of the contract addresses whose flag is being raised\\n   */\\n  function raiseFlags(\\n    address[] calldata subjects\\n  )\\n    external\\n    override\\n  {\\n    require(_allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      _tryToRaiseFlag(subjects[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to disable the warning flags for an addresses.\\n   * Access is controlled by loweringAccessController, except for owner\\n   * who always has access.\\n   * @param subject The contract address whose flag is being lowered\\n   */\\n  function lowerFlag(\\n    address subject\\n  )\\n    external\\n    override\\n  {\\n    require(_allowedToLowerFlags(), \\\"Not allowed to lower flags\\\");\\n\\n    _tryToLowerFlag(subject);\\n  }\\n\\n  /**\\n   * @notice allows owner to disable the warning flags for multiple addresses.\\n   * Access is controlled by loweringAccessController, except for owner\\n   * who always has access.\\n   * @param subjects List of the contract addresses whose flag is being lowered\\n   */\\n  function lowerFlags(\\n    address[] calldata subjects\\n  )\\n    external\\n    override\\n  {\\n    require(_allowedToLowerFlags(), \\\"Not allowed to lower flags\\\");\\n\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      address subject = subjects[i];\\n\\n      _tryToLowerFlag(subject);\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to change the access controller for raising flags.\\n   * @param racAddress new address for the raising access controller.\\n   */\\n  function setRaisingAccessController(\\n    address racAddress\\n  )\\n    public\\n    override\\n    onlyOwner()\\n  {\\n    address previous = address(raisingAccessController);\\n\\n    if (previous != racAddress) {\\n      raisingAccessController = AccessControllerInterface(racAddress);\\n\\n      emit RaisingAccessControllerUpdated(previous, racAddress);\\n    }\\n  }\\n\\n  function setLoweringAccessController(\\n    address lacAddress\\n  )\\n    public\\n    override\\n    onlyOwner()\\n  {\\n    address previous = address(loweringAccessController);\\n\\n    if (previous != lacAddress) {\\n      loweringAccessController = AccessControllerInterface(lacAddress);\\n\\n      emit LoweringAccessControllerUpdated(previous, lacAddress);\\n    }\\n  }\\n\\n\\n  // PRIVATE\\n  function _allowedToRaiseFlags()\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return msg.sender == owner() ||\\n      raisingAccessController.hasAccess(msg.sender, msg.data);\\n  }\\n\\n  function _allowedToLowerFlags()\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return msg.sender == owner() ||\\n      loweringAccessController.hasAccess(msg.sender, msg.data);\\n  }\\n\\n  function _tryToRaiseFlag(\\n    address subject\\n  )\\n    private\\n  {\\n    if (!flags[subject]) {\\n      flags[subject] = true;\\n      emit FlagRaised(subject);\\n    }\\n  }\\n\\n  function _tryToLowerFlag(\\n    address subject\\n  )\\n    private\\n  {\\n    if (flags[subject]) {\\n      flags[subject] = false;\\n      emit FlagLowered(subject);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/SimpleReadAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SimpleWriteAccessController.sol\\\";\\n\\n/**\\n * @title SimpleReadAccessController\\n * @notice Gives access to:\\n * - any externally owned account (note that offchain actors can always read\\n * any contract storage regardless of onchain access control measures, so this\\n * does not weaken the access control while improving usability)\\n * - accounts explicitly added to an access list\\n * @dev SimpleReadAccessController is not suitable for access controlling writes\\n * since it grants any externally owned account access! See\\n * SimpleWriteAccessController for that.\\n */\\ncontract SimpleReadAccessController is SimpleWriteAccessController {\\n\\n  /**\\n   * @notice Returns the access of an address\\n   * @param _user The address to query\\n   */\\n  function hasAccess(\\n    address _user,\\n    bytes memory _calldata\\n  )\\n    public\\n    view\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AccessControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AccessControllerInterface {\\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/interfaces/FlagsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface FlagsInterface {\\n  function getFlag(address) external view returns (bool);\\n  function getFlags(address[] calldata) external view returns (bool[] memory);\\n  function raiseFlag(address) external;\\n  function raiseFlags(address[] calldata) external;\\n  function lowerFlag(address) external;\\n  function lowerFlags(address[] calldata) external;\\n  function setRaisingAccessController(address) external;\\n  function setLoweringAccessController(address) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/SimpleWriteAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/AccessControllerInterface.sol\\\";\\n\\n/**\\n * @title SimpleWriteAccessController\\n * @notice Gives access to accounts explicitly added to an access list by the\\n * controller's owner.\\n * @dev does not make any special permissions for externally, see\\n * SimpleReadAccessController for that.\\n */\\ncontract SimpleWriteAccessController is AccessControllerInterface, ConfirmedOwner {\\n\\n  bool public checkEnabled;\\n  mapping(address => bool) internal accessList;\\n\\n  event AddedAccess(address user);\\n  event RemovedAccess(address user);\\n  event CheckAccessEnabled();\\n  event CheckAccessDisabled();\\n\\n  constructor() \\n    ConfirmedOwner(msg.sender) \\n  {\\n    checkEnabled = true;\\n  }\\n\\n  /**\\n   * @notice Returns the access of an address\\n   * @param _user The address to query\\n   */\\n  function hasAccess(\\n    address _user,\\n    bytes memory\\n  )\\n    public\\n    view\\n    virtual\\n    override\\n    returns (bool)\\n  {\\n    return accessList[_user] || !checkEnabled;\\n  }\\n\\n  /**\\n   * @notice Adds an address to the access list\\n   * @param _user The address to add\\n   */\\n  function addAccess(address _user)\\n    external\\n    onlyOwner()\\n  {\\n    if (!accessList[_user]) {\\n      accessList[_user] = true;\\n\\n      emit AddedAccess(_user);\\n    }\\n  }\\n\\n  /**\\n   * @notice Removes an address from the access list\\n   * @param _user The address to remove\\n   */\\n  function removeAccess(address _user)\\n    external\\n    onlyOwner()\\n  {\\n    if (accessList[_user]) {\\n      accessList[_user] = false;\\n\\n      emit RemovedAccess(_user);\\n    }\\n  }\\n\\n  /**\\n   * @notice makes the access check enforced\\n   */\\n  function enableAccessCheck()\\n    external\\n    onlyOwner()\\n  {\\n    if (!checkEnabled) {\\n      checkEnabled = true;\\n\\n      emit CheckAccessEnabled();\\n    }\\n  }\\n\\n  /**\\n   * @notice makes the access check unenforced\\n   */\\n  function disableAccessCheck()\\n    external\\n    onlyOwner()\\n  {\\n    if (checkEnabled) {\\n      checkEnabled = false;\\n\\n      emit CheckAccessDisabled();\\n    }\\n  }\\n\\n  /**\\n   * @dev reverts if the caller does not have access\\n   */\\n  modifier checkAccess() {\\n    require(hasAccess(msg.sender, msg.data), \\\"No access\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/ArbitrumValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"../interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"../SimpleWriteAccessController.sol\\\";\\n\\n/* dev dependencies - to be re/moved after audit */\\nimport \\\"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol\\\";\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\n\\n/**\\n * @title ArbitrumValidator\\n * @notice Allows to raise and lower Flags on the Arbitrum network through its Layer 1 contracts\\n *  - The internal AccessController controls the access of the validate method\\n *  - Gas configuration is controlled by a configurable external SimpleWriteAccessController\\n *  - Funds on the contract are managed by the owner\\n */\\ncontract ArbitrumValidator is TypeAndVersionInterface, AggregatorValidatorInterface, SimpleWriteAccessController {\\n  // Config for L1 -> L2 `createRetryableTicket` call\\n  struct GasConfiguration {\\n    uint256 maxSubmissionCost;\\n    uint256 maxGasPrice;\\n    uint256 gasCostL2;\\n    uint256 gasLimitL2;\\n    address refundableAddress;\\n  }\\n\\n  /// @dev Follows: https://eips.ethereum.org/EIPS/eip-1967\\n  address constant private FLAG_ARBITRUM_SEQ_OFFLINE = address(bytes20(bytes32(uint256(keccak256(\\\"chainlink.flags.arbitrum-seq-offline\\\")) - 1)));\\n  bytes constant private CALL_RAISE_FLAG = abi.encodeWithSelector(FlagsInterface.raiseFlag.selector, FLAG_ARBITRUM_SEQ_OFFLINE);\\n  bytes constant private CALL_LOWER_FLAG = abi.encodeWithSelector(FlagsInterface.lowerFlag.selector, FLAG_ARBITRUM_SEQ_OFFLINE);\\n\\n  address private s_l2FlagsAddress;\\n  IInbox private s_inbox;\\n  AccessControllerInterface private s_gasConfigAccessController;\\n  GasConfiguration private s_gasConfig;\\n\\n  /**\\n   * @notice emitted when a new gas configuration is set\\n   * @param maxSubmissionCost maximum cost willing to pay on L2\\n   * @param maxGasPrice maximum gas price to pay on L2\\n   * @param gasCostL2 value to send to L2 to cover gas fee\\n   * @param refundableAddress address where gas excess on L2 will be sent\\n   */\\n  event GasConfigurationSet(\\n    uint256 maxSubmissionCost,\\n    uint256 maxGasPrice,\\n    uint256 gasCostL2,\\n    uint256 gasLimitL2,\\n    address indexed refundableAddress\\n  );\\n\\n  /**\\n   * @notice emitted when a new gas access-control contract is set\\n   * @param previous the address prior to the current setting\\n   * @param current the address of the new access-control contract\\n   */\\n  event GasAccessControllerSet(\\n    address indexed previous,\\n    address indexed current\\n  );\\n\\n  /**\\n   * @param inboxAddress address of the Arbitrum Inbox L1 contract\\n   * @param l2FlagsAddress address of the Chainlink L2 Flags contract\\n   * @param gasConfigAccessControllerAddress address of the access controller for managing gas price on Arbitrum\\n   * @param maxSubmissionCost maximum cost willing to pay on L2\\n   * @param maxGasPrice maximum gas price to pay on L2\\n   * @param gasCostL2 value to send to L2 to cover gas fee\\n   * @param gasLimitL2 gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\\n   * @param refundableAddress address where gas excess on L2 will be sent\\n   */\\n  constructor(\\n    address inboxAddress,\\n    address l2FlagsAddress,\\n    address gasConfigAccessControllerAddress,\\n    uint256 maxSubmissionCost,\\n    uint256 maxGasPrice,\\n    uint256 gasCostL2,\\n    uint256 gasLimitL2,\\n    address refundableAddress\\n  ) {\\n    require(inboxAddress != address(0), \\\"Invalid Inbox contract address\\\");\\n    require(l2FlagsAddress != address(0), \\\"Invalid Flags contract address\\\");\\n    s_inbox = IInbox(inboxAddress);\\n    s_gasConfigAccessController = AccessControllerInterface(gasConfigAccessControllerAddress);\\n    s_l2FlagsAddress = l2FlagsAddress;\\n    _setGasConfiguration(maxSubmissionCost, maxGasPrice, gasCostL2, gasLimitL2, refundableAddress);\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - ArbitrumValidator 0.1.0: initial release\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion()\\n    external\\n    pure\\n    virtual\\n    override\\n    returns (\\n      string memory\\n    )\\n  {\\n    return \\\"ArbitrumValidator 0.1.0\\\";\\n  }\\n\\n  /// @return L2 Flags contract address\\n  function l2Flags()\\n    external\\n    view\\n    virtual\\n    returns (address)\\n  {\\n    return s_l2FlagsAddress;\\n  }\\n\\n  /// @return Arbitrum Inbox contract address\\n  function inbox()\\n    external\\n    view\\n    virtual\\n    returns (address)\\n  {\\n    return address(s_inbox);\\n  }\\n\\n  /// @return gas config AccessControllerInterface contract address\\n  function gasConfigAccessController()\\n    external\\n    view\\n    virtual\\n    returns (address)\\n  {\\n    return address(s_gasConfigAccessController);\\n  }\\n\\n  /// @return stored GasConfiguration\\n  function gasConfig()\\n    external\\n    view\\n    virtual\\n    returns (GasConfiguration memory)\\n  {\\n    return s_gasConfig;\\n  }\\n\\n  /// @notice makes this contract payable as it need funds to pay for L2 transactions fees on L1.\\n  receive() external payable {}\\n\\n  /**\\n   * @notice withdraws all funds availbale in this contract to the msg.sender\\n   * @dev only owner can call this\\n   */\\n  function withdrawFunds()\\n    external\\n    onlyOwner()\\n  {\\n    address payable to = payable(msg.sender);\\n    to.transfer(address(this).balance);\\n  }\\n\\n  /**\\n   * @notice withdraws all funds availbale in this contract to the address specified\\n   * @dev only owner can call this\\n   * @param to address where to send the funds\\n   */\\n  function withdrawFundsTo(\\n    address payable to\\n  ) \\n    external\\n    onlyOwner()\\n  {\\n    to.transfer(address(this).balance);\\n  }\\n\\n  /**\\n   * @notice sets gas config AccessControllerInterface contract\\n   * @dev only owner can call this\\n   * @param accessController new AccessControllerInterface contract address\\n   */\\n  function setGasAccessController(\\n    address accessController\\n  )\\n    external\\n    onlyOwner\\n  {\\n    _setGasAccessController(accessController);\\n  }\\n\\n  /**\\n   * @notice sets Arbitrum gas configuration\\n   * @dev access control provided by s_gasConfigAccessController\\n   * @param maxSubmissionCost maximum cost willing to pay on L2\\n   * @param maxGasPrice maximum gas price to pay on L2\\n   * @param gasCostL2 value to send to L2 to cover gas fee\\n   * @param gasLimitL2 gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\\n   * @param refundableAddress address where gas excess on L2 will be sent\\n   */\\n  function setGasConfiguration(\\n    uint256 maxSubmissionCost,\\n    uint256 maxGasPrice,\\n    uint256 gasCostL2,\\n    uint256 gasLimitL2,\\n    address refundableAddress\\n  )\\n    external\\n  {\\n    require(s_gasConfigAccessController.hasAccess(msg.sender, msg.data), \\\"Access required to set config\\\");\\n    _setGasConfiguration(maxSubmissionCost, maxGasPrice, gasCostL2, gasLimitL2, refundableAddress);\\n  }\\n\\n  /**\\n   * @notice validate method updates the state of an L2 Flag in case of change on the Arbitrum Sequencer.\\n   * A one answer considers the service as offline.\\n   * In case the previous answer is the same as the current it does not trigger any tx on L2. In other case,\\n   * a retryable ticket is created on the Arbitrum L1 Inbox contract. The tx gas fee can be paid from this\\n   * contract providing a value, or the same address on L2.\\n   * @dev access control provided internally by SimpleWriteAccessController\\n   * @param previousAnswer previous aggregator answer\\n   * @param currentAnswer new aggregator answer\\n   */\\n  function validate(\\n    uint256 /* previousRoundId */,\\n    int256 previousAnswer,\\n    uint256 /* currentRoundId */,\\n    int256 currentAnswer\\n  ) \\n    external\\n    override\\n    checkAccess()\\n    returns (bool)\\n  {\\n    // Avoids resending to L2 the same tx on every call\\n    if (previousAnswer == currentAnswer) {\\n      return true;\\n    }\\n\\n    int isServiceOffline = 1;\\n    // NOTICE: if gasCostL2 is zero the payment is processed on L2 so the L2 address needs to be funded, as it will\\n    // paying the fee. We also ignore the returned msg number, that can be queried via the InboxMessageDelivered event.\\n    s_inbox.createRetryableTicket{value: s_gasConfig.gasCostL2}(\\n      s_l2FlagsAddress,\\n      0, // L2 call value\\n      // NOTICE: maxSubmissionCost info will possibly become available on L1 after the London fork. At that time this\\n      // contract could start querying/calculating it directly so we wouldn't need to configure it statically. On L2 this\\n      // info is available via `ArbRetryableTx.getSubmissionPrice`.\\n      s_gasConfig.maxSubmissionCost, // Max submission cost of sending data length\\n      s_gasConfig.refundableAddress, // excessFeeRefundAddress\\n      s_gasConfig.refundableAddress, // callValueRefundAddress\\n      s_gasConfig.gasLimitL2,\\n      s_gasConfig.maxGasPrice,\\n      currentAnswer == isServiceOffline ? CALL_RAISE_FLAG : CALL_LOWER_FLAG\\n    );\\n    return true;\\n  }\\n\\n  function _setGasConfiguration(\\n    uint256 maxSubmissionCost,\\n    uint256 maxGasPrice,\\n    uint256 gasCostL2,\\n    uint256 gasLimitL2,\\n    address refundableAddress\\n  )\\n    internal\\n  {\\n    // L2 will pay the fee if gasCostL2 is zero\\n    if (gasCostL2 > 0) {\\n      uint256 minGasCostValue = maxSubmissionCost + gasLimitL2 * maxGasPrice;\\n      require(gasCostL2 >= minGasCostValue, \\\"Gas cost provided is too low\\\");\\n    }\\n    s_gasConfig = GasConfiguration(maxSubmissionCost, maxGasPrice, gasCostL2, gasLimitL2, refundableAddress);\\n    emit GasConfigurationSet(maxSubmissionCost, maxGasPrice, gasCostL2, gasLimitL2, refundableAddress);\\n  }\\n\\n  function _setGasAccessController(\\n    address accessController\\n  )\\n    internal\\n  {\\n    address previousAccessController = address(s_gasConfigAccessController);\\n    if (accessController != previousAccessController) {\\n      s_gasConfigAccessController = AccessControllerInterface(accessController);\\n      emit GasAccessControllerSet(previousAccessController, accessController);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma different from original (updated from `^0.6.11` -> `^0.8.6`)\\npragma solidity ^0.8.6;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IMessageProvider.sol\\\";\\n\\ninterface IInbox is IMessageProvider {\\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n    function sendUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        uint256 nonce,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        address destAddr,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function createRetryableTicket(\\n        address destAddr,\\n        uint256 arbTxCallValue,\\n        uint256 maxSubmissionCost,\\n        address submissionRefundAddress,\\n        address valueRefundAddress,\\n        uint256 maxGas,\\n        uint256 gasPriceBid,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function depositEth(address destAddr) external payable returns (uint256);\\n\\n    function depositEthRetryable(address destAddr, uint256 maxSubmissionCost, uint256 maxGas, uint256 maxGasPrice) external payable returns (uint256);\\n\\n    function bridge() external view returns (IBridge);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma different from original (updated from `^0.6.11` -> `^0.8.6`)\\npragma solidity ^0.8.6;\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    );\\n\\n    function deliverMessageToInbox(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function executeCall(\\n        address destAddr,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    // These are only callable by the admin\\n    function setInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    // View functions\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function messageCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IMessageProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma different from original (updated from `^0.6.11` -> `^0.8.6`)\\npragma solidity ^0.8.6;\\n\\ninterface IMessageProvider {\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/Flags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"./SimpleReadAccessController.sol\\\";\\nimport \\\"./interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\n\\n\\n/**\\n * @title The Flags contract\\n * @notice Allows flags to signal to any reader on the access control list.\\n * The owner can set flags, or designate other addresses to set flags. The\\n * owner must turn the flags off, other setters cannot. An expected pattern is\\n * to allow addresses to raise flags on themselves, so if you are subscribing to\\n * FlagOn events you should filter for addresses you care about.\\n */\\ncontract Flags is FlagsInterface, SimpleReadAccessController {\\n\\n  AccessControllerInterface public raisingAccessController;\\n\\n  mapping(address => bool) private flags;\\n\\n  event FlagRaised(\\n    address indexed subject\\n  );\\n  event FlagLowered(\\n    address indexed subject\\n  );\\n  event RaisingAccessControllerUpdated(\\n    address indexed previous,\\n    address indexed current\\n  );\\n\\n  /**\\n   * @param racAddress address for the raising access controller.\\n   */\\n  constructor(\\n    address racAddress\\n  ) {\\n    setRaisingAccessController(racAddress);\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subject The contract address being checked for a flag.\\n   * @return A true value indicates that a flag was raised and a\\n   * false value indicates that no flag was raised.\\n   */\\n  function getFlag(address subject)\\n    external\\n    view\\n    override\\n    checkAccess()\\n    returns (bool)\\n  {\\n    return flags[subject];\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subjects An array of addresses being checked for a flag.\\n   * @return An array of bools where a true value for any flag indicates that\\n   * a flag was raised and a false value indicates that no flag was raised.\\n   */\\n  function getFlags(address[] calldata subjects)\\n    external\\n    view\\n    override\\n    checkAccess()\\n    returns (bool[] memory)\\n  {\\n    bool[] memory responses = new bool[](subjects.length);\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      responses[i] = flags[subjects[i]];\\n    }\\n    return responses;\\n  }\\n\\n  /**\\n   * @notice enable the warning flag for an address.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subject The contract address whose flag is being raised\\n   */\\n  function raiseFlag(address subject)\\n    external\\n    override\\n  {\\n    require(allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    tryToRaiseFlag(subject);\\n  }\\n\\n  /**\\n   * @notice enable the warning flags for multiple addresses.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subjects List of the contract addresses whose flag is being raised\\n   */\\n  function raiseFlags(address[] calldata subjects)\\n    external\\n    override\\n  {\\n    require(allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      tryToRaiseFlag(subjects[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to disable the warning flags for multiple addresses.\\n   * @param subjects List of the contract addresses whose flag is being lowered\\n   */\\n  function lowerFlags(address[] calldata subjects)\\n    external\\n    override\\n    onlyOwner()\\n  {\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      address subject = subjects[i];\\n\\n      if (flags[subject]) {\\n        flags[subject] = false;\\n        emit FlagLowered(subject);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to change the access controller for raising flags.\\n   * @param racAddress new address for the raising access controller.\\n   */\\n  function setRaisingAccessController(\\n    address racAddress\\n  )\\n    public\\n    override\\n    onlyOwner()\\n  {\\n    address previous = address(raisingAccessController);\\n\\n    if (previous != racAddress) {\\n      raisingAccessController = AccessControllerInterface(racAddress);\\n\\n      emit RaisingAccessControllerUpdated(previous, racAddress);\\n    }\\n  }\\n\\n\\n  // PRIVATE\\n\\n  function allowedToRaiseFlags()\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return msg.sender == owner() ||\\n      raisingAccessController.hasAccess(msg.sender, msg.data);\\n  }\\n\\n  function tryToRaiseFlag(address subject)\\n    private\\n  {\\n    if (!flags[subject]) {\\n      flags[subject] = true;\\n      emit FlagRaised(subject);\\n    }\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/FlagsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface FlagsInterface {\\n  function getFlag(address) external view returns (bool);\\n  function getFlags(address[] calldata) external view returns (bool[] memory);\\n  function raiseFlag(address) external;\\n  function raiseFlags(address[] calldata) external;\\n  function lowerFlags(address[] calldata) external;\\n  function setRaisingAccessController(address) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/tests/FlagsTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Flags.sol\\\";\\n\\ncontract FlagsTestHelper {\\n  Flags public flags;\\n\\n  constructor(\\n    address flagsContract\\n  ) {\\n    flags = Flags(flagsContract);\\n  }\\n\\n  function getFlag(\\n    address subject\\n  )\\n    external\\n    view\\n    returns(bool)\\n  {\\n    return flags.getFlag(subject);\\n  }\\n\\n  function getFlags(\\n    address[] calldata subjects\\n  )\\n    external\\n    view\\n    returns(bool[] memory)\\n  {\\n    return flags.getFlags(subjects);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"src/v0.8/mocks/MockAggregatorValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\n\\ncontract MockAggregatorValidator is AggregatorValidatorInterface {\\n  \\n  uint8 immutable id;\\n\\n  constructor(uint8 id_) {\\n    id = id_;\\n  }\\n\\n  event ValidateCalled(\\n    uint8 id,\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  );\\n  \\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  )\\n    external\\n    override\\n    returns (\\n      bool\\n    )\\n  {\\n    emit ValidateCalled(id, previousRoundId, previousAnswer, currentRoundId, currentAnswer);\\n    return true;\\n  }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inboxAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2FlagsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gasConfigAccessControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasCostL2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimitL2\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refundableAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"GasAccessControllerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasCostL2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasLimitL2\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refundableAddress\",\"type\":\"address\"}],\"name\":\"GasConfigurationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RemovedAccess\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasCostL2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimitL2\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refundableAddress\",\"type\":\"address\"}],\"internalType\":\"struct ArbitrumValidator.GasConfiguration\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasConfigAccessController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"hasAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2Flags\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accessController\",\"type\":\"address\"}],\"name\":\"setGasAccessController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasCostL2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimitL2\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refundableAddress\",\"type\":\"address\"}],\"name\":\"setGasConfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"previousAnswer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"currentAnswer\",\"type\":\"int256\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawFundsTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ArbitrumValidator","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"000000000000000000000000578bade599406a8fe3d24fd7f7211c0911f5b29e0000000000000000000000003c14e07edd0dc67442fa96f1ec6999c57e810a830000000000000000000000002be843e2a5907fff0b7c9337b5058617bfec2bfe00000000000000000000000000000000000000000000000000000009c639f77d00000000000000000000000000000000000000000000000000000000215261ee00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001312d0000000000000000000000000029cd92f343f9d81e74fae28913b038a81005b46f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}