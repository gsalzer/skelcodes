{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/InterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport './libraries/WadRayMath.sol';\\n\\nimport './interfaces/IInterestRateModel.sol';\\n\\nimport './InterestRateModelStorage.sol';\\n\\n/**\\n * @title ELYFI InterestRateModel\\n * @author ELYSIA\\n * @notice Interest rates model in ELYFI. ELYFI's interest rates are determined by algorithms.\\n * When borrowing demand increases, borrowing interest and MoneyPool ROI increase,\\n * suppressing excessove borrowing demand and inducing depositors to supply liquidity.\\n * Therefore, ELYFI's interest rates are influenced by the Money Pool `utilizationRatio`.\\n * The Money Pool utilization ratio is a variable representing the current borrowing\\n * and deposit status of the Money Pool. The interest rates of ELYFI exhibits some form of kink.\\n * They sharply change at some defined threshold, `optimalUtilazationRate`.\\n */\\ncontract InterestRateModel is IInterestRateModel, InterestRateModelStorage {\\n  using WadRayMath for uint256;\\n\\n  /**\\n   * @param optimalUtilizationRate When the MoneyPool utilization ratio exceeds this parameter,\\n   * `optimalUtilizationRate`, the kinked rates model adjusts interests.\\n   * @param borrowRateBase The base interest rate.\\n   * @param borrowRateOptimal Interest rate when the Money Pool utilization ratio is optimal\\n   * @param borrowRateMax Interest rate when the Money Pool utilization ratio is 1\\n   */\\n  constructor(\\n    uint256 optimalUtilizationRate,\\n    uint256 borrowRateBase,\\n    uint256 borrowRateOptimal,\\n    uint256 borrowRateMax\\n  ) {\\n    _optimalUtilizationRate = optimalUtilizationRate;\\n    _borrowRateBase = borrowRateBase;\\n    _borrowRateOptimal = borrowRateOptimal;\\n    _borrowRateMax = borrowRateMax;\\n  }\\n\\n  struct calculateRatesLocalVars {\\n    uint256 totalDebt;\\n    uint256 utilizationRate;\\n    uint256 newBorrowAPY;\\n    uint256 newDepositAPY;\\n  }\\n\\n  /**\\n   * @notice Calculates the interest rates.\\n   * @dev\\n   * Calculation Example\\n   * Case1: under optimal U\\n   * baseRate = 2%, util = 40%, optimalRate = 10%, optimalUtil = 80%\\n   * result = 2+40*(10-2)/80 = 4%\\n   * Case2: over optimal U\\n   * optimalRate = 10%, util = 90%, maxRate = 100%, optimalUtil = 80%\\n   * result = 10+(90-80)*(100-10)/(100-80) = 55%\\n   * @param lTokenAssetBalance Total deposit amount\\n   * @param totalDTokenBalance total loan amount\\n   * @param depositAmount The liquidity added during the operation\\n   * @param borrowAmount The liquidity taken during the operation\\n   */\\n  function calculateRates(\\n    uint256 lTokenAssetBalance,\\n    uint256 totalDTokenBalance,\\n    uint256 depositAmount,\\n    uint256 borrowAmount,\\n    uint256 moneyPoolFactor\\n  ) public view override returns (uint256, uint256) {\\n    calculateRatesLocalVars memory vars;\\n    moneyPoolFactor;\\n\\n    vars.totalDebt = totalDTokenBalance;\\n\\n    uint256 availableLiquidity = lTokenAssetBalance + depositAmount - borrowAmount;\\n\\n    vars.utilizationRate = vars.totalDebt == 0\\n      ? 0\\n      : vars.totalDebt.rayDiv(availableLiquidity + vars.totalDebt);\\n\\n    vars.newBorrowAPY = 0;\\n\\n    if (vars.utilizationRate <= _optimalUtilizationRate) {\\n      vars.newBorrowAPY =\\n        _borrowRateBase +\\n        (\\n          (_borrowRateOptimal - _borrowRateBase).rayDiv(_optimalUtilizationRate).rayMul(\\n            vars.utilizationRate\\n          )\\n        );\\n    } else {\\n      vars.newBorrowAPY =\\n        _borrowRateOptimal +\\n        (\\n          (_borrowRateMax - _borrowRateOptimal)\\n          .rayDiv(WadRayMath.ray() - _optimalUtilizationRate)\\n          .rayMul(vars.utilizationRate - _borrowRateOptimal)\\n        );\\n    }\\n\\n    vars.newDepositAPY = vars.newBorrowAPY.rayMul(vars.utilizationRate);\\n\\n    return (vars.newBorrowAPY, vars.newDepositAPY);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/InterestRateModelStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\n/**\\n * @title ELYFI InterestRateModel\\n * @author ELYSIA\\n */\\ncontract InterestRateModelStorage {\\n  uint256 internal _optimalUtilizationRate;\\n\\n  uint256 internal _borrowRateBase;\\n\\n  uint256 internal _borrowRateOptimal;\\n\\n  uint256 internal _borrowRateMax;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport '../libraries/DataStruct.sol';\\n\\ninterface IInterestRateModel {\\n  function calculateRates(\\n    uint256 lTokenAssetBalance,\\n    uint256 totalDTokenBalance,\\n    uint256 depositAmount,\\n    uint256 borrowAmount,\\n    uint256 moneyPoolFactor\\n  ) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DataStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nlibrary DataStruct {\\n  /**\\n    @notice The main reserve data struct.\\n   */\\n  struct ReserveData {\\n    uint256 moneyPoolFactor;\\n    uint256 lTokenInterestIndex;\\n    uint256 borrowAPY;\\n    uint256 depositAPY;\\n    uint256 lastUpdateTimestamp;\\n    address lTokenAddress;\\n    address dTokenAddress;\\n    address interestModelAddress;\\n    address tokenizerAddress;\\n    uint8 id;\\n    bool isPaused;\\n    bool isActivated;\\n  }\\n\\n  /**\\n   * @notice The asset bond data struct.\\n   * @param ipfsHash The IPFS hash that contains the informations and contracts\\n   * between Collateral Service Provider and lender.\\n   * @param maturityTimestamp The amount of time measured in seconds that can elapse\\n   * before the NPL company liquidate the loan and seize the asset bond collateral.\\n   * @param borrower The address of the borrower.\\n   */\\n  struct AssetBondData {\\n    AssetBondState state;\\n    address borrower;\\n    address signer;\\n    address collateralServiceProvider;\\n    uint256 principal;\\n    uint256 debtCeiling;\\n    uint256 couponRate;\\n    uint256 interestRate;\\n    uint256 delinquencyRate;\\n    uint256 loanStartTimestamp;\\n    uint256 collateralizeTimestamp;\\n    uint256 maturityTimestamp;\\n    uint256 liquidationTimestamp;\\n    string ipfsHash; // refactor : gas\\n    string signerOpinionHash;\\n  }\\n\\n  struct AssetBondIdData {\\n    uint256 nonce;\\n    uint256 countryCode;\\n    uint256 collateralServiceProviderIdentificationNumber;\\n    uint256 collateralLatitude;\\n    uint256 collateralLatitudeSign;\\n    uint256 collateralLongitude;\\n    uint256 collateralLongitudeSign;\\n    uint256 collateralDetail;\\n    uint256 collateralCategory;\\n    uint256 productNumber;\\n  }\\n\\n  /**\\n    @notice The states of asset bond\\n    * EMPTY: After\\n    * SETTLED:\\n    * CONFIRMED:\\n    * COLLATERALIZED:\\n    * DELINQUENT:\\n    * REDEEMED:\\n    * LIQUIDATED:\\n   */\\n  enum AssetBondState {\\n    EMPTY,\\n    SETTLED,\\n    CONFIRMED,\\n    COLLATERALIZED,\\n    DELINQUENT,\\n    REDEEMED,\\n    LIQUIDATED\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant halfWAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return halfRAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return halfWAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfWAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (a * b + halfRAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Division by Zero');\\n    uint256 halfB = b / 2;\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n    return result;\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optimalUtilizationRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateOptimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateMax\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lTokenAssetBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"moneyPoolFactor\",\"type\":\"uint256\"}],\"name\":\"calculateRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"InterestRateModel","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"0000000000000000000000000000000000000000026c62ad77dc602dae000000000000000000000000000000000000000000000000295be96e6406697200000000000000000000000000000000000000000000000031a17e847807b1bc0000000000000000000000000000000000000000000000033b2e3c9fd0803ce8000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}